




@java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb open() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = delegate.open(); if (migration.readChanges()) { if (migration.disableChangeReviewDb()) { db = new com.google.gerrit.server.schema.NoChangesReviewDbWrapper(db); } db = new com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper(db); } if (groupsMigration.readFromNoteDb()) { db = new com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper(db); } return db; }
static java.lang.String getGroupName(com.google.gerrit.server.account.GroupCache groupCache, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { return groupCache.get(groupUuid).map(InternalGroup::getName).map(( name) -> formatNameEmail(name, groupUuid.get())).orElse(groupUuid.get()); }

@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(MonitoringCapability.ID)).to(com.googlesource.gerrit.plugins.javamelody.MonitoringCapability.class); if (cfg.getBoolean("allowTopMenu", true)) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.javamelody.MonitoringTopMenu.class); } }




@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.DELETE, true, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); com.google.gerrit.server.group.InternalGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null); assertThat(adminGroup).isNotNull(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroup.getGroupUUID()); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains("Not allowed to delete group branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNotNull(); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if ((receiveEvent.command.getRefName().startsWith(RefNames.REFS_GROUPS)) || (receiveEvent.command.getRefName().equals(RefNames.REFS_GROUPNAMES))) { throw new com.google.gerrit.server.git.validators.CommitValidationException("group update not allowed"); } return java.util.Collections.emptyList(); }

@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || ((!(destBranch.get().startsWith(RefNames.REFS_GROUPS))) && (!(destBranch.get().equals(RefNames.REFS_GROUPNAMES))))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException("group update not allowed"); }

@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = util.commit(util.tree(util.file("groups", util.blob(com.google.gerrit.server.git.ProjectConfigTest.group(developers))), util.file("project.config", util.blob(((("" + ("[plugin \"somePlugin\"]\n" + "key1 = ")) + (staff.toConfigValue())) + "\n"))))); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationErrors()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()).isEqualTo(((("project.config: group \"" + (staff.getName())) + "\" not in ") + (GroupList.FILE_NAME))); }
@org.junit.Test public void readConfigLabelScores() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = util.commit(util.tree(util.file("groups", util.blob(com.google.gerrit.server.git.ProjectConfigTest.group(developers))), util.file("project.config", util.blob((("" + "[label \"CustomLabel\"]\n") + (com.google.gerrit.server.git.ProjectConfigTest.LABEL_SCORES_CONFIG)))))); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> labels = cfg.getLabelSections(); com.google.gerrit.common.data.LabelType type = labels.entrySet().iterator().next().getValue(); assertThat(type.isCopyMinScore()).isNotEqualTo(LabelType.DEF_COPY_MIN_SCORE); assertThat(type.isCopyMaxScore()).isNotEqualTo(LabelType.DEF_COPY_MAX_SCORE); assertThat(type.isCopyAllScoresOnMergeFirstParentUpdate()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE); assertThat(type.isCopyAllScoresOnTrivialRebase()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE); assertThat(type.isCopyAllScoresIfNoCodeChange()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE); assertThat(type.isCopyAllScoresIfNoChange()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE); }
@org.junit.Test public void editPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = util.commit(util.tree(util.file("groups", util.blob(com.google.gerrit.server.git.ProjectConfigTest.group(developers))), util.file("project.config", util.blob(((("" + ("[plugin \"somePlugin\"]\n" + "key1 = ")) + (developers.toConfigValue())) + "\n"))))); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginCfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(developers); pluginCfg.setGroupReference("key1", staff); rev = commit(cfg); assertThat(text(rev, "project.config")).isEqualTo(((("" + ("[plugin \"somePlugin\"]\n" + "\tkey1 = ")) + (staff.toConfigValue())) + "\n")); assertThat(text(rev, "groups")).isEqualTo(((((("# UUID\tGroup Name\n" + "#\n") + (staff.getUUID().get())) + " \t") + (staff.getName())) + "\n")); }
@org.junit.Test public void readPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = util.commit(util.tree(util.file("groups", util.blob(com.google.gerrit.server.git.ProjectConfigTest.group(developers))), util.file("project.config", util.blob(((("" + ("[plugin \"somePlugin\"]\n" + "key1 = ")) + (developers.toConfigValue())) + "\n"))))); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginCfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(developers); }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = java.nio.file.Paths.get(java.lang.System.getProperty("java.io.tmpdir")).resolve(com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.JAVAMELODY_PREFIX); if (java.nio.file.Files.isDirectory(tmp)) { return tmp.toString(); } if (!(java.nio.file.Files.isDirectory(defaultDataDir))) { try { java.nio.file.Files.createDirectories(defaultDataDir); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.log.error("Creation of javamelody data dir [{}] failed.", defaultDataDir, e); throw new java.lang.RuntimeException(e); } } return defaultDataDir.toString(); }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo apply(com.google.gerrit.server.config.ConfigResource resource, com.google.gerrit.extensions.api.config.ConsistencyCheckInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE); if ((input == null) || (((input.checkAccounts) == null) && ((input.checkAccountExternalIds) == null))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("input required"); } com.google.gerrit.extensions.api.config.ConsistencyCheckInfo consistencyCheckInfo = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(); if ((input.checkAccounts) != null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountsResultInfo(accountsConsistencyChecker.check()); } if ((input.checkAccountExternalIds) != null) { consistencyCheckInfo.checkAccountExternalIdsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountExternalIdsResultInfo(externalIdsConsistencyChecker.check()); } return consistencyCheckInfo; }


private static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM); java.lang.String name = config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM); if ((uuid == null) || (name == null)) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("UUID '%s' and name '%s' must be defined", uuid, name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }





private boolean processAccount(com.google.gerrit.server.account.AccountState account) { com.google.gerrit.server.account.AccountDeactivator.log.debug(("processing account " + (account.getUserName()))); try { if (((account.getUserName()) != null) && (!(realm.isActive(account.getUserName())))) { sif.deactivate(account.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivator.log.info(("deactivated account " + (account.getUserName()))); return true; } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { com.google.gerrit.server.account.AccountDeactivator.log.info("Account {} already deactivated, continuing...", account.getUserName()); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error("Error deactivating account: {} ({}) {}", account.getUserName(), account.getAccount().getId(), e.getMessage(), e); } return false; }





public java.lang.String getName(java.lang.String anonymousCowardName) { if ((fullName) != null) { return fullName; } if ((preferredEmail) != null) { return preferredEmail; } return getNameEmail(anonymousCowardName); }
private static org.eclipse.jgit.lib.PersonIdent ident(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String anonymousCowardName, com.google.gerrit.server.CurrentUser u, java.util.Date when) { com.google.gerrit.server.notedb.AbstractChangeUpdate.checkUserType(u); if (u instanceof com.google.gerrit.server.IdentifiedUser) { return noteUtil.newIdent(u.asIdentifiedUser().getAccount(), when, serverIdent, anonymousCowardName); } else if (u instanceof com.google.gerrit.server.InternalUser) { return serverIdent; } throw new java.lang.IllegalStateException(); }

public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(groupsMigration.writeToNoteDb())) { return new java.util.ArrayList<>(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return check(repo); } }
@com.google.gerrit.common.Nullable public com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result check(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { if (!(groupsMigration.writeToNoteDb())) { return null; } com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result r = doCheck(repo); if (!(r.problems.isEmpty())) { r.uuidToGroupMap = null; } return r; }


@org.junit.Before public void setUp() throws java.lang.Exception { servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet(tempFolder.getRoot().toPath()); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setUnhealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error("Failed to set unhealthy", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setHealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error("Failed to set healthy", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }
private void sendError(javax.servlet.http.HttpServletResponse rsp, int statusCode) { try { rsp.sendError(statusCode); } catch (java.io.IOException e) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error("Failed to send error response", e); } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (unhealthyFile.exists()) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_SERVICE_UNAVAILABLE); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }

private static int getInt(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, int defaultValue) { try { return cfg.getInt(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error(java.lang.String.format("invalid value for %s; using default value %d", name, defaultValue)); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve integer value: " + (e.getMessage())), e); return defaultValue; } }
private static boolean getBoolean(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, boolean defaultValue) { try { return cfg.getBoolean(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error(java.lang.String.format("invalid value for %s; using default value %s", name, defaultValue)); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve boolean value: " + (e.getMessage())), e); return defaultValue; } }
private void evictCache(com.google.common.cache.Cache<?, ?> cache, java.lang.String cacheName, java.lang.Object key) { if (Constants.PROJECT_LIST.equals(cacheName)) { cache.invalidateAll(); } else { cache.invalidate(key); } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug("Invalidated {}", cacheName); }
public java.lang.String[] getIssueIds(java.lang.String haystack) { java.util.regex.Pattern pattern = itsConfig.getIssuePattern(); if (pattern == null) return new java.lang.String[]{ }; com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.log.debug(((("Matching '" + haystack) + "' against ") + (pattern.pattern()))); java.util.Set<java.lang.String> issues = com.google.common.collect.Sets.newHashSet(); java.util.regex.Matcher matcher = pattern.matcher(haystack); int groupIdx = itsConfig.getIssuePatternGroupIndex(); while (matcher.find()) { java.lang.String issueId = matcher.group(groupIdx); if (!(com.google.common.base.Strings.isNullOrEmpty(issueId))) { issues.add(issueId); } } return issues.toArray(new java.lang.String[issues.size()]); }
public boolean isEnabled(com.google.gerrit.reviewdb.client.Project.NameKey projectNK, java.lang.String refName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectNK); if (projectState == null) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig.log.error((((((("Failed to check if " + (pluginName)) + " is enabled for project ") + (projectNK.get())) + ": Project ") + (projectNK.get())) + " not found")); return false; } if (isEnforcedByAnyParentProject(refName, projectState)) { return true; } return (!("false".equals(pluginCfgFactory.getFromProjectConfigWithInheritance(projectState, pluginName).getString("enabled", "false")))) && (isEnabledForBranch(projectState, refName)); }

private java.lang.String getCommentChangeEvent(java.lang.String action, java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = ""; java.lang.String changeNumber = com.google.common.base.Strings.nullToEmpty(map.get("change-number")); changeNumber = com.google.common.base.Strings.nullToEmpty(map.get("changeNumber")); if (!(changeNumber.isEmpty())) { changeNumber += " "; } ret += ("Change " + changeNumber) + action; java.lang.String submitter = formatPerson(prefix, map); if (!(submitter.isEmpty())) { ret += " by " + submitter; } java.lang.String subject = com.google.common.base.Strings.nullToEmpty(map.get("subject")); if (!(subject.isEmpty())) { ret += ":\n" + subject; } java.lang.String reason = com.google.common.base.Strings.nullToEmpty(map.get("reason")); if (!(reason.isEmpty())) { ret += "\n\nReason:\n" + reason; } java.lang.String url = com.google.common.base.Strings.nullToEmpty(map.get("change-url")); url = com.google.common.base.Strings.nullToEmpty(map.get("changeUrl")); if (!(url.isEmpty())) { ret += "\n\n" + (its.createLinkForWebui(url, url)); } return ret; }
private java.lang.String formatPerson(java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "-name"))); ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Name"))); if (ret.isEmpty()) { ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "-username"))); ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Username"))); } return ret; }
static java.lang.String getOwnersFileName(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.query.change.ChangeData c) { if (((com.googlesource.gerrit.plugins.findowners.Config.config) != null) && (project != null)) { try { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS); if (name.trim().equals("")) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((((((("Project " + project) + " has wrong ") + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) + ": \"") + name) + "\" for ") + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(c)))); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((("Cannot find project " + project) + " for ") + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(c))), e); } } return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; }
private boolean shouldReplicate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { return shouldReplicate(project); } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
public java.util.regex.Pattern getIssuePattern() { java.util.Optional<java.lang.String> match = HEAD(bb16a6); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("patchSetNumber", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("createdOn", patchSetAttribute.createdOn.toString())); HEAD(bb16a6); }
public static com.google.common.collect.ImmutableList<java.lang.String> compare(com.google.gerrit.server.group.db.GroupBundle reviewDbBundle, com.google.gerrit.server.group.db.GroupBundle noteDbBundle) { reviewDbBundle = reviewDbBundle.truncateToSecond(); com.google.gerrit.reviewdb.client.AccountGroup reviewDbGroup = new com.google.gerrit.reviewdb.client.AccountGroup(reviewDbBundle.group()); reviewDbGroup.setDescription(com.google.common.base.Strings.emptyToNull(reviewDbGroup.getDescription())); reviewDbBundle = reviewDbBundle.toBuilder().group(reviewDbGroup).build(); checkArgument(((reviewDbBundle.source()) == (com.google.gerrit.server.group.db.GroupBundle.Source.REVIEW_DB)), "first bundle's source must be %s: %s", com.google.gerrit.server.group.db.GroupBundle.Source.REVIEW_DB, reviewDbBundle); checkArgument(((noteDbBundle.source()) == (com.google.gerrit.server.group.db.GroupBundle.Source.NOTE_DB)), "second bundle's source must be %s: %s", com.google.gerrit.server.group.db.GroupBundle.Source.NOTE_DB, noteDbBundle); com.google.common.collect.ImmutableList.Builder<java.lang.String> result = com.google.common.collect.ImmutableList.builder(); if (!(reviewDbBundle.group().equals(noteDbBundle.group()))) { result.add((("AccountGroups differ\n" + (("ReviewDb: " + (reviewDbBundle.group())) + "\n")) + ("NoteDb : " + (noteDbBundle.group())))); } if (!(reviewDbBundle.members().equals(noteDbBundle.members()))) { result.add((("AccountGroupMembers differ\n" + (("ReviewDb: " + (reviewDbBundle.members())) + "\n")) + ("NoteDb : " + (noteDbBundle.members())))); } if (!(com.google.gerrit.server.group.db.GroupBundle.areMemberAuditsConsideredEqual(reviewDbBundle.memberAudit(), noteDbBundle.memberAudit()))) { result.add((("AccountGroupMemberAudits differ\n" + (("ReviewDb: " + (reviewDbBundle.memberAudit())) + "\n")) + ("NoteDb : " + (noteDbBundle.memberAudit())))); } if (!(reviewDbBundle.byId().equals(noteDbBundle.byId()))) { result.add((("AccountGroupByIds differ\n" + (("ReviewDb: " + (reviewDbBundle.byId())) + "\n")) + ("NoteDb : " + (noteDbBundle.byId())))); } if (!(com.google.gerrit.server.group.db.GroupBundle.areByIdAuditsConsideredEqual(reviewDbBundle.byIdAudit(), noteDbBundle.byIdAudit()))) { result.add((("AccountGroupByIdAudits differ\n" + (("ReviewDb: " + (reviewDbBundle.byIdAudit())) + "\n")) + ("NoteDb : " + (noteDbBundle.byIdAudit())))); } return result.build(); }



@java.lang.Override public org.junit.runners.model.Statement apply(org.junit.runners.model.Statement base, org.junit.runner.Description description) { return new org.junit.runners.model.Statement() { @java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); try { base.evaluate(); } finally { afterTest(); } } }; }

@java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); try { base.evaluate(); } finally { afterTest(); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPNAMES); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.common.data.GroupReference> groupReferences = com.google.common.collect.ImmutableSet.builder(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.common.data.GroupReference groupReference = com.google.gerrit.server.group.db.GroupNameNotes.getGroupReference(reader, note.getData()); groupReferences.add(groupReference); } return groupReferences.build(); } }
public static com.google.gerrit.server.group.db.GroupConfig createForNewGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupCreation.getGroupUUID()); groupConfig.load(repository); groupConfig.setGroupCreation(groupCreation); return groupConfig; }
public static com.google.gerrit.server.group.db.GroupConfig loadForGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupUuid); groupConfig.load(repository); return groupConfig; }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> getLoadedGroup() { checkLoaded(); return loadedGroup; }
public static com.google.gerrit.server.group.db.GroupConfig loadForGroupSnapshot(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, org.eclipse.jgit.lib.ObjectId commitId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupUuid); groupConfig.load(repository, commitId); return groupConfig; }
private java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> loadGroup(com.google.gerrit.common.data.GroupReference groupReference) { return groupCache.get(groupReference.getUUID()).map(InternalGroupDescription::new); }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("You should only have no more than one --project and -n with --suggest"); } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().orElse(null)), ((limit) <= 0 ? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupRefs.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic desc = groupBackend.get(ref.getUUID()); if (desc != null) { groupInfos.add(json.addOptions(options).format(desc)); } } return groupInfos; }
int findApproval(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Emails emails) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExemptFromOwnerApproval(changeData)) { return 0; } com.googlesource.gerrit.plugins.findowners.OwnersDb db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(projectState, accountCache, emails, repository, changeData); if ((db.getNumOwners()) <= 0) { return 0; } if ((minVoteLevel) <= 0) { minVoteLevel = com.googlesource.gerrit.plugins.findowners.Config.getMinOwnerVoteLevel(changeData); } com.googlesource.gerrit.plugins.findowners.Checker.log.trace(("findApproval db key = " + (db.key))); return findApproval(accountCache, db); }
static int getMinOwnerVoteLevel(com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change().getProject(); try { return ((com.googlesource.gerrit.plugins.findowners.Config.config) == null) || (project == null) ? com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteLevel : com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_LEVEL, com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteLevel); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((("Cannot find project " + project) + " for ") + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(changeData))), e); return com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteLevel; } }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.WebLinks links) throws java.io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); boolean canDelete = perm.testOrFalse(RefPermission.DELETE); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (tagger != null ? com.google.gerrit.server.CommonConverters.toGitPerson(tag.getTaggerIdent()) : null), canDelete, (webLinks.isEmpty() ? null : webLinks)); } return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, (webLinks.isEmpty() ? null : webLinks)); }
@org.junit.Test public void lightweightTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/heads/master"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInput input = new com.google.gerrit.extensions.api.projects.TagInput(); input.ref = "v1.0"; input.revision = r.getCommit().getName(); com.google.gerrit.extensions.api.projects.TagInfo result = tag(input.ref).create(input).get(); assertThat(result.ref).isEqualTo(((R_TAGS) + (input.ref))); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.canDelete).isTrue(); input.ref = "refs/tags/v2.0"; result = tag(input.ref).create(input).get(); assertThat(result.ref).isEqualTo(input.ref); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.canDelete).isTrue(); setApiUser(user); result = tag(input.ref).get(); assertThat(result.canDelete).isFalse(); eventRecorder.assertRefUpdatedEvents(project.get(), result.ref, null, result.revision); }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.account = checkNotNull(account); this.registeredOn = account.getRegisteredOn(); }
@com.google.gerrit.common.Nullable public com.google.gerrit.reviewdb.client.Account getAccount() { checkLoaded(); return account; }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision) != null) { rw.reset(); rw.markStart(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); account = parse(cfg); account.setMetaId(revision.name()); } isLoaded = true; }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Key, com.google.gerrit.server.notedb.ChangeNotes> openChangesByBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.Change.Key, com.google.gerrit.server.notedb.ChangeNotes> r = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchOpen(branch)) { r.put(cd.change().getKey(), cd.notes()); } return r; }

@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (healthy) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); } else { try { rsp.sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_SERVICE_UNAVAILABLE); } catch (java.io.IOException e) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error("Failed to send error response", e); } } }

@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { this.healthy = true; rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }
@org.junit.Before public void setUp() throws java.lang.Exception { servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet(); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { this.healthy = false; rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert(@com.google.gerrit.common.Nullable java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getPureRevert.setClaimedOriginal(claimedOriginal).apply(change); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot compute pure revert", e); } }
@com.google.gerrit.common.Nullable public java.lang.Boolean isPureRevert() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getPureRevert(notes()).isPureRevert; } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new com.google.gwtorm.server.OrmException("could not compute pure revert", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet currentPatchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); if (currentPatchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } return getPureRevert(rsrc.getNotes()); }
private void setUp() throws java.lang.Exception { injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testing.InMemoryModule()); injector.injectMembers(this); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); lifecycle.start(); try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); setApiUser(accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId()); }
@org.junit.Test public void testErrorDuringTransitionToUnhealty() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); }



public void connect() { try { channel = new org.jgroups.JChannel(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { channel.getProtocolStack().getTransport().setBindAddress(address.get()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.debug("Channel bound to {}", address.get()); } else { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.warn("Channel not bound: address not present"); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("Channel {} successfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName()); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e); } }
protected void setUseSignedOffBy(com.google.gerrit.extensions.client.InheritableBoolean value) throws java.lang.Exception { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.getProject().setUseSignedOffBy(value); config.commit(md); projectCache.evict(config.getProject()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(state.isUseSignedOffBy())) { return java.util.Collections.emptyList(); } org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); org.eclipse.jgit.lib.PersonIdent author = commit.getAuthorIdent(); boolean sboAuthor = false; boolean sboCommitter = false; boolean sboMe = false; for (org.eclipse.jgit.revwalk.FooterLine footer : commit.getFooterLines()) { if (footer.matches(FooterKey.SIGNED_OFF_BY)) { java.lang.String e = footer.getEmailAddress(); if (e != null) { sboAuthor |= author.getEmailAddress().equals(e); sboCommitter |= committer.getEmailAddress().equals(e); sboMe |= user.hasEmailAddress(e); } } } if (((!sboAuthor) && (!sboCommitter)) && (!sboMe)) { try { perm.check(RefPermission.FORGE_COMMITTER); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.server.git.validators.CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer"); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.validators.CommitValidators.log.error("cannot check FORGE_COMMITTER", e); throw new com.google.gerrit.server.git.validators.CommitValidationException("internal auth error"); } } return java.util.Collections.emptyList(); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case READ_PRIVATE_CHANGES : return canViewPrivateChanges(); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().isUseSignedOffBy())); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@org.junit.Test public void createProjectWithProperties() throws java.lang.Exception { java.lang.String newProjectName = name("newProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = newProjectName; in.description = "Test description"; in.submitType = com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useSignedOffBy = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.requireChangeId = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects().create(in).get(); assertThat(p.name).isEqualTo(newProjectName); com.google.gerrit.reviewdb.client.Project project = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newProjectName)).getProject(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertThat(project.getDescription()).isEqualTo(in.description); assertThat(project.getSubmitType()).isEqualTo(in.submitType); assertThat(project.getUseContributorAgreements()).isEqualTo(in.useContributorAgreements); assertThat(project.getUseSignedOffBy()).isEqualTo(in.useSignedOffBy); assertThat(project.getUseContentMerge()).isEqualTo(in.useContentMerge); assertThat(project.getRequireChangeID()).isEqualTo(in.requireChangeId); }

private java.util.Set<com.google.gerrit.reviewdb.client.Account> scanAccounts(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.ProgressMonitor pm) throws java.sql.SQLException { try (java.sql.Statement stmt = newStatement(db);java.sql.ResultSet rs = stmt.executeQuery(("SELECT account_id," + (((((" registered_on," + " full_name, ") + " preferred_email,") + " status,") + " inactive") + " FROM accounts")))) { java.util.Set<com.google.gerrit.reviewdb.client.Account> s = new java.util.HashSet<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)), rs.getTimestamp(2)); a.setFullName(rs.getString(3)); a.setPreferredEmail(rs.getString(4)); a.setStatus(rs.getString(5)); a.setActive(rs.getString(6).equals("N")); s.add(a); pm.update(1); } return s; } }





@java.lang.Override public com.googlesource.gerrit.plugins.quota.Module.Holder load(java.lang.String key) throws java.lang.Exception { com.google.common.base.Optional<com.googlesource.gerrit.plugins.quota.AccountLimitsConfig.RateLimit> limit = finder.getRateLimit(AccountLimitsConfig.Type.UPLOADPACK, anonymous); if (limit.isPresent()) { return com.googlesource.gerrit.plugins.quota.Module.Holder.createWithBurstyRateLimiter(limit); } return com.googlesource.gerrit.plugins.quota.Module.Holder.EMPTY; }

public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return execute(action, com.google.gerrit.server.update.RetryHelper.defaults()); }
private static boolean isLockFailure(java.lang.Throwable t) { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } return t instanceof com.google.gerrit.server.git.LockFailureException; }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.server.update.RetryHelper.MetricListener listener = null; try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(opts.listener()); builder.withRetryListener(listener).withStopStrategy(com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeout(), defaultTimeout).toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS)).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if (e instanceof com.github.rholder.retry.RetryException) { metrics.timeoutCount.increment(); } if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } finally { if (listener != null) { metrics.attemptCounts.record(listener.getAttemptCount()); } } }
private com.google.gerrit.server.account.externalids.ExternalIdsUpdate.RefsMetaExternalIdsUpdate updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryer.call(() -> { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName);org.eclipse.jgit.lib.ObjectInserter ins = repo.newObjectInserter()) { org.eclipse.jgit.lib.ObjectId rev = readRevision(repo); afterReadRevision.run(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = readNoteMap(rw, rev); com.google.gerrit.server.account.externalids.UpdatedExternalIds updatedExtIds = updater.update(com.google.gerrit.server.account.externalids.OpenRepo.create(repo, rw, ins, noteMap)); return commit(repo, rw, ins, rev, noteMap, updatedExtIds); } } }); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gwtorm.server.OrmException.class); } throw new com.google.gwtorm.server.OrmException(e); } }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData> parentproject(java.lang.String name) { return new com.google.gerrit.server.query.change.ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name); }

public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot look up change for commit " + (commit.name())) + " in ") + project), e); } return isReachableFrom(state, repo, commit, repo.getAllRefs()); }
boolean isReachableFromHeadsOrTags(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.RefDatabase refdb = repo.getRefDatabase(); java.util.Collection<org.eclipse.jgit.lib.Ref> heads = refdb.getRefs(Constants.R_HEADS).values(); java.util.Collection<org.eclipse.jgit.lib.Ref> tags = refdb.getRefs(Constants.R_TAGS).values(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Maps.newHashMapWithExpectedSize(((heads.size()) + (tags.size()))); for (org.eclipse.jgit.lib.Ref r : com.google.common.collect.Iterables.concat(heads, tags)) { refs.put(r.getName(), r); } return commits.isReachableFrom(state, repo, commit, refs); } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey()), e); return false; } }
protected static java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.project.ProjectResource(projectState, self.get()); com.google.gerrit.server.project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.extensions.common.ProjectInfo p : children.apply(proj)) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn("cannot check permissions to expand child projects", e); } return r; }


@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canDeletePrivate(rsrc).value())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to unmark private"); } if (!(rsrc.getChange().isPrivate())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not private"); } com.google.gerrit.server.change.SetPrivateOp op = new com.google.gerrit.server.change.SetPrivateOp(cmUtil, false, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.data.ChangeAttribute asChangeAttribute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.data.ChangeAttribute a = new com.google.gerrit.server.data.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.topic = change.getTopic(); a.id = change.getKey().get(); a.number = change.getId().get(); a.subject = change.getSubject(); try { a.commitMessage = changeDataFactory.create(db, change).commitMessage(); } catch (java.lang.Exception e) { com.google.gerrit.server.events.EventFactory.log.error(("Error while getting full commit message for change " + (a.number))); } a.url = getChangeUrl(change); a.owner = asAccountAttribute(change.getOwner()); a.assignee = asAccountAttribute(change.getAssignee()); a.status = change.getStatus(); a.createdOn = (change.getCreatedOn().getTime()) / 1000L; return a; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canSetPrivate(rsrc).value())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to mark private"); } if (rsrc.getChange().isPrivate()) { return com.google.gerrit.extensions.restapi.Response.ok(""); } com.google.gerrit.server.change.SetPrivateOp op = new com.google.gerrit.server.change.SetPrivateOp(cmUtil, true, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (recursive) { return getTransitiveMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
private void addInternalDetails(com.google.gerrit.extensions.common.GroupInfo info, com.google.gerrit.common.data.GroupDescription.Internal internalGroup, java.util.function.Supplier<com.google.gerrit.server.account.GroupControl> groupControlSupplier) throws com.google.gwtorm.server.OrmException { info.description = com.google.common.base.Strings.emptyToNull(internalGroup.getDescription()); info.groupId = internalGroup.getId().get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerGroupUUID = internalGroup.getOwnerGroupUUID(); if (ownerGroupUUID != null) { info.ownerId = com.google.gerrit.extensions.restapi.Url.encode(ownerGroupUUID.get()); com.google.gerrit.common.data.GroupDescription.Basic o = groupBackend.get(ownerGroupUUID); if (o != null) { info.owner = o.getName(); } } info.createdOn = internalGroup.getCreatedOn(); if (options.contains(com.google.gerrit.server.group.MEMBERS)) { info.members = listMembers.get().getDirectMembers(internalGroup, groupControlSupplier.get()); } if (options.contains(com.google.gerrit.server.group.INCLUDES)) { info.includes = listSubgroups.get().getDirectSubgroups(internalGroup, groupControlSupplier.get()); } }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration); }
void display(java.io.PrintWriter writer) throws com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(name)); java.lang.String errorText = "Group not found or not visible\n"; if (!(group.isPresent())) { writer.write(errorText); writer.flush(); return; } java.util.List<com.google.gerrit.extensions.common.AccountInfo> members = getDirectMembers(group.get()); com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(writer, '\t'); formatter.addColumn("id"); formatter.addColumn("username"); formatter.addColumn("full name"); formatter.addColumn("email"); formatter.nextLine(); for (com.google.gerrit.extensions.common.AccountInfo member : members) { if (member == null) { continue; } formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.username, "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(member.name), "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.email, "n/a")); formatter.nextLine(); } formatter.finish(); }


public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { changeIdCounter.increment(com.google.gerrit.server.ChangeFinder.ChangeIdType.PROJECT_NUMERIC_ID); return fromProjectNumber(id.substring(0, z), n.intValue()); } } if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { changeIdCounter.increment(com.google.gerrit.server.ChangeFinder.ChangeIdType.NUMERIC_ID); return find(new com.google.gerrit.reviewdb.client.Change.Id(n)); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if (id.matches((((("^([0-9a-fA-F]{" + (com.google.gerrit.reviewdb.client.RevId.ABBREV_LEN)) + ",") + (com.google.gerrit.reviewdb.client.RevId.LEN)) + "})$"))) { changeIdCounter.increment(com.google.gerrit.server.ChangeFinder.ChangeIdType.COMMIT_HASH); return asChangeNotes(query.byCommit(id)); } if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); changeIdCounter.increment(com.google.gerrit.server.ChangeFinder.ChangeIdType.TRIPLET); return asChangeNotes(query.byBranchKey(t.branch(), t.id())); } } java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = asChangeNotes(query.byKeyPrefix(id)); if (!(notes.isEmpty())) { changeIdCounter.increment(com.google.gerrit.server.ChangeFinder.ChangeIdType.CHANGE_ID); } return notes; }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Star parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); java.util.Set<java.lang.String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId()); return new com.google.gerrit.server.account.AccountResource.Star(user, change, labels); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("change %s not found", id.get())); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error("cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("internal server error"); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded()); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
@java.lang.Override public AccountResource.StarredChange parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) { return new com.google.gerrit.server.account.AccountResource.StarredChange(user, change); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }

private void addExtId(org.eclipse.jgit.junit.TestRepository<?> testRepo, com.google.gerrit.server.account.externalids.ExternalId... extIds) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = com.google.gerrit.server.account.externalids.ExternalIdReader.readRevision(testRepo.getRepository()); try (org.eclipse.jgit.lib.ObjectInserter ins = testRepo.getRepository().newObjectInserter()) { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(testRepo.getRevWalk(), rev); for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalIdsUpdate.insert(testRepo.getRevWalk(), ins, noteMap, extId); } com.google.gerrit.server.account.externalids.ExternalIdsUpdate.commit(allUsers, testRepo.getRepository(), testRepo.getRevWalk(), ins, rev, noteMap, "Add external ID", admin.getIdent(), admin.getIdent(), null, GitReferenceUpdated.DISABLED); } }
@org.junit.Test public void retryOnLockFailure() throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId.Key fooId = ExternalId.Key.create("foo", "foo"); com.google.gerrit.server.account.externalids.ExternalId.Key barId = ExternalId.Key.create("bar", "bar"); final java.util.concurrent.atomic.AtomicBoolean doneBgUpdate = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.server.account.externalids.ExternalIdsUpdate update = new com.google.gerrit.server.account.externalids.ExternalIdsUpdate(repoManager, accountCache, allUsers, metricMaker, externalIds, new com.google.gerrit.server.account.externalids.DisabledExternalIdCache(), serverIdent.get(), serverIdent.get(), null, com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, new com.google.gerrit.server.update.RetryHelper(cfg, retryMetrics, null, null, null, ( r) -> r.withBlockStrategy(new com.github.rholder.retry.BlockStrategy() { @java.lang.Override public void block(long sleepTime) { } })), () -> { if (!(doneBgUpdate.getAndSet(true))) { try { extIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.create(barId, admin.id)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException | com.google.gwtorm.server.OrmException e) { } } }); assertThat(doneBgUpdate.get()).isFalse(); update.insert(com.google.gerrit.server.account.externalids.ExternalId.create(fooId, admin.id)); assertThat(doneBgUpdate.get()).isTrue(); assertThat(externalIds.get(fooId)).isNotNull(); assertThat(externalIds.get(barId)).isNotNull(); }
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId rev = com.google.gerrit.server.account.externalids.ExternalIdReader.readRevision(repo); if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return null; } return com.google.gerrit.server.account.externalids.ExternalIdReader.parse(key, rw, rev); } }
private com.google.gerrit.server.account.externalids.ExternalIdsUpdate.RefsMetaExternalIdsUpdate updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return retryHelper.execute(updater, ( i) -> { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName);org.eclipse.jgit.lib.ObjectInserter ins = repo.newObjectInserter()) { org.eclipse.jgit.lib.ObjectId rev = readRevision(repo); afterReadRevision.run(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = readNoteMap(rw, rev); com.google.gerrit.server.account.externalids.UpdatedExternalIds updatedExtIds = i.update(com.google.gerrit.server.account.externalids.OpenRepo.create(repo, rw, ins, noteMap)); return commit(repo, rw, ins, rev, noteMap, updatedExtIds); } } }); }










@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return null; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { return com.google.gerrit.server.account.externalids.ExternalIdReader.parse(key, rw, rev); } }








public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.api.accounts.StatusInput input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.api.accounts.StatusInput(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> a.setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getStatus()); }

private void updateAccountInfo() { if ((setFullNameTo) == null) { return; } logDebug("Updating full name of caller"); try { com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> { if (com.google.common.base.Strings.isNullOrEmpty(a.getFullName())) { a.setFullName(setFullNameTo); } }); if (account != null) { user.getAccount().setFullName(account.getFullName()); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { logWarn("Failed to update full name of caller", e); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (extId.key().get())) + "' in use by another account")); } update(who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { accountsUpdateFactory.create().update(to, ( a) -> { if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); } }); } } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public void unlink(com.google.gerrit.reviewdb.client.Account.Id from, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (extIdKeys.isEmpty()) { return; } java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.ArrayList(extIdKeys.size()); for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(extIdKey); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (extIdKey.get())) + "' in use by another account")); } extIds.add(extId); } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (extIdKey.get())) + "' not found")); } } externalIdsUpdateFactory.create().delete(extIds); if (extIds.stream().anyMatch(( e) -> (e.email()) != null)) { accountsUpdateFactory.create().update(from, ( a) -> { if ((a.getPreferredEmail()) != null) { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if (a.getPreferredEmail().equals(extId.email())) { a.setPreferredEmail(null); break; } } } }); } }
public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
@org.junit.Before public void setUpInjector() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = com.google.gerrit.testing.InMemoryModule.newDefaultConfig(); cfg.setInt("receive", null, "maxTrustDepth", 2); cfg.setStringList("receive", null, "trustedKey", com.google.common.collect.ImmutableList.of(com.google.gerrit.gpg.Fingerprint.toString(keyB().getPublicKey().getFingerprint()), com.google.gerrit.gpg.Fingerprint.toString(keyD().getPublicKey().getFingerprint()))); com.google.inject.Injector injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testing.InMemoryModule(cfg, com.google.gerrit.testing.NoteDbMode.newNotesMigrationFromEnv())); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); injector.injectMembers(this); lifecycle.start(); db = schemaFactory.open(); schemaCreator.create(db); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); accountsUpdate.create().update(userId, ( a) -> a.setPreferredEmail("user@example.com")); user = reloadUser(); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getUser() { return user; } @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } }); storeRepo = new org.eclipse.jgit.internal.storage.dfs.InMemoryRepository(new org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription("repo")); store = new com.google.gerrit.gpg.PublicKeyStore(storeRepo); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyPreferred = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> { if (email.equals(a.getPreferredEmail())) { alreadyPreferred.set(true); } else { a.setPreferredEmail(email); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyPreferred.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); java.lang.String email = "user@example.com"; externalIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createEmail(userId, email)); accountsUpdate.create().update(userId, ( a) -> a.setPreferredEmail(email)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userId)); }
@org.junit.Test public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws java.lang.Exception { TestAccount foo = accountCreator.create(name("foo"), ((name("foo")) + "@example.com"), "Foo"); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); java.lang.String noEmail = "no.email"; accountsUpdate.create().update(foo.id, ( a) -> a.setPreferredEmail(noEmail)); accountIndexedCounter.clear(); grant(allUsers, userRef, Permission.PUSH, false, com.google.gerrit.acceptance.api.accounts.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, foo); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String status = "in vacation"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status); pushFactory.create(db, foo.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus(); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.email).isEqualTo(noEmail); assertThat(info.name).isEqualTo(foo.fullName); assertThat(info.status).isEqualTo(status); }
@org.junit.Test public void updateAccountWithoutAccountConfigNoteDb() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount anonymousCoward = accountCreator.create(); assertUserBranchWithoutAccountConfig(anonymousCoward.getId()); java.lang.String status = "OOO"; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(anonymousCoward.getId(), ( a) -> a.setStatus(status)); assertThat(account).isNotNull(); assertThat(account.getFullName()).isNull(); assertThat(account.getStatus()).isEqualTo(status); assertUserBranch(anonymousCoward.getId(), null, status); }
@org.junit.Test public void lookUpByPreferredEmail() throws java.lang.Exception { java.lang.String prefix = "foo.preferred"; java.lang.String prefEmail = prefix + "@example.com"; com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); accountsUpdate.create().update(foo.id, ( a) -> a.setPreferredEmail(prefEmail)); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail); assertThat(accountsByPrefEmail).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id); accountsByPrefEmail = emails.getAccountFor(prefix); assertThat(accountsByPrefEmail).isEmpty(); accountsByPrefEmail = emails.getAccountFor(prefEmail.toUpperCase(java.util.Locale.US)); assertThat(accountsByPrefEmail).isEmpty(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.common.NameInput input) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.common.NameInput(); } if (!(realm.allowsEdit(AccountFieldName.FULL_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing name"); } java.lang.String newName = input.name; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> a.setFullName(newName)); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getFullName()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getFullName()); }
public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.function.Consumer<com.google.gerrit.reviewdb.client.Account> consumer) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return update(accountId, com.google.common.collect.ImmutableList.of(consumer)); }
@com.google.gerrit.common.Nullable public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.List<java.util.function.Consumer<com.google.gerrit.reviewdb.client.Account>> consumers) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (consumers.isEmpty()) { return null; } com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = accountConfig.getLoadedAccount(); if (account.isPresent()) { consumers.stream().forEach(( c) -> c.accept(account.get())); commit(accountConfig); } return account.orElse(null); }
public com.google.gerrit.reviewdb.client.Account insert(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.function.Consumer<com.google.gerrit.reviewdb.client.Account> init) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(); init.accept(account); commitNew(accountConfig); return account; }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if (!(loadedAccount.isPresent())) { return false; } if ((revision) != null) { commit.setMessage("Update account\n"); } else { commit.setMessage("Create account\n"); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); commit.setCommitter(new org.eclipse.jgit.lib.PersonIdent(commit.getCommitter(), registeredOn)); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); com.google.gerrit.server.account.AccountConfig.writeToConfig(loadedAccount.get(), cfg); saveConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); return true; }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.loadedAccount = java.util.Optional.of(account); this.registeredOn = account.getRegisteredOn(); }
private Account.Id createAccountOutsideRequestContext(java.lang.String username, java.lang.String fullName, java.lang.String email, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email != null) { accountManager.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, ( a) -> { a.setFullName(fullName); a.setPreferredEmail(email); a.setActive(active); }); return id; } }
@org.junit.Test public void checkMetaId() throws java.lang.Exception { assertThat(accounts.get(admin.getId()).getMetaId()).isEqualTo(getMetaId(admin.getId())); com.google.gerrit.server.account.AccountsUpdate au = accountsUpdate.create(); com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(seq.nextAccountId()); com.google.gerrit.reviewdb.client.Account account = au.insert(accountId, ( a) -> { }); assertThat(account.getMetaId()).isEqualTo(getMetaId(accountId)); com.google.gerrit.reviewdb.client.Account updatedAccount = au.update(accountId, ( a) -> a.setFullName("foo")); assertThat(account.getMetaId()).isNotEqualTo(updatedAccount.getMetaId()); assertThat(updatedAccount.getMetaId()).isEqualTo(getMetaId(accountId)); }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "asciidoctor: FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } if ((revnumberFile) != null) { try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(revnumberFile))) { revnumber = reader.readLine(); } } if (mktmp) { tmpdir = java.nio.file.Files.createTempDirectory("asciidoctor-").toFile(); } if (bazel) { renderFiles(inputFiles, null); } else { try (java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(java.nio.file.Files.newOutputStream(java.nio.file.Paths.get(zipFile)))) { renderFiles(inputFiles, zip); java.io.File[] cssFiles = tmpdir.listFiles(new java.io.FilenameFilter() { @java.lang.Override public boolean accept(java.io.File dir, java.lang.String name) { return name.endsWith(".css"); } }); for (java.io.File css : cssFiles) { AsciiDoctor.zipFile(css, css.getName(), zip); } } } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return execute(action, com.google.gerrit.server.update.RetryHelper.defaults(), ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Throwable { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return execute(action, retryerBuilder.build()); } finally { metrics.attemptCounts.record(listener.getAttemptCount()); } }

public <T> T execute(com.google.gerrit.server.update.RetryHelper.ChangeAction<T> changeAction, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { if (!(migration.disableChangeReviewDb())) { return execute(() -> changeAction.call(updateFactory), com.github.rholder.retry.RetryerBuilder.<T>newBuilder().build()); } return execute(() -> changeAction.call(updateFactory), opts, ( t) -> { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } return t instanceof com.google.gerrit.server.git.LockFailureException; }); } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(t); } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.RetryHelper.defaults(), ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); try { return retryerBuilder.build().call(() -> action.call()); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { java.lang.Throwable t = e; if ((e.getCause()) != null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private void recursivelyExpandGroups(final java.util.Set<java.lang.String> groupDNs, final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema, final javax.naming.directory.DirContext ctx, final java.lang.String groupDN) { if (((groupDNs.add(groupDN)) && ((schema.accountMemberField) != null)) && (schema.accountMemberExpandGroups)) { com.google.common.collect.ImmutableSet<java.lang.String> cachedParentsDNs = parentGroups.getIfPresent(groupDN); if (cachedParentsDNs == null) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> dns = com.google.common.collect.ImmutableSet.builder(); try { final javax.naming.Name compositeGroupName = new javax.naming.CompositeName().add(groupDN); final javax.naming.directory.Attribute in = ctx.getAttributes(compositeGroupName, schema.accountMemberFieldArray).get(schema.accountMemberField); if (in != null) { final javax.naming.NamingEnumeration<?> groups = in.getAll(); try { while (groups.hasMore()) { dns.add(((java.lang.String) (groups.next()))); } } catch (javax.naming.PartialResultException e) { } } } catch (javax.naming.NamingException e) { LdapRealm.log.warn(("Could not find group " + groupDN), e); } cachedParentsDNs = dns.build(); parentGroups.put(groupDN, cachedParentsDNs); } for (java.lang.String dn : cachedParentsDNs) { recursivelyExpandGroups(groupDNs, schema, ctx, dn); } } }
com.google.gerrit.server.api.changes.FileApiImpl create(com.google.gerrit.server.change.FileResource r);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.SubgroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc.getMemberDescription()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.VoteResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.VoteResource parse(com.google.gerrit.server.change.ReviewerResource reviewer, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((reviewer.getRevisionResource()) != null) && (!(reviewer.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Cannot access on non-current patch set"); } return new com.google.gerrit.server.change.VoteResource(reviewer, id.get()); }
@java.lang.Override public GroupDescription.Basic get(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { if (!(handles(uuid))) { return null; } java.lang.String groupDn = uuid.get().substring(com.google.gerrit.server.auth.ldap.Helper.LDAP_UUID.length()); com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((!(user.isIdentifiedUser())) || (!(membershipsOf(user.asIdentifiedUser()).contains(uuid)))) { try { if (!(existsCache.get(groupDn))) { return null; } } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.auth.ldap.LdapGroupBackend.log.warn(java.lang.String.format("Cannot lookup group %s in LDAP", groupDn), e); return null; } } final java.lang.String name = (com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME) + (com.google.gerrit.server.auth.ldap.LdapGroupBackend.cnFor(groupDn)); return new com.google.gerrit.common.data.GroupDescription.Basic() { @java.lang.Override public AccountGroup.UUID getGroupUUID() { return uuid; } @java.lang.Override public java.lang.String getName() { return name; } @java.lang.Override @com.google.gerrit.common.Nullable public java.lang.String getEmailAddress() { return null; } @java.lang.Override @com.google.gerrit.common.Nullable public java.lang.String getUrl() { return null; } }; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { com.google.gerrit.extensions.common.SetDashboardInput in = new com.google.gerrit.extensions.common.SetDashboardInput(); in.commitMessage = (input != null) ? input.commitMessage : null; return defaultSetter.get().apply(resource, in); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@org.junit.Test public void updateGroupNamesWithEmptyCollectionClearsAllNotes() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(); updateGroupNames(ident, g1, g2); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2"); updateGroupNames(ident); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).isEmpty(); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(2); assertThat(log.get(1)).message().isEqualTo("Store 0 group names"); }
@org.junit.Test public void emptyGroupName() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g = newGroup(""); updateGroupNames(com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(), g); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("", "-1"); assertThat(readNameNote(g)).isEqualTo("[group]\n\tuuid = -1\n\tname = \n"); }
@org.junit.Test public void updateGroupNames() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(); updateGroupNames(ident, g1, g2); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(1); assertThat(log.get(0)).parents().isEmpty(); assertThat(log.get(0)).message().isEqualTo("Store 2 group names"); assertThat(log.get(0)).author().matches(ident); assertThat(log.get(0)).committer().matches(ident); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2"); java.lang.String commit = log.get(0).commit; updateGroupNames(com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(), g1, g2); log = log(); assertThat(log).hasSize(1); assertThat(log.get(0)).commit().isEqualTo(commit); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.MemberResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddMembers.PutMember create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.group.AddMembers.PutMember(put, id.get()); }
@java.lang.Override public com.google.gerrit.server.group.MemberResource parse(com.google.gerrit.server.group.GroupResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal group = parent.asInternalGroup().orElseThrow(MethodNotAllowedException::new); com.google.gerrit.server.IdentifiedUser user = accounts.parse(TopLevelResource.INSTANCE, id).getUser(); if ((parent.getControl().canSeeMember(user.getAccountId())) && (com.google.gerrit.server.group.MembersCollection.isMember(group, user))) { return new com.google.gerrit.server.group.MemberResource(parent, user); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { return list.get(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FixResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.FixResource parse(com.google.gerrit.server.change.RevisionResource revisionResource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String fixId = id.get(); com.google.gerrit.server.notedb.ChangeNotes changeNotes = revisionResource.getNotes(); java.util.List<com.google.gerrit.reviewdb.client.RobotComment> robotComments = commentsUtil.robotCommentsByPatchSet(changeNotes, revisionResource.getPatchSet().getId()); for (com.google.gerrit.reviewdb.client.RobotComment robotComment : robotComments) { for (com.google.gerrit.reviewdb.client.FixSuggestion fixSuggestion : robotComment.fixSuggestions) { if (java.util.Objects.equals(fixId, fixSuggestion.fixId)) { return new com.google.gerrit.server.change.FixResource(revisionResource, fixSuggestion.replacements); } } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, TopicInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); if (((input != null) && ((input.topic) != null)) && ((input.topic.length()) > (com.google.gerrit.server.ChangeUtil.TOPIC_MAX_LENGTH))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH)); } com.google.gerrit.server.change.PutTopic.Op op = new com.google.gerrit.server.change.PutTopic.Op((input != null ? input : new TopicInput())); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(op.newTopicName); }
@org.junit.Test public void byLabelGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); createAccount("user2"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testing.InMemoryRepositoryManager.Repo> repo = createProject("repo"); java.lang.String g1 = createGroup("group1", "Administrators"); java.lang.String g2 = createGroup("group2", "Administrators"); gApi.groups().id(g1).addMembers("user1"); gApi.groups().id(g2).addMembers("user2"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo), user1); requestContext.setContext(newRequestContext(user1)); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput().label("Code-Review", 1)); requestContext.setContext(newRequestContext(userId)); assertQuery("label:Code-Review=+1,group1", change1); assertQuery("label:Code-Review=+1,group=group1", change1); assertQuery("label:Code-Review=+1,user=user1", change1); assertQuery("label:Code-Review=+1,user=user2"); assertQuery("label:Code-Review=+1,group=group2"); }
@org.junit.Test public void submitRecords() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testing.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); gApi.changes().id(change1.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); requestContext.setContext(newRequestContext(user1)); gApi.changes().id(change2.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); requestContext.setContext(newRequestContext(user.getAccountId())); assertQuery("is:submittable", change1); assertQuery("-is:submittable", change2); assertQuery("submittable:ok", change1); assertQuery("submittable:not_ready", change2); assertQuery("label:CodE-RevieW=ok", change1); assertQuery("label:CodE-RevieW=ok,user=user", change1); assertQuery("label:CodE-RevieW=ok,Administrators", change1); assertQuery("label:CodE-RevieW=ok,group=Administrators", change1); assertQuery("label:CodE-RevieW=ok,owner", change1); assertQuery("label:CodE-RevieW=ok,user1"); assertQuery("label:CodE-RevieW=need", change2); assertQuery("label:CodE-RevieW=need,user1"); assertQuery("label:CodE-RevieW=need,user"); }
@java.lang.Override public com.google.gerrit.extensions.common.CommitInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws java.io.IOException { return com.google.gerrit.server.git.CommitUtil.toCommitInfo(rsrc.getCommit()); }
@java.lang.Override public com.google.gerrit.server.project.CreateTag create(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString name) { return createTagFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.GroupInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Group already exists"); }
public static java.lang.String describe(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { return user.getAccountId().toString(); } if (user instanceof com.google.gerrit.server.query.change.SingleGroupUser) { return "group:" + (user.getEffectiveGroups().getKnownGroups().iterator().next().toString()); } return user.toString(); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.AccountLoader loader = infoFactory.create(true); com.google.gerrit.extensions.common.AccountInfo info = loader.get(rsrc.getMember().getAccountId()); loader.fill(); return info; }
private java.lang.String getGroupName(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { return groupCache.get(groupId).map(InternalGroup::getName).orElse(("Deleted group " + groupId)); }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById m : values) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = m.getIncludeUUID(); java.lang.String groupName = groupBackend.get(groupUuid).getName(); com.google.gerrit.reviewdb.client.AccountGroup.Id targetGroupId = m.getGroupId(); java.lang.String targetGroupName = getGroupName(targetGroupId); descriptions.add(java.text.MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, removedOn); audit.removedLegacy(); auditInserts.add(audit); } } db.accountGroupMembersAudit().update(auditUpdates); db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e); } }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, addedOn); auditInserts.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } } db.accountGroupByIdAud().update(auditUpdates); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e); } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Edit Topic").setVisible(rsrc.permissions().testCond(ChangePermission.EDIT_TOPIC_NAME)); }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, addedOn); includesAudit.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e); } }
public static void logFailToLoadFromGroupRefAsWarning(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblem(warning("Group with UUID %s from group name notes failed to load from group ref", uuid)); }
@com.google.common.annotations.VisibleForTesting static java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkWithGroupNameNotes(org.eclipse.jgit.lib.Repository allUsersRepo, java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException { try { java.util.Optional<com.google.gerrit.common.data.GroupReference> groupRef = com.google.gerrit.server.group.db.GroupNameNotes.loadOneGroupReference(allUsersRepo, groupName); if (!(groupRef.isPresent())) { return com.google.common.collect.ImmutableList.of(warning("Group with name '%s' doesn't exist in the list of all names", groupName)); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = groupRef.get().getUUID(); java.lang.String name = groupRef.get().getName(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); if (!(java.util.Objects.equals(groupUUID, uuid))) { problems.add(warning("group with name '%s' has UUID '%s' in 'group.config' but '%s' in group name notes", groupName, groupUUID, uuid)); } if (!(java.util.Objects.equals(groupName, name))) { problems.add(warning("group note of name '%s' claims to represent name of '%s'", groupName, name)); } return problems; } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { return com.google.common.collect.ImmutableList.of(warning("fail to check consistency with group name notes: %s", e.getMessage())); } }
private void readGroups(org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs, com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result result) throws java.io.IOException { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : refs.entrySet()) { if (!(entry.getKey().startsWith(RefNames.REFS_GROUPS))) { continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey()); if (uuid == null) { result.problems.add(error("null UUID from %s", entry.getKey())); continue; } try { com.google.gerrit.server.group.db.GroupConfig cfg = com.google.gerrit.server.group.db.GroupConfig.loadForGroupSnapshot(repo, uuid, entry.getValue().getObjectId()); result.uuidToGroupMap.put(uuid, cfg.getLoadedGroup().get()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { result.problems.add(error("group %s does not parse: %s", uuid, e.getMessage())); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ParentInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return apply(rsrc, input, true); }
public void validateParentUpdate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser user, java.lang.String newParent, boolean checkIfAdmin) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException { if (checkIfAdmin) { permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); } if ((project.equals(allUsers)) && (!(allProjects.get().equals(newParent)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("%s must inherit from %s", allUsers.get(), allProjects.get())); } if (project.equals(allProjects)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("cannot set parent of " + (allProjects.get()))); } newParent = com.google.common.base.Strings.emptyToNull(newParent); if (newParent != null) { com.google.gerrit.server.project.ProjectState parent = cache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newParent)); if (parent == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException((("parent project " + newParent) + " not found")); } if (parent.getName().equals(project.get())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot set parent to self"); } if (com.google.common.collect.Iterables.tryFind(parent.tree(), ( p) -> { return p.getNameKey().equals(project); }).isPresent()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((("cycle exists between " + (project.get())) + " and ") + (parent.getName()))); } } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.TagResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.TagResource parse(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return new com.google.gerrit.server.project.TagResource(rsrc.getProjectState(), rsrc.getUser(), list.get().get(rsrc, id)); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AgreementInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("contributor agreements disabled"); } if (!(self.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get contributor agreements"); } com.google.gerrit.server.IdentifiedUser user = self.get().asIdentifiedUser(); if (user != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get contributor agreements"); } java.util.List<com.google.gerrit.extensions.common.AgreementInfo> results = new java.util.ArrayList<>(); java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> cas = projectCache.getAllProjects().getConfig().getContributorAgreements(); for (com.google.gerrit.common.data.ContributorAgreement ca : cas) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupIds = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.PermissionRule rule : ca.getAccepted()) { if (((rule.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW)) && ((rule.getGroup()) != null)) { if ((rule.getGroup().getUUID()) != null) { groupIds.add(rule.getGroup().getUUID()); } else { com.google.gerrit.server.account.GetAgreements.log.warn(((((("group \"" + (rule.getGroup().getName())) + "\" does not ") + "exist, referenced in CLA \"") + (ca.getName())) + "\"")); } } } if (user.getEffectiveGroups().containsAnyOf(groupIds)) { results.add(agreementJson.format(ca)); } } return results; }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.get(accountId).getUserName(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.access.AccessCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.access.AccessResource.ACCESS_KIND); }
private void testCannotCreateGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, Permission.CREATE); grant(allUsers, refPattern, Permission.PUSH); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo).to(groupRef); r.assertErrorStatus(); assertThat(r.getMessage()).contains("Not allowed to create group branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNull(); } }
private static <T> com.google.common.collect.ImmutableSet<T> logIfNotUnique(com.google.gerrit.server.group.db.GroupBundle.Source source, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.Iterable<T> iterable, java.util.Comparator<T> comparator, java.lang.Class<T> clazz) { java.util.List<T> list = com.google.common.collect.Streams.stream(iterable).sorted(comparator).collect(java.util.stream.Collectors.toList()); com.google.common.collect.ImmutableSet<T> set = com.google.common.collect.ImmutableSet.copyOf(list); if ((set.size()) != (list.size())) { com.google.gerrit.server.group.db.GroupBundle.log.warn("group {} in {} has duplicate {} entities: {}", uuid, source, clazz.getSimpleName(), iterable); } return set; }
public static void updateGroupFile(org.eclipse.jgit.lib.Repository allUsersRepo, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String refName, java.lang.String fileName, java.lang.String contents) throws java.lang.Exception { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo)) { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.lib.Repository> testRepository = new org.eclipse.jgit.junit.TestRepository(allUsersRepo, rw); TestRepository<Repository>.CommitBuilder builder = testRepository.branch(refName).commit().add(fileName, contents).message("update group file").author(serverIdent).committer(serverIdent); org.eclipse.jgit.lib.Ref ref = allUsersRepo.exactRef(refName); if (ref != null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); if (c != null) { builder.parent(c); } } builder.create(); } }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.project.ProjectResource rsrc) { return json.format(rsrc.getProjectState()); }
com.google.gerrit.server.api.projects.BranchApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
private com.google.gerrit.server.project.BranchResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return branches.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult file(java.lang.String path) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.project.FileResource resource = filesCollection.parse(resource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); return getContent.apply(resource); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve file", e); } }
@org.junit.Test public void groupNameNoteHasDifferentUUID() throws java.lang.Exception { updateGroupNamesRef("g-1", "[group]\n\tuuid = uuid-2\n\tname = g-1\n"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning(("group with name 'g-1' has UUID 'uuid-1' in 'group.config' but 'uuid-2' in group " + "name notes"))); }
@org.junit.Test public void groupNameNoteIsConsistent() throws java.lang.Exception { updateGroupNamesRef("g-1", "[group]\n\tuuid = uuid-1\n\tname = g-1\n"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).isEmpty(); }
@org.junit.Test public void groupNameNoteFailToParse() throws java.lang.Exception { updateGroupNamesRef("g-1", "[invalid"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("fail to check consistency with group name notes: Unexpected end of config file")); }
@org.junit.Test public void groupNameNoteIsMissing() throws java.lang.Exception { updateGroupNamesRef("g-2", "[group]\n\tuuid = uuid-2\n\tname = g-2\n"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("Group with name 'g-1' doesn't exist in the list of all names")); }
@org.junit.Test public void groupNameNoteHasDifferentName() throws java.lang.Exception { updateGroupNamesRef("g-1", "[group]\n\tuuid = uuid-1\n\tname = g-2\n"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("group note of name 'g-1' claims to represent name of 'g-2'")); }
@org.junit.Test public void groupNameNoteHasDifferentNameAndUUID() throws java.lang.Exception { updateGroupNamesRef("g-1", "[group]\n\tuuid = uuid-2\n\tname = g-2\n"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning(("group with name 'g-1' has UUID 'uuid-1' in 'group.config' but 'uuid-2' in group " + "name notes")), warning("group note of name 'g-1' claims to represent name of 'g-2'")).inOrder(); }
com.google.gerrit.server.api.projects.ChildProjectApiImpl create(com.google.gerrit.server.project.ChildProjectResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteTagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.tags) == null)) || (input.tags.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("tags must be specified"); } deleteRefFactory.create(project).refs(input.tags).prefix(com.google.gerrit.server.project.R_TAGS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static void logInvalid(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, org.eclipse.jgit.revwalk.RevCommit c, org.eclipse.jgit.revwalk.FooterLine line) { com.google.gerrit.server.group.db.AuditLogReader.log.debug("Invalid footer line in commit {} while parsing audit log for group {}: {}", c.name(), uuid, line); }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, BanCommitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getNameKey(), rsrc.getUser(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } return r; }
private GroupBundle.Builder newBundle() { com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.Id(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("group-1"), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.Account.Id(1000), group.getId())); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(member, new com.google.gerrit.reviewdb.client.Account.Id(2000), ts); com.google.gerrit.reviewdb.client.AccountGroupById byId = new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup"))); com.google.gerrit.reviewdb.client.AccountGroupByIdAud byIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(byId, new com.google.gerrit.reviewdb.client.Account.Id(3000), ts); return com.google.gerrit.server.group.db.GroupBundle.builder().group(group).members(member).memberAudit(memberAudit).byId(byId).byIdAudit(byIdAudit); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.global:Anonymous-Users.name", value = "All Users") public void createGroupWithDefaultNameOfSystemGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group name 'Anonymous Users' is reserved"); gApi.groups().create("anonymous users"); }
com.google.gerrit.server.api.changes.RobotCommentApiImpl create(com.google.gerrit.server.change.RobotCommentResource c);
private com.google.gerrit.extensions.common.AuthInfo getAuthInfo(com.google.gerrit.server.config.AuthConfig cfg, com.google.gerrit.server.account.Realm realm) { com.google.gerrit.extensions.common.AuthInfo info = new com.google.gerrit.extensions.common.AuthInfo(); info.authType = cfg.getAuthType(); info.useContributorAgreements = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.isUseContributorAgreements()); info.editableAccountFields = new java.util.ArrayList(realm.getEditableFields()); info.switchAccountUrl = cfg.getSwitchAccountUrl(); info.gitBasicAuthPolicy = cfg.getGitBasicAuthPolicy(); if ((info.useContributorAgreements) != null) { java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> agreements = projectCache.getAllProjects().getConfig().getContributorAgreements(); if (!(agreements.isEmpty())) { info.contributorAgreements = com.google.common.collect.Lists.newArrayListWithCapacity(agreements.size()); for (com.google.gerrit.common.data.ContributorAgreement agreement : agreements) { info.contributorAgreements.add(agreementJson.format(agreement)); } } } switch (info.authType) { case LDAP : case LDAP_BIND : info.registerUrl = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterText(); info.editFullNameUrl = cfg.getEditFullNameUrl(); break; case CUSTOM_EXTENSION : info.registerUrl = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterText(); info.editFullNameUrl = cfg.getEditFullNameUrl(); info.httpPasswordUrl = cfg.getHttpPasswordUrl(); break; case HTTP : case HTTP_LDAP : info.loginUrl = cfg.getLoginUrl(); info.loginText = cfg.getLoginText(); break; case CLIENT_SSL_CERT_LDAP : case DEVELOPMENT_BECOME_ANY_ACCOUNT : case OAUTH : case OPENID : case OPENID_SSO : break; } return info; }
@org.junit.Test public void pushToGroupBranchForReviewForAllUsersRepoIsRejectedOnSubmit() throws java.lang.Exception { pushToGroupBranchForReviewAndSubmit(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()), "group update not allowed"); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.global:Anonymous-Users.name", value = "All Users") public void createGroupWithConfiguredNameOfSystemGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group 'All Users' already exists"); gApi.groups().create("all users"); }
@org.junit.Test public void createDuplicateSystemGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String newGroupName = "Registered Users"; exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group 'Registered Users' already exists"); gApi.groups().create(newGroupName); }
private void testCannotDeleteGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, Permission.DELETE, true, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains("Not allowed to delete group branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNotNull(); } }
private void pushToGroupBranchForReviewAndSubmit(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRef, java.lang.String expectedError) throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grantLabel("Code-Review", (-2), 2, project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS, false); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.SUBMIT, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRef + ":groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + groupRef)); r.assertOkStatus(); assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); if (expectedError != null) { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group update not allowed"); } gApi.changes().id(r.getChangeId()).current().submit(); }
@org.junit.Test public void pushToGroupNamesBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); allowGlobalCapabilities(com.google.gerrit.acceptance.api.group.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); assertPushToGroupBranch(allUsers, RefNames.REFS_GROUPNAMES, "group update not allowed"); }
@org.junit.Test public void pushToDeletedGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("foo")).get().id)); createBranch(allUsers, groupRef); assertPushToGroupBranch(allUsers, groupRef, "group update not allowed"); }
@org.junit.Test public void createDuplicateInternalGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String dupGroupName = name("dupGroup"); gApi.groups().create(dupGroupName); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage((("group '" + dupGroupName) + "' already exists")); gApi.groups().create(dupGroupName); }
private void assertPushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRefName, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_DELETED_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_DELETED_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, RefNames.REFS_GROUPNAMES, Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", GroupConfig.GROUP_CONFIG_FILE, "some content").to(groupRefName); if (expectedErrorOnUpdate != null) { r.assertErrorStatus(expectedErrorOnUpdate); } else { r.assertOkStatus(); } }
private void assertCreateGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", GroupConfig.GROUP_CONFIG_FILE, "some content").setParents(com.google.common.collect.ImmutableList.of()).to(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("bar")))); if (expectedErrorOnCreate != null) { r.assertErrorStatus(expectedErrorOnCreate); } else { r.assertOkStatus(); } }
@org.junit.Test public void onlyVisibleGroupsReturned() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = newGroupName; in.description = "a hidden group"; in.visibleToAll = false; in.ownerId = adminGroupUuid().get(); gApi.groups().create(in); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName); setApiUser(admin); gApi.groups().id(newGroupName).addMembers(user.username); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName); }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); assertPushToGroupBranch(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()), "group update not allowed"); }
@org.junit.Test public void groupDescription() throws java.lang.Exception { java.lang.String name = name("group"); gApi.groups().create(name); assertThat(gApi.groups().id(name).description()).isEmpty(); java.lang.String desc = "New description for the group."; gApi.groups().id(name).description(desc); assertThat(gApi.groups().id(name).description()).isEqualTo(desc); gApi.groups().id(name).description(null); assertThat(gApi.groups().id(name).description()).isEmpty(); gApi.groups().id(name).description(""); assertThat(gApi.groups().id(name).description()).isEmpty(); }
@org.junit.Test public void reindexPermissions() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount groupOwner = accountCreator.user2(); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("group"); in.members = java.util.Collections.singleton(groupOwner).stream().map(( u) -> u.id.toString()).collect(java.util.stream.Collectors.toList()); in.visibleToAll = true; com.google.gerrit.extensions.common.GroupInfo group = gApi.groups().create(in).get(); setApiUser(admin); gApi.groups().id(group.id).index(); setApiUser(groupOwner); gApi.groups().id(group.id).index(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("not allowed to index group"); gApi.groups().id(group.id).index(); }
@org.junit.Test public void createDuplicateSystemGroupCaseInsensitiveName_Conflict() throws java.lang.Exception { java.lang.String newGroupName = "registered users"; exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group 'Registered Users' already exists"); gApi.groups().create(newGroupName); }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE); info.showAssigneeInChangesTable = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)) && hasAssigneeInIndex)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.privateByDefault = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "privateByDefault", false)); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score")) + " (Shortcut: a)"; info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply")) + "\u2026"; info.updateDelay = ((int) (com.google.gerrit.server.config.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.change.Submit.wholeTopicEnabled(cfg); return info; }
private com.google.gerrit.extensions.common.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllUsersName allUsersName) { com.google.gerrit.extensions.common.GerritInfo info = new com.google.gerrit.extensions.common.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugText"); info.docUrl = getDocUrl(cfg); info.docSearch = docSearcher.isAvailable(); info.editGpgKeys = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(((enableSignedPush) && (cfg.getBoolean("gerrit", null, "editGpgKeys", true)))); info.webUis = java.util.EnumSet.noneOf(com.google.gerrit.extensions.client.UiType.class); if (gerritOptions.enableGwtUi()) { info.webUis.add(UiType.GWT); } if (gerritOptions.enablePolyGerrit()) { info.webUis.add(UiType.POLYGERRIT); } return info; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.accounts = getAccountsInfo(accountVisibilityProvider); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.defaultTheme = "/static/" + (com.google.gerrit.server.config.SitePaths.THEME_FILENAME); } info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ChildProjectResource>> views() { return views; }
@java.lang.Override public void check() throws com.google.gerrit.server.StartupException { java.lang.String invalid = cfg.getSubsections("groups").stream().filter(( sub) -> { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(sub); com.google.gerrit.server.account.GroupBackend groupBackend = universalGroupBackend.backend(uuid); return (groupBackend == null) || ((groupBackend.get(uuid)) == null); }).map(( u) -> ("'" + u) + "'").collect(java.util.stream.Collectors.joining(",")); if (!(invalid.isEmpty())) { throw new com.google.gerrit.server.StartupException(java.lang.String.format((((("Subsections for 'groups' in gerrit.config must be valid group" + " UUIDs. The following group UUIDs could not be resolved: ") + invalid) + " Please remove/fix these 'groups' subsections in") + " gerrit.config."))); } }
@java.lang.Deprecated @org.kohsuke.args4j.Option(name = "--query", aliases = { "-q" }, usage = "group to inspect (deprecated: use --group/-g instead)") void addGroup_Deprecated(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { addGroup(uuid); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.group.GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromDecoded(groupName)); com.google.gerrit.extensions.common.NameInput input = new com.google.gerrit.extensions.common.NameInput(); input.name = newGroupName; putName.apply(rsrc, input); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw die(e); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> getGroupFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUuid).toList(); if ((accountGroups.size()) == 1) { return java.util.Optional.of(com.google.common.collect.Iterables.getOnlyElement(accountGroups)); } else if (accountGroups.isEmpty()) { return java.util.Optional.empty(); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Duplicate group UUID " + groupUuid)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.BranchResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(parent.getRevision()), id.get()); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("project.config", ("[plugin \"somePlugin\"]\nkey1 = " + (staff.toConfigValue()))).create(); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationErrors()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()).isEqualTo(((("project.config: group \"" + (staff.getName())) + "\" not in ") + (GroupList.FILE_NAME))); }
@org.junit.Test public void editConfigMissingGroupTableEntry() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("project.config", ("[access \"refs/heads/*\"]\n" + (((" exclusiveGroupPermissions = read submit\n" + " submit = group People Who Can Submit\n") + " upload = group Developers\n") + " read = group Developers\n"))).create(); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.common.data.AccessSection section = cfg.getAccessSection("refs/heads/*"); com.google.gerrit.common.data.Permission submit = section.getPermission(Permission.SUBMIT); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))); rev = commit(cfg); assertThat(text(rev, "project.config")).isEqualTo(("[access \"refs/heads/*\"]\n" + ((((" exclusiveGroupPermissions = read submit\n" + " submit = group People Who Can Submit\n") + "\tsubmit = group Staff\n") + " upload = group Developers\n") + " read = group Developers\n"))); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.access.AccessResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.access.AccessResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.api.projects.TagInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Tag \"" + (resource.getTagInfo().ref)) + "\" already exists")); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).ref(rsrc.getBranchKey()).check(RefPermission.DELETE); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("branch " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server.group.GroupResource resource) { return com.google.gerrit.server.group.GroupJson.createOptions(resource.getGroup()); }
@org.kohsuke.args4j.Option(name = "-o", usage = "Output options per group") public void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--query2", aliases = { "-q2" }, usage = "group query") public void setQuery(java.lang.String query) { this.query = query; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo apply(com.google.gerrit.server.project.DashboardResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if ((inherited) && (!(rsrc.isProjectDefault()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("inherited flag can only be used with default"); } if (rsrc.isProjectDefault()) { try { rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } } return com.google.gerrit.server.project.DashboardsCollection.parse(rsrc.getProjectState().getProject(), rsrc.getRefName().substring(com.google.gerrit.server.project.REFS_DASHBOARDS.length()), rsrc.getPathName(), rsrc.getConfig(), rsrc.getProjectState().getName(), true); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.IdString.fromUrl(((ref + ':') + path))); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.RobotCommentResource>> views() { return views; }
@org.junit.Test public void byOwner() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo ownerGroup = createGroup(name("owner-group")); com.google.gerrit.extensions.common.GroupInfo group = createGroupWithOwner(name("group"), ownerGroup); createGroup(name("group2")); assertQuery(("owner:" + (group.id))); assertQuery(("owner:" + (ownerGroup.id)), group, ownerGroup); assertQuery(("owner:" + (ownerGroup.name)), group, ownerGroup); }
@java.lang.Override public com.google.gerrit.server.change.RobotCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.RobotComment c : commentsUtil.robotCommentsByPatchSet(notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.RobotCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); GroupInfo group = createGroup(name("Group")); assertQuery(("name:" + (group.name)), group); assertQuery(("name:" + (group.name.toLowerCase(Locale.US)))); GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen")); createGroup(name("group-no-match-with-hyphen")); assertQuery(("name:" + (groupWithHyphen.name)), groupWithHyphen); }
@org.junit.Test public void byDefaultField() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("foo-group")); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroupWithDescription(name("group3"), ("decription that contains foo and the UUID of group2: " + (group2.id))); assertQuery("non-existing"); assertQuery("foo", group1, group3); assertQuery(group2.id, group2, group3); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64(); } else if (Patch.MERGE_LIST.equals(path)) { byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64(); } return fileContentUtil.getContent(projectCache.checkedGet(rsrc.getRevision().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent); }
@org.junit.Test public void fixupCommitPostDatesAllAuditEventsEvenIfAuditEventsAreInTheFuture() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.util.stream.IntStream.range(0, 20).forEach(( i) -> com.google.gerrit.common.TimeUtil.nowTs()); java.sql.Timestamp future = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.testing.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, future)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd-group: Group <x>", "Account 8", "8@server-id"); assertServerCommit(log.get(2), "Update group\n\nAdd-group: Group <y>\nAdd-group: Group <z>"); assertThat(log.stream().map(( c) -> c.committer.date).collect(toImmutableList())).named("%s", log).isOrdered(); assertThat(com.google.gerrit.common.TimeUtil.nowTs()).isLessThan(future); }
@org.junit.Test public void memberAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = GroupRebuilderTest.builder().group(g).members(member(g, 1)).memberAudit(addMember(g, 1, 8, t2), addAndRemoveMember(g, 2, 8, t1, 9, t3)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id"); assertCommit(log.get(2), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id"); assertCommit(log.get(3), "Update group\n\nRemove: Account 2 <2@server-id>", "Account 9", "9@server-id"); }
@org.junit.Test public void unauditedByIdAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd-group: Group <x>", "Account 8", "8@server-id"); assertServerCommit(log.get(2), "Update group\n\nAdd-group: Group <y>\nAdd-group: Group <z>"); }
@org.junit.Test public void redundantByIdAuditsAreIgnored() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t4 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t5 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId().byIdAudit(addById(g, "x", 8, t1), addById(g, "x", 8, t3), addById(g, "x", 9, t4), addAndRemoveById(g, "x", 8, t2, 9, t5)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd-group: Group <x>", "Account 8", "8@server-id"); assertCommit(log.get(2), "Update group\n\nRemove-group: Group <x>", "Account 9", "9@server-id"); }
@org.junit.Test public void unauditedMembershipsAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id"); assertServerCommit(log.get(2), "Update group\n\nAdd: Account 2 <2@server-id>\nAdd: Account 3 <3@server-id>"); }
@org.junit.Test public void auditsAtSameTimestampBrokenDownByUserAndType() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp ts = com.google.gerrit.common.TimeUtil.nowTs(); int user1 = 8; int user2 = 9; com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, user1, ts), addMember(g, 2, user2, ts), addMember(g, 3, user1, ts)).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", user1, ts), addById(g, "y", user2, ts), addById(g, "z", user1, ts)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(5); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), ("Update group\n" + (("\n" + "Add: Account 1 <1@server-id>\n") + "Add: Account 3 <3@server-id>")), "Account 8", "8@server-id"); assertCommit(log.get(2), "Update group\n\nAdd-group: Group <x>\nAdd-group: Group <z>", "Account 8", "8@server-id"); assertCommit(log.get(3), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 9", "9@server-id"); assertCommit(log.get(4), "Update group\n\nAdd-group: Group <y>", "Account 9", "9@server-id"); }
@org.junit.Test public void byIdAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = GroupRebuilderTest.builder().group(g).byId(byId(g, "x")).byIdAudit(addById(g, "x", 8, t2), addAndRemoveById(g, "y", 8, t1, 9, t3)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd-group: Group <y>", "Account 8", "8@server-id"); assertCommit(log.get(2), "Update group\n\nAdd-group: Group <x>", "Account 8", "8@server-id"); assertCommit(log.get(3), "Update group\n\nRemove-group: Group <y>", "Account 9", "9@server-id"); }
@org.junit.Test public void membersAndSubgroups() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2)).byId(byId(g, "x"), byId(g, "y")).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(2); assertServerCommit(log.get(0), "Create group"); assertServerCommit(log.get(1), ("Update group\n" + (((("\n" + "Add: Account 1 <1@server-id>\n") + "Add: Account 2 <2@server-id>\n") + "Add-group: Group <x>\n") + "Add-group: Group <y>"))); }
@org.junit.Test public void allGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); g.setDescription("Description"); g.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("owner")); g.setVisibleToAll(true); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertServerCommit(log.get(0), "Create group"); }
@org.junit.Test public void memberAuditLegacyRemoved() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 2)).memberAudit(addAndLegacyRemoveMember(g, 1, 8, com.google.gerrit.common.TimeUtil.nowTs()), addMember(g, 2, 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0), "Create group"); assertCommit(log.get(1), "Update group\n\nAdd: Account 1 <1@server-id>", "Account 8", "8@server-id"); assertCommit(log.get(2), "Update group\n\nRemove: Account 1 <1@server-id>", "Account 8", "8@server-id"); assertCommit(log.get(3), "Update group\n\nAdd: Account 2 <2@server-id>", "Account 8", "8@server-id"); }
@org.junit.Test public void minimalGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertCommit(log.get(0), "Create group", com.google.gerrit.server.group.db.SERVER_NAME, com.google.gerrit.server.group.db.SERVER_EMAIL); assertThat(logGroupNames()).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.project.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return fileContentUtil.getContent(rsrc.getProjectState(), rsrc.getRev(), rsrc.getPath(), null); }
@org.junit.Test public void byDescription() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroupWithDescription(name("group1"), "This is a test group."); com.google.gerrit.extensions.common.GroupInfo group2 = createGroupWithDescription(name("group2"), "ANOTHER TEST GROUP."); createGroupWithDescription(name("group3"), "Maintainers of project foo."); assertQuery("description:test", group1, group2); assertQuery("description:non-existing"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("description operator requires a value"); assertQuery("description:\"\""); }
@org.junit.Test public void bySubgroups() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(GroupField.SUBGROUP); assertFailingQuery("subgroup:someGroupName", "'subgroup' operator is not supported by group index version"); return; } com.google.gerrit.extensions.common.GroupInfo superParentGroup = createGroup(name("superParentGroup")); com.google.gerrit.extensions.common.GroupInfo parentGroup1 = createGroup(name("parentGroup1")); com.google.gerrit.extensions.common.GroupInfo parentGroup2 = createGroup(name("parentGroup2")); com.google.gerrit.extensions.common.GroupInfo subGroup = createGroup(name("subGroup")); gApi.groups().id(superParentGroup.id).addGroups(parentGroup1.id, parentGroup2.id); gApi.groups().id(parentGroup1.id).addGroups(subGroup.id); gApi.groups().id(parentGroup2.id).addGroups(subGroup.id); assertQuery(("subgroup:" + (subGroup.id)), parentGroup1, parentGroup2); assertQuery(("subgroup:" + (parentGroup1.id)), superParentGroup); gApi.groups().id(superParentGroup.id).addGroups(subGroup.id); gApi.groups().id(parentGroup1.id).removeGroups(subGroup.id); assertQuery(("subgroup:" + (subGroup.id)), superParentGroup, parentGroup2); }
@org.junit.Test public void byMember() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(GroupField.MEMBER); assertFailingQuery("member:someName", "'member' operator is not supported by group index version"); return; } com.google.gerrit.extensions.common.AccountInfo user1 = createAccount("user1", "User1", "user1@example.com"); com.google.gerrit.extensions.common.AccountInfo user2 = createAccount("user2", "User2", "user2@example.com"); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("group1"), user1); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2"), user2); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup(name("group3"), user1); assertQuery(("member:" + (user1.name)), group1, group3); assertQuery(("member:" + (user1.email)), group1, group3); gApi.groups().id(group3.id).removeMembers(user1.username); gApi.groups().id(group2.id).addMembers(user1.username); assertQuery(("member:" + (user1.name)), group1, group2); }
@org.junit.Test public void byInname() throws java.lang.Exception { java.lang.String namePart = getSanitizedMethodName(); namePart = com.google.common.base.CharMatcher.is('_').removeFrom(namePart); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(("group-" + namePart)); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup((("group-" + namePart) + "-2")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup((("group-" + namePart) + "3")); assertQuery(("inname:" + namePart), group1, group2, group3); assertQuery(("inname:" + (namePart.toUpperCase(java.util.Locale.US))), group1, group2, group3); assertQuery(("inname:" + (namePart.toLowerCase(java.util.Locale.US))), group1, group2, group3); }
@org.junit.Test public void byIsVisibleToAll() throws java.lang.Exception { assertQuery("is:visibletoall"); com.google.gerrit.extensions.common.GroupInfo groupThatIsVisibleToAll = createGroupThatIsVisibleToAll(name("group-that-is-visible-to-all")); createGroup(name("group")); assertQuery("is:visibletoall", groupThatIsVisibleToAll); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void deleteGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Not allowed to delete group branch."); branch(new com.google.gerrit.reviewdb.client.Branch.NameKey(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()))).delete(); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Branch \"" + (rsrc.getRef())) + "\" already exists")); }
com.google.gerrit.server.api.changes.CommentApiImpl create(com.google.gerrit.server.change.CommentResource c);
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Move Change").setTitle("Move change to a different branch").setVisible(and(change.getStatus().isOpen(), and(permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testCond(com.google.gerrit.server.change.CREATE_CHANGE), rsrc.permissions().database(dbProvider).testCond(com.google.gerrit.server.change.ABANDON)))); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getProjectState().getProject().getDescription()); }
private com.google.gerrit.server.project.ProjectResource checkExists() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((project) == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(name); } return project; }
com.google.gerrit.server.api.projects.ProjectApiImpl create(com.google.gerrit.server.project.ProjectResource project);
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || (!(com.google.gerrit.reviewdb.client.RefNames.isGroupRef(destBranch.get())))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException("group update not allowed"); }
public static AccountGroup.UUID make(java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent creator) { java.security.MessageDigest md = org.eclipse.jgit.lib.Constants.newMessageDigest(); md.update(org.eclipse.jgit.lib.Constants.encode((("group " + groupName) + "\n"))); md.update(org.eclipse.jgit.lib.Constants.encode((("creator " + (creator.toExternalString())) + "\n"))); md.update(org.eclipse.jgit.lib.Constants.encode(java.lang.String.valueOf(java.lang.Math.random()))); return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(org.eclipse.jgit.lib.ObjectId.fromRaw(md.digest()).name()); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Ancient group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId()) != null) ? ref.getObjectId().name() : null; info.canDelete = ((!(targets.contains(ref.getName()))) && (perm.testOrFalse(RefPermission.DELETE))) ? true : null; com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
com.google.gerrit.extensions.api.projects.BranchInfo toBranchInfo(com.google.gerrit.server.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.lib.Ref r = db.exactRef(rsrc.getRef()); if (r == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, com.google.common.collect.ImmutableList.of(r)).get(0); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> allBranches(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.util.List<org.eclipse.jgit.lib.Ref> refs; try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { java.util.Collection<org.eclipse.jgit.lib.Ref> heads = db.getRefDatabase().getRefs(Constants.R_HEADS).values(); refs = new java.util.ArrayList(((heads.size()) + 3)); refs.addAll(heads); refs.addAll(db.getRefDatabase().exactRef(Constants.HEAD, RefNames.REFS_CONFIG, RefNames.REFS_USERS_DEFAULT).values()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noGitRepository) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, refs); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.BranchInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring).regex(matchRegex).start(start).limit(limit).filter(allBranches(rsrc)); }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> toBranchInfo(com.google.gerrit.server.project.ProjectResource rsrc, java.util.List<org.eclipse.jgit.lib.Ref> refs) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Set<java.lang.String> targets = com.google.common.collect.Sets.newHashSetWithExpectedSize(1); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { targets.add(ref.getTarget().getName()); } } com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey()); java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> branches = new java.util.ArrayList(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { java.lang.String target = ref.getTarget().getName(); if (!(perm.ref(target).test(RefPermission.READ))) { continue; } if (target.startsWith(Constants.R_HEADS)) { target = target.substring(Constants.R_HEADS.length()); } com.google.gerrit.extensions.api.projects.BranchInfo b = new com.google.gerrit.extensions.api.projects.BranchInfo(); b.ref = ref.getName(); b.revision = target; branches.add(b); if (!(Constants.HEAD.equals(ref.getName()))) { b.canDelete = (perm.ref(ref.getName()).testOrFalse(RefPermission.DELETE)) ? true : null; } continue; } if (perm.ref(ref.getName()).test(RefPermission.READ)) { branches.add(createBranchInfo(perm.ref(ref.getName()), ref, rsrc.getProjectState(), rsrc.getUser(), targets)); } } java.util.Collections.sort(branches, new com.google.gerrit.server.project.ListBranches.BranchComparator()); return branches; }
@java.lang.Override public Response.Accepted apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) { com.google.gerrit.reviewdb.client.Project.NameKey project = resource.getNameKey(); com.google.gerrit.server.git.MultiProgressMonitor.Task mpt = new com.google.gerrit.server.git.MultiProgressMonitor(com.google.common.io.ByteStreams.nullOutputStream(), "Reindexing project").beginSubTask("", MultiProgressMonitor.UNKNOWN); com.google.gerrit.server.index.change.AllChangesIndexer allChangesIndexer = allChangesIndexerProvider.get(); allChangesIndexer.setVerboseOut(NullOutputStream.INSTANCE); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<java.lang.Void> ignored = executor.submit(allChangesIndexer.reindexProject(indexer, project, mpt, mpt)); return com.google.gerrit.extensions.restapi.Response.accepted((("Project " + project) + " submitted for reindexing")); }
@org.kohsuke.args4j.Option(name = "--owned-by", usage = "list groups owned by the given group uuid") public void setOwnedBy(java.lang.String ownedBy) { this.ownedBy = ownedBy; }
@org.kohsuke.args4j.Option(name = "--group", aliases = { "-g" }, usage = "group to inspect") public void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { groupsToInspect.add(uuid); }
@org.kohsuke.args4j.Option(name = "-o", usage = "Output options per group") void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--regex", aliases = { "-r" }, metaVar = "REGEX", usage = "match group regex") public void setMatchRegex(java.lang.String matchRegex) { this.matchRegex = matchRegex; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); permissionBackend.user(user).project(resource.getNameKey()).ref(tag).check(RefPermission.DELETE); deleteRefFactory.create(resource).ref(tag).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.index.query.QueryParseException getExceptionForUnsupportedOperator(java.lang.String operatorName) { return new com.google.gerrit.index.query.QueryParseException(java.lang.String.format("'%s' operator is not supported by group index version", operatorName)); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username must be set"); } com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, user.getUserName())); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId newExtId = com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword); externalIdsUpdate.create().upsert(newExtId); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { int id = config.getInt(com.google.gerrit.server.group.db.GroupConfigEntry.SECTION_NAME, super.keyName, (-1)); if (id < 0) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("ID of the group %s must not be negative, found %d", groupUuid.get(), id)); } group.setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(id)); }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.project.ChildProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((recursive) || (rsrc.isDirectChild())) { return json.format(rsrc.getChild().getProject()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getChild().getName()); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.GroupInfo> apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new); return getDirectSubgroups(group, rsrc.getControl()); }
private java.util.List<com.google.gerrit.reviewdb.client.Account.Id> suggestAccounts(com.google.gerrit.server.change.SuggestReviewers suggestReviewers) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.metrics.Timer0.Context ctx = metrics.queryAccountsLatency.start()) { try { com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.account.AccountState> result = queryProvider.get().setUserProvidedLimit(((suggestReviewers.getLimit()) * (com.google.gerrit.server.ReviewersUtil.CANDIDATE_LIST_MULTIPLIER))).query(com.google.gerrit.server.query.account.AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()))); return result.entities().stream().map(( a) -> a.getAccount().getId()).collect(java.util.stream.Collectors.toList()); } catch (com.google.gerrit.index.query.QueryParseException e) { return com.google.common.collect.ImmutableList.of(); } } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.SubgroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddSubgroups.PutSubgroup create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.group.AddSubgroups.PutSubgroup(addSubgroups, id.get()); }
@java.lang.Override public com.google.gerrit.server.group.SubgroupResource parse(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.common.data.GroupDescription.Internal parent = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); com.google.gerrit.common.data.GroupDescription.Basic member = groupsCollection.parse(TopLevelResource.INSTANCE, id).getGroup(); if ((resource.getControl().canSeeGroup()) && (com.google.gerrit.server.group.SubgroupsCollection.isSubgroup(parent, member))) { return new com.google.gerrit.server.group.SubgroupResource(resource, member); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() { return list; }
com.google.gerrit.server.api.changes.DraftApiImpl create(com.google.gerrit.server.change.DraftCommentResource d);
@org.kohsuke.args4j.Option(name = "--match", aliases = { "-m" }, metaVar = "MATCH", usage = "match group substring") public void setMatchSubstring(java.lang.String matchSubstring) { this.matchSubstring = matchSubstring; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.common.GroupOptionsInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("options are required"); } if ((input.visibleToAll) == null) { input.visibleToAll = false; } if ((internalGroup.isVisibleToAll()) != (input.visibleToAll)) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setVisibleToAll(input.visibleToAll).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } } com.google.gerrit.extensions.common.GroupOptionsInfo options = new com.google.gerrit.extensions.common.GroupOptionsInfo(); if (input.visibleToAll) { options.visibleToAll = true; } return options; }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource resource) { com.google.gerrit.reviewdb.client.Project project = resource.getProjectState().getProject(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = project.getParent(allProjectsName); return parentName != null ? parentName.get() : ""; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.GarbageCollect.Input input) { com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getNameKey(); if (input.async) { return applyAsync(project, input); } return applySync(project, input); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Run GC").setTitle("Triggers the Git Garbage Collection for this project.").setVisible(canGC); }
protected com.google.gerrit.common.data.ContributorAgreement configureContributorAgreement(boolean autoVerify) throws java.lang.Exception { com.google.gerrit.common.data.ContributorAgreement ca; if (autoVerify) { java.lang.String g = createGroup("cla-test-group"); com.google.gerrit.extensions.api.groups.GroupApi groupApi = gApi.groups().id(g); groupApi.description("CLA test group"); com.google.gerrit.server.group.InternalGroup caGroup = group(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupApi.detail().id)); com.google.gerrit.common.data.GroupReference groupRef = new com.google.gerrit.common.data.GroupReference(caGroup.getGroupUUID(), caGroup.getName()); com.google.gerrit.common.data.PermissionRule rule = new com.google.gerrit.common.data.PermissionRule(groupRef); rule.setAction(PermissionRule.Action.ALLOW); ca = new com.google.gerrit.common.data.ContributorAgreement("cla-test"); ca.setAutoVerify(groupRef); ca.setAccepted(com.google.common.collect.ImmutableList.of(rule)); } else { ca = new com.google.gerrit.common.data.ContributorAgreement("cla-test-no-auto-verify"); } ca.setDescription("description"); ca.setAgreementUrl("agreement-url"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig(); cfg.replace(ca); saveProjectConfig(allProjects, cfg); return ca; }
@java.lang.Override public com.google.gerrit.server.change.FileResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.change.FileResource(rev, id.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FileResource>> views() { return views; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.extensions.api.projects.BanCommitInput input = com.google.gerrit.extensions.api.projects.BanCommitInput.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), input); printCommits(r.newlyBanned, "The following commits were banned"); printCommits(r.alreadyBanned, "The following commits were already banned"); printCommits(r.ignored, "The following ids do not represent commits and were ignored"); } catch (java.lang.Exception e) { throw die(e); } }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ownerGroupUuid = config.getString(com.google.gerrit.server.group.db.GroupConfigEntry.SECTION_NAME, null, super.keyName); if (com.google.common.base.Strings.isNullOrEmpty(ownerGroupUuid)) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Owner UUID of the group %s must be defined", groupUuid.get())); } group.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(ownerGroupUuid)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteBranchesInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.branches) == null)) || (input.branches.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("branches must be specified"); } deleteRefFactory.create(project).refs(input.branches).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.DraftCommentResource rsrc, DraftInput in) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException { if (((in == null) || ((in.message) == null)) || (in.message.trim().isEmpty())) { return delete.applyImpl(updateFactory, rsrc, null); } else if (((in.id) != null) && (!(rsrc.getId().equals(in.id)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("id must match URL"); } else if (((in.line) != null) && ((in.line) < 0)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must be >= 0"); } else if ((((in.line) != null) && ((in.range) != null)) && ((in.line) != (in.range.endLine))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("range endLine must be on the same line as the comment"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.PutDraftComment.Op op = new com.google.gerrit.server.change.PutDraftComment.Op(rsrc.getComment().key, in); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(commentJson.get().setFillAccounts(false).newCommentFormatter().format(op.comment)); } }
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(allUsersRepo, groupUuid); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); if (!(groupConfig.getLoadedGroup().isPresent())) { if (groupsMigration.readFromNoteDb()) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupUuid); } return java.util.Optional.empty(); } com.google.gerrit.server.group.InternalGroup originalGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = null; if (groupUpdate.getName().isPresent()) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = originalGroup.getNameKey(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey newName = groupUpdate.getName().get(); groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName); } commit(allUsersRepo, groupConfig, groupNameNotes); com.google.gerrit.server.group.InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Updated group wasn't automatically loaded")); return java.util.Optional.of(com.google.gerrit.server.group.db.GroupsUpdate.getUpdateResult(originalGroup, updatedGroup)); } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddGroupsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log add groups to group event", e); } } }
private void addMembers(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input input = AddMembers.Input.fromMembers(initialMembers.stream().map(java.lang.Object::toString).collect(java.util.stream.Collectors.toList())); addMembers.apply(rsrc, input); }
private void addSubgroups(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input input = AddSubgroups.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).collect(java.util.stream.Collectors.toList())); addSubgroups.apply(rsrc, input); }
@org.kohsuke.args4j.Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { initialGroups.add(id); }
@java.lang.Override public void replace(com.google.gerrit.server.group.InternalGroup group) throws java.io.IOException { io.searchbox.core.Bulk bulk = new io.searchbox.core.Bulk.Builder().defaultIndex(indexName).defaultType(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS).addAction(insert(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS, group)).refresh(true).build(); io.searchbox.client.JestResult result = client.execute(bulk); if (!(result.isSucceeded())) { throw new java.io.IOException(java.lang.String.format("Failed to replace group %s in index %s: %s", group.getGroupUUID().get(), indexName, result.getErrorMessage())); } }
private void reportGroupsAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupUuidList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = groupUuidList.stream().map(( uuid) -> groupCache.get(uuid).map(com.google.gerrit.server.group.InternalGroup::getName)).flatMap(Streams::stream).collect(java.util.stream.Collectors.joining(", ")); out.write(java.lang.String.format("Groups %s group %s: %s\n", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gerrit.sshd.commands.UnloggedFailure, java.lang.Exception { try { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid : groups) { com.google.gerrit.server.group.GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(groupUuid.get())); if (!(accountsToRemove.isEmpty())) { deleteMembers.apply(resource, fromMembers(accountsToRemove)); reportMembersAction("removed from", resource, accountsToRemove); } if (!(groupsToRemove.isEmpty())) { deleteSubgroups.apply(resource, fromGroups(groupsToRemove)); reportGroupsAction("excluded from", resource, groupsToRemove); } if (!(accountsToAdd.isEmpty())) { addMembers.apply(resource, fromMembers(accountsToAdd)); reportMembersAction("added to", resource, accountsToAdd); } if (!(groupsToInclude.isEmpty())) { addSubgroups.apply(resource, fromGroups(groupsToInclude)); reportGroupsAction("included to", resource, groupsToInclude); } } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountCache.get(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(", ")); out.write(java.lang.String.format("Members %s group %s: %s\n", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project \"" + (resource.getName())) + "\" already exists")); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { com.google.gerrit.extensions.api.projects.ConfigInput configInput = new com.google.gerrit.extensions.api.projects.ConfigInput(); configInput.requireChangeId = requireChangeID; configInput.submitType = submitType; configInput.useContentMerge = contentMerge; configInput.useContributorAgreements = contributorAgreements; configInput.useSignedOffBy = signedOffBy; configInput.state = state.getProject().getState(); configInput.maxObjectSizeLimit = maxObjectSizeLimit; if ((com.google.common.base.Strings.emptyToNull(projectDescription)) != null) { configInput.description = projectDescription; } else { configInput.description = projectState.getProject().getDescription(); } try { putConfig.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), configInput); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw die(e); } }
com.google.gerrit.server.api.groups.GroupApiImpl create(com.google.gerrit.server.group.GroupResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo owner() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getOwner.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot get group owner", e); } }
@java.lang.Override public void options(com.google.gerrit.extensions.common.GroupOptionsInfo options) throws com.google.gerrit.extensions.restapi.RestApiException { try { putOptions.apply(rsrc, options); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put group options", e); } }
@java.lang.Override public void index() throws com.google.gerrit.extensions.restapi.RestApiException { try { index.apply(rsrc, new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot index group", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> members(boolean recursive) throws com.google.gerrit.extensions.restapi.RestApiException { listMembers.setRecursive(recursive); try { return listMembers.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot list group members", e); } }
@java.lang.Override public void removeMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot remove group members", e); } }
@java.lang.Override public void name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.NameInput in = new com.google.gerrit.extensions.common.NameInput(); in.name = name; try { putName.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put group name", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo detail() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDetail.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve group", e); } }
@java.lang.Override public void addMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { addMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot add group members", e); } }
@java.lang.Override public void description(java.lang.String description) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.DescriptionInput in = new com.google.gerrit.extensions.common.DescriptionInput(); in.description = description; try { putDescription.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put group description", e); } }
@org.kohsuke.args4j.Option(name = "--member", aliases = { "-m" }, metaVar = "USERNAME", usage = "initial set of users to become members of the group") void addMember(com.google.gerrit.reviewdb.client.Account.Id id) { initialMembers.add(id); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { com.google.gerrit.server.group.GroupResource rsrc = createGroup(); if (!(initialMembers.isEmpty())) { addMembers(rsrc); } if (!(initialGroups.isEmpty())) { addSubgroups(rsrc); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e); } }
private com.google.gerrit.server.group.GroupResource createGroup() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.groups.GroupInput input = new com.google.gerrit.extensions.api.groups.GroupInput(); input.description = groupDescription; input.visibleToAll = visibleToAll; if ((ownerGroupId) != null) { input.ownerId = java.lang.String.valueOf(ownerGroupId.get()); } com.google.gerrit.extensions.common.GroupInfo group = createGroupFactory.create(groupName).apply(TopLevelResource.INSTANCE, input); return groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(group.id)); }
@java.lang.Override public com.google.gerrit.extensions.api.groups.GroupApi create(com.google.gerrit.extensions.api.groups.GroupInput in) throws com.google.gerrit.extensions.restapi.RestApiException { if ((checkNotNull(in, "GroupInput").name) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("GroupInput must specify name"); } try { com.google.gerrit.server.group.CreateGroup impl = createGroup.create(in.name); permissionBackend.user(user).checkAny(com.google.gerrit.server.permissions.GlobalPermission.fromAnnotation(impl.getClass())); com.google.gerrit.extensions.common.GroupInfo info = impl.apply(TopLevelResource.INSTANCE, in); return id(info.id); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot create group " + (in.name)), e); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPNAMES); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); java.util.Set<com.google.gerrit.common.data.GroupReference> groupReferences = new java.util.LinkedHashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.common.data.GroupReference groupReference = com.google.gerrit.server.group.db.GroupNameNotes.getGroupReference(reader, note.getData()); boolean result = groupReferences.add(groupReference); if (!result) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning("The UUID of group %s (%s) is duplicate in group name notes", groupReference.getName(), groupReference.getUUID()); } } return com.google.common.collect.ImmutableSet.copyOf(groupReferences); } }
private java.lang.String getCommitMessage() { if ((oldGroupName.isPresent()) && (newGroupName.isPresent())) { return java.lang.String.format("Rename group from '%s' to '%s'", oldGroupName.get(), newGroupName.get()); } if (newGroupName.isPresent()) { return java.lang.String.format("Create group '%s'", newGroupName.get()); } if (oldGroupName.isPresent()) { return java.lang.String.format("Delete group '%s'", oldGroupName.get()); } return "No-op"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource resource, com.google.gerrit.extensions.common.AgreementInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("contributor agreements disabled"); } if ((self.get()) != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to enter contributor agreement"); } java.lang.String agreementName = com.google.common.base.Strings.nullToEmpty(input.name); com.google.gerrit.common.data.ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName); if (ca == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("contributor agreement not found"); } if ((ca.getAutoVerify()) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("cannot enter a non-autoVerify agreement"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = ca.getAutoVerify().getUUID(); if (uuid == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("autoverify group uuid not found"); } com.google.gerrit.reviewdb.client.Account account = self.get().getAccount(); try { addMembers.addMembers(uuid, com.google.common.collect.ImmutableSet.of(account.getId())); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("autoverify group not found"); } agreementSignup.fire(account, agreementName); return com.google.gerrit.extensions.restapi.Response.ok(agreementName); }
@org.junit.Test public void sharedGroupID() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "id", g2.groupId); cfg.setString("group", null, "ownerGroupUuid", gAdmin.id); updateGroupFile(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), GroupConfig.GROUP_CONFIG_FILE, cfg.toText()); assertError("shared group id"); }
@org.junit.Test public void missingGroupNameRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(RefNames.REFS_GROUPNAMES); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("refs/meta/group-names does not exist"); }
@org.junit.Test public void nameWithoutGroupRef() throws java.lang.Exception { java.lang.String bogusName = "bogus name"; org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString("group", null, "uuid", com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID); config.setString("group", null, "name", bogusName); updateGroupFile(RefNames.REFS_GROUPNAMES, com.google.gerrit.server.group.db.GroupNameNotes.getNoteKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(bogusName)).getName(), config.toText()); assertError("entry missing as group ref"); }
@org.junit.Test public void missingNameEntry() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefRename ru = repo.renameRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID))); org.eclipse.jgit.lib.RefUpdate.Result result = ru.rename(); assertThat(result).isEqualTo(Result.RENAMED); } assertError((("group " + (com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID)) + " has no entry in name map")); }
@org.junit.Test public void unknownOwnerGroup() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "id", g1.groupId); cfg.setString("group", null, "ownerGroupUuid", com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID); updateGroupFile(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), GroupConfig.GROUP_CONFIG_FILE, cfg.toText()); assertError("nonexistent owner group"); }
@org.junit.Test public void missingGroupRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("missing as group ref"); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo get() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getGroup.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve group", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { if (name == null) { return java.util.Optional.empty(); } try { return byName.get(name.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot look up group %s by name", name.get()), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { try { return byId.get(groupId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(("Cannot load group " + groupId), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { if (groupUuid == null) { return java.util.Optional.empty(); } try { return byUUID.get(groupUuid.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot look up group %s by uuid", groupUuid.get()), e); return java.util.Optional.empty(); } }
private void index(com.google.gerrit.server.project.ProjectState projectState) { try { index.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), null); } catch (java.lang.Exception e) { writeError("error", java.lang.String.format("Unable to index %s: %s", projectState.getName(), e.getMessage())); } }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); if ((ref != null) && (!(visibleTags(resource.getProjectState(), repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty()))) { return com.google.gerrit.server.project.ListTags.createTagInfo(permissionBackend.user(resource.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, resource.getNameKey(), links); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey()); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getProjectState(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(perm.ref(ref.getName()), ref, rw, resource.getNameKey(), links)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.Set<java.lang.String>> apply(com.google.gerrit.server.change.ChangeResource req) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = req.getNotes().load(); java.util.Set<java.lang.String> hashtags = notes.getHashtags(); if (hashtags == null) { hashtags = java.util.Collections.emptySet(); } return com.google.gerrit.extensions.restapi.Response.ok(hashtags); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void createGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); assertCreateFails(new com.google.gerrit.reviewdb.client.Branch.NameKey(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("foo"))), com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()), com.google.gerrit.extensions.restapi.ResourceConflictException.class, "Not allowed to create group branch."); }
private java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> list(com.google.gerrit.server.api.groups.ListRequest req) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.restapi.TopLevelResource tlr = com.google.gerrit.extensions.restapi.TopLevelResource.INSTANCE; com.google.gerrit.server.group.ListGroups list = listGroups.get(); list.setOptions(req.getOptions()); for (java.lang.String project : req.getProjects()) { try { com.google.gerrit.server.project.ProjectResource rsrc = projects.parse(tlr, com.google.gerrit.extensions.restapi.IdString.fromDecoded(project)); list.addProject(rsrc.getProjectState()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Error looking up project " + project), e); } } for (java.lang.String group : req.getGroups()) { list.addGroup(groups.parse(group).getGroupUUID()); } list.setVisibleToAll(req.getVisibleToAll()); if ((req.getOwnedBy()) != null) { list.setOwnedBy(req.getOwnedBy()); } if ((req.getUser()) != null) { try { list.setUser(accounts.parse(req.getUser()).getAccountId()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Error looking up user " + (req.getUser())), e); } } list.setOwned(req.getOwned()); list.setLimit(req.getLimit()); list.setStart(req.getStart()); list.setMatchSubstring(req.getSubstring()); list.setMatchRegex(req.getRegex()); list.setSuggest(req.getSuggest()); try { return list.apply(tlr); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot list groups", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.List<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.extensions.restapi.Response.ok(java.util.Collections.emptyList()); } com.google.gerrit.server.account.AccountLoader accountLoader = accountLoaderFactory.create(true); java.util.List<com.google.gerrit.extensions.common.AccountInfo> infos = pastAssignees.stream().map(accountLoader::get).collect(java.util.stream.Collectors.toList()); accountLoader.fill(); return com.google.gerrit.extensions.restapi.Response.ok(infos); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData> visibleto(java.lang.String who) throws com.google.gerrit.index.query.QueryParseException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (isSelf(who)) { return is_visible(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); if (!(m.isEmpty())) { java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { return visibleto(args.userFactory.create(id)); } return com.google.gerrit.index.query.Predicate.or(p); } java.util.Collection<com.google.gerrit.common.data.GroupReference> suggestions = args.groupBackend.suggest(who, null); if (!(suggestions.isEmpty())) { java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> ids = new java.util.HashSet<>(); for (com.google.gerrit.common.data.GroupReference ref : suggestions) { ids.add(ref.getUUID()); } return visibleto(new com.google.gerrit.server.query.change.SingleGroupUser(ids)); } throw error((("No user or group matches \"" + who) + "\".")); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } else if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.common.data.GroupDescription.Basic group = parseId(id.get()); if (group == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id.get()); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(group); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.group.GroupResource(ctl); }
public void visit(org.eclipse.jgit.revwalk.RevCommit c) { checkState((!(done)), "visit() called after getGroups()"); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> interestingParents = getInterestingParents(c); if ((interestingParents.size()) == 0) { groups.put(c, c.name()); return; } else if ((interestingParents.size()) == 1) { groups.putAll(c, groups.get(interestingParents.iterator().next())); return; } java.util.Set<java.lang.String> thisCommitGroups = new java.util.TreeSet<>(); java.util.Set<java.lang.String> parentGroupsNewInThisPush = com.google.common.collect.Sets.newLinkedHashSetWithExpectedSize(interestingParents.size()); for (org.eclipse.jgit.revwalk.RevCommit p : interestingParents) { java.util.Collection<java.lang.String> parentGroups = groups.get(p); if (parentGroups.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format("no group assigned to parent %s of commit %s", p.name(), c.name())); } for (java.lang.String parentGroup : parentGroups) { if (isGroupFromExistingPatchSet(p, parentGroup)) { thisCommitGroups.add(parentGroup); } else { parentGroupsNewInThisPush.add(parentGroup); } } } java.lang.Iterable<java.lang.String> toAlias; if (thisCommitGroups.isEmpty()) { java.lang.String firstParentGroup = parentGroupsNewInThisPush.iterator().next(); thisCommitGroups = com.google.common.collect.ImmutableSet.of(firstParentGroup); toAlias = com.google.common.collect.Iterables.skip(parentGroupsNewInThisPush, 1); } else { toAlias = parentGroupsNewInThisPush; } groups.putAll(c, thisCommitGroups); for (java.lang.String pg : toAlias) { groupAliases.putAll(pg, thisCommitGroups); } }
private org.eclipse.jgit.lib.ObjectId parseGroup(org.eclipse.jgit.lib.ObjectId forCommit, java.lang.String group) { try { return org.eclipse.jgit.lib.ObjectId.fromString(group); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.git.GroupCollector.log.warn("group for commit {} is not a SHA-1: {}", forCommit.name(), group); return null; } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc); }
@org.junit.Test public void createGroupAsUserIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-group"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit = createExpMemberAudit(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit); }
private com.google.gerrit.server.group.InternalGroup updateGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.lang.Exception { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(allUsersRepo, uuid); groupConfig.setGroupUpdate(groupUpdate, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName); groupConfig.commit(createMetaDataUpdate(userIdent)); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("updated group failed")); }
@org.junit.Test public void addMultiSubgroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-group"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroup subgroup1 = createGroupAsUser(2, "test-group-2"); com.google.gerrit.server.group.InternalGroup subgroup2 = createGroupAsUser(3, "test-group-3"); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid1 = subgroup1.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid2 = subgroup2.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid1, subgroupUuid2)); assertTipCommit(uuid, ((("Update group\n" + "\n") + (java.lang.String.format("Add-group: Group <%s>\n", subgroupUuid1))) + (java.lang.String.format("Add-group: Group <%s>", subgroupUuid2)))); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit1 = createExpGroupAudit(group.getId(), subgroupUuid1, userId, getTipTimestamp(uuid)); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit2 = createExpGroupAudit(group.getId(), subgroupUuid2, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); }
@org.junit.Test public void createGroupAsServerIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroup(1, "test-group", serverIdent, null); assertThat(auditLogReader.getMembersAudit(allUsersRepo, group.getGroupUUID())).hasSize(0); }
private com.google.gerrit.server.group.InternalGroup createGroup(int next, java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent authorIdent, com.google.gerrit.reviewdb.client.Account.Id authorId) throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = com.google.gerrit.server.group.db.InternalGroupCreation.builder().setGroupUUID(com.google.gerrit.server.account.GroupUUID.make(groupName, serverIdent)).setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName)).setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(next)).build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = (authorIdent.equals(serverIdent)) ? com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setDescription("Groups").build() : com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setDescription("Groups").setMemberModification(( members) -> com.google.common.collect.ImmutableSet.of(authorId)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName); org.eclipse.jgit.revwalk.RevCommit commit = groupConfig.commit(createMetaDataUpdate(authorIdent)); assertCreateGroup(authorIdent, commit); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("create group failed")); }
private void assertCreateGroup(org.eclipse.jgit.lib.PersonIdent authorIdent, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { if (authorIdent.equals(serverIdent)) { assertServerCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), "Create group"); } else { assertCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), java.lang.String.format("Create group\n\nAdd: Account %s <%s@%s>", userId, userId, com.google.gerrit.server.group.db.SERVER_ID), getAccountName(userId), getAccountEmail(userId)); } }
void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException;
@org.junit.Test public void addAndRemoveSubgroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-group"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroup subgroup = createGroupAsUser(2, "test-group-2"); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid = subgroup.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format("Update group\n\nAdd-group: Group <%s>", subgroupUuid)); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit = createExpGroupAudit(group.getId(), subgroupUuid, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit); removeSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format("Update group\n\nRemove-group: Group <%s>", subgroupUuid)); expAudit.removed(userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit); }
@org.junit.Test public void addMultiMembers() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-group"); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit1 = createExpMemberAudit(groupId, userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id1 = new com.google.gerrit.reviewdb.client.Account.Id(100002); com.google.gerrit.reviewdb.client.Account.Id id2 = new com.google.gerrit.reviewdb.client.Account.Id(100003); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id1, id2)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit2 = createExpMemberAudit(groupId, id1, userId, getTipTimestamp(uuid)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit3 = createExpMemberAudit(groupId, id2, userId, getTipTimestamp(uuid)); assertTipCommit(uuid, ("Update group\n" + (("\n" + "Add: Account 100002 <100002@server-id>\n") + "Add: Account 100003 <100003@server-id>"))); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2, expAudit3).inOrder(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.CommitResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { if (com.google.gerrit.reviewdb.client.Patch.isMagic(id.get())) { return new com.google.gerrit.server.project.FileResource(parent.getProjectState(), parent.getCommit(), id.get()); } return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), parent.getCommit(), id.get()); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in._oneMember = id; try { java.util.List<com.google.gerrit.extensions.common.AccountInfo> list = put.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gwtorm.server.OrmException { return get.apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return list.get().toBranchInfo(rsrc); }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(org.eclipse.jgit.lib.Repository allUsersRepo, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Created group wasn't automatically loaded")); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.receive.ReceiveCommits.isConfig(cmd)) { logDebug("Reloading project in cache"); try { projectCache.evict(project); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(("Cannot evict from project cache, name key: " + (project.getName())), e); } com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug("Updating project description"); repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(("cannot update description of " + (project.getName())), e); } if (allProjectsName.equals(project.getNameKey())) { try { createGroupPermissionSyncer.syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.error("Can't sync create group permissions", e); } } } }
@java.lang.Override public com.google.gerrit.server.project.RepositoryStatistics apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); return new com.google.gerrit.server.project.RepositoryStatistics(gc.getStatistics()); } catch (org.eclipse.jgit.api.errors.GitAPIException | org.eclipse.jgit.api.errors.JGitInternalException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getName()); } }
@org.junit.Test public void addAndRemoveMember() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-group"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit1 = createExpMemberAudit(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(100002); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit2 = createExpMemberAudit(group.getId(), id, userId, getTipTimestamp(uuid)); assertTipCommit(uuid, "Update group\n\nAdd: Account 100002 <100002@server-id>"); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); removeMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); assertTipCommit(uuid, "Update group\n\nRemove: Account 100002 <100002@server-id>"); expAudit2.removed(userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); }
static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM); java.lang.String name = com.google.common.base.Strings.nullToEmpty(config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM)); if (uuid == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("UUID for group '%s' must be defined", name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.FixResource fixResource, java.lang.Void nothing) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.RevisionResource revisionResource = fixResource.getRevisionResource(); com.google.gerrit.reviewdb.client.Project.NameKey project = revisionResource.getProject(); com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(project); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); org.eclipse.jgit.lib.ObjectId patchSetCommitId = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); try (org.eclipse.jgit.lib.Repository repository = gitRepositoryManager.openRepository(project)) { java.util.List<com.google.gerrit.server.edit.tree.TreeModification> treeModifications = fixReplacementInterpreter.toTreeModifications(repository, projectState, patchSetCommitId, fixResource.getFixReplacements()); com.google.gerrit.server.edit.ChangeEdit changeEdit = changeEditModifier.combineWithModifiedPatchSetTree(repository, revisionResource.getNotes(), patchSet, treeModifications); return com.google.gerrit.extensions.restapi.Response.ok(changeEditJson.toEditInfo(changeEdit, false)); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
com.google.gerrit.server.api.projects.DashboardApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String id);
public com.google.gerrit.server.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String reviewer = input.reviewer; com.google.gerrit.extensions.client.ReviewerState state = input.state(); com.google.gerrit.extensions.api.changes.NotifyHandling notify = input.notify; com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify = null; try { accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { return fail(reviewer, e.getMessage()); } boolean confirmed = input.confirmed(); boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail(); com.google.gerrit.server.change.PostReviewers.Addition byAccountId = addByAccountId(reviewer, rsrc, state, notify, accountsToNotify, allowGroup, allowByEmail); if (byAccountId != null) { return byAccountId; } com.google.gerrit.server.change.PostReviewers.Addition wholeGroup = addWholeGroup(reviewer, rsrc, state, notify, accountsToNotify, confirmed, allowGroup, allowByEmail); if (wholeGroup != null) { return wholeGroup; } return addByEmail(reviewer, rsrc, state, notify, accountsToNotify); }
private java.lang.String createCommitMessage(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> originalMembers, java.util.Optional<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id>> updatedMembers, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> originalSubgroups, java.util.Optional<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>> updatedSubgroups) { java.lang.String summaryLine = (groupCreation.isPresent()) ? "Create group" : "Update group"; java.util.StringJoiner footerJoiner = new java.util.StringJoiner("\n", "\n\n", ""); footerJoiner.setEmptyValue(""); getCommitFooterForRename().ifPresent(footerJoiner::add); updatedMembers.ifPresent(( newMembers) -> getCommitFootersForMemberModifications(originalMembers, newMembers).forEach(footerJoiner::add)); updatedSubgroups.ifPresent(( newSubgroups) -> getCommitFootersForSubgroupModifications(originalSubgroups, newSubgroups).forEach(footerJoiner::add)); java.lang.String footer = footerJoiner.toString(); return summaryLine + footer; }
@java.lang.Override protected void run() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.HeadInput input = new com.google.gerrit.extensions.api.projects.HeadInput(); input.ref = newHead; try { setHead.apply(new com.google.gerrit.server.project.ProjectResource(project, user), input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw die(e); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.DraftCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> getChildrenForReparenting(com.google.gerrit.server.project.ProjectState parent) throws com.google.gerrit.server.permissions.PermissionBackendException { final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> childProjects = new java.util.ArrayList<>(); final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> excluded = new java.util.ArrayList(excludedChildren.size()); for (com.google.gerrit.server.project.ProjectState excludedChild : excludedChildren) { excluded.add(excludedChild.getProject().getNameKey()); } final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> automaticallyExcluded = new java.util.ArrayList(excludedChildren.size()); if ((newParentKey) != null) { automaticallyExcluded.addAll(getAllParents(newParentKey)); } for (com.google.gerrit.extensions.common.ProjectInfo child : listChildProjects.apply(new com.google.gerrit.server.project.ProjectResource(parent, user))) { final com.google.gerrit.reviewdb.client.Project.NameKey childName = new com.google.gerrit.reviewdb.client.Project.NameKey(child.name); if (!(excluded.contains(childName))) { if (!(automaticallyExcluded.contains(childName))) { childProjects.add(childName); } else { stdout.println((((((("Automatically excluded '" + childName) + "' ") + "from reparenting because it is in the parent ") + "line of the new parent '") + (newParentKey)) + "'.")); } } } return childProjects; }
public com.google.gerrit.extensions.common.AgreementInfo format(com.google.gerrit.common.data.ContributorAgreement ca) { com.google.gerrit.extensions.common.AgreementInfo info = new com.google.gerrit.extensions.common.AgreementInfo(); info.name = ca.getName(); info.description = ca.getDescription(); info.url = ca.getAgreementUrl(); com.google.gerrit.common.data.GroupReference autoVerifyGroup = ca.getAutoVerify(); if ((autoVerifyGroup != null) && (self.get().isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser user = identifiedUserFactory.create(self.get().getAccountId()); try { com.google.gerrit.server.account.GroupControl gc = genericGroupControlFactory.controlFor(user, autoVerifyGroup.getUUID()); com.google.gerrit.server.group.GroupResource group = new com.google.gerrit.server.group.GroupResource(gc); info.autoVerifyGroup = groupJson.format(group); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.config.AgreementJson.log.warn((((("autoverify group \"" + (autoVerifyGroup.getName())) + "\" does not exist, referenced in CLA \"") + (ca.getName())) + "\"")); } } return info; }
public static com.google.gerrit.server.project.DashboardResource projectDefault(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) { return new com.google.gerrit.server.project.DashboardResource(projectState, user, null, null, null, true); }
@java.lang.Override public com.google.gerrit.extensions.common.RobotCommentInfo apply(com.google.gerrit.server.change.RobotCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newRobotCommentFormatter().format(rsrc.getComment()); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gwtorm.server.OrmException { return json.format(resource.getGroup()); }
@org.junit.Test public void createProjectWithNonExistingOwner_UnprocessableEntity() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name("newProjectName"); in.owners = java.util.Collections.singletonList("non-existing-group"); assertCreateFails(in, com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); }
@org.kohsuke.args4j.Option(name = "--has-acl-for", metaVar = "GROUP", usage = "displays only projects on which access rights for this group are directly assigned") public void setGroupUuid(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { this.groupUuid = groupUuid; }
com.google.gerrit.server.api.projects.TagApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input in = new com.google.gerrit.server.group.AddSubgroups.Input(); in.groups = com.google.common.collect.ImmutableList.of(id); try { java.util.List<com.google.gerrit.extensions.common.GroupInfo> list = addSubgroups.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.SubgroupResource resource, com.google.gerrit.server.group.AddSubgroups.Input input) throws com.google.gwtorm.server.OrmException { return get.get().apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.CommentResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.CommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByPatchSet(dbProvider.get(), notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.CommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public static com.google.gerrit.server.project.FileResource create(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.project.ProjectState projectState, org.eclipse.jgit.lib.ObjectId rev, java.lang.String path) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectState.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree(rev); if ((org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree)) != null) { return new com.google.gerrit.server.project.FileResource(projectState, rev, path); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, git)) { md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); md.setMessage(com.google.gerrit.server.schema.Schema_164.COMMIT_MSG); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection groups = config.getAccessSection(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), true); com.google.gerrit.server.schema.AclUtil.grant(config, groups, Permission.READ, false, true, systemGroupBackend.getGroup(com.google.gerrit.server.schema.REGISTERED_USERS)); config.commit(md); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Failed to grant read permissions on group branches", e); } }
private com.google.gerrit.server.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
@java.lang.Override public void setDefault() throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInput(); input.id = id; try { set.apply(com.google.gerrit.server.project.DashboardResource.projectDefault(project.getProjectState(), project.getUser()), input); } catch (java.lang.Exception e) { java.lang.String msg = java.lang.String.format("Cannot %s default dashboard", ((id) != null ? "set" : "remove")); throw com.google.gerrit.server.api.ApiUtil.asRestApiException(msg, e); } }
private com.google.gerrit.server.project.TagResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { return tags.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); input = com.google.gerrit.server.group.AddMembers.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(("Cannot delete members from group " + (internalGroup.getName()))); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = new java.util.HashSet<>(); for (java.lang.String nameOrEmail : input.members) { com.google.gerrit.reviewdb.client.Account a = accounts.parse(nameOrEmail).getAccount(); membersToRemove.add(a.getId()); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); try { removeGroupMembers(groupUuid, membersToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public void owner(java.lang.String owner) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.groups.OwnerInput in = new com.google.gerrit.extensions.api.groups.OwnerInput(); in.owner = owner; try { putOwner.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put group owner", e); } }
@org.junit.Test public void rejectWhenFeatureIsDisabled() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.api.projects.ConfigInput conf = new com.google.gerrit.extensions.api.projects.ConfigInput(); conf.enableReviewerByEmail = com.google.gerrit.extensions.client.InheritableBoolean.FALSE; gApi.projects().name(project.get()).config(conf); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.AddReviewerResult result = gApi.changes().id(r.getChangeId()).addReviewer("Foo Bar <foo.bar@gerritcodereview.com>"); assertThat(result.error).isEqualTo("Foo Bar <foo.bar@gerritcodereview.com> does not identify a registered user or group"); assertThat(result.reviewers).isNull(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.DashboardResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.project.DashboardsCollection.newDashboardInfo(id.get()); } catch (com.google.gerrit.server.project.DashboardsCollection.InvalidDashboardId e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) { return new com.google.gerrit.server.project.ConfigInfoImpl(serverEnableSignedPush, resource.getProjectState(), resource.getUser(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); try { com.google.gerrit.server.account.GroupControl c = controlFactory.validateFor(group.getOwnerGroupUUID()); return json.format(c.getGroup()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.CommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkGroup(com.google.gerrit.server.group.InternalGroup g, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) throws java.io.IOException { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); problems.addAll(checkCycle(g, byUUID)); if (((byUUID.get(g.getOwnerGroupUUID())) == null) && ((groupBackend.get(g.getOwnerGroupUUID())) == null)) { problems.add(error("group %s (%s) has nonexistent owner group %s", g.getName(), g.getGroupUUID(), g.getOwnerGroupUUID())); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : g.getSubgroups()) { if (((byUUID.get(subUuid)) == null) && ((groupBackend.get(subUuid)) == null)) { problems.add(error("group %s (%s) has nonexistent subgroup %s", g.getName(), g.getGroupUUID(), subUuid)); } } for (com.google.gerrit.reviewdb.client.Account.Id id : g.getMembers().asList()) { com.google.gerrit.reviewdb.client.Account account; try { account = accounts.get(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { problems.add(error("group %s (%s) has member %s with invalid configuration: %s", g.getName(), g.getGroupUUID(), id, e.getMessage())); continue; } if (account == null) { problems.add(error("group %s (%s) has nonexistent member %s", g.getName(), g.getGroupUUID(), id)); } } return problems; }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkCycle(com.google.gerrit.server.group.InternalGroup root, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> todo = new java.util.LinkedHashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); todo.add(root); while (!(todo.isEmpty())) { com.google.gerrit.server.group.InternalGroup t = todo.iterator().next(); todo.remove(t); if (seen.contains(t)) { continue; } seen.add(t); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : t.getSubgroups()) { com.google.gerrit.server.group.InternalGroup g = byUUID.get(subUuid); if (g == null) { continue; } if (java.util.Objects.equals(g, root)) { problems.add(warning("group %s (%s) contains a cycle: %s (%s) points to it as subgroup.", root.getName(), root.getGroupUUID(), t.getName(), t.getGroupUUID())); } todo.add(g); } } return problems; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.TagResource resource) { return resource.getTagInfo(); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState parent, com.google.gerrit.server.project.ProjectState current, com.google.gerrit.server.CurrentUser user, com.google.gerrit.extensions.api.projects.DashboardInfo info) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.AmbiguousObjectException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.IncorrectObjectTypeException { java.lang.String ref = com.google.gerrit.server.project.DashboardsCollection.normalizeDashboardRef(info.ref); try { permissionBackend.user(user).project(parent.getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(ref))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.project.DashboardResource(current, user, ref, info.path, cfg, false); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } }
com.google.gerrit.server.api.projects.CommitApiImpl create(com.google.gerrit.server.project.CommitResource r);
@org.junit.Test public void idInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\townerGroupUuid = owners\n"); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("ID of the group users-XYZ"); com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void ownerUuidOfNewGroupMustNotBeNull() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Owner UUID of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameOfNewGroupMustNotBeNull() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Name of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Name of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void ownerUuidCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Owner UUID of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void idInConfigMustNotBeNegative() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = -5\n\townerGroupUuid = owners\n"); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("ID of the group users-XYZ"); com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void ownerUuidInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = 42\n"); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("Owner UUID of the group users-XYZ"); com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void nameInConfigMayBeUndefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().getName()).isEmpty(); }
@org.junit.Test public void nameCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Name of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameOfNewGroupMustNotBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Name of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
private void populateGroupConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.String fileContent) throws java.lang.Exception { testRepository.branch(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)).commit().message("Prepopulate group.config").add(GroupConfig.GROUP_CONFIG_FILE, fileContent).create(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if (com.google.gerrit.reviewdb.client.RefNames.isGroupRef(receiveEvent.command.getRefName())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("group update not allowed"); } return java.util.Collections.emptyList(); }
private static com.google.gerrit.server.change.PostReview.CommentSetEntry create(java.lang.String filename, int patchSetId, java.lang.Integer line, com.google.gerrit.extensions.client.Side side, com.google.common.hash.HashCode message, com.google.gerrit.reviewdb.client.Comment.Range range) { return new com.google.gerrit.server.change.AutoValue_PostReview_CommentSetEntry(filename, patchSetId, line, side, message, range); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log delete accounts from group event", e); } } }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log delete groups from group event", e); } } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddAccountsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log add accounts to group event", e); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.change.ChangeResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getChange().getTopic()); }
private void loadPluginSections(org.eclipse.jgit.lib.Config rc) { pluginConfigs = new java.util.HashMap(); for (java.lang.String plugin : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)) { org.eclipse.jgit.lib.Config pluginConfig = new org.eclipse.jgit.lib.Config(); pluginConfigs.put(plugin, pluginConfig); for (java.lang.String name : rc.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = rc.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); java.lang.String groupName = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if (groupName != null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if (ref == null) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("group \"" + groupName) + "\" not in ") + (GroupList.FILE_NAME)))); } rc.setString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, value); } pluginConfig.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } }
private void loadPermissionRules(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String varName, java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName, com.google.gerrit.common.data.Permission perm, boolean useRange) { for (java.lang.String ruleString : rc.getStringList(section, subsection, varName)) { com.google.gerrit.common.data.PermissionRule rule; try { rule = com.google.gerrit.common.data.PermissionRule.fromString(ruleString, useRange); } catch (java.lang.IllegalArgumentException notRule) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((((("Invalid rule in " + section) + (subsection != null ? "." + subsection : "")) + ".") + varName) + ": ") + (notRule.getMessage())))); continue; } com.google.gerrit.common.data.GroupReference ref = groupsByName.get(rule.getGroup().getName()); if (ref == null) { ref = rule.getGroup(); groupsByName.put(ref.getName(), ref); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("group \"" + (ref.getName())) + "\" not in ") + (GroupList.FILE_NAME)))); } rule.setGroup(ref); perm.add(rule); } }
private void savePluginSections(org.eclipse.jgit.lib.Config rc, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> keepGroups) { java.util.List<java.lang.String> existing = com.google.common.collect.Lists.newArrayList(rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)); for (java.lang.String name : existing) { rc.unsetSection(com.google.gerrit.server.git.ProjectConfig.PLUGIN, name); } for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Config> e : pluginConfigs.entrySet()) { java.lang.String plugin = e.getKey(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); for (java.lang.String name : pluginConfig.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = pluginConfig.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); java.lang.String groupName = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if (groupName != null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if ((ref != null) && ((ref.getUUID()) != null)) { keepGroups.add(ref.getUUID()); pluginConfig.setString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, ("group " + (ref.getName()))); } } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(pluginConfig.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in._oneMember = resource.getMember().getAccountId().toString(); return delete.get().apply(resource, in); }
public com.google.gerrit.common.data.GroupReference getGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return checkNotNull(uuids.get(uuid), "group %s not found", uuid.get()); }
public static com.google.gerrit.server.git.GroupList parse(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String text, com.google.gerrit.server.git.ValidationError.Sink errors) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.Row> rows = com.google.gerrit.server.git.GroupList.parse(text, com.google.gerrit.server.git.GroupList.FILE_NAME, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, errors); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.common.data.GroupReference> groupsByUUID = new java.util.HashMap(rows.size()); for (com.google.gerrit.server.git.Row row : rows) { if ((row.left) == null) { com.google.gerrit.server.git.GroupList.log.warn("null field in group list for {}:\n{}", project, text); continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(row.left); java.lang.String name = row.right; com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); } return new com.google.gerrit.server.git.GroupList(groupsByUUID); }
private static java.lang.String getAmbiguousNameMessage(java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.reviewdb.client.AccountGroup.UUID systemGroupUuid) { return java.lang.String.format(("The configured name '%s' for system group '%s' is ambiguous" + ((" with the name '%s' of existing group '%s'." + " Please remove/change the value for groups.%s.name in") + " gerrit.config.")), groupName, systemGroupUuid.get(), groupName, groupUuid.get(), systemGroupUuid.get()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); return com.google.common.base.Strings.nullToEmpty(group.getDescription()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gwtorm.server.OrmException { if (accountPatchReviewStore.get().markReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getPatchKey().getFileName())) { return com.google.gerrit.extensions.restapi.Response.created(""); } return com.google.gerrit.extensions.restapi.Response.ok(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gwtorm.server.OrmException { accountPatchReviewStore.get().clearReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getPatchKey().getFileName()); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, java.io.IOException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to index group"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID(); if (!(rsrc.isInternalGroup())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("External Group Not Allowed: %s", groupUuid.get())); } java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(groupUuid); if (group.isPresent()) { groupCache.evict(group.get().getGroupUUID(), group.get().getId(), group.get().getNameKey()); } return com.google.gerrit.extensions.restapi.Response.none(); }
public static void assertGroups(java.lang.Iterable<java.lang.String> expected, java.util.Set<java.lang.String> actual) { for (java.lang.String g : expected) { assertWithMessage(("missing group " + g)).that(actual.remove(g)).isTrue(); } assertWithMessage(("unexpected groups: " + actual)).that(actual).isEmpty(); }
public com.google.gerrit.extensions.api.access.ProjectAccessInfo apply(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(nameKey.get()); } return apply(new com.google.gerrit.server.project.ProjectResource(state, user.get())); }
private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo group = visibleGroups.get(id); if (group == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_SENTINEL; if (control.isVisible()) { group = groupJson.format(control.getGroup()); group.id = null; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { com.google.gerrit.server.project.GetAccess.LOG.warn(("NoSuchGroupException; ignoring group " + id), e); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_SENTINEL; } visibleGroups.put(id, group); } return group; }
private java.util.Collection<com.google.gerrit.server.project.ProjectState> tree(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.project.ProjectState> tree = new java.util.LinkedHashMap<>(); for (com.google.gerrit.server.project.ProjectState ps : rsrc.getProjectState().tree()) { tree.put(ps.getNameKey(), ps); } tree.keySet().retainAll(permissionBackend.user(user).filter(ProjectPermission.ACCESS, tree.keySet())); return tree.values(); }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.lang.String project = rsrc.getName(); if (!(inherited)) { return scan(rsrc.getProjectState(), project, true); } java.util.List<java.util.List<com.google.gerrit.extensions.api.projects.DashboardInfo>> all = new java.util.ArrayList<>(); boolean setDefault = true; for (com.google.gerrit.server.project.ProjectState ps : tree(rsrc)) { java.util.List<com.google.gerrit.extensions.api.projects.DashboardInfo> list = scan(ps, project, setDefault); for (com.google.gerrit.extensions.api.projects.DashboardInfo d : list) { if (((d.isDefault) != null) && (java.lang.Boolean.TRUE.equals(d.isDefault))) { setDefault = false; } } if (!(list.isEmpty())) { all.add(list); } } return all; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.OwnerInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("owner is required"); } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); if (!(internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID()))) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(owner.getGroupUUID()).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } } return json.format(owner); }
@org.junit.Test public void ownerUuidOfNewGroupMustNotBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Owner UUID of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public void onChangeMerged(com.google.gerrit.server.Event event) { if ((!(allProjects.get().equals(event.getChange().project))) || (!(RefNames.REFS_CONFIG.equals(event.getChange().branch)))) { return; } try { syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.CreateGroupPermissionSyncer.log.error("Can't sync create group permissions", e); } }
@org.junit.Test public void nameInConfigMayBeEmpty() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname=\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().getName()).isEmpty(); }
protected static java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.project.ProjectResource(projectState, self.get()); com.google.gerrit.server.project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.extensions.common.ProjectInfo p : children.apply(proj)) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn("cannot check permissions to expand child projects", e); } return r; }
public com.google.gerrit.extensions.common.GroupInfo format(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return createGroupInfo(rsrc.getGroup(), rsrc::getControl); }
private static void checkSameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) { checkState(group.equals(groupControl.getGroup()), "Specified group and groupControl do not match"); }
@java.lang.Override public void setReviewed(java.lang.String path, boolean reviewed) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.change.FileResource, com.google.gerrit.extensions.common.Input> view; if (reviewed) { view = putReviewed; } else { view = deleteReviewed; } view.apply(files.parse(revision, com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)), new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot update reviewed flag", e); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.CommitResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId objectId; try { objectId = org.eclipse.jgit.lib.ObjectId.fromString(id.get()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(parent.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(objectId); rw.parseBody(commit); if (!(canRead(parent.getProjectState(), repo, commit))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (int i = 0; i < (commit.getParentCount()); i++) { rw.parseBody(rw.parseCommit(commit.getParent(i))); } return new com.google.gerrit.server.project.CommitResource(parent, commit); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot look up change for commit " + (commit.name())) + " in ") + project), e); } return isReachableFrom(state, repo, commit, repo.getAllRefs()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.DraftCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { checkIdentifiedUser(); java.lang.String uuid = id.get(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByPatchSetAuthor(dbProvider.get(), rev.getPatchSet().getId(), rev.getAccountId(), rev.getNotes())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.DraftCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() { return list.get(); }
@java.lang.Override public com.google.gerrit.server.project.CreateBranch create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString name) { return createBranchFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource>> views() { return views; }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(0, ((id.length()) - (Constants.DOT_GIT_EXT.length()))); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Project Not Found: %s", id)); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.DeleteDraftComment.Op op = new com.google.gerrit.server.change.DeleteDraftComment.Op(rsrc.getComment().key); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.reviewdb.client.AccountGroup getExistingGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUuid).toList(); if ((accountGroups.size()) == 1) { return com.google.common.collect.Iterables.getOnlyElement(accountGroups); } else if (accountGroups.isEmpty()) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupUuid); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Duplicate group UUID " + groupUuid)); } }
@org.junit.Test public void ownerUuidCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUuid, "[group]\n\tname = users\n\tid = 42\n\townerGroupUuid = owners\n"); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Owner UUID of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic() ? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.DraftCommentResource>> views() { return views; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (recursive) { return getTransitiveMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
public com.google.gerrit.server.project.ProjectResource getParent() { return parent; }
@org.junit.Test public void idOfNewGroupMustNotBeNegative() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id((-2))).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("ID of the group users-XYZ"); groupConfig.commit(metaDataUpdate); } }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Created group wasn't automatically loaded")); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); input = com.google.gerrit.server.group.AddSubgroups.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveGroup())) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Cannot delete groups from group %s", internalGroup.getName())); } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupsToRemove = new java.util.HashSet<>(); for (java.lang.String subgroupIdentifier : input.groups) { com.google.gerrit.common.data.GroupDescription.Basic subgroup = groupsCollection.parse(subgroupIdentifier); subgroupsToRemove.add(subgroup.getGroupUUID()); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); try { removeSubgroups(groupUuid, subgroupsToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.SubgroupResource resource, com.google.gerrit.server.group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input in = new com.google.gerrit.server.group.AddSubgroups.Input(); in.groups = com.google.common.collect.ImmutableList.of(resource.getMember().get()); return delete.get().apply(resource, in); }
com.google.gerrit.server.project.DeleteRef create(com.google.gerrit.server.project.ProjectResource r);
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount()); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG); return apply(rsrc.getProjectState(), input); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { if (input == null) { input = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); } if (((input.label) != null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("label must match URL"); } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); if (((r.getRevisionResource()) != null) && (!(r.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Cannot delete vote on non-current patch set"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), r.getChangeResource().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(projectCache.checkedGet(r.getChange().getProject()), r.getReviewerUser().getAccount(), rsrc.getLabel(), input)); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
@java.lang.Override public void run() { java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> names = (tryingAgain) ? retryOn : projectCache.all(); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : names) { com.google.gerrit.server.git.ProjectConfig config = projectCache.get(projectName).getConfig(); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { continue; } try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) { rename(md); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noProject) { continue; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException err) { com.google.gerrit.server.git.RenameGroupOp.log.error(((("Cannot rename group " + (oldName)) + " in ") + projectName), err); } } if ((!(retryOn.isEmpty())) && (!(tryingAgain))) { tryingAgain = true; @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = start(5, java.util.concurrent.TimeUnit.MINUTES); } }
private void rename(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { boolean success = false; for (int attempts = 0; (!success) && (attempts < (com.google.gerrit.server.git.RenameGroupOp.MAX_TRIES)); attempts++) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { projectCache.evict(config.getProject()); return; } ref.setName(newName); md.getCommitBuilder().setAuthor(author); md.setMessage((((("Rename group " + (oldName)) + " to ") + (newName)) + "\n")); try { config.commit(md); projectCache.evict(config.getProject()); success = true; } catch (java.io.IOException e) { com.google.gerrit.server.git.RenameGroupOp.log.error(((((("Could not commit rename of group " + (oldName)) + " to ") + (newName)) + " in ") + (md.getProjectName().get())), e); try { java.lang.Thread.sleep(25); } catch (java.lang.InterruptedException wakeUp) { continue; } } } if (!success) { if (tryingAgain) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((("Could not rename group " + (oldName)) + " to ") + (newName)) + " in ") + (md.getProjectName().get()))); } else { retryOn.add(md.getProjectName()); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.SetDefaultDashboard set = setDefault.get(); set.inherited = inherited; return set.apply(com.google.gerrit.server.project.DashboardResource.projectDefault(resource.getProjectState(), resource.getUser()), input); }
private void renameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, java.lang.String newName) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = group.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(newName)).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("group with name " + newName) + " already exists")); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rsrc.getCommit(); com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getProjectState().getNameKey(); return includedIn.apply(project, commit.getId().getName()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource rsrc, NameInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } else if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("name is required"); } java.lang.String newName = input.name.trim(); if (newName.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("name is required"); } if (internalGroup.getName().equals(newName)) { return newName; } renameGroup(internalGroup, newName); return newName; }
@java.lang.Override java.lang.String groupPattern() { return "(&(objectClass=group)(cn=${groupname}))"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, path, parent); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byName(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.name(groupName.get()), (("group name '" + groupName) + "'")); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) { return resource.getName(); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byId(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.id(groupId), (("group id '" + groupId) + "'")); }




private void setSubmitType(com.google.gerrit.extensions.client.SubmitType newSubmitType) { int index = -1; if ((submitType) != null) { for (int i = 0; i < (submitType.getItemCount()); i++) { if (newSubmitType.name().equals(submitType.getValue(i))) { index = i; break; } } submitType.setSelectedIndex(index); setEnabledForUseContentMerge(); } }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(signedOffBy, result.useSignedOffBy()); setBool(contentMerge, result.useContentMerge()); setBool(newChangeForAllNotInTarget, result.createNewChangeForAllNotInTarget()); setBool(requireChangeID, result.requireChangeId()); if (com.google.gerrit.client.Gerrit.info().receive().enableSignedPush()) { setBool(enableSignedPush, result.enableSignedPush()); setBool(requireSignedPush, result.requireSignedPush()); } setBool(rejectImplicitMerges, result.rejectImplicitMerges()); setBool(privateByDefault, result.privateByDefault()); setBool(enableReviewerByEmail, result.enableReviewerByEmail()); setBool(matchAuthorToCommitterDate, result.matchAuthorToCommitterDate()); setSubmitType(result.submitType()); setState(result.state()); maxObjectSizeLimit.setText(result.maxObjectSizeLimit().configuredValue()); if ((result.maxObjectSizeLimit().inheritedValue()) != null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setText(AdminMessages.I.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value())); effectiveMaxObjectSizeLimit.setTitle(AdminMessages.I.globalMaxObjectSizeLimit(result.maxObjectSizeLimit().inheritedValue())); } else { effectiveMaxObjectSizeLimit.setVisible(false); } saveProject.setEnabled(false); initPluginOptions(result); initProjectActions(result); }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.server.account.externalids.ExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { accountsUpdateFactory.create().delete(account); externalIdsUpdateFactory.create().delete(extId); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }



@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String pfx) { com.google.gerrit.reviewdb.client.Project.NameKey start = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx); com.google.gerrit.reviewdb.client.Project.NameKey end = new com.google.gerrit.reviewdb.client.Project.NameKey((pfx + (java.lang.Character.MAX_VALUE))); try { return list.get(com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL).subSet(start, end); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn(("Cannot look up projects for prefix " + pfx), e); return java.util.Collections.emptyList(); } }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { return java.util.Collections.emptySet(); }
java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> all();
@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> all() { return java.util.Collections.emptySet(); }
java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix);
public java.lang.Iterable<T> search(java.util.List<T> list) { com.google.gerrit.server.util.RegexListSearcher.checkNotNull(list); int begin; int end; if (0 < (prefixLen)) { begin = find(list, prefixBegin); end = find(list, prefixEnd); } else { begin = 0; end = list.size(); } if (prefixOnly) { return begin < end ? list.subList(begin, end) : com.google.common.collect.ImmutableList.<T>of(); } return com.google.common.collect.Iterables.filter(list.subList(begin, end), ( x) -> pattern.run(apply(x))); }
public static com.google.gerrit.server.util.RegexListSearcher<java.lang.String> ofStrings(java.lang.String re) { return new com.google.gerrit.server.util.RegexListSearcher<java.lang.String>(re) { @java.lang.Override public java.lang.String apply(java.lang.String in) { return in; } }; }
private int find(java.util.List<T> list, java.lang.String p) { int r = java.util.Collections.binarySearch(com.google.common.collect.Lists.transform(list, this), p); return r < 0 ? -(r + 1) : r; }
private org.eclipse.jgit.internal.storage.dfs.InMemoryRepository add(com.google.gerrit.server.git.ProjectConfig pc) { com.google.gerrit.server.rules.PrologEnvironment.Factory envFactory = null; com.google.gerrit.server.project.ProjectControl.AssistedFactory projectControlFactory = null; com.google.gerrit.server.rules.RulesCache rulesCache = null; com.google.gerrit.server.config.SitePaths sitePaths = null; java.util.List<com.google.gerrit.extensions.api.projects.CommentLinkInfo> commentLinks = null; org.eclipse.jgit.internal.storage.dfs.InMemoryRepository repo; try { repo = repoManager.createRepository(pc.getName()); if ((pc.getProject()) == null) { pc.load(repo); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(e); } all.put(pc.getName(), new com.google.gerrit.server.project.ProjectState(sitePaths, projectCache, allProjectsName, allUsersName, projectControlFactory, envFactory, repoManager, rulesCache, commentLinks, capabilityCollectionFactory, pc)); return repo; }

private java.util.Optional<com.google.gerrit.reviewdb.client.Account> loadAccount(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { rw.reset(); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId); accountConfig.load(rw, commit); return accountConfig.getLoadedAccount(); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision) != null) { rw.reset(); rw.markStart(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadedAccount = java.util.Optional.of(parse(cfg, revision.name())); } else { loadedAccount = java.util.Optional.empty(); } }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { com.google.template.soy.SoyFileSet.Builder builder = com.google.template.soy.SoyFileSet.builder(); java.lang.String template = null; java.lang.String templateName = actionRequest.getParameter(1); if (templateName.isEmpty()) { com.googlesource.gerrit.plugins.its.base.workflow.action.AddSoyComment.log.error("No template name given in {}", actionRequest); } else { template = templateName; } if (!(com.google.common.base.Strings.isNullOrEmpty(template))) { java.lang.String comment = soyTextTemplate(builder, template, properties); its.addComment(issue, comment); } }
private void logProperty(com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level level, com.googlesource.gerrit.plugins.its.base.workflow.Property property) { java.lang.String message = property.toString(); switch (level) { case ERROR : com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.error(message); break; case WARN : com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.warn(message); break; case INFO : com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.info(message); break; case DEBUG : com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.debug(message); break; default : com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.error("Undefined log level."); } }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { java.lang.String levelParameter = actionRequest.getParameter(1); if (levelParameter != null) { levelParameter = levelParameter.toLowerCase(); } com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.INFO; if ("error".equals(levelParameter)) { level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.ERROR; } else if ("warn".equals(levelParameter)) { level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.WARN; } else if ("info".equals(levelParameter)) { level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.INFO; } else if ("debug".equals(levelParameter)) { level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.DEBUG; } for (com.googlesource.gerrit.plugins.its.base.workflow.Property property : properties) { logProperty(level, property); } }
public void BROKEN_testIsEnabledUnknownEvent() { com.google.gerrit.server.events.Event event = new com.google.gerrit.server.events.Event("foo") {}; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig(); replayMocks(); assertFalse(itsConfig.isEnabled(event)); assertLogMessageContains("not recognised and ignored"); }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(itsConfig.isEnabled(event))) { return; } java.util.Set<java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property>> propertiesCollections = propertyExtractor.extractFrom(event); for (java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties : propertiesCollections) { java.util.Collection<com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest> actions = ruleBase.actionRequestsFor(properties); if (!(actions.isEmpty())) { for (com.googlesource.gerrit.plugins.its.base.workflow.Property property : properties) { if ("issue".equals(property.getKey())) { java.lang.String issue = property.getValue(); actionExecutor.execute(issue, actions, properties); } } } } }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } try { permissionBackend.user(currentUser).database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("edit not permitted", denied); } }
boolean canAddPatchSet() { return (projectControl.controlForRef(("refs/for/" + (refName))).canPerform(Permission.ADD_PATCH_SET)) && (isProjectStatePermittingWrite()); }
private void ensureCanEditCommitMessage(com.google.gerrit.server.notedb.ChangeNotes changeNotes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { if (!(currentUserProvider.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } try { permissionBackend.user(currentUserProvider.get()).database(db.get()).change(changeNotes).check(ChangePermission.ADD_PATCH_SET); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("modifying commit message not permitted", denied); } }

@java.lang.Override public com.google.gerrit.server.restapi.change.Submit.Output apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { input.onBehalfOf = com.google.common.base.Strings.emptyToNull(input.onBehalfOf); com.google.gerrit.server.IdentifiedUser submitter; if ((input.onBehalfOf) != null) { submitter = onBehalfOf(rsrc, input); } else { rsrc.permissions().check(ChangePermission.SUBMIT); submitter = rsrc.getUser().asIdentifiedUser(); } return new com.google.gerrit.server.restapi.change.Submit.Output(mergeChange(rsrc, submitter, input)); }
@org.junit.Test public void unblockForceEditTopicName() { block(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForce(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.DEVS); assertThat(u.controlForRef("refs/heads/master").canForceEditTopicName()).named("u can edit topic name").isTrue(); }
@org.junit.Test public void unblockInLocalForceEditTopicName_Fails() { block(parent, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForce(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.REGISTERED_USERS); assertThat(u.controlForRef("refs/heads/master").canForceEditTopicName()).named("u can't edit topic name").isFalse(); }
private boolean canEditTopicName() { if (getChange().getStatus().isOpen()) { return ((((isOwner()) || (refControl.isOwner())) || (getProjectControl().isOwner())) || (refControl.canEditTopicName())) || (getProjectControl().isAdmin()); } return refControl.canForceEditTopicName(); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case CREATE_TAG : return canPerform(Permission.CREATE_TAG); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + (refName))).canSubmit(true); case READ_PRIVATE_CHANGES : return canViewPrivateChanges(); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().is(BooleanProjectConfig.USE_SIGNED_OFF_BY))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private void loadExtensionPanelSections(org.eclipse.jgit.lib.Config rc) { java.util.Map<java.lang.String, java.lang.String> lowerNames = com.google.common.collect.Maps.newHashMapWithExpectedSize(2); extensionPanelSections = com.google.common.collect.Maps.newLinkedHashMap(); for (java.lang.String name : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANELS)) { java.lang.String lower = name.toLowerCase(); if (lowerNames.containsKey(lower)) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, java.lang.String.format("Extension Panels \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower)))); } lowerNames.put(lower, name); extensionPanelSections.put(name, new java.util.ArrayList(java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANELS, name, com.google.gerrit.server.git.ProjectConfig.KEY_PANEL)))); } }
@java.lang.Override public org.eclipse.jgit.lib.Config getConfig() throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = com.googlesource.gerrit.plugins.gitiles.Resolver.getNameKey(req); com.google.gerrit.server.project.ProjectState state = projectCache.get(nameKey); if (state != null) { org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").getWithInheritance(); if (cfg != null) { return cfg; } } else { state = projectCache.getAllProjects(); org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").get(); if (cfg != null) { return cfg; } } return new org.eclipse.jgit.lib.Config(); }


com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(name); if (!(projectState.getProject().getState().permitsRead())) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }


@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Project Not Found: %s", id)); } return rsrc; }

@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return (isVisible()) && (getProjectControl().getProjectState().statePermitsRead()); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case CREATE_TAG : return canPerform(Permission.CREATE_TAG); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + (refName))).canSubmit(true); case READ_PRIVATE_CHANGES : return canPerform(Permission.VIEW_PRIVATE_CHANGES); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().is(BooleanProjectConfig.USE_SIGNED_OFF_BY))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), accountConfig.getProjectWatches(), accountConfig.getGeneralPreferences()); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences()))); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableMap.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), accountConfig.getProjectWatches(), accountConfig.getGeneralPreferences())); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableMap.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences())); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences())); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences()))); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate.AccountUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); com.google.gerrit.server.account.InternalAccountUpdate.Builder updateBuilder = com.google.gerrit.server.account.InternalAccountUpdate.builder(); updater.update(accountState, updateBuilder); com.google.gerrit.server.account.InternalAccountUpdate update = updateBuilder.build(); accountConfig.setAccountUpdate(update); com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes = createExternalIdNotes(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount updatedAccounts = new com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount(allUsersName, externalIds, message, accountConfig, extIdNotes); updatedAccounts.setCreated(true); return updatedAccounts; }).get(); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableMap.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
private void saveProjectWatches() throws java.io.IOException { if ((accountUpdate.isPresent()) && ((!(accountUpdate.get().getDeletedProjectWatches().isEmpty())) || (!(accountUpdate.get().getUpdatedProjectWatches().isEmpty())))) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = watchConfig.getProjectWatches(); accountUpdate.get().getDeletedProjectWatches().forEach(( pw) -> projectWatches.remove(pw)); accountUpdate.get().getUpdatedProjectWatches().forEach(( pw, nt) -> projectWatches.put(pw, nt)); saveConfig(WatchConfig.WATCH_CONFIG, watchConfig.save(projectWatches)); } }
public java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { checkLoaded(); return watchConfig.getProjectWatches(); }
@com.google.common.annotations.VisibleForTesting public static java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.git.ValidationError.Sink validationErrorSink) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = new java.util.HashMap<>(); for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { java.lang.String[] notifyValues = cfg.getStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName, com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY); for (java.lang.String nv : notifyValues) { if (com.google.common.base.Strings.isNullOrEmpty(nv)) { continue; } com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue = com.google.gerrit.server.account.WatchConfig.NotifyValue.parse(accountId, projectName, nv, validationErrorSink); if (notifyValue == null) { continue; } com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key = com.google.gerrit.server.account.WatchConfig.ProjectWatchKey.create(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), notifyValue.filter()); if (!(projectWatches.containsKey(key))) { projectWatches.put(key, java.util.EnumSet.noneOf(com.google.gerrit.server.account.WatchConfig.NotifyType.class)); } projectWatches.get(key).addAll(notifyValue.notifyTypes()); } } return projectWatches; }
public org.eclipse.jgit.lib.Config save(java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches) { this.projectWatches = projectWatches; for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { cfg.unsetSection(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName); } com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> notifyValuesByProject = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> e : projectWatches.entrySet()) { com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue = com.google.gerrit.server.account.WatchConfig.NotifyValue.create(e.getKey().filter(), e.getValue()); notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString()); } for (java.util.Map.Entry<java.lang.String, java.util.Collection<java.lang.String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, e.getKey(), com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY, new java.util.ArrayList(e.getValue())); } return cfg; }
public java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { if ((projectWatches) == null) { parse(); } return projectWatches; }
public java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { return projectWatches; }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate.AccountUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableMap.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); com.google.gerrit.server.account.InternalAccountUpdate.Builder updateBuilder = com.google.gerrit.server.account.InternalAccountUpdate.builder(); updater.update(accountState, updateBuilder); com.google.gerrit.server.account.InternalAccountUpdate update = updateBuilder.build(); accountConfig.setAccountUpdate(update); com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes = createExternalIdNotes(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount updatedAccounts = new com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount(allUsersName, externalIds, message, accountConfig, extIdNotes); updatedAccounts.setCreated(true); return updatedAccounts; }); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail); if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if ((accounts.get(id)) != null) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); if ((accounts.get(id)) != null) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.AccountState who = byId.getByUsername(nameOrEmail); if (who != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(nameOrEmail); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableMap.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, reviewer, val)) { return; } permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER); }
private boolean canRemoveReviewerWithoutPermissionCheck(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (!(change.getStatus().isOpen())) { return false; } if (currentUser.isIdentifiedUser()) { com.google.gerrit.reviewdb.client.Account.Id aId = currentUser.getAccountId(); if (aId.equals(reviewer)) { return true; } else if ((aId.equals(change.getOwner())) && (0 <= value)) { return true; } } com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(change.getProject()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(change.getProject()); } com.google.gerrit.server.project.ProjectControl ctl = projectState.controlFor(currentUser); if (((ctl.controlForRef(change.getDest()).isOwner()) || (ctl.isOwner())) || (ctl.isAdmin())) { return true; } return false; }
public boolean testRemoveReviewer(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) { return true; } return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void testSuggestedNonMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> ret; com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment ivc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED).atLeastOnce(); expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce(); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getName()).andReturn("TestCommit").anyTimes(); expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new java.lang.String[]{ }).atLeastOnce(); replayMocks(); ret = ivc.onCommitReceived(event); assertEquals("Size of returned CommitValidationMessages does not match", 1, ret.size()); assertTrue(("First CommitValidationMessages does not contain 'Missing " + "issue'"), ret.get(0).getMessage().contains("Missing issue")); }
public java.lang.String getCommentLinkName() { java.lang.String ret; ret = getPluginConfigString("commentlink"); if (ret == null) { ret = pluginName; } return ret; }

public void testMandatoryNonMatching() { com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment ivc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce(); expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce(); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getName()).andReturn("TestCommit").anyTimes(); expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new java.lang.String[]{ }).atLeastOnce(); replayMocks(); try { ivc.onCommitReceived(event); fail("onCommitReceived did not throw any exception"); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { assertTrue(("Message of thrown CommitValidationException does not " + "contain 'Missing issue'"), e.getMessage().contains("Missing issue")); } }
private java.lang.String getPluginConfigString(java.lang.String key) { return getCurrentPluginConfig().getString(key, gerritConfig.getString(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.PLUGIN, pluginName, key)); }

@java.lang.Override @com.google.gerrit.common.Nullable public synchronized com.google.gerrit.server.account.AccountState getByUsername(java.lang.String username) { return byUsername.get(username); }


public <T> T execute(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return execute(actionType, action, ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); }
private <T> T execute(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Throwable { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return execute(actionType, action, retryerBuilder.build()); } finally { metrics.attemptCounts.record(actionType, listener.getAttemptCount()); } }


private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Created group wasn't automatically loaded")); } }

private com.google.gerrit.reviewdb.client.Account updateAccount(com.google.gerrit.server.account.AccountsUpdate.AccountUpdate accountUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return retryHelper.execute(ActionType.ACCOUNT_UPDATE, () -> { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.UpdatedAccount updatedAccount = accountUpdate.update(allUsersRepo); if (updatedAccount == null) { return null; } commit(allUsersRepo, updatedAccount); return updatedAccount.getAccount(); } }); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic() ? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.BranchInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring).regex(matchRegex).start(start).limit(limit).filter(allBranches(rsrc)); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.IdString.fromUrl(((ref + ':') + path))); }
private com.google.gerrit.server.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.restapi.project.DashboardsCollection.newDashboardInfo(id.get()); } catch (com.google.gerrit.server.restapi.project.DashboardsCollection.InvalidDashboardId e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.restapi.change.ChangesCollection.toIdString(id)); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.restapi.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(change, user.get()); }
@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to modify") void addChange(java.lang.String token) { try { changeArgumentParser.addChange(token, changes, projectState); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { throw new java.lang.IllegalArgumentException(e.getMessage(), e); } catch (com.google.gwtorm.server.OrmException e) { throw new java.lang.IllegalArgumentException("database is down", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.IllegalArgumentException("can't check permissions", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.restapi.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("change %s not found", id.get())); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.restapi.account.StarredChanges.log.error("cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("internal server error"); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
private static boolean isVisible(com.google.gerrit.server.restapi.change.RelatedChangesSorter.PatchSetData psd, com.google.gerrit.server.permissions.PermissionBackend.WithUser perm) throws com.google.gerrit.server.permissions.PermissionBackendException { try { perm.change(psd.data()).check(ChangePermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } }
void sort(java.lang.String ref, java.util.List<com.google.gerrit.common.data.AccessSection> sections) { final int cnt = sections.size(); if (cnt <= 1) { return; } com.google.gerrit.server.project.SectionSortCache.EntryKey key = com.google.gerrit.server.project.SectionSortCache.EntryKey.create(ref, sections); com.google.gerrit.server.project.SectionSortCache.EntryVal val = cache.getIfPresent(key); if (val != null) { int[] srcIdx = val.order; if (srcIdx != null) { com.google.gerrit.common.data.AccessSection[] srcList = com.google.gerrit.server.project.SectionSortCache.copy(sections); for (int i = 0; i < cnt; i++) { sections.set(i, srcList[srcIdx[i]]); } } else { } } else { boolean poison = false; java.util.IdentityHashMap<com.google.gerrit.common.data.AccessSection, java.lang.Integer> srcMap = new java.util.IdentityHashMap<>(); for (int i = 0; i < cnt; i++) { poison |= (srcMap.put(sections.get(i), i)) != null; } java.util.Collections.sort(sections, new com.google.gerrit.server.util.MostSpecificComparator(ref)); int[] srcIdx; if (com.google.gerrit.server.project.SectionSortCache.isIdentityTransform(sections, srcMap)) { srcIdx = null; } else { srcIdx = new int[cnt]; for (int i = 0; i < cnt; i++) { srcIdx[i] = srcMap.get(sections.get(i)); } } if (poison) { com.google.gerrit.server.project.SectionSortCache.log.error("Received duplicate AccessSection instances, not caching sort"); } else { cache.put(key, new com.google.gerrit.server.project.SectionSortCache.EntryVal(srcIdx)); } } }
@org.junit.Test public void noteDbCommit() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.common.ChangeInfo c = assertCreateSucceeds(newChangeInput(ChangeStatus.NEW)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(repo.exactRef(changeMetaRef(new com.google.gerrit.reviewdb.client.Change.Id(c._number))).getObjectId()); assertThat(commit.getShortMessage()).isEqualTo("Create change"); org.eclipse.jgit.lib.PersonIdent expectedAuthor = changeNoteUtil.newIdent(accountCache.get(admin.id).getAccount(), c.created, serverIdent.get()); assertThat(commit.getAuthorIdent()).isEqualTo(expectedAuthor); assertThat(commit.getCommitterIdent()).isEqualTo(new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), c.created)); assertThat(commit.getParentCount()).isEqualTo(0); } }
@org.junit.Test public void getExternalIdsOfOtherUserWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.get(admin.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get((("/accounts/" + (admin.id)) + "/external.ids")); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@org.junit.Test public void getExternalIds() throws java.lang.Exception { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
private void assertUserBranch(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String name, @com.google.gerrit.common.Nullable java.lang.String status) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader()) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); assertThat(ref).isNotNull(); org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); long timestampDiffMs = java.lang.Math.abs((((c.getCommitTime()) * 1000L) - (accountCache.get(accountId).getAccount().getRegisteredOn().getTime()))); assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(or, AccountProperties.ACCOUNT_CONFIG, c.getTree())) { if ((name != null) || (status != null)) { assertThat(tw).isNotNull(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(new java.lang.String(or.open(tw.getObjectId(0), com.google.gerrit.acceptance.api.accounts.OBJ_BLOB).getBytes(), java.nio.charset.StandardCharsets.UTF_8)); assertThat(cfg.getString(AccountProperties.ACCOUNT, null, AccountProperties.KEY_FULL_NAME)).isEqualTo(name); assertThat(cfg.getString(AccountProperties.ACCOUNT, null, AccountProperties.KEY_STATUS)).isEqualTo(status); } else { assertThat(tw).isNull(); } } } }
@org.junit.Test public void getDetail() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/accounts/" + (admin.username)) + "/detail/")); com.google.gerrit.server.restapi.account.GetDetail.AccountDetailInfo info = newGson().fromJson(r.getReader(), com.google.gerrit.server.restapi.account.GetDetail.AccountDetailInfo.class); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.reviewdb.client.Account account = accountCache.get(admin.getId()).getAccount(); assertThat(info.registeredOn).isEqualTo(account.getRegisteredOn()); }
private void addNoteDbCommit(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String commitMessage) throws java.lang.Exception { if (!(notesMigration.commitChangeWrites())) { return; } org.eclipse.jgit.lib.PersonIdent committer = serverIdent.get(); org.eclipse.jgit.lib.PersonIdent author = noteUtil.newIdent(accountCache.get(admin.getId()).getAccount(), committer.getWhen(), committer); serverSideTestRepo.branch(com.google.gerrit.reviewdb.client.RefNames.changeMetaRef(id)).commit().author(author).committer(committer).message(commitMessage).create(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).getEditPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).getDiffPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).getGeneralPreferences(); }
public java.time.Duration getDefaultTimeout() { return defaultTimeout; }
private <T> T executeWithAttemptCount(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Throwable { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return executeWithTimeoutCount(actionType, action, retryerBuilder.build()); } finally { metrics.attemptCounts.record(actionType, listener.getAttemptCount()); } }


public com.google.gerrit.server.IdentifiedUser parseOnBehalfOf(@com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseIdOnBehalfOf(caller, id); if (user == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Account Not Found: %s", id)); } else if (!(accountControlFactory.get().canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Account Not Found: %s", id)); } return user; }
@java.lang.Override public com.google.gerrit.server.account.AccountResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseId(id.get()); if (user == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if (!(accountControlFactory.get().canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.account.AccountResource(user); }






@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.GeneralPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } checkDownloadScheme(input.downloadScheme); com.google.gerrit.server.account.Preferences.validateMy(input.my); com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdate.create().update("Set General Preferences via API", id, ( u) -> u.setGeneralPreferences(input)); return cache.get(id).getGeneralPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.EditPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("input must be provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdate.create().update("Set Diff Preferences via API", id, ( u) -> u.setEditPreferences(input)); return accountCache.get(id).getEditPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.DiffPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("input must be provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdate.create().update("Set Diff Preferences via API", id, ( u) -> u.setDiffPreferences(input)); return accountCache.get(id).getDiffPreferences(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::get).map(AccountState::getAccount).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((user != null) && (user.isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser who = user.asIdentifiedUser(); if ((who.getUserName()) != null) { req.setAttribute(com.google.gerrit.httpd.GetUserFilter.REQ_ATTR_KEY, who.getUserName()); } else { req.setAttribute(com.google.gerrit.httpd.GetUserFilter.REQ_ATTR_KEY, ("a/" + (who.getAccountId()))); } } chain.doFilter(req, resp); }
public org.eclipse.jgit.lib.PersonIdent newCommitterIdent(java.util.Date when, java.util.TimeZone tz) { final com.google.gerrit.reviewdb.client.Account ua = getAccount(); java.lang.String name = ua.getFullName(); java.lang.String email = ua.getPreferredEmail(); if ((email == null) || (email.isEmpty())) { java.lang.String user = getUserName(); if (user == null) { user = "account-" + (ua.getId().toString()); } java.lang.String host; if ((canonicalUrl.get()) != null) { try { host = new java.net.URL(canonicalUrl.get()).getHost(); } catch (java.net.MalformedURLException e) { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } } else { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } email = (user + "@") + host; } if ((name == null) || (name.isEmpty())) { final int at = email.indexOf('@'); if (0 < at) { name = email.substring(0, at); } else { name = anonymousCowardName; } } return new org.eclipse.jgit.lib.PersonIdent(name, email, when, tz); }
private java.lang.Iterable<java.lang.String> getUsernames(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { java.util.Set<java.lang.String> emails = user.asIdentifiedUser().getEmailAddresses(); if ((user.getUserName()) == null) { return emails; } else if (emails.isEmpty()) { return com.google.common.collect.ImmutableSet.of(user.getUserName()); } return com.google.common.collect.Iterables.concat(emails, com.google.common.collect.ImmutableSet.of(user.getUserName())); } if ((user.getUserName()) != null) { return com.google.common.collect.ImmutableSet.of(user.getUserName()); } return com.google.common.collect.ImmutableSet.of(); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return "Command was already destroyed"; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] args = dcmd.getArguments(); for (int i = 1; i < (args.length); i++) { commandName.append(".").append(args[i]); } return commandName.toString(); }




private com.google.common.collect.ListMultimap<java.lang.String, ?> extractParameters(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return com.google.common.collect.MultimapBuilder.hashKeys(0).arrayListValues(0).build(); } java.lang.String[] cmdArgs = dcmd.getArguments(); java.lang.String paramName = null; int argPos = 0; com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> parms = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (int i = 2; i < (cmdArgs.length); i++) { java.lang.String arg = cmdArgs[i]; if (arg.equals("--")) { for (i++; i < (cmdArgs.length); i++) { parms.put(("$" + (argPos++)), cmdArgs[i]); } break; } int eqPos = arg.indexOf('='); if ((arg.startsWith("--")) && (eqPos > 0)) { parms.put(arg.substring(0, eqPos), arg.substring((eqPos + 1))); continue; } if (arg.startsWith("-")) { if (paramName != null) { parms.put(paramName, null); } paramName = arg; continue; } if (paramName == null) { parms.put(("$" + (argPos++)), arg); } else { parms.put(paramName, arg); paramName = null; } } if (paramName != null) { parms.put(paramName, null); } return parms; }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw die(msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": ") + (commandName)) + ": not found"; throw die(msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) { bc.setName(commandName); } else { bc.setName((((getName()) + " ") + (commandName))); } bc.setArguments(args.toArray(new java.lang.String[args.size()])); } else if (!(args.isEmpty())) { throw die(((commandName) + " does not take arguments")); } provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes(com.google.gerrit.sshd.ENC)); err.flush(); onExit(e.exitCode); } }
void onExecute(com.google.gerrit.sshd.DispatchCommand dcmd, int exitValue, com.google.gerrit.sshd.SshSession sshSession) { final com.google.gerrit.sshd.SshScope.Context ctx = context.get(); ctx.finished = com.google.gerrit.common.TimeUtil.nowMs(); java.lang.String cmd = extractWhat(dcmd); final org.apache.log4j.spi.LoggingEvent event = log(cmd); event.setProperty(com.google.gerrit.sshd.SshLog.P_WAIT, (((ctx.started) - (ctx.created)) + "ms")); event.setProperty(com.google.gerrit.sshd.SshLog.P_EXEC, (((ctx.finished) - (ctx.started)) + "ms")); final java.lang.String status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status = "killed"; break; case BaseCommand.STATUS_NOT_FOUND : status = "not-found"; break; case BaseCommand.STATUS_NOT_ADMIN : status = "not-admin"; break; default : status = java.lang.String.valueOf(exitValue); break; } event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, status); java.lang.String peerAgent = sshSession.getPeerAgent(); if (peerAgent != null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_AGENT, peerAgent); } if ((async) != null) { async.append(event); } audit(context.get(), status, dcmd); }




@java.lang.Override protected void configure() { if ((gerritConfig.getString(pluginName, null, "url")) != null) { com.googlesource.gerrit.plugins.its.jira.JiraModule.LOG.info("JIRA is configured as ITS"); bind(com.googlesource.gerrit.plugins.its.base.its.ItsFacade.class).toInstance(new com.googlesource.gerrit.plugins.its.jira.JiraItsFacade(pluginName, gerritConfig)); install(new com.googlesource.gerrit.plugins.its.base.ItsHookModule(pluginName, pluginCfgFactory)); } }

private com.googlesource.gerrit.plugins.its.jira.JiraClient client() throws java.net.MalformedURLException { if ((client) == null) { log.debug("Connecting to jira at {}", getUrl()); client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(getUrl(), getUsername(), getPassword()); log.debug("Authenticating as User {}", getUsername()); } return client; }

private void authorizeUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.project.ProjectState state, java.lang.String operation) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { com.google.gerrit.reviewdb.client.Project.NameKey projectName = state.getNameKey(); if (((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD)) && (!(permissionBackend.user(user).project(projectName).testOrFalse(com.googlesource.gerrit.plugins.lfs.READ)))) || ((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD)) && (!(permissionBackend.user(user).project(projectName).testOrFalse(com.googlesource.gerrit.plugins.lfs.PUSH_AT_LEAST_ONE_REF))))) { java.lang.String op = operation.toLowerCase(); java.lang.String project = state.getProject().getName(); java.lang.String userName = (com.google.common.base.Strings.isNullOrEmpty(user.getUserName())) ? "anonymous" : user.getUserName(); com.googlesource.gerrit.plugins.lfs.LfsApiServlet.log.debug(java.lang.String.format("operation %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); } }
@org.junit.Test public void testVerifyDecodeAgainstEncodedInput() throws java.lang.Exception { java.lang.String plain = "plain text"; java.lang.String encrypted = cipher.encrypt(plain); com.google.common.base.Optional<java.lang.String> decrypted = cipher.decrypt(encrypted); assertThat(decrypted.isPresent()).isTrue(); assertThat(decrypted.get()).isEqualTo(plain); }
private void throwUnauthorizedOp(java.lang.String op, com.google.gerrit.server.project.ProjectState state, com.google.gerrit.server.CurrentUser user) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { java.lang.String project = state.getProject().getName(); java.lang.String userName = (com.google.common.base.Strings.isNullOrEmpty(user.getUserName())) ? "anonymous" : user.getUserName(); com.googlesource.gerrit.plugins.lfs.locks.LfsLocksAction.log.debug(java.lang.String.format("operation %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); }
@org.junit.Test public void testTokenSerializationDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor(cipher); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(0); java.lang.String serialized = processor.serialize(token); assertThat(serialized).isNotEmpty(); com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> deserialized = processor.deserialize(serialized); assertThat(deserialized.isPresent()).isTrue(); assertThat(token.expiresAt).isEqualTo(deserialized.get().expiresAt); }
public com.google.common.base.Optional<T> deserialize(java.lang.String input) { com.google.common.base.Optional<java.lang.String> decrypted = cipher.decrypt(input); if (!(decrypted.isPresent())) { return com.google.common.base.Optional.absent(); } return createToken(com.google.common.base.Splitter.on(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.Processor.DELIMETER).splitToList(decrypted.get())); }
protected abstract com.google.common.base.Optional<T> createToken(java.util.List<java.lang.String> values);
public boolean verifyAuthInfo(java.lang.String authToken, java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return false; } return new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.Verifier(token.get(), operation, id).verify(); }
@java.lang.Override protected com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 3) { return com.google.common.base.Optional.absent(); } return com.google.common.base.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1)), values.get(2))); }
@java.lang.Override protected com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 4) { return com.google.common.base.Optional.absent(); } return com.google.common.base.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3))); }
com.google.common.base.Optional<java.lang.String> getUserFromValidToken(java.lang.String authToken, java.lang.String project, java.lang.String operation) { com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return com.google.common.base.Optional.absent(); } com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier(token.get(), project, operation); if (!(verifier.verify())) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.log.error("Invalid data was provided with auth token {}.", authToken); return com.google.common.base.Optional.absent(); } return com.google.common.base.Optional.of(token.get().user); }
@java.lang.Override protected com.google.common.base.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.util.List<java.lang.String> values) { return com.google.common.base.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0))); }
public com.google.common.base.Optional<java.lang.String> decrypt(java.lang.String input) { if (com.google.common.base.Strings.isNullOrEmpty(input)) { return com.google.common.base.Optional.absent(); } byte[] bytes = org.eclipse.jgit.util.Base64.decode(input); byte[] initVector = java.util.Arrays.copyOf(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH); try { javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.DECRYPT_MODE); return com.google.common.base.Optional.of(new java.lang.String(cipher.doFinal(java.util.Arrays.copyOfRange(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH, bytes.length)), java.nio.charset.StandardCharsets.UTF_8)); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.LfsCipher.log.error("Exception was thrown during token verification", e); } return com.google.common.base.Optional.absent(); }
@org.junit.Test public void testVerifyDecodeAgainstInvalidInput() throws java.lang.Exception { java.lang.String plain = "plain text"; java.lang.String encrypted = cipher.encrypt(plain); while ((encrypted.charAt(0)) == (encrypted.charAt(1))) { encrypted = cipher.encrypt(plain); } com.google.common.base.Optional<java.lang.String> decrypted = cipher.decrypt((((encrypted.substring(1, 2)) + (encrypted.substring(0, 1))) + (encrypted.substring(2)))); assertThat(decrypted.isPresent()).isTrue(); assertThat(decrypted.get()).isNotEqualTo(plain); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (!(com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { com.google.common.base.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc != null) { return userFactory.create(acc); } } } } return anonymous.get(); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (!(com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { com.google.common.base.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc != null) { return userFactory.create(acc); } } } } return anonymous.get(); }
@org.junit.Test public void testOnTime() throws java.lang.Exception { org.joda.time.DateTime now = now(); assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(now.plusMillis(1)))).isTrue(); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { org.joda.time.DateTime now = now(); assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(now.minusMillis(1)))).isFalse(); }
static boolean onTime(java.lang.String dateTime) { java.lang.String now = com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now()); return (now.compareTo(dateTime)) <= 0; }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now().plusSeconds(expirationSeconds)); }
void appendSubmittedBy(com.google.gerrit.reviewdb.client.Account user) { sb.append("Submitted-by: "); appendUserData(user); sb.append("\n"); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkState(((account == null) || (accountId.equals(account.getId()))), "mismatching account IDs"); boolean needSpace = false; boolean wroteData = false; if (account != null) { if (((account.getFullName()) != null) && (!(account.getFullName().isEmpty()))) { sb.append(account.getFullName()); needSpace = true; wroteData = true; } if (((account.getPreferredEmail()) != null) && (!(account.getPreferredEmail().isEmpty()))) { if (needSpace) { sb.append(" "); } sb.append("<").append(account.getPreferredEmail()).append(">"); wroteData = true; } } if (!wroteData) { sb.append(anonymousCowardName).append(" #").append(accountId); } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null, null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type != null) { fmt.appendApproval(type, a.getValue(), accountCache.get(a.getAccountId()).getAccount()); } } } if (submit != null) { fmt.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount()); fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl) != null) { fmt.appendReviewedOn(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.get()); fmt.appendBranch(change.getDest().get()); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account user) { boolean needSpace = false; boolean wroteData = false; if (((user.getFullName()) != null) && (!(user.getFullName().isEmpty()))) { sb.append(user.getFullName()); needSpace = true; wroteData = true; } if (((user.getPreferredEmail()) != null) && (!(user.getPreferredEmail().isEmpty()))) { if (needSpace) { sb.append(" "); } sb.append("<").append(user.getPreferredEmail()).append(">"); wroteData = true; } if (!wroteData) { sb.append(anonymousCowardName).append(" #").append(user.getId()); } }
void appendApproval(com.google.gerrit.common.data.LabelType label, short value, com.google.gerrit.reviewdb.client.Account user) { sb.append(label.getName()); sb.append(com.google.gerrit.common.data.LabelValue.formatValue(value)); sb.append(": "); appendUserData(user); sb.append("\n"); }
public org.eclipse.jgit.lib.PersonIdent newIdent(com.google.gerrit.reviewdb.client.Account.Id authorId, java.util.Date when, org.eclipse.jgit.lib.PersonIdent serverIdent) { com.google.gerrit.reviewdb.client.Account author = accountCache.get(authorId).getAccount(); return new org.eclipse.jgit.lib.PersonIdent(author.getName(), (((author.getId().get()) + "@") + (serverId)), when, serverIdent.getTimeZone()); }
java.net.URL getBaseUrl() { return baseUrl; }
private java.net.HttpURLConnection prepHttpConnection(java.lang.String spec, boolean isPostRequest) throws java.io.IOException { java.net.URL url = new java.net.URL(baseUrl, spec); java.net.ProxySelector proxySelector = java.net.ProxySelector.getDefault(); java.net.Proxy proxy = org.eclipse.jgit.util.HttpSupport.proxyFor(proxySelector, url); java.net.HttpURLConnection conn = ((java.net.HttpURLConnection) (url.openConnection(proxy))); conn.setRequestProperty("Authorization", ("Basic " + (auth))); conn.setRequestProperty("Content-Type", "application/json"); if (isPostRequest) { conn.setRequestMethod("POST"); conn.setDoOutput(true); } else { conn.setRequestMethod("GET"); } return conn; }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug("validating creation of {}", name); HEAD(81.0F); com.ericsson.gerrit.plugins.projectgroupstructure.d64 Compile = 2.15 - (rc2); com.google.gerrit.server.project.ProjectControl parentCtrl; try { parentCtrl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.error(((((("Failed to create project " + name) + "; Cannot retrieve info about parent project ") + (args.newParent.get())) + ": ") + (e.getMessage())), e); throw new com.google.gerrit.server.validators.ValidationException(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.AN_ERROR_OCCURRED_MSG); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); if (name.contains(" ")) { throw new com.google.gerrit.server.validators.ValidationException(java.lang.String.format(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.PROJECT_CANNOT_CONTAINS_SPACES_MSG, documentationUrl)); } com.google.gerrit.server.project.ProjectControl parentCtrl = args.newParent; if (parentCtrl.getUser().getCapabilities().canAdministrateServer()) com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug("admin is creating project, bypassing all rules"); return; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { } if (allProjectsName.get().equals(parentCtrl.getProject().getNameKey())) { validateRootProject(name, args.permissionsOnly); } else { validateProject(name, parentCtrl); } if ((!(parentCtrl.isOwner())) && (!(configDisableGrantingOwnership(parentCtrl)))) { args.ownerIds.add(createGroup((name + "-admins"))); } }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug("validating creation of {}", name); com.google.gerrit.server.project.ProjectControl parentCtrl = args.newParent; try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug("admin is creating project, bypassing all rules"); return; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { } if (allProjectsName.get().equals(parentCtrl.getProject().getNameKey())) { validateRootProject(name, args.permissionsOnly); } else { validateProject(name, parentCtrl); } if ((!(parentCtrl.isOwner())) && (!(configDisableGrantingOwnership(parentCtrl)))) { args.ownerIds.add(createGroup((name + "-admins"))); } }
public boolean issueExists(java.lang.String issueKey) throws java.io.IOException { com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApi<com.googlesource.gerrit.plugins.its.jira.restapi.JiraIssue> api = apiBuilder.getIssue(); api.doGet(("/" + issueKey), java.net.HttpURLConnection.HTTP_OK, new int[]{ java.net.HttpURLConnection.HTTP_NOT_FOUND, java.net.HttpURLConnection.HTTP_FORBIDDEN }); java.lang.Integer code = api.getResponseCode(); switch (code) { case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_NOT_FOUND : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error("Issue {} not found", issueKey); return false; case java.net.HttpURLConnection.HTTP_FORBIDDEN : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error("No permission to read Issue {}", issueKey); return false; default : throw new java.io.IOException(("Unexpected HTTP code received:" + (code.toString()))); } }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.get(r.iterator().next()).getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = byId.maybeGet(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.get().isActive()))) { continue; } if (match != null) { return null; } match = account.get(); } return match; }
protected java.lang.String getFromLine() { final com.google.gerrit.reviewdb.client.Account account = args.accountCache.get(fromId).getAccount(); final java.lang.String name = account.getFullName(); final java.lang.String email = account.getPreferredEmail(); java.lang.StringBuilder f = new java.lang.StringBuilder(); if (((name != null) && (!(name.isEmpty()))) || ((email != null) && (!(email.isEmpty())))) { f.append("From"); if ((name != null) && (!(name.isEmpty()))) { f.append(" ").append(name); } if ((email != null) && (!(email.isEmpty()))) { f.append(" <").append(email).append(">"); } f.append(":\n\n"); } return f.toString(); }
private void appendIdent(java.io.PrintWriter writer, java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id id, java.sql.Timestamp ts) { org.eclipse.jgit.lib.PersonIdent ident = newIdent(accountCache.get(id).getAccount(), ts, serverIdent); java.lang.StringBuilder name = new java.lang.StringBuilder(); org.eclipse.jgit.lib.PersonIdent.appendSanitized(name, ident.getName()); name.append(" <"); org.eclipse.jgit.lib.PersonIdent.appendSanitized(name, ident.getEmailAddress()); name.append('>'); appendHeaderField(writer, header, name.toString()); }
public com.google.gerrit.reviewdb.client.Account findByNameOrEmail(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAllByNameOrEmail(nameOrEmail); return (r.size()) == 1 ? byId.get(r.iterator().next()).getAccount() : null; }
private void addSubmitRecordLabels(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecordAttribute sa) { if (((submitRecord.labels) != null) && (!(submitRecord.labels.isEmpty()))) { sa.labels = new java.util.ArrayList(); for (SubmitRecord.Label lbl : submitRecord.labels) { com.google.gerrit.server.data.SubmitLabelAttribute la = new com.google.gerrit.server.data.SubmitLabelAttribute(); la.label = lbl.label; la.status = lbl.status.name(); if ((lbl.appliedBy) != null) { com.google.gerrit.server.account.AccountState accountState = accountCache.get(lbl.appliedBy); la.by = asAccountAttribute(accountState); } sa.labels.add(la); } } }
public com.google.gerrit.server.data.AccountAttribute asAccountAttribute(com.google.gerrit.reviewdb.client.Account.Id id) { if (id == null) { return null; } return asAccountAttribute(accountCache.get(id)); }
protected com.google.gerrit.server.account.AccountState getAccountState(com.google.gerrit.reviewdb.client.Account.Id accountId) { return accountCache.maybeGet(accountId).get(); }
protected void removeUsersThatIgnoredTheChange() { for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.util.Collection<java.lang.String>> e : stars.asMap().entrySet()) { if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) { args.accountCache.maybeGet(e.getKey()).map(AccountState::getAccount).ifPresent(( a) -> removeUser(a)); } } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { opResult = com.google.gerrit.server.restapi.change.PostReviewersOp.Result.builder().setAddedReviewers(com.google.common.collect.ImmutableList.copyOf(addedReviewers)).setAddedCCs(com.google.common.collect.ImmutableList.copyOf(addedCCs)).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.Lists.transform(addedReviewers, ( r) -> r.getAccountId()), ((addedCCs) == null ? com.google.common.collect.ImmutableList.of() : addedCCs), reviewersByEmail, addedCCsByEmail, notify, accountsToNotify); if (!(addedReviewers.isEmpty())) { java.util.List<com.google.gerrit.server.account.AccountState> reviewers = addedReviewers.stream().map(( r) -> accountCache.get(r.getAccountId())).collect(java.util.stream.Collectors.toList()); reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen()); } }
private void logOrmException(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.Iterable<?> values, com.google.gwtorm.server.OrmException e) { java.lang.StringBuilder message = new java.lang.StringBuilder(header); message.append(" "); message.append(me); message.append("/"); message.append(accountCache.get(me).getUserName().orElse(null)); message.append(": "); message.append(com.google.common.base.Joiner.on("; ").join(values)); com.google.gerrit.server.group.DbGroupMemberAuditListener.log.error(message.toString(), e); }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.get(accountId).getUserName().orElse(null); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { java.lang.String senderName; if (fromId != null) { com.google.gerrit.reviewdb.client.Account a = accountCache.get(fromId).getAccount(); java.lang.String fullName = a.getFullName(); java.lang.String userEmail = a.getPreferredEmail(); if (canRelay(userEmail)) { return new com.google.gerrit.server.mail.Address(fullName, userEmail); } if ((fullName == null) || ("".equals(fullName.trim()))) { fullName = anonymousCowardName; } senderName = nameRewriteTmpl.replace("user", fullName).toString(); } else { senderName = serverAddress.getName(); } java.lang.String senderEmail; com.google.gerrit.common.data.ParameterizedString senderEmailPattern = new com.google.gerrit.common.data.ParameterizedString(serverAddress.getEmail()); if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { final java.lang.String senderName; if (fromId != null) { final com.google.gerrit.reviewdb.client.Account account = accountCache.get(fromId).getAccount(); java.lang.String fullName = account.getFullName(); if ((fullName == null) || ("".equals(fullName))) { fullName = anonymousCowardName; } senderName = namePattern.replace("user", fullName).toString(); } else { senderName = serverAddress.getName(); } java.lang.String senderEmail; if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
private org.eclipse.jgit.lib.PersonIdent newAuthorIdent(com.google.gerrit.server.notedb.rebuild.EventList<?> events) { com.google.gerrit.reviewdb.client.Account.Id id = events.getAccountId(); if (id == null) { return new org.eclipse.jgit.lib.PersonIdent(serverIdent, events.getWhen()); } return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), events.getWhen(), serverIdent); }
public java.lang.String getUserNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if ((name != null) && (email != null)) { return ((name + " <") + email) + ">"; } else if (email != null) { return email; } else if (name != null) { return name; } return who.getUserName().orElse(null); }
private java.lang.StringBuilder addIdent(java.lang.StringBuilder sb, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(accountId).getAccount(); org.eclipse.jgit.lib.PersonIdent ident = newIdent(account, when); org.eclipse.jgit.lib.PersonIdent.appendSanitized(sb, ident.getName()); sb.append(" <"); org.eclipse.jgit.lib.PersonIdent.appendSanitized(sb, ident.getEmailAddress()); sb.append('>'); return sb; }
public java.lang.String getNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if ((name != null) && (email != null)) { return ((name + " <") + email) + ">"; } else if (name != null) { return name; } else if (email != null) { return email; } else { return ((args.anonymousCowardName) + " #") + accountId; } }
private com.google.gerrit.server.mail.Address toAddress(com.google.gerrit.reviewdb.client.Account.Id id) { final com.google.gerrit.reviewdb.client.Account a = args.accountCache.get(id).getAccount(); final java.lang.String e = a.getPreferredEmail(); if ((!(a.isActive())) || (e == null)) { return null; } return new com.google.gerrit.server.mail.Address(a.getFullName(), e); }
protected java.lang.String getNameFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { if (accountId == null) { return args.gerritPersonIdent.getName(); } final com.google.gerrit.reviewdb.client.Account userAccount = args.accountCache.get(accountId).getAccount(); java.lang.String name = userAccount.getFullName(); if (name == null) { name = userAccount.getPreferredEmail(); } if (name == null) { name = ((args.anonymousCowardName) + " #") + accountId; } return name; }
private Account.Id user(java.lang.String name, java.lang.String email) { final com.google.gerrit.server.account.AccountState s = makeUser(name, email); expect(accountCache.get(eq(s.getAccount().getId()))).andReturn(s); return s.getAccount().getId(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::get).map(AccountState::getAccount).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.getEvenIfMissing(r.iterator().next()).getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = byId.maybeGet(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.get().isActive()))) { continue; } if (match != null) { return null; } match = account.get(); } return match; }
@java.lang.Override public final void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if (changeAlreadyMerged) { logDebug("Skipping post-update steps for change {}", getId()); return; } postUpdateImpl(ctx); if ((command) != null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject())) { git.setGitwebDescription(p.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("cannot update description of " + (p.getName())), e); } } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput.notify, args.accountsToNotify).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot email merged notification for " + (getId())), e); } if (((mergeResultRev) != null) && (!(args.dryrun))) { args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()), args.mergeTip.getCurrentTip().name(), ctx.getWhen()); } }
@java.lang.Override public void fillAccountInfo(java.lang.Iterable<? extends com.google.gerrit.extensions.common.AccountInfo> in, java.util.Set<com.google.gerrit.server.account.FillOptions> options) throws com.google.gerrit.server.account.DirectoryException { if (options.equals(com.google.gerrit.server.account.InternalAccountDirectory.ID_ONLY)) { return; } for (com.google.gerrit.extensions.common.AccountInfo info : in) { com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(info._accountId); com.google.gerrit.server.account.AccountState state = accountCache.get(id); fill(info, state, state.getExternalIds(), options); } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null, null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type != null) { fmt.appendApproval(type, a.getValue(), a.getAccountId(), accountCache.maybeGet(a.getAccountId()).map(AccountState::getAccount).orElse(null)); } } } if (submit != null) { fmt.appendSubmittedBy(submit.getAccountId(), accountCache.maybeGet(submit.getAccountId()).map(AccountState::getAccount).orElse(null)); fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl) != null) { fmt.appendReviewedOn(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.get()); fmt.appendBranch(change.getDest().get()); }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountCache.get(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(", ")); out.write(java.lang.String.format("Members %s group %s: %s\n", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@org.junit.Test public void blockPushDrafts() { allow(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/for/refs/*"); block(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.ANONYMOUS_USERS, "refs/drafts/*"); com.google.gerrit.server.permissions.ProjectControl u = user(local); assertCreateChange("refs/heads/master", u); assertBlocked(com.google.gerrit.server.permissions.PUSH, "refs/drafts/refs/heads/master", u); }
private static java.util.Optional<com.google.gerrit.server.notedb.NoteDbChangeState.RefState> parse(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> parts) { checkArgument((!(parts.isEmpty())), "missing state string for change %s", changeId); org.eclipse.jgit.lib.ObjectId changeMetaId = org.eclipse.jgit.lib.ObjectId.fromString(parts.get(0)); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> draftIds = com.google.common.collect.Maps.newHashMapWithExpectedSize(((parts.size()) - 1)); com.google.common.base.Splitter s = com.google.common.base.Splitter.on('='); for (int i = 1; i < (parts.size()); i++) { java.lang.String p = parts.get(i); java.util.List<java.lang.String> draftParts = s.splitToList(p); checkArgument(((draftParts.size()) == 2), "invalid draft state part for change %s: %s", changeId, p); draftIds.put(Account.Id.parse(draftParts.get(0)), org.eclipse.jgit.lib.ObjectId.fromString(draftParts.get(1))); } return java.util.Optional.of(com.google.gerrit.server.notedb.NoteDbChangeState.RefState.create(changeMetaId, draftIds)); }
private java.util.Optional<com.google.gerrit.server.account.AuthResult> byAccountId(java.lang.String idStr) { final com.google.gerrit.reviewdb.client.Account.Id id; try { id = Account.Id.parse(idStr); } catch (java.lang.NumberFormatException nfe) { return java.util.Optional.empty(); } try { return auth(accounts.get(id)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { getServletContext().log("cannot query database", e); return java.util.Optional.empty(); } }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail); if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); return com.google.common.collect.Streams.stream(accounts.get(id)).map(( a) -> id).collect(toImmutableSet()); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); return com.google.common.collect.Streams.stream(accounts.get(id)).map(( a) -> id).collect(toImmutableSet()); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { java.util.Optional<com.google.gerrit.server.account.AccountState> who = byId.getByUsername(nameOrEmail); if (who.isPresent()) { return com.google.common.collect.ImmutableSet.of(who.map(( a) -> a.getAccount().getId()).get()); } } return findAllByNameOrEmail(nameOrEmail); }
@java.lang.Override public com.google.gerrit.server.mail.ParsedToken decode(java.lang.String tokenString) throws com.google.gerrit.server.mail.InvalidTokenException { checkEmailRegistrationToken(); com.google.gwtjsonrpc.server.ValidToken token; try { token = emailRegistrationToken.checkToken(tokenString, null); } catch (com.google.gwtjsonrpc.server.XsrfException err) { throw new com.google.gerrit.server.mail.InvalidTokenException(err); } if (((token == null) || ((token.getData()) == null)) || (token.getData().isEmpty())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } java.lang.String payload = new java.lang.String(org.eclipse.jgit.util.Base64.decode(token.getData()), java.nio.charset.StandardCharsets.UTF_8); java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("^([0-9]+):(.+@.+)$").matcher(payload); if (!(matcher.matches())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } com.google.gerrit.reviewdb.client.Account.Id id; try { id = Account.Id.parse(matcher.group(1)); } catch (java.lang.IllegalArgumentException err) { throw new com.google.gerrit.server.mail.InvalidTokenException(err); } java.lang.String newEmail = matcher.group(2); return new com.google.gerrit.server.mail.ParsedToken(id, newEmail); }
public static com.google.gerrit.reviewdb.client.Account.Id parse(java.lang.String str) { com.google.gerrit.reviewdb.client.Account.Id r = new com.google.gerrit.reviewdb.client.Account.Id(); r.fromString(str); return r; }
private static void dashboard(java.lang.String token) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); if (rest.matches("[0-9]+")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(Account.Id.parse(rest))); return; } if (rest.equals("self")) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(com.google.gerrit.client.Gerrit.getUserAccount().getId())); } else { com.google.gerrit.client.ui.Screen s = new com.google.gerrit.client.changes.AccountDashboardScreen(null); s.setRequiresSignIn(true); com.google.gerrit.client.Gerrit.display(token, s); } return; } if (rest.startsWith("?")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.CustomDashboardScreen(rest.substring(1))); return; } com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); }
private java.lang.String changeKindMessage(com.google.gerrit.extensions.client.ChangeKind changeKind) { switch (changeKind) { case MERGE_FIRST_PARENT_UPDATE : case TRIVIAL_REBASE : case NO_CHANGE : return (": Patch Set " + (priorPatchSetId.get())) + " was rebased."; case NO_CODE_CHANGE : return ": Commit message was updated."; case REWORK : default : return null; } }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, addedOn); includesAudit.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } } db.accountGroupByIdAud().update(auditUpdates); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e); } }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.get(accountId).getUserName(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName)); } logOrmException(header, me, descriptions, e); }

public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log delete accounts from group event", e); } } }
@java.lang.Override public void onAddSubgroups(com.google.gerrit.server.audit.group.GroupSubgroupAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(com.google.gerrit.server.group.DbGroupMemberAuditListener.toAccountGroupByIdAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForSubgroupsEvent("Cannot log add groups to group event performed by user", event, e); } }
private void removeSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> subgroupsToRemove = subgroupUuids.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), subgroupsToRemove, removedOn); } db.accountGroupById().delete(subgroupsToRemove); }

private void addSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newSubgroups = subgroupUuids.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), newSubgroups, addedOn); } db.accountGroupById().insert(newSubgroups); }
@java.lang.Override public void onAddMembers(com.google.gerrit.server.audit.group.GroupMemberAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(com.google.gerrit.server.group.DbGroupMemberAuditListener.toAccountGroupMemberAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForMembersEvent("Cannot log add accounts to group event performed by user", event, e); } }
private void removeGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = accountIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), membersToRemove, removedOn); } db.accountGroupMembers().delete(membersToRemove); }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, addedOn); auditInserts.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e); } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddAccountsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log add accounts to group event", e); } } }
private void addGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> newMemberIds, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> newMembers = newMemberIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers, addedOn); } db.accountGroupMembers().insert(newMembers); }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log delete groups from group event", e); } } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddGroupsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("failed to log add groups to group event", e); } } }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById m : values) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = m.getIncludeUUID(); java.lang.String groupName = groupBackend.get(groupUuid).getName(); com.google.gerrit.reviewdb.client.AccountGroup.Id targetGroupId = m.getGroupId(); java.lang.String targetGroupName = getGroupName(targetGroupId); descriptions.add(java.text.MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { if (!(stalenessChecker.isStale(id))) { return false; } index(newChangeData(db.get(), project, id)); return true; }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { try { if (stalenessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Change {} was deleted, aborting reindexing the change.", id.get()); } return false; }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { try { if (!(publisherThread.isAlive())) { publisherThread.start(); } queue.put(event); } catch (java.lang.InterruptedException e) { com.googlesource.gerrit.plugins.rabbitmq.message.MessagePublisher.LOGGER.warn("Failed to queue event", e); } }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (recursive) { return getTransitiveMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
@java.lang.Override @com.google.gerrit.common.Nullable public synchronized <T> T get(com.google.gerrit.server.PropertyKey<T> key) { if ((properties) != null) { @java.lang.SuppressWarnings("unchecked") T value = ((T) (properties.get(key))); return value; } return null; }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupNameOrUUID) { com.google.gerrit.reviewdb.client.AccountGroup group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupNameOrUUID))).orElse(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupNameOrUUID))); if (group == null) { com.vmware.gerrit.owners.common.AccountsImpl.log.warn("Group {} was not found", groupNameOrUUID); } try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.openAs(adminUser.getAccountId())) { return groupMembers.create(adminUser).listAccounts(group.getGroupUUID(), null).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gerrit.server.project.NoSuchProjectException | com.google.gwtorm.server.OrmException | java.io.IOException e) { com.vmware.gerrit.owners.common.AccountsImpl.log.error(("Unable to list accounts in group " + group), e); return java.util.Collections.emptySet(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); update(resource.getProjectState().getProject().getName(), resource.getRef(), false); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupNameOrUUID) { com.google.gerrit.reviewdb.client.AccountGroup group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupNameOrUUID))).orElse(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupNameOrUUID))); if (group == null) { com.vmware.gerrit.owners.common.AccountsImpl.log.warn("Group {} was not found", groupNameOrUUID); } try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.openAs(adminUser.getAccountId())) { return groupMembers.create(adminUser).listAccounts(group.getGroupUUID(), null).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gerrit.server.project.NoSuchProjectException | com.google.gwtorm.server.OrmException | java.io.IOException e) { com.vmware.gerrit.owners.common.AccountsImpl.log.error(("Unable to list accounts in group " + group), e); return java.util.Collections.emptySet(); } }
private java.util.Map<java.lang.String, java.lang.Object> toFooterSoyData(com.google.gitiles.Paginator paginator, @javax.annotation.Nullable java.lang.String revision) { java.util.Map<java.lang.String, java.lang.Object> data = com.google.common.collect.Maps.newHashMapWithExpectedSize(1); org.eclipse.jgit.lib.ObjectId next = paginator.getNextStart(); if (next != null) { data.put("nextUrl", copyAndCanonicalizeView(revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl()); } return data; }
@java.lang.Override public java.lang.String authenticate(com.google.gerrit.server.CurrentUser user, java.util.List<java.lang.String> args) throws com.google.gerrit.sshd.BaseCommand.Failure, com.google.gerrit.sshd.BaseCommand.UnloggedFailure { try { java.net.URL url = new java.net.URL(canonicalWebUrl); java.lang.String path = url.getPath(); java.lang.String project = args.get(0); java.lang.String operation = args.get(1); java.lang.StringBuilder href = new java.lang.StringBuilder(url.getProtocol()).append("://").append(url.getAuthority()).append(path).append((path.endsWith("/") ? "" : "/")).append(project).append("/info/lfs"); com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo info = auth.generateAuthInfo(user, project, operation); com.googlesource.gerrit.plugins.lfs.ExpiringAction action = new com.googlesource.gerrit.plugins.lfs.ExpiringAction(href.toString(), info); return gson.toJson(action); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, ((("Server configuration error: " + "forming Git LFS endpoint URL from canonicalWebUrl [") + (canonicalWebUrl)) + "] failed.")); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { final org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; final org.eclipse.jgit.lib.AbbreviatedObjectId id = commit.abbreviate(7); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.ArrayList<>(); if ((this.maxSubjectLength) < (commit.getShortMessage().length())) { onLineTooLong(id, messages, (("commit subject >" + (this.maxSubjectLength)) + " characters; use shorter first paragraph")); } int longLineCnt = 0; int nonEmptyCnt = 0; for (java.lang.String line : commit.getFullMessage().split("\n")) { if (!(line.trim().isEmpty())) { nonEmptyCnt++; } if ((this.maxLineLength) < (line.length())) { longLineCnt++; } } if (longLineCnt > (((longLinesThreshold) * nonEmptyCnt) / 100)) { onLineTooLong(id, messages, (("too many commit message lines longer than " + (this.maxLineLength)) + " characters; manually wrap lines")); } return messages; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final java.lang.String[] tokens = token.split(","); if ((tokens.length) != 3) { throw new org.kohsuke.args4j.CmdLineException(owner, "change should be specified as <project>,<branch>,<change-id>"); } try { final com.google.gerrit.reviewdb.client.Change.Key key = Change.Key.parse(tokens[2]); final com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(tokens[0]); final com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, tokens[1]); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchKey(branch, key)) { setter.addValue(cd.getId()); return 1; } } catch (java.lang.IllegalArgumentException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "Change-Id is not valid"); } catch (com.google.gwtorm.server.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, ("Database error: " + (e.getMessage()))); } throw new org.kohsuke.args4j.CmdLineException(owner, (("\"" + token) + "\": change not found")); }
private static java.util.Map<java.lang.String, java.lang.String> getParameters(javax.servlet.http.HttpServletRequest req) { final java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); for (java.lang.String pair : req.getQueryString().split("[&;]")) { final int eq = pair.indexOf('='); if (0 < eq) { java.lang.String name = pair.substring(0, eq); java.lang.String value = pair.substring((eq + 1)); name = com.google.gerrit.extensions.restapi.Url.decode(name); value = com.google.gerrit.extensions.restapi.Url.decode(value); params.put(name, value); } } return params; }
private void init() { java.lang.String[] varParts = sectionAndKey.split("\\."); if ((varParts.length) != 2) { throw new java.lang.IllegalArgumentException((("Invalid name '" + (sectionAndKey)) + "': expected section.key format")); } section = varParts[0]; key = varParts[1]; }
private java.lang.String getPublicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = getSshPublicKey(); if ((s != null) && ((s.length()) > 0)) { java.lang.String[] parts = s.split(" "); if ((parts.length) > index) { return parts[index]; } } return defaultValue; }
public static java.lang.String trimQuotation(java.lang.String comment) { java.util.StringJoiner j = new java.util.StringJoiner("\n"); java.lang.String[] lines = comment.split("\n"); for (int i = 0; i < ((lines.length) - 2); i++) { j.add(lines[i]); } java.lang.String lastLine = lines[((lines.length) - 1)]; if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLine)) { if ((lines.length) > 1) { j.add(lines[((lines.length) - 2)]); } return j.toString().trim(); } if ((lines.length) > 1) { java.lang.String lastLines = (lines[((lines.length) - 2)]) + lastLine; if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLines)) { return j.toString().trim(); } } if ((lines.length) > 1) { j.add(lines[((lines.length) - 2)]); } j.add(lines[((lines.length) - 1)]); return j.toString().trim(); }
private void readCgiHeaders(javax.servlet.http.HttpServletResponse res, java.io.InputStream in) throws java.io.IOException { java.lang.String line; while (!((line = readLine(in)).isEmpty())) { if (line.startsWith("HTTP")) { throw new java.io.IOException(("NPH CGI not supported: " + line)); } final int sep = line.indexOf(':'); if (sep < 0) { throw new java.io.IOException(("CGI returned invalid header: " + line)); } final java.lang.String key = line.substring(0, sep).trim(); final java.lang.String value = line.substring((sep + 1)).trim(); if ("Location".equalsIgnoreCase(key)) { res.sendRedirect(value); } else if ("Status".equalsIgnoreCase(key)) { final java.lang.String[] token = value.split(" "); final int status = java.lang.Integer.parseInt(token[0]); res.setStatus(status); } else { res.addHeader(key, value); } } }
private void configureAliases() { com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); for (java.util.Map.Entry<java.lang.String, java.lang.String> e : aliases.entrySet()) { java.lang.String name = e.getKey(); java.lang.String[] dest = e.getValue().split("[ \\t]+"); com.google.gerrit.sshd.CommandName cmd = com.google.gerrit.sshd.Commands.named(dest[0]); for (int i = 1; i < (dest.length); i++) { cmd = com.google.gerrit.sshd.Commands.named(cmd, dest[i]); } bind(com.google.gerrit.sshd.Commands.key(gerrit, name)).toProvider(new com.google.gerrit.sshd.AliasCommandProvider(cmd)); } }
public static com.google.gerrit.server.account.HashedPassword decode(java.lang.String encoded) throws org.apache.commons.codec.DecoderException { if (!(encoded.startsWith(com.google.gerrit.server.account.HashedPassword.ALGORITHM_PREFIX))) { throw new org.apache.commons.codec.DecoderException("unrecognized algorithm"); } java.lang.String[] fields = encoded.split(":"); if ((fields.length) != 4) { throw new org.apache.commons.codec.DecoderException("want 4 fields"); } java.lang.Integer cost = com.google.common.primitives.Ints.tryParse(fields[1]); if (cost == null) { throw new org.apache.commons.codec.DecoderException("cost parse failed"); } if (!((cost >= 4) && (cost < 32))) { throw new org.apache.commons.codec.DecoderException(("cost should be 4..31 inclusive, got " + cost)); } byte[] salt = com.google.gerrit.server.account.HashedPassword.codec.decode(fields[2]); if ((salt.length) != 16) { throw new org.apache.commons.codec.DecoderException(("salt should be 16 bytes, got " + (salt.length))); } return new com.google.gerrit.server.account.HashedPassword(com.google.gerrit.server.account.HashedPassword.codec.decode(fields[3]), salt, cost); }
@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(id)) { index(id); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }

@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(uuid)) { index(uuid); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }

private com.google.inject.Injector createSysInjector() { return dbInjector.createChildInjector(new com.google.gerrit.extensions.config.FactoryModule() { @java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); install(getIndexModule()); factory(ChangeResource.Factory.class); } }); }
@java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); install(getIndexModule()); factory(ChangeResource.Factory.class); }
private java.lang.Module getIndexModule() { switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : return com.google.gerrit.lucene.LuceneIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), threads); case ELASTICSEARCH : return com.google.gerrit.elasticsearch.ElasticIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), threads); default : throw new java.lang.IllegalStateException("unsupported index.type"); } }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> toAccounts(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p) { return toAccounts(reviewDb, in, p, null); }










@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor(BATCH) com.google.common.util.concurrent.ListeningExecutorService getBatchIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { if ((batchExecutor) != null) { return batchExecutor; } int threads = config.getInt("index", null, "batchThreads", 0); if (threads <= 0) { threads = java.lang.Runtime.getRuntime().availableProcessors(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "Index-Batch")); }

@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = cfg.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (!(schedule.isPresent())) { com.google.gerrit.server.change.ChangeCleanupRunner.log.info("Ignoring missing changeCleanup schedule configuration"); } else if (((schedule.get().initialDelay()) < 0) || ((schedule.get().interval()) <= 0)) { com.google.gerrit.server.change.ChangeCleanupRunner.log.warn(java.lang.String.format("Ignoring invalid changeCleanup schedule configuration: %s", scheduleConfig)); } else { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(runner, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
@java.lang.Override public void start() { if (!(supportAutomaticAccountActivityUpdate)) { return; } java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (!(schedule.isPresent())) { com.google.gerrit.server.account.AccountDeactivator.log.info("Ignoring missing accountDeactivator schedule configuration"); } else if (((schedule.get().initialDelay()) < 0) || ((schedule.get().interval()) <= 0)) { com.google.gerrit.server.account.AccountDeactivator.log.warn(java.lang.String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig)); } else { queue.getDefaultQueue().scheduleAtFixedRate(deactivator, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }


@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = gcConfig.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (!(schedule.isPresent())) { com.google.gerrit.server.git.GarbageCollectionRunner.log.info("Ignoring missing gc schedule configuration"); } else if (((schedule.get().initialDelay()) < 0) || ((schedule.get().interval()) <= 0)) { com.google.gerrit.server.git.GarbageCollectionRunner.log.warn(java.lang.String.format("Ignoring invalid gc schedule configuration: %s", scheduleConfig)); } else { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(gcRunner, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
public long getInitialDelay() { if ((initialDelay) == null) { load(); } return initialDelay; }
private static long interval(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyInterval) { long interval = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; try { interval = com.google.gerrit.server.config.ConfigUtil.getTimeUnit(rc, section, subsection, keyInterval, (-1), java.util.concurrent.TimeUnit.MILLISECONDS); if (interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) { com.google.gerrit.server.config.ScheduleConfig.log.info(java.text.MessageFormat.format("{0} schedule parameter \"{0}.{1}\" is not configured", section, keyInterval)); } } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.config.ScheduleConfig.log.error(java.text.MessageFormat.format("Invalid {0} schedule parameter \"{0}.{1}\"", section, keyInterval), e); interval = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return interval; }
public com.google.gerrit.server.config.ScheduleConfig.Schedule schedule() { if ((schedule) == null) { schedule = loadSchedule(); } return schedule; }

@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertThat(s.schedule()).isEqualTo(com.google.gerrit.server.config.ScheduleConfig.Schedule.create(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS))); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertThat(s.schedule()).isEqualTo(com.google.gerrit.server.config.ScheduleConfig.Schedule.create(ScheduleConfig.MISSING_CONFIG, ScheduleConfig.MISSING_CONFIG)); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInterval()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(s.getInterval(), ScheduleConfig.MISSING_CONFIG); assertEquals(s.getInitialDelay(), ScheduleConfig.MISSING_CONFIG); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig.builder(com.google.gerrit.server.config.ScheduleConfigTest.config(startTime, interval), "section", "subsection").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build().getInitialDelay(); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return new com.google.gerrit.server.config.ScheduleConfig(com.google.gerrit.server.config.ScheduleConfigTest.config(startTime, interval), "section", "subsection", com.google.gerrit.server.config.ScheduleConfigTest.NOW).getInitialDelay(); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInterval()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(s.getInterval(), ScheduleConfig.MISSING_CONFIG); assertEquals(s.getInitialDelay(), ScheduleConfig.MISSING_CONFIG); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = new com.google.gerrit.server.config.ScheduleConfig(rc, "a", "b", "i", "s", com.google.gerrit.server.config.ScheduleConfigTest.NOW); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInterval()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = new com.google.gerrit.server.config.ScheduleConfig(rc, "a", "b", "myInterval", "myStart", com.google.gerrit.server.config.ScheduleConfigTest.NOW); assertEquals(s.getInterval(), ScheduleConfig.MISSING_CONFIG); assertEquals(s.getInitialDelay(), ScheduleConfig.MISSING_CONFIG); }
private static long initialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start != null) { java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern("[E ]HH:mm").withLocale(java.util.Locale.US); java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } else { com.google.gerrit.server.config.ScheduleConfig.log.info(java.text.MessageFormat.format("{0} schedule parameter \"{0}.{1}\" is not configured", section, keyStartTime)); } } catch (java.lang.IllegalArgumentException e2) { com.google.gerrit.server.config.ScheduleConfig.log.error(java.text.MessageFormat.format("Invalid {0} schedule parameter \"{0}.{1}\"", section, keyStartTime), e2); delay = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }
public long getInitialDelay() { return initialDelay; }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig.builder(ScheduleConfigTest.config(startTime, interval), "section", "subsection").setNow(ScheduleConfigTest.NOW).build().schedule().initialDelay(); }
private static void doCreateTable(java.sql.Statement stmt) throws java.sql.SQLException { stmt.executeUpdate(("CREATE TABLE IF NOT EXISTS account_patch_reviews (" + (((((("account_id INTEGER DEFAULT 0 NOT NULL, " + "change_id INTEGER DEFAULT 0 NOT NULL, ") + "patch_set_id INTEGER DEFAULT 0 NOT NULL, ") + "file_name VARCHAR(4096) DEFAULT '' NOT NULL, ") + "CONSTRAINT primary_key_account_patch_reviews ") + "PRIMARY KEY (change_id, patch_set_id, account_id, file_name)") + ")"))); }
java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getReviewerFilterSections() { com.google.common.collect.ImmutableList.Builder<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> b = com.google.common.collect.ImmutableList.builder(); for (java.lang.String f : cfg.getSubsections(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER)) { b.add(newReviewerFilterSection(f)); } return b.build(); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Update reviewers configuration\n"); } saveConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILENAME, cfg); return true; }




private java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getSections(com.google.gerrit.reviewdb.client.Project.NameKey projectName) { return configFactory.create(projectName).getReviewerFilterSections(); }

@java.lang.Override public int compareTo(com.googlesource.gerrit.plugins.importer.GerritApi.Version o) { if (((major) == null) || ((o.major) == null)) { return -1; } if ((major) == (o.major)) { if (com.google.common.base.Objects.equal(minor, o.minor)) { if (com.google.common.base.Objects.equal(patch, o.patch)) { return 0; } if ((o.patch) == null) { return 1; } if ((patch) == null) { return -1; } return (patch) - (o.patch); } if ((o.minor) == null) { return 1; } if ((minor) == null) { return -1; } return (minor) - (o.minor); } return (major) - (o.major); }
@org.junit.Test public void validPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.VALID_CHARACTERS.toCharArray()) { assertTrue(("valid character rejected: " + c), com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c)); } }
@org.junit.Test public void inalidPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.SOME_INVALID_CHARACTERS.toCharArray()) { assertFalse(("invalid character accepted: " + c), com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c)); } }
@java.lang.Override public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getRefs(java.lang.String prefix) throws java.io.IOException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = refFilter.filter(delegate.getRefs(prefix), true); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = com.google.common.collect.Maps.newHashMapWithExpectedSize(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { result.put(ref.getName().substring(prefix.length()), ref); } return refs; }
@java.lang.Override public org.eclipse.jgit.lib.Ref exactRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.exactRef(name); if (ref == null) { return null; } return refFilter.filter(com.google.common.collect.ImmutableMap.of(name, ref), true).get(name); }
@java.lang.Override public org.eclipse.jgit.lib.Ref getRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.getRef(name); if (ref == null) { return null; } return refFilter.filter(com.google.common.collect.ImmutableMap.of(ref.getName(), ref), true).get(ref.getName()); }
public static void loadSiteLib(java.nio.file.Path libdir) { try { com.google.gerrit.common.IoUtil.loadJARs(com.google.gerrit.common.SiteLibraryLoaderUtil.listJars(libdir)); } catch (java.io.IOException e) { com.google.gerrit.common.SiteLibraryLoaderUtil.log.error(("Error scanning lib directory " + libdir), e); } }


protected void init() throws com.google.gerrit.common.errors.EmailException { setupSoyContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new com.google.gerrit.server.mail.send.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); setHeader("Message-ID", ""); for (com.google.gerrit.extensions.api.changes.RecipientType recipientType : accountsToNotify.keySet()) { add(recipientType, accountsToNotify.get(recipientType)); } setHeader("X-Gerrit-MessageType", messageClass); textBody = new java.lang.StringBuilder(); htmlBody = new java.lang.StringBuilder(); if (((fromId) != null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { appendText(getFromLine()); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.mode", value = "WHITELIST") @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" }) public void listFilterWhitelistFiltersNotListedUser() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo changeInfo = createChangeAndReplyByEmail(); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages; assertThat(messages).hasSize(2); }

private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start != null) { java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern("[E ]HH:mm").withLocale(java.util.Locale.US); java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } } catch (java.lang.IllegalArgumentException e2) { delay = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }



private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start != null) { java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern("[E ]HH:mm").withLocale(java.util.Locale.US); java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } } catch (java.lang.IllegalArgumentException e2) { delay = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }
public static com.google.gerrit.server.config.ScheduleConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return new com.google.gerrit.server.config.AutoValue_ScheduleConfig.Builder().setNow(java.time.ZonedDateTime.now(java.time.ZoneId.systemDefault())).setKeyInterval(com.google.gerrit.server.config.ScheduleConfig.KEY_INTERVAL).setKeyStartTime(com.google.gerrit.server.config.ScheduleConfig.KEY_STARTTIME).setConfig(config).setSection(section); }
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isInternalUser()) || (canPerformOnAnyRef(Permission.READ)))) || (isOwner()); case READ : return (!(isHidden())) && (allRefsAreVisible(java.util.Collections.emptySet())); case CREATE_REF : return canAddRefs(); case CREATE_CHANGE : return canCreateChanges(); case RUN_RECEIVE_PACK : return canRunReceivePack(); case RUN_UPLOAD_PACK : return canRunUploadPack(); case PUSH_AT_LEAST_ONE_REF : return canPushToAtLeastOneRef(); case BAN_COMMIT : case READ_REFLOG : case READ_CONFIG : case WRITE_CONFIG : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }

private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return "Command was already destroyed"; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] args = dcmd.getArguments(); for (int i = 1; i < (args.length); i++) { commandName.append(".").append(args[i]); } return commandName.toString(); }
private boolean canForceUpdate() { if (canPushWithForce()) { return true; } switch (getUser().getAccessPath()) { case GIT : return false; case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return ((isOwner()) && (!(isForceBlocked(Permission.PUSH)))) || (projectControl.isAdmin()); } }
private boolean canDelete() { if (RefNames.REFS_CONFIG.equals(refName)) { return false; } switch (getUser().getAccessPath()) { case GIT : return (canPushWithForce()) || (canPerform(Permission.DELETE)); case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return ((((isOwner()) && (!(isForceBlocked(Permission.PUSH)))) || (canPushWithForce())) || (canPerform(Permission.DELETE))) || (projectControl.isAdmin()); } }

boolean canForceEditTopicName() { return canForcePerform(Permission.EDIT_TOPIC_NAME); }
com.google.gerrit.server.permissions.ProjectRef getRuleProps(com.google.gerrit.common.data.PermissionRule rule) { return ruleProps.get(rule); }
public java.lang.Iterable<java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.common.data.PermissionRule>>> getDeclaredPermissions() { return rules.entrySet(); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getPermission(java.lang.String permissionName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = rules.get(permissionName); return r != null ? r : java.util.Collections.<com.google.gerrit.common.data.PermissionRule>emptyList(); }
private com.google.gerrit.common.data.PermissionRange toRange(java.lang.String permissionName, java.util.List<com.google.gerrit.common.data.PermissionRule> ruleList) { java.util.Map<com.google.gerrit.server.permissions.ProjectRef, com.google.gerrit.server.permissions.RefControl.AllowedRange> ranges = new java.util.HashMap<>(); for (com.google.gerrit.common.data.PermissionRule rule : ruleList) { com.google.gerrit.server.permissions.ProjectRef p = relevant.getRuleProps(rule); com.google.gerrit.server.permissions.RefControl.AllowedRange r = ranges.get(p); if (r == null) { r = new com.google.gerrit.server.permissions.RefControl.AllowedRange(); ranges.put(p, r); } r.update(rule); } int allowMin = 0; int allowMax = 0; int blockMin = java.lang.Integer.MIN_VALUE; int blockMax = java.lang.Integer.MAX_VALUE; for (com.google.gerrit.server.permissions.RefControl.AllowedRange r : ranges.values()) { allowMin = java.lang.Math.min(allowMin, r.getAllowMin()); allowMax = java.lang.Math.max(allowMax, r.getAllowMax()); blockMin = java.lang.Math.max(blockMin, r.getBlockMin()); blockMax = java.lang.Math.min(blockMax, r.getBlockMax()); } int min = java.lang.Math.max(allowMin, (blockMin + 1)); int max = java.lang.Math.min(allowMax, (blockMax - 1)); return new com.google.gerrit.common.data.PermissionRange(permissionName, min, max); }
java.util.List<com.google.gerrit.common.data.PermissionRule> getOverridden(java.lang.String permissionName) { return firstNonNull(overridden.get(permissionName), java.util.Collections.<com.google.gerrit.common.data.PermissionRule>emptyList()); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE; if (ui.yesno(false, "Migrate draft changes to work-in-progress changes (default is private)?")) { strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS; } ui.message(java.lang.String.format("Replace draft changes with %s changes ...", strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE)) ? "is_private" : "work_in_progress"; e.execute(java.lang.String.format(("UPDATE changes SET %s = 'Y', created_on = created_on WHERE status = 'd' OR " + ("EXISTS (SELECT * FROM patch_sets WHERE " + "patch_sets.change_id = changes.change_id AND patch_sets.draft = 'Y')")), column)); e.execute("UPDATE changes SET status = 'n', created_on = created_on WHERE status = 'd'"); } ui.message("done"); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS; if (ui.yesno(false, "Migrate draft changes to private changes (default is work-in-progress)?")) { strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE; } ui.message(java.lang.String.format("Replace draft changes with %s changes ...", strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE)) ? "is_private" : "work_in_progress"; e.execute(java.lang.String.format(("UPDATE changes SET %s = 'Y', created_on = created_on WHERE status = 'd' OR " + ("EXISTS (SELECT * FROM patch_sets WHERE " + "patch_sets.change_id = changes.change_id AND patch_sets.draft = 'Y')")), column)); e.execute("UPDATE changes SET status = 'n', created_on = created_on WHERE status = 'd'"); } ui.message("done"); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return "Command was already destroyed"; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] args = dcmd.getArguments(); for (int i = 1; i < (args.length); i++) { commandName.append(".").append(args[i]); } return commandName.toString(); }

@org.junit.Test public void testHealthCheckEnabled() throws java.lang.Exception { when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HEALTH_CHECK_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.ENABLE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HEALTH_CHECK_ENABLED)).thenReturn(false); initializeConfiguration(); assertThat(configuration.healthCheck().enabled()).isFalse(); }
@org.junit.Test public void testGetJGroupsSkipInterface() throws java.lang.Exception { when(globalPluginConfigMock.getEnum(com.ericsson.gerrit.plugins.highavailability.Configuration.PEER_INFO_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.STRATEGY_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_PEER_INFO_STRATEGY)).thenReturn(Configuration.PeerInfoStrategy.JGROUPS); initializeConfiguration(); assertThat(configuration.jgroups().skipInterface()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SKIP_INTERFACE_LIST); when(globalPluginConfigMock.getStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SKIP_INTERFACE_KEY)).thenReturn(new java.lang.String[]{ "lo*", "eth0" }); initializeConfiguration(); assertThat(configuration.jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder(); }
@org.junit.Test public void testGetJGroupsCluster() throws java.lang.Exception { when(globalPluginConfigMock.getEnum(com.ericsson.gerrit.plugins.highavailability.Configuration.PEER_INFO_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.STRATEGY_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_PEER_INFO_STRATEGY)).thenReturn(Configuration.PeerInfoStrategy.JGROUPS); initializeConfiguration(); assertThat(configuration.jgroups().clusterName()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_CLUSTER_NAME); when(globalPluginConfigMock.getString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUSTER_NAME_KEY)).thenReturn("foo"); initializeConfiguration(); assertThat(configuration.jgroups().clusterName()).isEqualTo("foo"); }
@org.junit.Test public void testGetWebsessionSynchronize() throws java.lang.Exception { when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(true); initializeConfiguration(); assertThat(configuration.websession().synchronize()).isTrue(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(false); initializeConfiguration(); assertThat(configuration.websession().synchronize()).isFalse(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenThrow(new java.lang.IllegalArgumentException(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.ERROR_MESSAGE)); initializeConfiguration(); assertThat(configuration.websession().synchronize()).isTrue(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { initializeConfiguration(); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(configuration); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) { assertThat(matcher.matches(cache)).isTrue(); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo")) { assertThat(matcher.matches(cache)).isFalse(); } }
@org.junit.Test public void testGetEventSynchronize() throws java.lang.Exception { when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(true); initializeConfiguration(); assertThat(configuration.event().synchronize()).isTrue(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(false); initializeConfiguration(); assertThat(configuration.event().synchronize()).isFalse(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenThrow(new java.lang.IllegalArgumentException(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.ERROR_MESSAGE)); initializeConfiguration(); assertThat(configuration.event().synchronize()).isTrue(); }
@org.junit.Test public void testGetIndexSynchronize() throws java.lang.Exception { when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(true); initializeConfiguration(); assertThat(configuration.index().synchronize()).isTrue(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(false); initializeConfiguration(); assertThat(configuration.index().synchronize()).isFalse(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenThrow(new java.lang.IllegalArgumentException(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.ERROR_MESSAGE)); initializeConfiguration(); assertThat(configuration.index().synchronize()).isTrue(); }

@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, com.google.common.collect.Lists.newArrayList("^my_cache.*", "other")); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(getConfiguration()); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) { assertThat(matcher.matches(cache)).isTrue(); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo")) { assertThat(matcher.matches(cache)).isFalse(); } }
@org.junit.Test public void testGetCacheSynchronize() throws java.lang.Exception { when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(true); initializeConfiguration(); assertThat(configuration.cache().synchronize()).isTrue(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenReturn(false); initializeConfiguration(); assertThat(configuration.cache().synchronize()).isFalse(); when(globalPluginConfigMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SYNCHRONIZE)).thenThrow(new java.lang.IllegalArgumentException(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.ERROR_MESSAGE)); initializeConfiguration(); assertThat(configuration.cache().synchronize()).isTrue(); }
static boolean onTime(java.lang.String dateTime) { java.lang.String now = com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now()); return (now.compareTo(dateTime)) <= 0; }
@org.junit.Test public void testOnTime() throws java.lang.Exception { org.joda.time.DateTime now = now(); assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(now.plusMillis(1)))).isTrue(); }




static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now().plusSeconds(expirationSeconds)); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { org.joda.time.DateTime now = now(); assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.print(now.minusMillis(1)))).isFalse(); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if ((request instanceof javax.servlet.http.HttpServletRequest) && (response instanceof javax.servlet.http.HttpServletResponse)) { java.lang.String method = ((javax.servlet.http.HttpServletRequest) (request)).getMethod(); if (((method == "POST") || (method == "PUT")) || (method == "DELETE")) { ((javax.servlet.http.HttpServletResponse) (response)).sendError(com.googlesource.gerrit.plugins.readonly.SC_SERVICE_UNAVAILABLE, com.googlesource.gerrit.plugins.readonly.ReadOnly.READ_ONLY_MSG); return; } } chain.doFilter(request, response); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { throw new com.google.gerrit.server.git.validators.CommitValidationException(com.googlesource.gerrit.plugins.readonly.ReadOnly.READ_ONLY_MSG); }

public void tearDown() throws java.lang.Exception { stat.execute(("DROP TABLE " + (com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME))); store.stop(); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig("^WIP.*", true); }








private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore); when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }


@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.regex.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result = !(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("The specified ignore pattern was invalid", e); } return result; }
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug("{} {} {}", operation.name().toLowerCase(java.util.Locale.US), type, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.atomic.AtomicInteger idLock = getAndIncrementIdLock(id); synchronized(idLock) { index(id, operation); } if ((idLock.decrementAndGet()) == 0) { removeIdLock(id); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_CONFLICT, e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.error("Unable to update {} index", type, e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format("Error trying to find %s \n", type); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, msg); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }

@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.uploadvalidator.PatternCacheModule()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FooterValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.module()); bind(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactory.class).to(com.googlesource.gerrit.plugins.uploadvalidator.PluginConfigWithInheritanceFactory.class).in(Scopes.SINGLETON); }






@java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance("ItsTestName"); sitePath = randomTargetPath(); assertFalse((("sitePath already (" + (sitePath)) + ") already exists"), java.nio.file.Files.exists(sitePath)); cleanupSitePath = true; rulesConfigReader = createMock(com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.class); bind(com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.class).toInstance(rulesConfigReader); rulesProjectCache = createMock(com.googlesource.gerrit.plugins.its.base.workflow.ItsRulesProjectCache.class); bind(com.googlesource.gerrit.plugins.its.base.workflow.ItsRulesProjectCache.class).toInstance(rulesProjectCache); bind(java.nio.file.Path.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.GlobalRulesFileName.class).toInstance(com.googlesource.gerrit.plugins.its.base.workflow.RuleBaseTest.RuleBaseKind.GLOBAL.fileName); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.PluginRulesFileName.class).toInstance(com.googlesource.gerrit.plugins.its.base.workflow.RuleBaseTest.RuleBaseKind.ITS.fileName); }

@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully indexed", id); break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully deleted from index", id); break; } }
@java.lang.Override protected void configure() { bind(java.util.concurrent.Executor.class).annotatedWith(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutor.class).toProvider(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.ChangeIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.AccountIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); }

@java.lang.Override void index(com.google.gerrit.reviewdb.client.Account.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug("Account {} successfully indexed", id); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(uuid); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug("Group {} successfully indexed", uuid); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully indexed", id); } catch (java.lang.Exception e) { if (!(isCausedByNoSuchChangeException(e))) { throw e; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} was deleted, aborting forwarded indexing the change.", id.get()); } break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully deleted from index", id); break; } }
public void setLastLoginExternalIdKey(com.google.gerrit.server.account.ExternalId.Key externalIdKey) { put(lastLoginExternalIdPropertyKey, externalIdKey); }
private void convertLocalUserToLowerCase(com.google.gerrit.server.account.ExternalId extId) { if (extId.isScheme(com.google.gerrit.pgm.SCHEME_GERRIT)) { java.lang.String localUser = extId.key().id(); java.lang.String localUserLowerCase = localUser.toLowerCase(java.util.Locale.US); if (!(localUser.equals(localUserLowerCase))) { com.google.gerrit.server.account.ExternalId extIdLowerCase = com.google.gerrit.server.account.ExternalId.create(com.google.gerrit.pgm.SCHEME_GERRIT, localUserLowerCase, extId.accountId(), extId.email(), extId.password()); externalIdsBatchUpdate.replace(extId, extIdLowerCase); } } }
@java.lang.Override public int run() throws java.lang.Exception { com.google.inject.Injector dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); manager.add(dbInjector, dbInjector.createChildInjector(com.google.gerrit.server.schema.SchemaVersionCheck.module())); manager.start(); dbInjector.injectMembers(this); try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { java.util.Collection<com.google.gerrit.server.account.ExternalId> todo = com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().all().toList()); monitor.beginTask("Converting local usernames", todo.size()); for (com.google.gerrit.server.account.ExternalId extId : todo) { convertLocalUserToLowerCase(extId); monitor.update(1); } externalIdsBatchUpdate.commit(db, "Convert local usernames to lower case"); } monitor.endTask(); manager.stop(); return 0; }

private static boolean correctUser(java.lang.String user, com.google.gerrit.httpd.WebSession session) { com.google.gerrit.server.account.ExternalId.Key id = session.getLastLoginExternalId(); return (id != null) && (id.equals(ExternalId.Key.create(com.google.gerrit.httpd.auth.container.SCHEME_GERRIT, user))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.ConfirmEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } if (input == null) { input = new com.google.gerrit.server.config.ConfirmEmail.Input(); } if ((input.token) == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("missing token"); } try { com.google.gerrit.server.mail.EmailTokenVerifier.ParsedToken token = emailTokenVerifier.decode(input.token); com.google.gerrit.reviewdb.client.Account.Id accId = user.getAccountId(); if (accId.equals(token.getAccountId())) { accountManager.link(accId, token.toAuthRequest()); return com.google.gerrit.extensions.restapi.Response.none(); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("invalid token"); } catch (com.google.gerrit.server.mail.EmailTokenVerifier e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("invalid token"); } catch (com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } }
private com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.BlockExternalIdUpdateListener(allUsers))); }
private com.google.gerrit.server.git.validators.CommitValidators forReceiveCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(repo, rw); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.CommitterUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.BannedCommitsValidator(rejectCommits), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.BlockExternalIdUpdateListener(allUsers))); } }
private void writeObject(final java.io.ObjectOutputStream out) throws java.io.IOException { writeVarInt32(out, 1); writeVarInt32(out, accountId.get()); writeVarInt32(out, 2); writeFixInt64(out, refreshCookieAt); writeVarInt32(out, 3); writeVarInt32(out, (persistentCookie ? 1 : 0)); if ((externalId) != null) { writeVarInt32(out, 4); writeString(out, externalId.toString()); } if ((sessionId) != null) { writeVarInt32(out, 5); writeString(out, sessionId); } writeVarInt32(out, 6); writeFixInt64(out, expiresAt); if ((auth) != null) { writeVarInt32(out, 7); writeString(out, auth); } writeVarInt32(out, 0); }
ExternalId.Key getExternalId() { return externalId; }
private ExternalId.Key toExtIdKey(byte[] fp) { return ExternalId.Key.create(com.google.gerrit.gpg.server.SCHEME_GPGKEY, com.google.common.io.BaseEncoding.base16().encode(fp)); }
com.google.gerrit.httpd.WebSessionManager.Val createVal(com.google.gerrit.httpd.WebSessionManager.Key key, com.google.gerrit.reviewdb.client.Account.Id who, boolean remember, com.google.gerrit.server.account.ExternalId.Key lastLogin, java.lang.String sid, java.lang.String auth) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long now = nowMs(); final long refreshCookieAt = now + refresh; final long expiresAt = now + (sessionMaxAgeMillis); if (sid == null) { sid = newUniqueToken(who); } if (auth == null) { auth = newUniqueToken(who); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth); self.put(key.token, val); return val; }
public java.util.List<java.lang.String> getSecondaryEmails(com.google.gerrit.reviewdb.client.Account account, java.util.Collection<com.google.gerrit.server.account.ExternalId> externalIds) { java.util.List<java.lang.String> emails = new java.util.ArrayList(com.google.gerrit.server.account.AccountState.getEmails(externalIds)); if ((account.getPreferredEmail()) != null) { emails.remove(account.getPreferredEmail()); } java.util.Collections.sort(emails); return emails; }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return java.util.Optional.ofNullable(com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().get(ExternalId.Key.create(com.google.gerrit.server.auth.ldap.SCHEME_GERRIT, username).asAccountExternalIdKey()))).map(ExternalId::accountId); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { externalIdsUpdateFactory.create().insert(db, com.google.gerrit.server.account.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress()) != null) { byEmailCache.evict(who.getEmailAddress()); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); } }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Collection<com.google.gerrit.server.account.ExternalId> filteredExtIdsByScheme = com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().byAccount(to).toList()).stream().filter(( e) -> e.isScheme(who.getExternalIdKey().scheme())).collect(java.util.stream.Collectors.toSet()); if ((!(filteredExtIdsByScheme.isEmpty())) && (((filteredExtIdsByScheme.size()) > 1) || (!(filteredExtIdsByScheme.stream().filter(( e) -> e.key().equals(who.getExternalIdKey())).findAny().isPresent())))) { externalIdsUpdateFactory.create().delete(db, filteredExtIdsByScheme); } byIdCache.evict(to); return link(to, who); } }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (who.getExternalIdKey().get())) + "' in use by another account")); } externalIdsUpdateFactory.create().delete(db, extId); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (who.getExternalIdKey().get())) + "' not found")); } return new com.google.gerrit.server.account.AuthResult(from, who.getExternalIdKey(), false); } }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.server.account.ExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); externalIdsUpdateFactory.create().delete(db, extId); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId id = findExternalId(db, who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> putGpgKeys(com.google.gerrit.server.account.AccountResource account, java.util.List<java.lang.String> add, java.util.List<java.lang.String> delete) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.GpgException { com.google.gerrit.gpg.server.PostGpgKeys.Input in = new com.google.gerrit.gpg.server.PostGpgKeys.Input(); in.add = add; in.delete = delete; try { return postGpgKeys.apply(account, in); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.server.GpgException(e); } }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.FluentIterable<com.google.gerrit.server.account.ExternalId> getGpgExtIds(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().byAccount(accountId).toList())).filter(( in) -> in.isScheme(com.google.gerrit.gpg.server.SCHEME_GPGKEY)); }
static byte[] parseFingerprint(java.lang.String str, java.lang.Iterable<com.google.gerrit.server.account.ExternalId> existingExtIds) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { str = com.google.common.base.CharMatcher.whitespace().removeFrom(str).toUpperCase(); if ((((str.length()) != 8) && ((str.length()) != 40)) || (!(com.google.common.base.CharMatcher.anyOf("0123456789ABCDEF").matchesAllOf(str)))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } byte[] fp = null; for (com.google.gerrit.server.account.ExternalId extId : existingExtIds) { java.lang.String fpStr = extId.key().id(); if (!(fpStr.endsWith(str))) { continue; } else if (fp != null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple keys found for " + str)); } fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); if ((str.length()) == 40) { break; } } if (fp == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } return fp; }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { com.google.gerrit.gpg.server.GpgKeys.checkVisible(self, rsrc); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keys = new java.util.HashMap<>(); try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { for (com.google.gerrit.server.account.ExternalId extId : getGpgExtIds(rsrc)) { java.lang.String fpStr = extId.key().id(); byte[] fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); boolean found = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(com.google.gerrit.gpg.server.GpgKeys.keyId(fp))) { if (java.util.Arrays.equals(keyRing.getPublicKey().getFingerprint(), fp)) { found = true; com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing.getPublicKey(), checkerFactory.create(rsrc.getUser(), store), store); keys.put(info.id, info); info.id = null; break; } } if (!found) { com.google.gerrit.gpg.server.GpgKeys.log.warn("No public key stored for fingerprint {}", com.google.gerrit.gpg.Fingerprint.toString(fp)); } } } return keys; }
com.google.gerrit.httpd.WebSessionManager.Val createVal(com.google.gerrit.httpd.WebSessionManager.Key key, com.google.gerrit.httpd.WebSessionManager.Val val) { com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId(); boolean remember = val.isPersistentCookie(); com.google.gerrit.server.account.ExternalId.Key lastLogin = val.getExternalId(); return createVal(key, who, remember, lastLogin, val.sessionId, val.auth); }
private com.google.gerrit.gpg.CheckResult checkIdsForArbitraryUser(org.bouncycastle.openpgp.PGPPublicKey key) throws com.google.gwtorm.server.OrmException, org.bouncycastle.openpgp.PGPException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key)); if (accountStates.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("Key is not associated with any users"); } if ((accountStates.size()) > 1) { return com.google.gerrit.gpg.CheckResult.bad("Key is associated with multiple users"); } com.google.gerrit.server.IdentifiedUser user = userFactory.create(accountStates.get(0)); java.util.Set<java.lang.String> allowedUserIds = getAllowedUserIds(user); if (allowedUserIds.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("No identities found for user"); } if (hasAllowedUserId(key, allowedUserIds)) { return com.google.gerrit.gpg.CheckResult.trusted(); } return com.google.gerrit.gpg.CheckResult.bad("Key does not contain any valid certifications for user's identities"); }
private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException { PARSE : for (; ;) { final int tag = readVarInt32(in); switch (tag) { case 0 : break PARSE; case 1 : accountId = new com.google.gerrit.reviewdb.client.Account.Id(readVarInt32(in)); continue; case 2 : refreshCookieAt = readFixInt64(in); continue; case 3 : persistentCookie = (readVarInt32(in)) != 0; continue; case 4 : externalId = ExternalId.Key.parse(readString(in)); continue; case 5 : sessionId = readString(in); continue; case 6 : expiresAt = readFixInt64(in); continue; case 7 : auth = readString(in); continue; default : throw new java.io.IOException(("Unknown tag found in object: " + tag)); } } if ((expiresAt) == 0) { expiresAt = (refreshCookieAt) + (java.util.concurrent.TimeUnit.HOURS.toMillis(2)); } }
private boolean isTrusted(com.google.gerrit.server.account.ExternalId id) { if (id.isScheme(com.google.gerrit.server.config.SCHEME_MAILTO)) { return true; } if (id.isScheme(com.google.gerrit.server.config.SCHEME_UUID)) { return true; } if (id.isScheme(com.google.gerrit.server.config.SCHEME_USERNAME)) { return true; } for (com.google.gerrit.server.auth.openid.OpenIdProviderPattern p : trustedOpenIDs) { if (p.matches(id)) { return true; } } return false; }
private java.util.Set<com.google.gerrit.gpg.Fingerprint> readKeysToRemove(com.google.gerrit.gpg.server.PostGpgKeys.Input input, java.util.Collection<com.google.gerrit.server.account.ExternalId> existingExtIds) { if (((input.delete) == null) || (input.delete.isEmpty())) { return com.google.common.collect.ImmutableSet.of(); } java.util.Set<com.google.gerrit.gpg.Fingerprint> fingerprints = com.google.common.collect.Sets.newHashSetWithExpectedSize(input.delete.size()); for (java.lang.String id : input.delete) { try { fingerprints.add(new com.google.gerrit.gpg.Fingerprint(com.google.gerrit.gpg.server.GpgKeys.parseFingerprint(id, existingExtIds))); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } return fingerprints; }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), new java.util.HashMap()); }
public boolean matches(com.google.gerrit.server.account.ExternalId extId) { return matches(extId.key().get()); }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.emptySet(), java.util.Collections.emptySet(), new java.util.HashMap()); }
java.util.List<com.google.gerrit.server.account.ExternalId> create(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String username, java.lang.String email);
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.server.account.AccountState accountState : accountQueryProvider.get().byEmailPrefix(email)) { if (accountState.getExternalIds().stream().filter(( e) -> email.equals(e.email())).findAny().isPresent()) { r.add(accountState.getAccount().getId()); } } return com.google.common.collect.ImmutableSet.copyOf(r); } }
public boolean checkPassword(java.lang.String password, java.lang.String username) { if (password == null) { return false; } for (com.google.gerrit.server.account.ExternalId id : getExternalIds()) { if ((!(id.isScheme(com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME))) || (!(username.equals(id.key().id())))) { continue; } java.lang.String hashedStr = id.password(); if (!(com.google.common.base.Strings.isNullOrEmpty(hashedStr))) { try { return com.google.gerrit.server.account.HashedPassword.decode(hashedStr).checkPassword(password); } catch (org.apache.commons.codec.DecoderException e) { com.google.gerrit.server.account.AccountState.logger.error(java.lang.String.format("DecoderException for user %s: %s ", username, e.getMessage())); return false; } } } return false; }
public static java.util.Set<java.lang.String> getEmails(java.util.Collection<com.google.gerrit.server.account.ExternalId> ids) { java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (com.google.gerrit.server.account.ExternalId extId : ids) { if (extId.isScheme(com.google.gerrit.server.account.ExternalId.SCHEME_MAILTO)) { emails.add(extId.key().id()); } } return emails; }
public java.util.Collection<com.google.gerrit.server.account.ExternalId> getExternalIds() { return externalIds; }
public static java.lang.String getUserName(java.util.Collection<com.google.gerrit.server.account.ExternalId> ids) { for (com.google.gerrit.server.account.ExternalId extId : ids) { if (extId.isScheme(com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME)) { return extId.key().id(); } } return null; }
private void addExternalId(java.lang.String scheme, java.lang.String id, java.lang.String email) throws java.lang.Exception { externalIdsUpdateFactory.create().insert(db, com.google.gerrit.server.account.ExternalId.createWithEmail(scheme, id, user.getAccountId(), email)); reloadUser(); }
public java.util.List<com.google.gerrit.server.account.AccountState> byExternalId(java.lang.String scheme, java.lang.String id) throws com.google.gwtorm.server.OrmException { return byExternalId(ExternalId.Key.create(scheme, id)); }
public com.google.gerrit.server.account.AccountState oneByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { return oneByExternalId(ExternalId.Key.parse(externalId)); }
@java.lang.Override public void addEmail(com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), input.email); try { createEmailFactory.create(input.email).apply(rsrc, input); } catch (com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add email", e); } }
private void addExternalIdEmail(com.google.gerrit.acceptance.TestAccount account, java.lang.String email) throws java.lang.Exception { checkNotNull(email); externalIdsUpdate.insert(db, com.google.gerrit.server.account.ExternalId.createWithEmail(name("test"), email, account.getId(), email)); accountCache.evict(account.getId()); setApiUser(account); }
@org.junit.Before public void saveExternalIds() throws java.lang.Exception { externalIdsUpdate = externalIdsUpdateFactory.create(); savedExternalIds = new java.util.ArrayList(); savedExternalIds.addAll(getExternalIds(admin)); savedExternalIds.addAll(getExternalIds(user)); }
@org.junit.Test public void deleteEmailFromCustomExternalIdSchemes() throws java.lang.Exception { java.lang.String email = "foo.bar@example.com"; java.lang.String extId1 = "foo:bar"; java.lang.String extId2 = "foo:baz"; java.util.List<com.google.gerrit.server.account.ExternalId> extIds = com.google.common.collect.ImmutableList.of(com.google.gerrit.server.account.ExternalId.createWithEmail(ExternalId.Key.parse(extId1), admin.id, email), com.google.gerrit.server.account.ExternalId.createWithEmail(ExternalId.Key.parse(extId2), admin.id, email)); externalIdsUpdateFactory.create().insert(db, extIds); accountCache.evict(admin.id); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identity).collect(java.util.stream.Collectors.toSet())).containsAllOf(extId1, extId2); resetCurrentApiUser(); assertThat(getEmails()).contains(email); gApi.accounts().self().deleteEmail(email); resetCurrentApiUser(); assertThat(getEmails()).doesNotContain(email); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identity).collect(java.util.stream.Collectors.toSet())).containsNoneOf(extId1, extId2); }
private java.util.Collection<com.google.gerrit.server.account.ExternalId> getExternalIds(com.google.gerrit.acceptance.TestAccount account) throws java.lang.Exception { return accountCache.get(account.getId()).getExternalIds(); }
@org.junit.Test public void noExternalIds() throws java.lang.Exception { com.google.gerrit.server.account.ExternalIdsUpdate externalIdsUpdate = externalIdsUpdateFactory.create(); externalIdsUpdate.deleteAll(db, user.getAccountId()); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check http://test/#/settings/web-identities"); checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users"); externalIdsUpdate.insert(db, com.google.gerrit.server.account.ExternalId.create(com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey()), user.getAccountId())); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user"); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if ((self.get()) != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get external IDs"); } java.util.Collection<com.google.gerrit.server.account.ExternalId> ids = com.google.gerrit.server.account.ExternalId.from(db.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList()); if (ids.isEmpty()) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(ids.size()); for (com.google.gerrit.server.account.ExternalId id : ids) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.key().get(); info.emailAddress = id.email(); info.trusted = com.google.gerrit.server.account.GetExternalIds.toBoolean(authConfig.isIdentityTrustable(java.util.Collections.singleton(id))); if (!(id.isScheme(com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME))) { com.google.gerrit.server.account.ExternalId.Key last = resource.getUser().getLastLoginExternalIdKey(); info.canDelete = com.google.gerrit.server.account.GetExternalIds.toBoolean(((last == null) || (!(last.get().equals(info.identity))))); } result.add(info); } return result; }
@org.junit.Test public void addOtherUsersGpgKey_Conflict() throws java.lang.Exception { addExternalIdEmail(admin, "test5@example.com"); externalIdsUpdate.insert(db, com.google.gerrit.server.account.ExternalId.create("foo", "myId", user.getId())); accountCache.evict(user.getId()); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); addGpgKey(key.getPublicKeyArmored()); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("GPG key already associated with another account"); addGpgKey(key.getPublicKeyArmored()); }
@org.junit.After public void restoreExternalIds() throws java.lang.Exception { if ((savedExternalIds) != null) { externalIdsUpdate.delete(db, getExternalIds(admin)); externalIdsUpdate.delete(db, getExternalIds(user)); externalIdsUpdate.insert(db, savedExternalIds); } accountCache.evict(admin.getId()); accountCache.evict(user.getId()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutUsername.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set username"); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing username"); } if (input == null) { input = new com.google.gerrit.server.account.PutUsername.Input(); } try { changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call(); } catch (java.lang.IllegalStateException e) { if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(e.getMessage()); } throw e; } catch (com.google.gerrit.server.account.InvalidUserNameException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("invalid username"); } catch (com.google.gerrit.common.errors.NameAlreadyUsedException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username already used"); } return input.username; }
private com.google.gerrit.server.account.AuthResult auth(com.google.gerrit.reviewdb.client.Account.Id account) { if (account != null) { return new com.google.gerrit.server.account.AuthResult(account, null, false); } return null; }
private com.google.gerrit.server.account.AuthResult byUserName(final java.lang.String userName) { try { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQuery.byExternalId(com.google.gerrit.httpd.auth.become.SCHEME_USERNAME, userName); if (accountStates.isEmpty()) { getServletContext().log((("No accounts with username " + userName) + " found")); return null; } if ((accountStates.size()) > 1) { getServletContext().log((("Multiple accounts with username " + userName) + " found")); return null; } return auth(accountStates.get(0).getAccount().getId()); } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log("cannot query account index", e); return null; } }
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertEmail(byEmailCache.get(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(db, com.google.gerrit.server.account.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); accountCache.evict(admin.id); assertEmail(byEmailCache.get(email), admin); assertThat(byEmailCache.get(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(byEmailCache.get(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(byEmailCache.get("non-existing@example.com")).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.Email rsrc, com.google.gerrit.server.account.DeleteEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete email address"); } return apply(rsrc.getUser(), rsrc.getEmail()); }
ExternalId.Key getLastLoginExternalId();
private void assertKeys(java.lang.Iterable<com.google.gerrit.gpg.testutil.TestKey> expectedKeys) throws java.lang.Exception { com.google.common.collect.FluentIterable<com.google.gerrit.gpg.testutil.TestKey> expected = com.google.common.collect.FluentIterable.from(expectedKeys); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keyMap = gApi.accounts().self().listGpgKeys(); assertThat(keyMap.keySet()).named("keys returned by listGpgKeys()").containsExactlyElementsIn(expected.transform(TestKey::getKeyIdString)); for (com.google.gerrit.gpg.testutil.TestKey key : expected) { com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyEquals(key, gApi.accounts().self().gpgKey(key.getKeyIdString()).get()); com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyEquals(key, gApi.accounts().self().gpgKey(com.google.gerrit.gpg.Fingerprint.toString(key.getPublicKey().getFingerprint())).get()); com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyMapContains(key, keyMap); } com.google.gerrit.reviewdb.client.Account.Id currAccountId = atrScope.get().getUser().getAccountId(); java.lang.Iterable<java.lang.String> expectedFps = expected.transform(( k) -> com.google.common.io.BaseEncoding.base16().encode(k.getPublicKey().getFingerprint())); java.lang.Iterable<java.lang.String> actualFps = com.google.gerrit.gpg.server.GpgKeys.getGpgExtIds(db, currAccountId).transform(( e) -> e.key().id()); assertThat(actualFps).named("external IDs in database").containsExactlyElementsIn(expectedFps); for (com.google.gerrit.gpg.testutil.TestKey key : expected) { getOnlyKeyFromStore(key); } }
public boolean isIdentityTrustable(java.util.Collection<com.google.gerrit.server.account.ExternalId> ids) { switch (getAuthType()) { case DEVELOPMENT_BECOME_ANY_ACCOUNT : case HTTP : case HTTP_LDAP : case LDAP : case LDAP_BIND : case CLIENT_SSL_CERT_LDAP : case CUSTOM_EXTENSION : case OAUTH : return true; case OPENID_SSO : return true; case OPENID : for (com.google.gerrit.server.account.ExternalId e : ids) { if (!(isTrusted(e))) { return false; } } return true; default : return false; } }
private com.google.gerrit.reviewdb.client.Account getAccountByExternalId(com.google.gerrit.server.account.ExternalId.Key extIdKey) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(extIdKey); if (accountStates.isEmpty()) { return null; } if ((accountStates.size()) > 1) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("GPG key ").append(extIdKey.get()).append(" associated with multiple accounts: "); com.google.common.base.Joiner.on(", ").appendTo(msg, com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); log.error(msg.toString()); throw new java.lang.IllegalStateException(msg.toString()); } return accountStates.get(0).getAccount(); }
@java.lang.Override public void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), email); try { deleteEmail.apply(rsrc, null); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete email", e); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.server.account.AccountState accountState = accountQueryProvider.get().oneByExternalId(com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME, username); return java.util.Optional.ofNullable(accountState).map(( s) -> s.getAccount().getId()); }
private static com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> anon = com.google.common.collect.ImmutableSet.of(); return new com.google.gerrit.server.account.AccountState(account, anon, java.util.Collections.emptySet(), new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private java.util.Optional<com.google.gerrit.server.account.AccountState> load(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = db.accounts().get(who); if (account == null) { return java.util.Optional.empty(); } java.util.Set<com.google.gerrit.server.account.ExternalId> externalIds = com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> internalGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if ((group != null) && ((group.getGroupUUID()) != null)) { internalGroups.add(group.getGroupUUID()); } } internalGroups = java.util.Collections.unmodifiableSet(internalGroups); try { account.setGeneralPreferences(loader.load(who)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.AccountCacheImpl.log.warn((("Cannot load GeneralPreferences for " + who) + " (using default)"), e); account.setGeneralPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); } return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(account, internalGroups, externalIds, watchConfig.get().getProjectWatches(who))); }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key((((com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME) + ":") + username)))).map(AccountExternalId::getAccountId); } }
@java.lang.Override public boolean hasEmailAddress(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) { for (com.google.gerrit.server.account.ExternalId ext : user.state().getExternalIds()) { if ((email != null) && (email.equalsIgnoreCase(ext.email()))) { return true; } } return false; }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { delete.apply(rsrc, new com.google.gerrit.gpg.server.DeleteGpgKey.Input()); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete GPG key", e); } }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.extensions.common.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.extensions.common.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, e.email), new com.google.gerrit.server.account.DeleteEmail.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }
private void addEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput(); in.email = email; in.noConfirmation = true; try { createEmailFactory.create(email).apply(rsrc, in); } catch (com.google.gerrit.common.errors.EmailException e) { throw die(e.getMessage()); } }
@java.lang.Override public java.util.Set<java.lang.String> getEmailAddresses(com.google.gerrit.server.IdentifiedUser user) { java.util.Collection<com.google.gerrit.server.account.ExternalId> ids = user.state().getExternalIds(); java.util.Set<java.lang.String> emails = com.google.common.collect.Sets.newHashSetWithExpectedSize(ids.size()); for (com.google.gerrit.server.account.ExternalId ext : ids) { if (!(com.google.common.base.Strings.isNullOrEmpty(ext.email()))) { emails.add(ext.email()); } } return emails; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.extensions.api.accounts.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid email address"); } if ((input.noConfirmation) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow adding emails"); } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to clear HTTP password"); } newPassword = null; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "requires the Administrate Server permission")); } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username must be set"); } com.google.gerrit.server.account.ExternalId extId = com.google.gerrit.server.account.ExternalId.from(dbProvider.get().accountExternalIds().get(ExternalId.Key.create(com.google.gerrit.server.account.ExternalId.SCHEME_USERNAME, user.getUserName()).asAccountExternalIdKey())); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.ExternalId newExtId = com.google.gerrit.server.account.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword); externalIdsUpdate.create().upsert(dbProvider.get(), newExtId); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId user = com.google.gerrit.server.account.ExternalId.from(db.accountExternalIds().get(ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username).asAccountExternalIdKey())); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : authorizedKeys.getKeys(user.accountId())) { if (k.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
@org.junit.Test public void getExternalIDs() throws java.lang.Exception { java.util.Collection<com.google.gerrit.server.account.ExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = new java.util.ArrayList<>(); for (com.google.gerrit.server.account.ExternalId id : expectedIds) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.key().get(); info.emailAddress = id.email(); info.canDelete = (!(id.isScheme(com.google.gerrit.acceptance.rest.account.SCHEME_USERNAME))) ? true : null; info.trusted = true; expectedIdInfos.add(info); } com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@java.lang.Override public void deleteExternalIds(java.util.List<java.lang.String> externalIds) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteExternalIds.apply(account, externalIds); } catch (java.io.IOException | com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete external IDs", e); } }
@java.lang.Override public void login(com.google.gerrit.server.account.AuthResult res, boolean rememberMe) { com.google.gerrit.reviewdb.client.Account.Id id = res.getAccountId(); com.google.gerrit.server.account.ExternalId.Key identity = res.getExternalId(); if ((val) != null) { manager.destroy(key); } key = manager.createKey(id); val = manager.createVal(key, id, rememberMe, identity, null, null); saveCookie(); user = identified.create(val.getAccountId()); }
private java.lang.String readResponse(java.io.InputStream responseStream) { try { java.util.Scanner scanner; scanner = new java.util.Scanner(responseStream, "UTF-8"); scanner.useDelimiter("\\A"); return scanner.next(); } catch (java.lang.Exception e) { throw new java.lang.RuntimeException((("Error reading response: [" + (e.getMessage())) + "]."), e); } }

public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() { if ((submitTypeRecord) == null) { submitTypeRecord = submitRuleEvaluatorFactory.create(this).getSubmitType(); } return submitTypeRecord; }



public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : submitRuleEvaluatorFactory.create(cd).evaluate()) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
public com.google.gerrit.server.project.SubmitRuleEvaluator setOptions(com.google.gerrit.server.project.SubmitRuleOptions opts) { checkNotStarted(); if (opts != null) { optsBuilder = opts.toBuilder(); } else { optsBuilder = com.google.gerrit.server.project.SubmitRuleOptions.builder(); } return this; }



public static com.google.gerrit.server.project.SubmitRuleOptions.Builder builder() { return new com.google.gerrit.server.project.AutoValue_SubmitRuleOptions.Builder().allowClosed(false).skipFilters(false).rule(null); }




private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }

public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.server.project.ProjectState projectState; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException("No change found"); } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchProjectException e) { return ruleError(("Error looking up change " + (cd.getId())), e); } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", cd, projectState); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError(java.lang.String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), projectState.getName())); } return resultsToSubmitRecord(getSubmitRule(), results, cd); }

public static void checkSubmitRule(com.google.gerrit.server.query.change.ChangeData cd, boolean allowClosed) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet patchSet = cd.currentPatchSet(); if (patchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("missing current patch set for change " + (cd.getId()))); } java.util.List<com.google.gerrit.common.data.SubmitRecord> results = com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd, allowClosed); if (com.google.gerrit.common.data.SubmitRecord.findOkRecord(results).isPresent()) { return; } else if (results.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format("SubmitRuleEvaluator.evaluate for change %s returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get())); } for (com.google.gerrit.common.data.SubmitRecord record : results) { switch (record.status) { case CLOSED : throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is closed"); case RULE_ERROR : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("submit rule error: " + (record.errorMessage))); case NOT_READY : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(com.google.gerrit.server.git.MergeOp.describeLabels(cd, record.labels)); case FORCED : case OK : default : throw new java.lang.IllegalStateException(java.lang.String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get())); } } throw new java.lang.IllegalStateException(); }
private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) { return com.google.gerrit.common.data.SubmitRecord.findOkRecord(cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)).isPresent(); }
public static java.util.Optional<com.google.gerrit.common.data.SubmitRecord> findOkRecord(java.util.Collection<com.google.gerrit.common.data.SubmitRecord> in) { if (in == null) { return java.util.Optional.empty(); } return in.stream().filter(( r) -> (r.status) == (com.google.gerrit.common.data.SubmitRecord.Status.OK)).findFirst(); }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd).setPatchSet(patchSet).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }

private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels) != null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord.Label(); srl.label = label.label; srl.status = label.status; srl.appliedBy = ((label.appliedBy) != null) ? new com.google.gerrit.reviewdb.client.Account.Id(label.appliedBy) : null; rec.labels.add(srl); } } return rec; }
@java.lang.Override protected void configure() { install(new com.google.gerrit.server.rules.PrologModule.EnvironmentModule()); bind(PrologEnvironment.Args.class); }

private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-on-reviewer-added", true)).thenReturn(publishOnReviewerAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore); when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("ignore-rebase-empty-patch-set", true)).thenReturn(ignoreRebaseEmptyPatchSet); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig(true); }

private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore) throws java.lang.Exception { return getConfig(ignore, true, true); }



@java.lang.Override public boolean shouldPublish() { return (config.isEnabled()) && (config.shouldPublishOnReviewerAdded()); }

@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmptyPatchSet()) && (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE)))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("Error checking patch set kind", e); } boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.regex.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result = !(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("The specified ignore pattern was invalid", e); } return result; }

@java.lang.Override public boolean shouldPublish() { return (config.isEnabled()) && (config.shouldPublishOnCommentAdded()); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(publishOnCommentAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); }

private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig(true); }

private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig("^WIP.*", true, true); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, true); }

private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreRebaseEmptyPatchSet); }



@java.lang.Override public void run() throws java.io.IOException { com.google.gerrit.server.index.IndexModule.IndexType type = com.google.gerrit.server.index.IndexModule.IndexType.LUCENE; if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) > 1) { ui.header("Index"); type = index.select("Type", "type", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.ELASTICSEARCH)) { index.select("Transport protocol", "protocol", "http", com.google.common.collect.Sets.newHashSet("http", "https")); index.string("Hostname", "hostname", "localhost"); index.string("Port", "port", "9200"); index.string("Index Name", "name", "gerrit"); } if (((site.isNew) || (isEmptySite())) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { for (com.google.gerrit.server.index.SchemaDefinitions<?> def : com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS) { com.google.gerrit.server.index.IndexUtils.setReady(site, def.getName(), def.getLatest().getVersion(), true); } } else { if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) <= 1) { ui.header("Index"); } java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }

private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug("{} {} {}", operation, indexName, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.locks.Lock idLock = idLocks.get(id); idLock.lock(); try { index(id, operation); } finally { idLock.unlock(); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_CONFLICT, e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.error("Unable to update {} index", indexName, e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format("Error trying to find %s \n", indexName); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, msg); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); try { java.util.List<java.lang.String> params = com.google.common.base.Splitter.on('/').splitToList(req.getPathInfo()); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.CACHENAME_INDEX); java.lang.String json = req.getReader().readLine(); forwardedCacheEvictionHandler.evict(com.ericsson.gerrit.plugins.highavailability.forwarder.CacheEntry.from(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.fromJson(cacheName, json))); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (com.ericsson.gerrit.plugins.highavailability.forwarder.CacheNotFoundException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.error("Failed to process eviction request: {}", e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.error("Failed to process eviction request: {}", e.getMessage(), e); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); try { if (!(com.google.common.net.MediaType.parse(req.getContentType()).is(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8))) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_UNSUPPORTED_MEDIA_TYPE, (("Expecting " + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8.toString())) + " content type")); return; } forwardedEventHandler.dispatch(getEventFromRequest(req)); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (com.google.gwtorm.server.OrmException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.logger.debug("Error trying to find a change ", e); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, "Change not found\n"); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.logger.error("Unable to re-trigger event", e); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } }


@org.junit.Test public void accountEvictionFromAccountCreatorIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); com.google.gerrit.acceptance.AccountCreator accountCreator = org.easymock.EasyMock.createNiceMock(com.google.gerrit.acceptance.AccountCreator.class); accountCreator.evict(com.google.common.collect.ImmutableSet.of(accountId)); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCreator); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(accountCreator, null, null).reset(project).reset(allUsers).build()) { createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); } org.easymock.EasyMock.verify(accountCreator); }
@org.junit.Test public void accountEvictionIfUserBranchIsReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); org.eclipse.jgit.lib.Ref userBranch = createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); com.google.gerrit.server.account.AccountCache accountCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCache); org.eclipse.jgit.lib.Ref nonUserBranch = createRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, accountCache, null).reset(project).reset(allUsers).build()) { updateRef(nonUserBranch); updateRef(allUsersRepo, userBranch); } org.easymock.EasyMock.verify(accountCache); }
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createRepository(project2); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(projectCache); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, null, projectCache).reset(project).reset(project2).build()) { createRef("refs/heads/master"); createRef(repo2, RefNames.REFS_CONFIG); } org.easymock.EasyMock.verify(projectCache); }
@org.junit.Test public void accountEvictionIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); com.google.gerrit.server.account.AccountCache accountCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCache); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, accountCache, null).reset(project).reset(allUsers).build()) { createRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); } org.easymock.EasyMock.verify(accountCache); }

public com.google.gerrit.acceptance.ProjectResetter build() throws java.io.IOException { return new com.google.gerrit.acceptance.ProjectResetter(repoManager, allUsersName, accountCreator, accountCache, projectCache, refsByProject); }
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createRepository(project2); org.eclipse.jgit.lib.Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(projectCache); org.eclipse.jgit.lib.Ref nonMetaConfig = createRef("refs/heads/master"); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, null, projectCache).reset(project).reset(project2).build()) { updateRef(nonMetaConfig); updateRef(repo2, metaConfig); } org.easymock.EasyMock.verify(projectCache); }



@org.junit.Test public void deleteItems() throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId oldMetaId = metaRef(accountId); java.util.List<java.lang.String> defaultNames = com.google.common.collect.ImmutableList.copyOf(myMenusFromApi(accountId).keySet()); GeneralPreferencesInfo prefs = gApi.accounts().id(accountId.get()).getPreferences(); prefs.my.add(0, new com.google.gerrit.extensions.client.MenuItem("Something else", ((com.google.gerrit.server.schema.Schema_160.DEFAULT_DRAFT_ITEM) + "+is:mergeable"))); prefs.my.add(new com.google.gerrit.extensions.client.MenuItem("Drafts", com.google.gerrit.server.schema.Schema_160.DEFAULT_DRAFT_ITEM)); prefs.my.add(new com.google.gerrit.extensions.client.MenuItem("Totally not drafts", com.google.gerrit.server.schema.Schema_160.DEFAULT_DRAFT_ITEM)); gApi.accounts().id(accountId.get()).setPreferences(prefs); java.util.List<java.lang.String> oldNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add("Something else").addAll(defaultNames).add("Drafts").add("Totally not drafts").build(); assertThat(myMenusFromApi(accountId).keySet()).containsExactlyElementsIn(oldNames).inOrder(); schema160.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); accountCache.evict(accountId); testEnv.setApiUser(accountId); assertThat(metaRef(accountId)).isNotEqualTo(oldMetaId); java.util.List<java.lang.String> newNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add("Something else").addAll(defaultNames).build(); assertThat(myMenusFromNoteDb(accountId).keySet()).containsExactlyElementsIn(newNames).inOrder(); assertThat(myMenusFromApi(accountId).keySet()).containsExactlyElementsIn(newNames).inOrder(); }


java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> resolve(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.AccountInfo uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); com.google.gerrit.server.account.GroupMembers groupMembers = null; for (java.lang.String r : in) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(reviewDb, r); if ((account != null) && (account.isActive())) { if ((uploader == null) || ((uploader._accountId) != (account.getId().get()))) { reviewers.add(account.getId()); } continue; } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.error("For the change {} of project {}: failed to resolve account {}.", changeNumber, p, r, e); continue; } if ((groupMembers == null) && (uploader != null)) { java.lang.String uploaderNameEmail = java.lang.String.format("%s <%s>", uploader.name, uploader.email); try { com.google.gerrit.reviewdb.client.Account uploaderAccount = accountResolver.findByNameOrEmail(reviewDb, uploaderNameEmail); if (uploaderAccount != null) { groupMembers = groupMembersFactory.create(identifiedUserFactory.create(uploaderAccount.getId())); } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}, cannot retrieve uploader account {}.", changeNumber, p, r, uploaderNameEmail, e); } } try { if (groupMembers != null) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::isActive).map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } else { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}; cannot retrieve uploader account for {}.", changeNumber, p, r, uploader.email); } } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: reviewer {} is neither an account nor a group.", changeNumber, p, r); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r, e); } } return reviewers; }

private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers groupMembers, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::isActive).map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: reviewer {} is neither an account nor a group.", changeNumber, p, r); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r, e); } }
private void run(java.util.function.Consumer<java.lang.String> logOneLine, @com.google.gerrit.common.Nullable java.io.PrintWriter progressWriter) { if (!((repoManager) instanceof com.google.gerrit.server.git.LocalDiskRepositoryManager)) { logOneLine.accept((("Skipping GC of " + (allUsers)) + "; not a local disk repo")); return; } if (progressWriter == null) { logOneLine.accept((("collecting garbage for \"" + (allUsers)) + "\":\n")); } com.google.gerrit.common.data.GarbageCollectionResult result = gcFactory.create().run(com.google.common.collect.ImmutableList.of(allUsers), progressWriter); if (!(result.hasErrors())) { return; } for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case GC_ALREADY_SCHEDULED : logOneLine.accept(("GC already scheduled for " + (e.getProjectName()))); break; case GC_FAILED : logOneLine.accept(("GC failed for " + (e.getProjectName()))); break; case REPOSITORY_NOT_FOUND : logOneLine.accept(((e.getProjectName()) + " repo not found")); break; default : logOneLine.accept(((("GC failed for " + (e.getProjectName())) + ": ") + (e.getType()))); break; } } }
public java.util.Set<java.lang.String> getUpstreamBranches(java.lang.String toBranch, java.lang.String project) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<java.lang.String> upstreamBranches = new java.util.HashSet<java.lang.String>(); java.util.Set<java.lang.String> subsections = getConfig().getSubsections(pluginName); for (java.lang.String subsection : subsections) { java.lang.String[] branchPair = subsection.split(com.google.re2j.Pattern.quote(com.googlesource.gerrit.plugins.automerger.ConfigLoader.BRANCH_DELIMITER)); if ((branchPair.length) != 2) { throw new org.eclipse.jgit.errors.ConfigInvalidException(("Automerger config branch pair malformed: " + subsection)); } if (toBranch.equals(branchPair[1])) { java.util.Set<java.lang.String> projectsInScope = getProjectsInScope(branchPair[0], branchPair[1]); if (projectsInScope.contains(project)) { upstreamBranches.add(branchPair[0]); } } } return upstreamBranches; }
@org.junit.Test public void basicGroupProperties() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups().create(name("group")).get(); try (com.google.gerrit.acceptance.api.group.GroupRebuilderIT.BlockReviewDbUpdatesForGroups ctx = new com.google.gerrit.acceptance.api.group.GroupRebuilderIT.BlockReviewDbUpdatesForGroups()) { com.google.gerrit.server.group.InternalGroup reviewDbGroup = groups.getGroup(db, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(createdGroup.id)).get(); deleteGroupRefs(reviewDbGroup); assertThat(com.google.gerrit.acceptance.api.group.GroupRebuilderIT.removeRefState(rebuild(reviewDbGroup))).isEqualTo(roundToSecond(reviewDbGroup)); } }
private com.google.gerrit.server.group.InternalGroup createGroupInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException { checkIfReviewDbUpdatesAreBlocked(); com.google.gerrit.reviewdb.client.AccountGroupName gn = new com.google.gerrit.reviewdb.client.AccountGroupName(groupCreation.getNameKey(), groupCreation.getId()); db.accountGroupNames().insert(com.google.common.collect.ImmutableList.of(gn)); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.db.GroupsUpdate.createAccountGroup(groupCreation); com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult updateResult = updateGroupInReviewDb(db, group, groupUpdate); return com.google.gerrit.server.group.InternalGroup.create(group, updateResult.getModifiedMembers(), updateResult.getModifiedSubgroups(), updateResult.getRefState()); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(3); values.add(token.operation); values.add(token.id.getName()); values.add(token.expiresAt); return values; }
@org.junit.Test public void testTokenSerializationDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor(cipher); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(0); java.lang.String serialized = processor.serialize(token); assertThat(serialized).isNotEmpty(); java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> deserialized = processor.deserialize(serialized); assertThat(deserialized.isPresent()).isTrue(); assertThat(token.expiresAt).isEqualTo(deserialized.get().expiresAt); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 3) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1)), values.get(2))); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(4); values.add(token.user); values.add(token.project); values.add(token.operation); values.add(token.expiresAt); return values; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 4) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3))); }
com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo generateAuthInfo(com.google.gerrit.server.CurrentUser user, java.lang.String project, java.lang.String operation) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(user.getUserName(), project, operation, expirationSeconds); return new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(processor.serialize(token), token.expiresAt); }
public com.googlesource.gerrit.plugins.lfs.AuthInfo generateAuthInfo(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id, int expirationSeconds) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token = new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(operation, id, expirationSeconds); return new com.googlesource.gerrit.plugins.lfs.AuthInfo(processor.serialize(token), token.expiresAt); }
static boolean onTime(java.lang.String dateTime) { return (com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORMAT.now().compareTo(dateTime)) <= 0; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.util.List<java.lang.String> values) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0))); }
@org.junit.Test public void testTokenOnTime() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(1); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier(token); assertThat(verifier.verify()).isTrue(); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(2); values.add(token.expiresAt); return values; }
@org.junit.Test public void testTokenExpired() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken((-1)); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier(token); assertThat(verifier.verify()).isFalse(); }
@org.junit.Test public void testVerifyAuthInfo() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "o", zeroId())).isTrue(); }
@org.junit.Test public void testVerifyAgainstDifferentOperation() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse(); }
@org.junit.Test public void testVerifyAgainstDifferentObjectId() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "o", org.eclipse.jgit.lfs.lib.LongObjectId.fromString(("123456789012345678901234567890" + ("123456789012345678901234567890" + "1234"))))).isFalse(); }
private boolean isRecoverable(java.io.IOException e) { return !(e instanceof javax.net.ssl.SSLException); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.get().post(remote, content.get()); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
private void createRepository() { org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); HEAD((5723.0F - 2.15)); com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event = new com.google.gerrit.extensions.events.NewProjectCreatedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return projectName.get(); } @java.lang.Override public java.lang.String getHeadName() { return head != null ? head.getTarget().getName() : null; } @java.lang.Override public com.google.gerrit.extensions.api.changes.NotifyHandling getNotify() { return com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } }; replicationQueue.onNewProjectCreated(event); com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(("Missing repository created; retry replication to " + (uri))); }


public static com.google.gerrit.server.group.db.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupFromReviewDb(db, groupId); return com.google.gerrit.server.group.db.GroupBundle.create(com.google.gerrit.server.group.db.GroupBundle.Source.REVIEW_DB, group, com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMembersFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupAuditsFromReviewDb(db, groupId)); }











@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); java.lang.String projectName = branch.getParentKey().get(); soyContext.put("projectName", projectName); soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "...")); soyContextEmailData.put("sshHost", getSshHost()); java.util.Map<java.lang.String, java.lang.String> branchData = new java.util.HashMap<>(); branchData.put("shortName", branch.getShortName()); soyContext.put("branch", branchData); footers.add(((MailHeader.PROJECT.withDelimiter()) + (branch.getParentKey().get()))); footers.add(("Gerrit-Branch: " + (branch.getShortName()))); }


@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for review"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
protected <T> org.elasticsearch.index.query.QueryBuilder toQueryBuilder(com.google.gerrit.server.query.Predicate<T> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<T>) (p))); } else { throw new com.google.gerrit.server.query.QueryParseException(("cannot create query for index: " + p)); } }
public org.apache.lucene.search.Query toQuery(com.google.gerrit.server.query.Predicate<V> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<V>) (p))); } else { throw new com.google.gerrit.server.query.QueryParseException(("cannot create query for index: " + p)); } }

private boolean canRead(org.eclipse.jgit.lib.ObjectId revId) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try { permissionBackend.user(user).project(projectName).check(ProjectPermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException e) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(revId); return commits.canRead(projectState, repo, commit); } } }














@java.lang.Override public com.google.gerrit.server.restapi.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.restapi.change.Description().setLabel("Start Review").setTitle("Set Ready For Review").setVisible((((rsrc.isUserOwner()) && ((rsrc.getChange().getStatus()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) && (rsrc.getChange().isWorkInProgress()))); }
@java.lang.Override public com.google.gerrit.server.restapi.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.restapi.change.Description().setLabel("WIP").setTitle("Set Work In Progress").setVisible((((rsrc.isUserOwner()) && ((rsrc.getChange().getStatus()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) && (!(rsrc.getChange().isWorkInProgress())))); }
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (IOException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.statePermitsRead())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.user(userProvider).project(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (IOException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.statePermitsRead())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.user(userProvider).project(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; }
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().state()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
public java.lang.String create() { java.lang.String summaryLine = (originalGroup.isPresent()) ? "Update group" : "Create group"; java.util.StringJoiner footerJoiner = new java.util.StringJoiner("\n", "\n\n", ""); footerJoiner.setEmptyValue(""); getFooterForRename().ifPresent(footerJoiner::add); getFootersForMemberModifications().forEach(footerJoiner::add); getFootersForSubgroupModifications().forEach(footerJoiner::add); java.lang.String footer = footerJoiner.toString(); return summaryLine + footer; }
private boolean couldDeleteWhenIn(com.google.gerrit.reviewdb.client.Change.Status status) { switch (status) { case NEW : case ABANDONED : return true; case MERGED : return false; } return false; }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change.Status status = rsrc.getChange().getStatus(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions().database(db); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Delete").setTitle(("Delete change " + (rsrc.getId()))).setVisible(and(couldDeleteWhenIn(status), perm.testCond(ChangePermission.DELETE))); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { if ((rsrc.getChange().getStatus()) == (Change.Status.MERGED)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("delete not permitted"); } rsrc.permissions().database(db).check(ChangePermission.DELETE); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.Change.Id id = rsrc.getChange().getId(); bu.setOrder(Order.DB_BEFORE_REPO); bu.addOp(id, opProvider.get()); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(0, ((id.length()) - (Constants.DOT_GIT_EXT.length()))); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.WRITE_CONFIG); } catch (com.google.gerrit.extensions.restapi.AuthException e) { state.checkStatePermitsRead(); } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
private com.google.gerrit.server.project.ProjectState checkProjectState() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(projectName); try { permissionBackend.user(user).project(projectName).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } state.checkStatePermitsRead(); return state; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { java.lang.String projectName = params.getParameter(0); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } while (projectName.startsWith("/")) { projectName = projectName.substring(1); } java.lang.String nameWithoutSuffix = com.google.gerrit.common.ProjectUtil.stripGitSuffix(projectName); com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(nameWithoutSuffix); com.google.gerrit.server.project.ProjectState state; try { state = projectCache.checkedGet(nameKey); if (state == null) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format("project %s not found", nameWithoutSuffix)); } permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.kohsuke.args4j.CmdLineException(owner, new com.google.gerrit.server.project.NoSuchProjectException(nameKey).getMessage()); } catch (com.google.gerrit.server.permissions.PermissionBackendException | java.io.IOException e) { com.google.gerrit.server.args4j.ProjectHandler.log.warn(("Cannot load project " + nameWithoutSuffix), e); throw new org.kohsuke.args4j.CmdLineException(owner, new com.google.gerrit.server.project.NoSuchProjectException(nameKey).getMessage()); } setter.addValue(state); return 1; }
public static com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> getCacheBuilder(org.eclipse.jgit.lib.Config config, java.lang.String name) { com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> b = com.google.common.cache.CacheBuilder.newBuilder(); try { if ((config.getString("cache", name, "maximumWeight")) != null) { b.maximumWeight(config.getLong("cache", name, "maximumWeight", (20 << 20))); } if ((config.getString("cache", name, "maximumSize")) != null) { b.maximumSize(config.getLong("cache", name, "maximumSize", 16384)); } org.joda.time.Duration expireAfterWrite = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterWrite", null); if (expireAfterWrite != null) { b.expireAfterWrite(expireAfterWrite.getMillis(), java.util.concurrent.TimeUnit.MILLISECONDS); } org.joda.time.Duration expireAfterAccess = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterAccess", null); if (expireAfterAccess != null) { b.expireAfterAccess(expireAfterAccess.getMillis(), java.util.concurrent.TimeUnit.MILLISECONDS); } } catch (java.lang.IllegalArgumentException e) { throw new java.lang.IllegalArgumentException(("Error getting CacheBuilder for " + name), e); } catch (java.lang.IllegalStateException e) { throw new java.lang.IllegalStateException(("Error getting CacheBuilder for " + name), e); } return b; }
public static org.joda.time.Duration getDuration(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection, java.lang.String name, @javax.annotation.Nullable org.joda.time.Duration defaultValue) { long m = config.getTimeUnit(section, subsection, name, (-1), java.util.concurrent.TimeUnit.MILLISECONDS); return m == (-1) ? defaultValue : org.joda.time.Duration.millis(m); }
@org.junit.Test public void nullAsDefault() throws java.lang.Exception { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); org.joda.time.Duration t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank", " "); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); }
@org.junit.Test public void getDurationCanReturnDefault() throws java.lang.Exception { org.joda.time.Duration def = org.joda.time.Duration.standardSeconds(1); org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); org.joda.time.Duration t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t.getMillis()).isEqualTo(1000); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t.getMillis()).isEqualTo(1000); config.setString("core", null, "blank", " "); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t.getMillis()).isEqualTo(1000); }
@org.junit.Test public void getDurationReturnsDuration() throws java.lang.Exception { org.joda.time.Duration def = org.joda.time.Duration.standardSeconds(2); org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); org.joda.time.Duration t; config.setString("core", "dht", "timeout", "500 ms"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertThat(t.getMillis()).isEqualTo(500); config.setString("core", "dht", "timeout", "5.2 sec"); try { com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); fail("expected IllegalArgumentException"); } catch (java.lang.IllegalArgumentException e) { assertThat(e).hasMessageThat().isEqualTo("Invalid time unit value: core.dht.timeout=5.2 sec"); } config.setString("core", "dht", "timeout", "1 min"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertThat(t.getMillis()).isEqualTo(60000); }
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> additions) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("Cannot edit global capabilities for projects other than " + (allProjects.get()))); } } } for (com.google.gerrit.common.data.AccessSection section : additions) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (!isGlobalCapabilities) { if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid section name"); } com.google.gerrit.server.project.RefPattern.validate(name); } else { for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isCapability(p.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException((("Cannot add non-global capability " + (p.getName())) + " to global capabilities")); } } } } }


private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } try { permissionBackend.currentUser().database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("edit not permitted", denied); } }

@java.lang.Override public boolean deleteChangeFromIndex(final int changeId) { return new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.Request((("delete change " + changeId) + " from index")) { @java.lang.Override com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send() throws java.io.IOException { return httpSession.delete(buildIndexEndpoint(changeId)); } }.execute(); }
@org.junit.Test public void storedSubmitRecordsWithRequirements() { com.google.gerrit.common.data.SubmitRecord r = com.google.gerrit.server.index.change.ChangeFieldTest.record(SubmitRecord.Status.OK, com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Label.Status.MAY, "Label-1", null), com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Label.Status.OK, "Label-2", 1)); com.google.gerrit.common.data.SubmitRequirement sr = new com.google.gerrit.common.data.SubmitRequirement("short reason", "Full reason can be a long string with special symbols like < > \\ / ; :", null); r.requirements = java.util.Collections.singletonList(sr); com.google.gerrit.server.index.change.ChangeFieldTest.assertStoredRecordRoundTrip(r); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels) != null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord.Label(); srl.label = label.label; srl.status = label.status; srl.appliedBy = ((label.appliedBy) != null) ? new com.google.gerrit.reviewdb.client.Account.Id(label.appliedBy) : null; rec.labels.add(srl); } } if ((requirements) != null) { rec.requirements = new java.util.ArrayList(requirements.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredRequirement requirement : requirements) { com.google.gerrit.common.data.SubmitRequirement sr = new com.google.gerrit.common.data.SubmitRequirement(requirement.shortReason, requirement.fullReason, requirement.label); rec.requirements.add(sr); } } return rec; }
@java.lang.Override public boolean equals(java.lang.Object o) { if ((this) == o) { return true; } if (o instanceof com.google.gerrit.common.data.SubmitRequirement) { com.google.gerrit.common.data.SubmitRequirement that = ((com.google.gerrit.common.data.SubmitRequirement) (o)); return ((java.util.Objects.equals(shortReason, that.shortReason)) && (java.util.Objects.equals(fullReason, that.fullReason))) && (java.util.Objects.equals(label, that.label)); } return false; }
public java.util.Optional<java.lang.String> label() { return java.util.Optional.ofNullable(label); }
public java.lang.String shortReason() { return shortReason; }
@java.lang.Override public java.lang.String toString() { return ((((((((("SubmitRequirement{" + "shortReason='") + (shortReason)) + '\'') + ", fullReason='") + (fullReason)) + '\'') + ", label='") + (label)) + '\'') + '}'; }
@java.lang.Override public int hashCode() { return java.util.Objects.hash(shortReason, fullReason, label); }
public java.lang.String fullReason() { return fullReason; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.startReindexer(name, force)) { stdout.println("Reindexer started"); } else { stdout.println("Nothing to reindex, index is already the latest version"); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(("Failed to start reindexer: " + (e.getMessage()))); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.activateLatestIndex(name)) { stdout.println("Activated latest index version"); } else { stdout.println("Not activating index, already using latest version"); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(("Failed to activate latest index: " + (e.getMessage()))); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String userName = user.getUserName().orElseThrow(() -> new com.google.gerrit.extensions.restapi.ResourceConflictException("username must be set")); com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.restapi.account.SCHEME_USERNAME, userName)); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } accountsUpdateProvider.get().update("Set HTTP Password via API", extId.accountId(), ( u) -> u.updateExternalId(com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword))); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@org.junit.Test public void rawDocument() throws java.lang.Exception { com.google.gerrit.extensions.common.AccountInfo userInfo = gApi.accounts().id(admin.getAccountId().get()).get(); java.util.Optional<com.google.gerrit.index.query.FieldBundle> rawFields = indexes.getSearchIndex().getRaw(new com.google.gerrit.reviewdb.client.Account.Id(userInfo._accountId), com.google.gerrit.index.QueryOptions.create(com.google.gerrit.index.IndexConfig.createDefault(), 0, 1, indexes.getSearchIndex().getSchema().getStoredFields().keySet())); assertThat(rawFields).isPresent(); assertThat(rawFields.get().getValue(AccountField.ID)).isEqualTo(userInfo._accountId); if ((getSchemaVersion()) < 6) { return; } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> externalIdInfos = gApi.accounts().self().getExternalIds(); java.util.List<com.google.gerrit.server.query.account.AbstractQueryAccountsTest.ByteArrayWrapper> blobs = new java.util.ArrayList<>(); for (com.google.gerrit.extensions.common.AccountExternalIdInfo info : externalIdInfos) { blobs.add(new com.google.gerrit.server.query.account.AbstractQueryAccountsTest.ByteArrayWrapper(externalIds.get(ExternalId.Key.parse(info.identity)).toByteArray())); } assertThat(rawFields.get().getValue(AccountField.EXTERNAL_ID_STATE)).hasSize(blobs.size()); assertThat(com.google.common.collect.Streams.stream(rawFields.get().getValue(AccountField.EXTERNAL_ID_STATE)).map(( b) -> new com.google.gerrit.server.query.account.ByteArrayWrapper(b)).collect(java.util.stream.Collectors.toList())).containsExactlyElementsIn(blobs); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); permissionBackend.currentUser().project(resource.getNameKey()).ref(tag).check(RefPermission.DELETE); resource.getProjectState().checkStatePermitsWrite(); deleteRefFactory.create(resource).ref(tag).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.currentUser().ref(rsrc.getBranchKey()).check(RefPermission.DELETE); rsrc.getProjectState().checkStatePermitsWrite(); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("branch " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.restapi.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }

private boolean canDelete(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { try { permissions.ref(cmd.getRefName()).check(RefPermission.DELETE); return projectState.statePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId()) != null) ? ref.getObjectId().name() : null; info.canDelete = (((!(targets.contains(ref.getName()))) && (perm.testOrFalse(RefPermission.DELETE))) && (projectState.statePermitsWrite())) ? true : null; com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
@org.junit.Test public void storeThenQueryNotVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); tearDown(); }
@org.junit.Test public void storeThenQueryVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doNothing().when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); java.lang.String json = new com.google.gson.Gson().toJson(mockEvent); assertThat(events).containsExactly(json); tearDown(); }
@java.lang.Override public java.util.List<java.lang.String> queryChangeEvents(java.lang.String query) throws com.ericsson.gerrit.plugins.eventslog.EventsLogException { if (!(online)) { throw new com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException(); } java.util.List<com.ericsson.gerrit.plugins.eventslog.sql.SQLEntry> entries = new java.util.ArrayList<>(); for (java.util.Map.Entry<java.lang.String, java.util.Collection<com.ericsson.gerrit.plugins.eventslog.sql.SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) { java.lang.String projectName = entry.getKey(); try { permissionBackend.user(userProvider).project(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)).check(ProjectPermission.ACCESS); entries.addAll(entry.getValue()); } catch (com.google.gerrit.extensions.restapi.AuthException e) { } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.warn("Cannot check project access permission", e); } } return sortedEventsFromEntries(entries); }
@org.junit.Test public void notReturnEventWithNoVisibilityInfo() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); tearDown(); }
private java.lang.Object logo() { if ((logoUrl) == null) { return null; } java.lang.String url = fmt.image(logoUrl); if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return url; } else if (com.google.gitiles.doc.html.HtmlBuilder.isImageDataUri(url)) { return com.google.template.soy.shared.restricted.Sanitizers.filterImageDataUri(url); } else { return FilterImageDataUri.INSTANCE.getInnocuousOutput(); } }
java.lang.String inline(@javax.annotation.Nullable java.lang.String markdownPath, java.lang.String imagePath) { java.lang.String data = inlineMaybe(markdownPath, imagePath); if (data != null) { return data; } return FilterImageDataUri.INSTANCE.getInnocuousOutput(); }
@com.google.common.annotations.VisibleForTesting java.lang.String href(java.lang.String target) { if (((target.startsWith("#")) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(target))) || (com.google.gitiles.doc.html.HtmlBuilder.isValidMailtoUri(target))) { return target; } else if (target.startsWith("git:")) { if (com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri(target)) { return target; } return FilterNormalizeUri.INSTANCE.getInnocuousOutput(); } java.lang.String anchor = ""; int hash = target.indexOf('#'); if (hash >= 0) { anchor = target.substring(hash); target = target.substring(0, hash); } java.lang.String dest = com.google.gitiles.doc.PathResolver.resolve(filePath, target); if ((dest == null) || ((view) == null)) { return FilterNormalizeUri.INSTANCE.getInnocuousOutput(); } com.google.gitiles.GitilesView.Builder b; if ((view.getType()) == (GitilesView.Type.ROOTED_DOC)) { b = com.google.gitiles.GitilesView.rootedDoc(); } else { b = com.google.gitiles.GitilesView.path(); } dest = b.copyFrom(view).setPathPart(dest).build().toUrl(); return (com.google.gitiles.doc.PathResolver.relative(requestUri, dest)) + anchor; }
java.lang.String image(java.lang.String dest) { if ((com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest)) || (com.google.gitiles.doc.html.HtmlBuilder.isImageDataUri(dest))) { return dest; } else if ((imageLoader) != null) { return imageLoader.inline(filePath, dest); } return FilterImageDataUri.INSTANCE.getInnocuousOutput(); }
@org.junit.Test public void voteOnBehalfOfInvalidLabel() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.RevisionApi revision = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Not-A-Label", 5); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("label \"Not-A-Label\" is not a configured label"); revision.review(in); }



@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.account.AccountResource.Capability resource) { return com.google.gerrit.extensions.restapi.BinaryResult.create("ok\n"); }


@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser(); if ((self.get()) != (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : perm.test(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.AccountLimits limits = limitsFactory.create(rsrc.getUser()); addRanges(have, limits); addPriority(have, limits); return OutputFormat.JSON.newGson().toJsonTree(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Capability parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.IdentifiedUser target = parent.getUser(); if ((self.get()) != target) { permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm = parse(id); if (permissionBackend.user(target).test(perm)) { return new com.google.gerrit.server.account.AccountResource.Capability(target, perm.permissionName()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private com.google.gerrit.extensions.api.access.GlobalOrPluginPermission parse(com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { java.lang.String name = id.get(); com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm = com.google.gerrit.server.permissions.GlobalPermission.byName(name); if (perm != null) { return perm; } int dash = name.lastIndexOf('-'); if (dash < 0) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } java.lang.String pluginName = name.substring(0, dash); java.lang.String capability = name.substring((dash + 1)); if ((pluginName.isEmpty()) || (capability.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, capability); }


@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.restapi.config.ListCapabilities.CapabilityInfo> apply(com.google.gerrit.server.config.ConfigResource resource) throws java.lang.IllegalAccessException, java.lang.NoSuchFieldException { return com.google.common.collect.ImmutableMap.<java.lang.String, com.google.gerrit.server.restapi.config.ListCapabilities.CapabilityInfo>builder().putAll(collectCoreCapabilities()).putAll(collectPluginCapabilities()).build(); }

private java.util.Collection<com.google.gerrit.server.account.AccountSshKey> fixInvalidSequenceNumbers(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> keys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.comparing(( k) -> k.getKey().get())); java.util.List<com.google.gerrit.server.account.AccountSshKey> fixedKeys = new java.util.ArrayList(keys); com.google.gerrit.server.account.AccountSshKey minKey = o.min(keys); while ((minKey.getKey().get()) <= 0) { com.google.gerrit.server.account.AccountSshKey fixedKey = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(minKey.getKey().getParentKey(), java.lang.Math.max(((o.max(keys).getKey().get()) + 1), 1)), minKey.getSshPublicKey()); java.util.Collections.replaceAll(fixedKeys, minKey, fixedKey); minKey = o.min(fixedKeys); } return fixedKeys; }
private void markInvalid(com.google.gerrit.server.account.AccountSshKey k) { try { com.google.gerrit.sshd.SshKeyCacheImpl.log.info((("Flagging SSH key " + (k.getKey())) + " invalid")); authorizedKeys.markKeyInvalid(k.getAccount(), k.getKey().get()); k.setInvalid(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.sshd.SshKeyCacheImpl.log.error((("Failed to mark SSH key" + (k.getKey())) + " invalid"), e); } }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) { return new com.google.gerrit.server.account.AccountSshKey(id, encoded); }
private void add(java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl, com.google.gerrit.server.account.AccountSshKey k) { try { kl.add(new com.google.gerrit.sshd.SshKeyCacheEntry(k.getKey(), com.google.gerrit.sshd.SshUtil.parse(k))); } catch (java.lang.OutOfMemoryError e) { throw e; } catch (java.lang.Throwable e) { markInvalid(k); } }
private void deleteSshKey(com.google.gerrit.extensions.common.SshKeyInfo i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.account.AccountSshKey sshKey = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(user.getAccountId(), i.seq), i.sshPublicKey); deleteSshKey.apply(new com.google.gerrit.server.account.AccountResource.SshKey(user.asIdentifiedUser(), sshKey), null); }
public static com.google.gerrit.extensions.common.SshKeyInfo newSshKeyInfo(com.google.gerrit.server.account.AccountSshKey sshKey) { com.google.gerrit.extensions.common.SshKeyInfo info = new com.google.gerrit.extensions.common.SshKeyInfo(); info.seq = sshKey.getKey().get(); info.sshPublicKey = sshKey.getSshPublicKey(); info.encodedKey = sshKey.getEncodedKey(); info.algorithm = sshKey.getAlgorithm(); info.comment = com.google.common.base.Strings.emptyToNull(sshKey.getComment()); info.valid = sshKey.isValid(); return info; }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId user = externalIds.get(ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username)); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.server.account.AccountSshKey k : authorizedKeys.getKeys(user.accountId())) { if (k.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); }
private boolean markKeyInvalid(int seq) { checkLoaded(); com.google.gerrit.server.account.AccountSshKey key = getKey(seq); if ((key != null) && (key.isValid())) { key.setInvalid(); return true; } return false; }
public java.lang.String getEncodedKey() { return getPublicKeyPart(1, null); }

public com.google.gerrit.server.account.AccountSshKey.Id getKey() { return id; }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(id, com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey(encoded)); com.google.gerrit.sshd.SshUtil.parse(key); return key; } catch (java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e) { throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } catch (java.security.NoSuchProviderException e) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error("Cannot parse SSH key", e); throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } }
public static java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String s) { java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys = new java.util.ArrayList<>(); int seq = 1; for (java.lang.String line : s.split("\\r?\\n")) { line = line.trim(); if (line.isEmpty()) { continue; } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX)) { java.lang.String pub = line.substring(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX.length()); com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++)), pub); key.setInvalid(); keys.add(java.util.Optional.of(key)); } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.DELETED_KEY_COMMENT)) { keys.add(java.util.Optional.empty()); seq++; } else if (line.startsWith("#")) { continue; } else { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++)), line); keys.add(java.util.Optional.of(key)); } } return keys; }
@org.junit.Test public void validity() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (-1)), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.isValid()).isFalse(); key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 0), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.isValid()).isFalse(); key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.isValid()).isTrue(); }
@org.junit.Test public void getters() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.getSshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.getAlgorithm()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[0]); assertThat(key.getEncodedKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[1]); assertThat(key.getComment()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[2]); }
private static void assertParse(java.lang.StringBuilder authorizedKeys, java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> expectedKeys) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parsedKeys = com.google.gerrit.server.account.AuthorizedKeys.parse(accountId, authorizedKeys.toString()); assertThat(parsedKeys).containsExactlyElementsIn(expectedKeys); int seq = 1; for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> sshKey : parsedKeys) { if (sshKey.isPresent()) { assertThat(sshKey.get().getAccount()).isEqualTo(accountId); assertThat(sshKey.get().getKey().get()).isEqualTo(seq); } seq++; } }
private static java.lang.String addInvalidKey(java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(keyId, pub); key.setInvalid(); keys.add(java.util.Optional.of(key)); return ((AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX) + (key.getSshPublicKey())) + "\n"; }
@org.junit.Test public void keyWithNewLines() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1_WITH_NEWLINES); assertThat(key.getSshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.getAlgorithm()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[0]); assertThat(key.getEncodedKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[1]); assertThat(key.getComment()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(" ")[2]); }
private static java.lang.String addKey(java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey(keyId, pub); keys.add(java.util.Optional.of(key)); return (key.getSshPublicKey()) + "\n"; }
private com.google.gerrit.server.account.AccountSshKey addKey(java.lang.String pub) throws com.google.gerrit.common.errors.InvalidSshKeyException { checkLoaded(); for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key : keys) { if ((key.isPresent()) && (key.get().getSshPublicKey().trim().equals(pub.trim()))) { return key.get(); } } int seq = (keys.size()) + 1; com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(accountId, seq); com.google.gerrit.server.account.AccountSshKey key = sshKeyCreator.create(keyId, pub); keys.add(java.util.Optional.of(key)); return key; }
public java.lang.String getSshPublicKey() { return sshPublicKey; }
public Account.Id getAccount() { return id.accountId; }
public void setInvalid() { valid = false; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.SshKey rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get()); rsrc.getUser().getUserName().ifPresent(sshKeyCache::evict); return com.google.gerrit.extensions.restapi.Response.none(); }

private com.google.gerrit.server.account.AccountSshKey createSshKey(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String keyFile) throws java.io.IOException { java.nio.file.Path p = java.nio.file.Paths.get(keyFile); if (!(java.nio.file.Files.exists(p))) { throw new java.io.IOException(java.lang.String.format("Cannot add public SSH key: %s is not a file", keyFile)); } java.lang.String content = new java.lang.String(java.nio.file.Files.readAllBytes(p), java.nio.charset.StandardCharsets.UTF_8); return new com.google.gerrit.server.account.AccountSshKey(new com.google.gerrit.server.account.AccountSshKey.Id(id, 1), content); }
private java.lang.String getPublicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = getSshPublicKey(); if ((s != null) && ((s.length()) > 0)) { java.lang.String[] parts = s.split(" "); if ((parts.length) > index) { return parts[index]; } } return defaultValue; }
public void setKeys(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> newKeys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.comparing(( k) -> k.getKey().get())); keys = new java.util.ArrayList(java.util.Collections.nCopies(o.max(newKeys).getKey().get(), java.util.Optional.empty())); for (com.google.gerrit.server.account.AccountSshKey key : newKeys) { keys.set(((key.getKey().get()) - 1), java.util.Optional.of(key)); } }
@java.lang.Override public void start() { if ((executor) == null) { return; } java.util.concurrent.ExecutorService scheduler = java.util.concurrent.Executors.newFixedThreadPool(1); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("Loading project cache"); scheduler.execute(() -> { for (com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { executor.execute(() -> { cache.get(name); }); } executor.shutdown(); try { executor.awaitTermination(java.lang.Long.MAX_VALUE, java.util.concurrent.TimeUnit.MILLISECONDS); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("Finished loading project cache"); } catch (java.lang.InterruptedException e) { com.google.gerrit.server.project.ProjectCacheWarmer.log.warn("Interrupted while waiting for project cache to load"); } }); }



