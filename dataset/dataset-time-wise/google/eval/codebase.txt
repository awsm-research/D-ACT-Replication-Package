static java.util.Map<java.lang.String, java.lang.Integer> getVotes(com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = changeData.db(); java.util.Map<java.lang.String, java.lang.Integer> map = new java.util.HashMap<>(); com.google.gerrit.reviewdb.server.AccountAccess ac = db.accounts(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : changeData.currentApprovals()) { if ((p.getValue()) != 0) { com.google.gerrit.reviewdb.client.Account.Id id = p.getAccountId(); try { map.put(ac.get(id).getPreferredEmail(), java.lang.Integer.valueOf(p.getValue())); } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.findowners.Checker.log.error(("Cannot get email address of account id: " + (id.get())), e); } } } return map; }
private java.lang.String readCookie() { final javax.servlet.http.Cookie[] all = request.getCookies(); if (all != null) { for (final javax.servlet.http.Cookie c : all) { if (com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE.equals(c.getName())) { final java.lang.String v = c.getValue(); return (v != null) && (!("".equals(v))) ? v : null; } } } return null; }

private static void setCorsHeaders(javax.servlet.http.HttpServletResponse res, java.lang.String origin) { res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_ORIGIN, origin); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_MAX_AGE, "600"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_METHODS, "GET, OPTIONS, PUT, DELETE, POST"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_HEADERS, com.google.common.base.Joiner.on(", ").join(com.google.gerrit.httpd.restapi.RestApiServlet.ALLOWED_CORS_REQUEST_HEADERS)); }

@org.junit.After public void cleanUp() throws java.lang.Exception { gApi.accounts().id(user42.getId().toString()).setPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } accountCache.evictAll(); }
@org.junit.After public void cleanUp() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } accountCache.evictAll(); }
private com.google.gerrit.extensions.client.GeneralPreferencesInfo writeToGit(com.google.gerrit.extensions.client.GeneralPreferencesInfo i) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.config.ConfigUtil.storeSection(p.getConfig(), UserConfigSections.GENERAL, null, i, com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); com.google.gerrit.server.account.SetPreferences.storeUrlAliases(p, i.urlAliases); p.commit(md); accountCache.evictAll(); com.google.gerrit.extensions.client.GeneralPreferencesInfo r = com.google.gerrit.server.config.ConfigUtil.loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new com.google.gerrit.extensions.client.GeneralPreferencesInfo(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(), null); return loader.loadMyMenusAndUrlAliases(r, p, null); } }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate()); } return updates; }

public com.google.gerrit.server.git.WorkQueue.Executor createQueue(int poolsize, java.lang.String prefix) { final com.google.gerrit.server.git.WorkQueue.Executor r = new com.google.gerrit.server.git.WorkQueue.Executor(poolsize, prefix); r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true); queues.add(r); return r; }
@java.lang.Override public WorkQueue.Executor get() { final com.google.gerrit.server.git.WorkQueue.Executor executor; executor = queues.createQueue(poolSize, "SSH-Stream-Worker"); final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory(); executor.setThreadFactory(new java.util.concurrent.ThreadFactory() { @java.lang.Override public java.lang.Thread newThread(final java.lang.Runnable task) { final java.lang.Thread t = parent.newThread(task); t.setPriority(java.lang.Thread.MIN_PRIORITY); return t; } }); return executor; }






@java.lang.Override public void close() { executor.shutdownNow(); }
private void checkPreconditions() { checkState((!(started)), "SiteRebuilder may only be used once"); boolean hasChanges = !(changes.isEmpty()); boolean hasProjects = !(projects.isEmpty()); checkState((!(hasChanges && hasProjects)), "cannot set both changes and projects"); }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); if (!(notesMigration.enabled())) { throw die("NoteDb is not enabled."); } com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); java.lang.System.out.println("Rebuilding the NoteDb"); try (com.google.gerrit.server.notedb.rebuild.SiteRebuilder rebuilder = rebuilderFactory.create(threads, projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList()), changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList()))) { return rebuilder.rebuild() ? 0 : 1; } }



public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setForceRebuild(boolean forceRebuild) { this.forceRebuild = forceRebuild; return this; }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); try (com.google.gerrit.server.notedb.rebuild.SiteRebuilder rebuilder = rebuilderProvider.get().setThreads(threads).setProgressOut(java.lang.System.err).setTrialMode(true).setForceRebuild(true).setProjects(projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList())).setChanges(changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList()))) { if ((!(projects.isEmpty())) || (!(changes.isEmpty()))) { rebuilder.rebuild(); } else { rebuilder.autoRebuild(); } } return 0; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setTrialMode(boolean trial) { this.trial = trial; return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setProjects(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) { this.projects = (projects != null) ? com.google.common.collect.ImmutableList.copyOf(projects) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setThreads(int threads) { executor = (threads > 1) ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService(); return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setChanges(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id> changes) { this.changes = (changes != null) ? com.google.common.collect.ImmutableList.copyOf(changes) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setProgressOut(java.io.OutputStream progressOut) { this.progressOut = checkNotNull(progressOut); return this; }
public void autoRebuild() throws com.google.gwtorm.server.OrmException, java.io.IOException { checkAutoRebuildPreconditions(); java.util.Optional<com.google.gerrit.server.notedb.NotesMigrationState> maybeState = loadState(); if (!(maybeState.isPresent())) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException("Could not determine initial migration state"); } com.google.gerrit.server.notedb.NotesMigrationState state = maybeState.get(); if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) > 0)) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes")); } boolean rebuilt = false; while ((state.compareTo(NotesMigrationState.NOTE_DB_UNFUSED)) < 0) { if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) >= 0)) { return; } switch (state) { case REVIEW_DB : state = turnOnWrites(state); break; case WRITE : state = rebuildAndEnableReads(state); rebuilt = true; break; case READ_WRITE_NO_SEQUENCE : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = enableSequences(); break; case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = setNoteDbPrimary(); break; case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY : state = disableReviewDb(); break; case NOTE_DB_UNFUSED : break; case NOTE_DB : default : throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration out of the following state is not supported:\n" + (state.toText()))); } } }
private void checkPreconditions() { checkState((!(started)), "SiteRebuilder may only be used once"); }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get()); if (ctl.isHidden()) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(name); return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(ctl, repo, new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, ctl, db.get(), true)); }
public org.eclipse.jgit.lib.ObjectId sha1() { return org.eclipse.jgit.lib.ObjectId.fromRaw(com.google.common.hash.Hashing.sha1().hashString(get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()); }
private java.lang.String etag(com.google.gitiles.doc.DocServlet.MarkdownFile srcmd, @javax.annotation.Nullable com.google.gitiles.doc.DocServlet.MarkdownFile navmd) { byte[] b = new byte[org.eclipse.jgit.lib.Constants.OBJECT_ID_LENGTH]; com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); h.putInt(com.google.gitiles.doc.DocServlet.ETAG_GEN); renderer.getTemplateHash(com.google.gitiles.doc.DocServlet.SOY_FILE).writeBytesTo(b, 0, b.length); h.putBytes(b); if (navmd != null) { navmd.id.copyRawTo(b, 0); h.putBytes(b); } srcmd.id.copyRawTo(b, 0); h.putBytes(b); return h.hash().toString(); }
private static java.lang.String randSuffix() { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); byte[] buf = new byte[8]; org.eclipse.jgit.util.NB.encodeInt64(buf, 0, com.google.gerrit.common.TimeUtil.nowMs()); h.putBytes(buf); com.google.gerrit.server.change.FileContentUtil.rng.nextBytes(buf); h.putBytes(buf); return h.hash().toString(); }
@java.lang.Override public java.lang.String getETag(com.google.gerrit.server.change.RevisionResource rsrc) { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); com.google.gerrit.server.CurrentUser user = rsrc.getControl().getUser(); try { rsrc.getChangeResource().prepareETag(h, user); h.putBoolean(com.google.gerrit.server.change.Submit.wholeTopicEnabled(config)); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.get().completeChangeSet(db, rsrc.getChange(), user); for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { changeResourceFactory.create(cd.changeControl()).prepareETag(h, user); } h.putBoolean(cs.furtherHiddenChanges()); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gwtorm.server.OrmRuntimeException(e); } return h.hash().toString(); }
com.google.common.hash.HashCode computeTemplateHash(java.lang.String soyFile) { java.net.URL u = templates.get(soyFile); checkState((u != null), "Missing Soy template %s", soyFile); com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); try (java.io.InputStream is = u.openStream();java.io.OutputStream os = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(is, os); } catch (java.io.IOException e) { throw new java.lang.IllegalStateException(("Missing Soy template " + soyFile), e); } return h.hash(); }
@java.lang.Override public java.lang.String getETag() { com.google.gerrit.server.CurrentUser user = control.getUser(); com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, user); return h.hash().toString(); }
private void verifyFileChecksum() { if ((sha1) == null) { java.lang.System.err.println(); java.lang.System.err.flush(); return; } com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); try (java.io.InputStream in = java.nio.file.Files.newInputStream(dst);java.io.OutputStream out = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(in, out); } catch (java.io.IOException e) { deleteDst(); throw new com.google.gerrit.common.Die(("cannot checksum " + (dst)), e); } if (sha1.equals(h.hash().toString())) { java.lang.System.err.println((("Checksum " + (dst.getFileName())) + " OK")); java.lang.System.err.flush(); } else if (ui.isBatch()) { deleteDst(); throw new com.google.gerrit.common.Die(((dst) + " SHA-1 checksum does not match")); } else if (!(ui.yesno(null, "error: SHA-1 checksum does not match\nUse %s anyway", dst.getFileName()))) { deleteDst(); throw new com.google.gerrit.common.Die("aborted by user"); } }
public static com.google.gerrit.server.change.PostReview.CommentSetEntry create(com.google.gerrit.reviewdb.client.Comment comment) { return com.google.gerrit.server.change.PostReview.CommentSetEntry.create(comment.key.filename, comment.key.patchSetId, comment.lineNbr, com.google.gerrit.extensions.client.Side.fromShort(comment.side), com.google.common.hash.Hashing.sha1().hashString(comment.message, java.nio.charset.StandardCharsets.UTF_8), comment.range); }
public final void addOps(com.google.gerrit.server.update.BatchUpdate bu, java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = buildOps(toMerge); java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> added = com.google.common.collect.Sets.newHashSetWithExpectedSize(ops.size()); for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { added.add(op.getCommit()); } java.util.List<com.google.gerrit.server.git.CodeReviewCommit> difference = new java.util.ArrayList(com.google.common.collect.Sets.difference(toMerge, added)); java.util.Collections.reverse(difference); for (com.google.gerrit.server.git.CodeReviewCommit c : difference) { bu.addOp(c.change().getId(), new com.google.gerrit.server.git.strategy.ImplicitIntegrateOp(args, c)); } for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { bu.addOp(op.getId(), op); } }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(com.google.gerrit.server.update.BatchUpdate.Factory batchUpdateFactory, java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate(batchUpdateFactory)); } return updates; }

public final org.eclipse.jgit.notes.NoteMap commitNewNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws java.io.IOException, org.eclipse.jgit.api.errors.ConcurrentRefUpdateException { this.overwrite = false; commitNotes(notes, notesBranch, commitAuthor, commitMessage); org.eclipse.jgit.notes.NoteMap newlyCreated = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); for (org.eclipse.jgit.notes.Note n : notes) { if (((base) == null) || (!(base.contains(n)))) { newlyCreated.set(n, n.getData()); } } return newlyCreated; }
@java.lang.Override public com.google.gerrit.server.project.BanCommit.BanResultInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } try { com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } catch (org.eclipse.jgit.api.errors.ConcurrentRefUpdateException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } return r; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectControl), input); printCommits(r.newlyBanned, "The following commits were banned"); printCommits(r.alreadyBanned, "The following commits were already banned"); printCommits(r.ignored, "The following ids do not represent commits and were ignored"); } catch (com.google.gerrit.extensions.restapi.RestApiException | java.io.IOException e) { throw die(e); } }
public final void commitAllNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws java.io.IOException, org.eclipse.jgit.api.errors.ConcurrentRefUpdateException { this.overwrite = true; commitNotes(notes, notesBranch, commitAuthor, commitMessage); }





public boolean doCanForDefaultPermissionBackend(com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { if (perm instanceof com.google.gerrit.server.permissions.GlobalPermission) { return can(((com.google.gerrit.server.permissions.GlobalPermission) (perm))); } else if (perm instanceof com.google.gerrit.extensions.api.access.PluginPermission) { return (canPerform(perm.permissionName())) || (isAdmin_DoNotUse()); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private WorkQueue.Executor getExecutor() { return queue.getQueue(user.get().getCapabilities().getQueueType()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), new com.google.gerrit.server.change.WorkInProgressOp(cmUtil, true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for review"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), new com.google.gerrit.server.change.WorkInProgressOp(cmUtil, false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }

@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); change.setWorkInProgress(workInProgress); if ((!(change.hasReviewStarted())) && (!(workInProgress))) { change.setReviewStarted(true); } change.setLastUpdatedOn(ctx.getWhen()); update.setWorkInProgress(workInProgress); addMessage(ctx, update); return true; }


@org.junit.Test public void migrationDoesNotRequireIndex() throws java.lang.Exception { assertNotesMigrationState(NotesMigrationState.REVIEW_DB); setUpOneChange(); int version = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion(); com.google.gerrit.server.index.GerritIndexStatus status = new com.google.gerrit.server.index.GerritIndexStatus(new com.google.gerrit.server.config.SitePaths(site)); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isTrue(); status.setReady(ChangeSchemaDefinitions.NAME, version, false); status.save(); migrate("--trial", "false"); assertNotesMigrationState(NotesMigrationState.NOTE_DB_UNFUSED); status = new com.google.gerrit.server.index.GerritIndexStatus(new com.google.gerrit.server.config.SitePaths(site)); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isFalse(); try (com.google.gerrit.acceptance.GerritServer server = startServer()) { fail("expected server startup to fail"); } catch (com.google.gerrit.acceptance.GerritServer e) { } }

public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator build() throws com.google.gerrit.server.notedb.rebuild.MigrationException { return new com.google.gerrit.server.notedb.rebuild.NoteDbMigrator(sitePaths, schemaFactory, rebuilder, globalNotesMigration, ((threads) > 1 ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService()), projects, changes, progressOut, trial, forceRebuild); }
private static com.google.gerrit.acceptance.GerritServer startOnDisk(com.google.gerrit.acceptance.GerritServer.Description desc, java.nio.file.Path site, com.google.gerrit.pgm.Daemon daemon, java.util.concurrent.CyclicBarrier serverStarted) throws java.lang.Exception { checkNotNull(site); java.util.concurrent.ExecutorService daemonService = java.util.concurrent.Executors.newSingleThreadExecutor(); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = daemonService.submit(() -> { int rc = daemon.main(new java.lang.String[]{ "-d", site.toString(), "--headless", "--console-log", "--show-stack-trace" }); if (rc != 0) { java.lang.System.err.println("Failed to start Gerrit daemon"); serverStarted.reset(); } return null; }); serverStarted.await(); java.lang.System.out.println("Gerrit Server Started"); return new com.google.gerrit.acceptance.GerritServer(desc, com.google.gerrit.acceptance.GerritServer.createTestInjector(daemon), daemon, daemonService); }
private com.google.gerrit.server.notedb.NotesMigrationState enableSequences() { throw new java.lang.UnsupportedOperationException("not yet implemented"); }

@org.junit.Test public void preconditionsFail() throws java.lang.Exception { java.util.List<com.google.gerrit.reviewdb.client.Change.Id> cs = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Change.Id(1)); java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> ps = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Project.NameKey("p")); assertMigrationException("Cannot rebuild without noteDb.changes.write=true", ( b) -> b, NoteDbMigrator::rebuild); assertMigrationException("Cannot set both changes and projects", ( b) -> b.setChanges(cs).setProjects(ps), ( m) -> { }); assertMigrationException("Cannot set changes or projects during auto-migration", ( b) -> b.setChanges(cs), NoteDbMigrator::migrate); assertMigrationException("Cannot set changes or projects during auto-migration", ( b) -> b.setProjects(ps), NoteDbMigrator::migrate); setNotesMigrationState(NotesMigrationState.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", ( b) -> b.setTrialMode(true), NoteDbMigrator::migrate); setNotesMigrationState(NotesMigrationState.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY); assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", ( b) -> b.setForceRebuild(true), NoteDbMigrator::migrate); }




@java.lang.Override public synchronized void stop() { if ((ds) instanceof org.apache.commons.dbcp.BasicDataSource) { try { ((org.apache.commons.dbcp.BasicDataSource) (ds)).close(); } catch (java.sql.SQLException e) { } } }
@java.lang.Override public void onTimeout(org.eclipse.jetty.continuation.Continuation self) { executor.remove(this); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); reject(cmd, "invalid object"); return; } logDebug("Creating {}", cmd); if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); boolean ok; try { permissions.ref(cmd.getRefName()).check(RefPermission.CREATE); ok = true; } catch (com.google.gerrit.extensions.restapi.AuthException err) { ok = false; } if (ok && (ctl.canCreate(rp.getRepository(), obj))) { if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); actualCommands.add(cmd); } else { reject(cmd, ("prohibited by Gerrit: create access denied for " + (cmd.getRefName()))); } }
private boolean canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { if (canUpdate()) { return true; } else if (isMergedIntoBranchOrTag(repo, commit)) { return true; } return false; }









@java.lang.Override public void configure() { listener().to(com.google.gerrit.lucene.LuceneVersionManager.class); }



public com.google.gerrit.reviewdb.client.Account get(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { return db.accounts().get(accountId); }
public java.util.List<com.google.gerrit.reviewdb.client.Account> all(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { return db.accounts().all().toList(); }

public java.util.List<com.google.gerrit.reviewdb.client.Account> get(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException { return db.accounts().get(accountIds).toList(); }





public int getEffectiveMaxBatchChangesLimit(com.google.gerrit.server.CurrentUser user) { com.google.gerrit.server.account.CapabilityControl cap = capabilityFactory.create(user); if (cap.hasExplicitRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT)) { return cap.getRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT).getMax(); } return systemMaxBatchChanges; }
private void addRanges(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.CapabilityControl cc) { for (java.lang.String name : com.google.gerrit.common.data.GlobalCapability.getRangeNames()) { if ((want(name)) && (cc.hasExplicitRange(name))) { have.put(name, new com.google.gerrit.server.account.GetCapabilities.Range(cc.getRange(name))); } } }
private void addPriority(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.CapabilityControl cc) { com.google.gerrit.server.git.QueueProvider.QueueType queue = cc.getQueueType(); if ((queue != (QueueProvider.QueueType.INTERACTIVE)) || (((query) != null) && (query.contains(com.google.gerrit.server.account.PRIORITY)))) { have.put(com.google.gerrit.server.account.PRIORITY, queue); } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(self); if ((self.get()) != (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : perm.test(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.CapabilityControl cc = capabilityFactory.create(rsrc.getUser()); addRanges(have, cc); addPriority(have, cc); return OutputFormat.JSON.newGson().toJsonTree(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.lang.String branchName = id.get(); if (!(branchName.equals(Constants.HEAD))) { branchName = com.google.gerrit.reviewdb.client.RefNames.fullName(branchName); } java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> branches = list.get().apply(parent); for (com.google.gerrit.extensions.api.projects.BranchInfo b : branches) { if (branchName.equals(b.ref)) { return new com.google.gerrit.server.project.BranchResource(parent.getControl(), b); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }


protected void grantLabel(java.lang.String permission, int min, int max, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, boolean force, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { md.setMessage(java.lang.String.format("Grant %s on %s", permission, ref)); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection s = config.getAccessSection(ref, true); com.google.gerrit.common.data.Permission p = s.getPermission(permission, true); com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.newRule(config, groupUUID); rule.setForce(force); rule.setMin(min); rule.setMax(max); p.add(rule); config.commit(md); projectCache.evict(config.getProject()); } }


void populate(int row, com.google.gerrit.client.projects.TagInfo k) { if (k.canDelete()) { com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); canDelete = true; } else { table.setText(row, 1, ""); } table.setWidget(row, 2, new com.google.gwt.user.client.ui.InlineHTML(highlight(k.getShortName(), match))); if ((k.revision()) != null) { table.setText(row, 3, k.revision()); } else { table.setText(row, 3, ""); } com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); java.lang.String iconCellStyle = Gerrit.RESOURCES.css().iconCell(); java.lang.String dataCellStyle = Gerrit.RESOURCES.css().dataCell(); fmt.addStyleName(row, 1, iconCellStyle); fmt.addStyleName(row, 2, dataCellStyle); fmt.addStyleName(row, 3, dataCellStyle); setRowItem(row, k); }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.RefControl control) throws java.io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (tagger != null ? com.google.gerrit.server.CommonConverters.toGitPerson(tag.getTaggerIdent()) : null), control.canDelete()); } return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), ref.getObjectId().getName(), control.canDelete()); }
private java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> visibleTags(com.google.gerrit.server.project.ProjectControl control, org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> tags) { return new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, control, dbProvider.get(), false).filter(tags, true); }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); com.google.gerrit.server.project.ProjectControl control = resource.getControl(); if ((ref != null) && (!(visibleTags(control, repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty()))) { return com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, control.controlForRef(ref.getName())); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.project.ProjectControl control = resource.getControl(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(control, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, control.controlForRef(ref.getName()))); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags); }





protected void allow(java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, java.lang.String ref) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, permission, id, ref); saveProjectConfig(project, cfg); }


public void load(org.eclipse.jgit.revwalk.RevWalk walk, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { this.rw = walk; this.reader = walk.getObjectReader(); try { revision = (id != null) ? walk.parseCommit(id) : null; onLoad(); } finally { walk = null; reader = null; } }
@java.lang.Override public void visit(org.commonmark.node.Heading node) { outputNamedAnchor = false; java.lang.String tag = "h" + (node.getLevel()); html.open(tag); java.lang.String id = toc.idFromHeader(node); if (id != null) { html.open("a").attribute("class", "h").attribute("name", id).attribute("href", ("#" + id)).open("span").close("span").close("a"); } visitChildren(node); html.close(tag); outputNamedAnchor = true; }
public java.util.Optional<com.google.gerrit.reviewdb.client.Comment> get(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Comment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return java.util.Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(( plc) -> plc.asComment(serverId)); } java.util.function.Predicate<com.google.gerrit.reviewdb.client.Comment> p = ( c) -> key.equals(c.key); java.util.Optional<com.google.gerrit.reviewdb.client.Comment> c = publishedByChange(db, notes).stream().filter(p).findFirst(); if (c.isPresent()) { return c; } return draftByChange(db, notes).stream().filter(p).findFirst(); }

@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.reviewdb.client.Comment> maybeComment = commentsUtil.get(ctx.getDb(), ctx.getNotes(), key); if (!(maybeComment.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("comment not found: " + (key))); } com.google.gerrit.reviewdb.client.Comment origComment = maybeComment.get(); comment = new com.google.gerrit.reviewdb.client.Comment(origComment); ctx.getUser().updateRealAccountId(comment::setRealAuthor); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(psId); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("patch set not found: " + psId)); } if (((in.path) != null) && (!(in.path.equals(origComment.key.filename)))) { commentsUtil.deleteComments(ctx.getDb(), update, java.util.Collections.singleton(origComment)); comment.key.filename = in.path; } com.google.gerrit.server.CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), ps); commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, java.util.Collections.singleton(com.google.gerrit.server.change.PutDraftComment.update(comment, in, ctx.getWhen()))); ctx.dontBumpLastUpdatedOn(); return true; }
@org.junit.Test public void includesNavbar() throws java.lang.Exception { java.lang.String navbar = "# Site Title\n" + (("\n" + "* [Home](index.md)\n") + "* [README](README.md)\n"); repo.branch("master").commit().add("README.md", "# page\n\nof information.").add("navbar.md", navbar).create(); java.lang.String html = buildHtml("/repo/+doc/master/README.md"); assertThat(html).contains("<title>Site Title - page</title>"); assertThat(html).contains("<span class=\"Header-anchorTitle\">Site Title</span>"); assertThat(html).contains("<li><a href=\"/b/repo/+/master/index.md\">Home</a></li>"); assertThat(html).contains("<li><a href=\"/b/repo/+/master/README.md\">README</a></li>"); assertThat(html).contains(("<h1>" + (("<a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>" + "<a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>") + "page</h1>"))); }




@java.lang.Override public void setMessage(java.lang.String in) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.change.PutMessage.Input input = new com.google.gerrit.server.change.PutMessage.Input(); input.message = in; putMessage.apply(change, input); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot edit commit message", e); } }






@java.lang.Override public java.lang.String getAuthorizationUrl() { java.lang.String url = service.getAuthorizationUrl(null); try { if (!(com.google.common.base.Strings.isNullOrEmpty(domain))) { url += "&hd=" + (java.net.URLEncoder.encode(domain, java.nio.charset.StandardCharsets.UTF_8.name())); } } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.IllegalArgumentException(e); } if (com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.isDebugEnabled()) { com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.debug("OAuth2: authorization URL={}", url); } return url; }
protected void assertRebase(org.eclipse.jgit.junit.TestRepository<?> testRepo, boolean contentMerge) throws java.lang.Exception { org.eclipse.jgit.lib.Repository repo = testRepo.getRepository(); org.eclipse.jgit.revwalk.RevCommit localHead = getHead(repo); org.eclipse.jgit.revwalk.RevCommit remoteHead = getRemoteHead(); assert_().withMessage(java.lang.String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId()); assertThat(remoteHead.getParentCount()).isEqualTo(1); if (!contentMerge) { assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo)); } assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage()); }
private java.io.File resolveFile(javax.servlet.http.HttpServletRequest req) { return new java.io.File(site_path, ((req.getServletPath()) + (req.getPathInfo()))); }
private void setMissingHeader(final java.util.Map<java.lang.String, com.google.gerrit.server.mail.send.EmailHeader> hdrs, java.lang.String name, java.lang.String value) { if ((!(hdrs.containsKey(name))) || (hdrs.get(name).isEmpty())) { hdrs.put(name, new com.google.gerrit.server.mail.send.EmailHeader.String(value)); } }
protected java.lang.String buildMultipartBody(java.lang.String boundary, java.lang.String textPart, java.lang.String htmlPart) { return ((((((((((((((((("--" + boundary) + "\r\n") + "Content-Type: text/plain; charset=UTF-8\r\n") + "Content-Transfer-Encoding: 8bit\r\n") + "\r\n") + textPart) + "\r\n") + "--") + boundary) + "\r\n") + "Content-Type: text/html; charset=UTF-8\r\n") + "Content-Transfer-Encoding: 8bit\r\n") + "\r\n") + htmlPart) + "\r\n") + "--") + boundary) + "--\r\n"; }

public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.reviewdb.client.Project p) { com.google.gerrit.extensions.common.ProjectInfo info = new com.google.gerrit.extensions.common.ProjectInfo(); info.name = p.getName(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = p.getParent(allProjects); info.parent = (parentName != null) ? parentName.get() : null; info.description = com.google.common.base.Strings.emptyToNull(p.getDescription()); info.state = p.getState(); info.id = com.google.gerrit.extensions.restapi.Url.encode(info.name); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getProjectLinks(p.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.server.project.ProjectResource rsrc) { return format(rsrc.getControl().getProject()); }
public static com.google.gerrit.acceptance.GerritServer initAndStart(com.google.gerrit.acceptance.GerritServer.Description desc, org.eclipse.jgit.lib.Config baseConfig) throws java.lang.Exception { if (!(desc.memory())) { assume().withMessage("FUSED mode not yet supported for on-disk sites").that(com.google.gerrit.testutil.NoteDbMode.get()).isNotEqualTo(NoteDbMode.FUSED); } java.nio.file.Path site = java.nio.file.Paths.get(baseConfig.getString("gerrit", null, "tempSiteDir")); if (!(desc.memory())) { com.google.gerrit.acceptance.GerritServer.init(desc, baseConfig, site); } return com.google.gerrit.acceptance.GerritServer.start(desc, baseConfig, site, null); }
public org.eclipse.jgit.lib.ObjectId loadRevision() throws com.google.gwtorm.server.OrmException { if (loaded) { return getRevision(); } else if (!(args.migration.enabled())) { return null; } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(getProjectName())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(getRefName()); return ref != null ? ref.getObjectId() : null; } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }

@com.google.gwtorm.server.Sequence(startWith = 1000000) int nextAccountId() throws com.google.gwtorm.server.OrmException;

@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { com.google.gerrit.server.patch.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if ((key.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(key), com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } throw e; } }
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException { if (!visible) { return cd.changeControl().getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((("Failed to get submit type for " + (cd.getId())) + ": ") + (str.errorMessage))); } return str.type; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, this).getSubmitType(); } return submitTypeRecord; }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { for (com.google.gerrit.common.data.PermissionRange pr : cd.changeControl().getLabelRanges()) { if (!(pr.isEmpty())) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec)); } return rec.type; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment(com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((opts.rule()) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.StringReader(opts.rule())); } } catch (com.googlecode.prolog_cafe.exceptions.CompileException err) { java.lang.String msg; if (((opts.rule()) == null) && (control.getProjectControl().isOwner())) { msg = java.lang.String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage()); } else if ((opts.rule()) != null) { msg = err.getMessage(); } else { msg = java.lang.String.format("Cannot load rules.pl for %s", getProjectName()); } throw new com.google.gerrit.server.project.RuleEvalException(msg, err); } env.set(StoredValues.ACCOUNT_CACHE, accountCache); env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.CHANGE_CONTROL, control); if (user != null) { env.set(StoredValues.CURRENT_USER, user); } return env; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, cd).setPatchSet(patchSet).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo(); info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
public com.google.gson.JsonElement display(java.io.PrintWriter stdout) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = com.google.common.collect.Lists.newArrayList(pluginLoader.getPlugins(all)); java.util.Collections.sort(plugins, new java.util.Comparator<com.google.gerrit.server.plugins.Plugin>() { @java.lang.Override public int compare(com.google.gerrit.server.plugins.Plugin a, com.google.gerrit.server.plugins.Plugin b) { return a.getName().compareTo(b.getName()); } }); if (!(format.isJson())) { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format("%-30s %-10s %-8s %s\n", p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return OutputFormat.JSON.newGson().toJsonTree(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); } else if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }


@java.lang.Override public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException { throw new java.lang.UnsupportedOperationException(); }


java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException;
@java.lang.Override public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException { try { return extIdsByAccount.get(externalIdReader.readRevision()).byEmail().get(email); } catch (java.util.concurrent.ExecutionException e) { throw new java.io.IOException("Cannot list external ids by email", e); } }
void loadChangeInfo(boolean fg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get()); java.util.EnumSet<com.google.gerrit.extensions.client.ListChangesOption> opts = java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS); if (enableSignedPush()) { opts.add(ListChangesOption.PUSH_CERTIFICATES); } com.google.gerrit.client.changes.ChangeList.addOptions(call, opts); if (!fg) { call.background(); } call.get(cb); }
public static void editWithFiles(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id).addParameterTrue("list").get(cb); }
public static void comment(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String commentId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, "comments").id(commentId).get(cb); }
public static void detail(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.detail(id).get(cb); }
public static void updateDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, "drafts").id(draftId).put(content, cb); }
public static void deleteDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { CommentApi.revision(id, "drafts").id(draftId).delete(cb); }
public static void comments(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, "comments").get(cb); }
public static void createDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, "drafts").put(content, cb); }
public static com.google.gerrit.client.rpc.RestApi revision(int id, java.lang.String revision) { return ChangeApi.change(id).view("revisions").id(revision); }
public static com.google.gerrit.client.rpc.RestApi hashtag(int changeId, java.lang.String hashtag) { return com.google.gerrit.client.changes.ChangeApi.change(changeId).view("hashtags").id(hashtag); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getSideBySideDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toSideBySideDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toSideBySideDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); toSideBySideDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toSideBySide(base, revision, path)); toSideBySideDiffLink.setTitle(PatchUtil.C.sideBySideDiff()); return java.util.Collections.singletonList(toSideBySideDiffLink); }
private static void onRemove(com.google.gwt.dom.client.NativeEvent event) { java.lang.String hashtags = com.google.gerrit.client.change.Hashtags.getDataId(event); if (hashtags != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.PatchSet.Id psId = screen.getPatchSetId(); com.google.gerrit.client.changes.ChangeApi.hashtags(psId.getParentKey().get()).post(com.google.gerrit.client.change.Hashtags.PostInput.create(null, hashtags), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } } }); } }
private void addHashtag(final java.lang.String hashtags) { com.google.gerrit.client.changes.ChangeApi.hashtags(changeId.get()).post(com.google.gerrit.client.change.Hashtags.PostInput.create(hashtags, null), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId.getParentKey(), java.lang.String.valueOf(psId.get()))); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); hashtagTextBox.setEnabled(true); } }); }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { if ((edit) != null) { edit.setName(edit.commit().commit()); result.revisions().put(edit.name(), com.google.gerrit.client.info.ChangeInfo.RevisionInfo.fromEdit(edit)); } render(result.revisions()); loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.client.info.ChangeInfo info, final java.lang.String revision, java.lang.String project, final java.lang.String commitMessage) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); if ((info.status()) == (Change.Status.MERGED)) { message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision)); } else { message.setText(commitMessage.trim()); } } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private static com.google.gerrit.client.rpc.RestApi revision(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String type) { return com.google.gerrit.client.changes.ChangeApi.revision(id).view(type); }
public static void draft(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, "drafts").id(draftId).get(cb); }
public static void drafts(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, "drafts").get(cb); }
@java.lang.Override protected void onLoad() { if ((fetch) == null) { if ((psId.get()) == 0) { com.google.gerrit.client.changes.ChangeApi.editWithCommands(change.legacyId().get()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.EditInfo result) { fetch = result.fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } else { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(change.legacyId().get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of((revision.equals(change.currentRevision()) ? com.google.gerrit.extensions.client.ListChangesOption.CURRENT_REVISION : com.google.gerrit.extensions.client.ListChangesOption.ALL_REVISIONS), ListChangesOption.DOWNLOAD_COMMANDS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { fetch = result.revision(revision).fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); }
public static com.google.gerrit.client.rpc.RestApi vote(int id, int reviewer, java.lang.String vote) { return ChangeApi.reviewer(id, reviewer).view("votes").id(vote); }
public static void deleteChange(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id).delete(cb); }
public static void delete(int id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editFile(id, path).delete(cb); }
private void scrollToPath(java.lang.String token) { int s = token.indexOf('/'); try { java.lang.String c = token.substring(0, s); int editIndex = c.indexOf(",edit"); if (editIndex > 0) { c = c.substring(0, editIndex); } if ((s < 0) || (!(changeId.equals(Change.Id.parse(c))))) { return; } } catch (java.lang.IllegalArgumentException e) { return; } s = token.indexOf('/', (s + 1)); if (s < 0) { return; } int c = token.lastIndexOf(','); if (0 <= c) { token = token.substring((s + 1), c); } else { token = token.substring((s + 1)); } if (!(token.isEmpty())) { files.scrollToPath(com.google.gwtorm.client.KeyUtil.decode(token)); } }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(com.google.gerrit.client.diff.Unified.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static void put(int id, java.lang.String path, java.lang.String content, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { if (Patch.COMMIT_MSG.equals(path)) { com.google.gerrit.client.changes.ChangeEditApi.putMessage(id, content, cb); } else { com.google.gerrit.client.changes.ChangeEditApi.editFile(id, path).put(content, cb); } }
public static void rename(int id, java.lang.String path, java.lang.String newPath, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.oldPath(path); in.newPath(newPath); com.google.gerrit.client.changes.ChangeApi.edit(id).post(in, cb); }
void renderPublished(com.google.gerrit.client.diff.DisplaySide forSide, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> in) { for (com.google.gerrit.client.changes.CommentInfo info : com.google.gerrit.client.rpc.Natives.asList(in)) { com.google.gerrit.client.diff.DisplaySide side = displaySide(info, forSide); if (side != null) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), info, side, isOpen()); group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.comment(host.getCmFromSide(side), (cmLinePlusOne - 1))); getPublished().put(info.id(), box); } } }
com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.diff.DisplaySide side, com.google.gerrit.client.changes.CommentInfo info) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), info, isExpandAll()); if ((info.inReplyTo()) != null) { com.google.gerrit.client.diff.PublishedBox r = getPublished().get(info.inReplyTo()); if (r != null) { r.setReplyBox(box); } } group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.draft(host.getCmFromSide(side), java.lang.Math.max(0, (cmLinePlusOne - 1)))); return box; }
private void renderComments(java.util.List<com.google.gerrit.client.changes.CommentInfo> list) { com.google.gerrit.client.ui.CommentLinkProcessor clp = history.getCommentLinkProcessor(); com.google.gerrit.reviewdb.client.PatchSet.Id ps = new com.google.gerrit.reviewdb.client.PatchSet.Id(history.getChangeId(), info._revisionNumber()); java.util.TreeMap<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> m = com.google.gerrit.client.change.Message.byPath(list); java.util.List<com.google.gerrit.client.changes.CommentInfo> l = m.remove(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, Util.C.commitMessage(), l)); } l = m.remove(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, Util.C.mergeList(), l)); } for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> e : m.entrySet()) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, e.getKey(), e.getValue())); } }
public static void getMeta(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.editor.EditFileInfo> cb) { if ((id.get()) != 0) { throw new java.lang.IllegalStateException("only supported for edits"); } com.google.gerrit.client.changes.ChangeEditApi.editFile(id.getParentKey().get(), path).view("meta").get(cb); }
private void loadCommit(final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { if ((rev.isEdit()) || ((rev.commit()) != null)) { return; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { rev.setCommit(info); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.PatchSet.Id ps, com.google.gerrit.client.changes.CommentInfo info) { return com.google.gerrit.client.Dispatcher.toPatch(null, ps, info.path(), ((info.side()) == (com.google.gerrit.extensions.client.Side.PARENT) ? com.google.gerrit.client.diff.DisplaySide.A : com.google.gerrit.client.diff.DisplaySide.B), info.line()); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadDrafts(com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } else { r.add(com.google.gerrit.client.rpc.NativeMap.<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>create()); } return r; }
private static com.google.gerrit.client.rpc.RestApi editMessage(int id) { return com.google.gerrit.client.changes.ChangeApi.change(id).view("edit:message"); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { super.onFailure(err); } }
static void publishEdit(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.publishEdit(id.get(), com.google.gerrit.client.change.EditActions.cs(id, editButtons)); }
static void rebaseEdit(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.rebaseEdit(id.get(), com.google.gerrit.client.change.EditActions.cs(id, editButtons)); }
static void deleteEdit(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.deleteEdit(id.get(), com.google.gerrit.client.change.EditActions.cs(id, editButtons)); }
private void delete(java.lang.String path) { hide(); com.google.gerrit.client.changes.ChangeEditApi.delete(changeId.get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(changeId)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
public static com.google.gerrit.client.rpc.RestApi suggestReviewers(int id, java.lang.String q, int n, boolean e) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e); if (q != null) { api.addParameter("q", q); } return api; }
public static void includedIn(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo> cb) { com.google.gerrit.client.changes.ChangeApi.call(id, "in").get(cb); }
@com.google.gwt.uibinder.client.UiHandler("deleteEdit") void onDeleteEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChangeEdit())) { com.google.gerrit.client.change.EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit); } }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(final com.google.gerrit.reviewdb.client.Change.Id id, final com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.change.EditActions.setEnabled(false, editButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { super.onFailure(err); } } }; }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
@java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(revision.getParentKey(), revision.getId())); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); }
private void open(java.lang.String path) { hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, revision._number()), path)); }
void onDelete() { if ((popup) != null) { popup.hide(); return; } if ((deleteBox) == null) { deleteBox = new com.google.gerrit.client.change.DeleteFileBox(changeId, revision); } deleteBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(deleteButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(deleteBox); p.showRelativeTo(deleteButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); deleteBox.setFocus(true); popup = p; }
private void getImpl(final java.lang.Integer id, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> cb) { java.lang.String name = changeToProject.get(id); if (name != null) { getImpl(name, cb); return; } com.google.gerrit.client.changes.ChangeApi.change(id).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { changeToProject.put(id, result.project()); getImpl(result.project(), cb); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { cb.onFailure(caught); } }); }

private com.google.inject.Key<javax.servlet.http.HttpServlet> directChangeById() { return key(new javax.servlet.http.HttpServlet() { private static final long serialVersionUID = 1L; @java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(id), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } } }); }
@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(id), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } }
static void call(com.google.gerrit.client.info.ChangeInfo changeInfo, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revisionInfo) { if (com.google.gerrit.client.api.ChangeGlue.onSubmitChange(changeInfo, revisionInfo)) { final com.google.gerrit.reviewdb.client.Change.Id changeId = changeInfo.legacyId(); com.google.gerrit.client.changes.ChangeApi.submit(changeId.get(), revisionInfo.name(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.SubmitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.SubmitInfo result) { redisplay(); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); } else { super.onFailure(err); } redisplay(); } private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } }); } }
private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); }
void onRestore(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.restore(curr.getParentKey().get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getUnifiedDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toUnifiedDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toUnifiedDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); toUnifiedDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toUnified(base, revision, path)); toUnifiedDiffLink.setTitle(PatchUtil.C.unifiedDiff()); return java.util.Collections.singletonList(toUnifiedDiffLink); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return info.binary() ? com.google.gerrit.client.Dispatcher.toUnified(base, curr, info.path()) : (mode) == (com.google.gerrit.client.change.FileTable.Mode.REVIEW) ? com.google.gerrit.client.Dispatcher.toPatch(base, curr, info.path()) : com.google.gerrit.client.Dispatcher.toEditScreen(curr, info.path()); }
void onDelete(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.delete(curr.getParentKey().get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey())); }
private void setReviewed(com.google.gerrit.client.info.FileInfo info, boolean r) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(curr).view("files").id(info.path()).view("reviewed"); if (r) { api.put(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } else { api.delete(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } }
@java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(changeId, base, rev, openReplyBox, FileTable.Mode.REVIEW)); }
private void countParents(com.google.gerrit.client.rpc.CallbackGroup cbg) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision.getId()).view("commit").get(cbg.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { parents = info.parents().length(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { parents = 0; } })); }
void reloadDiffInfo() { int id = ++(reloadVersionId); com.google.gerrit.client.diff.DiffApi.diff(revision, path).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { if ((id == (reloadVersionId)) && (isAttached())) { diff = diffInfo; operation(() -> { skipManager.removeAll(); getChunkManager().reset(); getDiffTable().scrollbar.removeDiffAnnotations(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); }); } } }); }
private java.lang.Runnable openEditScreen(net.codemirror.lib.CodeMirror cm) { return () -> { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras().activeLine(); int line = (cm.getLineNumber(handle)) + 1; if (Patch.COMMIT_MSG.equals(path)) { line = adjustCommitMessageLine(line); } java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen(revision, path, line); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(token); } else { com.google.gerrit.client.Gerrit.display(token); } }; }
void prefetchNextFile() { java.lang.String nextPath = header.getNextPath(); if (nextPath != null) { com.google.gerrit.client.diff.DiffApi.diff(revision, nextPath).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo info) { new net.codemirror.mode.ModeInjector().add(getContentType(info.metaA())).add(getContentType(info.metaB())).inject(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private java.lang.Runnable upToChange(boolean openReplyBox) { return () -> { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); getCommentManager().saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(changeId, base, rev, openReplyBox, FileTable.Mode.REVIEW)); } }); }; }
private void rename(java.lang.String path, java.lang.String newPath) { hide(); com.google.gerrit.client.changes.ChangeEditApi.rename(changeId.get(), path, newPath, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(changeId)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
static void invoke(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.rpc.RestApi api) { com.google.gerrit.client.api.DefaultActions.invoke(action, api, com.google.gerrit.client.api.DefaultActions.callback(com.google.gerrit.common.PageLinks.toChange(change.legacyId()))); }
private static void codemirror(final java.lang.String token, final com.google.gerrit.client.DiffObject base, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); } }); }
@com.google.gwt.uibinder.client.UiHandler("permalink") void onReload(com.google.gwt.event.dom.client.ClickEvent e) { e.preventDefault(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(com.google.gerrit.client.diff.SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static java.lang.String toChange(com.google.gerrit.reviewdb.client.Change.Id c, java.lang.String b, java.lang.String p) { java.lang.String u = ("/c/" + c) + "/"; if (b != null) { u += b + ".."; } u += p; return u; }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }

public static java.lang.String toChangeInEditMode(com.google.gerrit.reviewdb.client.Change.Id c) { return ("/c/" + c) + ",edit/"; }
private void loadDiff(com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group) { java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(rev, group); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts = loadDrafts(rev, group); loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts); if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((fileTableMode) == (FileTable.Mode.REVIEW))) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { files.markReviewed(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } }
@com.google.gwt.uibinder.client.UiHandler("rebaseEdit") void onRebaseEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit); }
private void updateToken(com.google.gerrit.client.info.ChangeInfo info, com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev) { java.lang.StringBuilder token = new java.lang.StringBuilder("/c/").append(info._number()).append("/"); if ((base.asString()) != null) { token.append(base.asString()).append(".."); } if (((base.asString()) != null) || (!(rev.name().equals(info.currentRevision())))) { token.append(rev._number()); } setToken(token.toString()); }
@com.google.gwt.uibinder.client.UiHandler("publishEdit") void onPublishEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit); }
void showUpdates(com.google.gerrit.client.info.ChangeInfo newInfo) { if ((!(isAttached())) || (newInfo.updated().equals(lastDisplayedUpdate))) { return; } com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> om = changeInfo.messages(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> nm = newInfo.messages(); if (om == null) { om = com.google.gwt.core.client.JsArray.createArray().cast(); } if (nm == null) { nm = com.google.gwt.core.client.JsArray.createArray().cast(); } if ((om.length()) == (nm.length())) { return; } if ((updateAvailable) == null) { updateAvailable = new com.google.gerrit.client.change.UpdateAvailableBar() { @java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } @java.lang.Override void onIgnore(java.sql.Timestamp newTime) { lastDisplayedUpdate = newTime; } }; } updateAvailable.set(com.google.gerrit.client.rpc.Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated()); if (!(updateAvailable.isAttached())) { add(updateAvailable); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId.getParentKey(), java.lang.String.valueOf(psId.get()))); }
private com.google.gerrit.client.ui.InlineHyperlink createLink(java.lang.String label, com.google.gerrit.client.DiffObject id) { assert (other) != null; if (sideA) { assert !(other.idActive.isBaseOrAutoMerge()); } com.google.gerrit.client.DiffObject diffBase = (sideA) ? id : other.idActive; com.google.gerrit.client.DiffObject revision = (sideA) ? other.idActive : id; return new com.google.gerrit.client.ui.InlineHyperlink(label, (parent.isSideBySide() ? com.google.gerrit.client.Dispatcher.toSideBySide(diffBase, revision.asPatchSetId(), path) : com.google.gerrit.client.Dispatcher.toUnified(diffBase, revision.asPatchSetId(), path))); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.createChange(project, branch, topic, message, base, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); hide(); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); hide(); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.EditInfo edit, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.edit(change.legacyId().get()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.EditGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(edit); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
public static void get(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, boolean base, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.rpc.RestApi api; if ((id.get()) != 0) { api = com.google.gerrit.client.changes.ChangeApi.revision(id).view("files").id(path).view("content"); } else if (Patch.COMMIT_MSG.equals(path)) { api = com.google.gerrit.client.changes.ChangeEditApi.editMessage(id.getParentKey().get()).addParameter("base", base); } else { api = com.google.gerrit.client.changes.ChangeEditApi.editFile(id.getParentKey().get(), path).addParameter("base", base); } api.get(cb); }
public static void putMessage(int id, java.lang.String m, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editMessage(id).put(m, cb); }
public static void restore(int id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.restorePath(path); com.google.gerrit.client.changes.ChangeApi.edit(id).post(in, cb); }
private static com.google.gerrit.client.rpc.RestApi editFile(int id, java.lang.String path) { return com.google.gerrit.client.changes.ChangeApi.edit(id).id(path); }
void setUpBlame(final net.codemirror.lib.CodeMirror cm, final boolean isBase, final com.google.gerrit.reviewdb.client.PatchSet.Id rev, final java.lang.String path) { if (((!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) && (com.google.gerrit.client.Gerrit.isSignedIn())) && (com.google.gerrit.client.Gerrit.info().change().allowBlame())) { com.google.gwt.user.client.ui.Anchor blameIcon = createBlameIcon(); blameIcon.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(rev, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } } }); linkPanel.add(blameIcon); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(rev, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } }
private com.google.gwt.user.client.ui.Widget createEditIcon() { com.google.gerrit.reviewdb.client.PatchSet.Id id = (idActive.isBaseOrAutoMerge()) ? other.idActive.asPatchSetId() : idActive.asPatchSetId(); com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.edit()), ("#" + (com.google.gerrit.client.Dispatcher.toEditScreen(id, path)))); anchor.setTitle(PatchUtil.C.edit()); return anchor; }
public static void get(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.changes.ChangeEditApi.get(id, path, false, cb); }
private java.lang.String getReplyCommentName() { return "savedReplyComment-" + (changeId.toString()); }
@com.google.gwt.uibinder.client.UiHandler("fix") void onFix(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); java.lang.String t = com.google.gerrit.client.Dispatcher.toEditScreen(psId, comment.path(), comment.line()); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(t); } else { com.google.gerrit.client.Gerrit.display(t); } }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.restore(id.get(), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); hide(); } }); }
@java.lang.Override protected void onOpenRow(final int row) { final com.google.gerrit.client.info.ChangeInfo c = getRowItem(row); final com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); }
@com.google.gwt.uibinder.client.UiHandler("done") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(getCommentManager().host.getToken()); } else if ((replyBox) == null) { done.setEnabled(false); com.google.gerrit.client.changes.CommentInfo input = com.google.gerrit.client.changes.CommentInfo.createReply(comment); input.message(PatchUtil.C.cannedReplyDone()); com.google.gerrit.client.changes.CommentApi.createDraft(psId, input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); getCommentManager().addDraftBox(displaySide, result); } }); } else { openReplyBox(); setOpen(false); } }
private java.lang.String getInlineCommentName(com.google.gerrit.client.changes.CommentInfo comment) { if ((psId) == null) { return null; } java.lang.String result = "patchComment-"; if ((comment.id()) != null) { result = ("patchCommentEdit-" + (comment.id())) + "-"; } else if ((comment.inReplyTo()) != null) { result = ("patchReply-" + (comment.inReplyTo())) + "-"; } result += (((((((changeId) + "-") + (psId.getId())) + "-") + (com.google.gerrit.client.change.LocalComments.btoa(comment.path()))) + "-") + (comment.side())) + "-"; if (comment.hasRange()) { result += (((((("R" + (comment.range().startLine())) + ",") + (comment.range().startCharacter())) + "-") + (comment.range().endLine())) + ",") + (comment.range().endCharacter()); } else { result += comment.line(); } return result; }
public static void saveInlineComments() { final com.google.gerrit.client.change.LocalComments.StorageBackend storage = new com.google.gerrit.client.change.LocalComments.StorageBackend(); for (final java.lang.String cookie : storage.getKeys()) { if (com.google.gerrit.client.change.LocalComments.isInlineComment(cookie)) { com.google.gerrit.client.change.LocalComments.InlineComment input = com.google.gerrit.client.change.LocalComments.getInlineComment(cookie); if ((input.commentInfo.id()) == null) { com.google.gerrit.client.changes.CommentApi.createDraft(input.psId, input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } }); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(input.psId, input.commentInfo.id(), input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { storage.removeItem(cookie); } else { super.onFailure(caught); } } }); } } } }
public static java.lang.String toChange(com.google.gerrit.reviewdb.client.Change.Id c, java.lang.String p) { return (("/c/" + c) + "/") + p; }
private java.lang.String url(com.google.gerrit.client.info.ChangeInfo.RevisionInfo r) { return com.google.gerrit.common.PageLinks.toChange(changeId, r.id()); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { super.onFailure(err); } }
static void call(final com.google.gwt.user.client.ui.Button b, final java.lang.String project) { b.setEnabled(false); new com.google.gerrit.client.ui.CreateChangeDialog(new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(AdminConstants.I.buttonCreate()); message.setText(AdminConstants.I.buttonCreateDescription()); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private com.google.gwtexpui.globalkey.client.KeyCommand setupNav(com.google.gerrit.client.ui.InlineHyperlink link, char key, java.lang.String help, com.google.gerrit.client.info.FileInfo info) { if (info != null) { final java.lang.String url = url(info); link.setTargetHistoryToken(url); link.setTitle(PatchUtil.M.fileNameWithShortcutKey(com.google.gerrit.client.info.FileInfo.getFileName(info.path()), java.lang.Character.toString(key))); com.google.gwtexpui.globalkey.client.KeyCommand k = new com.google.gwtexpui.globalkey.client.KeyCommand(0, key, help) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(url); } }; keys.add(k); if (link == (prev)) { hasPrev = true; } else { hasNext = true; } return k; } link.getElement().getStyle().setVisibility(Visibility.HIDDEN); keys.add(new com.google.gerrit.client.diff.UpToChangeCommand(patchSetId, 0, key)); return null; }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(final com.google.gerrit.reviewdb.client.Change.Id id, final com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.change.ChangeActions.setEnabled(false, draftButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { super.onFailure(err); } } }; }
static void delete(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteRevision(id.get(), revision, com.google.gerrit.client.change.ChangeActions.cs(id, draftButtons)); }
static void unmarkPrivate(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.unmarkPrivate(id.get(), com.google.gerrit.client.change.ChangeActions.cs(id, draftButtons)); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); }
public static void restore(int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, "restore").post(input, cb); }
static void publish(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.publish(id.get(), revision, com.google.gerrit.client.change.ChangeActions.cs(id, draftButtons)); }
static void markPrivate(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.markPrivate(id.get(), com.google.gerrit.client.change.ChangeActions.cs(id, draftButtons)); }
void onRename() { if ((popup) != null) { popup.hide(); return; } if ((renameBox) == null) { renameBox = new com.google.gerrit.client.change.RenameFileBox(changeId, revision); } renameBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(renameButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(renameBox); p.showRelativeTo(renameButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); renameBox.setFocus(true); popup = p; }
public void onEdit() { if ((popup) != null) { popup.hide(); return; } files.unregisterKeys(); if ((addBox) == null) { addBox = new com.google.gerrit.client.change.AddFileBox(changeId, revision, files); } addBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(addButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(addBox); p.showRelativeTo(addButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); addBox.setFocus(true); popup = p; }
private void doSearch() { final java.lang.String query = searchBox.getText().trim(); if ("".equals(query)) { return; } searchBox.setFocus(false); if (((dropdown) != null) && (dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc()))) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toDocumentationQuery(query)); } else { if (query.matches("^[1-9][0-9]*$")) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(Change.Id.parse(query))); } else { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeQuery(query), com.google.gerrit.client.changes.QueryScreen.forQuery(query)); } } }
@java.lang.Override protected void onLoad() { commentsPanel.setVisible(false); post.setEnabled(false); if (lc.hasReplyComment()) { message.setText(lc.getReplyComment()); lc.removeReplyComment(); } com.google.gerrit.client.changes.ChangeApi.drafts(psId.getParentKey().get()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { displayComments(result); post.setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { post.setEnabled(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { java.lang.String t = message.getText(); if (t != null) { message.setCursorPos(t.length()); } return false; } }, 0); }
private static com.google.gerrit.client.rpc.RestApi call(int id, java.lang.String action) { return com.google.gerrit.client.changes.ChangeApi.change(id).view(action); }
private void displayComments(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> m) { comments.clear(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> l = m.get(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.COMMIT_MSG, l))); } l = m.get(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.MERGE_LIST, l))); } java.util.List<java.lang.String> paths = new java.util.ArrayList(m.keySet()); java.util.Collections.sort(paths); for (java.lang.String path : paths) { if (!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, path, com.google.gerrit.client.change.ReplyBox.copyPath(path, m.get(path)))); } } commentsPanel.setVisible(((comments.getWidgetCount()) > 0)); }

@com.google.gwt.uibinder.client.UiHandler({ "discard1", "discard2" }) void onDiscard(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (isNew()) { removeUI(); restoreSelection(); } else { setEdit(false); pendingGroup = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.changes.CommentApi.deleteDraft(psId, comment.id(), pendingGroup.addFinal(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { pendingGroup = null; removeUI(); } })); } }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(id.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static java.lang.String toEditScreen(com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, int line) { return com.google.gerrit.client.Dispatcher.toPatch("edit", com.google.gerrit.client.DiffObject.base(), revision, fileName, null, line); }
static void call(final com.google.gwt.user.client.ui.Button b, final java.lang.String project, final java.lang.String branch, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, final boolean enabled) { b.setEnabled(false); new com.google.gerrit.client.ui.RebaseDialog(project, branch, id, enabled) { @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(id.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override protected void onRequestSuggestions(final com.google.gerrit.client.change.Request req, final com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision.name()).view("files"); if ((req.getQuery()) != null) { api.addParameter("q", ((req.getQuery()) == null ? "" : req.getQuery())); } api.background().get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { java.util.List<com.google.gerrit.client.change.Suggestion> r = new java.util.ArrayList<>(); for (java.lang.String path : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.PathSuggestOracle.PathSuggestion(path)); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { java.util.List<com.google.gerrit.client.change.Suggestion> none = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(none)); } }); }
public static void unmarkPrivate(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id).view("private.delete").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.PatchSet.Id ps, com.google.gerrit.client.changes.CommentInfo info) { return com.google.gerrit.client.Dispatcher.toPatch(null, ps, info.path()); }
@java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); }
@com.google.gwt.uibinder.client.UiHandler("deleteRevision") void onDeleteRevision(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteDraftRevision())) { com.google.gerrit.client.change.ChangeActions.delete(changeId, revision, publish, deleteRevision); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { if (((replyAction) != null) && (replyAction.isVisible())) { replyAction.quickApprove(input); } else { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision).view("review").post(input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); }
private void postReview() { in.message(message.getText().trim()); in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS); in.prePost(); com.google.gerrit.client.changes.ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotSignedIn(caught)) { lc.setReplyComment(message.getText()); } super.onFailure(caught); } }); hide(); }
public static com.google.gerrit.client.rpc.RestApi reviewer(int id, int reviewer) { return ChangeApi.change(id).view("reviewers").id(reviewer); }
public static void markPrivate(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id).view("private").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
public static com.google.gerrit.client.rpc.RestApi actions(int id, java.lang.String revision) { if ((revision == null) || (revision.equals(""))) { revision = "current"; } return com.google.gerrit.client.changes.ChangeApi.call(id, revision, "actions"); }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, final java.lang.String commitSubject) { b.setEnabled(false); new com.google.gerrit.client.ui.TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) { { sendButton.setText(Util.C.buttonRevertChangeSend()); message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
private com.google.gerrit.client.rpc.RestApi reviewed() { return com.google.gerrit.client.changes.ChangeApi.revision(patchSetId).view("files").id(path).view("reviewed"); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return (diffScreenType) == (com.google.gerrit.extensions.client.GeneralPreferencesInfo.DiffView.UNIFIED_DIFF) ? com.google.gerrit.client.Dispatcher.toUnified(base, patchSetId, info.path()) : com.google.gerrit.client.Dispatcher.toSideBySide(base, patchSetId, info.path()); }
@java.lang.Override protected void onLoad() { com.google.gerrit.client.diff.DiffApi.list(patchSetId, base.asPatchSetId(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); fileNumber.setInnerText(java.lang.Integer.toString(((com.google.gerrit.client.rpc.Natives.asList(files).indexOf(result.get(path))) + 1))); fileCount.setInnerText(java.lang.Integer.toString(files.length())); } }); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { boolean b = com.google.gerrit.client.rpc.Natives.asList(result).contains(path); reviewed.setValue(b, false); if ((!b) && ((reviewedState) == (com.google.gerrit.client.diff.Header.ReviewedState.AUTO_REVIEW))) { postAutoReviewed(); } reviewedState = com.google.gerrit.client.diff.Header.ReviewedState.LOADED; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private static void onRemoveReviewer(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); if (user != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.reviewer(changeId.get(), user).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } } }); } }
private static void onRemoveVote(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); java.lang.String vote = com.google.gerrit.client.change.Labels.getVoteId(event); if ((user != null) && (vote != null)) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.vote(changeId.get(), user, vote).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } } }); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } }
@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String query = com.google.common.base.CharMatcher.is('/').trimTrailingFrom(req.getPathInfo()); java.util.List<com.google.gerrit.extensions.common.ChangeInfo> results; try { results = changes.query(query).withLimit(2).get(); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { com.google.gerrit.httpd.DirectChangeByCommit.log.warn(("Cannot process query by URL: /r/" + query), e); results = com.google.common.collect.ImmutableList.of(); } java.lang.String token; if ((results.size()) == 1) { token = com.google.gerrit.common.PageLinks.toChange(new com.google.gerrit.reviewdb.client.Change.Id(results.iterator().next()._number)); } else { token = com.google.gerrit.common.PageLinks.toChangeQuery(query); } com.google.gerrit.httpd.UrlModule.toGerrit(token, req, rsp); }
public static com.google.gerrit.client.rpc.RestApi reviewers(int id) { return com.google.gerrit.client.changes.ChangeApi.change(id).view("reviewers"); }
private static com.google.gerrit.client.rpc.RestApi call(int id, java.lang.String commit, java.lang.String action) { return ChangeApi.change(id).view("revisions").id(commit).view(action); }
public static void setAssignee(int id, java.lang.String user, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.AssigneeInput input = com.google.gerrit.client.changes.ChangeApi.AssigneeInput.create(); input.assignee(user); com.google.gerrit.client.changes.ChangeApi.change(id).view("assignee").put(input, cb); }
public static void edit(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id).get(cb); }
@java.lang.Override protected com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList> loadCallback() { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeList>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { display(result); com.google.gerrit.client.changes.QueryScreen.this.display(); } } } }; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } else { display(result); this.display(); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } else { displayReadOnly(access); } }
public static void submit(int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.SubmitInfo> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(id, commit, "submit").post(in, cb); }
public static void deleteRevision(int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.revision(id, commit).delete(cb); }
public static com.google.gerrit.client.rpc.RestApi reviewer(int id, java.lang.String reviewer) { return ChangeApi.change(id).view("reviewers").id(reviewer); }
public static void commitWithLinks(int changeId, java.lang.String revision, com.google.gerrit.client.rpc.CallbackGroup.Callback<com.google.gerrit.client.info.ChangeInfo.CommitInfo> callback) { com.google.gerrit.client.changes.ChangeApi.revision(changeId, revision).view("commit").addParameterTrue("links").get(callback); }
@com.google.gwt.uibinder.client.UiHandler("publish") void onPublish(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.publish(changeId, revision, publish, deleteRevision); }
public static void deleteEdit(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id).delete(cb); }
public static void revert(int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, "revert").post(input, cb); }
public static com.google.gerrit.client.rpc.RestApi drafts(int id) { return com.google.gerrit.client.changes.ChangeApi.call(id, "drafts"); }
@com.google.gwt.uibinder.client.UiHandler("review") void onReview(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gerrit.common.data.ProjectAccess access = driver.flush(); if (driver.hasErrors()) { com.google.gwt.user.client.Window.alert(AdminConstants.I.errorsMustBeFixed()); return; } java.lang.String message = commitMessage.getText().trim(); if ("".equals(message)) { message = null; } enable(false); Util.PROJECT_SVC.reviewProjectAccess(getProjectKey(), access.getRevision(), message, access.getLocal(), access.getInheritsFrom(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } else { displayReadOnly(access); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { error.clear(); enable(true); super.onFailure(caught); } }); }
public static void deleteAssignee(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.change(id).view("assignee").delete(cb); }
public static void rebaseEdit(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(id).view("edit:rebase").post(in, cb); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.abandon(id.get(), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); hide(); } }); }
void updateReviewerList() { com.google.gerrit.client.changes.ChangeApi.detail(changeId.get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { display(result); } }); }
public static com.google.gerrit.client.rpc.RestApi blame(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, boolean base) { return ChangeApi.revision(id).view("files").id(path).view("blame").addParameter("base", base); }
private void initRevisionsAction(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision, com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actions) { int currentPatchSet; if (((info.currentRevision()) != null) && (info.revisions().containsKey(info.currentRevision()))) { currentPatchSet = info.revision(info.currentRevision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.info.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } java.lang.String currentlyViewedPatchSet; boolean isPatchSetCurrent = true; java.lang.String revisionId = info.revision(revision).id(); if (revisionId.equals("edit")) { currentlyViewedPatchSet = Resources.M.editPatchSet(com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParent(info.revisions().values())); currentPatchSet = (info.revisions().values().length()) - 1; } else { currentlyViewedPatchSet = revisionId; if (!(currentlyViewedPatchSet.equals(java.lang.Integer.toString(currentPatchSet)))) { isPatchSetCurrent = false; } } patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); updatePatchSetsTextStyle(isPatchSetCurrent); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets); com.google.gerrit.client.info.ChangeInfo.RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { if (actions.containsKey("publish")) { publish.setVisible(true); publish.setTitle(actions.get("publish").title()); } if (actions.containsKey("/")) { deleteRevision.setVisible(true); deleteRevision.setTitle(actions.get("/").title()); } } }
public static java.lang.String toPatch(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { return com.google.gerrit.client.Dispatcher.toPatch("", diffBase, revision, fileName, side, line); }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(id, line)); }
private void initIncludedInAction(com.google.gerrit.client.info.ChangeInfo info) { if ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { includedInAction = new com.google.gerrit.client.change.IncludedInAction(info.legacyId(), style, headerLine, includedIn); includedIn.setVisible(true); } }
public static java.lang.String toPatch(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("", diffBase, revision, fileName, null, 0); }
public static java.lang.String toUnified(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("unified", diffBase, revision, fileName, null, 0); }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(this, base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
private static java.lang.String toPatch(java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(); p.append("/c/").append(c).append("/"); if ((diffBase != null) && ((diffBase.asString()) != null)) { p.append(diffBase.asString()).append(".."); } p.append(revision.getId()).append("/").append(com.google.gwtorm.client.KeyUtil.encode(fileName)); if (((type != null) && (!(type.isEmpty()))) && ((!("sidebyside".equals(type))) || (com.google.gerrit.client.Dispatcher.preferUnified()))) { p.append(",").append(type); } if ((side == (com.google.gerrit.client.diff.DisplaySide.A)) && (line > 0)) { p.append("@a").append(line); } else if (line > 0) { p.append("@").append(line); } return p.toString(); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(change.legacyId().get()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.ChangeGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.changes.ChangeApi.includedIn(changeId.get(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.IncludedInInfo r) { branches.setInnerSafeHtml(formatList(r.branches())); tags.setInnerSafeHtml(formatList(r.tags())); for (java.lang.String n : r.externalNames()) { com.google.gwt.core.client.JsArrayString external = r.external(n); if ((external.length()) > 0) { appendRow(n, external); } } loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private void renderLinksToDiff() { com.google.gerrit.client.ui.InlineHyperlink sbs = new com.google.gerrit.client.ui.InlineHyperlink(); sbs.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); sbs.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch("sidebyside", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path))); sbs.setTitle(PatchUtil.C.sideBySideDiff()); linkPanel.add(sbs); com.google.gerrit.client.ui.InlineHyperlink unified = new com.google.gerrit.client.ui.InlineHyperlink(); unified.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); unified.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch("unified", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path))); unified.setTitle(PatchUtil.C.unifiedDiff()); linkPanel.add(unified); }
@com.google.gwt.uibinder.client.UiHandler("abandon") void onAbandon(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((abandonAction) == null) { abandonAction = new com.google.gerrit.client.change.AbandonAction(abandon, changeId); } abandonAction.show(); }
private java.lang.Runnable save() { return () -> { if (!(cmEdit.isClean(generation))) { close.setEnabled(false); java.lang.String text = cmEdit.getValue(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String trimmed = (text.trim()) + "\r"; if (!(trimmed.equals(text))) { text = trimmed; cmEdit.setValue(text); } } final int g = cmEdit.changeGeneration(false); com.google.gerrit.client.changes.ChangeEditApi.put(revision.getParentKey().get(), path, text, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { generation = g; setClean(cmEdit.isClean(g)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { close.setEnabled(true); } }); } }; }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); }
static void delete(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteChange(id.get(), com.google.gerrit.client.change.ChangeActions.mine(draftButtons)); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); }
@com.google.gwt.uibinder.client.UiHandler("followUp") void onFollowUp(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((followUpAction) == null) { followUpAction = new com.google.gerrit.client.change.FollowUpAction(followUp, project, branch, topic, key); } followUpAction.show(); }
@com.google.gwt.uibinder.client.UiHandler("showBase") void onShowBase(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> e) { boolean shouldShow = e.getValue(); if (shouldShow) { if ((baseContent) == null) { com.google.gerrit.client.changes.ChangeEditApi.get(revision, path, true, new com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> fc) { baseContent = fc; displayBase(); } @java.lang.Override public void onFailure(java.lang.Throwable e) { } }); } else { displayBase(); } } else { cmBase.getWrapperElement().getParentElement().addClassName(style.hideBase()); cmEdit.getWrapperElement().getParentElement().addClassName(style.fullWidth()); mv.getGapElement().addClassName(style.hideBase()); } mv.setShowDifferences(shouldShow); }
public static void publishEdit(int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(id).view("edit:publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi edit(int id) { return com.google.gerrit.client.changes.ChangeApi.change(id).view("edit"); }
public static void list(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.reviewdb.client.PatchSet.Id base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(id).view("files"); if (base != null) { if ((base.get()) < 0) { api.addParameter("parent", (-(base.get()))); } else { api.addParameter("base", base.get()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static void abandon(int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, "abandon").post(input, cb); }
void loadRevisionInfo() { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.actions(changeId.get(), revision); call.background(); call.get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actionMap) { actionMap.copyKeysIntoChildren("id"); renderRevisionInfo(changeInfo, actionMap); } }); }
private void initEditMode(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); if (info.status().isOpen()) { if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); deleteFile.setVisible((!(editMode.isVisible()))); renameFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); addFileAction = new com.google.gerrit.client.change.AddFileAction(changeId, info.revision(revision), style, addFile, files); deleteFileAction = new com.google.gerrit.client.change.DeleteFileAction(changeId, info.revision(revision), style, addFile); renameFileAction = new com.google.gerrit.client.change.RenameFileAction(changeId, info.revision(revision), style, addFile); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } if (rev.isEdit()) { if (info.hasEditBasedOnCurrentPatchSet()) { publishEdit.setVisible(true); } else { rebaseEdit.setVisible(true); } deleteEdit.setVisible(true); } } else if (rev.isEdit()) { deleteEdit.setStyleName(style.highlight()); deleteEdit.setVisible(true); } } }
public static com.google.gerrit.client.rpc.RestApi revision(com.google.gerrit.reviewdb.client.PatchSet.Id id) { int cn = id.getParentKey().get(); java.lang.String revision = com.google.gerrit.client.changes.RevisionInfoCache.get(id); if (revision != null) { return ChangeApi.revision(cn, revision); } return ChangeApi.change(cn).view("revisions").id(id.get()); }
void set(com.google.gerrit.client.info.ChangeInfo info) { this.changeId = info.legacyId(); display(info); reviewerSuggestOracle.setChange(changeId); addReviewerIcon.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); }
@com.google.gwt.uibinder.client.UiHandler("restore") void onRestore(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((restoreAction) == null) { restoreAction = new com.google.gerrit.client.change.RestoreAction(restore, changeId); } restoreAction.show(); }
public static com.google.gerrit.client.rpc.RestApi change(int id) { return new com.google.gerrit.client.rpc.RestApi("/changes/").id(java.lang.String.valueOf(id)); }
private static void patch(java.lang.String token, com.google.gerrit.client.DiffObject base, com.google.gerrit.reviewdb.client.Patch.Key id, com.google.gerrit.client.diff.DisplaySide side, int line, java.lang.String panelType) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = (0 <= c) ? token.substring((c + 1)) : ""; } if (("".equals(panel)) || ("cm".equals(panel))) { if (com.google.gerrit.client.Dispatcher.preferUnified()) { com.google.gerrit.client.Dispatcher.unified(token, base, id, side, line); } else { com.google.gerrit.client.Dispatcher.codemirror(token, base, id, side, line); } } else if ("sidebyside".equals(panel)) { com.google.gerrit.client.Dispatcher.codemirror(token, base, id, side, line); } else if ("unified".equals(panel)) { com.google.gerrit.client.Dispatcher.unified(token, base, id, side, line); } else if ("edit".equals(panel)) { if ((!(com.google.gerrit.reviewdb.client.Patch.isMagic(id.get()))) || (Patch.COMMIT_MSG.equals(id.get()))) { com.google.gerrit.client.Dispatcher.codemirrorForEdit(token, id, line); } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } }
private static void unified(final java.lang.String token, final com.google.gerrit.client.DiffObject base, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); } }); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadComments(final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); com.google.gerrit.client.changes.ChangeApi.comments(changeId.get()).get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(com.google.gerrit.client.change.ChangeScreen.filterForRevision(result, rev._number())); history.addComments(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); return r; }
void load(com.google.gerrit.client.rpc.CallbackGroup group) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.comments(base.asPatchSetId(), group.add(publishedBase())); } com.google.gerrit.client.changes.CommentApi.comments(revision, group.add(publishedRevision())); if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.drafts(base.asPatchSetId(), group.add(draftsBase())); } com.google.gerrit.client.changes.CommentApi.drafts(revision, group.add(draftsRevision())); } }
static void call(final com.google.gwt.user.client.ui.Button b, final java.lang.String project) { b.setEnabled(false); com.google.gerrit.client.changes.ChangeApi.createChange(project, RefNames.REFS_CONFIG, null, AdminConstants.I.editConfigMessage(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), "project.config")); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); super.onFailure(caught); } }); }
public static void message(int id, java.lang.String commit, java.lang.String message, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.CherryPickInput input = com.google.gerrit.client.changes.ChangeApi.CherryPickInput.create(); input.setMessage(message); com.google.gerrit.client.changes.ChangeApi.call(id, commit, "message").post(input, cb); }
@java.lang.Override protected void onRequestSuggestions(final com.google.gerrit.client.change.Request req, final com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.changes.ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit(), false).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo> result) { java.util.List<com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion> r = new java.util.ArrayList(result.length()); for (com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo reviewer : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion(reviewer, req.getQuery())); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { java.util.List<com.google.gerrit.client.change.Suggestion> r = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), "project.config")); }
public static void topic(int id, java.lang.String topic, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.call(id, "topic"); topic = com.google.gerrit.client.changes.ChangeApi.emptyToNull(topic); if (topic != null) { com.google.gerrit.client.changes.ChangeApi.TopicInput input = com.google.gerrit.client.changes.ChangeApi.TopicInput.create(); input.topic(topic); call.put(input, com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } else { call.delete(com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } }
public static void rebase(int id, java.lang.String commit, java.lang.String base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.RebaseInput rebaseInput = com.google.gerrit.client.changes.ChangeApi.RebaseInput.create(); rebaseInput.setBase(base); com.google.gerrit.client.changes.ChangeApi.call(id, commit, "rebase").post(rebaseInput, cb); }
public static com.google.gerrit.client.rpc.RestApi hashtags(int changeId) { return com.google.gerrit.client.changes.ChangeApi.change(changeId).view("hashtags"); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeApi.topic(psId.getParentKey().get(), input.getValue().trim(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } }); onCancel(null); }
void onReply(com.google.gerrit.client.info.ChangeInfo.MessageInfo msg) { if ((popup) != null) { popup.hide(); return; } if ((replyBox) == null) { replyBox = new com.google.gerrit.client.change.ReplyBox(clp, psId, revision, allLabels, permittedLabels); allLabels = null; permittedLabels = null; } if (msg != null) { replyBox.replyTo(msg); } final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true, false); p.setStyleName(style.replyBox()); p.addAutoHidePartner(replyButton.getElement()); p.addAutoHidePartner(quickApproveButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; if ((hasDraftComments) || (replyBox.hasMessage())) { replyButton.setStyleName(style.highlight()); } } } }); p.add(replyBox); com.google.gwt.user.client.Window.scrollTo(0, 0); replyButton.removeStyleName(style.highlight()); p.showRelativeTo(replyButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); popup = p; }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revision, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(change.legacyId().get(), revision.name()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.RevisionGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(revision); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); }
public static com.google.gerrit.client.diff.DiffApi diff(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path) { return new com.google.gerrit.client.diff.DiffApi(com.google.gerrit.client.changes.ChangeApi.revision(id).view("files").id(path).view("diff")); }
public static com.google.gerrit.client.rpc.RestApi detail(int id) { return com.google.gerrit.client.changes.ChangeApi.call(id, "detail"); }
public static void publish(int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(id, commit, "publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi comments(int id) { return com.google.gerrit.client.changes.ChangeApi.call(id, "comments"); }
private void loadFileList(final com.google.gerrit.client.DiffObject base, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, final java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts) { com.google.gerrit.client.diff.DiffApi.list(changeId.get(), rev.name(), baseRev, group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { files.showError(caught); } })); }
public void setChange(com.google.gerrit.reviewdb.client.Change.Id changeId) { this.changeId = changeId; }
@com.google.gwt.uibinder.client.UiHandler("unmarkPrivate") void onUnmarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.unmarkPrivate(changeId, unmarkPrivate); }
@com.google.gwt.uibinder.client.UiHandler("deleteChange") void onDeleteChange(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChange())) { com.google.gerrit.client.change.ChangeActions.delete(changeId, deleteChange); } }
@com.google.gwt.uibinder.client.UiHandler("markPrivate") void onMarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.markPrivate(changeId, markPrivate); }
public static void list(int id, java.lang.String revision, com.google.gerrit.client.info.ChangeInfo.RevisionInfo base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(id, revision).view("files"); if (base != null) { if ((base._number()) < 0) { api.addParameter("parent", (-(base._number()))); } else { api.addParameter("base", base.name()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSuccess(final com.google.gerrit.client.info.ChangeInfo info) { info.init(); initCurrentRevision(info); final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { if ((base.isBase()) && (rev.isMerge())) { base = com.google.gerrit.client.DiffObject.parse(info.legacyId(), com.google.gerrit.client.Gerrit.getUserPreferences().defaultBaseForMerges().getBase()); } loadConfigInfo(info, base); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> mAr = info.messages(); for (int i = 0; i < (mAr.length()); i++) { if ((mAr.get(i).tag()) != null) { hideTaggedComments.setVisible(true); break; } } } }); group.done(); }
public static java.lang.String toPatch(java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.Patch.Key id) { return com.google.gerrit.client.Dispatcher.toPatch(type, diffBase, id.getParentKey(), id.get(), null, 0); }
private static void codemirrorForEdit(final java.lang.String token, final com.google.gerrit.reviewdb.client.Patch.Key id, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(id, line)); } }); }
public static com.google.gerrit.client.rpc.RestApi editWithCommands(int id) { return com.google.gerrit.client.changes.ChangeApi.edit(id).addParameterTrue("download-commands"); }
private void upToChange() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey())); }
private boolean handlePolyGerritParam(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { if (!(options.enableGwtUi())) { return false; } boolean redirect = false; java.lang.String param = req.getParameter("polygerrit"); if ("1".equals(param)) { setPolyGerritCookie(req, res, UiType.POLYGERRIT); redirect = true; } else if ("0".equals(param)) { setPolyGerritCookie(req, res, UiType.GWT); redirect = true; } if (redirect) { res.sendRedirect(req.getRequestURL().toString()); } return redirect; }
void addFile(java.lang.String dirPath, java.lang.String filePath, java.lang.String[] lines) { com.googlesource.gerrit.plugins.findowners.Parser.Result result = com.googlesource.gerrit.plugins.findowners.Parser.parseFile(dirPath, filePath, lines); if (result.stopLooking) { stopLooking.add(dirPath); } for (java.lang.String owner : result.owner2paths.keySet()) { for (java.lang.String path : result.owner2paths.get(owner)) { addOwnerPathPair(owner, path); } } if (com.googlesource.gerrit.plugins.findowners.Config.getReportSyntaxError()) { result.warnings.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.warn(w)); result.errors.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error(w)); } }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { return get(repo, changeData, changeData.currentPatchSet().getId().get()); }
@java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(key, repository, project, branch, files); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.query.change.ChangeData changeData, int patchset) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change().getProject(); java.lang.String branch = changeData.change().getDest().get(); java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey(changeData.getId().get(), patchset, branch); return get(dbKey, repository, project, branch, changeData.currentFilePaths()); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(java.lang.String key, org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch, java.util.Collection<java.lang.String> files) { if ((dbCache) == null) { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(key, repository, project, branch, files); } try { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(((((("Get from cash " + (dbCache)) + ", key=") + key) + ", cache size=") + (dbCache.size()))); return dbCache.get(key, new java.util.concurrent.Callable<com.googlesource.gerrit.plugins.findowners.OwnersDb>() { @java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(key, repository, project, branch, files); } }); } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.findowners.Cache.log.error(("Cache.get has exception: " + e)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(key, repository, project, branch, files); } }
@org.junit.Test public void actionApplyTest() throws java.lang.Exception { com.googlesource.gerrit.plugins.findowners.Cache cache = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().init(0, 10); assertThat(cache.size()).isEqualTo(0); com.google.gerrit.extensions.common.ChangeInfo changeInfo = newChangeInfo("test Action.apply"); com.google.gerrit.server.change.ChangeResource cr = parseChangeResource(changeInfo.changeId); com.googlesource.gerrit.plugins.findowners.Action.Parameters param = new com.googlesource.gerrit.plugins.findowners.Action.Parameters(); com.googlesource.gerrit.plugins.findowners.Action action = new com.googlesource.gerrit.plugins.findowners.Action("find-owners", null, null, null, changeDataFactory, accountCache, repoManager); com.google.gerrit.extensions.restapi.Response<com.googlesource.gerrit.plugins.findowners.RestResult> response = action.apply(db, cr, param); com.googlesource.gerrit.plugins.findowners.RestResult result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, false); param.debug = true; response = action.apply(db, cr, param); result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, true); assertThat(result.dbgmsgs.user).isEqualTo("?"); assertThat(result.dbgmsgs.project).isEqualTo(changeInfo.project); assertThat(result.dbgmsgs.branch).contains(changeInfo.branch); assertThat(result.dbgmsgs.path2owners).isEmpty(); assertThat(result.dbgmsgs.owner2paths).isEmpty(); assertThat(result.file2owners).isEmpty(); assertThat(result.reviewers).isEmpty(); assertThat(result.owners).isEmpty(); assertThat(result.files).isEmpty(); assertThat(cache.size()).isEqualTo(0); }
int findApproval(com.google.gerrit.server.account.AccountCache accountCache) throws com.google.gwtorm.server.OrmException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExemptFromOwnerApproval(changeData)) { return 0; } com.googlesource.gerrit.plugins.findowners.OwnersDb db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(repository, changeData); if ((db.getNumOwners()) <= 0) { return 0; } if ((minVoteLevel) <= 0) { minVoteLevel = com.googlesource.gerrit.plugins.findowners.Config.getMinOwnerVoteLevel(changeData); } com.googlesource.gerrit.plugins.findowners.Checker.log.trace(("findApproval db key = " + (db.key))); return findApproval(accountCache, db); }
public static int findApproval(com.googlecode.prolog_cafe.lang.Prolog engine, int minVoteLevel) { try { com.google.gerrit.server.account.AccountCache accountCache = StoredValues.ACCOUNT_CACHE.get(engine); com.google.gerrit.server.query.change.ChangeData changeData = StoredValues.CHANGE_DATA.get(engine); org.eclipse.jgit.lib.Repository repository = StoredValues.REPOSITORY.get(engine); return new com.googlesource.gerrit.plugins.findowners.Checker(repository, changeData, minVoteLevel).findApproval(accountCache); } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.findowners.Checker.log.error("Exception", e); return 0; } }







private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(tip.copy(), id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, ((assignee) != null ? assignee.orElse(null) : null), status, com.google.common.collect.Sets.newLinkedHashSet(com.google.common.collect.Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), com.google.gerrit.server.ReviewerByEmailSet.fromTable(com.google.common.collect.Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted); }
@org.junit.Test public void revert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit(); ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get(); java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> sourceMessages = new java.util.ArrayList(gApi.changes().id(r.getChangeId()).get().messages); assertThat(sourceMessages).hasSize(4); java.lang.String expectedMessage = java.lang.String.format("Created a revert of this change as %s", revertChange.changeId); assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage); assertThat(revertChange.messages).hasSize(1); assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1."); }

public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> display(@com.google.gerrit.common.Nullable java.io.PrintWriter stdout) { java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = com.google.common.collect.Lists.newArrayList(pluginLoader.getPlugins(all)); java.util.Collections.sort(plugins, new java.util.Comparator<com.google.gerrit.server.plugins.Plugin>() { @java.lang.Override public int compare(com.google.gerrit.server.plugins.Plugin a, com.google.gerrit.server.plugins.Plugin b) { return a.getName().compareTo(b.getName()); } }); if (!(format.isJson())) { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format("%-30s %-10s %-8s %s\n", p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return output; } else if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }
public com.google.gerrit.server.update.BatchUpdate create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.CurrentUser user, java.sql.Timestamp when) { if (migration.disableChangeReviewDb()) { if (migration.fuseUpdates()) { return fusedNoteDbBatchUpdateFactory.create(db, project, user, when); } return unfusedNoteDbBatchUpdateFactory.create(db, project, user, when); } return reviewDbBatchUpdateFactory.create(db, project, user, when); }
private void setChangeId(int id) { changeId = new com.google.gerrit.reviewdb.client.Change.Id(id); ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate).setWorkInProgress(magicBranch.workInProgress).setValidate(false); if (magicBranch.draft) { ins.setDraft(magicBranch.draft); } else if (magicBranch.merged) { ins.setStatus(Change.Status.MERGED); } cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName()); if ((rp.getPushCertificate()) != null) { ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature()); } }





public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(user, id.substring(0, z), n.intValue()); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeControls(query.byBranchKey(t.branch(), t.id()), user); } } java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id, 10); if (n != null) { return asChangeControls(query.byLegacyChangeId(new com.google.gerrit.reviewdb.client.Change.Id(n)), user); } return asChangeControls(query.byKeyPrefix(id), user); }
boolean isMergedIntoVisibleRef(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Collection<org.eclipse.jgit.lib.Ref> unfilteredRefs) throws java.io.IOException { com.google.gerrit.server.git.VisibleRefFilter filter = refFilter.create(state, repo); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> m = com.google.common.collect.Maps.newHashMapWithExpectedSize(unfilteredRefs.size()); for (org.eclipse.jgit.lib.Ref r : unfilteredRefs) { m.put(r.getName(), r); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = filter.filter(m, true); return (!(refs.isEmpty())) && (com.google.gerrit.server.change.IncludedInResolver.includedInOne(repo, rw, commit, refs.values())); }
public com.google.gerrit.common.EventListener getEventListener() { }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.accounts.AccountInput input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply((input != null ? input : new com.google.gerrit.extensions.api.accounts.AccountInput())); }

private boolean isMember(com.google.gerrit.reviewdb.client.AccountGroup parent, com.google.gerrit.common.data.GroupDescription.Basic member) throws com.google.gwtorm.server.OrmException { return (dbProvider.get().accountGroupById().get(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parent.getId(), member.getGroupUUID()))) != null; }

public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupById> getIncludes() { return includes; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutOwner.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((resource.toAccountGroup()) == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("owner is required"); } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> updatedGroup = groupsUpdateProvider.get().updateGroup(db.get(), resource.getGroupUUID(), ( group) -> group.setOwnerGroupUUID(owner.getGroupUUID())); if (!(updatedGroup.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return json.format(owner); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutDescription.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.group.PutDescription.Input(); } if ((resource.toAccountGroup()) == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } java.lang.String newDescription = com.google.common.base.Strings.emptyToNull(input.description); java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> updatedGroup = groupsUpdateProvider.get().updateGroup(db.get(), resource.getGroupUUID(), ( group) -> group.setDescription(newDescription)); if (!(updatedGroup.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return com.google.common.base.Strings.isNullOrEmpty(input.description) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(input.description); }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> getMembers() { return members; }
public java.util.stream.Stream<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getParentGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID childGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> accountGroupByIds = db.accountGroupById().byIncludeUUID(childGroupUuid); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.Id> foundParentGroupIds = com.google.common.collect.Streams.stream(accountGroupByIds).map(AccountGroupById::getGroupId).collect(toImmutableSet()); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> existingParentGroups = db.accountGroups().get(foundParentGroupIds); return com.google.common.collect.Streams.stream(existingParentGroups).map(AccountGroup::getGroupUUID); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.Id> ids = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById agi : db.accountGroupById().byIncludeUUID(key)) { ids.add(agi.getGroupId()); } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupArray = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup g : db.accountGroups().get(ids)) { groupArray.add(g.getGroupUUID()); } return com.google.common.collect.ImmutableList.copyOf(groupArray); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup internalGroup = resource.toAccountGroup(); if (internalGroup == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } input = com.google.gerrit.server.group.AddMembers.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.reviewdb.client.AccountGroupMember> members = getMembers(internalGroup.getId()); final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> toRemove = new java.util.ArrayList<>(); for (java.lang.String nameOrEmail : input.members) { com.google.gerrit.reviewdb.client.Account a = accounts.parse(nameOrEmail).getAccount(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(("Cannot delete member: " + (a.getFullName()))); } final com.google.gerrit.reviewdb.client.AccountGroupMember m = members.remove(a.getId()); if (m != null) { toRemove.add(m); } } writeAudits(toRemove); db.get().accountGroupMembers().delete(toRemove); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : toRemove) { accountCache.evict(m.getAccountId()); } return com.google.gerrit.extensions.restapi.Response.none(); }
private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } args.groups.getMembers(db, ig.getId()).forEachOrdered(matching.accounts::add); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) { if (seen.add(m)) { q.add(m); } } } }


private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } for (com.google.gerrit.reviewdb.client.AccountGroupMember m : db.accountGroupMembers().byGroup(ig.getId())) { matching.accounts.add(m.getAccountId()); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) { if (seen.add(m)) { q.add(m); } } } }


@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> conflicts(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.query.change.ConflictsPredicate(args, value, parseChange(value)); }
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("change %s not found", id.get())); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.StarredChanges.log.error("cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("internal server error"); } }
public void addChange(java.lang.String id, java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeResource> changes, com.google.gerrit.server.project.ProjectControl projectControl, boolean useIndex) throws com.google.gerrit.sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> matched = (useIndex) ? changeFinder.find(id, currentUser) : changeFromNotesFactory(id, currentUser); java.util.List<com.google.gerrit.server.project.ChangeControl> toAdd = new java.util.ArrayList(changes.size()); boolean canMaintainServer; try { permissionBackend.user(currentUser).check(GlobalPermission.MAINTAIN_SERVER); canMaintainServer = true; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { canMaintainServer = false; } for (com.google.gerrit.server.project.ChangeControl ctl : matched) { if (((!(changes.containsKey(ctl.getId()))) && (inProject(projectControl, ctl.getProject()))) && (canMaintainServer || (ctl.isVisible(db)))) { toAdd.add(ctl); } } if (toAdd.isEmpty()) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) + "\" no such change")); } else if ((toAdd.size()) > 1) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) + "\" matches multiple changes")); } com.google.gerrit.server.project.ChangeControl ctl = toAdd.get(0); changes.put(ctl.getId(), changesCollection.parse(ctl)); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } try { com.google.gerrit.reviewdb.client.Change c = cd.change(); if (c == null) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(c); com.google.gerrit.server.project.ChangeControl cc = changeControl.controlFor(notes, user); if (cc.isVisible(db.get(), cd)) { cd.cacheVisibleTo(cc); return true; } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { } return false; }
private boolean canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { if (canUpdate()) { return true; } else if (isMergedIntoBranchOrTag(repo, commit)) { return true; } return false; }

@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id.encoded(), user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(ctl.isVisible(db.get()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(ctl); }

public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id, user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(ctl.isVisible(db.get()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(ctl); }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId extId = findExternalId(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (who.getExternalIdKey().get())) + "' in use by another account")); } externalIdsUpdateFactory.create().delete(extId); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = accounts.get(db, from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); accountsUpdateFactory.create().update(db, a); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (who.getExternalIdKey().get())) + "' not found")); } return new com.google.gerrit.server.account.AuthResult(from, who.getExternalIdKey(), false); } }
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertEmail(byEmailCache.get(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); accountCache.evict(admin.id); assertEmail(byEmailCache.get(email), admin); assertThat(byEmailCache.get(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(byEmailCache.get(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(byEmailCache.get("non-existing@example.com")).isEmpty(); }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId extId = findExternalId(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = accounts.get(db, to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); accountsUpdateFactory.create().update(db, a); } } if ((who.getEmailAddress()) != null) { byEmailCache.evict(who.getEmailAddress()); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); } }
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertEmail(byEmailCache.get(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(byEmailCache.get(email), admin); assertThat(byEmailCache.get(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(byEmailCache.get(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(byEmailCache.get("non-existing@example.com")).isEmpty(); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> oldRefs = rp.getAdvertisedRefs(); if (oldRefs == null) { try { oldRefs = rp.getRepository().getRefDatabase().getRefs(com.google.gerrit.server.git.receive.ALL); } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { throw e; } catch (java.io.IOException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(); ex.initCause(e); throw ex; } } com.google.gerrit.server.git.receive.ReceiveCommitsAdvertiseRefsHook.Result r = advertiseRefs(oldRefs); rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves()); }
private void showDoc(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, com.google.gitiles.GitilesView view, com.google.gitiles.doc.MarkdownConfig cfg, com.google.gitiles.doc.MarkdownToHtml.Builder fmt, com.google.gitiles.doc.DocServlet.MarkdownFile navFile, com.google.gitiles.doc.DocServlet.MarkdownFile srcFile) throws java.io.IOException { java.util.Map<java.lang.String, java.lang.Object> data = new java.util.HashMap<>(); data.putAll(buildNavbar(cfg, fmt, navFile)); org.commonmark.node.Node doc = com.google.gitiles.doc.GitilesMarkdown.parse(cfg, srcFile.consumeContent()); data.put("pageTitle", com.google.gitiles.doc.DocServlet.pageTitle(doc, srcFile)); if ((view.getType()) != (GitilesView.Type.ROOTED_DOC)) { data.put("sourceUrl", com.google.gitiles.GitilesView.show().copyFrom(view).toUrl()); data.put("logUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl()); data.put("blameUrl", com.google.gitiles.GitilesView.blame().copyFrom(view).toUrl()); } if ((cfg.analyticsId) != null) { data.put("analyticsId", cfg.analyticsId); } try (java.io.OutputStream out = startRenderCompressedStreamingHtml(req, res, com.google.gitiles.doc.DocServlet.SOY_TEMPLATE, data)) { java.io.Writer w = newWriter(out, res); fmt.setFilePath(srcFile.path).build().renderToHtml(new com.google.gitiles.doc.html.StreamHtmlBuilder(w), doc); w.flush(); } catch (com.google.gitiles.doc.RuntimeIOException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); throw e; } }

@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { update(c, event.getRefName()); } catch (java.io.IOException | org.eclipse.jgit.api.errors.GitAPIException e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); error("update for %s (ref %s) failed: %s", c.toString(), event.getRefName(), e); } } }

@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Ancient group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.server.schema.Schema_150_to_151_Test.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }

@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.server.schema.Schema_150_to_151_Test.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isAtLeast(testStartTime); }







public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { builder.withStopStrategy(stopStrategy).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); if ((opts.listener()) != null) { builder.withRetryListener(opts.listener()); } } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } }

private java.lang.String getPluginCanonicalWebUrl(java.lang.String name) { java.lang.String url = java.lang.String.format("%s/plugins/%s/", com.google.common.base.CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name); return url; }
static java.lang.String computeCanonicalPath(java.lang.String canonicalURL) throws java.net.URISyntaxException { java.net.URI uri = new java.net.URI(canonicalURL); return uri.getPath().replaceAll("/$", ""); }
public Project.NameKey project() throws com.google.gwtorm.server.OrmException { if ((project) == null) { checkState((!(notesMigration.readChanges())), "should not have created ChangeData without a project when NoteDb is enabled"); project = change().getProject(); } return project; }
private java.util.Optional<com.google.gerrit.server.patch.DiffSummary> getDiffSummary(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.PatchSet ps) { java.lang.Integer psId = ps.getId().get(); if ((diffSummaries) == null) { diffSummaries = new java.util.HashMap(); } java.util.Optional<com.google.gerrit.server.patch.DiffSummary> r = diffSummaries.get(psId); if (r == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } try { r = java.util.Optional.of(patchListCache.getDiffSummary(c, ps)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { r = java.util.Optional.empty(); } diffSummaries.put(psId, r); } return r; }
public java.util.Set<java.lang.String> stars(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { if ((starsOf) != null) { if (!(starsOf.accountId().equals(accountId))) { starsOf = null; } } if ((starsOf) == null) { if ((stars) != null) { starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, stars.get(accountId)); } else { if (!(lazyLoad)) { return com.google.common.collect.ImmutableSet.of(); } starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId)); } } return starsOf.stars(); }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSetApproval> approvals() throws com.google.gwtorm.server.OrmException { if ((allApprovals) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableListMultimap.of(); } allApprovals = approvalsUtil.byChange(db, notes()); } return allApprovals; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, this).getSubmitType(); } return submitTypeRecord; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public static void ensureCurrentPatchSetLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentPatchSet(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentPatchSet) == null) && ((cd.patchSets) == null)) { missing.put(cd.change().currentPatchSetId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.reviewdb.client.PatchSet ps : first.db.patchSets().get(missing.keySet())) { missing.get(ps.getId()).currentPatchSet = ps; } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> patchSets() throws com.google.gwtorm.server.OrmException { if ((patchSets) == null) { patchSets = psUtil.byChange(db, notes()); } return patchSets; }
public static void ensureMessagesLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.messages(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.messages) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.changeMessages().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage> result = results.get(i); if (result != null) { batch.get(i).messages = result.toList(); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.RobotComment> robotComments() throws com.google.gwtorm.server.OrmException { if ((robotComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } robotComments = commentsUtil.robotCommentsByChange(notes()); } return robotComments; }
public java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages() throws com.google.gwtorm.server.OrmException { if ((messages) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } messages = cmUtil.byChange(db, notes()); } return messages; }
public static com.google.gerrit.server.query.change.ChangeData createForTest(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, int currentPatchSetId) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, project, id); cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, currentPatchSetId)); return cd; }
public com.google.gerrit.server.ReviewerSet reviewers() throws com.google.gwtorm.server.OrmException { if ((reviewers) == null) { if (!(lazyLoad)) { return com.google.gerrit.server.ReviewerSet.empty(); } reviewers = approvalsUtil.getReviewers(notes(), approvals().values()); } return reviewers; }
public java.util.List<com.google.gerrit.server.ReviewerStatusUpdate> reviewerUpdates() throws com.google.gwtorm.server.OrmException { if ((reviewerUpdates) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } reviewerUpdates = approvalsUtil.getReviewerUpdates(notes()); } return reviewerUpdates; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> editRefs() throws com.google.gwtorm.server.OrmException { if ((editsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } editsByUser = new java.util.HashMap(); com.google.gerrit.reviewdb.client.Change.Id id = checkNotNull(change.getId()); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).entrySet()) { if (id.equals(Change.Id.fromEditRefPart(e.getKey()))) { editsByUser.put(Account.Id.fromRefPart(e.getKey()), e.getValue()); } } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } return editsByUser; }
private boolean loadCommitData() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return false; } java.lang.String sha1 = ps.getRevision().get(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project());org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); commitFooters = c.getFooterLines(); author = c.getAuthorIdent(); committer = c.getCommitterIdent(); } return true; }
public static void ensureCurrentApprovalsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentApprovals(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.currentApprovals) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.patchSetApprovals().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval> result = results.get(i); if (result != null) { batch.get(i).currentApprovals = com.google.gerrit.server.ApprovalsUtil.sortApprovals(result); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.Comment> publishedComments() throws com.google.gwtorm.server.OrmException { if ((publishedComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } publishedComments = commentsUtil.publishedByChange(db, notes()); } return publishedComments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals() throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else { try { currentApprovals = com.google.common.collect.ImmutableList.copyOf(approvalsUtil.byPatchSet(db, changeControl(), c.currentPatchSetId(), null, null)); } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { currentApprovals = java.util.Collections.emptyList(); } else { throw e; } } } } return currentApprovals; }
public com.google.gerrit.server.notedb.ChangeNotes notes() throws com.google.gwtorm.server.OrmException { if ((notes) == null) { if (!(lazyLoad)) { throw new com.google.gwtorm.server.OrmException("ChangeNotes not available, lazyLoad = false"); } notes = notesFactory.create(db, project(), legacyId); } return notes; }
public com.google.common.collect.ImmutableMap<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.StarredChangesUtil.StarRef> starRefs() throws com.google.gwtorm.server.OrmException { if ((starRefs) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableMap.of(); } starRefs = checkNotNull(starredChangesUtil).byChange(legacyId); } return starRefs; }
public com.google.gerrit.server.project.ChangeControl changeControl(com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if ((changeControl) != null) { com.google.gerrit.server.CurrentUser oldUser = user; if (com.google.gerrit.server.query.change.ChangeData.sameUser(user, oldUser)) { return changeControl; } throw new java.lang.IllegalStateException(("user already specified: " + (changeControl.getUser()))); } try { if ((change) != null) { changeControl = changeControlFactory.controlFor(db, change, user); } else { changeControl = changeControlFactory.controlFor(db, project(), legacyId, user); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } return changeControl; }
public com.google.gerrit.server.project.ChangeControl changeControl() throws com.google.gwtorm.server.OrmException { if ((changeControl) == null) { com.google.gerrit.reviewdb.client.Change c = change(); try { changeControl = changeControlFactory.controlFor(db, c, userFactory.create(c.getOwner())); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } } return changeControl; }
public static void ensureAllPatchSetsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.patchSets(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.patchSets) == null) { results.add(cd.db.patchSets().byChange(cd.getId())); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> result = results.get(i); if (result != null) { batch.get(i).patchSets = result.toList(); } } } }

public com.google.gerrit.reviewdb.client.Change reloadChange() throws com.google.gwtorm.server.OrmException { try { notes = notesFactory.createChecked(db, project, legacyId); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(("Unable to load change " + (legacyId)), e); } change = notes.getChange(); setPatchSets(null); return change; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> draftRefs() throws com.google.gwtorm.server.OrmException { if ((draftsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } draftsByUser = new java.util.HashMap(); if (notesMigration.readChanges()) { for (org.eclipse.jgit.lib.Ref ref : commentsUtil.getDraftRefs(notes.getChangeId())) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefSuffix(ref.getName()); if ((account != null) && (!(notes().getDraftComments(account, ref).isEmpty()))) { draftsByUser.put(account, ref); } } } else { for (Comment sc : commentsUtil.draftByChange(db, notes())) { draftsByUser.put(sc.author.getId(), null); } } } return draftsByUser; }
public static void ensureChangeLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.change(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if ((cd.change) == null) { missing.put(cd.getId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.server.notedb.ChangeNotes notes : first.notesFactory.create(first.db, missing.keySet())) { missing.get(notes.getChangeId()).change = notes.getChange(); } }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change; try { change = cd.change(); if (change == null) { return false; } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); com.google.gerrit.server.project.ChangeControl cc = changeControl.controlFor(notes, user); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gwtorm.server.OrmException("unable to check permissions", e); } if (visible) { cd.cacheVisibleTo(cc); return true; } return false; }


@java.lang.Override public java.lang.Object apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException { format = com.google.gerrit.server.OutputFormat.JSON; return display(null); }
@java.lang.Override public void run() throws java.lang.Exception { impl.display(stdout); }
public boolean isDisabled() { return (getPermittedLimit()) <= 0; }

private int getEffectiveLimit(com.google.gerrit.index.query.Predicate<T> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(4); possibleLimits.add(getBackendSupportedLimit()); int permittedLimit = getPermittedLimit(); com.google.gerrit.server.query.QueryProcessor.checkState((permittedLimit > 0), "permitted limit should have been positive"); possibleLimits.add(permittedLimit); if ((limitFromCaller) > 0) { possibleLimits.add(limitFromCaller); } if ((limitField) != null) { java.lang.Integer limitFromPredicate = com.google.gerrit.index.query.LimitPredicate.getLimit(limitField, p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } } return com.google.common.collect.Ordering.natural().min(possibleLimits); }


public <R extends com.google.gerrit.extensions.restapi.RestResource> com.google.common.collect.FluentIterable<com.google.gerrit.extensions.webui.UiAction.Description> from(com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<R>> views, R resource) { return com.google.common.collect.FluentIterable.from(views).transform(( e) -> describe(e, resource)).filter(java.util.Objects::nonNull); }
static java.lang.String computeFromRequest(javax.servlet.http.HttpServletRequest req) { java.lang.StringBuffer url = req.getRequestURL(); url.setLength(((url.length()) - (req.getServletPath().length()))); if ((url.charAt(((url.length()) - 1))) != '/') { url.append('/'); } return url.toString(); }

private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectControl projectControl = controlFor(project); return (shouldReplicate(projectControl)) && ((PushOne.ALL_REFS.equals(ref)) || (projectControl.controlForRef(ref).isVisible())); } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
private java.util.List<org.eclipse.jgit.lib.Ref> getBranchRefs(com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.project.ProjectControl projectControl) { org.eclipse.jgit.lib.Ref[] result = new org.eclipse.jgit.lib.Ref[showBranch.size()]; try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName)) { for (int i = 0; i < (showBranch.size()); i++) { org.eclipse.jgit.lib.Ref ref = git.findRef(showBranch.get(i)); if ((((ref != null) && ((ref.getObjectId()) != null)) && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible())) || ((all) && (projectControl.isOwner()))) { result[i] = ref; } } } catch (java.io.IOException ioe) { } return java.util.Arrays.asList(result); }

public static com.google.gerrit.server.account.externalids.ExternalId createWithEmail(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(key, accountId, com.google.common.base.Strings.emptyToNull(email), null); }
public static com.google.gerrit.server.account.externalids.ExternalId create(java.lang.String scheme, java.lang.String id, com.google.gerrit.reviewdb.client.Account.Id accountId) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(com.google.gerrit.server.account.externalids.ExternalId.Key.create(scheme, id), accountId, null, null); }
private static com.google.gerrit.server.account.externalids.ExternalId parse(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; } byte[] raw = rw.getObjectReader().open(noteMap.get(noteId), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); return com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw); }
public static void remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return; } byte[] raw = rw.getObjectReader().open(noteMap.get(noteId), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw); checkState(extId.equals(actualExtId), "external id %s should be removed, but it's not matching the actual external id %s", extId.toString(), actualExtId.toString()); noteMap.remove(noteId); }
public static com.google.gerrit.server.account.externalids.ExternalId create(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email, @com.google.gerrit.common.Nullable java.lang.String hashedPassword) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(key, accountId, com.google.common.base.Strings.emptyToNull(email), com.google.common.base.Strings.emptyToNull(hashedPassword)); }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; } byte[] raw = rw.getObjectReader().open(noteMap.get(noteId), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw); if (expectedAccountId != null) { checkState(expectedAccountId.equals(extId.accountId()), ("external id %s should be removed for account %s," + " but external id belongs to account %s"), extIdKey.get(), expectedAccountId.get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; }
private java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException { if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return com.google.common.collect.ImmutableSet.of(); } try (com.google.gerrit.metrics.Timer0.Context ctx = readAllLatency.start();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = rw.getObjectReader().open(note.getData(), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw)); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIdReader.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; } }





@java.lang.Override public java.lang.String toString() { return java.lang.String.format("%s => %s", src(), dest()); }




public static com.google.gerrit.index.query.Predicate<com.google.gerrit.server.group.InternalGroup> name(java.lang.String name) { return new com.google.gerrit.server.query.group.GroupPredicates.GroupPredicate(com.google.gerrit.server.index.group.GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name.toLowerCase(java.util.Locale.US)); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); GroupInfo group = createGroup(name("group")); assertQuery(("name:" + (group.name)), group); assertQuery(("name:" + (group.name.toUpperCase(Locale.US))), group); GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen")); createGroup(name("group-no-match-with-hyphen")); assertQuery(("name:" + (groupWithHyphen.name)), groupWithHyphen); }



private boolean isProjectStatePermittingWrite() { return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); reject(cmd, "invalid object"); return; } logDebug("Creating {}", cmd); if ((com.google.gerrit.server.git.receive.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); java.lang.String rejectReason = ctl.canCreate(rp.getRepository(), obj); if (rejectReason != null) { reject(cmd, ("prohibited by Gerrit: " + rejectReason)); return; } if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); actualCommands.add(cmd); }


private boolean can(com.google.gerrit.server.permissions.ChangePermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { try { switch (perm) { case READ : return isVisible(db(), changeData()); case ABANDON : return canAbandon(db()); case DELETE : return canDelete(db(), getChange().getStatus()); case ADD_PATCH_SET : return canAddPatchSet(db()); case EDIT_ASSIGNEE : return canEditAssignee(); case EDIT_DESCRIPTION : return canEditDescription(); case EDIT_HASHTAGS : return canEditHashtags(); case EDIT_TOPIC_NAME : return canEditTopicName(); case REBASE : return canRebase(db()); case RESTORE : return canRestore(db()); case SUBMIT : return getRefControl().canSubmit(isOwner()); case REMOVE_REVIEWER : case SUBMIT_AS : return getRefControl().canPerform(perm.permissionName().get()); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.permissions.PermissionBackendException("unavailable", e); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { builder.withStopStrategy(com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeout(), defaultTimeout).toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS)).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); if ((opts.listener()) != null) { builder.withRetryListener(opts.listener()); } } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { com.google.gerrit.server.project.RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName); try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, refControl.getProjectControl().getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, refControl, new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
private java.util.List<com.google.gerrit.server.change.RevisionResource> loadEdit(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.reviewdb.client.RevId revid) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change.getChange()); if (edit.isPresent()) { com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 0)); com.google.gerrit.reviewdb.client.RevId editRevId = new com.google.gerrit.reviewdb.client.RevId(org.eclipse.jgit.lib.ObjectId.toString(edit.get().getEditCommit())); ps.setRevision(editRevId); if ((revid == null) || (editRevId.equals(revid))) { return java.util.Collections.singletonList(new com.google.gerrit.server.change.RevisionResource(change, ps, edit)); } } return java.util.Collections.emptyList(); }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(change); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(change.getId()); }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ChangeControl ctl = rsrc.getControl(); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), rsrc.getNotes()); com.google.gerrit.reviewdb.client.Project.NameKey project = ctl.getProject().getNameKey(); return includedIn.apply(project, ps.getRevision().get()); }
@java.lang.Override protected com.google.gerrit.extensions.common.ChangeInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.AbandonInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { req.permissions().database(dbProvider).check(ChangePermission.ABANDON); com.google.gerrit.extensions.api.changes.NotifyHandling notify = ((input.notify) == null) ? defaultNotify(req.getControl()) : input.notify; com.google.gerrit.reviewdb.client.Change change = abandon(updateFactory, req.getControl(), input.message, notify, notifyUtil.resolveAccounts(input.notifyDetails)); return json.noOptions().format(change); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ChangeControl control) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, control, "", defaultNotify(control), com.google.common.collect.ImmutableListMultimap.of()); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ChangeControl control, java.lang.String msgTxt) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, control, msgTxt, defaultNotify(control), com.google.common.collect.ImmutableListMultimap.of()); }
private java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> lookupChangeEdit(com.google.gerrit.server.project.ChangeControl changeControl) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException { return changeEditUtil.byChange(changeControl); }


@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(dbProvider.get(), rsrc.getUser().getAccountId(), ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot deactivate own account"); } java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(dbProvider.get(), rsrc.getUser().getAccountId(), ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }


public com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.server.project.RefControl refctl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.revwalk.RevWalk rw) { com.google.gerrit.server.IdentifiedUser user = refctl.getUser().asIdentifiedUser(); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(perm), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(user, perm, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refctl, rw, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new com.google.gerrit.server.git.validators.CommitValidators.AccountValidator(allUsers))); }


private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("You should only have no more than one --project and -n with --suggest"); } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, com.google.common.collect.Iterables.getFirst(projects, null)), ((limit) <= 0 ? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupRefs.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic desc = groupBackend.get(ref.getUUID()); if (desc != null) { groupInfos.add(json.addOptions(options).format(desc)); } } return groupInfos; }
private org.eclipse.jgit.revwalk.RevCommit newMergeCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter oi, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.ProjectControl projectControl, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.extensions.common.MergeInput merge, org.eclipse.jgit.lib.PersonIdent authorIdent, java.lang.String commitMessage) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { if (com.google.common.base.Strings.isNullOrEmpty(merge.source)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("merge.source must be non-empty"); } com.google.gerrit.server.project.ProjectState state = projectControl.getProjectState(); org.eclipse.jgit.revwalk.RevCommit sourceCommit = com.google.gerrit.server.git.MergeUtil.resolveCommit(repo, rw, merge.source); if (!(commits.canRead(state, repo, sourceCommit))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("do not have read permission for: " + (merge.source))); } com.google.gerrit.server.git.MergeUtil mergeUtil = mergeUtilFactory.create(state); java.lang.String mergeStrategy = com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(merge.strategy), mergeUtil.mergeStrategyName()); return com.google.gerrit.server.git.MergeUtil.createMergeCommit(oi, repo.getConfig(), mergeTip, sourceCommit, mergeStrategy, authorIdent, commitMessage, rw); }

private com.google.gerrit.server.notedb.ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { checkState((!(args.migration.readChanges())), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled"); return new com.google.gerrit.server.notedb.ChangeNotes(args, change).load(); }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChangesByScan() { com.google.gerrit.reviewdb.client.Project.NameKey project = projectCtl.getProject().getNameKey(); try { java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChanges = new java.util.HashMap<>(); for (com.google.gerrit.server.notedb.ChangeNotes cn : changeNotesFactory.scan(git, db.get(), project)) { if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) { visibleChanges.put(cn.getChangeId(), cn.getChange().getDest()); } } return visibleChanges; } catch (java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error((("Cannot load changes for project " + project) + ", assuming no changes are visible"), e); return java.util.Collections.emptyMap(); } }
private java.util.List<com.google.gerrit.server.notedb.ChangeNotes> scanNoteDb(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes.Factory.ScanResult sr = com.google.gerrit.server.notedb.ChangeNotes.Factory.scanChangeIds(repo); java.util.List<com.google.gerrit.server.notedb.ChangeNotes> changeNotes = new java.util.ArrayList(sr.fromPatchSetRefs().size()); com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage defaultStorage = args.migration.changePrimaryStorage(); for (com.google.gerrit.reviewdb.client.Change.Id id : sr.all()) { com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange(db, id); if (change == null) { if (!(sr.fromMetaRefs().contains(id))) { continue; } if (defaultStorage == (com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage.REVIEW_DB)) { com.google.gerrit.server.notedb.ChangeNotes.log.warn("skipping change {} found in project {} but not in ReviewDb", id, project); continue; } change = com.google.gerrit.server.notedb.ChangeNotes.Factory.newNoteDbOnlyChange(project, id); } else if (!(change.getProject().equals(project))) { com.google.gerrit.server.notedb.ChangeNotes.log.error("skipping change {} found in project {} because ReviewDb change has project {}", id, project, change.getProject()); continue; } com.google.gerrit.server.notedb.ChangeNotes.log.debug("adding change {} found in project {}", id, project); changeNotes.add(new com.google.gerrit.server.notedb.ChangeNotes(args, change).load()); } return changeNotes; }

public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> create(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.function.Predicate<com.google.gerrit.server.notedb.ChangeNotes> predicate) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> m = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); if (args.migration.readChanges()) { for (com.google.gerrit.reviewdb.client.Project.NameKey project : projectCache.all()) { try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(project)) { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> changes = scanNoteDb(repo, db, project); for (com.google.gerrit.server.notedb.ChangeNotes cn : changes) { if (predicate.test(cn)) { m.put(project, cn); } } } } } else { for (com.google.gerrit.reviewdb.client.Change change : com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db).changes().all()) { com.google.gerrit.server.notedb.ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change); if (predicate.test(notes)) { m.put(change.getProject(), notes); } } } return com.google.common.collect.ImmutableListMultimap.copyOf(m); }
private static com.google.gerrit.server.notedb.ChangeNotes.Factory.ScanResult scanChangeIds(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromPs = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromMeta = com.google.common.collect.ImmutableSet.builder(); for (org.eclipse.jgit.lib.Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) { com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.fromRef(r.getName()); if (id != null) { (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id); } } return new com.google.gerrit.server.notedb.AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build()); }
@java.lang.Override public void stop() { if ((threadPool) != null) { threadPool.unregisterWorkQueue(); threadPool = null; } }

private com.google.gerrit.extensions.api.access.AccessSectionInfo createAccessSection(com.google.gerrit.common.data.AccessSection section) { com.google.gerrit.extensions.api.access.AccessSectionInfo accessSectionInfo = new com.google.gerrit.extensions.api.access.AccessSectionInfo(); accessSectionInfo.permissions = new java.util.HashMap(); for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { com.google.gerrit.extensions.api.access.PermissionInfo pInfo = new com.google.gerrit.extensions.api.access.PermissionInfo(p.getLabel(), (p.getExclusiveGroup() ? true : null)); pInfo.rules = new java.util.HashMap(); for (com.google.gerrit.common.data.PermissionRule r : p.getRules()) { com.google.gerrit.extensions.api.access.PermissionRuleInfo info = new com.google.gerrit.extensions.api.access.PermissionRuleInfo(com.google.gerrit.server.project.GetAccess.ACTION_TYPE.get(r.getAction()), r.getForce()); if (r.hasRange()) { info.max = r.getMax(); info.min = r.getMin(); } com.google.gerrit.reviewdb.client.AccountGroup.UUID group = r.getGroup().getUUID(); if (group != null) { pInfo.rules.put(group.get(), info); } } accessSectionInfo.permissions.put(p.getName(), pInfo); } return accessSectionInfo; }
boolean isPatchSetLocked(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if ((getChange().getStatus()) == (Change.Status.MERGED)) { return false; } for (com.google.gerrit.reviewdb.client.PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId(), null, null)) { com.google.gerrit.common.data.LabelType type = getLabelTypes().byLabel(ap.getLabel()); if (((type != null) && ((ap.getValue()) == 1)) && (type.getFunctionName().equalsIgnoreCase("PatchSetLock"))) { return true; } } return false; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { user = ctx.getIdentifiedUser(); notes = ctx.getNotes(); ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); boolean dirty = false; dirty |= insertComments(ctx); dirty |= insertRobotComments(ctx); dirty |= updateLabels(ctx); dirty |= insertMessage(ctx); return dirty; }
private void fireCommentAddedEvent(com.google.gerrit.server.update.Context ctx) throws com.google.gwtorm.server.OrmException { if (approvals.isEmpty()) { return; } com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), notes.getChange(), ctx.getUser()); java.util.List<com.google.gerrit.common.data.LabelType> labels = changeControl.getLabelTypes().getLabelTypes(); java.util.Map<java.lang.String, java.lang.Short> allApprovals = new java.util.HashMap<>(); java.util.Map<java.lang.String, java.lang.Short> oldApprovals = new java.util.HashMap<>(); for (com.google.gerrit.common.data.LabelType lt : labels) { allApprovals.put(lt.getName(), ((short) (0))); oldApprovals.put(lt.getName(), null); } for (java.util.Map.Entry<java.lang.String, java.lang.Short> entry : approvals.entrySet()) { if ((entry.getValue()) != 0) { allApprovals.put(entry.getKey(), entry.getValue()); oldApprovals.put(entry.getKey(), ((short) (0))); } } commentAdded.fire(notes.getChange(), newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen()); }
public com.google.gerrit.server.git.LabelNormalizer.Result normalize(com.google.gerrit.server.project.ChangeControl ctl, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> unchanged = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> updated = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> deleted = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getLabelTypes(); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { com.google.gerrit.reviewdb.client.Change.Id changeId = psa.getKey().getParentKey().getParentKey(); checkArgument(changeId.equals(ctl.getId()), "Approval %s does not match change %s", psa.getKey(), ctl.getChange().getKey()); if (psa.isLegacySubmit()) { unchanged.add(psa); continue; } com.google.gerrit.common.data.LabelType label = labelTypes.byLabel(psa.getLabelId()); if (label == null) { deleted.add(psa); continue; } com.google.gerrit.reviewdb.client.PatchSetApproval copy = copy(psa); applyTypeFloor(label, copy); if (!(applyRightFloor(ctl, label, copy))) { deleted.add(psa); } else if ((copy.getValue()) != (psa.getValue())) { updated.add(copy); } else { unchanged.add(psa); } } return com.google.gerrit.server.git.LabelNormalizer.Result.create(unchanged, updated, deleted); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(com.google.gerrit.reviewdb.server.ReviewDb db, java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail); if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.AccountState who = byId.getByUsername(nameOrEmail); if (who != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(db, nameOrEmail); }
private boolean verify(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String username = com.google.gerrit.httpd.RemoteUserUtil.getRemoteUser(req, loginHttpHeader); if (username == null) { rsp.sendError(com.google.gerrit.httpd.SC_FORBIDDEN); return false; } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } final com.google.gerrit.server.account.AccountState who = accountCache.getByUsername(username); if ((who == null) || (!(who.getAccount().isActive()))) { rsp.sendError(com.google.gerrit.httpd.SC_UNAUTHORIZED); return false; } com.google.gerrit.httpd.WebSession ws = session.get(); ws.setUserAccountId(who.getAccount().getId()); ws.setAccessPathOk(AccessPath.GIT, true); ws.setAccessPathOk(AccessPath.REST_API, true); return true; }
@java.lang.Override public boolean validateIdentity(org.apache.sshd.server.session.ServerSession session, java.lang.String identity) { final com.google.gerrit.sshd.SshSession sd = session.getAttribute(SshSession.KEY); int at = identity.indexOf('@'); java.lang.String username; if (at == (-1)) { username = identity; } else { username = identity.substring(0, at); } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } com.google.gerrit.server.account.AccountState state = accounts.getByUsername(username); com.google.gerrit.reviewdb.client.Account account = (state == null) ? null : state.getAccount(); boolean active = (account != null) && (account.isActive()); if (active) { return com.google.gerrit.sshd.SshUtil.success(username, session, sshScope, sshLog, sd, com.google.gerrit.sshd.SshUtil.createUser(sd, userFactory, account.getId())); } return false; }

void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.lang.Exception;
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.lang.Exception { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.getDestBranch().equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.repo.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.getDestBranch()); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.Utils.readBlob(srcRepo, ((srcRef + ":") + (c.getXmlPath())))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.isRecordSubmoduleLabels()).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setTargetURI(c.getDestRepoKey().toString()).setURI(c.getBaseUri().toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.repo.RepoUpdater.GerritIncludeReader(srcRepo, srcRef)); cmd.call(); }

@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { com.googlesource.gerrit.plugins.supermanifest.SubModuleUpdater subModuleUpdater; switch (c.getToolType()) { case Repo : subModuleUpdater = new com.googlesource.gerrit.plugins.supermanifest.repo.RepoUpdater(serverIdent, canonicalWebUrl); break; default : throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("invalid toolType: %s", c.getToolType().name())); } try (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { subModuleUpdater.update(reader, c, event.getRefName()); } } catch (java.lang.Exception e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); java.io.StringWriter sw = new java.io.StringWriter(); java.io.PrintWriter pw = new java.io.PrintWriter(sw); e.printStackTrace(pw); error("update for %s (ref %s) failed: %s", c.toString(), event.getRefName(), sw); } } }


@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.common.base.Optional<com.ericsson.gerrit.plugins.highavailability.peers.PeerInfo>>() {}).toProvider(com.ericsson.gerrit.plugins.highavailability.peers.PluginConfigPeerInfoProvider.class); }



@java.lang.Override public void run() throws java.lang.Exception { ui.message("\n"); ui.header("%s Plugin", pluginName); if (ui.yesno(true, "Configure %s", pluginName)) { ui.header("Configuring %s", pluginName); java.nio.file.Path pluginConfigFile = site.etc_dir.resolve(((pluginName) + ".config")); config = new org.eclipse.jgit.storage.file.FileBasedConfig(pluginConfigFile.toFile(), org.eclipse.jgit.util.FS.DETECTED); config.load(); configureMainSection(); configurePeerInfoSection(); configureHttp(); configureCacheSection(); configureIndexSection(); configureWebsessiosSection(); config.save(); } }




private void configureMainSection() { ui.header("Main section"); java.lang.String sharedDir = promptAndSetString("Shared directory", com.ericsson.gerrit.plugins.highavailability.MAIN_SECTION, com.ericsson.gerrit.plugins.highavailability.SHARED_DIRECTORY_KEY, null); if (!(com.google.common.base.Strings.isNullOrEmpty(sharedDir))) { java.nio.file.Path shared = site.site_path.resolve(sharedDir); com.google.gerrit.common.FileUtil.mkdirsOrDie(shared, ("cannot create " + shared)); } }
private boolean applyRightFloor(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.common.data.LabelType lt, com.google.gerrit.reviewdb.client.PatchSetApproval a) { com.google.gerrit.common.data.PermissionRange range = getRange(ctl, lt, a.getAccountId()); if (range.isEmpty()) { return false; } a.setValue(((short) (range.squash(a.getValue())))); return true; }







private java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents() { java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all()) { com.google.gerrit.server.project.ProjectState ps = projectCache.get(p); if (ps != null) { com.google.gerrit.reviewdb.client.Project.NameKey parent = ps.getProject().getParent(); if (parent != null) { parents.add(parent); } } } parents.add(allProjects); return parents; }
private void service() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.Failure, java.io.IOException { state = projectControl.getProjectState(); project = state.getProject(); projectName = project.getNameKey(); try { repo = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.Failure(1, (("fatal: '" + (project.getName())) + "': not a git archive"), e); } try { runImpl(); } finally { repo.close(); } }
private boolean validCommit(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.reviewdb.client.Branch.NameKey branch, org.eclipse.jgit.transport.ReceiveCommand cmd, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { if (validCommits.contains(id)) { return true; } org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(id); rw.parseBody(c); try (com.google.gerrit.server.events.CommitReceivedEvent receiveEvent = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, project, branch.get(), rw.getObjectReader(), c, user)) { boolean isMerged = (((magicBranch) != null) && (cmd.getRefName().equals(magicBranch.cmd.getRefName()))) && (magicBranch.merged); com.google.gerrit.server.git.validators.CommitValidators validators = (isMerged) ? commitValidatorsFactory.forMergedCommits(perm, user.asIdentifiedUser()) : commitValidatorsFactory.forReceiveCommits(perm, branch, user.asIdentifiedUser(), sshInfo, repo, rw); messages.addAll(validators.validate(receiveEvent)); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { logDebug("Commit validation failed on {}", c.name()); messages.addAll(e.getMessages()); reject(cmd, e.getMessage()); return false; } validCommits.add(c.copy()); return true; }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, projectCache.checkedGet(ctx.getProject()).getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (checkAddPatchSetPermission) { permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origCtl.getNotes()).check(ChangePermission.ADD_PATCH_SET); } if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origCtl.getChange().getDest()); java.lang.String refName = getPatchSetId().toRefName(); try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commitId, ((refName.substring(0, ((refName.lastIndexOf('/')) + 1))) + "new")), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(origCtl.getProject().getNameKey(), origCtl.getRefControl().getRefName()), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRef(receiveEvent.refName); if (accountId == null) { return java.util.Collections.emptyList(); } try { java.util.List<java.lang.String> errorMessages = accountValidator.validate(accountId, receiveEvent.revWalk, receiveEvent.command.getOldId(), receiveEvent.commit); if (!(errorMessages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("invalid account configuration", errorMessages.stream().map(( m) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(m, true)).collect(java.util.stream.Collectors.toList())); } } catch (java.io.IOException e) { java.lang.String m = java.lang.String.format("Validating update for account %s failed", accountId.get()); com.google.gerrit.server.git.validators.CommitValidators.log.error(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } return java.util.Collections.emptyList(); }
@java.lang.Override public Project.NameKey getProjectNameKey() { return project.getNameKey(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if ((allUsers.equals(receiveEvent.project.getNameKey())) && (RefNames.REFS_EXTERNAL_IDS.equals(receiveEvent.refName))) { try { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = externalIdsConsistencyChecker.check(receiveEvent.commit); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> msgs = problems.stream().map(( p) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(p.message, (p.status == ConsistencyProblemInfo.Status.ERROR))).collect(java.util.stream.Collectors.toList()); if (msgs.stream().anyMatch(( m) -> m.isError())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("invalid external IDs", msgs); } return msgs; } catch (java.io.IOException e) { java.lang.String m = "error validating external IDs"; com.google.gerrit.server.git.validators.CommitValidators.log.warn(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } } return java.util.Collections.emptyList(); }
private void assertNoProblems(com.google.gerrit.server.project.ChangeControl ctl, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix) { assertThat(checker.check(ctl, fix).problems()).isEmpty(); }

private com.google.gerrit.server.project.ChangeControl incrementPatchSet(com.google.gerrit.server.project.ChangeControl ctl, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { com.google.gerrit.server.change.PatchSetInserter ins; try (com.google.gerrit.server.update.BatchUpdate bu = newUpdate(ctl.getChange().getOwner())) { ins = patchSetInserterFactory.create(ctl, nextPatchSetId(ctl), commit).setValidate(false).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE); bu.addOp(ctl.getId(), ins).execute(); } return reload(ctl); }
private void assertProblems(com.google.gerrit.server.project.ChangeControl ctl, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix, com.google.gerrit.extensions.common.ProblemInfo first, com.google.gerrit.extensions.common.ProblemInfo... rest) { java.util.List<com.google.gerrit.extensions.common.ProblemInfo> expected = new java.util.ArrayList((1 + (rest.length))); expected.add(first); expected.addAll(java.util.Arrays.asList(rest)); assertThat(checker.check(ctl, fix).problems()).containsExactlyElementsIn(expected).inOrder(); }
@org.junit.Test public void missingRepo() throws java.lang.Exception { assumeNoteDbDisabled(); com.google.gerrit.server.project.ChangeControl ctl = insertChange(); com.google.gerrit.reviewdb.client.Project.NameKey name = ctl.getProject().getNameKey(); ((com.google.gerrit.testutil.InMemoryRepositoryManager) (repoManager)).deleteRepository(name); assertProblems(ctl, null, com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem(("Destination repository not found: " + name))); }
private void setUpChange() throws java.lang.Exception { change = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new com.google.gerrit.reviewdb.client.Change.Id(1), userId, new com.google.gerrit.reviewdb.client.Branch.NameKey(allProjects, "refs/heads/master"), com.google.gerrit.common.TimeUtil.nowTs()); com.google.gerrit.reviewdb.client.PatchSetInfo ps = new com.google.gerrit.reviewdb.client.PatchSetInfo(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 1)); ps.setSubject("Test change"); change.setCurrentPatchSet(ps); db.changes().insert(com.google.common.collect.ImmutableList.of(change)); }
private java.util.List<com.google.gerrit.server.project.ChangeControl> asChangeControls(java.util.List<com.google.gerrit.server.query.change.ChangeData> cds, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = new java.util.ArrayList(cds.size()); if (!(indexConfig.separateChangeSubIndexes())) { for (com.google.gerrit.server.query.change.ChangeData cd : cds) { com.google.gerrit.server.ChangeFinder.checkedAdd(cd, ctls, user); } return ctls; } java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> seen = com.google.common.collect.Sets.newHashSetWithExpectedSize(cds.size()); for (com.google.gerrit.server.query.change.ChangeData cd : cds) { if (seen.add(cd.getId())) { com.google.gerrit.server.ChangeFinder.checkedAdd(cd, ctls, user); } } return ctls; }
private com.google.gerrit.server.change.ChangeResource parseResource(com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(r.getChangeId(), atrScope.get().getUser()); assertThat(ctls).hasSize(1); return changeResourceFactory.create(ctls.get(0)); }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id.encoded(), user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(canRead(ctl))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(ctl); }
private java.util.List<com.google.gerrit.server.project.ChangeControl> changeFromNotesFactory(java.lang.String id, com.google.gerrit.server.CurrentUser currentUser) throws com.google.gerrit.sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { return changeNotesFactory.create(db, parseId(id)).stream().map(( changeNote) -> controlForChange(changeNote, currentUser)).filter(( changeControl) -> changeControl.isPresent()).map(( changeControl) -> changeControl.get()).collect(java.util.stream.Collectors.toList()); }
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(user, id.substring(0, z), n.intValue()); } } if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return find(new com.google.gerrit.reviewdb.client.Change.Id(n), user); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeControls(query.byBranchKey(t.branch(), t.id()), user); } } return asChangeControls(query.byKeyPrefix(id), user); }
private java.util.List<com.google.gerrit.server.project.ChangeControl> fromProjectNumber(com.google.gerrit.server.CurrentUser user, java.lang.String project, int changeNumber) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change.Id cId = new com.google.gerrit.reviewdb.client.Change.Id(changeNumber); try { return com.google.common.collect.ImmutableList.of(changeControlFactory.controlFor(reviewDb.get(), Project.NameKey.parse(project), cId, user)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return java.util.Collections.emptyList(); } catch (java.lang.IllegalArgumentException e) { java.lang.String changeNotFound = java.lang.String.format("change %s not found in ReviewDb", cId); java.lang.String projectNotFound = java.lang.String.format("passed project %s when creating ChangeNotes for %s, but actual project is", project, cId); if ((e.getMessage().equals(changeNotFound)) || (e.getMessage().startsWith(projectNotFound))) { return java.util.Collections.emptyList(); } throw e; } catch (com.google.gwtorm.server.OrmException e) { if ((com.google.common.base.Throwables.getRootCause(e)) instanceof org.eclipse.jgit.errors.RepositoryNotFoundException) { return java.util.Collections.emptyList(); } throw e; } }
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(com.google.gerrit.reviewdb.client.Change.Id id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { java.lang.String project = changeIdProjectCache.getIfPresent(id); if (project != null) { return fromProjectNumber(user, project, id.get()); } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); java.util.List<com.google.gerrit.server.query.change.ChangeData> r = query.byLegacyChangeId(id); if ((r.size()) == 1) { changeIdProjectCache.put(id, r.get(0).project().get()); } return asChangeControls(r, user); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id, user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(canRead(ctl))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(ctl); }

@java.lang.Override public org.eclipse.jgit.lib.Config get() { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(site.gerrit_config.toFile(), org.eclipse.jgit.util.FS.DETECTED); if (!(cfg.getFile().exists())) { com.google.gerrit.server.config.GerritServerConfigProvider.log.info((("No " + (site.gerrit_config.toAbsolutePath())) + "; assuming defaults")); return new com.google.gerrit.server.config.GerritConfig(cfg, secureStore); } try { cfg.load(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.inject.ProvisionException(e.getMessage(), e); } return new com.google.gerrit.server.config.GerritConfig(cfg, secureStore); }


public com.google.gerrit.server.git.ChangeReportFormatter.Input setSubject(java.lang.String subject) { this.subject = subject; return this; }
public com.google.gerrit.server.git.ChangeReportFormatter.Input setEdit(boolean edit) { this.edit = edit; return this; }
public com.google.gerrit.server.git.ChangeReportFormatter.Input setDraft(boolean draft) { this.draft = draft; return this; }
public com.google.gerrit.reviewdb.client.Change getChange() { return change; }
private boolean requestReplace(org.eclipse.jgit.transport.ReceiveCommand cmd, boolean checkMergedInto, com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.revwalk.RevCommit newCommit) { if (change.getStatus().isClosed()) { reject(cmd, changeFormatter.changeClosed(new com.google.gerrit.server.git.ChangeReportFormatter.Input(change))); return false; } com.google.gerrit.server.git.receive.ReceiveCommits.ReplaceRequest req = new com.google.gerrit.server.git.receive.ReceiveCommits.ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); if (replaceByChange.containsKey(req.ontoChange)) { reject(cmd, "duplicate request"); return false; } replaceByChange.put(req.ontoChange, req); return true; }
public com.google.gerrit.server.git.ChangeReportFormatter.Input setWorkInProgress(boolean wip) { this.wip = wip; return this; }
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(db.get(), revision.getControl()); return new java.util.HashSet(changeData.filePaths(revision.getPatchSet())); }
public Change.Id getId() { return control.getId(); }
public boolean isUserOwner() { com.google.gerrit.server.CurrentUser user = control.getUser(); com.google.gerrit.reviewdb.client.Account.Id owner = getChange().getOwner(); return (user.isIdentifiedUser()) && (user.asIdentifiedUser().getAccountId().equals(owner)); }
@java.lang.Override public java.lang.String getETag() { com.google.gerrit.server.CurrentUser user = control.getUser(); com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, user); return h.hash().toString(); }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec)); } return rec.type; }
private boolean isReviewer(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { if (ctx.getAccountId().equals(ctx.getChange().getOwner())) { return true; } com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl()); com.google.gerrit.server.ReviewerSet reviewers = cd.reviewers(); if (reviewers.byState(com.google.gerrit.server.change.REVIEWER).contains(ctx.getAccountId())) { return true; } return false; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(ctl);org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null); accountLoader.fill(); return rev; } }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.project.ProjectState projectState = rsrc.getRevision().getControl().getProjectControl().getProjectState(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectState, revstr, path, parent); }
public com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl()); return format(cd, java.util.Optional.of(rsrc.getPatchSet().getId()), true); }
public PermissionBackend.ForChange permissions() { return permissionBackend.user(control.getUser()).change(getNotes()); }
public com.google.gerrit.reviewdb.client.Change getChange() { return control.getChange(); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet currentPatchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); if (currentPatchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } else if (!(rsrc.getControl().isPatchVisible(currentPatchSet, dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("current revision not accessible"); } if ((claimedOriginal) == null) { if ((rsrc.getChange().getRevertOf()) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("no ID was provided and change isn't a revert"); } com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(dbProvider.get(), notesFactory.createChecked(dbProvider.get(), rsrc.getProject(), rsrc.getChange().getRevertOf())); claimedOriginal = ps.getRevision().get(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getProject());org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit claimedOriginalCommit; try { claimedOriginalCommit = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(claimedOriginal)); } catch (org.eclipse.jgit.errors.InvalidObjectIdException | org.eclipse.jgit.errors.MissingObjectException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid object ID"); } if ((claimedOriginalCommit.getParentCount()) == 0) { throw new com.google.gerrit.extensions.restapi.BadRequestException("can't check against initial commit"); } org.eclipse.jgit.revwalk.RevCommit claimedRevertCommit = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(currentPatchSet.getRevision().get())); if ((claimedRevertCommit.getParentCount()) == 0) { throw new com.google.gerrit.extensions.restapi.BadRequestException("claimed revert has no parents"); } org.eclipse.jgit.merge.ThreeWayMerger merger = mergeUtilFactory.create(projectCache.checkedGet(rsrc.getProject())).newThreeWayMerger(oi, repo.getConfig()); merger.setBase(claimedRevertCommit.getParent(0)); merger.merge(claimedRevertCommit, claimedOriginalCommit); if ((merger.getResultTreeId()) == null) { return new com.google.gerrit.extensions.common.PureRevertInfo(false); } try (org.eclipse.jgit.diff.DiffFormatter df = new org.eclipse.jgit.diff.DiffFormatter(new java.io.ByteArrayOutputStream())) { df.setRepository(repo); java.util.List<org.eclipse.jgit.diff.DiffEntry> entries = df.scan(claimedOriginalCommit.getParent(0), merger.getResultTreeId()); return new com.google.gerrit.extensions.common.PureRevertInfo(entries.isEmpty()); } } }




private java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> getMembers(final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seenGroups) throws com.google.gwtorm.server.OrmException { seenGroups.add(groupUUID); final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> members = new java.util.HashMap<>(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupUUID); if (group == null) { return java.util.Collections.emptyMap(); } final com.google.gerrit.common.data.GroupDetail groupDetail; try { groupDetail = groupDetailFactory.create(group.getGroupUUID()).call(); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { return java.util.Collections.emptyMap(); } for (com.google.gerrit.reviewdb.client.Account.Id member : groupDetail.getMembers()) { if (!(members.containsKey(member))) { members.put(member, accountLoader.get(member)); } } if (recursive) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid : groupDetail.getIncludes()) { if (!(seenGroups.contains(includedGroupUuid))) { members.putAll(getMembers(includedGroupUuid, seenGroups)); } } } accountLoader.fill(); return members; }
private void addIncludedGroups(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddIncludedGroups.Input input = AddIncludedGroups.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).collect(java.util.stream.Collectors.toList())); addIncludedGroups.apply(rsrc, input); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(final com.google.gerrit.reviewdb.client.AccountGroup group, com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { seen.add(group.getGroupUUID()); final com.google.gerrit.common.data.GroupDetail groupDetail = groupDetailFactory.create(group.getGroupUUID()).call(); final java.util.Set<com.google.gerrit.reviewdb.client.Account> members = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account.Id memberId : groupDetail.getMembers()) { members.add(accountCache.get(memberId).getAccount()); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupIncludeUuid : groupDetail.getIncludes()) { com.google.gerrit.reviewdb.client.AccountGroup includedGroup = groupCache.get(groupIncludeUuid); if ((includedGroup != null) && (!(seen.contains(includedGroup.getGroupUUID())))) { members.addAll(listAccounts(includedGroup.getGroupUUID(), project, seen)); } } return members; }
public void deleteIncludedGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> includedGroupUuids) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> includedGroupsToRemove = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid : includedGroupUuids) { boolean isIncluded = groups.isIncluded(db, parentGroupUuid, includedGroupUuid); if (isIncluded) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, includedGroupUuid); includedGroupsToRemove.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (includedGroupsToRemove.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), includedGroupsToRemove); } db.accountGroupById().delete(includedGroupsToRemove); for (com.google.gerrit.reviewdb.client.AccountGroupById groupToRemove : includedGroupsToRemove) { groupIncludeCache.evictParentGroupsOf(groupToRemove.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }
public void addIncludedGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> includedGroupUuids) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newIncludedGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid : includedGroupUuids) { boolean isIncluded = groups.isIncluded(db, parentGroupUuid, includedGroupUuid); if (!isIncluded) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, includedGroupUuid); newIncludedGroups.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (newIncludedGroups.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), newIncludedGroups); } db.accountGroupById().insert(newIncludedGroups); for (com.google.gerrit.reviewdb.client.AccountGroupById newIncludedGroup : newIncludedGroups) { groupIncludeCache.evictParentGroupsOf(newIncludedGroup.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }







private void loadPublished(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, java.lang.String file) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes notes = control.getNotes(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) { comments.include(change.getId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null) { p.setCommentCount(((p.getCommentCount()) + 1)); } } }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(control.getNotes()); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(change.getId()); }
private void loadDrafts(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.String file) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) { comments.include(change.getId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null) { p.setDraftCount(((p.getDraftCount()) + 1)); } } }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); newTopicName = com.google.common.base.Strings.nullToEmpty(input.topic); oldTopicName = com.google.common.base.Strings.nullToEmpty(change.getTopic()); if (oldTopicName.equals(newTopicName)) { return false; } java.lang.String summary; if (oldTopicName.isEmpty()) { summary = "Topic set to " + (newTopicName); } else if (newTopicName.isEmpty()) { summary = ("Topic " + (oldTopicName)) + " removed"; } else { summary = java.lang.String.format("Topic changed from %s to %s", oldTopicName, newTopicName); } change.setTopic(com.google.common.base.Strings.emptyToNull(newTopicName)); update.setTopic(change.getTopic()); com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.TAG_SET_TOPIC); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); return true; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.server.change.PutTopic.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); com.google.gerrit.server.change.PutTopic.Op op = new com.google.gerrit.server.change.PutTopic.Op((input != null ? input : new com.google.gerrit.server.change.PutTopic.Input())); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(op.newTopicName); }



private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectControl ctl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = ctl.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = ctl.getProject().getDefaultDashboard(); } if ("default".equals(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(ctl, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : ctl.getProjectState().tree()) { id = ps.getProject().getDefaultDashboard(); if ("default".equals(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { ctl = ps.controlFor(ctl.getUser()); return parse(ctl, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.project.ProjectControl myCtl = parent.getControl(); if (id.toString().equals("default")) { return com.google.gerrit.server.project.DashboardResource.projectDefault(myCtl); } java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id.get())); if ((parts.size()) != 2) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.CurrentUser user = myCtl.getUser(); java.lang.String ref = parts.get(0); java.lang.String path = parts.get(1); for (com.google.gerrit.server.project.ProjectState ps : myCtl.getProjectState().tree()) { try { return parse(ps.controlFor(user), ref, path, myCtl); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (id.toString().equals("default")) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }

private void attemptToMergeAtomic(com.criteo.gerrit.plugins.automerge.Change change) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { final java.util.List<com.google.gerrit.extensions.common.ChangeInfo> related = com.google.common.collect.Lists.newArrayList(); related.addAll(api.changes().query(("status: open AND topic: " + (change.topic))).withOption(ListChangesOption.CURRENT_REVISION).get()); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { if (!(atomicityHelper.isSubmittable(info.project, info._number))) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Change {} is not submittable because same topic change {} has not all approvals.", change.number, info._number); return; } } for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { boolean dependsOnNonMergedCommit = atomicityHelper.hasDependentReview(info.project, info._number); if ((!(info.mergeable)) || dependsOnNonMergedCommit) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Change {} is not mergeable because same topic change {} {}", change.number, info._number, (!(info.mergeable) ? "is non mergeable" : "depends on a non merged commit.")); if (!(info.mergeable)) { reviewUpdater.commentOnReview(change.project, change.number, AutomergeConfig.CANT_MERGE_COMMENT_FILE); } return; } } com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Submitting atomic change {}...", change.number); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { atomicityHelper.mergeReview(info.project, info._number); } }
public void commentOnReview(java.lang.String project, int number, java.lang.String commentTemplate) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput comment = createComment(commentTemplate); applyComment(project, number, comment); }
private com.google.gerrit.extensions.api.changes.ReviewInput createComment(final java.lang.String commentTemplate) { return new com.google.gerrit.extensions.api.changes.ReviewInput().message(((com.criteo.gerrit.plugins.automerge.ReviewUpdater.commentsPrefix) + (getCommentFromFile(commentTemplate)))); }

public void setMinusOne(java.lang.String project, int number, java.lang.String commentTemplate) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput message = createComment(commentTemplate).label("Code-Review", (-1)); applyComment(project, number, message); }
private void processNewAtomicPatchSet(com.criteo.gerrit.plugins.automerge.Change change) { try { checkReviewExists(change.number); if (atomicityHelper.hasDependentReview(change.project, change.number)) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format("Warn the user by setting -1 on change %d, as other atomic changes exists on the same repository.", change.number)); reviewUpdater.setMinusOne(change.project, change.number, AutomergeConfig.ATOMIC_REVIEWS_SAME_REPO_FILE); } else { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format("Detected atomic review on change %d.", change.number)); reviewUpdater.commentOnReview(change.project, change.number, AutomergeConfig.ATOMIC_REVIEW_DETECTED_FILE); } } catch (com.google.gerrit.extensions.restapi.RestApiException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException e) { throw new java.lang.RuntimeException(e); } }
public void ignore(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { star(accountId, project, changeId, com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL), com.google.common.collect.ImmutableSet.of()); }
public void unignore(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { star(accountId, project, changeId, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.Mute.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.StarredChangesUtil.IllegalLabelException, com.google.gwtorm.server.OrmException { if ((rsrc.isUserOwner()) || (isMuted(rsrc.getChange()))) { return com.google.gerrit.extensions.restapi.Response.ok(""); } stars.mute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange()); return com.google.gerrit.extensions.restapi.Response.ok(""); }
static java.util.Set<java.lang.String> extractTags(java.util.Set<java.lang.String> input) throws java.lang.IllegalArgumentException { if (input == null) { return java.util.Collections.emptySet(); } java.util.HashSet<java.lang.String> result = new java.util.HashSet<>(); for (java.lang.String hashtag : input) { if (hashtag.contains(",")) { throw new java.lang.IllegalArgumentException("Hashtags may not contain commas"); } hashtag = com.google.gerrit.server.change.HashtagsUtil.cleanupHashtag(hashtag); if (!(hashtag.isEmpty())) { result.add(hashtag); } } return result; }

@org.junit.Test public void dashboardDoesNotExist() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name(project.get()).dashboard("dashboard").get(); }

@org.junit.Test public void invalidInputs() { java.util.List<com.google.gerrit.extensions.api.config.AccessCheckInput> inputs = com.google.common.collect.ImmutableList.of(new com.google.gerrit.extensions.api.config.AccessCheckInput(), new com.google.gerrit.extensions.api.config.AccessCheckInput(user.email, null, null), new com.google.gerrit.extensions.api.config.AccessCheckInput(null, normalProject.toString(), null), new com.google.gerrit.extensions.api.config.AccessCheckInput("doesnotexist@invalid.com", normalProject.toString(), null)); for (com.google.gerrit.extensions.api.config.AccessCheckInput input : inputs) { try { gApi.config().server().checkAccess(input); fail(java.lang.String.format("want RestApiException for %s", newGson().toJson(input))); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { } } }

private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException { if (!visible) { return cd.changeControl().getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((("Failed to get submit type for " + (cd.getId())) + ": ") + (str.errorMessage))); } return str.type; }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectControl ctl, java.lang.String ref, java.lang.String path, com.google.gerrit.server.project.ProjectControl myCtl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.AmbiguousObjectException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.IncorrectObjectTypeException { java.lang.String id = (ref + ":") + path; if (!(ref.startsWith(com.google.gerrit.server.project.REFS_DASHBOARDS))) { ref = (REFS_DASHBOARDS) + ref; } try { permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(ref))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(ctl.getProject().getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + path)); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.project.DashboardResource(myCtl, ref, path, cfg, false); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }

private boolean canImport() { com.google.gerrit.server.account.CapabilityControl ctl = userProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || (ctl.canPerform((((pluginName) + "-") + (ImportCapability.ID)))); }
private boolean canCompleteImport(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.account.CapabilityControl ctl = currentUserProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || ((ctl.canPerform((((pluginName) + "-") + (ImportCapability.ID)))) && (rsrc.getControl().isOwner())); }
private boolean canCopy() { com.google.gerrit.server.account.CapabilityControl ctl = currentUserProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || (ctl.canPerform((((pluginName) + "-") + (CopyProjectCapability.ID)))); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Copy...").setTitle(java.lang.String.format("Copy project %s", rsrc.getName())).setVisible(canCopy()); }
private boolean canResumeCopy(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.account.CapabilityControl ctl = currentUserProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || ((ctl.canPerform((((pluginName) + "-") + (CopyProjectCapability.ID)))) && (rsrc.getControl().isOwner())); }
private boolean canResumeImport(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.account.CapabilityControl ctl = currentUserProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || ((ctl.canPerform((((pluginName) + "-") + (ImportCapability.ID)))) && (rsrc.getControl().isOwner())); }
@java.lang.Override protected void run() throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.validators.ValidationException, com.google.gwtorm.server.OrmException, com.googlesource.gerrit.plugins.importer.UnloggedFailure, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { com.googlesource.gerrit.plugins.importer.ImportProject.Input input = new com.googlesource.gerrit.plugins.importer.ImportProject.Input(); input.from = url; input.name = name; input.user = user; input.pass = com.googlesource.gerrit.plugins.importer.PasswordUtil.readPassword(in, pass); if (!(com.google.common.base.Strings.isNullOrEmpty(parent))) { input.parent = parent; } try { com.googlesource.gerrit.plugins.importer.ImportProject importer = importProjectFactory.create(new com.google.gerrit.reviewdb.client.Project.NameKey(project)); if (!(quiet)) { importer.setErr(stderr); } com.googlesource.gerrit.plugins.importer.ImportStatistic stats = importer.apply(new com.google.gerrit.server.config.ConfigResource(), input); stdout.print((("Created Changes: " + (stats.numChangesCreated)) + "\n")); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
public static boolean isValidHttpUri(java.lang.String val) { return (((val.startsWith("https://")) || (val.startsWith("http://"))) || (val.startsWith("//"))) && (com.google.gitiles.doc.html.HtmlBuilder.URI.getValueFilter().matcher(val).find()); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return groups.getParentGroups(db, key).map(groupCache::get).flatMap(Streams::stream).map(InternalGroup::getGroupUUID).collect(toImmutableList()); } }
@org.junit.Test public void getGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")); testGetGroup(adminGroup.getGroupUUID().get(), adminGroup); testGetGroup(adminGroup.getName(), adminGroup); testGetGroup(adminGroup.getId().get(), adminGroup); }
@org.junit.Test public void branchDelegation2() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, fixers, "refs/heads/x/y/*"); com.google.gerrit.server.project.Util.doNotInherit(local, com.google.gerrit.server.project.OWNER, "refs/heads/x/y/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwnerAnyRef(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); com.google.gerrit.server.project.ProjectControl uFix = user(local, fixers); assertNotOwner(uFix); assertOwnerAnyRef(uFix); assertOwner("refs/heads/x/y/*", uFix); assertOwner("refs/heads/x/y/bar", uFix); assertNotOwner("refs/heads/x/*", uFix); assertNotOwner("refs/heads/x/y", uFix); assertNotOwner("refs/*", uFix); assertNotOwner("refs/heads/master", uFix); }
private boolean canAddRefs() { return (canPerformOnAnyRef(Permission.CREATE)) || (isOwnerAnyRef()); }
@org.junit.Test public void branchDelegation1() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwnerAnyRef(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); }
void cacheVisibleTo(com.google.gerrit.server.project.ChangeControl ctl) { visibleTo = ctl.getUser(); changeControl = ctl; }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want && (cd.changeControl().isPatchVisible(in, db.get()))) { res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo)); } } return res; } }
private java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes()); if (messages.isEmpty()) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(messages.size()); for (com.google.gerrit.reviewdb.client.ChangeMessage message : messages) { com.google.gerrit.reviewdb.client.PatchSet.Id patchNum = message.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet ps = (patchNum != null) ? map.get(patchNum) : null; if ((patchNum == null) || (cd.changeControl().isPatchVisible(ps, db.get()))) { com.google.gerrit.extensions.common.ChangeMessageInfo cmi = new com.google.gerrit.extensions.common.ChangeMessageInfo(); cmi.id = message.getKey().get(); cmi.author = accountLoader.get(message.getAuthor()); cmi.date = message.getWrittenOn(); cmi.message = message.getMessage(); cmi.tag = message.getTag(); cmi._revisionNumber = (patchNum != null) ? patchNum.get() : null; com.google.gerrit.reviewdb.client.Account.Id realAuthor = message.getRealAuthor(); if (realAuthor != null) { cmi.realAuthor = accountLoader.get(realAuthor); } result.add(cmi); } } return result; }
private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.index.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.index.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.index.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.List<com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); com.google.gerrit.server.change.ChangeJson cjson = json.create(options); cjson.setPluginDefinedAttributesFactory(this.imp); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = cjson.lazyLoad(com.google.gerrit.server.query.change.QueryChanges.containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if (results.get(n).more()) { info.get(((info.size()) - 1))._moreChanges = true; } } return res; }




@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.server.project.SetDashboard.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId id = externalIds.get(who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }






@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot deactivate own account"); } java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().atomicUpdate(dbProvider.get(), rsrc.getUser().getAccountId(), ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().atomicUpdate(dbProvider.get(), rsrc.getUser().getAccountId(), ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }



@org.junit.Test public void cannotMuteOwnChange() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("cannot mute own change"); gApi.changes().id(changeId).mute(true); }
@java.lang.Override public void mute(boolean mute) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (mute) { this.mute.apply(change, new com.google.gerrit.server.change.Mute.Input()); } else { unmute.apply(change, new com.google.gerrit.server.change.Unmute.Input()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot mute change", e); } }
private static java.lang.String getMuteLabel(com.google.gerrit.reviewdb.client.Change change) { return ((com.google.gerrit.server.StarredChangesUtil.MUTE_LABEL) + "/") + (change.currentPatchSetId().get()); }
public void mute(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.server.StarredChangesUtil.IllegalLabelException, com.google.gwtorm.server.OrmException { star(rsrc.getUser().asIdentifiedUser().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.getMuteLabel(rsrc.getChange())), com.google.common.collect.ImmutableSet.of()); }
private static void checkMutuallyExclusiveLabels(java.util.Set<java.lang.String> labels) throws com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException { if (labels.containsAll(com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL))) { throw new com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL); } }
private static com.google.gerrit.server.StarredChangesUtil.StarRef readLabels(org.eclipse.jgit.lib.Repository repo, java.lang.String refName) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); if (ref == null) { return com.google.gerrit.server.StarredChangesUtil.StarRef.MISSING; } try (org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader()) { org.eclipse.jgit.lib.ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB); return com.google.gerrit.server.StarredChangesUtil.StarRef.create(ref, com.google.common.base.Splitter.on(com.google.common.base.CharMatcher.whitespace()).omitEmptyStrings().split(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8))); } }




@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { try { com.google.gerrit.server.List<java.lang.Module> modules = new java.util.ArrayList(); com.google.inject.Injector modulesInjector = injector; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { modulesInjector = injector.createChildInjector(); for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { java.lang.Class<java.lang.Module> mClass = ((java.lang.Class<java.lang.Module>) (loader.loadClass(moduleName))); modules.add(modulesInjector.getInstance(mClass)); } } return modulesInjector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { try { return injector.createChildInjector().getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { com.google.gerrit.server.List<java.lang.Module> modules = new java.util.ArrayList(); try { if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { try { java.lang.Class<?> moduleClass = loader.loadClass(moduleName); modules.add(((java.lang.Module) (moduleClass.getConstructor().newInstance()))); } catch (java.lang.NoSuchMethodException | java.lang.InstantiationException | java.lang.IllegalAccessException | java.lang.reflect.InvocationTargetException e) { } } } return injector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: unable to check permissions " + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(projectControl.getProjectState(), repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) { org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(preUploadHooks))); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); return up; }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(com.google.gerrit.acceptance.InProcessProtocol.Context req, org.eclipse.jgit.lib.Repository repo) throws org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException { threadContext.setContext(req); com.google.gerrit.acceptance.InProcessProtocol.current.set(req); try { permissionBackend.user(userProvider).project(req.project).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException(); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.RuntimeException(e); } com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(req.project); } catch (java.io.IOException e) { throw new java.lang.RuntimeException(e); } if (projectState == null) { throw new java.lang.RuntimeException(("can't load project state for " + (req.project.get()))); } org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(transferConfig.getPackConfig()); up.setTimeout(transferConfig.getTimeout()); up.setAdvertiseRefsHook(refFilterFactory.create(projectState, repo)); java.util.List<org.eclipse.jgit.transport.PreUploadHook> hooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); hooks.add(uploadValidatorsFactory.create(projectState.getProject(), repo, "localhost-test")); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(hooks)); return up; }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> out; try { out = query(); } catch (com.google.gerrit.server.query.QueryParseException e) { java.util.regex.Pattern p = java.util.regex.Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$"); java.util.regex.Matcher m = p.matcher(e.getMessage()); if (m.matches()) { java.lang.String op = m.group(1); throw new com.google.gerrit.extensions.restapi.AuthException(("Must be signed-in to use " + op)); } throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage(), e); } return (out.size()) == 1 ? out.get(0) : out; }

@org.junit.Test public void create() throws java.lang.Exception { create(2); }



@org.junit.Test @com.google.gerrit.acceptance.UseSsh public void createWithSshKeys() throws java.lang.Exception { create(3); }


@com.google.inject.Provides java.util.Collection<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>> getIndexDefinitions(com.google.gerrit.server.index.account.AccountIndexDefinition accounts, com.google.gerrit.server.index.change.ChangeIndexDefinition changes, com.google.gerrit.server.index.group.GroupIndexDefinition groups) { java.util.Collection<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>> result = com.google.common.collect.ImmutableList.<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>>of(accounts, groups, changes); java.util.Set<java.lang.String> expected = com.google.common.collect.FluentIterable.from(com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet(); java.util.Set<java.lang.String> actual = com.google.common.collect.FluentIterable.from(result).transform(IndexDefinition::getName).toSet(); if (!(expected.equals(actual))) { throw new com.google.inject.ProvisionException(((("need index definitions for all schemas: " + expected) + " != ") + actual)); } return result; }




@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(cmd)) { logDebug("Reloading project in cache"); projectCache.evict(project); com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug("Updating project description"); repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(("cannot update description of " + (project.getName())), e); } } }
@java.lang.Override public void evict(com.google.gerrit.reviewdb.client.Project p) { if (p != null) { byName.invalidate(p.getNameKey().get()); } }



private org.eclipse.jgit.lib.Repository openRepository(java.nio.file.Path path, com.google.gerrit.reviewdb.client.Project.NameKey name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } java.io.File gitDir = path.resolve(name.get()).toFile(); if (!(names.contains(name))) { if (!(name.get().endsWith(Constants.DOT_GIT_EXT))) { if ((org.eclipse.jgit.lib.RepositoryCache.FileKey.resolve(gitDir, FS.DETECTED)) != null) { onCreateProject(name); } else { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(gitDir); } } else { final java.io.File directory = gitDir; if (org.eclipse.jgit.lib.RepositoryCache.FileKey.isGitRepository(new java.io.File(directory, org.eclipse.jgit.lib.Constants.DOT_GIT), FS.DETECTED)) { onCreateProject(name); } else if (org.eclipse.jgit.lib.RepositoryCache.FileKey.isGitRepository(new java.io.File(directory.getParentFile(), ((directory.getName()) + (org.eclipse.jgit.lib.Constants.DOT_GIT_EXT))), FS.DETECTED)) { onCreateProject(name); } else { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(gitDir); } } } final org.eclipse.jgit.lib.RepositoryCache.FileKey loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.lenient(gitDir, FS.DETECTED); try { return org.eclipse.jgit.lib.RepositoryCache.open(loc); } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot open repository " + name)); e2.initCause(e1); throw e2; } }
private void setAccount() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { user = genericUserFactory.create(id); rsrc = new com.google.gerrit.server.account.AccountResource(user); try { for (java.lang.String email : addEmails) { addEmail(email); } for (java.lang.String email : deleteEmails) { deleteEmail(email); } if ((preferredEmail) != null) { putPreferred(preferredEmail); } if ((fullName) != null) { com.google.gerrit.server.account.PutName.Input in = new com.google.gerrit.server.account.PutName.Input(); in.name = fullName; putName.apply(rsrc, in); } if (((httpPassword) != null) || (clearHttpPassword)) { com.google.gerrit.server.account.PutHttpPassword.Input in = new com.google.gerrit.server.account.PutHttpPassword.Input(); in.httpPassword = httpPassword; putHttpPassword.apply(rsrc, in); } if (active) { putActive.apply(rsrc, null); } else if (inactive) { try { deleteActive.apply(rsrc, null); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } addSshKeys = readSshKey(addSshKeys); if (!(addSshKeys.isEmpty())) { addSshKeys(addSshKeys); } deleteSshKeys = readSshKey(deleteSshKeys); if (!(deleteSshKeys.isEmpty())) { deleteSshKeys(deleteSshKeys); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { newPassword = null; } else { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> load(com.google.gerrit.reviewdb.client.AccountGroup.Id key) throws java.lang.Exception { return groupQueryProvider.get().byId(key); }

@java.lang.Override public java.lang.String formQueryFromRequestParameters(java.util.Map<java.lang.String, java.lang.String> params) throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { if (params == null) { return getDefaultQuery(); } java.util.Date[] dates; try { dates = parseDates(params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_ONE), params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_TWO)); } catch (java.text.ParseException e) { throw new com.ericsson.gerrit.plugins.eventslog.MalformedQueryException(e); } return java.lang.String.format("SELECT * FROM %s WHERE %s BETWEEN '%s' and '%s' LIMIT %d", com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME, com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.DATE_ENTRY, com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.DATE_TIME_FORMAT.get().format(dates[0]), com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.DATE_TIME_FORMAT.get().format(dates[1]), returnLimit); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error("Couldn't fire event", e); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want && (ctl.isVisible(db.get()))) { res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo)); } } return res; } }

public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null); accountLoader.fill(); return rev; } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> makeFetchMap(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> r = new java.util.LinkedHashMap<>(); com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous); for (com.google.gerrit.extensions.registration.DynamicMap.Entry<com.google.gerrit.extensions.config.DownloadScheme> e : downloadSchemes) { java.lang.String schemeName = e.getExportName(); com.google.gerrit.extensions.config.DownloadScheme scheme = e.getProvider().get(); if ((!(scheme.isEnabled())) || ((scheme.isAuthRequired()) && (!(userProvider.get().isIdentifiedUser())))) { continue; } if ((!(scheme.isAuthSupported())) && (!(ctl.isVisible(db.get())))) { continue; } java.lang.String projectName = cd.project().get(); java.lang.String url = scheme.getUrl(projectName); java.lang.String refName = in.getRefName(); com.google.gerrit.extensions.common.FetchInfo fetchInfo = new com.google.gerrit.extensions.common.FetchInfo(url, refName); r.put(schemeName, fetchInfo); if (has(com.google.gerrit.server.change.DOWNLOAD_COMMANDS)) { com.google.gerrit.server.change.ChangeJson.populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo); } } return r; }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error("Couldn't fire event", e); } }


private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().isUseSignedOffBy())); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private boolean isOwnerOfProjectOrBranch(com.google.gerrit.reviewdb.client.Account.Id user) { return ((projectState) != null) && (projectState.controlFor(args.identifiedUserFactory.create(user)).controlForRef(change.getDest()).isOwner()); }

private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isInternalUser()) || (canPerformOnAnyRef(Permission.READ)))) || (isOwner()); case READ : return (!(isHidden())) && (allRefsAreVisible(java.util.Collections.emptySet())); case READ_NO_CONFIG : return (!(isHidden())) && (allRefsAreVisible(com.google.common.collect.ImmutableSet.of(RefNames.REFS_CONFIG))); case CREATE_REF : return canAddRefs(); case CREATE_CHANGE : return canCreateChanges(); case RUN_RECEIVE_PACK : return canRunReceivePack(); case RUN_UPLOAD_PACK : return canRunUploadPack(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } try { com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } } return r; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.FixInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((!(rsrc.isUserOwner())) && (!(projectControlFactory.controlFor(rsrc.getProject(), rsrc.getUser()).isOwner()))) { permissionBackend.user(user).check(GlobalPermission.MAINTAIN_SERVER); } return com.google.gerrit.extensions.restapi.Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc)); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to project owner"); } return apply(rsrc.getProjectState(), input); }
@org.junit.Test public void nonOwnerCannotSetConfig() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ConfigInput input = createTestConfigInput(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("restricted to project owner"); gApi.projects().name(project.get()).config(input); }
@java.lang.Override public java.lang.String format(org.apache.log4j.spi.LoggingEvent event) { final java.lang.StringBuffer buf = new java.lang.StringBuffer(128); buf.append('['); formatDate(event.getTimeStamp(), buf); buf.append(' '); buf.append(timeZone); buf.append(']'); buf.append(' '); buf.append(event.getLevel().toString()); req(DeleteLog.ACCOUNT_ID, buf, event); req(DeleteLog.USER_NAME, buf, event); buf.append(' '); buf.append(event.getMessage()); req(DeleteLog.PROJECT_NAME, buf, event); opt(DeleteLog.OPTIONS, buf, event); opt(DeleteLog.ERROR, buf, event); buf.append('\n'); return buf.toString(); }
private void formatDate(final long now, final java.lang.StringBuffer sbuf) { final int millis = ((int) (now % 1000)); final long rounded = now - millis; if (rounded != (lastTimeMillis)) { synchronized(calendar) { final int start = sbuf.length(); calendar.setTimeInMillis(rounded); sbuf.append(calendar.get(java.util.Calendar.YEAR)); sbuf.append('-'); sbuf.append(toTwoDigits(((calendar.get(java.util.Calendar.MONTH)) + 1))); sbuf.append('-'); sbuf.append(toTwoDigits(calendar.get(java.util.Calendar.DAY_OF_MONTH))); sbuf.append(' '); sbuf.append(toTwoDigits(calendar.get(java.util.Calendar.HOUR_OF_DAY))); sbuf.append(':'); sbuf.append(toTwoDigits(calendar.get(java.util.Calendar.MINUTE))); sbuf.append(':'); sbuf.append(toTwoDigits(calendar.get(java.util.Calendar.SECOND))); sbuf.append(','); sbuf.getChars(start, sbuf.length(), lastTimeString, 0); lastTimeMillis = rounded; } } else { sbuf.append(lastTimeString); } sbuf.append(java.lang.String.format("%03d", millis)); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change = cd.change(); if (change == null) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gwtorm.server.OrmException("unable to check permissions", e); } if (visible) { cd.cacheVisibleTo(user); return true; } return false; }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> toAccounts(java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, com.google.gerrit.extensions.common.AccountInfo uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); com.google.gerrit.server.account.GroupMembers groupMembers = null; for (java.lang.String r : in) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(r); if (account != null) { reviewers.add(account); continue; } } catch (com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.error(("Failed to resolve account " + r), e); continue; } if (groupMembers == null) { java.lang.String uploaderNameEmail = java.lang.String.format("%s <%s>", uploader.name, uploader.email); try { com.google.gerrit.reviewdb.client.Account uploaderAccount = accountResolver.findByNameOrEmail(uploaderNameEmail); if (uploaderAccount != null) { groupMembers = groupMembersFactory.create(identifiedUserFactory.create(uploaderAccount.getId())); } } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s, cannot retrieve uploader account %s", r, uploaderNameEmail), e); } try { if (groupMembers != null) { reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p)); } else { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s; cannot retrieve uploader account for %s", r, uploader.email)); } } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Reviewer %s is neither an account nor a group", r)); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s and project %s", r, p)); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s", r), e); } } } return reviewers; }
com.google.gerrit.server.git.receive.ReplaceOp create(com.google.gerrit.server.project.ProjectControl projectControl, com.google.gerrit.reviewdb.client.Branch.NameKey dest, boolean checkMergedInto, @com.google.inject.assistedinject.Assisted("priorPatchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id priorPatchSetId, @com.google.inject.assistedinject.Assisted("priorCommitId") org.eclipse.jgit.lib.ObjectId priorCommit, @com.google.inject.assistedinject.Assisted("patchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, @com.google.inject.assistedinject.Assisted("commitId") org.eclipse.jgit.lib.ObjectId commitId, com.google.gerrit.reviewdb.client.PatchSetInfo info, java.util.List<java.lang.String> groups, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.receive.ReceiveCommits.MagicBranchInput magicBranch, @com.google.gerrit.common.Nullable org.eclipse.jgit.transport.PushCertificate pushCertificate);
void addOps(com.google.gerrit.server.update.BatchUpdate bu, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.MultiProgressMonitor.Task progress) throws java.io.IOException { if (((magicBranch) != null) && ((magicBranch.edit) || (magicBranch.draft))) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ReceiveCommits.ReindexOnlyOp()); if ((prev) != null) { bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(prev)); } bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(cmd)); return; } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit newCommit = rw.parseCommit(newCommitId); rw.parseBody(newCommit); org.eclipse.jgit.revwalk.RevCommit priorCommit = revisions.inverse().get(priorPatchSet); replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator); bu.addOp(notes.getChangeId(), replaceOp); if (progress != null) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ChangeProgressOp(progress)); } }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: unable to check permissions " + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(projectControl.getProjectState(), repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(projectControl.getProject().getNameKey(), up); } try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
private void index(com.google.gerrit.server.project.ProjectControl projectControl) { try { index.apply(new com.google.gerrit.server.project.ProjectResource(projectControl.getProjectState(), projectControl.getUser()), null); } catch (java.lang.Exception e) { writeError("error", java.lang.String.format("Unable to index %s: %s", projectControl.getProject().getName(), e.getMessage())); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectControl.getProjectState(), projectControl.getUser()), input); printCommits(r.newlyBanned, "The following commits were banned"); printCommits(r.alreadyBanned, "The following commits were already banned"); printCommits(r.ignored, "The following ids do not represent commits and were ignored"); } catch (java.lang.Exception e) { throw die(e); } }

public java.util.List<com.google.gerrit.extensions.common.GroupInfo> get() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (!(com.google.common.base.Strings.isNullOrEmpty(suggest))) { return suggestGroups(); } if ((!(com.google.common.base.Strings.isNullOrEmpty(matchSubstring))) && (!(com.google.common.base.Strings.isNullOrEmpty(matchRegex)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Specify one of m/r"); } if (owned) { return getGroupsOwnedBy(((user) != null ? userFactory.create(user) : identifiedUser.get())); } if ((user) != null) { return accountGetGroups.apply(new com.google.gerrit.server.account.AccountResource(userFactory.create(user))); } return getAllGroups(); }





private void checkLabels(com.google.gerrit.server.change.RevisionResource rsrc, boolean strict, java.util.Map<java.lang.String, java.lang.Short> labels) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.common.data.LabelTypes types = rsrc.getControl().getLabelTypes(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions(); java.util.Iterator<java.util.Map.Entry<java.lang.String, java.lang.Short>> itr = labels.entrySet().iterator(); while (itr.hasNext()) { java.util.Map.Entry<java.lang.String, java.lang.Short> ent = itr.next(); com.google.gerrit.common.data.LabelType lt = types.byLabel(ent.getKey()); if (lt == null) { if (strict) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("label \"%s\" is not a configured label", ent.getKey())); } itr.remove(); continue; } if (((ent.getValue()) == null) || ((ent.getValue()) == 0)) { continue; } if ((lt.getValue(ent.getValue())) == null) { if (strict) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue())); } itr.remove(); continue; } short val = ent.getValue(); try { perm.check(new com.google.gerrit.server.permissions.LabelPermission.WithValue(lt, val)); } catch (com.google.gerrit.extensions.restapi.AuthException e) { if (strict) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Applying label \"%s\": %d is restricted", lt.getName(), val)); } ent.setValue(perm.squashThenCheck(lt, val)); } } }
protected static com.google.gerrit.acceptance.AbstractNotificationTest.FakeEmailSenderSubject assertThat(com.google.gerrit.testutil.FakeEmailSender sender) { return assertAbout(com.google.gerrit.acceptance.AbstractNotificationTest.FAKE_EMAIL_SENDER_SUBJECT_FACTORY).that(sender); }
public static com.google.gerrit.extensions.common.EditInfoSubject assertThat(com.google.gerrit.extensions.common.EditInfo editInfo) { return assertAbout(com.google.gerrit.extensions.common.EditInfoSubject.EDIT_INFO_SUBJECT_FACTORY).that(editInfo); }
public static com.google.gerrit.extensions.common.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.FixReplacementInfoSubject.FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common.FixSuggestionInfoSubject assertThat(com.google.gerrit.extensions.common.FixSuggestionInfo fixSuggestionInfo) { return assertAbout(com.google.gerrit.extensions.common.FixSuggestionInfoSubject.FIX_SUGGESTION_INFO_SUBJECT_FACTORY).that(fixSuggestionInfo); }
public static com.google.gerrit.extensions.common.GitPersonSubject assertThat(com.google.gerrit.extensions.common.GitPerson gitPerson) { return assertAbout(com.google.gerrit.extensions.common.GitPersonSubject.GIT_PERSON_SUBJECT_FACTORY).that(gitPerson); }
public static com.google.gerrit.extensions.common.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.RobotCommentInfoSubject.ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo); }
public static com.google.gerrit.extensions.restapi.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.BinaryResultSubject.BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult); }
public static com.google.gerrit.server.edit.tree.ChangeFileContentModificationSubject assertThat(com.google.gerrit.server.edit.tree.ChangeFileContentModification modification) { return assertAbout(com.google.gerrit.server.edit.tree.ChangeFileContentModificationSubject.MODIFICATION_SUBJECT_FACTORY).that(modification); }
public static com.google.gerrit.extensions.common.ContentEntrySubject assertThat(com.google.gerrit.extensions.common.DiffInfo.ContentEntry contentEntry) { return assertAbout(com.google.gerrit.extensions.common.ContentEntrySubject.DIFF_INFO_SUBJECT_FACTORY).that(contentEntry); }
public static com.google.gerrit.server.edit.tree.TreeModificationSubject assertThat(com.google.gerrit.server.edit.tree.TreeModification treeModification) { return assertAbout(com.google.gerrit.server.edit.tree.TreeModificationSubject.TREE_MODIFICATION_SUBJECT_FACTORY).that(treeModification); }
public static com.google.gerrit.extensions.common.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.CommitInfoSubject.COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo); }
public static com.google.gerrit.extensions.client.RangeSubject assertThat(com.google.gerrit.extensions.client.Comment.Range range) { return assertAbout(com.google.gerrit.extensions.client.RangeSubject.RANGE_SUBJECT_FACTORY).that(range); }
public static com.google.gerrit.extensions.common.FileInfoSubject assertThat(com.google.gerrit.extensions.common.FileInfo fileInfo) { return assertAbout(com.google.gerrit.extensions.common.FileInfoSubject.FILE_INFO_SUBJECT_FACTORY).that(fileInfo); }
public static com.google.gerrit.extensions.common.PathSubject assertThat(java.nio.file.Path path) { return assertAbout(com.google.gerrit.extensions.common.PathSubject.PATH_SUBJECT_FACTORY).that(path); }
public static com.google.gerrit.extensions.common.DiffInfoSubject assertThat(com.google.gerrit.extensions.common.DiffInfo diffInfo) { return assertAbout(com.google.gerrit.extensions.common.DiffInfoSubject.DIFF_INFO_SUBJECT_FACTORY).that(diffInfo); }
static java.lang.String getOwnersFileName(com.google.gerrit.reviewdb.client.Project.NameKey project) { if (((com.googlesource.gerrit.plugins.findowners.Config.config) != null) && (project != null)) { try { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS); if (name.trim().equals("")) { com.googlesource.gerrit.plugins.findowners.Config.log.error((((((("Project " + (project.get())) + " has wrong ") + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) + ": \"") + name) + "\"")); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.findowners.Config.log.error(("Cannot find project: " + project), e); } } return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { for (com.google.gerrit.reviewdb.client.AccountGroup.Id id : scanSystemGroups(db)) { com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(id); if ((group != null) && (com.google.gerrit.server.group.SystemGroupBackend.isSystemGroup(group.getGroupUUID()))) { db.accountGroups().delete(java.util.Collections.singleton(group)); db.accountGroupNames().deleteKeys(java.util.Collections.singleton(group.getNameKey())); } } }
@org.junit.Before public void setUp() throws java.lang.Exception { testEnv.getInjector().injectMembers(this); db = testEnv.getDb(); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().all().toList(); for (com.google.gerrit.reviewdb.client.AccountGroup accountGroup : accountGroups) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId()); java.util.Optional<java.sql.Timestamp> firstTimeMentioned = com.google.common.collect.Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(java.util.Comparator.naturalOrder()); java.sql.Timestamp createdOn = firstTimeMentioned.orElseGet(() -> com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); accountGroup.setCreatedOn(createdOn); } db.accountGroups().update(accountGroups); }
public java.lang.String getChangeMessageThreadId() throws com.google.gerrit.common.errors.EmailException { return velocify("<gerrit.${change.createdOn.time}.$change.key.get()@$email.gerritHost>"); }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); setListIdHeader(); }

@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections("remote")) { java.lang.String url = cfg.getString("remote", name, "url"); if (com.google.common.base.Strings.isNullOrEmpty(url)) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("remote.{}.url not defined, skipping this remote", name); continue; } if (shouldPost(projectEvent, cfg.getStringList("remote", name, "event"))) { post(url, projectEvent); } } }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY); }
@org.junit.Test public void nonProjectEventNotPosted() { config.setString(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.REMOTE, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.URL, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO_URL); com.google.gerrit.server.events.Event nonProjectEvent = new com.google.gerrit.server.events.Event("non-project-event") {}; eventHandler.onEvent(nonProjectEvent); verifyZeroInteractions(postTask); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(@com.google.inject.assistedinject.Assisted("url") java.lang.String url, @com.google.inject.assistedinject.Assisted("body") java.lang.String body);
@org.junit.Test public void remoteUrlUndefinedEventsNotPosted() { eventHandler.onEvent(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_CREATED); verifyZeroInteractions(postTask); }
@org.junit.Test public void specifiedEventTypesPosted() { config.setString(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.REMOTE, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.URL, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO_URL); config.setString(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.REMOTE, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.EVENT, "project-created"); eventHandler.onEvent(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_CREATED); verify(postTask, times(1)).schedule(); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(taskFactory.create(anyString(), anyString())).thenReturn(postTask); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, taskFactory); }



@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class); bind(com.googlesource.gerrit.plugins.webhooks.Configuration.class).in(Scopes.SINGLETON); bind(org.apache.http.impl.client.CloseableHttpClient.class).toProvider(com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class).in(Scopes.SINGLETON); factory(PostTask.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); }
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if (id.matches((("^([0-9a-fA-F]{4," + (com.google.gerrit.reviewdb.client.RevId.LEN)) + "})$"))) { return asChangeControls(query.byCommit(id), user); } if ((!(id.isEmpty())) && ((id.charAt(0)) != '0')) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return asChangeControls(query.byLegacyChangeId(new com.google.gerrit.reviewdb.client.Change.Id(n)), user); } } if (!(id.contains("~"))) { return asChangeControls(query.byKeyPrefix(id), user); } java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id); if (triplet.isPresent()) { return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user); } return java.util.Collections.emptyList(); }
@java.lang.Override public void setStatus(java.lang.String status) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.PutStatus.Input in = new com.google.gerrit.server.account.PutStatus.Input(status); try { putStatus.apply(account, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot set status", e); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.server.account.PutStatus.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.server.account.PutStatus.Input(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> a.setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getStatus()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutStatus.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } return apply(rsrc.getUser(), input); }


@org.junit.Test public void normalizeByPermission() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); allow(pc, forLabel("Verified"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 2); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(v), com.google.gerrit.server.git.LabelNormalizerTest.list(copy(cr, 1)), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
@org.junit.Test public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 0); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 0); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(cr), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list(v)), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }

@org.junit.Test public void emptyPermissionRangeOmitsResult() throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 1); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v)), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
public java.lang.String getFunctionName() { return functionName; }
public void setFunctionName(java.lang.String functionName) { this.functionName = functionName; }
@org.junit.Test public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(2); int indexAdmin = (admin.fullName.equals(cr.all.get(0).name)) ? 0 : 1; int indexUser = (indexAdmin == 0) ? 1 : 0; assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName); assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1); assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName); assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1."); assertThatUserIsOnlyReviewer(ci, admin); }
@org.junit.Test public void pushNewPatchSetForMasterWithApprovals() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master"); r.assertOkStatus(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to("refs/for/master/%l=Code-Review+2"); ChangeInfo ci = get(r.getChangeId()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2."); assertThatUserIsOnlyReviewer(ci, admin); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value).isEqualTo(2); }
@org.junit.Test public void pushWithMultipleApprovals() throws java.lang.Exception { com.google.gerrit.common.data.LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value((-1), "Negative")); com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet(project).getConfig(); com.google.gerrit.reviewdb.client.AccountGroup.UUID anon = systemGroupBackend.getGroup(com.google.gerrit.acceptance.git.ANONYMOUS_USERS).getUUID(); java.lang.String heads = "refs/heads/*"; com.google.gerrit.server.project.Util.allow(config, com.google.gerrit.common.data.Permission.forLabel("Custom-Label"), (-1), 1, anon, heads); config.getLabelSections().put(Q.getName(), Q); saveProjectConfig(project, config); org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()); com.google.gerrit.extensions.common.LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); cr = ci.labels.get("Custom-Label"); assertThat(cr.all).hasSize(1); assertThatUserIsOnlyReviewer(ci, admin); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeDeletions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("is-draft", java.lang.Boolean.toString(patchSetAttribute.isDraft))); properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "author")); return properties; }




public java.util.Map<java.lang.String, java.util.Set<java.lang.String>> getIssueIds(java.lang.String projectName, java.lang.String commitId, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> current = getIssueIds(projectName, commitId); if (patchSetId != null) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> previous = com.google.common.collect.Maps.newHashMap(); if ((patchSetId.get()) != 1) { com.google.gerrit.reviewdb.client.PatchSet.Id previousPatchSetId = new com.google.gerrit.reviewdb.client.PatchSet.Id(patchSetId.getParentKey(), ((patchSetId.get()) - 1)); try { com.google.gerrit.reviewdb.client.PatchSet previousPatchSet = db.patchSets().get(previousPatchSetId); if (previousPatchSet != null) { previous = getIssueIds(projectName, previousPatchSet.getRevision().get()); } } catch (com.google.gwtorm.server.OrmException e) { } } for (java.lang.String issue : current.keySet()) { java.util.Set<java.lang.String> currentOccurrences = current.get(issue); java.util.Set<java.lang.String> previousOccurrences = previous.get(issue); java.util.Set<java.lang.String> newOccurrences; if ((previousOccurrences == null) || (previousOccurrences.isEmpty())) { newOccurrences = com.google.common.collect.Sets.newHashSet(currentOccurrences); } else { newOccurrences = com.google.common.collect.Sets.newHashSet(currentOccurrences); newOccurrences.removeAll(previousOccurrences); } for (java.lang.String occurrence : newOccurrences) { currentOccurrences.add(("added@" + occurrence)); } } } return current; }
@java.lang.Override protected void configure() { itsConfig = createMock(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class); bind(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(itsConfig); commitMessageFetcher = createMock(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class); bind(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class).toInstance(commitMessageFetcher); db = createMock(com.google.gerrit.reviewdb.server.ReviewDb.class); bind(com.google.gerrit.reviewdb.server.ReviewDb.class).toInstance(db); }
@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp(); injector = com.google.inject.Guice.createInjector(new com.googlesource.gerrit.plugins.its.base.util.IssueExtractorTest.TestModule()); }

com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(java.lang.String endpoint, java.lang.String content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(endpoint); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); post.setEntity(new org.apache.http.entity.StringEntity(content, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public void run() { try { java.lang.String content = body.get(); if (com.google.common.base.Strings.isNullOrEmpty(content)) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", url); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(url, content); if ((!(result.successful)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
@java.lang.Override public java.lang.String toString() { return body.get(); }
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public java.lang.String process() { return com.googlesource.gerrit.plugins.webhooks.processors.JenkinsEventProcessor.GSON.toJson(event); }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(processor.process()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, processor); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws java.io.IOException { for (com.google.gerrit.index.Index<?, com.google.gerrit.server.project.ProjectData> i : getWriteIndexes()) { i.replace(projectCache.get(nameKey).toProjectData()); } fireProjectIndexedEvent(nameKey.get()); }
@org.junit.Test public void addReviewerThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); fail("Expected ResourceNotFoundException"); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } setApiUser(admin); com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = user.email; com.google.gerrit.extensions.api.changes.AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in); assertThat(r.input).isEqualTo(user.email); assertThat(r.error).contains("does not have permission to see this change"); assertThat(r.reviewers).isNull(); }
@org.junit.Test public void fetchExternalIdsBranch() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, user); try { com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); fail("expected TransportException"); } catch (org.eclipse.jgit.api.errors.TransportException e) { assertThat(e.getMessage()).isEqualTo((("Remote does not have " + (com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS)) + " available for fetch.")); } allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); allUsersRepo = cloneProject(allUsers, user); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); }
@org.junit.Test public void addInvalidEmail() throws java.lang.Exception { java.util.List<java.lang.String> emails = com.google.common.collect.ImmutableList.of("new.email", "new.email@", "@example.com", "new.email@example.africa"); for (java.lang.String email : emails) { com.google.gerrit.extensions.api.accounts.EmailInput input = newEmailInput(email); try { gApi.accounts().self().addEmail(input); fail(("Expected BadRequestException for invalid email address: " + email)); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { assertThat(e).hasMessageThat().isEqualTo("invalid email address"); } } accountIndexedCounter.assertNoReindex(); }
@org.junit.Test public void deactivateNotActive() throws java.lang.Exception { assertThat(gApi.accounts().id("user").getActive()).isTrue(); gApi.accounts().id("user").setActive(false); assertThat(gApi.accounts().id("user").getActive()).isFalse(); try { gApi.accounts().id("user").setActive(false); fail("Expected exception"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e.getMessage()).isEqualTo("account not active"); } gApi.accounts().id("user").setActive(true); }
@org.junit.Test public void failWhenWritesDisabled() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); assertThat(gApi.changes().id(id.get()).info().topic).isNull(); setNotesMigration(false, true); try { gApi.changes().id(id.get()).topic(name("a-topic")); fail("Expected write to fail"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isNull(); assertChangeUpToDate(true, id); }
@org.junit.Test public void rebuildWhenWritesDisabledWorksButDoesNotWrite() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); setNotesMigration(false, false); gApi.changes().id(id.get()).topic(name("a-topic")); setInvalidNoteDbState(id); assertChangeUpToDate(false, id); setNotesMigration(false, true); assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); try { gApi.changes().id(id.get()).topic(name("other-topic")); fail("Expected write to fail"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); }
private void assertBadRequest(com.google.gerrit.extensions.api.plugins.Plugins.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.TagInfo> req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.BranchInfo> req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
@org.junit.Test public void deleteBranchesNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); branches.add("refs/heads/does-not-exist"); input.branches = branches; try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void pushCommitOfOtherUserThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); ChangeInfo change = gApi.changes().id(result.getChangeId()).get(); assertThat(change.owner._accountId).isEqualTo(admin.id.get()); com.google.gerrit.extensions.common.CommitInfo commit = change.revisions.get(change.currentRevision).commit; assertThat(commit.author.email).isEqualTo(user.email); assertThat(commit.committer.email).isEqualTo(user.email); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); fail("Expected ResourceNotFoundException"); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.REVIEWER)).isNull(); assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.CC)).isNull(); assertThat(sender.getMessages()).isEmpty(); }
@org.junit.Test public void deleteBranchesNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList("refs/heads/does-not-exist"); branches.addAll(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); input.branches = branches; try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void mixingSubmitTypesOnOneBranchFails() throws java.lang.Exception { setRulesPl(com.google.gerrit.acceptance.api.change.SubmitTypeRuleIT.SUBMIT_TYPE_FROM_SUBJECT); com.google.gerrit.acceptance.PushOneCommit.Result r1 = createChange("master", "CHERRY_PICK 1"); com.google.gerrit.acceptance.PushOneCommit.Result r2 = createChange("master", "MERGE_IF_NECESSARY 2"); gApi.changes().id(r1.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r2.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); try { gApi.changes().id(r2.getChangeId()).current().submit(); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(((((((("Failed to submit 2 changes due to the following problems:\n" + "Change ") + (r1.getChange().getId())) + ": Change has submit type ") + "CHERRY_PICK, but previously chose submit type MERGE_IF_NECESSARY ") + "from change ") + (r2.getChange().getId())) + " in the same batch")); } }
@org.junit.Test public void deleteTagsNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList("refs/tags/does-not-exist"); tags.addAll(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); input.tags = tags; try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); tags.add("refs/tags/does-not-exist"); input.tags = tags; try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); input.tags = com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS; setApiUser(user); try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS)); } setApiUser(admin); assertTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); }
private java.lang.String cherryPick(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case REWORK : case TRIVIAL_REBASE : break; case NO_CODE_CHANGE : case NO_CHANGE : case MERGE_FIRST_PARENT_UPDATE : default : fail(("unexpected change kind: " + changeKind)); } testRepo.reset(getRemoteHead()); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "other.txt", ("new content " + (java.lang.System.nanoTime()))).to("refs/for/master"); r.assertOkStatus(); vote(admin, r.getChangeId(), 2, 1); merge(r); java.lang.String subject = (com.google.gerrit.acceptance.api.change.TRIVIAL_REBASE.equals(changeKind)) ? com.google.gerrit.acceptance.PushOneCommit.SUBJECT : "Reworked change " + (java.lang.System.nanoTime()); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "master"; in.message = java.lang.String.format("%s\n\nChange-Id: %s", subject, changeId); com.google.gerrit.extensions.common.ChangeInfo c = gApi.changes().id(changeId).revision("current").cherryPick(in).get(); return c.changeId; }
private void updateChange(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case NO_CODE_CHANGE : noCodeChange(changeId); return; case REWORK : rework(changeId); return; case TRIVIAL_REBASE : trivialRebase(changeId); return; case MERGE_FIRST_PARENT_UPDATE : updateFirstParent(changeId); return; case NO_CHANGE : noChange(changeId); return; default : fail(("unexpected change kind: " + changeKind)); } }
private void assertBadRequest(com.google.gerrit.extensions.api.groups.Groups.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
protected void submit(java.lang.String changeId, com.google.gerrit.extensions.api.changes.SubmitInput input, java.lang.Class<? extends com.google.gerrit.extensions.restapi.RestApiException> expectedExceptionType, java.lang.String expectedExceptionMsg) throws java.lang.Exception { approve(changeId); if (expectedExceptionType == null) { assertSubmittable(changeId); } try { gApi.changes().id(changeId).current().submit(input); if (expectedExceptionType != null) { fail(("Expected exception of type " + (expectedExceptionType.getSimpleName()))); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { if (expectedExceptionType == null) { throw e; } if ((!(expectedExceptionType.isAssignableFrom(e.getClass()))) || (!(e.getMessage().equals(expectedExceptionMsg)))) { throw new java.lang.AssertionError((((((((("Expected exception of type " + (expectedExceptionType.getSimpleName())) + " with message: \"") + expectedExceptionMsg) + "\" but got exception of type ") + (e.getClass().getSimpleName())) + " with message \"") + (e.getMessage())) + "\""), e); } return; } com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).info(); assertMerged(change.changeId); }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.Projects.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException expected) { } }
@org.junit.Test public void deleteBranchesForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); input.branches = com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES; setApiUser(user); try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES)); } setApiUser(admin); assertBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); }
@org.junit.Test public void createChangeRespectsCLA() throws java.lang.Exception { assume().that(isContributorAgreementsEnabled()).isTrue(); setUseContributorAgreements(InheritableBoolean.FALSE); gApi.changes().create(newChangeInput()); setUseContributorAgreements(InheritableBoolean.TRUE); try { gApi.changes().create(newChangeInput()); fail("Expected AuthException"); } catch (com.google.gerrit.extensions.restapi.AuthException e) { assertThat(e.getMessage()).contains("A Contributor Agreement must be completed"); } gApi.accounts().self().signAgreement(caAutoVerify.getName()); setApiUser(user); gApi.changes().create(newChangeInput()); }


public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.SUBGROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.SubgroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.EXTERNAL_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); } }; }

@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.SUBGROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.SubgroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.EXTERNAL_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); }


public static com.google.gerrit.extensions.common.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.RobotCommentInfoSubject.ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Ancient group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.testutil.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.testutil.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isAtLeast(testStartTime); }
public static com.google.gerrit.extensions.common.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.FixReplacementInfoSubject.FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.CommitInfoSubject.COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo); }
public static com.google.gerrit.extensions.restapi.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.BinaryResultSubject.BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult); }
private void createSubmoduleCommitMsg(java.lang.StringBuilder msgbuf, com.google.gerrit.reviewdb.client.SubmoduleSubscription s, com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo subOr, org.eclipse.jgit.revwalk.RevCommit newCommit, org.eclipse.jgit.revwalk.RevCommit oldCommit) throws com.google.gerrit.server.git.SubmoduleException { msgbuf.append(("* Update " + (s.getPath()))); msgbuf.append(((" from branch '" + (s.getSubmodule().getShortName())) + "'")); if (oldCommit == null) { return; } try { subOr.rw.resetRetain(subOr.canMergeFlag); subOr.rw.markStart(newCommit); subOr.rw.markUninteresting(oldCommit); for (org.eclipse.jgit.revwalk.RevCommit c : subOr.rw) { subOr.rw.parseBody(c); if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.SUBJECT_ONLY)) { msgbuf.append(("\n - " + (c.getShortMessage()))); } else if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.TRUE)) { msgbuf.append(("\n - " + (c.getFullMessage().replace("\n", "\n ")))); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException("Could not perform a revwalk to create superproject commit message", e); } }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections(com.googlesource.gerrit.plugins.webhooks.Configuration.REMOTE)) { java.lang.String url = cfg.getString(com.googlesource.gerrit.plugins.webhooks.Configuration.REMOTE, name, "url"); if (com.google.common.base.Strings.isNullOrEmpty(url)) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("remote.{}.url not defined, skipping this remote", name); continue; } com.googlesource.gerrit.plugins.webhooks.EventProcessor processor = processorFactory.create(projectEvent, cfg, name); if (processor.shouldProcess()) { post(url, processor); } } }
@org.junit.Test public void eventsNotSpecifiedAllEventsShouldPost() throws java.lang.Exception { when(config.getStringList(eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REMOTE), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.EVENT))).thenReturn(new java.lang.String[]{ }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, config, com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, config, com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO); actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(@com.google.inject.assistedinject.Assisted("url") java.lang.String url, com.googlesource.gerrit.plugins.webhooks.EventProcessor processor);
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Result> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", url); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(url, content.get().headers, content.get().body); if ((!(result.successful)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }


@java.lang.Override public boolean shouldProcess() { java.lang.String[] wantedEvents = cfg.getStringList(Configuration.REMOTE, name, "event"); if ((wantedEvents.length) == 0) { return true; } for (java.lang.String type : wantedEvents) { if ((!(com.google.common.base.Strings.isNullOrEmpty(type))) && (type.equals(event.getType()))) { return true; } } return false; }
@org.junit.Test public void specifiedEventTypesShouldPost() throws java.lang.Exception { when(config.getStringList(eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REMOTE), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.EVENT))).thenReturn(new java.lang.String[]{ "project-created" }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, config, com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(processor.process()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.CONTENT); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, processor); }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(java.lang.String endpoint, java.util.Map<java.lang.String, java.lang.String> headers, java.lang.String content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(endpoint); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); headers.entrySet().stream().forEach(( e) -> { post.addHeader(e.getKey(), e.getValue()); }); post.setEntity(new org.apache.http.entity.StringEntity(content, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(factory.create(any(com.google.gerrit.server.events.ProjectEvent.class), eq(config), eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO))).thenReturn(processor); when(taskFactory.create(anyString(), eq(processor))).thenReturn(postTask); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, taskFactory, factory); }
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void nonSpecifiedProjectEventTypesNotPosted() throws java.lang.Exception { when(config.getStringList(eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REMOTE), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO), eq(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.EVENT))).thenReturn(new java.lang.String[]{ "project-created" }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, config, com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.FOO); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isFalse(); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Result> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(remote.getUrl(), content.get().headers, remote, content.get().body); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
@org.junit.Before public void setup() { when(remote.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(remote.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.CONTENT); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, processor, projectCreated, remote); }




void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> additions) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("Cannot edit global capabilities for projects other than " + (allProjects.get()))); } } } for (com.google.gerrit.common.data.AccessSection section : additions) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (!isGlobalCapabilities) { if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid section name"); } com.google.gerrit.server.project.RefPattern.validate(name); } else { for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isCapability(p.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException((("Cannot add non-global capability " + (p.getName())) + " to global capabilities")); } } } } }

@java.lang.Override public RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); next = seed.get(); } else { oldId = ref.getObjectId(); next = parse(oldId); } return store(repo, rw, oldId, ((next) + (count))); }









private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = loadFor(groupUuid); if (!(groupConfig.getLoadedGroup().isPresent())) { return java.util.Optional.empty(); } return updateGroupInNoteDb(groupConfig, groupUpdate); }

private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.server.group.db.GroupConfig groupConfig, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.io.IOException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> originalGroup = groupConfig.getLoadedGroup(); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(groupConfig); com.google.gerrit.server.group.InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Updated group wasn't automatically loaded")); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> modifiedMembers = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedMembers(originalGroup, updatedGroup); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> modifiedSubgroups = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedSubgroups(originalGroup, updatedGroup); java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> previousName = com.google.gerrit.server.group.db.GroupsUpdate.getPreviousNameIfModified(originalGroup, updatedGroup); com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.Builder resultBuilder = com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups); previousName.ifPresent(resultBuilder::setPreviousGroupName); return java.util.Optional.of(resultBuilder.build()); }

@org.junit.Test public void createGroup() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(newGroupName).get(); com.google.gerrit.acceptance.api.group.GroupAssert.assertGroupInfo(getFromCache(newGroupName), g); }
@org.junit.Test public void createGroupWithProperties() throws java.lang.Exception { com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("newGroup"); in.description = "Test description"; in.visibleToAll = true; in.ownerId = getFromCache("Administrators").getGroupUUID().get(); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(in).detail(); assertThat(g.description).isEqualTo(in.description); assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll); assertThat(g.ownerId).isEqualTo(in.ownerId); }

@org.junit.Test public void groupOwner() throws java.lang.Exception { java.lang.String name = name("group"); com.google.gerrit.extensions.common.GroupInfo info = gApi.groups().create(name).get(); java.lang.String adminUUID = getFromCache("Administrators").getGroupUUID().get(); java.lang.String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get(); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id); gApi.groups().id(name).owner("Registered Users"); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID); gApi.groups().id(name).owner(adminUUID); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID); exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); gApi.groups().id(name).owner("Non-Existing Group"); }
private com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData load(int expectedValue) throws java.lang.Exception { com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData d = new com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData(); d.load(repo); assertThat(d.getValue()).isEqualTo(expectedValue); return d; }

@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); com.googlesource.gerrit.plugins.supermanifest.JiriProjects projects = com.googlesource.gerrit.plugins.supermanifest.JiriManifestParser.getProjects(srcRepo, srcRef, c.getXmlPath()); java.lang.String targetRef = (c.getDestBranch().equals("*")) ? srcRef : (REFS_HEADS) + (c.getDestBranch()); updateSubmodules(destRepo, targetRef, java.net.URI.create(((c.getDestRepoKey().toString()) + "/")), projects, reader); }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get()); if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }
@org.junit.Test public void createBranchByAdmin() throws java.lang.Exception { assertCreateSucceeds(); }
@org.junit.Test public void createBranchByAdminCreateReferenceBlocked_Forbidden() throws java.lang.Exception { blockCreateReference(); assertCreateFails(com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void createBranchByProjectOwnerCreateReferenceBlocked_Forbidden() throws java.lang.Exception { grantOwner(); blockCreateReference(); setApiUser(user); assertCreateFails(com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void createBranchByProjectOwner() throws java.lang.Exception { grantOwner(); setApiUser(user); assertCreateSucceeds(); }
@org.junit.Test public void createBranch_Forbidden() throws java.lang.Exception { setApiUser(user); assertCreateFails(com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void branchAlreadyExists_Conflict() throws java.lang.Exception { assertCreateSucceeds(); assertCreateFails(com.google.gerrit.extensions.restapi.ResourceConflictException.class); }

@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); } }; }
@java.lang.Override public void viewAccepted(org.jgroups.View view) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("viewAccepted(view: {}) called", view); synchronized(this) { if ((view.getMembers().size()) > 2) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.warn("{} members joined the jgroups channel {}. Only two members are supported. Members: {}", view.getMembers().size(), channel.getName(), view.getMembers()); } if (((peerAddress) != null) && (!(view.getMembers().contains(peerAddress)))) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("viewAccepted(): removed peerInfo"); peerAddress = null; peerInfo = java.util.Optional.empty(); } } if ((view.size()) > 1) { try { channel.send(new org.jgroups.Message(null, myUrl)); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("Sending a message over jgroups channel {} failed", jgroupsConfig.clusterName(), e); } } }
public void connect() { try { channel = new org.jgroups.JChannel(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { channel.getProtocolStack().getTransport().setBindAddress(address.get()); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("Succesfully joined jgroups channel {}", channel); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("joining jgroups channel {} failed", e); } }
@java.lang.Override public void cleanUp() { for (java.nio.file.Path path : listFiles()) { com.google.gerrit.httpd.WebSessionManager.Val val = readFile(path); if (val != null) { org.joda.time.DateTime expires = new org.joda.time.DateTime(val.getExpiresAt()); if (expires.isBefore(new org.joda.time.DateTime())) { deleteFile(path); } } } }








@java.lang.Override protected void configure() { if (!(enabled)) { bind(com.google.gerrit.server.api.accounts.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiModule.NoGpgApi.class); return; } bind(com.google.gerrit.server.api.accounts.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiAdapterImpl.class); factory(GpgKeyApiImpl.Factory.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.gpg.api.GPG_KEY_KIND); child(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.GpgKeys.class); post(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.PostGpgKeys.class); get(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(GpgKeys.Get.class); delete(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(com.google.gerrit.gpg.server.DeleteGpgKey.class); }



@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getOldFilePath(); }
@java.lang.Override public com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(edit.getOldFilePath(), adjustedFilePath, edit.getBeginA(), edit.getEndA(), ((edit.getBeginB()) + shiftedAmount), ((edit.getEndB()) + shiftedAmount), (!(java.util.Objects.equals(edit.getNewFilePath(), adjustedFilePath)))); }
private com.google.gerrit.server.patch.PatchList listFor(com.google.gerrit.server.patch.PatchListKey key) throws com.google.gerrit.server.patch.PatchListNotAvailableException { return patchListCache.get(key, notes.getProjectName()); }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder(com.google.gerrit.server.patch.PatchList list, org.eclipse.jgit.lib.Repository git) { final com.google.gerrit.server.patch.PatchScriptBuilder b = builderFactory.get(); b.setRepository(git, notes.getProjectName()); b.setChange(notes.getChange()); b.setDiffPrefs(diffPrefs); b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId()); return b; }
public java.util.Optional<com.google.gerrit.server.query.change.ChangeData.ChangedLines> changedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((changedLines) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } changedLines = computeChangedLines(); } return changedLines; }
private com.google.gerrit.server.patch.PatchListKey keyFor(com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { if ((parentNum) < 0) { return com.google.gerrit.server.patch.PatchListKey.againstCommit(aId, bId, whitespace); } return com.google.gerrit.server.patch.PatchListKey.againstParentNum(((parentNum) + 1), bId, whitespace); }
@org.junit.Test public void empty1() { final java.lang.String name = "empty-file"; final com.google.gerrit.server.patch.PatchListEntry e = com.google.gerrit.server.patch.PatchListEntry.empty(name); assertNull(e.getOldName()); assertEquals(name, e.getNewName()); assertSame(Patch.PatchType.UNIFIED, e.getPatchType()); assertSame(Patch.ChangeType.MODIFIED, e.getChangeType()); assertTrue(e.getEdits().isEmpty()); }
private com.google.gerrit.server.patch.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree); if (tw == null) { return Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return new com.google.gerrit.server.patch.Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB)); } else if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_COMMIT)) { java.lang.String str = "Subproject commit " + (org.eclipse.jgit.lib.ObjectId.toString(tw.getObjectId(0))); return new com.google.gerrit.server.patch.Text(str.getBytes(java.nio.charset.StandardCharsets.UTF_8)); } else { return Text.EMPTY; } }
private static boolean isBlankLineGap(com.google.gerrit.server.patch.Text a, int b, int e) { for (; b < e; b++) { if (!(com.google.gerrit.server.patch.IntraLineLoader.BLANK_LINE_RE.matcher(a.getString(b)).matches())) { return false; } } return true; }
private static boolean isControlBlockStart(com.google.gerrit.server.patch.Text a, int idx) { return com.google.gerrit.server.patch.IntraLineLoader.CONTROL_BLOCK_START_RE.matcher(a.getString(idx)).find(); }
com.google.gerrit.server.patch.IntraLineLoader create(com.google.gerrit.server.patch.IntraLineDiffKey key, com.google.gerrit.server.patch.IntraLineDiffArgs args);
private static void combineLineEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.server.patch.Text a, com.google.gerrit.server.patch.Text b) { for (int j = 0; j < ((edits.size()) - 1);) { org.eclipse.jgit.diff.Edit c = edits.get(j); org.eclipse.jgit.diff.Edit n = edits.get((j + 1)); final int ad = (n.getBeginA()) - (c.getEndA()); final int bd = (n.getBeginB()) - (c.getEndB()); if ((((1 <= ad) && (com.google.gerrit.server.patch.IntraLineLoader.isBlankLineGap(a, c.getEndA(), n.getBeginA()))) || ((1 <= bd) && (com.google.gerrit.server.patch.IntraLineLoader.isBlankLineGap(b, c.getEndB(), n.getBeginB())))) || (((ad == 1) && (bd == 1)) && (com.google.gerrit.server.patch.IntraLineLoader.isControlBlockStart(a, c.getEndA())))) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); edits.set(j, new org.eclipse.jgit.diff.Edit(ab, ae, bb, be)); edits.remove((j + 1)); continue; } j++; } }
@java.lang.Override public com.google.gerrit.server.patch.DiffSummary call() throws java.lang.Exception { com.google.gerrit.server.patch.PatchList patchList = patchListCache.get(key.toPatchListKey(), project); return com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(patchList); }
void setTrees(com.google.gerrit.server.patch.ComparisonType ct, org.eclipse.jgit.lib.ObjectId a, org.eclipse.jgit.lib.ObjectId b) { comparisonType = ct; aId = a; bId = b; }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.patch.IntraLineDiff::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public static java.util.stream.Stream<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> toEdits(com.google.gerrit.server.patch.PatchListEntry patchListEntry) { com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> edits = patchListEntry.getEdits(); if (edits.isEmpty()) { return java.util.stream.Stream.of(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.createForNoContentEdit(patchListEntry)); } return edits.stream().map(( edit) -> com.google.gerrit.server.patch.ContextAwareEdit.create(patchListEntry, edit)); }
private static org.eclipse.jgit.diff.Edit copy(org.eclipse.jgit.diff.Edit edit) { if (edit instanceof org.eclipse.jgit.diff.ReplaceEdit) { return com.google.gerrit.server.patch.IntraLineDiff.copy(((org.eclipse.jgit.diff.ReplaceEdit) (edit))); } return new org.eclipse.jgit.diff.Edit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB()); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeEnum(out, status); writeVarInt32(out, edits.size()); for (org.eclipse.jgit.diff.Edit e : edits) { com.google.gerrit.server.patch.IntraLineDiff.writeEdit(out, e); if (e instanceof org.eclipse.jgit.diff.ReplaceEdit) { org.eclipse.jgit.diff.ReplaceEdit r = ((org.eclipse.jgit.diff.ReplaceEdit) (e)); writeVarInt32(out, r.getInternalEdits().size()); for (org.eclipse.jgit.diff.Edit i : r.getInternalEdits()) { com.google.gerrit.server.patch.IntraLineDiff.writeEdit(out, i); } } else { writeVarInt32(out, 0); } } }
public static com.google.gerrit.server.patch.IntraLineDiffKey create(org.eclipse.jgit.lib.ObjectId aId, org.eclipse.jgit.lib.ObjectId bId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.patch.AutoValue_IntraLineDiffKey(aId, bId, whitespace); }
public java.util.List<java.lang.String> currentFilePaths() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((currentFiles) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } java.util.Optional<com.google.gerrit.server.patch.DiffSummary> p = getDiffSummary(); currentFiles = p.map(DiffSummary::getPaths).orElse(java.util.Collections.emptyList()); } return currentFiles; }
private java.util.Optional<com.google.gerrit.server.query.change.ChangeData.ChangedLines> computeChangedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.patch.DiffSummary> ds = getDiffSummary(); if (ds.isPresent()) { return java.util.Optional.of(ds.get().getChangedLines()); } return java.util.Optional.empty(); }
@java.lang.Override public int hash(com.google.gerrit.server.patch.CharText seq, int ptr) { return seq.charAt(ptr); }
public void setChangedLines(int insertions, int deletions) { changedLines = java.util.Optional.of(new com.google.gerrit.server.query.change.ChangeData.ChangedLines(insertions, deletions)); }
private java.util.Optional<com.google.gerrit.server.patch.DiffSummary> getDiffSummary() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((diffSummary) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Change c = change(); com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (((c == null) || (ps == null)) || (!(loadCommitData()))) { return java.util.Optional.empty(); } org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.patch.PatchListKey pk = ((parentCount) > 1) ? com.google.gerrit.server.patch.PatchListKey.againstParentNum(1, id, ws) : com.google.gerrit.server.patch.PatchListKey.againstDefaultBase(id, ws); com.google.gerrit.server.patch.DiffSummaryKey key = com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(pk); try { diffSummary = java.util.Optional.of(patchListCache.getDiffSummary(key, c.getProject())); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { diffSummary = java.util.Optional.empty(); } } return diffSummary; }
private static org.eclipse.jgit.diff.ReplaceEdit copy(org.eclipse.jgit.diff.ReplaceEdit edit) { java.util.List<org.eclipse.jgit.diff.Edit> internalEdits = edit.getInternalEdits().stream().map(com.google.gerrit.server.patch.IntraLineDiff::copy).collect(java.util.stream.Collectors.toList()); return new org.eclipse.jgit.diff.ReplaceEdit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), internalEdits); }
public com.google.gerrit.server.patch.IntraLineDiff.Status getStatus() { return status; }
public void transformReferencesOfSideA(java.util.List<com.google.gerrit.server.patch.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.patch.EditTransformer.SideAStrategy.INSTANCE); }
@java.lang.Override public int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getEndB(); }
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(java.lang.String oldFilePath, java.lang.String newFilePath, int beginA, int endA, int beginB, int endB, boolean filePathAdjusted) { java.lang.String adjustedOldFilePath = com.google.common.base.MoreObjects.firstNonNull(oldFilePath, newFilePath); boolean implicitRename = (!(java.util.Objects.equals(oldFilePath, newFilePath))) && filePathAdjusted; return new com.google.gerrit.server.patch.AutoValue_EditTransformer_ContextAwareEdit(adjustedOldFilePath, newFilePath, beginA, endA, beginB, endB, implicitRename); }
private static java.lang.String newName(com.google.gerrit.server.patch.PatchListEntry entry) { switch (entry.getChangeType()) { case DELETED : return null; case ADDED : case MODIFIED : case COPIED : case RENAMED : case REWRITE : default : return entry.getNewName(); } }
@java.lang.Override public com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(adjustedFilePath, edit.getNewFilePath(), ((edit.getBeginA()) + shiftedAmount), ((edit.getEndA()) + shiftedAmount), edit.getBeginB(), edit.getEndB(), (!(java.util.Objects.equals(edit.getOldFilePath(), adjustedFilePath)))); }
@java.lang.Override public int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getBeginA(); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.patch.PatchListKey.class, com.google.gerrit.server.patch.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.patch.IntraLineDiffKey.class, com.google.gerrit.server.patch.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.patch.DiffSummaryKey.class, com.google.gerrit.server.patch.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.patch.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); } }; }
@java.lang.Override public com.google.gerrit.server.patch.DiffSummary getDiffSummary(com.google.gerrit.server.patch.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { return diffSummaryCache.get(key, diffSummaryLoaderFactory.create(key, project)); } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } throw e; } }
@java.lang.Override public int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getBeginB(); }
private static boolean isModify(com.google.gerrit.server.patch.PatchListEntry content) { switch (content.getChangeType()) { case MODIFIED : case COPIED : case RENAMED : case REWRITE : return true; case ADDED : case DELETED : default : return false; } }
private java.lang.String getLine(com.google.gerrit.server.patch.PatchFile fileInfo, short side, int lineNbr) { try { return fileInfo.getLine(side, lineNbr); } catch (java.io.IOException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format("Failed to read file on side %d", side), err); return ""; } catch (java.lang.IndexOutOfBoundsException err) { com.google.gerrit.server.mail.send.CommentSender.log.debug(java.lang.String.format("Failed to get line number of file on side %d", side), err); return ""; } catch (com.google.gerrit.common.errors.NoSuchEntityException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format("Side %d of file didn't exist", side), err); return ""; } }
private java.util.List<java.lang.String> getLinesByRange(com.google.gerrit.reviewdb.client.Comment.Range range, com.google.gerrit.server.patch.PatchFile fileData, short side) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); for (int n = range.startLine; n <= (range.endLine); n++) { java.lang.String s = getLine(fileData, side, n); if (((n == (range.startLine)) && (n == (range.endLine))) && ((range.startChar) < (range.endChar))) { s = s.substring(java.lang.Math.min(range.startChar, s.length()), java.lang.Math.min(range.endChar, s.length())); } else if (n == (range.startLine)) { s = s.substring(java.lang.Math.min(range.startChar, s.length())); } else if (n == (range.endLine)) { s = s.substring(0, java.lang.Math.min(range.endChar, s.length())); } lines.add(s); } return lines; }
private static java.util.stream.Stream<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> transformEdits(com.google.gerrit.server.patch.EditTransformer.SideStrategy sideStrategy, java.util.List<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> originalEdits, java.util.List<com.google.gerrit.server.patch.PatchListEntry> transformingEntries) { if (transformingEntries.isEmpty()) { return originalEdits.stream(); } return transformingEntries.stream().flatMap(( transEntry) -> transformEdits(sideStrategy, originalEdits, transEntry.getEdits(), transEntry.getNewName()).stream()); }
int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { com.google.gerrit.server.patch.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if (pl instanceof com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone) { throw new com.google.gerrit.server.patch.PatchListObjectTooLargeException((("Error computing " + key) + ". Previous attempt failed with LargeObjectException")); } if ((key.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(key), com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { fileCache.put(key, new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone()); PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } throw e; } }
@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getNewFilePath(); }
private java.util.List<java.lang.String> getLinesOfComment(com.google.gerrit.reviewdb.client.Comment comment, com.google.gerrit.server.patch.PatchFile fileData) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); if ((comment.lineNbr) == 0) { return lines; } if ((comment.range) == null) { lines.add(getLine(fileData, comment.side, comment.lineNbr)); } else { lines.addAll(getLinesByRange(comment.range, fileData, comment.side)); } return lines; }
@java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.patch.PatchListKey.class, com.google.gerrit.server.patch.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.patch.IntraLineDiffKey.class, com.google.gerrit.server.patch.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.patch.DiffSummaryKey.class, com.google.gerrit.server.patch.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.patch.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); }
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.PatchListEntry patchListEntry, org.eclipse.jgit.diff.Edit edit) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), false); }
private com.google.gerrit.server.patch.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path, org.eclipse.jgit.lib.ObjectReader reader) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return com.google.gerrit.server.patch.Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(reader, path, tree); if (tw == null) { return com.google.gerrit.server.patch.Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) != (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return com.google.gerrit.server.patch.Text.EMPTY; } return new com.google.gerrit.server.patch.Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB)); }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { status = readEnum(in, com.google.gerrit.server.patch.IntraLineDiff.Status.values()); int editCount = readVarInt32(in); org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { editArray[i] = com.google.gerrit.server.patch.IntraLineDiff.readEdit(in); int innerCount = readVarInt32(in); if (0 < innerCount) { org.eclipse.jgit.diff.Edit[] inner = new org.eclipse.jgit.diff.Edit[innerCount]; for (int j = 0; j < innerCount; j++) { inner[j] = com.google.gerrit.server.patch.IntraLineDiff.readEdit(in); } editArray[i] = new org.eclipse.jgit.diff.ReplaceEdit(editArray[i], com.google.gerrit.server.patch.IntraLineDiff.toList(inner)); } } edits = com.google.common.collect.ImmutableList.copyOf(editArray); }
com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath);
public com.google.gerrit.server.patch.PatchListCache getPatchListCache() { return patchListCache; }
private static java.lang.String oldName(com.google.gerrit.server.patch.PatchListEntry entry) { switch (entry.getChangeType()) { case ADDED : return null; case DELETED : case MODIFIED : case REWRITE : return entry.getNewName(); case COPIED : case RENAMED : default : return entry.getOldName(); } }
@java.lang.Override public org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.patch.PatchListNotAvailableException { return get(change, patchSet, parentNum).getOldId(); }
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.patch.PatchListNotAvailableException { return get(change, patchSet, null); }
private void transformEdits(java.util.List<com.google.gerrit.server.patch.PatchListEntry> transformingEntries, com.google.gerrit.server.patch.EditTransformer.SideStrategy sideStrategy) { java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit>> editsPerFilePath = edits.stream().collect(java.util.stream.Collectors.groupingBy(sideStrategy::getFilePath)); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.patch.PatchListEntry>> transEntriesPerPath = transformingEntries.stream().collect(java.util.stream.Collectors.groupingBy(com.google.gerrit.server.patch.EditTransformer::getOldFilePath)); edits = editsPerFilePath.entrySet().stream().flatMap(( pathAndEdits) -> { java.util.List<com.google.gerrit.server.patch.PatchListEntry> transEntries = transEntriesPerPath.getOrDefault(pathAndEdits.getKey(), com.google.common.collect.ImmutableList.of()); return com.google.gerrit.server.patch.EditTransformer.transformEdits(sideStrategy, pathAndEdits.getValue(), transEntries); }).collect(java.util.stream.Collectors.toList()); }
com.google.gerrit.common.data.PatchScript toPatchScript(com.google.gerrit.server.patch.PatchListEntry content, com.google.gerrit.common.data.CommentDetail comments, java.util.List<com.google.gerrit.reviewdb.client.Patch> history) throws java.io.IOException { reader = db.newObjectReader(); try { return build(content, comments, history); } finally { reader.close(); } }
public com.google.gerrit.reviewdb.client.Patch.PatchType getPatchType() { return com.google.gerrit.reviewdb.client.Patch.PatchType.forCode(patchType); }
public void setPatchType(com.google.gerrit.reviewdb.client.Patch.PatchType type) { patchType = type.getCode(); }
int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit createForNoContentEdit(com.google.gerrit.server.patch.PatchListEntry patchListEntry) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), (-1), (-1), (-1), (-1), false); }
@java.lang.Override public com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.patch.IntraLineDiffKey key, com.google.gerrit.server.patch.IntraLineDiffArgs args) { if (computeIntraline) { try { return intraCache.get(key, intraLoaderFactory.create(key, args)); } catch (java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e) { IntraLineLoader.log.warn(("Error computing " + key), e); return new com.google.gerrit.server.patch.IntraLineDiff(IntraLineDiff.Status.ERROR); } } return new com.google.gerrit.server.patch.IntraLineDiff(IntraLineDiff.Status.DISABLED); }
public void transformReferencesOfSideB(java.util.List<com.google.gerrit.server.patch.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.patch.EditTransformer.SideBStrategy.INSTANCE); }
private static boolean canCoalesce(com.google.gerrit.server.patch.CharText a, int b, int e) { while (b < e) { if ((a.charAt((b++))) == '\n') { return false; } } return true; }
java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.patch.IntraLineDiff call() throws java.lang.Exception { java.util.concurrent.Future<com.google.gerrit.server.patch.IntraLineDiff> result = diffExecutor.submit(() -> com.google.gerrit.server.patch.IntraLineLoader.compute(args.aText(), args.bText(), args.edits())); try { return result.get(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.InterruptedException | java.util.concurrent.TimeoutException e) { com.google.gerrit.server.patch.IntraLineLoader.log.warn(((((((((((((timeoutMillis) + " ms timeout reached for IntraLineDiff") + " in project ") + (args.project())) + " on commit ") + (args.commit().name())) + " for path ") + (args.path())) + " comparing ") + (key.getBlobA().name())) + "..") + (key.getBlobB().name()))); result.cancel(true); return new com.google.gerrit.server.patch.IntraLineDiff(IntraLineDiff.Status.TIMEOUT); } catch (java.util.concurrent.ExecutionException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.lang.Exception.class); throw new java.lang.Exception(e.getMessage(), e.getCause()); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error("Couldn't fire event", e); } }
private com.google.gerrit.server.patch.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.patch.PatchListNotAvailableException { com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); if ((patchSet.getRevision()) == null) { throw new com.google.gerrit.server.patch.PatchListNotAvailableException(("revision is null for " + (patchSet.getId()))); } org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; if (parentNum != null) { return get(com.google.gerrit.server.patch.PatchListKey.againstParentNum(parentNum, b, ws), project); } return get(com.google.gerrit.server.patch.PatchListKey.againstDefaultBase(b, ws), project); }
public com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsPerFilePath() { return edits.stream().collect(toMultimap(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit::getNewFilePath, java.util.function.Function.identity(), ArrayListMultimap::create)); }
public com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> getEdits() { return com.google.gerrit.server.patch.IntraLineDiff.deepCopyEdits(edits); }
@java.lang.Override public boolean equals(com.google.gerrit.server.patch.CharText a, int ai, com.google.gerrit.server.patch.CharText b, int bi) { return (a.charAt(ai)) == (b.charAt(bi)); }
static com.google.gerrit.server.patch.DiffSummary toDiffSummary(com.google.gerrit.server.patch.PatchList patchList) { java.util.List<java.lang.String> r = new java.util.ArrayList(patchList.getPatches().size()); for (com.google.gerrit.server.patch.PatchListEntry e : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : case REWRITE : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; } } java.util.Collections.sort(r); return new com.google.gerrit.server.patch.DiffSummary(r.toArray(new java.lang.String[r.size()]), patchList.getInsertions(), patchList.getDeletions()); }
public static com.google.gerrit.server.patch.PatchListKey againstCommit(org.eclipse.jgit.lib.AnyObjectId otherCommitId, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.patch.PatchListKey(otherCommitId, newId, whitespace, com.google.gerrit.server.patch.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
protected com.google.gerrit.server.patch.PatchList getPatchList() throws com.google.gerrit.server.patch.PatchListNotAvailableException { if ((patchSet) != null) { return args.patchListCache.get(change, patchSet); } throw new com.google.gerrit.server.patch.PatchListNotAvailableException("no patchSet specified"); }
public java.lang.String getUnifiedDiff() { com.google.gerrit.server.patch.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return "[Octopus merge; cannot be formatted as a diff.]\n"; } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn(("Cannot format patch " + (e.getMessage()))); return ""; } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot format patch", e); return ""; } int maxSize = args.settings.maximumDiffSize; org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(java.lang.Math.min(com.google.gerrit.server.mail.send.ChangeEmail.HEAP_EST_SIZE, maxSize), maxSize); try (org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf)) { try (org.eclipse.jgit.lib.Repository git = args.server.openRepository(change.getProject())) { try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot format patch", e); return ""; } } catch (java.io.IOException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot open repository to format patch", e); return ""; } } }
public java.lang.String getChangeDetail() { try { java.lang.StringBuilder detail = new java.lang.StringBuilder(); if ((patchSetInfo) != null) { detail.append(patchSetInfo.getMessage().trim()).append("\n"); } else { detail.append(change.getSubject().trim()).append("\n"); } if ((patchSet) != null) { detail.append("---\n"); com.google.gerrit.server.patch.PatchList patchList = getPatchList(); for (com.google.gerrit.server.patch.PatchListEntry p : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(p.getNewName())) { continue; } detail.append(p.getChangeType().getCode()).append(" ").append(p.getNewName()).append("\n"); } detail.append(java.text.MessageFormat.format(("" + ((("{0,choice,0#0 files|1#1 file|1<{0} files} changed, " + "{1,choice,0#0 insertions|1#1 insertion|1<{1} insertions}(+), ") + "{2,choice,0#0 deletions|1#1 deletion|1<{2} deletions}(-)") + "\n")), ((patchList.getPatches().size()) - 1), patchList.getInsertions(), patchList.getDeletions())); detail.append("\n"); } return detail.toString(); } catch (java.lang.Exception err) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn("Cannot format change detail", err); return ""; } }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) { com.googlecode.prolog_cafe.lang.Term a5 = engine.r5; @java.lang.SuppressWarnings("unchecked") java.util.Iterator<com.google.gerrit.server.patch.PatchListEntry> iter = ((java.util.Iterator<com.google.gerrit.server.patch.PatchListEntry>) (((com.googlecode.prolog_cafe.lang.JavaObjectTerm) (a5)).object())); if (!(iter.hasNext())) { return engine.fail(); } return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.cont = cont; engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); if (a1 instanceof com.googlecode.prolog_cafe.lang.VariableTerm) { throw new com.googlecode.prolog_cafe.exceptions.PInstantiationException(this, 1); } if (!(a1 instanceof com.googlecode.prolog_cafe.lang.SymbolTerm)) { throw new com.googlecode.prolog_cafe.exceptions.IllegalTypeException(this, 1, "symbol", a1); } java.util.regex.Pattern regex = java.util.regex.Pattern.compile(a1.name()); engine.r1 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(regex); engine.r2 = arg2; engine.r3 = arg3; engine.r4 = arg4; com.google.gerrit.server.patch.PatchList pl = StoredValues.PATCH_LIST.get(engine); java.util.Iterator<com.google.gerrit.server.patch.PatchListEntry> iter = pl.getPatches().iterator(); engine.r5 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(iter); return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@org.junit.Test public void largeObjectTombstoneGetsCached() { com.google.gerrit.server.patch.PatchListKey key = com.google.gerrit.server.patch.PatchListKey.againstDefaultBase(org.eclipse.jgit.lib.ObjectId.zeroId(), Whitespace.IGNORE_ALL); com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone tombstone = new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone(); abstractPatchListCache.put(key, tombstone); assertThat(abstractPatchListCache.getIfPresent(key)).isSameAs(tombstone); }
private static void assertAdded(java.lang.String expectedNewName, com.google.gerrit.server.patch.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.ADDED); }
private com.google.gerrit.server.patch.PatchListKey getKey(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) { return com.google.gerrit.server.patch.PatchListKey.againstCommit(revisionIdA, revisionIdB, Whitespace.IGNORE_NONE); }
private static void assertDeleted(java.lang.String expectedNewName, com.google.gerrit.server.patch.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.DELETED); }
private static void assertName(java.lang.String expectedNewName, com.google.gerrit.server.patch.PatchListEntry e) { assertThat(e.getNewName()).isEqualTo(expectedNewName); assertThat(e.getOldName()).isNull(); }
private java.util.List<com.google.gerrit.server.patch.PatchListEntry> getCurrentPatches(java.lang.String changeId) throws java.lang.Exception { return patchListCache.get(getKey(null, getCurrentRevisionId(changeId)), project).getPatches(); }
private java.util.List<com.google.gerrit.server.patch.PatchListEntry> getPatches(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) throws java.lang.Exception { return patchListCache.get(getKey(revisionIdA, revisionIdB), project).getPatches(); }
private static void assertModified(java.lang.String expectedNewName, com.google.gerrit.server.patch.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.MODIFIED); }
public void addPatchSetFileNames(com.google.gerrit.server.data.PatchSetAttribute patchSetAttribute, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) { try { com.google.gerrit.server.patch.PatchList patchList = patchListCache.get(change, patchSet); for (com.google.gerrit.server.patch.PatchListEntry patch : patchList.getPatches()) { if ((patchSetAttribute.files) == null) { patchSetAttribute.files = new java.util.ArrayList(); } com.google.gerrit.server.data.PatchAttribute p = new com.google.gerrit.server.data.PatchAttribute(); p.file = patch.getNewName(); p.fileOld = patch.getOldName(); p.type = patch.getChangeType(); p.deletions -= patch.getDeletions(); p.insertions = patch.getInsertions(); patchSetAttribute.files.add(p); } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.events.EventFactory.log.warn(("Cannot get patch list: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.events.EventFactory.log.warn("Cannot get patch list", e); } }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.lib.ObjectId objectId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId a = (base == null) ? null : org.eclipse.jgit.lib.ObjectId.fromString(base.getRevision().get()); return toFileInfoMap(change, com.google.gerrit.server.patch.PatchListKey.againstCommit(a, objectId, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.patch.PatchListNotAvailableException { return toFileInfoMap(change, patchSet.getRevision(), null); }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.patch.PatchListKey key) throws com.google.gerrit.server.patch.PatchListNotAvailableException { com.google.gerrit.server.patch.PatchList list = patchListCache.get(key, change.getProject()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> files = new java.util.TreeMap<>(); for (com.google.gerrit.server.patch.PatchListEntry e : list.getPatches()) { com.google.gerrit.extensions.common.FileInfo d = new com.google.gerrit.extensions.common.FileInfo(); d.status = ((e.getChangeType()) != (Patch.ChangeType.MODIFIED)) ? e.getChangeType().getCode() : null; d.oldPath = e.getOldName(); d.sizeDelta = e.getSizeDelta(); d.size = e.getSize(); if ((e.getPatchType()) == (Patch.PatchType.BINARY)) { d.binary = true; } else { d.linesInserted = ((e.getInsertions()) > 0) ? e.getInsertions() : null; d.linesDeleted = ((e.getDeletions()) > 0) ? e.getDeletions() : null; } com.google.gerrit.extensions.common.FileInfo o = files.put(e.getNewName(), d); if (o != null) { d.status = Patch.ChangeType.REWRITE.getCode(); d.sizeDelta = o.sizeDelta; d.size = o.size; if (((o.binary) != null) && (o.binary)) { d.binary = true; } if ((o.linesInserted) != null) { d.linesInserted = o.linesInserted; } if ((o.linesDeleted) != null) { d.linesDeleted = o.linesDeleted; } } } return files; }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, int parent) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, com.google.gerrit.server.patch.PatchListKey.againstParentNum((parent + 1), b, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId objectId = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, objectId, base); }
public com.google.gerrit.server.query.change.ChangeData.ChangedLines getChangedLines() { return new com.google.gerrit.server.query.change.ChangeData.ChangedLines(insertions, deletions); }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null, isWorldReadable(cd)); accountLoader.fill(); return rev; } }
static com.google.gerrit.server.patch.ComparisonType readFrom(java.io.InputStream in) throws java.io.IOException { int p = readVarInt32(in); java.lang.Integer parentNum = (p > 0) ? p : null; boolean autoMerge = (readVarInt32(in)) != 0; return new com.google.gerrit.server.patch.ComparisonType(parentNum, autoMerge); }
private com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.query.change.ChangeData cd, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws com.google.gwtorm.server.OrmException { try { if (fillAccountLoader) { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); com.google.gerrit.extensions.common.ChangeInfo res = toChangeInfo(cd, limitToPsId); accountLoader.fill(); return res; } return toChangeInfo(cd, limitToPsId); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (!(has(com.google.gerrit.server.change.CHECK))) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(e); } return checkOnly(cd); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); java.lang.Boolean isWorldReadable = null; try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want) { if (isWorldReadable == null) { isWorldReadable = isWorldReadable(cd); } res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo, isWorldReadable)); } } return res; } }
private java.util.List<com.google.gerrit.extensions.common.ChangeInfo> toChangeInfo(java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.extensions.common.ChangeInfo> out, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { com.google.gerrit.extensions.common.ChangeInfo i = out.get(cd.getId()); if (i == null) { try { i = toChangeInfo(cd, java.util.Optional.empty()); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (has(com.google.gerrit.server.change.CHECK)) { i = checkOnly(cd); } else if (e instanceof com.google.gerrit.server.project.NoSuchChangeException) { com.google.gerrit.server.change.ChangeJson.log.info((("NoSuchChangeException: Omitting corrupt change " + (cd.getId())) + " from results. Seems to be stale in the index.")); continue; } else { com.google.gerrit.server.change.ChangeJson.log.warn((("Omitting corrupt change " + (cd.getId())) + " from results"), e); continue; } } out.put(cd.getId(), i); } info.add(i); } return info; }
@java.lang.Override public int weigh(com.google.gerrit.server.patch.DiffSummaryKey key, com.google.gerrit.server.patch.DiffSummary value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 16) + 8) + (2 * 4)) + 16) + 8; for (java.lang.String p : value.getPaths()) { size += ((((16 + 8) + (4 * 4)) + 16) + 8) + ((p.length()) * 2); } return size; }
public static com.google.gerrit.server.patch.ComparisonType againstAutoMerge() { return new com.google.gerrit.server.patch.ComparisonType(null, true); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeCanBeNull(out, oldId); out.writeInt(((parentNum) == null ? 0 : parentNum)); writeNotNull(out, newId); java.lang.Character c = com.google.gerrit.server.patch.PatchListKey.WHITESPACE_TYPES.get(whitespace); if (c == null) { throw new java.io.IOException(("Invalid whitespace type: " + (whitespace))); } out.writeChar(c); out.writeChar(com.google.gerrit.server.patch.PatchListKey.ALGORITHM_TYPES.get(algorithm)); }
public static com.google.gerrit.server.patch.ComparisonType againstParent(int parentNum) { return new com.google.gerrit.server.patch.ComparisonType(parentNum, false); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.patch.PatchListKey) { com.google.gerrit.server.patch.PatchListKey k = ((com.google.gerrit.server.patch.PatchListKey) (o)); return ((((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace))) && ((algorithm) == (k.algorithm)); } return false; }
public static void setCommentRevId(com.google.gerrit.reviewdb.client.Comment c, com.google.gerrit.server.patch.PatchListCache cache, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { checkArgument(((c.key.patchSetId) == (ps.getId().get())), "cannot set RevId for patch set %s on comment %s", ps.getId(), c); if ((c.revId) == null) { try { if ((com.google.gerrit.extensions.client.Side.fromShort(c.side)) == (com.google.gerrit.extensions.client.Side.PARENT)) { if ((c.side) < 0) { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, (-(c.side)))); } else { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, null)); } } else { c.revId = ps.getRevision().get(); } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.google.gwtorm.server.OrmException(e); } } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.changes.ReviewResult> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply(updateFactory, revision, input, com.google.gerrit.common.TimeUtil.nowTs()); }
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId newId = org.eclipse.jgit.lib.ObjectId.fromString(revision.getPatchSet().getRevision().get()); com.google.gerrit.server.patch.DiffSummaryKey key = com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(com.google.gerrit.server.patch.PatchListKey.againstDefaultBase(newId, Whitespace.IGNORE_NONE)); com.google.gerrit.server.patch.DiffSummary ds = patchListCache.getDiffSummary(key, revision.getProject()); return new java.util.HashSet(ds.getPaths()); }
private <T extends com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput> void checkComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<T>> commentsPerPath) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.patch.PatchListNotAvailableException { java.util.Set<java.lang.String> revisionFilePaths = getAffectedFilePaths(revision); for (java.util.Map.Entry<java.lang.String, java.util.List<T>> entry : commentsPerPath.entrySet()) { java.lang.String path = entry.getKey(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = revision.getChange().currentPatchSetId(); com.google.gerrit.server.change.PostReview.ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId); java.util.List<T> comments = entry.getValue(); for (T comment : comments) { com.google.gerrit.server.change.PostReview.ensureLineIsNonNegative(comment.line, path); com.google.gerrit.server.change.PostReview.ensureCommentNotOnMagicFilesOfAutoMerge(path, comment); com.google.gerrit.server.change.PostReview.ensureRangeIsValid(path, comment.range); } } }
private void checkRobotComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> in) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.patch.PatchListNotAvailableException { com.google.gerrit.server.change.PostReview.cleanUpComments(in); for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> e : in.entrySet()) { java.lang.String commentPath = e.getKey(); for (com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput c : e.getValue()) { ensureSizeOfJsonInputIsWithinBounds(c); com.google.gerrit.server.change.PostReview.ensureRobotIdIsSet(c.robotId, commentPath); com.google.gerrit.server.change.PostReview.ensureRobotRunIdIsSet(c.robotRunId, commentPath); com.google.gerrit.server.change.PostReview.ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath); } } checkComments(revision, in); }
com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException;
com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.patch.IntraLineDiffKey key, com.google.gerrit.server.patch.IntraLineDiffArgs args);
org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.patch.PatchListNotAvailableException;
com.google.gerrit.server.patch.DiffSummary getDiffSummary(com.google.gerrit.server.patch.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException;
com.google.gerrit.server.patch.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.patch.PatchListNotAvailableException;
private java.util.Collection<java.lang.String> reviewed(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.reviewdb.client.Account.Id userId = user.getAccountId(); com.google.gerrit.reviewdb.client.PatchSet patchSetId = resource.getPatchSet(); java.util.Optional<com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId); if (o.isPresent()) { com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles res = o.get(); if (res.patchSetId().equals(patchSetId.getId())) { return res.files(); } try { return copy(res.files(), res.patchSetId(), resource, userId); } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn(("Cannot copy patch review flags: " + (e.getMessage()))); } catch (java.io.IOException | com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn("Cannot copy patch review flags", e); } } return java.util.Collections.emptyList(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { checkOptions(); if (reviewed) { return com.google.gerrit.extensions.restapi.Response.ok(reviewed(resource)); } else if ((query) != null) { return com.google.gerrit.extensions.restapi.Response.ok(query(resource)); } com.google.gerrit.extensions.restapi.Response<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo>> r; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(resource.getChangeResource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), baseResource.getPatchSet())); } else if ((parentNum) > 0) { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), ((parentNum) - 1))); } else { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet())); } if (resource.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; }
private static java.nio.charset.Charset charset(byte[] content, java.lang.String encoding) { if (encoding == null) { org.mozilla.universalchardet.UniversalDetector d = new org.mozilla.universalchardet.UniversalDetector(null); d.handleData(content, 0, content.length); d.dataEnd(); encoding = d.getDetectedCharset(); } if (encoding == null) { return java.nio.charset.StandardCharsets.ISO_8859_1; } try { return java.nio.charset.Charset.forName(encoding); } catch (java.nio.charset.IllegalCharsetNameException err) { com.google.gerrit.server.patch.Text.log.error(((("Invalid detected charset name '" + encoding) + "': ") + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } catch (java.nio.charset.UnsupportedCharsetException err) { com.google.gerrit.server.patch.Text.log.error(((("Detected charset '" + encoding) + "' not supported: ") + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error("Couldn't fire event", e); } }
public static byte[] asByteArray(org.eclipse.jgit.lib.ObjectLoader ldr) throws java.io.IOException, org.eclipse.jgit.errors.LargeObjectException, org.eclipse.jgit.errors.MissingObjectException { return ldr.getCachedBytes(com.google.gerrit.server.patch.Text.bigFileThreshold); }
@java.lang.Override protected java.lang.String decode(int s, int e) { if ((charset) == null) { charset = com.google.gerrit.server.patch.Text.charset(content, null); } return org.eclipse.jgit.util.RawParseUtils.decode(charset, content, s, e); }
public static com.google.gerrit.server.patch.Text forMergeList(com.google.gerrit.server.patch.ComparisonType comparisonType, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(commitId); java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case 0 : break; case 1 : { break; } default : int uniterestingParent = (comparisonType.isAgainstParent()) ? comparisonType.getParentNum() : 1; b.append("Merge List:\n\n"); for (org.eclipse.jgit.revwalk.RevCommit commit : com.google.gerrit.server.patch.MergeListBuilder.build(rw, c, uniterestingParent)) { b.append("* "); b.append(reader.abbreviate(commit, 8).name()); b.append(" "); b.append(commit.getShortMessage()); b.append("\n"); } } return new com.google.gerrit.server.patch.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
@org.junit.Test public void fileOrder() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.patch.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@org.junit.Test public void fileOrderNoMerge() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.patch.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.patch.PatchList.comparePaths(o1, o2); }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { return revisionInfo(project.getNameKey(), ps); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error("Couldn't fire event", e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.server.patch.PatchList value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 8) + 16) + (3 * 8)) + (3 * 4)) + 20; for (com.google.gerrit.server.patch.PatchListEntry e : value.getPatches()) { size += e.weigh(); } return size; }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { oldId = readCanBeNull(in); int n = in.readInt(); parentNum = (n == 0) ? null : java.lang.Integer.valueOf(n); newId = readNotNull(in); char t = in.readChar(); whitespace = com.google.gerrit.server.patch.PatchListKey.WHITESPACE_TYPES.inverse().get(t); if ((whitespace) == null) { throw new java.io.IOException(("Invalid whitespace type code: " + t)); } char algorithmCharacter = in.readChar(); algorithm = com.google.gerrit.server.patch.PatchListKey.ALGORITHM_TYPES.inverse().get(algorithmCharacter); }
public static com.google.gerrit.server.patch.PatchListKey againstParentNum(int parentNum, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.patch.PatchListKey(parentNum, newId, ws, com.google.gerrit.server.patch.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public com.google.gerrit.server.patch.PatchListKey.Algorithm getAlgorithm() { return algorithm; }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey()); return changeJson.getRevisionInfo(cd, ps); }
public static com.google.gerrit.server.patch.PatchListKey againstDefaultBase(org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.patch.PatchListKey(null, newId, ws, com.google.gerrit.server.patch.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public static com.google.gerrit.server.patch.Text forCommit(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c; if (commitId instanceof org.eclipse.jgit.revwalk.RevCommit) { c = ((org.eclipse.jgit.revwalk.RevCommit) (commitId)); } else { c = rw.parseCommit(commitId); } java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case 0 : break; case 1 : { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(0); rw.parseBody(p); b.append("Parent: "); b.append(reader.abbreviate(p, 8).name()); b.append(" ("); b.append(p.getShortMessage()); b.append(")\n"); break; } default : for (int i = 0; i < (c.getParentCount()); i++) { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(i); rw.parseBody(p); b.append((i == 0 ? "Merge Of: " : " ")); b.append(reader.abbreviate(p, 8).name()); b.append(" ("); b.append(p.getShortMessage()); b.append(")\n"); } } com.google.gerrit.server.patch.Text.appendPersonIdent(b, "Author", c.getAuthorIdent()); com.google.gerrit.server.patch.Text.appendPersonIdent(b, "Commit", c.getCommitterIdent()); b.append("\n"); b.append(c.getFullMessage()); return new com.google.gerrit.server.patch.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
com.google.gerrit.server.patch.DiffSummaryLoader create(com.google.gerrit.server.patch.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); com.googlecode.prolog_cafe.lang.Term a2 = arg2.dereference(); com.googlecode.prolog_cafe.lang.Term a3 = arg3.dereference(); com.google.gerrit.server.patch.PatchList pl = StoredValues.PATCH_LIST.get(engine); if (!(a1.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(((pl.getPatches().size()) - (countMagicFiles(pl.getPatches())))), engine.trail))) { return engine.fail(); } if (!(a2.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getInsertions()), engine.trail))) { return engine.fail(); } if (!(a3.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getDeletions()), engine.trail))) { return engine.fail(); } return cont; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser()); if (!(edit.isPresent())) { return com.google.gerrit.extensions.restapi.Response.none(); } com.google.gerrit.extensions.common.EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands); if (list) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = null; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(rsrc, com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); basePatchSet = baseResource.getPatchSet(); } try { editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getEditCommit(), basePatchSet); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } } return com.google.gerrit.extensions.restapi.Response.ok(editInfo); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error("Couldn't fire event", e); } }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.patch.IntraLineDiffArgs::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public abstract com.google.gerrit.server.patch.Text aText();
public abstract com.google.gerrit.server.patch.Text bText();
public static com.google.gerrit.server.patch.IntraLineDiffArgs create(com.google.gerrit.server.patch.Text aText, com.google.gerrit.server.patch.Text bText, java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId commit, java.lang.String path) { return new com.google.gerrit.server.patch.AutoValue_IntraLineDiffArgs(aText, bText, com.google.gerrit.server.patch.IntraLineDiffArgs.deepCopyEdits(edits), project, commit, path); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.patch.DiffSummaryKey) { com.google.gerrit.server.patch.DiffSummaryKey k = ((com.google.gerrit.server.patch.DiffSummaryKey) (o)); return (((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace)); } return false; }
public static com.google.gerrit.server.patch.DiffSummaryKey fromPatchListKey(com.google.gerrit.server.patch.PatchListKey plk) { com.google.common.base.Preconditions.checkArgument(((plk.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF))); return new com.google.gerrit.server.patch.DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace()); }
com.google.gerrit.server.patch.PatchListKey toPatchListKey() { return new com.google.gerrit.server.patch.PatchListKey(oldId, parentNum, newId, whitespace, PatchListKey.Algorithm.OPTIMIZED_DIFF); }
private com.google.gerrit.server.patch.PatchListEntry newCommitMessage(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit) throws java.io.IOException { com.google.gerrit.server.patch.Text aText = (aCommit != null) ? com.google.gerrit.server.patch.Text.forCommit(reader, aCommit) : Text.EMPTY; com.google.gerrit.server.patch.Text bText = com.google.gerrit.server.patch.Text.forCommit(reader, bCommit); return com.google.gerrit.server.patch.PatchListLoader.createPatchListEntry(cmp, aCommit, aText, bText, Patch.COMMIT_MSG); }
@java.lang.Override public com.google.gerrit.server.patch.PatchList call() throws com.google.gerrit.server.patch.PatchListNotAvailableException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter ins = newInserter(repo);org.eclipse.jgit.lib.ObjectReader reader = ins.newReader();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { return readPatchList(repo, rw, ins); } }
private java.util.Optional<com.google.gerrit.server.patch.PatchListEntry> getPatchListEntry(org.eclipse.jgit.lib.ObjectReader objectReader, org.eclipse.jgit.diff.DiffFormatter diffFormatter, org.eclipse.jgit.diff.DiffEntry diffEntry, org.eclipse.jgit.revwalk.RevTree treeA, org.eclipse.jgit.revwalk.RevTree treeB, java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebase) throws java.io.IOException { org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(key.getNewId(), diffFormatter, diffEntry); long oldSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getOldMode(), diffEntry.getOldPath(), treeA); long newSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getNewMode(), diffEntry.getNewPath(), treeB); java.util.Set<org.eclipse.jgit.diff.Edit> contentEditsDueToRebase = com.google.gerrit.server.patch.PatchListLoader.getContentEdits(editsDueToRebase); com.google.gerrit.server.patch.PatchListEntry patchListEntry = com.google.gerrit.server.patch.PatchListLoader.newEntry(treeA, fileHeader, contentEditsDueToRebase, newSize, (newSize - oldSize)); if (com.google.gerrit.server.patch.EditTransformer.toEdits(patchListEntry).allMatch(editsDueToRebase::contains)) { return java.util.Optional.empty(); } return java.util.Optional.of(patchListEntry); }
private com.google.gerrit.server.patch.ComparisonType getComparisonType(org.eclipse.jgit.revwalk.RevObject a, org.eclipse.jgit.revwalk.RevCommit b) { for (int i = 0; i < (b.getParentCount()); i++) { if (b.getParent(i).equals(a)) { return com.google.gerrit.server.patch.ComparisonType.againstParent((i + 1)); } } if (((key.getOldId()) == null) && ((b.getParentCount()) > 0)) { return com.google.gerrit.server.patch.ComparisonType.againstAutoMerge(); } return com.google.gerrit.server.patch.ComparisonType.againstOtherPatchSet(); }
private com.google.gerrit.server.patch.PatchListEntry newMergeList(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit, com.google.gerrit.server.patch.ComparisonType comparisonType) throws java.io.IOException { com.google.gerrit.server.patch.Text aText = (aCommit != null) ? com.google.gerrit.server.patch.Text.forMergeList(comparisonType, reader, aCommit) : Text.EMPTY; com.google.gerrit.server.patch.Text bText = com.google.gerrit.server.patch.Text.forMergeList(comparisonType, reader, bCommit); return com.google.gerrit.server.patch.PatchListLoader.createPatchListEntry(cmp, aCommit, aText, bText, Patch.MERGE_LIST); }
private static java.util.Set<org.eclipse.jgit.diff.Edit> getContentEdits(java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebase) { return editsDueToRebase.stream().map(ContextAwareEdit::toEdit).filter(java.util.Optional::isPresent).map(java.util.Optional::get).collect(java.util.stream.Collectors.toSet()); }
private static com.google.gerrit.server.patch.PatchListEntry newEntry(org.eclipse.jgit.revwalk.RevTree aTree, org.eclipse.jgit.patch.FileHeader fileHeader, java.util.Set<org.eclipse.jgit.diff.Edit> editsDueToRebase, long size, long sizeDelta) { if (((aTree == null) || ((fileHeader.getPatchType()) != (org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED))) || (fileHeader.getHunks().isEmpty())) { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } java.util.List<org.eclipse.jgit.diff.Edit> edits = fileHeader.toEditList(); if (edits.isEmpty()) { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, edits, editsDueToRebase, size, sizeDelta); }
private org.eclipse.jgit.revwalk.RevObject aFor(com.google.gerrit.server.patch.PatchListKey key, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.revwalk.RevCommit b) throws java.io.IOException { if ((key.getOldId()) != null) { return rw.parseAny(key.getOldId()); } switch (b.getParentCount()) { case 0 : return rw.parseAny(com.google.gerrit.server.patch.PatchListLoader.emptyTree(ins)); case 1 : { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(0); rw.parseBody(r); return r; } case 2 : if ((key.getParentNum()) != null) { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(((key.getParentNum()) - 1)); rw.parseBody(r); return r; } return autoMerger.merge(repo, rw, ins, b, mergeStrategy); default : return null; } }
private java.util.List<com.google.gerrit.server.patch.PatchListEntry> getRelevantPatchListEntries(java.util.List<org.eclipse.jgit.diff.DiffEntry> parentDiffEntries, org.eclipse.jgit.revwalk.RevCommit parentCommitA, org.eclipse.jgit.revwalk.RevCommit parentCommitB, java.util.Set<java.lang.String> touchedFilePaths, org.eclipse.jgit.diff.DiffFormatter diffFormatter) throws java.io.IOException { java.util.List<com.google.gerrit.server.patch.PatchListEntry> parentPatchListEntries = new java.util.ArrayList(parentDiffEntries.size()); for (org.eclipse.jgit.diff.DiffEntry parentDiffEntry : parentDiffEntries) { if (!(com.google.gerrit.server.patch.PatchListLoader.isTouched(touchedFilePaths, parentDiffEntry))) { continue; } org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry); com.google.gerrit.server.patch.PatchListEntry patchListEntry = com.google.gerrit.server.patch.PatchListLoader.newEntry(parentCommitA.getTree(), fileHeader, com.google.common.collect.ImmutableSet.of(), 0, 0); parentPatchListEntries.add(patchListEntry); } return parentPatchListEntries; }
private static com.google.gerrit.server.patch.PatchListEntry createPatchListEntry(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.revwalk.RevCommit aCommit, com.google.gerrit.server.patch.Text aText, com.google.gerrit.server.patch.Text bText, java.lang.String fileName) { byte[] rawHdr = com.google.gerrit.server.patch.PatchListLoader.getRawHeader((aCommit != null), fileName); byte[] aContent = aText.getContent(); byte[] bContent = bText.getContent(); long size = bContent.length; long sizeDelta = (bContent.length) - (aContent.length); org.eclipse.jgit.diff.RawText aRawText = new org.eclipse.jgit.diff.RawText(aContent); org.eclipse.jgit.diff.RawText bRawText = new org.eclipse.jgit.diff.RawText(bContent); org.eclipse.jgit.diff.EditList edits = new org.eclipse.jgit.diff.HistogramDiff().diff(cmp, aRawText, bRawText); org.eclipse.jgit.patch.FileHeader fh = new org.eclipse.jgit.patch.FileHeader(rawHdr, edits, org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED); return new com.google.gerrit.server.patch.PatchListEntry(fh, edits, com.google.common.collect.ImmutableSet.of(), size, sizeDelta); }
private static java.util.Set<java.lang.String> getTouchedFilePaths(com.google.gerrit.server.patch.PatchListEntry patchListEntry) { java.lang.String oldFilePath = patchListEntry.getOldName(); java.lang.String newFilePath = patchListEntry.getNewName(); return oldFilePath == null ? com.google.common.collect.ImmutableSet.of(newFilePath) : com.google.common.collect.ImmutableSet.of(oldFilePath, newFilePath); }
public abstract com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsDueToRebasePerFilePath();
com.google.gerrit.server.patch.PatchListLoader create(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
private static java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsDueToRebase(com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath, org.eclipse.jgit.diff.DiffEntry diffEntry) { if (editsDueToRebasePerFilePath.isEmpty()) { return com.google.common.collect.ImmutableSet.of(); } java.lang.String filePath = diffEntry.getNewPath(); if ((diffEntry.getChangeType()) == (org.eclipse.jgit.diff.DiffEntry.ChangeType.DELETE)) { filePath = diffEntry.getOldPath(); } return com.google.common.collect.ImmutableSet.copyOf(editsDueToRebasePerFilePath.get(filePath)); }
public static com.google.gerrit.server.patch.PatchListLoader.EditsDueToRebaseResult create(java.util.List<org.eclipse.jgit.diff.DiffEntry> relevantDiffEntries, com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath) { return new com.google.gerrit.server.patch.AutoValue_PatchListLoader_EditsDueToRebaseResult(relevantDiffEntries, editsDueToRebasePerFilePath); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error("Couldn't fire event", e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.patch.IntraLineDiffKey key, com.google.gerrit.server.patch.IntraLineDiff value) { return ((((((((16 + (8 * 8)) + (2 * 36)) + 16) + (2 * 8)) + 16) + 8) + 4) + 20) + (((8 + 16) + (4 * 4)) * (value.getEdits().size())); }
private int search(java.lang.String fileName) { com.google.gerrit.server.patch.PatchListEntry want = com.google.gerrit.server.patch.PatchListEntry.empty(fileName); return java.util.Arrays.binarySearch(patches, 0, patches.length, want, com.google.gerrit.server.patch.PatchList.PATCH_CMP); }
private int countMagicFiles(java.util.List<com.google.gerrit.server.patch.PatchListEntry> entries) { int count = 0; for (com.google.gerrit.server.patch.PatchListEntry e : entries) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { count++; } } return count; }
private static java.lang.String getOldFilePath(com.google.gerrit.server.patch.PatchListEntry patchListEntry) { return com.google.common.base.MoreObjects.firstNonNull(patchListEntry.getOldName(), patchListEntry.getNewName()); }
static com.google.gerrit.server.patch.PatchListEntry readFrom(java.io.InputStream in) throws java.io.IOException { com.google.gerrit.reviewdb.client.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.ChangeType.values()); com.google.gerrit.reviewdb.client.Patch.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.PatchType.values()); java.lang.String oldName = readString(in); java.lang.String newName = readString(in); byte[] hdr = readBytes(in); int ins = readVarInt32(in); int del = readVarInt32(in); long size = readFixInt64(in); long sizeDelta = readFixInt64(in); org.eclipse.jgit.diff.Edit[] editArray = com.google.gerrit.server.patch.PatchListEntry.readEditArray(in); org.eclipse.jgit.diff.Edit[] editsDueToRebase = com.google.gerrit.server.patch.PatchListEntry.readEditArray(in); return new com.google.gerrit.server.patch.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.common.collect.ImmutableList.copyOf(editArray), com.google.common.collect.ImmutableSet.copyOf(editsDueToRebase), ins, del, size, sizeDelta); }
@java.lang.Override public int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getEndA(); }
@java.lang.Override public com.google.gerrit.server.patch.PatchList createValue(com.googlecode.prolog_cafe.lang.Prolog engine) { com.google.gerrit.server.rules.PrologEnvironment env = ((com.google.gerrit.server.rules.PrologEnvironment) (engine.control)); com.google.gerrit.reviewdb.client.PatchSet ps = com.google.gerrit.server.rules.StoredValues.getPatchSet(engine); com.google.gerrit.server.patch.PatchListCache plCache = env.getArgs().getPatchListCache(); com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.rules.StoredValues.getChange(engine); com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.patch.PatchListKey plKey = com.google.gerrit.server.patch.PatchListKey.againstDefaultBase(b, ws); com.google.gerrit.server.patch.PatchList patchList; try { patchList = plCache.get(plKey, project); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.googlecode.prolog_cafe.exceptions.SystemException(("Cannot create " + plKey)); } return patchList; }
private void writeObject(java.io.ObjectOutputStream output) throws java.io.IOException { final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); try (java.util.zip.DeflaterOutputStream out = new java.util.zip.DeflaterOutputStream(buf)) { writeCanBeNull(out, oldId); writeNotNull(out, newId); writeVarInt32(out, (isMerge ? 1 : 0)); comparisonType.writeTo(out); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeVarInt32(out, patches.length); for (com.google.gerrit.server.patch.PatchListEntry p : patches) { p.writeTo(out); } } writeBytes(output, buf.toByteArray()); }
public static com.google.gerrit.server.patch.ComparisonType againstOtherPatchSet() { return new com.google.gerrit.server.patch.ComparisonType(null, false); }
private static com.google.gerrit.reviewdb.client.Patch.PatchType toPatchType(org.eclipse.jgit.patch.FileHeader hdr) { com.google.gerrit.reviewdb.client.Patch.PatchType pt; switch (hdr.getPatchType()) { case UNIFIED : pt = com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED; break; case GIT_BINARY : case BINARY : pt = com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY; break; default : throw new java.lang.IllegalArgumentException(("Unsupported type " + (hdr.getPatchType()))); } if (pt != (com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY)) { final byte[] buf = hdr.getBuffer(); for (int ptr = hdr.getStartOffset(); ptr < (hdr.getEndOffset()); ptr++) { if ((buf[ptr]) == '\u0000') { pt = com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY; break; } } } return pt; }
void writeTo(java.io.OutputStream out) throws java.io.IOException { writeEnum(out, changeType); writeEnum(out, patchType); writeString(out, oldName); writeString(out, newName); writeBytes(out, header); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeFixInt64(out, size); writeFixInt64(out, sizeDelta); com.google.gerrit.server.patch.PatchListEntry.writeEditArray(out, edits); com.google.gerrit.server.patch.PatchListEntry.writeEditArray(out, editsDueToRebase); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
public java.util.List<com.google.gerrit.server.patch.PatchListEntry> getPatches() { return java.util.Collections.unmodifiableList(java.util.Arrays.asList(patches)); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error("Couldn't fire event", e); } }
@java.lang.Override public int compare(com.google.gerrit.server.patch.PatchListEntry a, com.google.gerrit.server.patch.PatchListEntry b) { return com.google.gerrit.server.patch.PatchList.comparePaths(a.getNewName(), b.getNewName()); }
public com.google.gerrit.reviewdb.client.Patch.PatchType getPatchType() { return patchType; }
private static byte[] compact(org.eclipse.jgit.patch.FileHeader h) { final int end = com.google.gerrit.server.patch.PatchListEntry.end(h); if (((h.getStartOffset()) == 0) && (end == (h.getBuffer().length))) { return h.getBuffer(); } final byte[] buf = new byte[end - (h.getStartOffset())]; java.lang.System.arraycopy(h.getBuffer(), h.getStartOffset(), buf, 0, buf.length); return buf; }
public java.util.List<com.google.gerrit.reviewdb.client.Patch> toPatchList(com.google.gerrit.reviewdb.client.PatchSet.Id setId) { final java.util.ArrayList<com.google.gerrit.reviewdb.client.Patch> r = new java.util.ArrayList(patches.length); for (com.google.gerrit.server.patch.PatchListEntry e : patches) { r.add(e.toPatch(setId)); } return r; }
int weigh() { int size = ((((((16 + (6 * 8)) + (2 * 4)) + 20) + 16) + 8) + 4) + 20; size += com.google.gerrit.server.patch.PatchListEntry.stringSize(oldName); size += com.google.gerrit.server.patch.PatchListEntry.stringSize(newName); size += header.length; size += ((8 + 16) + (4 * 4)) * (edits.size()); size += ((8 + 16) + (4 * 4)) * (editsDueToRebase.size()); return size; }
public com.google.gerrit.server.patch.PatchListEntry get(java.lang.String fileName) { final int index = search(fileName); return 0 <= index ? patches[index] : com.google.gerrit.server.patch.PatchListEntry.empty(fileName); }
static com.google.gerrit.server.patch.PatchListEntry empty(java.lang.String fileName) { return new com.google.gerrit.server.patch.PatchListEntry(com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.patch.PatchListEntry.EMPTY_HEADER, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), 0, 0, 0, 0); }
private byte[] getMergeList(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change.Id changeId = notes.getChangeId(); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), notes); if (ps == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(notes.getProjectName());org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(git)) { return com.google.gerrit.server.patch.Text.forMergeList(com.google.gerrit.server.patch.ComparisonType.againstAutoMerge(), revWalk.getObjectReader(), org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())).getContent(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
public com.google.gerrit.server.patch.ComparisonType getComparisonType() { return comparisonType; }
private void readObject(java.io.ObjectInputStream input) throws java.io.IOException { final java.io.ByteArrayInputStream buf = new java.io.ByteArrayInputStream(readBytes(input)); try (java.util.zip.InflaterInputStream in = new java.util.zip.InflaterInputStream(buf)) { oldId = readCanBeNull(in); newId = readNotNull(in); isMerge = (readVarInt32(in)) != 0; comparisonType = com.google.gerrit.server.patch.ComparisonType.readFrom(in); insertions = readVarInt32(in); deletions = readVarInt32(in); final int cnt = readVarInt32(in); final com.google.gerrit.server.patch.PatchListEntry[] all = new com.google.gerrit.server.patch.PatchListEntry[cnt]; for (int i = 0; i < (all.length); i++) { all[i] = com.google.gerrit.server.patch.PatchListEntry.readFrom(in); } patches = all; } }
private static java.util.List<org.eclipse.jgit.diff.Edit> intraline(java.lang.String a, java.lang.String b, org.eclipse.jgit.diff.Edit lines) throws java.lang.Exception { com.google.gerrit.server.patch.Text aText = new com.google.gerrit.server.patch.Text(a.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.patch.Text bText = new com.google.gerrit.server.patch.Text(b.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.patch.IntraLineDiff diff = com.google.gerrit.server.patch.IntraLineLoader.compute(aText, bText, com.google.common.collect.ImmutableList.of(lines)); assertThat(diff.getStatus()).isEqualTo(IntraLineDiff.Status.EDIT_LIST); java.util.List<org.eclipse.jgit.diff.Edit> actualEdits = diff.getEdits(); assertThat(actualEdits).hasSize(1); org.eclipse.jgit.diff.Edit actualEdit = actualEdits.get(0); assertThat(actualEdit.getBeginA()).isEqualTo(lines.getBeginA()); assertThat(actualEdit.getEndA()).isEqualTo(lines.getEndA()); assertThat(actualEdit.getBeginB()).isEqualTo(lines.getBeginB()); assertThat(actualEdit.getEndB()).isEqualTo(lines.getEndB()); assertThat(actualEdit).isInstanceOf(org.eclipse.jgit.diff.ReplaceEdit.class); return ((org.eclipse.jgit.diff.ReplaceEdit) (actualEdit)).getInternalEdits(); }
@java.lang.SuppressWarnings("deprecation") private static org.eclipse.jgit.lib.ObjectId getNoteKey(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { return org.eclipse.jgit.lib.ObjectId.fromRaw(com.google.common.hash.Hashing.sha1().hashString(groupName.get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()); }


private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log(com.google.gerrit.reviewdb.client.AccountGroup g) throws java.lang.Exception { com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> result = com.google.common.collect.ImmutableList.of(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(g.getGroupUUID())); if (ref != null) { rw.sort(RevSort.REVERSE); rw.setRetainBody(true); rw.markStart(rw.parseCommit(ref.getObjectId())); result = com.google.common.collect.Streams.stream(rw).map(CommitUtil::toCommitInfo).collect(toImmutableList()); } } return result; }
private static java.lang.String getAsNoteData(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM, uuid.get()); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM, groupName.get()); return config.toText(); }
private static com.google.gerrit.common.data.GroupReference getGroupReference(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.ObjectId noteDataBlobId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { byte[] noteData = reader.open(noteDataBlobId, com.google.gerrit.server.group.db.OBJ_BLOB).getCachedBytes(); return com.google.gerrit.server.group.db.GroupNameNotes.getFromNoteData(noteData); }
@java.lang.Override public void run() { com.google.gerrit.server.account.AccountDeactivator.log.debug("Running account deactivations"); try { int numberOfAccountsDeactivated = 0; for (com.google.gerrit.server.account.AccountState acc : accountQueryProvider.get().query(com.google.gerrit.server.query.account.AccountPredicates.isActive())) { com.google.gerrit.server.account.AccountDeactivator.log.debug(("processing account " + (acc.getUserName()))); if (((acc.getUserName()) != null) && (!(realm.isActive(acc.getUserName())))) { sif.deactivate(acc.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivator.log.debug(("deactivated accout " + (acc.getUserName()))); numberOfAccountsDeactivated++; } } com.google.gerrit.server.account.AccountDeactivator.log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error(("Failed to deactivate inactive accounts " + (e.getMessage())), e); } }
private boolean matchCriteria(com.google.gerrit.server.config.PluginConfig config, java.lang.String criteria, java.lang.String value, boolean allowRegex, boolean refMatcher) { boolean match = true; for (java.lang.String s : config.getStringList(criteria)) { if ((allowRegex && (com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.match(value, s, refMatcher))) || ((!allowRegex) && (s.equals(value)))) { return true; } match = false; } return match; }
@java.lang.Override public org.apache.http.impl.client.CloseableHttpClient get() { return org.apache.http.impl.client.HttpClients.custom().setConnectionManager(customConnectionManager()).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build(); }


@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class); bind(org.apache.http.impl.client.CloseableHttpClient.class).toProvider(com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class).in(Scopes.SINGLETON); factory(PostTask.Factory.class); factory(RemoteConfig.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); install(processors); }
@org.junit.Test public void pushToGroupBranchForNonAllUsersRepo() throws java.lang.Exception { pushToGroupBranch(project, null, null); }
private void pushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").setParents(com.google.common.collect.ImmutableList.of()).to(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo")))); if (expectedErrorOnCreate != null) { r.assertErrorStatus(expectedErrorOnCreate); } else { r.assertOkStatus(); } java.lang.String groupRefName = (com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("bar")); createGroupBranch(project, groupRefName); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").to(groupRefName); if (expectedErrorOnUpdate != null) { r.assertErrorStatus(expectedErrorOnUpdate); } else { r.assertOkStatus(); } }



@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { pushToGroupBranch(allUsers, "Not allowed to create group branch.", "group update not allowed"); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { for (com.google.gerrit.index.Index<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.account.AccountState> i : getWriteIndexes()) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull(id); if (accountState != null) { i.replace(accountState); } else { i.delete(id); } } fireAccountIndexedEvent(id.get()); }






@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.project.ProjectData> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.project.ProjectData> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneProjectIndex.QuerySource(opts, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneProjectIndex.NAME_SORT_FIELD, SortField.Type.STRING, false))); }

@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.group.InternalGroup> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.group.InternalGroup> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneGroupIndex.QuerySource(opts, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneGroupIndex.UUID_SORT_FIELD, SortField.Type.STRING, false))); }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.account.AccountState> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.account.AccountState> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneAccountIndex.QuerySource(opts, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneAccountIndex.ID_SORT_FIELD, SortField.Type.LONG, true))); }































@org.junit.Test public void getAuditLog() throws java.lang.Exception { assume().that(cfg.getBoolean("user", null, "readGroupsFromNoteDb", false)).isFalse(); com.google.gerrit.extensions.api.groups.GroupApi g = gApi.groups().create(name("group")); java.util.List<? extends com.google.gerrit.extensions.common.GroupAuditEventInfo> auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(1); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, admin.id); g.addMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(2); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id); g.removeMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(3); assertAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id); java.lang.String otherGroup = name("otherGroup"); gApi.groups().create(otherGroup); g.addGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(4); assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup); g.removeGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(5); assertAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup); java.sql.Timestamp lastDate = null; for (com.google.gerrit.extensions.common.GroupAuditEventInfo auditEvent : auditEvents) { if (lastDate != null) { assertThat(lastDate).isGreaterThan(auditEvent.date); } lastDate = auditEvent.date; } }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { if (readFromNoteDb) { throw new com.google.gwtorm.server.OrmException("Audit logs not yet implemented in NoteDb"); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { if (readFromNoteDb) { throw new com.google.gwtorm.server.OrmException("Audit logs not yet implemented in NoteDb"); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); }

public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getSubgroupsAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> audits = db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); java.util.Collections.sort(audits, java.util.Comparator.comparing((com.google.gerrit.reviewdb.client.AccountGroupByIdAud a) -> a.getAddedOn())); return audits; }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getMembersAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> audits = db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); java.util.Collections.sort(audits, java.util.Comparator.comparing((com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a) -> a.getAddedOn())); return audits; }