static java.util.Map<java.lang.String, java.lang.Integer> getVotes(com.google.gerrit.server.<START_MOD>account.AccountCache accountCache, com.google.gerrit.server.<END_MOD>query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, java.lang.Integer> map = new java.util.HashMap<>(); com.<START_MOD>googlesource.gerrit.plugins.findowners.AccountAccess ac = db.accounts(); for (com.<END_MOD>google.gerrit.reviewdb.client.PatchSetApproval p : changeData.currentApprovals()) { if ((p.getValue()) != 0) { <START_MOD>map.put(accountCache.get(<END_MOD>p.getAccountId()<START_MOD>).getAccount().getPreferredEmail(), java.lang.Integer.valueOf(p.getValue())); } } return<END_MOD> map; }
private java.lang.String readCookie() { javax.servlet.http.Cookie[] all = request.getCookies(); if (all != null) { for (javax.servlet.http.Cookie c : all) { if (com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE.equals(c.getName())) { java.lang.String v = c.getValue(); return (v != null) && (!("".equals(v))) ? v : null; } } } return <START_MOD>getQueryParameter(com.google.gerrit.httpd.CacheBasedWebSession.XD_AUTHORIZATION)<END_MOD>; }
<START_MOD>private java.lang.String getQueryParameter(java.lang.String param) { java.lang.String queryString = request.getQueryString(); if ((!(com.google.common.base.Strings.isNullOrEmpty(queryString))) && (queryString.contains(param))) { for (java.lang.String kvPair : com.google.common.base.Splitter.on('&').split(queryString)) { java.util.Iterator<java.lang.String> i = com.google.common.base.Splitter.on('=').limit(2).split(kvPair).iterator(); java.lang.String key = com.google.gerrit.extensions.restapi.Url.decode(i.next()); if (param.equals(key)) { return i.hasNext() ? com.google.gerrit.extensions.restapi.Url.decode(i.next()) : null; } } } return null; }<END_MOD>
private static void setCorsHeaders(javax.servlet.http.HttpServletResponse res, java.lang.String origin) { res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_ORIGIN, origin); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_MAX_AGE, "600"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_METHODS, <START_MOD>com.google.common.base.Joiner.on(<END_MOD>  <START_MOD> com.google.common.collect.ImmutableList.of("HEAD"<END_MOD>, <START_MOD>"OPTIONS"))));<END_MOD> res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_HEADERS, com.google.common.base.Joiner.on(   }
<START_MOD>private static javax.servlet.http.HttpServletRequest applyXdOverrides(javax.servlet.http.HttpServletRequest req, com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> xd) throws com.google.gerrit.extensions.restapi.BadRequestException { java.lang.String method = com.google.common.collect.Iterables.getFirst(xd.get(com.google.gerrit.httpd.restapi.RestApiServlet.XD_METHOD), null); if (!(com.google.gerrit.httpd.restapi.RestApiServlet.ALLOWED_XD_METHODS.contains(method))) { com.google.gerrit.httpd.restapi.RestApiServlet.log.error(("method " + method)); throw new com.google.gerrit.extensions.restapi.BadRequestException("method not allowed"); } java.lang.String contentType = com.google.common.collect.Iterables.getFirst(xd.get(com.google.gerrit.httpd.restapi.RestApiServlet.XD_CONTENT_TYPE), null); if ((method.equals("POST")) || (method.equals("PUT"))) { if (!("text/plain".equals(req.getContentType()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("invalid " + (CONTENT_TYPE))); } else if (com.google.common.base.Strings.isNullOrEmpty(contentType)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(((com.google.gerrit.httpd.restapi.RestApiServlet.XD_CONTENT_TYPE) + " required")); } } return new javax.servlet.http.HttpServletRequestWrapper(req) { @java.lang.Override public java.lang.String getMethod() { return method; } @java.lang.Override public java.lang.String getContentType() { return contentType; } }; }<END_MOD>
@org.junit.After public void cleanUp() throws java.lang.Exception { gApi.accounts().id(user42.getId().toString()).setPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } <START_MOD>for (com.google.gerrit.reviewdb.client.Account.Id id : accounts.allIds()) { <END_MOD>accountCache.<START_MOD>evict(id); } }<END_MOD>
@org.junit.After public void cleanUp() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } <START_MOD>for (com.google.gerrit.reviewdb.client.Account.Id id : accounts.allIds()) { <END_MOD>accountCache.<START_MOD>evict<END_MOD>(<START_MOD>id<END_MOD>); }<START_MOD> }<END_MOD>
private com.google.gerrit.extensions.client.GeneralPreferencesInfo writeToGit(com.google.gerrit.extensions.client.GeneralPreferencesInfo i) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.config.ConfigUtil.storeSection(p.getConfig(), UserConfigSections.GENERAL, null, i, com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); com.google.gerrit.server.account.SetPreferences.storeUrlAliases(p, i.urlAliases); p.commit(md); <START_MOD>for (com.google.gerrit.reviewdb.client.Account.Id id : accounts.allIds()) { <END_MOD>accountCache.<START_MOD>evict(id); }<END_MOD> com.google.gerrit.extensions.client.GeneralPreferencesInfo r = com.google.gerrit.server.config.ConfigUtil.loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new com.google.gerrit.extensions.client.GeneralPreferencesInfo(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(), null); return loader.loadMyMenusAndUrlAliases(r, p, null); } }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate()<START_MOD>.setRefLogMessage("push")<END_MOD>); } return updates; }
<START_MOD>public static boolean isGroupReference(java.lang.String configValue) { return configValue.startsWith(com.google.gerrit.common.data.GroupReference.PREFIX); }<END_MOD>
public com.google.gerrit.server.git.WorkQueue.Executor createQueue(int poolsize, java.lang.String prefix) { <START_MOD>createQueue<END_MOD>(poolsize, prefix<START_MOD>, java.lang.Thread.NORM_PRIORITY<END_MOD>); }
@java.lang.Override public WorkQueue.Executor get() { <START_MOD>return<END_MOD> queues.createQueue(poolSize, "SSH-Stream-Worker"<START_MOD>,<END_MOD> java.lang.Thread.MIN_PRIORITY); }
<START_MOD>public com.google.gerrit.server.git.WorkQueue.Executor createQueue(int poolsize, java.lang.String prefix, int threadPriority) { final com.google.gerrit.server.git.WorkQueue.Executor r = new com.google.gerrit.server.git.WorkQueue.Executor(poolsize, prefix); if (threadPriority != (java.lang.Thread.NORM_PRIORITY)) { final java.util.concurrent.ThreadFactory parent = r.getThreadFactory(); r.setThreadFactory(( task) -> { final java.lang.Thread t = parent.newThread(task); t.setPriority(java.lang.Thread.MIN_PRIORITY); return t; }); } r.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); r.setExecuteExistingDelayedTasksAfterShutdownPolicy(true); queues.add(r); return r; }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setTrialMode(boolean trial) { this.trial = trial; return this; }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setForceRebuild(boolean forceRebuild) { this.forceRebuild = forceRebuild; return this; }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setThreads(int threads) { executor = (threads > 1) ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService(); return this; }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setChanges(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id> changes) { this.changes = (changes != null) ? com.google.common.collect.ImmutableList.copyOf(changes) : com.google.common.collect.ImmutableList.of(); return this; }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setProjects(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) { this.projects = (projects != null) ? com.google.common.collect.ImmutableList.copyOf(projects) : com.google.common.collect.ImmutableList.of(); return this; }<END_MOD>
@java.lang.Override public void close() { <START_MOD>if ((executor) != null) { <END_MOD>executor.shutdownNow(); }<START_MOD> }<END_MOD>
private void checkPreconditions() { checkState((!(started)),   may only be used once }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); if (!(notesMigration.enabled())) { throw die( is not enabled. } com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); <START_MOD>try (com.google.gerrit.server.notedb.rebuild.SiteRebuilder rebuilder = rebuilderProvider.get().setThreads(threads).setProgressOut(<END_MOD>java.lang.System.<START_MOD>err).setProjects(<END_MOD>projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList())<START_MOD>).setChanges(<END_MOD>changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList()))) { return rebuilder.rebuild() ?   : 1; } }
<START_MOD>public void autoRebuild() throws com.google.gwtorm.server.OrmException, java.io.IOException { checkAutoRebuildPreconditions(); java.util.Optional<com.google.gerrit.server.notedb.NotesMigrationState> maybeState = loadState(); if (!(maybeState.isPresent())) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException("Could not determine initial migration state"); } com.google.gerrit.server.notedb.NotesMigrationState state = maybeState.get(); if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) > 0)) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes")); } boolean rebuilt = false; while ((state.compareTo(NotesMigrationState.NOTE_DB_UNFUSED)) < 0) { if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) >= 0)) { return; } switch (state) { case REVIEW_DB : state = turnOnWrites(state); break; case WRITE : state = rebuildAndEnableReads(state); rebuilt = true; break; case READ_WRITE_NO_SEQUENCE : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = enableSequences(); break; case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = setNoteDbPrimary(); break; case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY : state = disableReviewDb(); break; case NOTE_DB_UNFUSED : break; case NOTE_DB : default : throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration out of the following state is not supported:\n" + (state.toText()))); } } }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.SiteRebuilder setProgressOut(java.io.OutputStream progressOut) { this.progressOut = checkNotNull(progressOut); return this; }<END_MOD>
<START_MOD>@org.junit.Test public void rebuildEmptySiteStartingWithNoteDbDisabed() throws java.lang.Exception { setNotesMigrationState(NotesMigrationState.REVIEW_DB); com.google.gerrit.acceptance.pgm.RebuildNoteDbIT.runGerrit("RebuildNoteDb", "-d", sitePath, "--show-stack-trace"); assertNotesMigrationState(NotesMigrationState.READ_WRITE_NO_SEQUENCE); }<END_MOD>
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setForceRebuild(boolean forceRebuild) { this.forceRebuild = forceRebuild; return this; }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); try (com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> rebuilder = <START_MOD>migratorProvider<END_MOD>.get().setThreads(threads).setProgressOut(java.lang.System.err).setProjects(projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList())).setChanges(changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList()))) { if ((!(<START_MOD>changes.isEmpty())) || (!(<END_MOD>projects.isEmpty()))) { rebuilder.rebuild(); } else { rebuilder.<START_MOD>setTrialMode(trial).setForceRebuild(force).migrate<END_MOD>(); } } return 0; }
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setTrialMode(boolean trial) { this.trial = trial; return this; }
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setProjects(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) { this.projects = (projects != null) ? com.google.common.collect.ImmutableList.copyOf(projects) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setThreads(int threads) { executor = (threads > 1) ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService(); return this; }
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setChanges(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id> changes) { this.changes = (changes != null) ? com.google.common.collect.ImmutableList.copyOf(changes) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.<START_MOD>NoteDbMigrator<END_MOD> setProgressOut(java.io.OutputStream progressOut) { this.progressOut = checkNotNull(progressOut); return this; }
public void <START_MOD>migrate<END_MOD>() throws com.google.gwtorm.server.OrmException, java.io.IOException { checkAutoRebuildPreconditions(); java.util.Optional<com.google.gerrit.server.notedb.NotesMigrationState> maybeState = loadState(); if (!(maybeState.isPresent())) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException( not determine initial migration state } com.google.gerrit.server.notedb.NotesMigrationState state = maybeState.get(); if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) > 0)) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException(( has already progressed past the endpoint of the   mode state; +   NoteDb is already the primary storage for some changes } boolean rebuilt = false; while ((state.compareTo(NotesMigrationState.NOTE_DB_UNFUSED)) < 0) { if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) >= 0)) { return; } switch (state) { case REVIEW_DB : state = turnOnWrites(state); break; case WRITE : state = rebuildAndEnableReads(state); rebuilt = true; break; case READ_WRITE_NO_SEQUENCE : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = enableSequences(); break; case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = setNoteDbPrimary(); break; case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY : state = disableReviewDb(); break; case NOTE_DB_UNFUSED : break; case NOTE_DB : default : throw new com.google.gerrit.server.notedb.rebuild.MigrationException(( out of the following state is not supported: + (state.toText()))); } } }
private void checkPreconditions() { checkState((!(started)),   may only be used once <START_MOD>getClass().getSimpleName()); <END_MOD>}
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get()); if (ctl.<START_MOD>getProject<END_MOD>(<START_MOD>).getState().equals(ProjectState.HIDDEN<END_MOD>)) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(name); return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(ctl, repo, <START_MOD>visibleRefFilterFactory<END_MOD>.<START_MOD>create(ctl<END_MOD>.<START_MOD>getProjectState<END_MOD>(), <START_MOD>repo<END_MOD>)); }
public org.eclipse.jgit.lib.ObjectId sha1() { <START_MOD>@java.lang.SuppressWarnings("deprecation")<END_MOD> <START_MOD>byte[] h = <END_MOD>com.google.common.hash.Hashing.sha1().hashString(get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()<START_MOD>; return org.eclipse.jgit.lib.ObjectId.fromRaw(h<END_MOD>); }
private java.lang.String etag(com.google.gitiles.doc.DocServlet.MarkdownFile srcmd, @javax.annotation.Nullable com.google.gitiles.doc.DocServlet.MarkdownFile navmd) { byte[] b = new byte[org.eclipse.jgit.lib.Constants.OBJECT_ID_LENGTH]; <START_MOD>@java.lang.SuppressWarnings("deprecation") <END_MOD>com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); h.putInt(com.google.gitiles.doc.DocServlet.ETAG_GEN); renderer.getTemplateHash(com.google.gitiles.doc.DocServlet.SOY_FILE).writeBytesTo(b, 0, b.length); h.putBytes(b); if (navmd != null) { navmd.id.copyRawTo(b, 0); h.putBytes(b); } srcmd.id.copyRawTo(b, 0); h.putBytes(b); return h.hash().toString(); }
private static java.lang.String randSuffix() {<START_MOD> @java.lang.SuppressWarnings("deprecation")<END_MOD> com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); byte[] buf = new byte[8]; org.eclipse.jgit.util.NB.encodeInt64(buf, 0, com.google.gerrit.common.TimeUtil.nowMs()); h.putBytes(buf); com.google.gerrit.server.change.FileContentUtil.rng.nextBytes(buf); h.putBytes(buf); return h.hash().toString(); }
@java.lang.Override public java.lang.String getETag(com.google.gerrit.server.change.RevisionResource rsrc) { <START_MOD>@java.lang.SuppressWarnings("deprecation") <END_MOD>com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); com.google.gerrit.server.CurrentUser user = rsrc.getControl().getUser(); try { rsrc.getChangeResource().prepareETag(h, user); h.putBoolean(com.google.gerrit.server.change.Submit.wholeTopicEnabled(config)); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.get().completeChangeSet(db, rsrc.getChange(), user); for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { changeResourceFactory.create(cd.changeControl()).prepareETag(h, user); } h.putBoolean(cs.furtherHiddenChanges()); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gwtorm.server.OrmRuntimeException(e); } return h.hash().toString(); }
com.google.common.hash.HashCode computeTemplateHash(java.lang.String soyFile) { java.net.URL u = templates.get(soyFile); checkState((u != null),   Soy template %s soyFile); <START_MOD>@java.lang.SuppressWarnings("deprecation") <END_MOD>com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); try (java.io.InputStream is = u.openStream();java.io.OutputStream os = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(is, os); } catch (java.io.IOException e) { throw new java.lang.IllegalStateException(( Soy template   + soyFile), e); } return h.hash(); }
@java.lang.Override public java.lang.String getETag() { com.google.gerrit.server.CurrentUser user = control.getUser();<START_MOD> @java.lang.SuppressWarnings("deprecation")<END_MOD> com.google.common.hash.Hasher h = com.google.common.hash.Hashing.md5().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, user); return h.hash().toString(); }
private void verifyFileChecksum() { if ((sha1) == null) { java.lang.System.err.println(); java.lang.System.err.flush(); return; }<START_MOD> @java.lang.SuppressWarnings("deprecation")<END_MOD> com.google.common.hash.Hasher h = com.google.common.hash.Hashing.sha1().newHasher(); try (java.io.InputStream in = java.nio.file.Files.newInputStream(dst);java.io.OutputStream out = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(in, out); } catch (java.io.IOException e) { deleteDst(); throw new com.google.gerrit.common.Die(( checksum   + (dst)), e); } if (sha1.equals(h.hash().toString())) { java.lang.System.err.println(((   + (dst.getFileName())) +   OK java.lang.System.err.flush(); } else if (ui.isBatch()) { deleteDst(); throw new com.google.gerrit.common.Die(((dst) +   SHA-1 checksum does not match } else if (!(ui.yesno(null,   SHA-1 checksum does not match %s anyway dst.getFileName()))) { deleteDst(); throw new com.google.gerrit.common.Die( by user } }
public static com.google.gerrit.server.change.PostReview.CommentSetEntry create(com.google.gerrit.reviewdb.client.Comment comment) {<START_MOD> @java.lang.SuppressWarnings("deprecation") com.google.common.hash.HashCode h = com.google.common.hash.Hashing.sha1().hashString(comment.message, java.nio.charset.StandardCharsets.UTF_8);<END_MOD> return com.google.gerrit.server.change.PostReview.CommentSetEntry.create(comment.key.filename, comment.key.patchSetId, comment.lineNbr, com.google.gerrit.extensions.client.Side.fromShort(comment.side), <START_MOD>h<END_MOD>, comment.range); }
public final void addOps(com.google.gerrit.server.update.BatchUpdate bu, java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = buildOps(toMerge); java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> added = com.google.common.collect.Sets.newHashSetWithExpectedSize(ops.size()); for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { added.add(op.getCommit()); } java.util.List<com.google.gerrit.server.git.CodeReviewCommit> difference = new java.util.ArrayList(com.google.common.collect.Sets.difference(toMerge, added)); java.util.Collections.reverse(difference); for (com.google.gerrit.server.git.CodeReviewCommit c : difference) { <START_MOD>com.google.gerrit.reviewdb.client.Change.Id id = c.change().getId(); <END_MOD>bu.addOp(c.change().getId(), new com.google.gerrit.server.git.strategy.ImplicitIntegrateOp(args, c)); <START_MOD>maybeAddTestHelperOp(bu, id); <END_MOD>} for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { bu.addOp(op.getId(), op); <START_MOD>maybeAddTestHelperOp(bu, op.getId()); <END_MOD>} }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate()); } return updates; }
<START_MOD>private org.eclipse.jgit.revwalk.RevCommit parseCurrentRevision(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { return rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(get(r.getChangeId(), ListChangesOption.CURRENT_REVISION).currentRevision)); }<END_MOD>
public final org.eclipse.jgit.notes.NoteMap commitNewNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws <START_MOD>com.google.gerrit.server.git.LockFailureException, <END_MOD>java.io.IOException { this.overwrite = false; commitNotes(notes, notesBranch, commitAuthor, commitMessage); org.eclipse.jgit.notes.NoteMap newlyCreated = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); for (org.eclipse.jgit.notes.Note n : notes) { if (((base) == null) || (!(base.contains(n)))) { newlyCreated.set(n, n.getData()); } } return newlyCreated; }
@java.lang.Override public com.google.gerrit.server.project.BanCommit.BanResultInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.<START_MOD>server.update.UpdateException { return retryHelper.execute(( updateFactory) -> { com.google.gerrit.server.project<END_MOD>.BanResultInfo r = new com.google.gerrit.server.project.BanResultInfo(); if (((input != null) && (input.commits != null)) && (!(input.commits.isEmpty()))) { List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new <START_MOD>com.google.gerrit.server.project<END_MOD>.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch ( e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(<START_MOD>com.google.gerrit.server.project.<END_MOD>e.getMessage()); } } try { com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits()); r.ignored = transformCommits(result.getIgnoredObjectIds()); } catch ( e) { throw new com.google.gerrit.extensions.restapi.AuthException(<START_MOD>com.google.gerrit.server.project.<END_MOD>e.getMessage()); } } return r; }<START_MOD>); }<END_MOD>
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectControl), input); printCommits(r.newlyBanned,   following commits were banned printCommits(r.alreadyBanned,   following commits were already banned printCommits(r.ignored,   following ids do not represent commits and were ignored } catch (com.google.gerrit.extensions.restapi.RestApiException | <START_MOD>com.google.gerrit.server.update.UpdateException<END_MOD> e) { throw die(e); } }
public final void commitAllNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws <START_MOD>com.google.gerrit.server.git.LockFailureException, <END_MOD>java.io.IOException { this.overwrite = true; commitNotes(notes, notesBranch, commitAuthor, commitMessage); }
<START_MOD>void message(java.lang.String message) throws com.google.gerrit.extensions.restapi.RestApiException;<END_MOD>
<START_MOD>private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repository, org.eclipse.jgit.revwalk.RevCommit basePatchSetCommit, org.eclipse.jgit.lib.ObjectId tree, java.lang.String commitMessage, java.sql.Timestamp timestamp) throws java.io.IOException { try (org.eclipse.jgit.lib.ObjectInserter objectInserter = repository.newObjectInserter()) { org.eclipse.jgit.lib.CommitBuilder builder = new org.eclipse.jgit.lib.CommitBuilder(); builder.setTreeId(tree); builder.setParentIds(basePatchSetCommit.getParents()); builder.setAuthor(basePatchSetCommit.getAuthorIdent()); builder.setCommitter(currentUserProvider.get().asIdentifiedUser().newCommitterIdent(timestamp, tz)); builder.setMessage(commitMessage); org.eclipse.jgit.lib.ObjectId newCommitId = objectInserter.insert(builder); objectInserter.flush(); return newCommitId; } }<END_MOD>
<START_MOD>@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.PutMessage.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.edit.UnchangedCommitMessageException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes()); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } else if (!(rsrc.getControl().isPatchVisible(ps, dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("current revision not accessible"); } return putMessage.applyImpl(updateFactory, new com.google.gerrit.server.change.RevisionResource(rsrc, ps), input); }<END_MOD>
<START_MOD>@java.lang.Override public void message(java.lang.String message) { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }<END_MOD>
<START_MOD>@java.lang.Override public void message(java.lang.String message) throws com.google.gerrit.extensions.restapi.RestApiException { current().message(message); }<END_MOD>
public boolean doCanForDefaultPermissionBackend(com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { if (perm instanceof com.google.gerrit.server.permissions.GlobalPermission) { return can(((com.google.gerrit.server.permissions.GlobalPermission) (perm))); } else if (perm instanceof com.google.gerrit.extensions.api.access.PluginPermission) { return (canPerform(perm.permissionName())) || (<START_MOD>isAdmin<END_MOD>()); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
private WorkQueue.Executor getExecutor() { <START_MOD>com.google.gerrit.server.git.QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType(); <END_MOD>return queue.getQueue(<START_MOD>qt<END_MOD>); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set work in progress } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( is   + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is already work in progress } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), new com.google.gerrit.server.change.WorkInProgressOp(cmUtil, <START_MOD>null, null, <END_MOD>true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set ready for review } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( is   + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is not work in progress } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), new com.google.gerrit.server.change.WorkInProgressOp(cmUtil, <START_MOD>email, psUtil, <END_MOD>false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
<START_MOD>@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { if (((email) == null) || ((ps) == null)) { return; } email.create(NotifyHandling.ALL, com.google.common.collect.ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, com.google.common.collect.ImmutableList.of(), cmsg.getMessage(), com.google.common.collect.ImmutableList.of()).sendAsync(); }<END_MOD>
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { <START_MOD>change = ctx.getChange(); notes = ctx.getNotes(); if ((psUtil) != null) { ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId()); } <END_MOD>com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); change.setWorkInProgress(workInProgress); if ((!(change.hasReviewStarted())) && (!(workInProgress))) { change.setReviewStarted(true); } change.setLastUpdatedOn(ctx.getWhen()); update.setWorkInProgress(workInProgress); addMessage(ctx, update); return true; }
<START_MOD>private void startReview(com.google.gerrit.acceptance.server.mail.StagedChange sc) throws com.google.gerrit.extensions.restapi.RestApiException { setApiUser(sc.owner); gApi.changes().id(sc.changeId).setReadyForReview(); gApi.changes().id(sc.changeId).revision("current").review(com.google.gerrit.extensions.api.changes.ReviewInput.noScore()); }<END_MOD>
<START_MOD>protected com.google.gerrit.acceptance.GerritServer startServer() throws java.lang.Exception { return com.google.gerrit.acceptance.GerritServer.start(serverDesc, baseConfig, sitePaths.site_path); }<END_MOD>
@org.junit.Test public void migrationDoesNotRequireIndex() throws java.lang.Exception { assertNotesMigrationState(NotesMigrationState.REVIEW_DB); setUpOneChange(); int version = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion(); com.google.gerrit.server.index.GerritIndexStatus status = new com.google.gerrit.server.index.GerritIndexStatus(<START_MOD>sitePaths); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isTrue(); status.setReady(ChangeSchemaDefinitions.NAME, version, false); status.save(); migrate("--trial", "false"); assertNotesMigrationState(NotesMigrationState.NOTE_DB_UNFUSED); status = <END_MOD>new com.google.gerrit.server.<START_MOD>index.GerritIndexStatus(sitePaths<END_MOD>); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isFalse(); try (com.google.gerrit.acceptance.GerritServer server = startServer()) { fail( server startup to fail } catch (com.google.gerrit.acceptance.GerritServer e) { } }
<START_MOD>@org.junit.Test public void enableSequencesWithGap() throws java.lang.Exception { testEnableSequences(null, 503, "513"); }<END_MOD>
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator build() throws com.google.gerrit.server.notedb.rebuild.MigrationException { return new com.google.gerrit.server.notedb.rebuild.NoteDbMigrator(sitePaths, schemaFactory<START_MOD>, repoManager, allProjects<END_MOD>, rebuilder, globalNotesMigration, ((threads) > 1 ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService()), projects, changes, progressOut, <START_MOD>stopAtState, <END_MOD>trial, forceRebuild<START_MOD>, ((sequenceGap) != null ? sequenceGap : com.google.gerrit.server.Sequences.getChangeSequenceGap(cfg))<END_MOD>); }
private static com.google.gerrit.acceptance.GerritServer startOnDisk(com.google.gerrit.acceptance.GerritServer.Description desc, java.nio.file.Path site, com.google.gerrit.pgm.Daemon daemon, java.util.concurrent.CyclicBarrier serverStarted) throws java.lang.Exception { checkNotNull(site); java.util.concurrent.ExecutorService daemonService = java.util.concurrent.Executors.newSingleThreadExecutor(); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = daemonService.submit(() -> { int rc = daemon.main(new java.lang.String[]{ "-d", site.toString(), "--headless", "--console-log", "--show-stack-trace" }); if (rc != 0) { java.lang.System.err.println( to start Gerrit daemon serverStarted.reset(); } return null; }); <START_MOD>try { <END_MOD>serverStarted.await(); <START_MOD>} catch (java.util.concurrent.BrokenBarrierException e) { throw new com.google.gerrit.acceptance.GerritServer.StartupException( to start Gerrit daemon; see log e); } <END_MOD>java.lang.System.out.println( Server Started return new com.google.gerrit.acceptance.GerritServer(desc, com.google.gerrit.acceptance.GerritServer.createTestInjector(daemon), daemon, daemonService); }
private com.google.gerrit.server.notedb.NotesMigrationState enableSequences(<START_MOD>com.google.gerrit.server.notedb.NotesMigrationState prev) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()<END_MOD>) { <START_MOD>@<END_MOD>java.lang.<START_MOD>SuppressWarnings<END_MOD>(<START_MOD>"deprecation")<END_MOD> <START_MOD>com.google.gerrit.server.notedb.RepoSequence<END_MOD> <START_MOD>seq = new com.google.gerrit.server.notedb.RepoSequence(repoManager, allProjects, com.google.gerrit.server.Sequences.CHANGES, () -> (db.nextChangeId()) + (sequenceGap), 1); seq.next();<END_MOD> }<START_MOD> return saveState(prev, com.google.gerrit.server.notedb.NotesMigrationState.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); }<END_MOD>
<START_MOD>public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setSequenceGap(java.lang.Integer sequenceGap) { this.sequenceGap = sequenceGap; return this; }<END_MOD>
@org.junit.Test public void preconditionsFail() throws java.lang.Exception { java.util.List<com.google.gerrit.reviewdb.client.Change.Id> cs = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Change.Id(1)); java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> ps = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Project.NameKey("p")); assertMigrationException( rebuild without noteDb.changes.write=true ( b) -> b, NoteDbMigrator::rebuild); assertMigrationException( set both changes and projects ( b) -> b.setChanges(cs).setProjects(ps), ( m) -> { }); assertMigrationException( set changes or projects during auto-migration ( b) -> b.setChanges(cs), NoteDbMigrator::migrate); assertMigrationException( set changes or projects during auto-migration ( b) -> b.setProjects(ps), NoteDbMigrator::migrate); <START_MOD>assertMigrationException( gap must be non-negative ( b) -> b.setSequenceGap((-1)), ( m) -> { }); <END_MOD>setNotesMigrationState(<START_MOD>com.google.gerrit.acceptance.server.notedb<END_MOD>.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); assertMigrationException( has already progressed past the endpoint of the   mode state ( b) -> b.setTrialMode(true), NoteDbMigrator::migrate); setNotesMigrationState(<START_MOD>com.google.gerrit.acceptance.server.notedb<END_MOD>.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY); assertMigrationException( force rebuild changes; NoteDb is already the primary storage for some changes ( b) -> b.setForceRebuild(true), NoteDbMigrator::migrate); }
<START_MOD>protected static com.google.gerrit.server.util.ManualRequestContext openContext(com.google.gerrit.acceptance.GerritServer server) throws java.lang.Exception { com.google.inject.Injector i = server.getTestInjector(); com.google.gerrit.acceptance.TestAccount a = i.getInstance(com.google.gerrit.acceptance.AccountCreator.class).admin(); return com.google.gerrit.acceptance.StandaloneSiteTest.openContext(server, a.getId()); }<END_MOD>
<START_MOD>protected static com.google.gerrit.server.util.ManualRequestContext openContext(com.google.gerrit.acceptance.GerritServer server, com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.lang.Exception { return server.getTestInjector().getInstance(com.google.gerrit.server.util.OneOffRequestContext.class).openAs(accountId); }<END_MOD>
<START_MOD>private void testEnableSequences(java.lang.Integer builderOption, int expectedFirstId, java.lang.String expectedRefValue) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); assertThat(id.get()).isEqualTo(1); migrate(( b) -> b.setSequenceGap(builderOption).setStopAtStateForTesting(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY)); assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId); assertThat(sequences.nextChangeId()).isEqualTo((expectedFirstId + 1)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allProjects);org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader()) { org.eclipse.jgit.lib.Ref ref = repo.exactRef("refs/sequences/changes"); assertThat(ref).isNotNull(); org.eclipse.jgit.lib.ObjectLoader loader = reader.open(ref.getObjectId()); assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB); assertThat(new java.lang.String(loader.getCachedBytes(), java.nio.charset.StandardCharsets.UTF_8)).isEqualTo(expectedRefValue); } try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { @java.lang.SuppressWarnings("deprecation") int nextFromReviewDb = db.nextChangeId(); assertThat(nextFromReviewDb).isEqualTo(3); } }<END_MOD>
<START_MOD>@org.junit.Test public void enableSequencesNoGap() throws java.lang.Exception { testEnableSequences(0, 3, "13"); }<END_MOD>
@java.lang.Override public synchronized void stop() {<START_MOD> new java.lang.Exception(( data source   + (ds))).printStackTrace();<END_MOD> if ((ds) instanceof org.apache.commons.dbcp.BasicDataSource) { try { ((org.apache.commons.dbcp.BasicDataSource) (ds)).close(); } catch (java.sql.SQLException e) { <START_MOD>new java.lang.Exception( to close e).printStackTrace(); <END_MOD>} } }
@java.lang.Override public void onTimeout(org.eclipse.jetty.continuation.Continuation self) { <START_MOD>end<END_MOD>(); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((( object   + (cmd.getNewId().name())) +   for   + (cmd.getRefName())) +   creation err); reject(cmd,   object return; } logDebug( {} cmd); if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); boolean ok; try { permissions.ref(cmd.getRefName()).check(RefPermission.CREATE); ok = true; } catch (com.google.gerrit.extensions.restapi.AuthException err) { ok = false; } if (<START_MOD>!<END_MOD>ok<START_MOD>) { reject(cmd, ( by Gerrit: 'create' permission missing   + (cmd.getRefName()))); return; } java.lang.String rejectReason = <END_MOD>ctl.canCreate(rp.getRepository(), obj)<START_MOD>; if (rejectReason != null) { reject(cmd, ( by Gerrit:   + rejectReason)); return; }<END_MOD> if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); actualCommands.add(cmd); }
<START_MOD>@com.google.gerrit.common.Nullable <END_MOD>private <START_MOD>java.lang.String<END_MOD> canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { if (canUpdate()) { return <START_MOD>null<END_MOD>; } else if (isMergedIntoBranchOrTag(repo, commit)) { return <START_MOD>null<END_MOD>; } return <START_MOD>  new commit object requires 'push' permission<END_MOD> }
<START_MOD>@org.junit.Test public void shouldBlockCreationToNonOwnersOfParentProjectIfGroupRefIsNotUsed() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); com.google.gerrit.extensions.api.groups.GroupApi dGroup = gApi.groups().create(delegatingGroup); dGroup.addMembers(user.username); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); cfg.getPluginConfig("project-group-structure").setString(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, delegatingGroup); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }<END_MOD>
<START_MOD>@org.junit.Test public void shouldBlockCreationToNonOwnersOfParentProjectAndTheDelegatingGroupDoesNotExist() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); java.lang.String gId = "fake-gId"; cfg.getPluginConfig("project-group-structure").setString(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, (((("Group[" + delegatingGroup) + " / ") + gId) + "]")); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }<END_MOD>
<START_MOD>@org.junit.Test public void shouldBlockCreationToNonOwnersOfParentProjectAndUserIsNotInDelegatingGroup() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); gApi.groups().create(delegatingGroup); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); java.lang.String gId = gApi.groups().id(delegatingGroup).get().id; cfg.getPluginConfig("project-group-structure").setString(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, (((("Group[" + delegatingGroup) + " / ") + gId) + "]")); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }<END_MOD>
<START_MOD>@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure { if ((localDiskRepositoryManager) == null) { throw new com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure(1, "Command only works with disk based repository managers"); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); if ((projectCache.get(nameKey)) != null) { stdout.print((((((localDiskRepositoryManager.getBasePath(nameKey)) + "/") + (nameKey.get())) + ".git") + "\n")); } else { throw new com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure(1, "Repository not found"); } }<END_MOD>
<START_MOD>private synchronized void finish(com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt a, java.util.List<com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt> out) { checkState(((finished.getCount()) > 0), "already started %s upgrades, can't start %s", numExpected, a); out.add(a); finished.countDown(); }<END_MOD>
<START_MOD>@java.lang.Override public void configure() { bind(com.google.gerrit.server.index.VersionManager.class).to(com.google.gerrit.elasticsearch.ElasticVersionManager.class); listener().to(com.google.gerrit.elasticsearch.ElasticVersionManager.class); listener().to(com.google.gerrit.server.index.OnlineUpgrader.class); }<END_MOD>
<START_MOD>@java.lang.Override public synchronized void onStart(java.lang.String name, int oldVersion, int newVersion) { com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt a = com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt.create(name, oldVersion, newVersion); checkState(((started.getCount()) > 0), "already started %s upgrades, can't start %s", numExpected, a); startedAttempts.add(a); started.countDown(); }<END_MOD>
<START_MOD>void runUpgrades() throws java.lang.Exception { int timeoutSec = 60; if (!(started.await(timeoutSec, java.util.concurrent.TimeUnit.SECONDS))) { assert_().fail("%s/%s online upgrades started after %ss", ((numExpected) - (started.getCount())), numExpected, timeoutSec); } finished.await(); }<END_MOD>
<START_MOD>private void assertReady(int expectedReady) throws java.lang.Exception { java.util.Map<java.lang.Integer, java.lang.Boolean> expected = new java.util.LinkedHashMap<>(); ChangeSchemaDefinitions.INSTANCE.getSchemas().keySet().forEach(( v) -> expected.put(v, false)); expected.put(expectedReady, true); com.google.gerrit.server.index.GerritIndexStatus status = new com.google.gerrit.server.index.GerritIndexStatus(sitePaths); assertThat(ChangeSchemaDefinitions.INSTANCE.getSchemas().keySet().stream().collect(toImmutableMap(( v) -> v, ( v) -> status.getReady(ChangeSchemaDefinitions.NAME, v)))).named("ready state for index versions").containsExactlyEntriesIn(expected); }<END_MOD>
@java.lang.Override public void configure() {<START_MOD> bind(com.google.gerrit.server.index.VersionManager.class).to(com.google.gerrit.lucene.LuceneVersionManager.class);<END_MOD> listener().to(com.google.gerrit.lucene.LuceneVersionManager.class); <START_MOD>listener().to(com.google.gerrit.server.index.OnlineUpgrader.class); <END_MOD>}
<START_MOD>@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try { for (com.google.gerrit.reviewdb.client.Account account : scanAccounts(db)) { updateAccountInNoteDb(account); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Migrating accounts to NoteDb failed", e); } }<END_MOD>
<START_MOD>private void updateAccountInNoteDb(com.google.gerrit.reviewdb.client.Account account) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, repo); org.eclipse.jgit.lib.PersonIdent ident = serverIdent.get(); md.getCommitBuilder().setAuthor(ident); md.getCommitBuilder().setCommitter(ident); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(null, account.getId()); accountConfig.load(repo); accountConfig.setAccount(account); accountConfig.commit(md); } }<END_MOD>
<START_MOD>private byte[] getAccountConfig(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) throws java.io.IOException { rw.parseCommit(commit); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(rw.getObjectReader(), AccountConfig.ACCOUNT_CONFIG, commit.getTree())) { return tw != null ? rw.getObjectReader().open(tw.getObjectId(0), com.google.gerrit.server.git.validators.OBJ_BLOB).getBytes() : null; } }<END_MOD>
public com.google.gerrit.reviewdb.client.Account get(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException<END_MOD> {<START_MOD> if (readFromGit) { return read(accountId); }<END_MOD> return db.accounts().get(accountId); }
public java.util.List<com.google.gerrit.reviewdb.client.Account> all(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException { if (readFromGit) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds = allIds(); java.util.List<com.google.gerrit.reviewdb.client.Account> accounts = new java.util.ArrayList(accountIds.size()); for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { try { accounts.add(get(db, accountId)); } catch (java.lang.Exception e) { com.google.gerrit.server.account.Accounts.log.error(java.lang.String.format( invalid account %s accountId.get()), e); } }<END_MOD> return <START_MOD>accounts; } return <END_MOD>db.accounts().all().toList(); }
<START_MOD>private com.google.gerrit.reviewdb.client.Account read(com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(emailValidator, accountId); accountConfig.load(repo); return accountConfig.getAccount(); } }<END_MOD>
public java.util.List<com.google.gerrit.reviewdb.client.Account> get(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException<END_MOD> { <START_MOD>if (readFromGit) { java.util.List<com.google.gerrit.reviewdb.client.Account> accounts = new java.util.ArrayList(accountIds.size()); for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { accounts.add(read(accountId)); } <END_MOD>return <START_MOD>accounts; } return <END_MOD>db.accounts().get(accountIds).toList(); }
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchIsRejected() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, ((com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)) + ":userRef")); allUsersRepo.reset("userRef"); org.eclipse.jgit.lib.Config ac = new org.eclipse.jgit.lib.Config(); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(allUsersRepo.getRepository(), AccountConfig.ACCOUNT_CONFIG, getHead(allUsersRepo.getRepository()).getTree())) { assertThat(tw).isNotNull(); ac.fromText(new java.lang.String(allUsersRepo.getRevWalk().getObjectReader().open(tw.getObjectId(0), com.google.gerrit.acceptance.api.accounts.OBJ_BLOB).getBytes(), java.nio.charset.StandardCharsets.UTF_8)); } ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, "OOO"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(RefNames.REFS_USERS_SELF); r.assertErrorStatus("account update not allowed"); }<END_MOD>
<START_MOD>@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if ((revision) != null) { commit.setMessage("Update account\n"); } else if ((account) != null) { commit.setMessage("Create account\n"); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getCommitter(), registeredOn)); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); com.google.gerrit.server.account.AccountConfig.setActive(cfg, account.isActive()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_FULL_NAME, account.getFullName()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_PREFERRED_EMAIL, account.getPreferredEmail()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_STATUS, account.getStatus()); saveConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); return true; }<END_MOD>
<START_MOD>@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRef(receiveEvent.refName); if (accountId == null) { return java.util.Collections.emptyList(); } if ((receiveEvent.commit.getParentCount()) > 1) { throw new com.google.gerrit.server.git.validators.CommitValidationException(java.lang.String.format(("Merge commits not allowed on user branches:" + " Commit %s for user branch of account %s is a merge commit"), receiveEvent.commit.name(), accountId.get())); } try { byte[] newContent = getAccountConfig(receiveEvent.revWalk, receiveEvent.commit); byte[] oldContent = ((receiveEvent.commit.getParentCount()) == 1) ? getAccountConfig(receiveEvent.revWalk, receiveEvent.commit.getParent(0)) : null; if (!(java.util.Arrays.equals(oldContent, newContent))) { throw new com.google.gerrit.server.git.validators.CommitValidationException("account update not allowed"); } } catch (java.io.IOException e) { java.lang.String m = java.lang.String.format("Validating update for account %s failed", accountId.get()); com.google.gerrit.server.git.validators.CommitValidators.log.error(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } return java.util.Collections.emptyList(); }<END_MOD>
<START_MOD>private com.google.gerrit.reviewdb.client.Account parse(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, registeredOn); account.setActive(cfg.getBoolean(com.google.gerrit.server.account.AccountConfig.ACCOUNT, null, com.google.gerrit.server.account.AccountConfig.KEY_ACTIVE, true)); account.setFullName(cfg.getString(com.google.gerrit.server.account.AccountConfig.ACCOUNT, null, com.google.gerrit.server.account.AccountConfig.KEY_FULL_NAME)); java.lang.String preferredEmail = cfg.getString(com.google.gerrit.server.account.AccountConfig.ACCOUNT, null, com.google.gerrit.server.account.AccountConfig.KEY_PREFERRED_EMAIL); account.setPreferredEmail(preferredEmail); if (((emailValidator) != null) && (!(emailValidator.isValid(preferredEmail)))) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, java.lang.String.format("Invalid preferred email: %s", preferredEmail))); } account.setStatus(cfg.getString(com.google.gerrit.server.account.AccountConfig.ACCOUNT, null, com.google.gerrit.server.account.AccountConfig.KEY_STATUS)); return account; }<END_MOD>
<START_MOD>public void renderToHtml(com.google.gitiles.doc.html.HtmlBuilder out, org.commonmark.node.Node node) { if (node != null) { html = out; toc = new com.google.gitiles.doc.TocFormatter(html, 3); toc.setRoot(node); node.accept(this); html.finish(); } }<END_MOD>
public int getEffectiveMaxBatchChangesLimit(com.google.gerrit.server.CurrentUser user) { com.google.gerrit.server.account.<START_MOD>AccountLimits<END_MOD> cap = capabilityFactory.create(user); if (cap.hasExplicitRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT)) { return cap.getRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT).getMax(); } return systemMaxBatchChanges; }
private void addRanges(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.<START_MOD>AccountLimits<END_MOD> cc) { for (java.lang.String name : com.google.gerrit.common.data.GlobalCapability.getRangeNames()) { if ((want(name)) && (cc.hasExplicitRange(name))) { have.put(name, new com.google.gerrit.server.account.GetCapabilities.Range(cc.getRange(name))); } } }
private void addPriority(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.<START_MOD>AccountLimits<END_MOD> cc) { com.google.gerrit.server.git.QueueProvider.QueueType queue = cc.getQueueType(); if ((queue != (QueueProvider.QueueType.INTERACTIVE)) || (((query) != null) && (query.contains(com.google.gerrit.server.account.PRIORITY)))) { have.put(com.google.gerrit.server.account.PRIORITY, queue); } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(self); if ((self.get()) != (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : perm.test(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.<START_MOD>AccountLimits<END_MOD> cc = capabilityFactory.create(rsrc.getUser()); addRanges(have, cc); addPriority(have, cc); return OutputFormat.JSON.newGson().toJsonTree(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>AuthException, com.google.gerrit.extensions.restapi.<END_MOD>BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, <START_MOD>com.google.gerrit.server.permissions.PermissionBackendException, <END_MOD>java.io.IOException { <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); <END_MOD>java.lang.String <START_MOD>name = com.google.gerrit.reviewdb.client.RefNames.fullName(<END_MOD>id.get()<START_MOD>); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref refName = repo.exactRef(name)<END_MOD>; if (<START_MOD>refName != null) { name = (refName.isSymbolic()) ? refName.getTarget().getName() : refName.getName(); } permissionBackend.user(user).project(project).ref(name).check(RefPermission.READ); if (refName == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.project.BranchResource<END_MOD>(parent<START_MOD>.getControl(), refName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw<END_MOD> new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }<START_MOD> }<END_MOD>
<START_MOD>private void grantApprove(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, boolean exclusive) throws java.lang.Exception { grantLabel(((com.google.gerrit.common.data.Permission.LABEL) + "Code-Review"), (-2), 2, project, "refs/heads/*", false, groupUUID, exclusive); }<END_MOD>
<START_MOD>@org.junit.Test public void testChangeOwner_BlockedOnParentProject() throws java.lang.Exception { setApiUser(admin); blockLabel(((com.google.gerrit.common.data.Permission.LABEL) + "Code-Review"), (-2), 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project); com.google.gerrit.reviewdb.client.Project.NameKey child = createProject("child", project); setApiUser(user); grantApproveToAll(child); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> childRepo = cloneProject(child, user); java.lang.String changeId = createMyChange(childRepo); assertApproveFails(user, changeId); approve(user2, changeId); }<END_MOD>
protected void grantLabel(java.lang.String permission, int min, int max, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, boolean force, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID<START_MOD>, boolean exclusive<END_MOD>) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { md.setMessage(java.lang.String.format( %s on %s permission, ref)); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection s = config.getAccessSection(ref, true); com.google.gerrit.common.data.Permission p = s.getPermission(permission, true); <START_MOD>p.setExclusiveGroup(exclusive); <END_MOD>com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.newRule(config, groupUUID); rule.setForce(force); rule.setMin(min); rule.setMax(max); p.add(rule); config.commit(md); projectCache.evict(config.getProject()); } }
<START_MOD>protected void blockLabel(java.lang.String permission, int min, int max, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, java.lang.String ref, com.google.gerrit.reviewdb.client.Project.NameKey project) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.block(cfg, permission, id, ref); rule.setMin(min); rule.setMax(max); saveProjectConfig(project, cfg); }<END_MOD>
<START_MOD>@org.junit.Test public void testChangeOwner_BlockedOnParentProjectAndExclusiveAllowOnChild() throws java.lang.Exception { setApiUser(admin); blockLabel(((com.google.gerrit.common.data.Permission.LABEL) + "Code-Review"), (-2), 2, SystemGroupBackend.CHANGE_OWNER, "refs/heads/*", project); com.google.gerrit.reviewdb.client.Project.NameKey child = createProject("child", project); setApiUser(user); grantExclusiveApproveToAll(child); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> childRepo = cloneProject(child, user); java.lang.String changeId = createMyChange(childRepo); assertApproveFails(user, changeId); approve(user2, changeId); }<END_MOD>
void populate(int row, com.google.gerrit.client.projects.TagInfo k) { if (k.canDelete()) { com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); canDelete = true; } else { table.setText(row, 1, ""); } table.setWidget(row, 2, new com.google.gwt.user.client.ui.InlineHTML(highlight(k.getShortName(), match))); if ((k.revision()) != null) { table.setText(row, 3, k.revision()); } else { table.setText(row, 3, ""); } com.google.gwt.user.client.ui.<START_MOD>FlowPanel actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); if ((k.webLinks()) != null) { for (com.google.gerrit.client.info.WebLinkInfo webLink : com.google.gerrit.client.rpc.Natives.asList(k.webLinks())) { actionsPanel.add(webLink.toAnchor()); } } table.setWidget(row, 4, actionsPanel); com.google.gwt.user.client.ui.<END_MOD>FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); java.lang.String iconCellStyle = Gerrit.RESOURCES.css().iconCell(); java.lang.String dataCellStyle = Gerrit.RESOURCES.css().dataCell(); fmt.addStyleName(row, 1, iconCellStyle); fmt.addStyleName(row, 2, dataCellStyle); fmt.addStyleName(row, 3, dataCellStyle); setRowItem(row, k); }
<START_MOD>private<END_MOD> <START_MOD>java.util.Map<java.lang.String,<END_MOD> org.eclipse.jgit.lib.Ref<START_MOD>><END_MOD> <START_MOD>visibleTags()<END_MOD> <START_MOD>{<END_MOD> com.google.gerrit.server.project.<START_MOD>ProjectControl<END_MOD> control; com.google.gerrit.server.<START_MOD>project<END_MOD>.<START_MOD>ProjectControl<END_MOD> <START_MOD>Repository<END_MOD>; }
<START_MOD>public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.RefControl control, com.google.gerrit.server.project.ProjectControl pcntl, com.google.gerrit.server.WebLinks links) throws<END_MOD> java.<START_MOD>io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); java.<END_MOD>util.<START_MOD>List<END_MOD><<START_MOD>com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(pctl.getProject().getName(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object));<END_MOD> org.eclipse.jgit.lib.<START_MOD>PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (tagger != null ? <END_MOD>com.google.gerrit.server.<START_MOD>CommonConverters.toGitPerson(tag.getTaggerIdent()) : null),<END_MOD> control<START_MOD>.canDelete(), (webLinks.isEmpty() ? null : webLinks)); }<END_MOD> return new com.google.gerrit.<START_MOD>extensions.api.projects.TagInfo(ref.getName(), ref.getObjectId().getName()<END_MOD>, control<START_MOD>.canDelete(), (webLinks.isEmpty() ? null : webLinks)<END_MOD>); }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); com.google.gerrit.server.project.ProjectControl <START_MOD>pctl = resource.getControl(); if ((ref != null) && (!(visibleTags(<END_MOD>control<START_MOD>, repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty()))) { return com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, <END_MOD>control<START_MOD>.controlForRef<END_MOD>(ref.getName()<START_MOD>), pctl, links<END_MOD>); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.project.ProjectControl control = resource.getControl(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(control, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, control.controlForRef(ref.getName())<START_MOD>, control, links<END_MOD>)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags); }
<START_MOD>private int reindexAccounts() throws java.lang.Exception { monitor.beginTask("Reindex accounts", ProgressMonitor.UNKNOWN); java.util.List<java.lang.String> reindexArgs = com.google.common.collect.ImmutableList.of("--site-path", getSitePath().toString(), "--index", AccountSchemaDefinitions.NAME); java.lang.System.out.println("Migration complete, reindexing accounts with:"); java.lang.System.out.println((" reindex " + (reindexArgs.stream().collect(java.util.stream.Collectors.joining(" "))))); com.google.gerrit.pgm.Reindex reindexPgm = new com.google.gerrit.pgm.Reindex(); int exitCode = reindexPgm.main(reindexArgs.stream().toArray(java.lang.String[]::new)); monitor.endTask(); return exitCode; }<END_MOD>
<START_MOD>protected void allow(java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, com.google.gerrit.reviewdb.client.Project.NameKey p, java.lang.String ref) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, permission, id, ref); saveProjectConfig(p, cfg); }<END_MOD>
<START_MOD>private java.util.List<java.lang.String> lsRemote(com.google.gerrit.reviewdb.client.Project.NameKey p, com.google.gerrit.acceptance.TestAccount a) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<?> adminTestRepository = cloneProject(p, a); try (org.eclipse.jgit.api.Git git = adminTestRepository.git()) { org.eclipse.jgit.api.LsRemoteCommand lsRemoteCommand = git.lsRemote(); java.util.List<java.lang.String> refNames = lsRemoteCommand.call().stream().map(Ref::getName).collect(java.util.stream.Collectors.toList()); return refNames; } }<END_MOD>
<START_MOD>static java.lang.String skipShardedRefPart(java.lang.String name) { if (name == null) { return null; } java.lang.String[] parts = name.split("/"); int n = parts.length; if (n < 2) { return null; } int le; for (le = 0; le < (parts[0].length()); le++) { if (!(java.lang.Character.isDigit(parts[0].charAt(le)))) { return null; } } if (le != 2) { return null; } int ie; for (ie = 0; ie < (parts[1].length()); ie++) { if (!(java.lang.Character.isDigit(parts[1].charAt(ie)))) { if (ie == 0) { return null; } break; } } int shard = java.lang.Integer.parseInt(parts[0]); int id = java.lang.Integer.parseInt(parts[1].substring(0, ie)); if ((id % 100) != shard) { return null; } return name.substring((((parts[0].length()) + 1) + ie)); }<END_MOD>
<START_MOD>static java.lang.Integer parseAfterShardedRefPart(java.lang.String name) { java.lang.String rest = com.google.gerrit.reviewdb.client.RefNames.skipShardedRefPart(name); if ((rest == null) || (!(rest.startsWith("/")))) { return null; } rest = rest.substring(1); if (rest.isEmpty()) { return null; } int ie; for (ie = 0; ie < (rest.length()); ie++) { if (!(java.lang.Character.isDigit(rest.charAt(ie)))) { if (ie == 0) { return null; } break; } } return java.lang.Integer.parseInt(rest.substring(0, ie)); }<END_MOD>
protected void allow(java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, java.lang.String ref) throws java.lang.Exception { allow(permission, id, <START_MOD>project, <END_MOD>ref); }
<START_MOD>@org.junit.Test public void advertisedReferencesOmitStarredChangesRefsOfOtherUsers() throws java.lang.Exception { assume().that(notesMigration.commitChangeWrites()).isTrue(); allow(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, allUsersName, "refs/*"); gApi.accounts().self().starChange(c3.getId().toString()); java.lang.String starredChangesRef = com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(c3.getId(), admin.id); assertThat(lsRemote(allUsersName, admin)).contains(starredChangesRef); assertThat(lsRemote(allUsersName, user)).doesNotContain(starredChangesRef); }<END_MOD>
<START_MOD>@org.junit.Test public void advertisedReferencesOmitDraftCommentRefsOfOtherUsers() throws java.lang.Exception { assume().that(notesMigration.commitChangeWrites()).isTrue(); allow(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, allUsersName, "refs/*"); com.google.gerrit.extensions.api.changes.DraftInput draftInput = new com.google.gerrit.extensions.api.changes.DraftInput(); draftInput.line = 1; draftInput.message = "nit: trailing whitespace"; draftInput.path = com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG; gApi.changes().id(c3.getId().get()).current().createDraft(draftInput); java.lang.String draftCommentRef = com.google.gerrit.reviewdb.client.RefNames.refsDraftComments(c3.getId(), admin.id); assertThat(lsRemote(allUsersName, admin)).contains(draftCommentRef); assertThat(lsRemote(allUsersName, user)).doesNotContain(draftCommentRef); }<END_MOD>
public void load(org.eclipse.jgit.revwalk.RevWalk walk, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { this.rw = walk; this.reader = walk.getObjectReader(); try { revision = (id != null) ? walk.parseCommit(id) : null; onLoad(); } finally { <START_MOD>rw<END_MOD> = null; reader = null; } }
@java.lang.Override public void visit(org.commonmark.node.Heading node) { outputNamedAnchor = false; java.lang.String tag = "h" + (node.getLevel()); html.open(tag); java.lang.String id = toc.idFromHeader(node); if (id != null) { html.open("a").attribute("class", "h").attribute("name", id<START_MOD>.toLowerCase()<END_MOD>).attribute("href", ("#" + <START_MOD>(<END_MOD>id<START_MOD>.toLowerCase())<END_MOD>)).open("span").close("span").close("a"); } visitChildren(node); html.close(tag); outputNamedAnchor = true; }
public java.util.Optional<com.google.gerrit.reviewdb.client.Comment> <START_MOD>getDraft(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Comment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return java.util.Optional.ofNullable(db.patchComments().<END_MOD>get(<START_MOD>PatchLineComment.Key.from(notes.getChangeId(), key))).map(( plc) -> plc.asComment(serverId)); } return draftByChangeAuthor(<END_MOD>db, notes, <START_MOD>user.getAccountId()).stream().filter(( c<END_MOD>) -> <START_MOD>key.equals(c.key)).findFirst(<END_MOD>); }
<START_MOD>public java.util.Optional<com.google.gerrit.reviewdb.client.Comment> getPublished(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Comment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return java.util.Optional.ofNullable(db.patchComments().get(PatchLineComment.Key.from(notes.getChangeId(), key))).map(( plc) -> plc.asComment(serverId)); } return publishedByChange(db, notes).stream().filter(( c) -> key.equals(c.key)).findFirst(); }<END_MOD>
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.reviewdb.client.Comment> maybeComment = commentsUtil.<START_MOD>getDraft<END_MOD>(ctx.getDb(), ctx.getNotes<START_MOD>(), ctx.getIdentifiedUser<END_MOD>(), key); if (!(maybeComment.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( not found:   + (key))); } com.google.gerrit.reviewdb.client.Comment origComment = maybeComment.get(); comment = new com.google.gerrit.reviewdb.client.Comment(origComment); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(psId); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( set not found:   + psId)); } if (((in.path) != null) && (!(in.path.equals(origComment.key.filename)))) { commentsUtil.deleteComments(ctx.getDb(), update, java.util.Collections.singleton(origComment)); comment.key.filename = in.path; } com.google.gerrit.server.CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), ps); commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, java.util.Collections.singleton(com.google.gerrit.server.change.PutDraftComment.update(comment, in, ctx.getWhen()))); ctx.dontBumpLastUpdatedOn(); return true; }
@org.junit.Test public void includesNavbar() throws java.lang.Exception { java.lang.String navbar =   Site Title + (("\n" +   [Home](index.md) +   [README](README.md) repo.branch("master").commit().add("README.md",   page information.").add("navbar.md navbar).create(); java.lang.String html = buildHtml("/repo/+doc/master/README.md"); assertThat(html).contains( Title - page</title> assertThat(html).contains( class= Title</span> assertThat(html).contains( href= assertThat(html).contains( href= assertThat(html).contains(("<h1>" + ( class= name= href= + "page</h1>"))); }
<START_MOD>void setMessage(com.google.gerrit.extensions.common.MessageInput in) throws com.google.gerrit.extensions.restapi.RestApiException;<END_MOD>
<START_MOD>private void editCommitMessage(com.google.gerrit.acceptance.server.mail.StagedChange sc, com.google.gerrit.acceptance.TestAccount by, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.NotifyHandling notify, com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy emailStrategy) throws java.lang.Exception { setEmailStrategy(by, emailStrategy); com.google.gerrit.extensions.common.CommitInfo commit = gApi.changes().id(sc.changeId).revision("current").commit(false); com.google.gerrit.extensions.common.MessageInput in = new com.google.gerrit.extensions.common.MessageInput(); in.message = "update\n" + (commit.message); in.notify = notify; gApi.changes().id(sc.changeId).setMessage(in); }<END_MOD>
<START_MOD>@java.lang.Override public void setMessage(com.google.gerrit.extensions.common.MessageInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { putMessage.apply(change, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot edit commit message", e); } }<END_MOD>
<START_MOD>@java.lang.Override public void setMessage(com.google.gerrit.extensions.common.MessageInput in) { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }<END_MOD>
@java.lang.Override public void setMessage(java.lang.String <START_MOD>msg<END_MOD>) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>common<END_MOD>.<START_MOD>MessageInput<END_MOD> <START_MOD>in<END_MOD> = new com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>common<END_MOD>.<START_MOD>MessageInput<END_MOD>(); <START_MOD>in<END_MOD>.message = <START_MOD>msg<END_MOD>; <START_MOD>setMessage<END_MOD>(<START_MOD>in<END_MOD>); }
<START_MOD>private void assertUploadTag(com.google.gerrit.server.query.change.ChangeData cd, java.lang.String expectedTag) throws java.lang.Exception { java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> msgs = cd.messages(); assertThat(msgs).isNotEmpty(); com.google.gerrit.reviewdb.client.ChangeMessage msg = msgs.get(((msgs.size()) - 1)); assertThat(msg.getTag()).isEqualTo(expectedTag); }<END_MOD>
<START_MOD>@org.junit.Test public void tagForCreateWipChange() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createWorkInProgressChange(); r.assertOkStatus(); assertUploadTag(r.getChange(), ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET); }<END_MOD>
<START_MOD>@org.junit.Test public void reviewAndStartReview() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createWorkInProgressChange(); r.assertOkStatus(); assertThat(r.getChange().change().isWorkInProgress()).isTrue(); com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.noScore().setWorkInProgress(false); in.ready = true; gApi.changes().id(r.getChangeId()).revision("current").review(in); com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().id(r.getChangeId()).get(); assertThat(info.workInProgress).isNull(); }<END_MOD>
<START_MOD>private java.util.List<java.lang.String> getChangeParents(com.google.gerrit.extensions.api.changes.ChangeApi change, java.lang.String currentRevision) throws com.google.gerrit.extensions.restapi.RestApiException { java.util.List<java.lang.String> parents = new java.util.ArrayList<>(); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisionMap = change.get(java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT)).revisions; java.util.List<com.google.gerrit.extensions.common.CommitInfo> changeParents = revisionMap.get(currentRevision).commit.parents; for (com.google.gerrit.extensions.common.CommitInfo commit : changeParents) { parents.add(commit.commit); } return parents; }<END_MOD>
<START_MOD>private java.lang.String getBaseChangeId(java.util.List<java.lang.String> parents, java.lang.String topic) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.InvalidQueryParameterException { if ((parents.size()) == 0) { com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.info("No base change id for change with no parents."); return null; } java.util.List<ChangeInfo> changesInTopic = getChangesInTopic(topic); java.lang.String firstParent = parents.get(0); for (ChangeInfo change : changesInTopic) { java.util.List<com.google.gerrit.extensions.common.CommitInfo> topicChangeParents = change.revisions.get(change.currentRevision).commit.parents; if ((topicChangeParents.size()) > 1) { if (topicChangeParents.get(1).commit.equals(firstParent)) { return java.lang.String.valueOf(change._number); } } } return null; }<END_MOD>
<START_MOD>private java.util.List<com.google.gerrit.extensions.common.ChangeInfo> getChangesInTopic(java.lang.String topic) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.InvalidQueryParameterException { com.googlesource.gerrit.plugins.automerger.QueryBuilder queryBuilder = new com.googlesource.gerrit.plugins.automerger.QueryBuilder(); queryBuilder.addParameter("topic", topic); queryBuilder.addParameter("status", "open"); return gApi.changes().query(queryBuilder.get()).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get(); }<END_MOD>
@java.lang.Override public java.lang.String getAuthorizationUrl() { java.lang.String url = service.getAuthorizationUrl(null); try { if (<START_MOD>(domains.length) == 1<END_MOD>) { url += "&hd=" + (java.net.URLEncoder.encode(<START_MOD>domains[0]<END_MOD>, java.nio.charset.StandardCharsets.UTF_8.name()))<START_MOD>; } else if ((domains.length) > 1) { url += "&hd=*"<END_MOD>; } } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.IllegalArgumentException(e); } if (com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.isDebugEnabled()) { com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.debug( authorization URL={} url); } return url; }
protected void assertRebase(org.eclipse.jgit.junit.TestRepository<?> testRepo, boolean contentMerge) throws java.lang.Exception { org.eclipse.jgit.lib.Repository repo = testRepo.getRepository(); org.eclipse.jgit.revwalk.RevCommit localHead = getHead(repo); org.eclipse.jgit.revwalk.RevCommit remoteHead = getRemoteHead(); <START_MOD>assertWithMessage<END_MOD>(java.lang.String.format( not equal %s localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId()); assertThat(remoteHead.getParentCount()).isEqualTo(1); if (!contentMerge) { assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo)); } assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage()); }
private java.<START_MOD>nio<END_MOD>.<START_MOD>file.Path<END_MOD> <START_MOD>resolvePath<END_MOD>(javax.servlet.http.HttpServletRequest req) { return <START_MOD>sitePaths<END_MOD>.<START_MOD>resolve<END_MOD>(((req.getServletPath()) + (req.getPathInfo()))); }
private<START_MOD> static<END_MOD> void setMissingHeader(final java.util.Map<java.lang.String, com.google.gerrit.server.mail.send.EmailHeader> hdrs, java.lang.String name, java.lang.String value) { if ((!(hdrs.containsKey(name))) || (hdrs.get(name).isEmpty())) { hdrs.put(name, new com.google.gerrit.server.mail.send.EmailHeader.String(value)); } }
protected java.lang.String buildMultipartBody(java.lang.String boundary, java.lang.String textPart, java.lang.String htmlPart)<START_MOD> throws java.io.IOException<END_MOD> { return ((((((((((((((((("--" + boundary) + "\r\n") +   text/plain; charset=UTF-8 +   <START_MOD>quoted-printable<END_MOD> + "\r\n") + <START_MOD>(quotedPrintableEncode(<END_MOD>textPart<START_MOD>))<END_MOD>) + "\r\n") + "--") + boundary) + "\r\n") +   text/html; charset=UTF-8 +   <START_MOD>quoted-printable<END_MOD> + "\r\n") + <START_MOD>(quotedPrintableEncode(<END_MOD>htmlPart<START_MOD>))<END_MOD>) + "\r\n") + "--") + boundary) + "--\r\n"; }
<START_MOD>protected java.lang.String quotedPrintableEncode(java.lang.String input) throws java.io.IOException { java.io.ByteArrayOutputStream s = new java.io.ByteArrayOutputStream(); org.apache.james.mime4j.codec.QuotedPrintableOutputStream qp = new org.apache.james.mime4j.codec.QuotedPrintableOutputStream(s, false); qp.write(input.getBytes(java.nio.charset.StandardCharsets.UTF_8)); qp.close(); return s.toString(); }<END_MOD>
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.reviewdb.client.Project p) {<START_MOD> java.lang.System.err.println("fmt");<END_MOD> com.google.gerrit.extensions.common.ProjectInfo info = new com.google.gerrit.extensions.common.ProjectInfo(); info.name = p.getName(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = p.getParent(allProjects); info.parent = (parentName != null) ? parentName.get() : null; info.description = com.google.common.base.Strings.emptyToNull(p.getDescription()); info.state = p.getState(); info.id = com.google.gerrit.extensions.restapi.Url.encode(info.name); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getProjectLinks(p.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.server.project.ProjectResource rsrc) { <START_MOD>java.lang.System.err.println( prsrc com.google.gerrit.server.project.ProjectControl ctl = rsrc.getControl(); com.google.gerrit.extensions.common.ProjectInfo info = format(ctl.getProject()); info.labels = new java.util.TreeMap(); for (com.google.gerrit.common.data.LabelType t : ctl.getLabelTypes().getLabelTypes()) { com.google.gerrit.extensions.common.ProjectInfo.LabelInfo labelInfo = new com.google.gerrit.extensions.common.ProjectInfo.LabelInfo(); for (com.google.gerrit.common.data.LabelValue value : t.getValues()) { labelInfo.values.put(new java.lang.Integer(value.getValue()), value.getText()); } info.labels.put(t.getName(), labelInfo); } <END_MOD>return <START_MOD>info<END_MOD>; }
public static com.google.gerrit.acceptance.GerritServer initAndStart(com.google.gerrit.acceptance.GerritServer.Description desc, org.eclipse.jgit.lib.Config baseConfig) throws java.lang.Exception { if (!(desc.memory())) { assume().withMessage( mode not yet supported for on-disk sites } java.nio.file.Path site = <START_MOD>com.google.gerrit.testutil.TempFileUtil.createTempDirectory().toPath(); baseConfig = new org.eclipse.jgit.lib.Config(baseConfig); baseConfig.setString("gerrit", null, "tempSiteDir", site.toString()); try { if (!(desc.memory())) { com.google.gerrit.acceptance.GerritServer.init(desc, baseConfig, site); } return com.google.gerrit.acceptance.GerritServer.start(desc, baseConfig, site, null); } catch (<END_MOD>java.<START_MOD>lang.Exception e) { com.google.gerrit.testutil.TempFileUtil.recursivelyDelete(site.toFile()); throw e; } }<END_MOD>
public org.eclipse.jgit.lib.ObjectId loadRevision() throws com.google.gwtorm.server.OrmException { if (loaded) { return getRevision(); } else if (!(args.migration.<START_MOD>commitChangeWrites<END_MOD>())) { return null; } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(getProjectName())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(getRefName()); return ref != null ? ref.getObjectId() : null; } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
<START_MOD>public com.google.common.collect.ImmutableList<java.lang.Integer> nextAccountIds(int count) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.metrics.Timer2.Context timer = nextIdLatency.start(com.google.gerrit.server.Sequences.SequenceType.ACCOUNTS, (count > 1))) { return accountSeq.next(count); } }<END_MOD>
@com.google.gwtorm.server.Sequence(startWith = <START_MOD>com.google.gerrit.reviewdb.server.ReviewDb.FIRST_ACCOUNT_ID<END_MOD>) int nextAccountId() throws com.google.gwtorm.server.OrmException;
<START_MOD>public int nextAccountId() throws com.google.gwtorm.server.OrmException { if ((accountSeq) == null) { accountSeq = new com.google.gerrit.server.notedb.RepoSequence(repoManager, new com.google.gerrit.reviewdb.client.Project.NameKey(allUsersName.get()), com.google.gerrit.server.Sequences.NAME_ACCOUNTS, () -> ReviewDb.FIRST_ACCOUNT_ID, 1); } return accountSeq.next(); }<END_MOD>
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { com.google.gerrit.server.patch.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if (<START_MOD>pl instanceof com.google.gerrit.server.patch.PatchListCacheImpl.PatchListTombstone) { throw new com.google.gerrit.server.patch.PatchListNotAvailableException((( computing   + key) +   Previous attempt failed with LargeObjectException } if (<END_MOD>(key.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(key), com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(( computing   + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { <START_MOD>fileCache.put(key, new com.google.gerrit.server.patch.PatchListCacheImpl.PatchListTombstone()); <END_MOD>PatchListLoader.log.warn(( computing   + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } throw e; } }
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException { if (!visible) { return cd.changeControl().getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((( to get submit type for   + (cd.getId())) +     + (str.errorMessage))); } return str.type; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, this).getSubmitType(); } return submitTypeRecord; }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { for (com.google.gerrit.common.data.PermissionRange pr : cd.changeControl().getLabelRanges()) { if (!(pr.isEmpty())) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException( rules are disabled } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( %s produced invalid result: %s evaluator.getSubmitRuleName(), rec)); } return rec.type; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException( rules are disabled } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment(com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((opts.rule()) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.StringReader(opts.rule())); } } catch (com.googlecode.prolog_cafe.exceptions.CompileException err) { java.lang.String msg; if (((opts.rule()) == null) && (control.getProjectControl().isOwner())) { msg = java.lang.String.format( load rules.pl for %s: %s getProjectName(), err.getMessage()); } else if ((opts.rule()) != null) { msg = err.getMessage(); } else { msg = java.lang.String.format( load rules.pl for %s getProjectName()); } throw new com.google.gerrit.server.project.RuleEvalException(msg, err); } env.set(StoredValues.<START_MOD>ACCOUNT_BY_EMAIL_CACHE, accountByEmailCache); env.set(StoredValues.<END_MOD>ACCOUNT_CACHE, accountCache); env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.CHANGE_CONTROL, control); if (user != null) { env.set(StoredValues.CURRENT_USER, user); } return env; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>accountByEmailCache, <END_MOD>accountCache, cd).setPatchSet(patchSet).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(( type rule failed:   + rec)); } return rec.type; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo();<START_MOD> if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.defaultTheme = "/static/" + (com.google.gerrit.server.config.SitePaths.THEME_FILENAME); }<END_MOD> info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
public <START_MOD>java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo><END_MOD> display(<START_MOD>@com.google.gerrit.common.Nullable <END_MOD>java.io.PrintWriter stdout) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = com.google.common.collect.Lists.newArrayList(pluginLoader.getPlugins(all)); java.util.Collections.sort(plugins, new java.util.Comparator<com.google.gerrit.server.plugins.Plugin>() { @java.lang.Override public int compare(com.google.gerrit.server.plugins.Plugin a, com.google.gerrit.server.plugins.Plugin b) { return a.getName().compareTo(b.getName()); } }); if (!(format.isJson())) { stdout.format( %-10s %-8s %s "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format( %-10s %-8s %s p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return <START_MOD>output; } else if (format.isJson()) { format<END_MOD>.newGson().<START_MOD>toJson<END_MOD>(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, <START_MOD>com.google.gerrit.extensions.common.PluginInfo<END_MOD>>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }
<START_MOD>java.util.Map<java.lang.String, java.util.Set<com.google.gerrit.server.account.externalids.ExternalId>> byEmails(java.lang.String... emails) throws java.io.IOException;<END_MOD>
<START_MOD>public java.util.Map<java.lang.String, java.util.Set<com.google.gerrit.server.account.externalids.ExternalId>> byEmails(java.lang.String... emails) throws java.io.IOException { return externalIdCache.byEmails(emails); }<END_MOD>
@java.lang.Override public<START_MOD> java.util.Map<java.lang.String,<END_MOD> java.util.Set<com.google.gerrit.server.account.externalids.ExternalId><START_MOD>><END_MOD> <START_MOD>byEmails<END_MOD>(java.lang.String<START_MOD>...<END_MOD> <START_MOD>emails<END_MOD>) throws java.io.IOException { throw new java.lang.UnsupportedOperationException(); }
<START_MOD>public java.util.Map<java.lang.String, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id>> byEmails(java.lang.String... emails) throws java.io.IOException { return externalIds.byEmails(emails).entrySet().stream().collect(toImmutableMap(java.util.Map.Entry::getKey, ( e) -> e.getValue().stream().map(( extId) -> extId.accountId()).collect(toImmutableSet()))); }<END_MOD>
<START_MOD>@org.junit.Test public void lookUpByEmail() throws java.lang.Exception { assertEmail(accounts.byEmail(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(accounts.byEmail(email), admin); assertThat(accounts.byEmail(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(accounts.byEmail(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(accounts.byEmail("non-existing@example.com")).isEmpty(); java.util.Map<java.lang.String, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id>> byEmails = accounts.byEmails(admin.email, user.email); assertEmail(byEmails.get(admin.email), admin); assertEmail(byEmails.get(user.email), user); }<END_MOD>
<START_MOD>default <END_MOD>java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException<START_MOD> { return byEmails(email).get(email)<END_MOD>;<START_MOD> }<END_MOD>
@java.lang.Override public java.util.<START_MOD>Map<java.lang.String, java.util.<END_MOD>Set<com.google.gerrit.server.account.externalids.ExternalId><START_MOD>> byEmails(java.lang.String... emails) throws java.io.IOException { try { com.google.gerrit.server.account.externalids.ExternalIdCacheImpl.AllExternalIds allExternalIds = extIdsByAccount.get(externalIdReader.readRevision()); java.util.Map<java.lang.String, java.util.Set<com.google.gerrit.server.account.externalids.ExternalId>> byEmails = new java.util.HashMap<>(); for (java.lang.String email : emails) { byEmails.put(email, allExternalIds.<END_MOD>byEmail(<START_MOD>).get(email)); } return byEmails; } catch (java.util.concurrent.ExecutionException e) { throw new<END_MOD> java.io.IOException<START_MOD>( list external ids by email<END_MOD> e)<START_MOD>; } }<END_MOD>
void loadChangeInfo(boolean fg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get()<START_MOD>, Project.NameKey.asStringOrNull(project)<END_MOD>); java.util.EnumSet<com.google.gerrit.extensions.client.ListChangesOption> opts = java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS); if (enableSignedPush()) { opts.add(ListChangesOption.PUSH_CERTIFICATES); } com.google.gerrit.client.changes.ChangeList.addOptions(call, opts); if (!fg) { call.background(); } call.get(cb); }
public static void editWithFiles(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).addParameterTrue("list").get(cb); }
public static void comment(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commentId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, <START_MOD>project, <END_MOD>"comments").id(commentId).get(cb); }
public static void detail(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.detail(id<START_MOD>, project<END_MOD>).get(cb); }
public static void updateDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String draftId, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, <START_MOD>project, <END_MOD>"drafts").id(draftId).put(content, cb); }
public static void deleteDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { CommentApi.revision(id, <START_MOD>project, <END_MOD>"drafts").id(draftId).delete(cb); }
public static void comments(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, <START_MOD>project, <END_MOD>"comments").get(cb); }
public static void createDraft(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, <START_MOD>project, <END_MOD>"drafts").put(content, cb); }
public static com.google.gerrit.client.rpc.RestApi revision(int id, <START_MOD>@com.google.gerrit.common.Nullable java.lang.String project, <END_MOD>java.lang.String revision) { return ChangeApi.change(id<START_MOD>, project<END_MOD>).view("revisions").id(revision); }
public static com.google.gerrit.client.rpc.RestApi hashtag(int changeId<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String hashtag) { return com.google.gerrit.client.changes.ChangeApi.change(changeId<START_MOD>, project<END_MOD>).view("hashtags").id(hashtag); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getSideBySideDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toSideBySideDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toSideBySideDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); toSideBySideDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toSideBySide(base, revision, <START_MOD>getProject(), <END_MOD>path)); toSideBySideDiffLink.setTitle(PatchUtil.C.sideBySideDiff()); return java.util.Collections.singletonList(toSideBySideDiffLink); }
private static void onRemove(com.google.gwt.dom.client.NativeEvent event) { java.lang.String hashtags = com.google.gerrit.client.change.Hashtags.getDataId(event); if (hashtags != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.PatchSet.Id psId = screen.getPatchSetId(); <START_MOD>final com.google.gerrit.reviewdb.client.Project.NameKey project = null; <END_MOD>com.google.gerrit.client.changes.ChangeApi.hashtags(psId.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>)).post(com.google.gerrit.client.change.Hashtags.PostInput.create(null, hashtags), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } } }); } }
private void addHashtag(final java.lang.String hashtags) { com.google.gerrit.client.changes.ChangeApi.hashtags(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>)).post(com.google.gerrit.client.change.Hashtags.PostInput.create(hashtags, null), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId.getParentKey(), <START_MOD>project, <END_MOD>java.lang.String.valueOf(psId.get()))); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); hashtagTextBox.setEnabled(true); } }); }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>)); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { if ((edit) != null) { edit.setName(edit.commit().commit()); result.revisions().put(edit.name(), com.google.gerrit.client.info.ChangeInfo.RevisionInfo.fromEdit(edit)); } render(result.revisions()); loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.client.info.ChangeInfo info, final java.lang.String revision, <START_MOD>final com.google.gerrit.reviewdb.client.Project.NameKey project, final <END_MOD>java.lang.String <START_MOD>commitMessage) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(<END_MOD>project) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); if ((info.status()) == (Change.Status.MERGED)) { message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision)); } else { message.setText(commitMessage.trim()); } } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private static com.google.gerrit.client.rpc.RestApi revision(com.google.gerrit.reviewdb.client.PatchSet.Id id, <START_MOD>@com.google.gerrit.common.Nullable java.lang.String project, <END_MOD>java.lang.String type) { return com.google.gerrit.client.changes.ChangeApi.revision(id<START_MOD>, project<END_MOD>).view(type); }
public static void draft(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(id, <START_MOD>project, <END_MOD>"drafts").id(draftId).get(cb); }
public static void drafts(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(id, <START_MOD>project, <END_MOD>"drafts").get(cb); }
@java.lang.Override protected void onLoad() { if ((fetch) == null) { if ((psId.get()) == 0) { com.google.gerrit.client.changes.ChangeApi.editWithCommands(change.legacyId().get<START_MOD>(), change.project<END_MOD>()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.EditInfo result) { fetch = result.fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } else { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(change.legacyId().get()<START_MOD>, change.project()<END_MOD>); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of((revision.equals(change.currentRevision()) ? com.google.gerrit.extensions.client.ListChangesOption.CURRENT_REVISION : com.google.gerrit.extensions.client.ListChangesOption.ALL_REVISIONS), ListChangesOption.DOWNLOAD_COMMANDS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { fetch = result.revision(revision).fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, project<END_MOD>)); }
public static com.google.gerrit.client.rpc.RestApi vote(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, int reviewer, java.lang.String vote) { return ChangeApi.reviewer(id, <START_MOD>project, <END_MOD>reviewer).view("votes").id(vote); }
public static void deleteChange(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).delete(cb); }
public static void delete(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editFile(id, <START_MOD>project, <END_MOD>path).delete(cb); }
private void scrollToPath(java.lang.String token) { <START_MOD>com.google.gerrit.client.change.ChangeIdParser.Result result = com.google.gerrit.client.change.ChangeIdParser.parse(token); if (!(changeId.equals(result.changeId))) { return; } <END_MOD>int s = token.indexOf('/', (<START_MOD>(result.identifierLength())<END_MOD> + 1)); if (s < 0) { return; } int c = token.lastIndexOf(','); if ( <= c) { token = token.substring((s + 1), c); } else { token = token.substring((s + 1)); } if (!(token.isEmpty())) { files.scrollToPath(com.google.gwtorm.client.KeyUtil.decode(token)); } }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(com.google.gerrit.client.diff.Unified.this, base, revision, <START_MOD>getProject(), <END_MOD>path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static void put(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path, java.lang.String content, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { if (Patch.COMMIT_MSG.equals(path)) { com.google.gerrit.client.changes.ChangeEditApi.putMessage(id, <START_MOD>project, <END_MOD>content, cb); } else { com.google.gerrit.client.changes.ChangeEditApi.editFile(id, <START_MOD>project, <END_MOD>path).put(content, cb); } }
public static void rename(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path, java.lang.String newPath, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.oldPath(path); in.newPath(newPath); com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).post(in, cb); }
void renderPublished(com.google.gerrit.client.diff.DisplaySide forSide, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> in) { for (com.google.gerrit.client.changes.CommentInfo info : com.google.gerrit.client.rpc.Natives.asList(in)) { com.google.gerrit.client.diff.DisplaySide side = displaySide(info, forSide); if (side != null) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), <START_MOD>project, <END_MOD>info, side, isOpen()); group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.comment(host.getCmFromSide(side), (cmLinePlusOne - 1))); getPublished().put(info.id(), box); } } }
com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.diff.DisplaySide side, com.google.gerrit.client.changes.CommentInfo info) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), <START_MOD>project, <END_MOD>info, isExpandAll()); if ((info.inReplyTo()) != null) { com.google.gerrit.client.diff.PublishedBox r = getPublished().get(info.inReplyTo()); if (r != null) { r.setReplyBox(box); } } group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.draft(host.getCmFromSide(side), java.lang.Math.max(0, (cmLinePlusOne - 1)))); return box; }
private void renderComments(java.util.List<com.google.gerrit.client.changes.CommentInfo> list) { com.google.gerrit.client.ui.CommentLinkProcessor clp = history.getCommentLinkProcessor(); com.google.gerrit.reviewdb.client.PatchSet.Id ps = new com.google.gerrit.reviewdb.client.PatchSet.Id(history.getChangeId(), info._revisionNumber()); java.util.TreeMap<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> m = com.google.gerrit.client.change.Message.byPath(list); java.util.List<com.google.gerrit.client.changes.CommentInfo> l = m.remove(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, <START_MOD>history.getProject(), <END_MOD>Util.C.commitMessage(), l)); } l = m.remove(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, <START_MOD>history.getProject(), <END_MOD>Util.C.mergeList(), l)); } for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> e : m.entrySet()) { comments.add(new com.google.gerrit.client.change.FileComments(clp, ps, <START_MOD>history.getProject(), <END_MOD>e.getKey(), e.getValue())); } }
public static void getMeta(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.editor.EditFileInfo> cb) { if ((id.get()) != 0) { throw new java.lang.IllegalStateException( supported for edits } com.google.gerrit.client.changes.ChangeEditApi.editFile(id.getParentKey().get(), <START_MOD>project, <END_MOD>path).view("meta").get(cb); }
private void loadCommit(final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { if ((rev.isEdit()) || ((rev.commit()) != null)) { return; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks(changeId.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>rev.name(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { rev.setCommit(info); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.PatchSet.Id ps<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gerrit.client.changes.CommentInfo info) { return com.google.gerrit.client.Dispatcher.toPatch(null, ps<START_MOD>, project<END_MOD>, info.path(), ((info.side()) == (com.google.gerrit.extensions.client.Side.PARENT) ? com.google.gerrit.client.diff.DisplaySide.A : com.google.gerrit.client.diff.DisplaySide.B), info.line()); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadDrafts(com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>rev.name()).view("drafts").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } else { r.add(com.google.gerrit.client.rpc.NativeMap.<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>create()); } return r; }
private static com.google.gerrit.client.rpc.RestApi editMessage(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("edit:message"); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } else { super.onFailure(err); } }
static void publishEdit(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.publishEdit(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.EditActions.cs(id, <START_MOD>project, <END_MOD>editButtons)); }
static void rebaseEdit(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.rebaseEdit(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.EditActions.cs(id, <START_MOD>project, <END_MOD>editButtons)); }
static void deleteEdit(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.deleteEdit(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.EditActions.cs(id, <START_MOD>project, <END_MOD>editButtons)); }
private void delete(java.lang.String path) { hide(); com.google.gerrit.client.changes.ChangeEditApi.delete(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(changeId<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
public static com.google.gerrit.client.rpc.RestApi suggestReviewers(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String q, int n, boolean e) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("suggest_reviewers").addParameter("n", n).addParameter("e", e); if (q != null) { api.addParameter("q", q); } return api; }
public static void includedIn(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo> cb) { com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"in").get(cb); }
@com.google.gwt.uibinder.client.UiHandler("deleteEdit") void onDeleteEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChangeEdit())) { com.google.gerrit.client.change.EditActions.deleteEdit(changeId, <START_MOD>project, <END_MOD>publishEdit, rebaseEdit, deleteEdit); } }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(final com.google.gerrit.reviewdb.client.Change.Id id, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>final com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.change.EditActions.setEnabled(false, editButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } else { super.onFailure(err); } } }; }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(this, base, revision, <START_MOD>getProject(), <END_MOD>path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
@java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(revision.getParentKey(), <START_MOD>project, <END_MOD>revision.getId())); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number())<START_MOD>, project<END_MOD>, style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); }
private void open(java.lang.String path) { hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, revision._number()), <START_MOD>project, <END_MOD>path)); }
void onDelete() { if ((popup) != null) { popup.hide(); return; } if ((deleteBox) == null) { deleteBox = new com.google.gerrit.client.change.DeleteFileBox(changeId, <START_MOD>project, <END_MOD>revision); } deleteBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(deleteButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(deleteBox); p.showRelativeTo(deleteButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); deleteBox.setFocus(true); popup = p; }
private void getImpl(final java.lang.Integer id, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> cb) { java.lang.String name = changeToProject.get(id); if (name != null) { getImpl(name, cb); return; } com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, null<END_MOD>).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { changeToProject.put(id, result.project()); getImpl(result.project(), cb); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { cb.onFailure(caught); } }); }
<START_MOD>public com.google.gerrit.client.rpc.RestApi id(int id, java.lang.String project) { return idRaw((((com.google.gwt.http.client.URL.encodePathSegment(project)) + "~") + id)); }<END_MOD>
private com.google.inject.Key<javax.servlet.http.HttpServlet> directChangeById() { return key(new javax.servlet.http.HttpServlet() { private static final long serialVersionUID = 1L; @java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, null<END_MOD>), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } } }); }
@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, null<END_MOD>), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } }
static void call(com.google.gerrit.client.info.ChangeInfo changeInfo, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revisionInfo) { if (com.google.gerrit.client.api.ChangeGlue.onSubmitChange(changeInfo, revisionInfo)) { final com.google.gerrit.reviewdb.client.Change.Id changeId = changeInfo.legacyId(); com.google.gerrit.client.changes.ChangeApi.submit(changeId.get<START_MOD>(), changeInfo.project<END_MOD>(), revisionInfo.name(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.SubmitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.SubmitInfo result) { redisplay(); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); } else { super.onFailure(err); } redisplay(); } private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, changeInfo.projectNameKey())); } }); } }<END_MOD>
private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, changeInfo.projectNameKey()<END_MOD>)); }
void onRestore(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.restore(curr.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey()<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getUnifiedDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toUnifiedDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toUnifiedDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); toUnifiedDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toUnified(base, revision, <START_MOD>getProject(), <END_MOD>path)); toUnifiedDiffLink.setTitle(PatchUtil.C.unifiedDiff()); return java.util.Collections.singletonList(toUnifiedDiffLink); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return info.binary() ? com.google.gerrit.client.Dispatcher.toUnified(base, curr, <START_MOD>project, <END_MOD>info.path()) : (mode) == (com.google.gerrit.client.change.FileTable.Mode.REVIEW) ? com.google.gerrit.client.Dispatcher.toPatch(base, curr, <START_MOD>project, <END_MOD>info.path()) : com.google.gerrit.client.Dispatcher.toEditScreen(curr, <START_MOD>project, <END_MOD>info.path()); }
void onDelete(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.delete(curr.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey()<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(curr.getParentKey()<START_MOD>, project<END_MOD>)); }
private void setReviewed(com.google.gerrit.client.info.FileInfo info, boolean r) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(curr<START_MOD>, Project.NameKey.asStringOrNull(project)<END_MOD>).view("files").id(info.path()).view("reviewed"); if (r) { api.put(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } else { api.delete(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } }
@java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, <START_MOD>project, <END_MOD>base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(changeId, <START_MOD>null, <END_MOD>base, rev, openReplyBox, FileTable.Mode.REVIEW)); }
private void countParents(com.google.gerrit.client.rpc.CallbackGroup cbg) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(<START_MOD>), ((project) == null ? null : project.get()<END_MOD>), revision.getId()).view("commit").get(cbg.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { parents = info.parents().length(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { parents = 0; } })); }
void reloadDiffInfo() { int id = ++(reloadVersionId); com.google.gerrit.client.diff.DiffApi.diff(revision, <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>path).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { if ((id == (reloadVersionId)) && (isAttached())) { diff = diffInfo; operation(() -> { skipManager.removeAll(); getChunkManager().reset(); getDiffTable().scrollbar.removeDiffAnnotations(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); }); } } }); }
private java.lang.Runnable openEditScreen(net.codemirror.lib.CodeMirror cm) { return () -> { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras().activeLine(); int line = (cm.getLineNumber(handle)) + 1; if (Patch.COMMIT_MSG.equals(path)) { line = adjustCommitMessageLine(line); } java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen(revision, <START_MOD>project, <END_MOD>path, line); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(token); } else { com.google.gerrit.client.Gerrit.display(token); } }; }
void prefetchNextFile() { java.lang.String nextPath = header.getNextPath(); if (nextPath != null) { com.google.gerrit.client.diff.DiffApi.diff(revision<START_MOD>, Project.NameKey.asStringOrNull(project)<END_MOD>, nextPath).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo info) { new net.codemirror.mode.ModeInjector().add(getContentType(info.metaA())).add(getContentType(info.metaB())).inject(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private java.lang.Runnable upToChange(boolean openReplyBox) { return () -> { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); getCommentManager().saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, <START_MOD>project, <END_MOD>base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(changeId, <START_MOD>null, <END_MOD>base, rev, openReplyBox, FileTable.Mode.REVIEW)); } }); }; }
private void rename(java.lang.String path, java.lang.String newPath) { hide(); com.google.gerrit.client.changes.ChangeEditApi.rename(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), path, newPath, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(changeId<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
static void invoke(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.rpc.RestApi api) { com.google.gerrit.client.api.DefaultActions.invoke(action, api, com.google.gerrit.client.api.DefaultActions.callback(com.google.gerrit.common.PageLinks.toChange(change.legacyId()<START_MOD>, change.projectNameKey()<END_MOD>))); }
private static void codemirror(final java.lang.String token, final com.google.gerrit.client.DiffObject base, final com.google.gerrit.reviewdb.client.Patch.Key id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), <START_MOD>project, <END_MOD>id.get(), side, line)); } }); }
@com.google.gwt.uibinder.client.UiHandler("permalink") void onReload(com.google.gwt.event.dom.client.ClickEvent e) { e.preventDefault(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(com.google.gerrit.client.diff.SideBySide.this, base, revision, <START_MOD>getProject(), <END_MOD>path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static java.lang.String toChange(com.google.gerrit.reviewdb.client.Change.Id c<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String b, java.lang.String p) { java.lang.String u = <START_MOD>com.google.gerrit.common.PageLinks.toChange<END_MOD>(<START_MOD>c,<END_MOD> <START_MOD>project<END_MOD>); if (b != null) { u += b + ".."; } u += p; return u; }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
<START_MOD>private static java.lang.String toChangeNoSlash(com.google.gerrit.reviewdb.client.Change.Id c, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project) { if (project != null) { return (("/c/" + (project.get())) + (com.google.gerrit.common.PageLinks.PROJECT_CHANGE_DELIMITER)) + c; } return "/c/" + c; }<END_MOD>
public static java.lang.String toChangeInEditMode(com.google.gerrit.reviewdb.client.Change.Id c<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>) { return (<START_MOD>com.google.gerrit.common.PageLinks.toChangeNoSlash(c,<END_MOD> <START_MOD>project)<END_MOD>) + ",edit/"; }
private void loadDiff(com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group) { java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(rev, group); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts = loadDrafts(rev, group); loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts); if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((fileTableMode) == (FileTable.Mode.REVIEW))) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { files.markReviewed(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } }
@com.google.gwt.uibinder.client.UiHandler("rebaseEdit") void onRebaseEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.rebaseEdit(changeId, <START_MOD>project, <END_MOD>publishEdit, rebaseEdit, deleteEdit); }
private void updateToken(com.google.gerrit.client.info.ChangeInfo info, com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev) { java.lang.StringBuilder token = new java.lang.StringBuilder("/c/")<START_MOD>; if ((project) != null) { token.append(project.get()); token.append(PageLinks.PROJECT_CHANGE_DELIMITER); } token<END_MOD>.append(info._number()).append("/"); if ((base.asString()) != null) { token.append(base.asString()).append(".."); } if (((base.asString()) != null) || (!(rev.name().equals(info.currentRevision())))) { token.append(rev._number()); } setToken(token.toString()); }
@com.google.gwt.uibinder.client.UiHandler("publishEdit") void onPublishEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.publishEdit(changeId, <START_MOD>project, <END_MOD>publishEdit, rebaseEdit, deleteEdit); }
void showUpdates(com.google.gerrit.client.info.ChangeInfo newInfo) { if ((!(isAttached())) || (newInfo.updated().equals(lastDisplayedUpdate))) { return; } com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> om = changeInfo.messages(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> nm = newInfo.messages(); if (om == null) { om = com.google.gwt.core.client.JsArray.createArray().cast(); } if (nm == null) { nm = com.google.gwt.core.client.JsArray.createArray().cast(); } if ((om.length()) == (nm.length())) { return; } if ((updateAvailable) == null) { updateAvailable = new com.google.gerrit.client.change.UpdateAvailableBar() { @java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); } @java.lang.Override void onIgnore(java.sql.Timestamp newTime) { lastDisplayedUpdate = newTime; } }; } updateAvailable.set(com.google.gerrit.client.rpc.Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated()); if (!(updateAvailable.isAttached())) { add(updateAvailable); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId.getParentKey(), <START_MOD>project, <END_MOD>java.lang.String.valueOf(psId.get()))); }
private com.google.gerrit.client.ui.InlineHyperlink createLink(java.lang.String label, com.google.gerrit.client.DiffObject id) { assert (other) != null; if (sideA) { assert !(other.idActive.isBaseOrAutoMerge()); } com.google.gerrit.client.DiffObject diffBase = (sideA) ? id : other.idActive; com.google.gerrit.client.DiffObject revision = (sideA) ? other.idActive : id; return new com.google.gerrit.client.ui.InlineHyperlink(label, (parent.isSideBySide() ? com.google.gerrit.client.Dispatcher.toSideBySide(diffBase, revision.asPatchSetId(), <START_MOD>project, <END_MOD>path) : com.google.gerrit.client.Dispatcher.toUnified(diffBase, revision.asPatchSetId(), <START_MOD>project, <END_MOD>path))); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.createChange(project, branch, topic, message, base, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); hide(); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); hide(); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.EditInfo edit, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.edit(change.legacyId().get()<START_MOD>, change.project()<END_MOD>).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.EditGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(edit); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
public static void get(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String path, boolean base, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.rpc.RestApi api; <START_MOD>java.lang.String projectStr = (project == null) ? null : project.get(); <END_MOD>if ((id.get()) != 0) { api = com.google.gerrit.client.changes.ChangeApi.revision(id<START_MOD>, projectStr<END_MOD>).view("files").id(path).view("content"); } else if (Patch.COMMIT_MSG.equals(path)) { api = com.google.gerrit.client.changes.ChangeEditApi.editMessage(id.getParentKey().get()<START_MOD>, projectStr<END_MOD>).addParameter("base", base); } else { api = com.google.gerrit.client.changes.ChangeEditApi.editFile(id.getParentKey().get(), <START_MOD>projectStr, <END_MOD>path).addParameter("base", base); } api.get(cb); }
public static void putMessage(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String m, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editMessage(id<START_MOD>, project<END_MOD>).put(m, cb); }
public static void restore(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.restorePath(path); com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).post(in, cb); }
private static com.google.gerrit.client.rpc.RestApi editFile(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String path) { return com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).id(path); }
void setUpBlame(final net.codemirror.lib.CodeMirror cm, final boolean isBase, final com.google.gerrit.reviewdb.client.PatchSet.Id rev, final java.lang.String path) { if (((!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) && (com.google.gerrit.client.Gerrit.isSignedIn())) && (com.google.gerrit.client.Gerrit.info().change().allowBlame())) { com.google.gwt.user.client.ui.Anchor blameIcon = createBlameIcon(); blameIcon.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(rev<START_MOD>, ((project) == null ? null : project.get())<END_MOD>, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } } }); linkPanel.add(blameIcon); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(rev<START_MOD>, ((project) == null ? null : project.get())<END_MOD>, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } }
private com.google.gwt.user.client.ui.Widget createEditIcon() { com.google.gerrit.reviewdb.client.PatchSet.Id id = (idActive.isBaseOrAutoMerge()) ? other.idActive.asPatchSetId() : idActive.asPatchSetId(); com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.edit()), ("#" + (com.google.gerrit.client.Dispatcher.toEditScreen(id, <START_MOD>project, <END_MOD>path)))); anchor.setTitle(PatchUtil.C.edit()); return anchor; }
public static void get(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String path, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.changes.ChangeEditApi.get(id, <START_MOD>project, <END_MOD>path, false, cb); }
private java.lang.String getReplyCommentName() {<START_MOD> if ((project) != null) { return (("savedReplyComment-" + (project.get())) + (com.google.gerrit.common.PageLinks.PROJECT_CHANGE_DELIMITER)) + (changeId.toString()); }<END_MOD> return "savedReplyComment-" + (changeId.toString()); }
@com.google.gwt.uibinder.client.UiHandler("fix") void onFix(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); java.lang.String t = com.google.gerrit.client.Dispatcher.toEditScreen(psId<START_MOD>, project<END_MOD>, comment.path(), comment.line()); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(t); } else { com.google.gerrit.client.Gerrit.display(t); } }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.restore(id.get(<START_MOD>), ((project) == null ? null : project.get()<END_MOD>), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); hide(); } }); }
@java.lang.Override protected void onOpenRow(final int row) { final com.google.gerrit.client.info.ChangeInfo c = getRowItem(row); final com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, c.projectNameKey()<END_MOD>)); }
@com.google.gwt.uibinder.client.UiHandler("done") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(getCommentManager().host.getToken()); } else if ((replyBox) == null) { done.setEnabled(false); com.google.gerrit.client.changes.CommentInfo input = com.google.gerrit.client.changes.CommentInfo.createReply(comment); input.message(PatchUtil.C.cannedReplyDone()); com.google.gerrit.client.changes.CommentApi.createDraft(psId, <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); getCommentManager().addDraftBox(displaySide, result); } }); } else { openReplyBox(); setOpen(false); } }
private java.lang.String getInlineCommentName(com.google.gerrit.client.changes.CommentInfo comment) { if ((psId) == null) { return null; } java.lang.String result = "patchComment-"; if ((comment.id()) != null) { result = ("patchCommentEdit-" + (comment.id())) + "-"; } else if ((comment.inReplyTo()) != null) { result = ("patchReply-" + (comment.inReplyTo())) + "-"; } <START_MOD>if ((project) != null) { <END_MOD>result += (<START_MOD>project.get()) + (com.google.gerrit.common.PageLinks.PROJECT_CHANGE_DELIMITER); } result += (<END_MOD>((((((changeId) + "-") + (psId.getId())) + "-") + (com.google.gerrit.client.change.LocalComments.btoa(comment.path()))) + "-") + (comment.side())) + "-"; if (comment.hasRange()) { result += (((((("R" + (comment.range().startLine())) + ",") + (comment.range().startCharacter())) + "-") + (comment.range().endLine())) + ",") + (comment.range().endCharacter()); } else { result += comment.line(); } return result; }
public static void saveInlineComments() { final com.google.gerrit.client.change.LocalComments.StorageBackend storage = new com.google.gerrit.client.change.LocalComments.StorageBackend(); for (final java.lang.String cookie : storage.getKeys()) { if (com.google.gerrit.client.change.LocalComments.isInlineComment(cookie)) { com.google.gerrit.client.change.LocalComments.InlineComment input = com.google.gerrit.client.change.LocalComments.getInlineComment(cookie); if ((input.commentInfo.id()) == null) { com.google.gerrit.client.changes.CommentApi.createDraft(input.psId<START_MOD>, Project.NameKey.asStringOrNull(input.project)<END_MOD>, input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } }); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(input.psId, <START_MOD>Project.NameKey.asStringOrNull(input.project), <END_MOD>input.commentInfo.id(), input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { storage.removeItem(cookie); } else { super.onFailure(caught); } } }); } } } }
public static java.lang.String toChange(com.google.gerrit.reviewdb.client.Change.Id c, <START_MOD>@com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.common.Nullable<END_MOD> <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>) { return (<START_MOD>com.google.gerrit.common.PageLinks.toChangeNoSlash<END_MOD>(<START_MOD>c,<END_MOD> <START_MOD>project)<END_MOD>) + "/"; }
private java.lang.String url(com.google.gerrit.client.info.ChangeInfo.RevisionInfo r) { return com.google.gerrit.common.PageLinks.toChange(changeId, <START_MOD>project, <END_MOD>r.id()); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } else { super.onFailure(err); } }
static void call(final com.google.gwt.user.client.ui.Button b, final java.lang.String project) { b.setEnabled(false); new com.google.gerrit.client.ui.CreateChangeDialog(new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(AdminConstants.I.buttonCreate()); message.setText(AdminConstants.I.buttonCreateDescription()); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private com.google.gwtexpui.globalkey.client.KeyCommand setupNav(com.google.gerrit.client.ui.InlineHyperlink link, char key, java.lang.String help, com.google.gerrit.client.info.FileInfo info) { if (info != null) { final java.lang.String url = url(info); link.setTargetHistoryToken(url); link.setTitle(PatchUtil.M.fileNameWithShortcutKey(com.google.gerrit.client.info.FileInfo.getFileName(info.path()), java.lang.Character.toString(key))); com.google.gwtexpui.globalkey.client.KeyCommand k = new com.google.gwtexpui.globalkey.client.KeyCommand(0, key, help) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(url); } }; keys.add(k); if (link == (prev)) { hasPrev = true; } else { hasNext = true; } return k; } link.getElement().getStyle().setVisibility(Visibility.HIDDEN); keys.add(new com.google.gerrit.client.diff.UpToChangeCommand(patchSetId, <START_MOD>projectKey, <END_MOD>0, key)); return null; }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(final com.google.gerrit.reviewdb.client.Change.Id id, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>final com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.change.ChangeActions.setEnabled(false, draftButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } else { super.onFailure(err); } } }; }
static void delete(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteRevision(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>revision, com.google.gerrit.client.change.ChangeActions.cs(id, <START_MOD>project, <END_MOD>draftButtons)); }
static void unmarkPrivate(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.unmarkPrivate(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.ChangeActions.cs(id, <START_MOD>project, <END_MOD>draftButtons)); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); }
public static void restore(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"restore").post(input, cb); }
static void publish(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.publish(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>revision, com.google.gerrit.client.change.ChangeActions.cs(id, <START_MOD>project, <END_MOD>draftButtons)); }
static void markPrivate(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.markPrivate(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.ChangeActions.cs(id, <START_MOD>project, <END_MOD>draftButtons)); }
void onRename() { if ((popup) != null) { popup.hide(); return; } if ((renameBox) == null) { renameBox = new com.google.gerrit.client.change.RenameFileBox(changeId, <START_MOD>project, <END_MOD>revision); } renameBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(renameButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(renameBox); p.showRelativeTo(renameButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); renameBox.setFocus(true); popup = p; }
public void onEdit() { if ((popup) != null) { popup.hide(); return; } files.unregisterKeys(); if ((addBox) == null) { addBox = new com.google.gerrit.client.change.AddFileBox(changeId, <START_MOD>project, <END_MOD>revision, files); } addBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(addButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(addBox); p.showRelativeTo(addButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); addBox.setFocus(true); popup = p; }
private void doSearch() { final java.lang.String query = searchBox.getText().trim(); if ("".equals(query)) { return; } searchBox.setFocus(false); if (((dropdown) != null) && (dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc()))) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toDocumentationQuery(query)); } else { if (query.matches("^[1-9][0-9]*$")) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(Change.Id.parse(query)<START_MOD>, null<END_MOD>)); } else { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeQuery(query), com.google.gerrit.client.changes.QueryScreen.forQuery(query)); } } }
@java.lang.Override protected void onLoad() { commentsPanel.setVisible(false); post.setEnabled(false); if (lc.hasReplyComment()) { message.setText(lc.getReplyComment()); lc.removeReplyComment(); } com.google.gerrit.client.changes.ChangeApi.drafts(psId.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>)).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { displayComments(result); post.setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { post.setEnabled(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { java.lang.String t = message.getText(); if (t != null) { message.setCursorPos(t.length()); } return false; } }, 0); }
private static com.google.gerrit.client.rpc.RestApi call(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String action) { return com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view(action); }
private void displayComments(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> m) { comments.clear(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> l = m.get(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, <START_MOD>project, <END_MOD>Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.COMMIT_MSG, l))); } l = m.get(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId<START_MOD>, project<END_MOD>, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.MERGE_LIST, l))); } java.util.List<java.lang.String> paths = new java.util.ArrayList(m.keySet()); java.util.Collections.sort(paths); for (java.lang.String path : paths) { if (!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, <START_MOD>project, <END_MOD>path, com.google.gerrit.client.change.ReplyBox.copyPath(path, m.get(path)))); } } commentsPanel.setVisible(((comments.getWidgetCount()) > 0)); }
<START_MOD>@com.google.gerrit.common.Nullable Project.NameKey getProject() { return project; }<END_MOD>
@com.google.gwt.uibinder.client.UiHandler({ "discard1", "discard2" }) void onDiscard(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (isNew()) { removeUI(); restoreSelection(); } else { setEdit(false); pendingGroup = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.changes.CommentApi.deleteDraft(psId<START_MOD>, Project.NameKey.asStringOrNull(project)<END_MOD>, comment.id(), pendingGroup.addFinal(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { pendingGroup = null; removeUI(); } })); } }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(id<START_MOD>.get(), project<END_MOD>.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static java.lang.String toEditScreen(com.google.gerrit.reviewdb.client.PatchSet.Id revision<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String fileName, int line) { return com.google.gerrit.client.Dispatcher.toPatch("edit", com.google.gerrit.client.DiffObject.base(), revision, <START_MOD>project, <END_MOD>fileName, null, line); }
static void call(final com.google.gwt.user.client.ui.Button b, final <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey project, final <END_MOD>java.lang.String <START_MOD>branch, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, final boolean enabled) { b.setEnabled(false); new com.google.gerrit.client.ui.RebaseDialog(<END_MOD>project, branch, id, enabled) { <START_MOD>@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(id.get(), <END_MOD>project.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override protected void onRequestSuggestions(final com.google.gerrit.client.change.Request req, final com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), revision.name()).view("files"); if ((req.getQuery()) != null) { api.addParameter("q", ((req.getQuery()) == null ? "" : req.getQuery())); } api.background().get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { java.util.List<com.google.gerrit.client.change.Suggestion> r = new java.util.ArrayList<>(); for (java.lang.String path : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.PathSuggestOracle.PathSuggestion(path)); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { java.util.List<com.google.gerrit.client.change.Suggestion> none = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(none)); } }); }
public static void unmarkPrivate(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("private.delete").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.PatchSet.Id ps, com.google.gerrit.client.changes.CommentInfo info<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>) { return com.google.gerrit.client.Dispatcher.toPatch(null, ps, <START_MOD>project, <END_MOD>info.path()); }
@java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); }
@com.google.gwt.uibinder.client.UiHandler("deleteRevision") void onDeleteRevision(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteDraftRevision())) { com.google.gerrit.client.change.ChangeActions.delete(changeId, <START_MOD>project, <END_MOD>revision, publish, deleteRevision); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { if (((replyAction) != null) && (replyAction.isVisible())) { replyAction.quickApprove(input); } else { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), <START_MOD>project.get(), <END_MOD>revision).view("review").post(input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); }
private void postReview() { in.message(message.getText().trim()); in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS); in.prePost(); com.google.gerrit.client.changes.ChangeApi.revision(psId.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), revision).view("review").post(in, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotSignedIn(caught)) { lc.setReplyComment(message.getText()); } super.onFailure(caught); } }); hide(); }
public static com.google.gerrit.client.rpc.RestApi reviewer(int id, <START_MOD>@com.google.gerrit.common.Nullable java.lang.String project, <END_MOD>int reviewer) { return ChangeApi.change(id<START_MOD>, project<END_MOD>).view("reviewers").id(reviewer); }
public static void markPrivate(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("private").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
public static com.google.gerrit.client.rpc.RestApi actions(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String revision) { if ((revision == null) || (revision.equals(""))) { revision = "current"; } return com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>revision, "actions"); }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Change.Id id, <START_MOD>@com.google.gerrit.common.Nullable <END_MOD>final <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey project, final <END_MOD>java.lang.String revision, final java.lang.String commitSubject) { b.setEnabled(false); new com.google.gerrit.client.ui.TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) { { sendButton.setText(Util.C.buttonRevertChangeSend()); message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
private com.google.gerrit.client.rpc.RestApi reviewed() { return com.google.gerrit.client.changes.ChangeApi.revision(patchSetId<START_MOD>, Project.NameKey.asStringOrNull(projectKey)<END_MOD>).view("files").id(path).view("reviewed"); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return (diffScreenType) == (com.google.gerrit.extensions.client.GeneralPreferencesInfo.DiffView.UNIFIED_DIFF) ? com.google.gerrit.client.Dispatcher.toUnified(base, patchSetId, <START_MOD>projectKey, <END_MOD>info.path()) : com.google.gerrit.client.Dispatcher.toSideBySide(base, patchSetId, <START_MOD>projectKey, <END_MOD>info.path()); }
@java.lang.Override protected void onLoad() { com.google.gerrit.client.diff.DiffApi.list(patchSetId, base.asPatchSetId(<START_MOD>), Project.NameKey.asStringOrNull(projectKey<END_MOD>), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); fileNumber.setInnerText(java.lang.Integer.toString(((com.google.gerrit.client.rpc.Natives.asList(files).indexOf(result.get(path))) + 1))); fileCount.setInnerText(java.lang.Integer.toString(files.length())); } }); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(patchSetId<START_MOD>, Project.NameKey.asStringOrNull(projectKey)<END_MOD>).view("files").addParameterTrue("reviewed").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { boolean b = com.google.gerrit.client.rpc.Natives.asList(result).contains(path); reviewed.setValue(b, false); if ((!b) && ((reviewedState) == (com.google.gerrit.client.diff.Header.ReviewedState.AUTO_REVIEW))) { postAutoReviewed(); } reviewedState = com.google.gerrit.client.diff.Header.ReviewedState.LOADED; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private static void onRemoveReviewer(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); if (user != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.reviewer(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(screen.getProject()<END_MOD>), user).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, screen.getProject())); } } }); } }<END_MOD>
private static void onRemoveVote(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); java.lang.String vote = com.google.gerrit.client.change.Labels.getVoteId(event); if ((user != null) && (vote != null)) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.vote(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(screen.getProject()<END_MOD>), user, vote).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, screen.getProject())); } } }); } }<END_MOD>
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, screen.getProject()<END_MOD>)); } }
@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String query = com.google.common.base.CharMatcher.is('/').trimTrailingFrom(req.getPathInfo()); java.util.List<com.google.gerrit.extensions.common.ChangeInfo> results; try { results = changes.query(query).withLimit(2).get(); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { com.google.gerrit.httpd.DirectChangeByCommit.log.warn(( process query by URL: /r/ + query), e); results = com.google.common.collect.ImmutableList.of(); } java.lang.String token; if ((results.size()) == 1) { <START_MOD>com.google.gerrit.extensions.common.ChangeInfo ci = results.iterator().next(); <END_MOD>token = com.google.gerrit.common.PageLinks.toChange(new com.google.gerrit.reviewdb.client.Change.Id(<START_MOD>ci<END_MOD>._number)<START_MOD>, new com.google.gerrit.reviewdb.client.Project.NameKey(ci.project)<END_MOD>); } else { token = com.google.gerrit.common.PageLinks.toChangeQuery(query); } com.google.gerrit.httpd.UrlModule.toGerrit(token, req, rsp); }
public static com.google.gerrit.client.rpc.RestApi reviewers(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("reviewers"); }
private static com.google.gerrit.client.rpc.RestApi call(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, java.lang.String action) { return ChangeApi.change(id<START_MOD>, project<END_MOD>).view("revisions").id(commit).view(action); }
public static void setAssignee(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String user, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.AssigneeInput input = com.google.gerrit.client.changes.ChangeApi.AssigneeInput.create(); input.assignee(user); com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("assignee").put(input, cb); }
public static void edit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).get(cb); }
@java.lang.Override protected com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList> loadCallback() { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeList>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, c.projectNameKey()<END_MOD>)); } else { display(result); com.google.gerrit.client.changes.QueryScreen.this.display(); } } } }; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, c.projectNameKey()<END_MOD>)); } else { display(result); this.display(); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, getProjectKey()<END_MOD>)); } else { displayReadOnly(access); } }
public static void submit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.SubmitInfo> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>commit, "submit").post(in, cb); }
public static void deleteRevision(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.revision(id, <START_MOD>project, <END_MOD>commit).delete(cb); }
public static com.google.gerrit.client.rpc.RestApi reviewer(int id, <START_MOD>@com.google.gerrit.common.Nullable java.lang.String project, <END_MOD>java.lang.String reviewer) { return ChangeApi.change(id<START_MOD>, project<END_MOD>).view("reviewers").id(reviewer); }
public static void commitWithLinks(int changeId<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String revision, com.google.gerrit.client.rpc.CallbackGroup.Callback<com.google.gerrit.client.info.ChangeInfo.CommitInfo> callback) { com.google.gerrit.client.changes.ChangeApi.revision(changeId, <START_MOD>project, <END_MOD>revision).view("commit").addParameterTrue("links").get(callback); }
@com.google.gwt.uibinder.client.UiHandler("publish") void onPublish(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.publish(changeId, <START_MOD>project, <END_MOD>revision, publish, deleteRevision); }
public static void deleteEdit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).delete(cb); }
public static void revert(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"revert").post(input, cb); }
public static com.google.gerrit.client.rpc.RestApi drafts(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"drafts"); }
@com.google.gwt.uibinder.client.UiHandler("review") void onReview(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gerrit.common.data.ProjectAccess access = driver.flush(); if (driver.hasErrors()) { com.google.gwt.user.client.Window.alert(AdminConstants.I.errorsMustBeFixed()); return; } java.lang.String message = commitMessage.getText().trim(); if ("".equals(message)) { message = null; } enable(false); Util.PROJECT_SVC.reviewProjectAccess(getProjectKey(), access.getRevision(), message, access.getLocal(), access.getInheritsFrom(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, getProjectKey()<END_MOD>)); } else { displayReadOnly(access); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { error.clear(); enable(true); super.onFailure(caught); } }); }
public static void deleteAssignee(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("assignee").delete(cb); }
public static void rebaseEdit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("edit:rebase").post(in, cb); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.abandon(id.get(<START_MOD>), ((project) == null ? null : project.get()<END_MOD>), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id<START_MOD>, project<END_MOD>)); hide(); } }); }
void updateReviewerList() { com.google.gerrit.client.changes.ChangeApi.detail(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { display(result); } }); }
public static com.google.gerrit.client.rpc.RestApi blame(com.google.gerrit.reviewdb.client.PatchSet.Id id, <START_MOD>@com.google.gerrit.common.Nullable java.lang.String project, <END_MOD>java.lang.String path, boolean base) { return ChangeApi.revision(id<START_MOD>, project<END_MOD>).view("files").id(path).view("blame").addParameter("base", base); }
private void initRevisionsAction(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision, com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actions) { int currentPatchSet; if (((info.currentRevision()) != null) && (info.revisions().containsKey(info.currentRevision()))) { currentPatchSet = info.revision(info.currentRevision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.info.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } java.lang.String currentlyViewedPatchSet; boolean isPatchSetCurrent = true; java.lang.String revisionId = info.revision(revision).id(); if (revisionId.equals("edit")) { currentlyViewedPatchSet = Resources.M.editPatchSet(com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParent(info.revisions().values())); currentPatchSet = (info.revisions().values().length()) - 1; } else { currentlyViewedPatchSet = revisionId; if (!(currentlyViewedPatchSet.equals(java.lang.Integer.toString(currentPatchSet)))) { isPatchSetCurrent = false; } } patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); updatePatchSetsTextStyle(isPatchSetCurrent); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacyId(), <START_MOD>info.projectNameKey(), <END_MOD>revision, edit, style, headerLine, patchSets); com.google.gerrit.client.info.ChangeInfo.RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { if (actions.containsKey("publish")) { publish.setVisible(true); publish.setTitle(actions.get("publish").title()); } if (actions.containsKey("/")) { deleteRevision.setVisible(true); deleteRevision.setTitle(actions.get("/").title()); } } }
public static java.lang.String toPatch(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { return com.google.gerrit.client.Dispatcher.toPatch("", diffBase, revision, <START_MOD>project, <END_MOD>fileName, side, line); }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(id, <START_MOD>project, <END_MOD>line)); }
private void initIncludedInAction(com.google.gerrit.client.info.ChangeInfo info) { if ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { includedInAction = new com.google.gerrit.client.change.IncludedInAction(info.legacyId(), <START_MOD>project, <END_MOD>style, headerLine, includedIn); includedIn.setVisible(true); } }
public static java.lang.String toPatch(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("", diffBase, revision, <START_MOD>project, <END_MOD>fileName, null, 0); }
public static java.lang.String toUnified(com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("unified", diffBase, revision, <START_MOD>project, <END_MOD>fileName, null, 0); }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(this, base, revision, <START_MOD>getProject(), <END_MOD>path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
private static java.lang.String toPatch(java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(<START_MOD>toChange<END_MOD>(c<START_MOD>, project)); if ((diffBase != null) && ((diffBase.asString()) != null)) { p.append(diffBase.asString()).append(".."); } p.append(revision.getId()<END_MOD>).append("/")<START_MOD>.append(com.google.gwtorm.client.KeyUtil.encode(fileName))<END_MOD>; if ((<START_MOD>(type<END_MOD> != null) && (<START_MOD>!(type.isEmpty()))) && ((!("sidebyside".equals(type))) || (com.google.gerrit.client.Dispatcher.preferUnified())<END_MOD>)) { p.append(<START_MOD>",").append(type<END_MOD>); } if ((<START_MOD>side == (com.google.gerrit.client.diff.DisplaySide.A)<END_MOD>) && (<START_MOD>line > 0<END_MOD>)) { p.append(<START_MOD>"@a").append(line<END_MOD>); } <START_MOD>else <END_MOD>if (line > 0) { p.append(<START_MOD>"@"<END_MOD>).append(line); } <START_MOD>return p.toString(<END_MOD>); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(change.legacyId().get()<START_MOD>, change.project()<END_MOD>).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.ChangeGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.changes.ChangeApi.includedIn(changeId.get(<START_MOD>), ((project) == null ? null : project.get()<END_MOD>), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.IncludedInInfo r) { branches.setInnerSafeHtml(formatList(r.branches())); tags.setInnerSafeHtml(formatList(r.tags())); for (java.lang.String n : r.externalNames()) { com.google.gwt.core.client.JsArrayString external = r.external(n); if ((external.length()) > 0) { appendRow(n, external); } } loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private void renderLinksToDiff() { com.google.gerrit.client.ui.InlineHyperlink sbs = new com.google.gerrit.client.ui.InlineHyperlink(); sbs.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); sbs.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch("sidebyside", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path)<START_MOD>, projectKey<END_MOD>)); sbs.setTitle(PatchUtil.C.sideBySideDiff()); linkPanel.add(sbs); com.google.gerrit.client.ui.InlineHyperlink unified = new com.google.gerrit.client.ui.InlineHyperlink(); unified.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); unified.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch("unified", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path)<START_MOD>, projectKey<END_MOD>)); unified.setTitle(PatchUtil.C.unifiedDiff()); linkPanel.add(unified); }
@com.google.gwt.uibinder.client.UiHandler("abandon") void onAbandon(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((abandonAction) == null) { abandonAction = new com.google.gerrit.client.change.AbandonAction(abandon, changeId<START_MOD>, project<END_MOD>); } abandonAction.show(); }
private java.lang.Runnable save() { return () -> { if (!(cmEdit.isClean(generation))) { close.setEnabled(false); java.lang.String text = cmEdit.getValue(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String trimmed = (text.trim()) + "\r"; if (!(trimmed.equals(text))) { text = trimmed; cmEdit.setValue(text); } } final int g = cmEdit.changeGeneration(false); com.google.gerrit.client.changes.ChangeEditApi.put(revision.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(projectKey<END_MOD>), path, text, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { generation = g; setClean(cmEdit.isClean(g)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { close.setEnabled(true); } }); } }; }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), <START_MOD>project, <END_MOD>id.get(), side, line)); }
static void delete(com.google.gerrit.reviewdb.client.Change.Id id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteChange(id.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>com.google.gerrit.client.change.ChangeActions.mine(draftButtons)); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId<START_MOD>, project<END_MOD>)); }
@com.google.gwt.uibinder.client.UiHandler("followUp") void onFollowUp(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((followUpAction) == null) { followUpAction = new com.google.gerrit.client.change.FollowUpAction(followUp, <START_MOD>Project.NameKey.asStringOrNull(<END_MOD>project<START_MOD>)<END_MOD>, branch, topic, key); } followUpAction.show(); }
@com.google.gwt.uibinder.client.UiHandler("showBase") void onShowBase(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> e) { boolean shouldShow = e.getValue(); if (shouldShow) { if ((baseContent) == null) { com.google.gerrit.client.changes.ChangeEditApi.get(revision, <START_MOD>projectKey, <END_MOD>path, true, new com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> fc) { baseContent = fc; displayBase(); } @java.lang.Override public void onFailure(java.lang.Throwable e) { } }); } else { displayBase(); } } else { cmBase.getWrapperElement().getParentElement().addClassName(style.hideBase()); cmEdit.getWrapperElement().getParentElement().addClassName(style.fullWidth()); mv.getGapElement().addClassName(style.hideBase()); } mv.setShowDifferences(shouldShow); }
public static void publishEdit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("edit:publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi edit(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.change(id<START_MOD>, project<END_MOD>).view("edit"); }
public static void list(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.reviewdb.client.PatchSet.Id base<START_MOD>, java.lang.String project<END_MOD>, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(id<START_MOD>, project<END_MOD>).view("files"); if (base != null) { if ((base.get()) < 0) { api.addParameter("parent", (-(base.get()))); } else { api.addParameter("base", base.get()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacyId()<START_MOD>, result.projectNameKey()<END_MOD>)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static void abandon(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"abandon").post(input, cb); }
void loadRevisionInfo() { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.actions(changeId.get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), revision); call.background(); call.get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actionMap) { actionMap.copyKeysIntoChildren("id"); renderRevisionInfo(changeInfo, actionMap); } }); }
private void initEditMode(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); if (info.status().isOpen()) { if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); deleteFile.setVisible((!(editMode.isVisible()))); renameFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); addFileAction = new com.google.gerrit.client.change.AddFileAction(changeId, <START_MOD>project, <END_MOD>info.revision(revision), style, addFile, files); deleteFileAction = new com.google.gerrit.client.change.DeleteFileAction(changeId, <START_MOD>project, <END_MOD>info.revision(revision), style, addFile); renameFileAction = new com.google.gerrit.client.change.RenameFileAction(changeId, <START_MOD>project, <END_MOD>info.revision(revision), style, addFile); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } if (rev.isEdit()) { if (info.hasEditBasedOnCurrentPatchSet()) { publishEdit.setVisible(true); } else { rebaseEdit.setVisible(true); } deleteEdit.setVisible(true); } } else if (rev.isEdit()) { deleteEdit.setStyleName(style.highlight()); deleteEdit.setVisible(true); } } }
public static com.google.gerrit.client.rpc.RestApi revision(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { int cn = id.getParentKey().get(); java.lang.String revision = com.google.gerrit.client.changes.RevisionInfoCache.get(id); if (revision != null) { return ChangeApi.revision(cn, <START_MOD>project, <END_MOD>revision); } return ChangeApi.change(cn<START_MOD>, project<END_MOD>).view("revisions").id(id.get()); }
void set(com.google.gerrit.client.info.ChangeInfo info) { this.changeId = info.legacyId(); <START_MOD>this.project = info.projectNameKey(); <END_MOD>display(info); reviewerSuggestOracle.setChange(changeId<START_MOD>, project<END_MOD>); addReviewerIcon.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); }
@com.google.gwt.uibinder.client.UiHandler("restore") void onRestore(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((restoreAction) == null) { restoreAction = new com.google.gerrit.client.change.RestoreAction(restore, changeId<START_MOD>, project<END_MOD>); } restoreAction.show(); }
public static com.google.gerrit.client.rpc.RestApi change(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project) { if (project == null<END_MOD>) { return new com.google.gerrit.client.rpc.RestApi("/changes/").id(java.lang.String.valueOf(id)); }<START_MOD> else { return new com.google.gerrit.client.rpc.RestApi("/changes/").id(id, project); } }<END_MOD>
private static void patch(java.lang.String token, com.google.gerrit.client.DiffObject base, com.google.gerrit.reviewdb.client.Patch.Key id, <START_MOD>@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, <END_MOD>com.google.gerrit.client.diff.DisplaySide side, int line, java.lang.String panelType) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = ( <= c) ? token.substring((c + 1)) : ""; } if (("".equals(panel)) || ("cm".equals(panel))) { if (com.google.gerrit.client.Dispatcher.preferUnified()) { com.google.gerrit.client.Dispatcher.unified(token, base, id, <START_MOD>project, <END_MOD>side, line); } else { com.google.gerrit.client.Dispatcher.codemirror(token, base, id, <START_MOD>project, <END_MOD>side, line); } } else if ("sidebyside".equals(panel)) { com.google.gerrit.client.Dispatcher.codemirror(token, base, id, <START_MOD>project, <END_MOD>side, line); } else if ("unified".equals(panel)) { com.google.gerrit.client.Dispatcher.unified(token, base, id, <START_MOD>project, <END_MOD>side, line); } else if ("edit".equals(panel)) { if ((!(com.google.gerrit.reviewdb.client.Patch.isMagic(id.get()))) || (Patch.COMMIT_MSG.equals(id.get()))) { com.google.gerrit.client.Dispatcher.codemirrorForEdit(token, id, <START_MOD>project, <END_MOD>line); } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } }
private static void unified(final java.lang.String token, final com.google.gerrit.client.DiffObject base, final com.google.gerrit.reviewdb.client.Patch.Key id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), <START_MOD>project, <END_MOD>id.get(), side, line)); } }); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadComments(final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); com.google.gerrit.client.changes.ChangeApi.comments(changeId.get()<START_MOD>, Project.NameKey.asStringOrNull(project)<END_MOD>).get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(com.google.gerrit.client.change.ChangeScreen.filterForRevision(result, rev._number())); history.addComments(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); return r; }
void load(com.google.gerrit.client.rpc.CallbackGroup group) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.comments(base.asPatchSetId(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>group.add(publishedBase())); } com.google.gerrit.client.changes.CommentApi.comments(revision, <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>group.add(publishedRevision())); if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.drafts(base.asPatchSetId(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>group.add(draftsBase())); } com.google.gerrit.client.changes.CommentApi.drafts(revision, <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>group.add(draftsRevision())); } }
static void call(final com.google.gwt.user.client.ui.Button b, final <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey<END_MOD> project) { b.setEnabled(false); com.google.gerrit.client.changes.ChangeApi.createChange(project<START_MOD>.get()<END_MOD>, RefNames.REFS_CONFIG, null, AdminConstants.I.editConfigMessage(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), <START_MOD>project, <END_MOD>"project.config")); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); super.onFailure(caught); } }); }
public static void message(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, java.lang.String message, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.CherryPickInput input = com.google.gerrit.client.changes.ChangeApi.CherryPickInput.create(); input.setMessage(message); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>commit, "message").post(input, cb); }
@java.lang.Override protected void onRequestSuggestions(final com.google.gerrit.client.change.Request req, final com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.changes.ChangeApi.suggestReviewers(changeId.get(<START_MOD>), ((project) == null ? null : project.get()<END_MOD>), req.getQuery(), req.getLimit(), false).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo> result) { java.util.List<com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion> r = new java.util.ArrayList(result.length()); for (com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo reviewer : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion(reviewer, req.getQuery())); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { java.util.List<com.google.gerrit.client.change.Suggestion> r = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), <START_MOD>project, <END_MOD>"project.config")); }
public static void topic(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String topic, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"topic"); topic = com.google.gerrit.client.changes.ChangeApi.emptyToNull(topic); if (topic != null) { com.google.gerrit.client.changes.ChangeApi.TopicInput input = com.google.gerrit.client.changes.ChangeApi.TopicInput.create(); input.topic(topic); call.put(input, com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } else { call.delete(com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } }
public static void rebase(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, java.lang.String base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.RebaseInput rebaseInput = com.google.gerrit.client.changes.ChangeApi.RebaseInput.create(); rebaseInput.setBase(base); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>commit, "rebase").post(rebaseInput, cb); }
public static com.google.gerrit.client.rpc.RestApi hashtags(int changeId<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.change(changeId<START_MOD>, project<END_MOD>).view("hashtags"); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeApi.topic(psId.getParentKey().get(<START_MOD>), Project.NameKey.asStringOrNull(project<END_MOD>), input.getValue().trim(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId)); } }); onCancel(null); }
void onReply(com.google.gerrit.client.info.ChangeInfo.MessageInfo msg) { if ((popup) != null) { popup.hide(); return; } if ((replyBox) == null) { replyBox = new com.google.gerrit.client.change.ReplyBox(clp, psId<START_MOD>, project<END_MOD>, revision, allLabels, permittedLabels); allLabels = null; permittedLabels = null; } if (msg != null) { replyBox.replyTo(msg); } final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true, false); p.setStyleName(style.replyBox()); p.addAutoHidePartner(replyButton.getElement()); p.addAutoHidePartner(quickApproveButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; if ((hasDraftComments) || (replyBox.hasMessage())) { replyButton.setStyleName(style.highlight()); } } } }); p.add(replyBox); com.google.gwt.user.client.Window.scrollTo(0, 0); replyButton.removeStyleName(style.highlight()); p.showRelativeTo(replyButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); popup = p; }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revision, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(change.legacyId().get(), <START_MOD>change.project(), <END_MOD>revision.name()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.RevisionGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(revision); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), <START_MOD>project, <END_MOD>id.get(), side, line)); }
public static com.google.gerrit.client.diff.DiffApi diff(com.google.gerrit.reviewdb.client.PatchSet.Id id<START_MOD>, java.lang.String project<END_MOD>, java.lang.String path) { return new com.google.gerrit.client.diff.DiffApi(com.google.gerrit.client.changes.ChangeApi.revision(id<START_MOD>, project<END_MOD>).view("files").id(path).view("diff")); }
public static com.google.gerrit.client.rpc.RestApi detail(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"detail"); }
public static void publish(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>commit, "publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi comments(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.call(id, <START_MOD>project, <END_MOD>"comments"); }
private void loadFileList(final com.google.gerrit.client.DiffObject base, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, final java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts) { com.google.gerrit.client.diff.DiffApi.list(changeId.get(), <START_MOD>Project.NameKey.asStringOrNull(project), <END_MOD>rev.name(), baseRev, group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), <START_MOD>project, <END_MOD>style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { files.showError(caught); } })); }
public void setChange(com.google.gerrit.reviewdb.client.Change.Id changeId<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>) { this.changeId = changeId; <START_MOD>this.project = project; <END_MOD>}
@com.google.gwt.uibinder.client.UiHandler("unmarkPrivate") void onUnmarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.unmarkPrivate(changeId, <START_MOD>project, <END_MOD>unmarkPrivate); }
@com.google.gwt.uibinder.client.UiHandler("deleteChange") void onDeleteChange(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChange())) { com.google.gerrit.client.change.ChangeActions.delete(changeId, <START_MOD>project, <END_MOD>deleteChange); } }
@com.google.gwt.uibinder.client.UiHandler("markPrivate") void onMarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.markPrivate(changeId, <START_MOD>project, <END_MOD>markPrivate); }
public static void list(int id<START_MOD>, java.lang.String project<END_MOD>, java.lang.String revision, com.google.gerrit.client.info.ChangeInfo.RevisionInfo base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(id, <START_MOD>project, <END_MOD>revision).view("files"); if (base != null) { if ((base._number()) < 0) { api.addParameter("parent", (-(base._number()))); } else { api.addParameter("base", base.name()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSuccess(final com.google.gerrit.client.info.ChangeInfo info) { info.init();<START_MOD> if ((project) == null) { project = info.projectNameKey(); }<END_MOD> initCurrentRevision(info); final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { if ((base.isBase()) && (rev.isMerge())) { base = com.google.gerrit.client.DiffObject.parse(info.legacyId(), com.google.gerrit.client.Gerrit.getUserPreferences().defaultBaseForMerges().getBase()); } loadConfigInfo(info, base); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> mAr = info.messages(); for (int i = 0; i < (mAr.length()); i++) { if ((mAr.get(i).tag()) != null) { hideTaggedComments.setVisible(true); break; } } } }); group.done(); }
public static java.lang.String toPatch(java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.Patch.Key id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>) { return com.google.gerrit.client.Dispatcher.toPatch(type, diffBase, id.getParentKey(), <START_MOD>project, <END_MOD>id.get(), null, 0); }
private static void codemirrorForEdit(final java.lang.String token, final com.google.gerrit.reviewdb.client.Patch.Key id<START_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project<END_MOD>, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(id, <START_MOD>project, <END_MOD>line)); } }); }
public static com.google.gerrit.client.rpc.RestApi editWithCommands(int id<START_MOD>, @com.google.gerrit.common.Nullable java.lang.String project<END_MOD>) { return com.google.gerrit.client.changes.ChangeApi.edit(id<START_MOD>, project<END_MOD>).addParameterTrue("download-commands"); }
private void upToChange() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey()<START_MOD>, projectKey<END_MOD>)); }
private boolean handlePolyGerritParam(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { if (!(options.enableGwtUi())) { return false; } boolean redirect = false; <START_MOD>if (req.getMethod().equals("GET")) { <END_MOD>java.lang.String param = req.getParameter("polygerrit"); if ("1".equals(param)) { setPolyGerritCookie(req, res, UiType.POLYGERRIT); redirect = true; } else if ("0".equals(param)) { setPolyGerritCookie(req, res, UiType.GWT); redirect = true; } <START_MOD>} <END_MOD>if (redirect) { res.sendRedirect(req.getRequestURL().toString()); } return redirect; }
void addFile(java.lang.String dirPath, java.lang.String filePath, java.lang.String[] lines) { com.googlesource.gerrit.plugins.findowners.Parser.Result result = com.googlesource.gerrit.plugins.findowners.Parser.parseFile(dirPath, filePath, lines); if (result.stopLooking) { stopLooking.add(dirPath); } for (java.lang.String owner : result.owner2paths.keySet()) { <START_MOD>java.lang.String email = getPreferredEmail(owner); <END_MOD>for (java.lang.String path : result.owner2paths.get(owner)) { addOwnerPathPair(<START_MOD>email<END_MOD>, path); } } if (com.googlesource.gerrit.plugins.findowners.Config.getReportSyntaxError()) { result.warnings.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.warn(w)); result.errors.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error(w)); } }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(<START_MOD>com.google.gerrit.server.account.AccountByEmailCache accountByEmailCache, com.google.gerrit.server.account.AccountCache accountCache, <END_MOD>org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { return get(<START_MOD>accountByEmailCache, accountCache, <END_MOD>repo, changeData, changeData.currentPatchSet().getId().get()); }
@java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(( new OwnersDb, key= + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(<START_MOD>accountByEmailCache, accountCache, <END_MOD>key, repository, project, branch, files); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(<START_MOD>com.google.gerrit.server.account.AccountByEmailCache accountByEmailCache, com.google.gerrit.server.account.AccountCache accountCache, <END_MOD>org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.query.change.ChangeData changeData, int patchset) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change().getProject(); java.lang.String branch = changeData.change().getDest().get(); java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey(changeData.getId().get(), patchset, branch); return get(<START_MOD>accountByEmailCache, accountCache, <END_MOD>dbKey, repository, project, branch, changeData.currentFilePaths()); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(<START_MOD>com.google.gerrit.server.account.AccountByEmailCache accountByEmailCache, com.google.gerrit.server.account.AccountCache accountCache, <END_MOD>java.lang.String key, org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch, java.util.Collection<java.lang.String> files) { if ((dbCache) == null) { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(( new OwnersDb, key= + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(<START_MOD>accountByEmailCache, accountCache, <END_MOD>key, repository, project, branch, files); } try { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(((((( from cash   + (dbCache)) +   key= + key) +   cache size= + (dbCache.size()))); return dbCache.get(key, new java.util.concurrent.Callable<com.googlesource.gerrit.plugins.findowners.OwnersDb>() { @java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(( new OwnersDb, key= + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(<START_MOD>accountByEmailCache, accountCache, <END_MOD>key, repository, project, branch, files); } }); } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.findowners.Cache.log.error(( has exception:   + e)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(<START_MOD>accountByEmailCache, accountCache, <END_MOD>key, repository, project, branch, files); } }
@org.junit.Test public void actionApplyTest() throws java.lang.Exception { com.googlesource.gerrit.plugins.findowners.Cache cache = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().init(0, 10); assertThat(cache.size()).isEqualTo(0); com.google.gerrit.extensions.common.ChangeInfo changeInfo = newChangeInfo( Action.apply com.google.gerrit.server.change.ChangeResource cr = parseChangeResource(changeInfo.changeId); com.googlesource.gerrit.plugins.findowners.Action.Parameters param = new com.googlesource.gerrit.plugins.findowners.Action.Parameters(); com.googlesource.gerrit.plugins.findowners.Action action = new com.googlesource.gerrit.plugins.findowners.Action("find-owners", null, null, null, changeDataFactory, <START_MOD>accountByEmailCache, <END_MOD>accountCache, repoManager); com.google.gerrit.extensions.restapi.Response<com.googlesource.gerrit.plugins.findowners.RestResult> response = action.apply(db, cr, param); com.googlesource.gerrit.plugins.findowners.RestResult result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, false); param.debug = true; response = action.apply(db, cr, param); result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, true); assertThat(result.dbgmsgs.user).isEqualTo("?"); assertThat(result.dbgmsgs.project).isEqualTo(changeInfo.project); assertThat(result.dbgmsgs.branch).contains(changeInfo.branch); assertThat(result.dbgmsgs.path2owners).isEmpty(); assertThat(result.dbgmsgs.owner2paths).isEmpty(); assertThat(result.file2owners).isEmpty(); assertThat(result.reviewers).isEmpty(); assertThat(result.owners).isEmpty(); assertThat(result.files).isEmpty(); assertThat(cache.size()).isEqualTo(0); }
int findApproval(com.google.gerrit.server.account.<START_MOD>AccountByEmailCache accountByEmailCache, com.google.gerrit.server.account.<END_MOD>AccountCache accountCache) throws com.google.gwtorm.server.OrmException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExemptFromOwnerApproval(changeData)) { return 0; } com.googlesource.gerrit.plugins.findowners.OwnersDb db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(<START_MOD>accountByEmailCache, accountCache, <END_MOD>repository, changeData); if ((db.getNumOwners()) <= 0) { return 0; } if ((minVoteLevel) <= 0) { minVoteLevel = com.googlesource.gerrit.plugins.findowners.Config.getMinOwnerVoteLevel(changeData); } com.googlesource.gerrit.plugins.findowners.Checker.log.trace(( db key =   + (db.key))); return findApproval(accountCache, db); }
public static int findApproval(com.googlecode.prolog_cafe.lang.Prolog engine, int minVoteLevel) { try { com.google.gerrit.server.account.<START_MOD>AccountByEmailCache accountByEmailCache = StoredValues.ACCOUNT_BY_EMAIL_CACHE.get(engine); com.google.gerrit.server.account.<END_MOD>AccountCache accountCache = StoredValues.ACCOUNT_CACHE.get(engine); com.google.gerrit.server.query.change.ChangeData changeData = StoredValues.CHANGE_DATA.get(engine); org.eclipse.jgit.lib.Repository repository = StoredValues.REPOSITORY.get(engine); return new com.googlesource.gerrit.plugins.findowners.Checker(repository, changeData, minVoteLevel).findApproval(<START_MOD>accountByEmailCache, <END_MOD>accountCache); } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.findowners.Checker.log.error("Exception", e); return 0; } }
<START_MOD>java.lang.String getPreferredEmail(java.lang.String owner) { java.lang.String email = preferredEmails.get(owner); if (email == null) { email = owner; if (!(owner.equals("*"))) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> ids = accountByEmailCache.get(owner); if ((ids == null) || ((ids.size()) != 1)) { errors.add(owner); } else { email = accountCache.get(ids.iterator().next()).getAccount().getPreferredEmail(); } } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error(("Fail to find preferred email of " + owner), e); errors.add(owner); } } preferredEmails.put(owner, email); } return email; }<END_MOD>
<START_MOD>public static java.lang.String nameOf(java.lang.String name) { if (name.endsWith(".disabled")) { name = name.substring(0, name.lastIndexOf('.')); } int ext = name.lastIndexOf('.'); return 0 < ext ? name.substring(0, ext) : name; }<END_MOD>
<START_MOD>public static java.util.List<java.nio.file.Path> listPlugins(java.nio.file.Path pluginsDir) throws java.io.IOException { return com.google.gerrit.server.plugins.PluginUtil.listPlugins(pluginsDir, null); }<END_MOD>
<START_MOD>private java.lang.Integer parseRevertOf(com.google.gerrit.server.notedb.ChangeNotesCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String footer = parseOneFooter(commit, com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_REVERT_OF); if (footer == null) { return null; } return com.google.common.primitives.Ints.tryParse(footer); }<END_MOD>
<START_MOD>@org.junit.Test public void setRevertOfPersistsValue() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.reviewdb.client.Change changeToRevert = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setRevertOf(changeToRevert.getChangeId()); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertThat(notes.getRevertOf()).isEqualTo(changeToRevert.getId()); }<END_MOD>
<START_MOD>@org.junit.Test public void setRevertOfToCurrentChangeFails() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); exception.expect(java.lang.IllegalArgumentException.class); exception.expectMessage("A change cannot revert itself."); update.setRevertOf(c.getId().get()); }<END_MOD>
<START_MOD>public void setRevertOf(int revertOf) { int ownId = getChange().getId().get(); checkArgument((ownId != revertOf), "A change cannot revert itself."); this.revertOf = revertOf; }<END_MOD>
private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(tip.copy(), id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, ((assignee) != null ? assignee.orElse(null) : null), status, com.google.common.collect.Sets.newLinkedHashSet(com.google.common.collect.Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), com.google.gerrit.server.ReviewerByEmailSet.fromTable(com.google.common.collect.Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted<START_MOD>, ((revertOf) != null ? new com.google.gerrit.reviewdb.client.Change.Id(revertOf) : null)<END_MOD>); }
@org.junit.Test public void revert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit(); ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get(); java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> sourceMessages = new java.util.ArrayList(gApi.changes().id(r.getChangeId()).get().messages); assertThat(sourceMessages).hasSize(4); java.lang.String expectedMessage = java.lang.String.format( a revert of this change as %s revertChange.changeId); assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage); assertThat(revertChange.messages).hasSize(1); assertThat(revertChange.messages.iterator().next().message).isEqualTo( patch set 1. <START_MOD>assertThat(revertChange.revertOf).isEqualTo(r.getChange().getId().get()); <END_MOD>}
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "plugins.allowRemoteAdmin", value = "true") public void pluginManagement() throws java.lang.Exception { assertThat(list().get()).isEmpty(); assertThat(list().all().get()).isEmpty(); com.google.gerrit.extensions.api.plugins.PluginApi test; com.google.gerrit.extensions.common.PluginInfo info; com.google.gerrit.extensions.common.InstallPluginInput input = new com.google.gerrit.extensions.common.InstallPluginInput(); input.raw = com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.api.plugin.PluginIT.JS_PLUGIN_CONTENT); for (java.lang.String plugin : com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS) { test = gApi.plugins().install((plugin + ".js"), input); assertThat(test).isNotNull(); info = test.get(); assertThat(info.id).isEqualTo(plugin); assertThat(info.disabled).isNull(); } assertThat(list().get()).hasSize(com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.size()); test = gApi.plugins().name("plugin-a"); test.disable(); test = gApi.plugins().name("plugin-a"); info = test.get(); assertThat(info.disabled).isTrue(); assertThat(list().get()).hasSize(((com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.size()) - 1)); assertThat(list().all().get()).hasSize(com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.size()); test.enable(); test = gApi.plugins().name("plugin-a"); info = test.get(); assertThat(info.disabled).isNull(); assertThat(list().get()).hasSize(com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.size()); }<END_MOD>
public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> display(@com.google.gerrit.common.Nullable java.io.PrintWriter stdout) { java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); <START_MOD>com.google.common.collect.FluentIterable<com.google.gerrit.server.plugins.Plugin> iterable = com.google.common.collect.FluentIterable.from(pluginLoader.getPlugins(all)); <END_MOD>java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = <START_MOD>iterable.toSortedList(<END_MOD>com.google.gerrit.server.plugins.<START_MOD>ListPlugins.COMPARATOR<END_MOD>); if (!(format.isJson())) { stdout.format( %-10s %-8s %s "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format( %-10s %-8s %s p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return output; } else if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }
public com.google.gerrit.server.update.BatchUpdate create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.CurrentUser user, java.sql.Timestamp when) { if (migration.disableChangeReviewDb()) { return fusedNoteDbBatchUpdateFactory.create(db, project, user, when); } return reviewDbBatchUpdateFactory.create(db, project, user, when); }
private void setChangeId(int id) { changeId = new com.google.gerrit.reviewdb.client.Change.Id(id); ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(<START_MOD>((receiveConfig.privateByDefault) || (<END_MOD>magicBranch.isPrivate)<START_MOD>))<END_MOD>.setWorkInProgress(magicBranch.workInProgress).setValidate(false); if (magicBranch.draft) { ins.setDraft(magicBranch.draft); } else if (magicBranch.merged) { ins.setStatus(Change.Status.MERGED); } cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName()); if ((rp.getPushCertificate()) != null) { ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature()); } }
<START_MOD>@org.junit.Test public void pushWithPrivateByDefaultEnabled() throws java.lang.Exception { assume().that(isPrivateByDefault()).isTrue(); assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true); }<END_MOD>
<START_MOD>@com.google.gerrit.testutil.ConfigSuite.Config public static org.eclipse.jgit.lib.Config privateByDefaultEnabled() { return privateByDefaultEnabledConfig(); }<END_MOD>
<START_MOD>@org.junit.Test public void createChangeWithPrivateByDefaultDisabled() throws java.lang.Exception { assume().that(isPrivateByDefault()).isFalse(); com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().create(new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change")).get(); assertThat(info.isPrivate).isNull(); }<END_MOD>
<START_MOD>@org.junit.Test public void createChangeWithPrivateByDefaultEnabled() throws java.lang.Exception { assume().that(isPrivateByDefault()).isTrue(); com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().create(new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change")).get(); assertThat(info.isPrivate).isEqualTo(true); }<END_MOD>
<START_MOD>@org.junit.Test public void pushWithPrivateByDefaultDisabled() throws java.lang.Exception { assume().that(isPrivateByDefault()).isFalse(); assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false); }<END_MOD>
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(user, id.substring(0, z), n.intValue()); } } <START_MOD>if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id, 10); if (n != null) { return find(new com.google.gerrit.reviewdb.client.Change.Id(n), user); } } <END_MOD>com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeControls(query.byBranchKey(t.branch(), t.id()), user); } } return asChangeControls(query.<START_MOD>byKeyPrefix(id<END_MOD>), user); }
boolean isMergedIntoVisibleRef(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Collection<org.eclipse.jgit.lib.Ref> unfilteredRefs) throws java.io.IOException { com.google.gerrit.server.git.VisibleRefFilter filter = refFilter.create(state, repo); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> m = com.google.common.collect.Maps.newHashMapWithExpectedSize(unfilteredRefs.size()); for (org.eclipse.jgit.lib.Ref r : unfilteredRefs) { m.put(r.getName(), r); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = filter.filter(m, true); return (!(refs.isEmpty())) && (com.google.gerrit.server.change.IncludedInResolver.<START_MOD>includedInAny<END_MOD>(repo, rw, commit, refs.values())); }
public com.google.gerrit.common.EventListener getEventListener()<START_MOD>;<END_MOD>
<START_MOD>public void removeGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> foundGroup = groups.get(db, groupUuid); if (!(foundGroup.isPresent())) { return; } com.google.gerrit.reviewdb.client.AccountGroup group = foundGroup.get(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> existingMembers = groups.getMembers(db, group.getId()).collect(toImmutableSet()); com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = accountIds.stream().distinct().filter(existingMembers::contains).map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableList()); if ((currentUser) != null) { auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), membersToRemove); } db.accountGroupMembers().delete(membersToRemove); for (com.google.gerrit.reviewdb.client.AccountGroupMember member : membersToRemove) { accountCache.evict(member.getAccountId()); } }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.accounts.AccountInput input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.<START_MOD>ResourceNotFoundException, com.google.gerrit.extensions.restapi.<END_MOD>UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply((input != null ? input : new com.google.gerrit.extensions.api.accounts.AccountInput())); }
<START_MOD>public java.util.stream.Stream<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getParentGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID childGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> accountGroupByIds = db.accountGroupById().byIncludeUUID(childGroupUuid); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.Id> foundParentGroupIds = com.google.common.collect.Streams.stream(accountGroupByIds).map(AccountGroupById::getGroupId).collect(toImmutableSet()); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> existingParentGroups = db.accountGroups().get(foundParentGroupIds); return com.google.common.collect.Streams.stream(existingParentGroups).map(AccountGroup::getGroupUUID); }<END_MOD>
private boolean isMember(com.google.gerrit.reviewdb.client.AccountGroup parent, com.google.gerrit.common.data.GroupDescription.Basic member) throws com.google.gwtorm.server.OrmException { return <START_MOD>groups.isMember<END_MOD>(dbProvider.get()<START_MOD>,<END_MOD> parent.getId(), member.getGroupUUID()); }
<START_MOD>public boolean isMember(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentId, com.google.gerrit.reviewdb.client.AccountGroup.UUID childGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentId, childGroupUuid); return (db.accountGroupById().get(key)) != null; }<END_MOD>
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>common.collect.ImmutableSet<END_MOD><com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> getIncludes() { return includes; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutOwner.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((resource.toAccountGroup()) == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( group owner } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( is required } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); <START_MOD>com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = resource.getGroupUUID(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, ( group) -> group.setOwnerGroupUUID(owner.getGroupUUID())); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(<END_MOD>java.<START_MOD>lang.String.format( %s not found groupUuid)<END_MOD>); } return json.format(owner); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutDescription.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.group.PutDescription.Input(); } if ((resource.toAccountGroup()) == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( group owner } java.lang.String newDescription = com.google.common.base.Strings.emptyToNull(input.description); com.google.gerrit.reviewdb.client.AccountGroup<START_MOD>.UUID groupUuid<END_MOD> = <START_MOD>resource.getGroupUUID(); try { <END_MOD>groupsUpdateProvider.get().updateGroup(db.get(), <START_MOD>groupUuid<END_MOD>, ( group) -> group.setDescription(newDescription)); <START_MOD>} catch (com.google.gerrit.common.errors.NoSuchGroupException e<END_MOD>) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(<START_MOD>java.lang.String.format( %s not found groupUuid)<END_MOD>); } return com.google.common.base.Strings.isNullOrEmpty(input.description) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(input.description); }
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>common.collect.ImmutableSet<END_MOD><com.google.gerrit.reviewdb.client.<START_MOD>Account.Id<END_MOD>> getMembers() { return members; }
public java.util.stream.Stream<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getParentGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID <START_MOD>includedGroupUuid<END_MOD>) throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> accountGroupByIds = db.accountGroupById().byIncludeUUID(<START_MOD>includedGroupUuid<END_MOD>); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.Id> foundParentGroupIds = com.google.common.collect.Streams.stream(accountGroupByIds).map(AccountGroupById::getGroupId).collect(toImmutableSet()); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> existingParentGroups = db.accountGroups().get(foundParentGroupIds); return com.google.common.collect.Streams.stream(existingParentGroups).map(AccountGroup::getGroupUUID); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { <START_MOD>return groups<END_MOD>.<START_MOD>getParentGroups(db,<END_MOD> <START_MOD>key<END_MOD>).<START_MOD>collect<END_MOD>(<START_MOD>toImmutableList<END_MOD>()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup internalGroup = resource.toAccountGroup(); if (internalGroup == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } input = com.google.gerrit.server.group.AddMembers.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); <START_MOD>if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(( delete any members from group   + (resource.getName()))); } com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = com.google.common.collect.ImmutableSet.builder(); for (<END_MOD>java.<START_MOD>lang.String nameOrEmail : input.members) { <END_MOD>com.google.gerrit.reviewdb.client.Account<START_MOD> a<END_MOD> = <START_MOD>accounts.parse(nameOrEmail).getAccount(); membersToRemove.add(a.getId()); } groupsUpdateProvider.get().removeGroupMembers(db.get(), <END_MOD>internalGroup.<START_MOD>getGroupUUID(), membersToRemove.build()); return com.google.gerrit.extensions.restapi.Response.none(<END_MOD>); }
private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } args.groups.getMembers(db, ig.<START_MOD>getGroupUUID<END_MOD>()).forEachOrdered(matching.accounts::add); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) { if (seen.add(m)) { q.add(m); } } } }
<START_MOD>public com.google.gerrit.reviewdb.client.AccountGroup getGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName accountGroupName = db.accountGroupNames().get(groupName); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = accountGroupName.getId(); return db.accountGroups().get(groupId); }<END_MOD>
<START_MOD>public void addGroupMember(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { db.accountGroupMembers().insert(com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)))); }<END_MOD>
private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } <START_MOD>args.groups.getMembers(db, ig.getId()).forEachOrdered(matching.accounts::add); <END_MOD>for (com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD> m : <START_MOD>args.groupIncludes.subgroupsOf(uuid)) { if (seen<END_MOD>.add(m<START_MOD>)) { q.add(<END_MOD>m<START_MOD>); } } } }<END_MOD>
<START_MOD>private void addGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup group, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> existingMembers = groups.getMembers(db, group.getId()).collect(toImmutableSet()); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroupMember> newMembers = accountIds.stream().distinct().filter(( id) -> !(existingMembers.contains(id))).map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableList()); if ((currentUser) != null) { auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers); } db.accountGroupMembers().insert(newMembers); for (com.google.gerrit.reviewdb.client.AccountGroupMember newMember : newMembers) { accountCache.evict(newMember.getAccountId()); } }<END_MOD>
<START_MOD>public void addGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup group) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName gn = new com.google.gerrit.reviewdb.client.AccountGroupName(group); db.accountGroupNames().insert(java.util.Collections.singleton(gn)); db.accountGroups().insert(java.util.Collections.singleton(group)); }<END_MOD>
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> conflicts(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { <START_MOD>java.util.List<com.google.gerrit.reviewdb.client.Change> changes = parseChange(value); if ((changes.size()) == 1) { <END_MOD>return <START_MOD>com.google.gerrit.server.query.change.ConflictsPredicate.create(args, value, changes.get(0)); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> or = <END_MOD>new <START_MOD>java.util.ArrayList(changes.size()); for (com.google.gerrit.reviewdb.client.Change c : changes) { or.add(<END_MOD>com.google.gerrit.server.query.change.ConflictsPredicate<START_MOD>.create<END_MOD>(args, value, <START_MOD>c<END_MOD>)); }<START_MOD> return com.google.gerrit.server.query.Predicate.or(or); }<END_MOD>
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( %s not found id.get())); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.StarredChanges.log.error( resolve change e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( server error } <START_MOD>catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error( test permissions for change e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( server error } }<END_MOD>
public void addChange(java.lang.String id, java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeResource> changes, com.google.gerrit.server.project.ProjectControl projectControl, boolean useIndex) throws com.google.gerrit.<START_MOD>server.permissions.PermissionBackendException, com.google.gerrit.<END_MOD>sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> matched = (useIndex) ? changeFinder.find(id, currentUser) : changeFromNotesFactory(id, currentUser); java.util.List<com.google.gerrit.server.project.ChangeControl> toAdd = new java.util.ArrayList(changes.size()); boolean canMaintainServer; try { permissionBackend.user(currentUser).check(GlobalPermission.MAINTAIN_SERVER); canMaintainServer = true; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { canMaintainServer = false; } for (com.google.gerrit.server.project.ChangeControl ctl : matched) { if (((!(changes.containsKey(ctl.getId()))) && (inProject(projectControl, ctl.getProject()))) && (canMaintainServer || (<START_MOD>permissionBackend.user(currentUser).change(ctl.getNotes()).test(ChangePermission.READ<END_MOD>)))) { toAdd.add(ctl); } } if (toAdd.isEmpty()) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) +   no such change } else if ((toAdd.size()) > 1) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) +   matches multiple changes } com.google.gerrit.server.project.ChangeControl ctl = toAdd.get(0); changes.put(ctl.getId(), changesCollection.parse(ctl)); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } <START_MOD>com.google.gerrit.reviewdb.client.Change change; <END_MOD>try { <START_MOD>change<END_MOD> = cd.change(); if (<START_MOD>change<END_MOD> == null) { return false; } <START_MOD>} catch (com.google.gerrit.server.project.NoSuchChangeException e) { return false; } <END_MOD>com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(<START_MOD>change<END_MOD>); com.google.gerrit.server.project.ChangeControl cc = changeControl.controlFor(notes, user); <START_MOD>boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { for (java.lang.Throwable t : com.google.common.base.Throwables.getCausalChain(e)) { <END_MOD>if (<START_MOD>t instanceof com.google.gwtorm.server.OrmException) { throw ((com.google.gwtorm.server.OrmException) (t)); } } throw new com.google.gwtorm.server.OrmException( to check permissions e); } if (visible) { cd.cacheVisibleTo(<END_MOD>cc); return true; } return false; }
private boolean canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { if (canUpdate()) { return true; } else if (<START_MOD>projectControl.isReachableFromHeadsOrTags<END_MOD>(repo, commit)) { return true; } return false; }
<START_MOD>public boolean isReachableFrom(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { refs = refFilter.create(state, repo).filter(refs, true); return (!(refs.isEmpty())) && (com.google.gerrit.server.change.IncludedInResolver.includedInOne(repo, rw, commit, refs.values())); } catch (java.io.IOException e) { com.google.gerrit.server.project.CommitsCollection.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e); return false; } }<END_MOD>
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.<START_MOD>gerrit.server.permissions.PermissionBackendException, com.google.<END_MOD>gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id.encoded(), user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(<START_MOD>permissionBackend.user(user).change(<END_MOD>ctl.<START_MOD>getNotes()).database<END_MOD>(db<START_MOD>).test(ChangePermission.READ<END_MOD>))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(ctl); }
<START_MOD>public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getProject().getNameKey(); try { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(user).database(db); java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().byProjectCommit(project, commit); if (!(perm.filterChangeData(ChangePermission.READ, changes).isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot look up change for commit " + (commit.name())) + " in ") + project), e); } return isReachableFrom(state, repo, commit, repo.getAllRefs()); }<END_MOD>
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.<START_MOD>gerrit.server.permissions.PermissionBackendException, com.google.<END_MOD>gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id, user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(<START_MOD>permissionBackend.user(user).change(<END_MOD>ctl.<START_MOD>getNotes()).database<END_MOD>(db<START_MOD>).test(ChangePermission.READ<END_MOD>))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(ctl); }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId extId = findExternalId(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException(((   + (who.getExternalIdKey().get())) +   in use by another account } externalIdsUpdateFactory.create().delete(extId); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = accounts.get(db, from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); accountsUpdateFactory.create().update(db, a); } <START_MOD>byIdCache<END_MOD>.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException(((   + (who.getExternalIdKey().get())) +   not found } return new com.google.gerrit.server.account.AuthResult(from, who.getExternalIdKey(), false); } }
@org.junit.Test public void <START_MOD>lookUpByEmail<END_MOD>() throws java.lang.Exception { assertEmail(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); accountCache.evict(admin.id); assertEmail(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(email), admin); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>("non-existing@example.com")).isEmpty(); }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId extId = findExternalId(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException( in use by another account } update(db, who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = accounts.get(db, to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); accountsUpdateFactory.create().update(db, a); } } <START_MOD>byIdCache<END_MOD>.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); } }
@org.junit.Test public void <START_MOD>lookUpByEmail<END_MOD>() throws java.lang.Exception { assertEmail(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(email), admin); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(<START_MOD>accounts<END_MOD>.<START_MOD>byEmail<END_MOD>("non-existing@example.com")).isEmpty(); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> oldRefs = rp.getAdvertisedRefs(); <START_MOD>checkState(<END_MOD>(oldRefs <START_MOD>!=<END_MOD> null)<START_MOD>,<END_MOD>   <START_MOD>refs<END_MOD> <START_MOD>to<END_MOD> <START_MOD>previously<END_MOD> <START_MOD>be advertised; %s assumes it is not the first %s in the chain getClass<END_MOD>().<START_MOD>getSimpleName<END_MOD>()<START_MOD>,<END_MOD> org.eclipse.jgit.transport.<START_MOD>AdvertiseRefsHook<END_MOD>.<START_MOD>class<END_MOD>.<START_MOD>getSimpleName<END_MOD>()); com.google.gerrit.server.git.receive.ReceiveCommitsAdvertiseRefsHook.Result r = advertiseRefs(oldRefs); rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves()); }
private void showDoc(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, com.google.gitiles.GitilesView view, com.google.gitiles.doc.MarkdownConfig cfg, com.google.gitiles.doc.MarkdownToHtml.Builder fmt, com.google.gitiles.doc.DocServlet.MarkdownFile navFile, com.google.gitiles.doc.DocServlet.MarkdownFile srcFile) throws java.io.IOException { java.util.Map<java.lang.String, java.lang.Object> data = new java.util.HashMap<>(); data.putAll(buildNavbar(cfg, fmt, navFile)); org.commonmark.node.Node doc = com.google.gitiles.doc.GitilesMarkdown.parse(cfg, srcFile.consumeContent()); data.put("pageTitle", com.google.gitiles.doc.DocServlet.pageTitle(doc, srcFile)); if ((view.getType()) != (GitilesView.Type.ROOTED_DOC)) { data.put("sourceUrl", com.google.gitiles.GitilesView.show().copyFrom(view).toUrl()); data.put("logUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl()); data.put("blameUrl", com.google.gitiles.GitilesView.blame().copyFrom(view).toUrl()); } if ((cfg.analyticsId) != null) { data.put("analyticsId", cfg.analyticsId); } <START_MOD>fmt.setFilePath(srcFile.path); <END_MOD>try (java.io.OutputStream out = startRenderCompressedStreamingHtml(req, res, com.google.gitiles.doc.DocServlet.SOY_TEMPLATE, data)) { java.io.Writer w = newWriter(out, res); <START_MOD>createMarkdownToHtml(<END_MOD>fmt).renderToHtml(new com.google.gitiles.doc.html.StreamHtmlBuilder(w), doc); w.flush(); } catch (com.google.gitiles.doc.RuntimeIOException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); throw e; } }
<START_MOD>@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.lang.Exception { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.getDestBranch().equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.repo.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.getDestBranch()); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.Utils.readBlob(srcRepo, ((srcRef + ":") + (c.getXmlPath())))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.isRecordSubmoduleLabels()).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setTargetURI(c.getDestRepoKey().toString()).setURI(c.getBaseUri().toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.repo.RepoUpdater.GerritIncludeReader(srcRepo, srcRef)); cmd.call(); }<END_MOD>
@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.<START_MOD>ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { com.googlesource.gerrit.plugins.supermanifest.SubModuleUpdater subModuleUpdater = c.getSubModuleUpdater(serverIdent, canonicalWebUrl); try (com.googlesource.gerrit.plugins.supermanifest.<END_MOD>SuperManifestRefUpdatedListener.<START_MOD>GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { subModuleUpdater.update(reader, c, <END_MOD>event.getRefName())<START_MOD>; }<END_MOD> } catch (java.<START_MOD>lang.Exception<END_MOD> e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); <START_MOD>java.io.StringWriter sw = new java.io.StringWriter(); java.io.PrintWriter pw = new java.io.PrintWriter(sw); e.printStackTrace(pw); <END_MOD>error( for %s (ref %s) failed: %s c.toString(), event.getRefName(), <START_MOD>sw); } } }<END_MOD>
<START_MOD>public java.lang.String getToolType() { return toolType; }<END_MOD>
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup( group for schema migration setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.server.schema.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
<START_MOD>@java.lang.Override public void pruneSchema(com.google.gwtorm.server.StatementExecutor e, java.util.List<java.lang.String> pruneList) throws com.google.gwtorm.server.OrmException { }<END_MOD>
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup( for schema migration setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.server.schema.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isAtLeast(testStartTime); }
<START_MOD>@java.lang.Override public boolean isBatch() { return false; }<END_MOD>
<START_MOD>@org.junit.Before public void setUp() throws java.lang.Exception { com.google.inject.Injector injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testutil.InMemoryModule()); injector.injectMembers(this); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); lifecycle.start(); try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); com.google.gerrit.reviewdb.client.Account.Id userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); com.google.gerrit.server.IdentifiedUser user = userFactory.create(userId); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getUser() { return user; } @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } }); }<END_MOD>
<START_MOD>@java.lang.Override public boolean yesno(boolean def, java.lang.String msg) { return false; }<END_MOD>
<START_MOD>@org.junit.After public void tearDown() { if ((lifecycle) != null) { lifecycle.stop(); } requestContext.setContext(null); if ((db) != null) { db.close(); } com.google.gerrit.testutil.InMemoryDatabase.drop(inMemoryDatabase); }<END_MOD>
<START_MOD>public com.google.gerrit.server.update.RetryHelper.Options.Builder timeout(long timeout, java.util.concurrent.TimeUnit unit) { return timeoutMs(unit.toMillis(timeout)); }<END_MOD>
<START_MOD>@com.google.gerrit.common.Nullable abstract java.lang.Long timeoutMs();<END_MOD>
<START_MOD>public com.google.gerrit.server.update.RetryHelper.Options build() { com.google.gerrit.server.update.RetryHelper.Options opts = autoBuild(); if ((opts.timeoutMs()) != null) { checkArgument(((opts.timeoutMs()) > 0), "timeout must be positive: %sms", opts.timeoutMs()); } return opts; }<END_MOD>
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { builder.withStopStrategy(<START_MOD>com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeoutMs(), defaultTimeoutMs), java.util.concurrent.TimeUnit.MILLISECONDS)<END_MOD>).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); if ((opts.listener()) != null) { builder.withRetryListener(opts.listener()); } } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } }
<START_MOD>public static long getRetryTimeoutMs(org.eclipse.jgit.lib.Config cfg) { return cfg.getTimeUnit("noteDb", null, "retryTimeout", java.util.concurrent.TimeUnit.SECONDS.toMillis(5), java.util.concurrent.TimeUnit.MILLISECONDS); }<END_MOD>
private java.lang.String getPluginCanonicalWebUrl(java.lang.String name) {<START_MOD> java.lang.String canonicalWebUrl = urlProvider.get(); if (canonicalWebUrl == null) { canonicalWebUrl = ""; }<END_MOD> java.lang.String url = java.lang.String.format("%s/plugins/%s/", com.google.common.base.CharMatcher.is('/').trimTrailingFrom(<START_MOD>canonicalWebUrl<END_MOD>), name); return url; }
static java.lang.String computeCanonicalPath(java.lang.String canonicalURL) throws java.net.URISyntaxException {<START_MOD> if (canonicalURL == null) { return ""; }<END_MOD> java.net.URI uri = new java.net.URI(canonicalURL); return uri.getPath().replaceAll("/$", ""); }
public Project.NameKey project() throws com.google.gwtorm.server.OrmException { if ((project) == null) { checkState((!(<START_MOD>a.<END_MOD>notesMigration.readChanges())),   not have created ChangeData without a project when NoteDb is enabled project = change().getProject(); } return project; }
private java.util.Optional<com.google.gerrit.server.patch.DiffSummary> getDiffSummary(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.PatchSet ps) { java.lang.Integer psId = ps.getId().get(); if ((diffSummaries) == null) { diffSummaries = new java.util.HashMap(); } java.util.Optional<com.google.gerrit.server.patch.DiffSummary> r = diffSummaries.get(psId); if (r == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } try { r = java.util.Optional.of(<START_MOD>a.<END_MOD>patchListCache.getDiffSummary(c, ps)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { r = java.util.Optional.empty(); } diffSummaries.put(psId, r); } return r; }
public java.util.Set<java.lang.String> stars(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { if ((starsOf) != null) { if (!(starsOf.accountId().equals(accountId))) { starsOf = null; } } if ((starsOf) == null) { if ((stars) != null) { starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, stars.get(accountId)); } else { if (!(lazyLoad)) { return com.google.common.collect.ImmutableSet.of(); } starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, <START_MOD>a.<END_MOD>starredChangesUtil.getLabels(accountId, legacyId)); } } return starsOf.stars(); }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = <START_MOD>a.<END_MOD>repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = <START_MOD>a.<END_MOD>mergeUtilFactory.create(<START_MOD>a.<END_MOD>projectCache.get(project())).mergeStrategyName(); mergeable = <START_MOD>a.<END_MOD>mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSetApproval> approvals() throws com.google.gwtorm.server.OrmException { if ((allApprovals) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableListMultimap.of(); } allApprovals = <START_MOD>a.<END_MOD>approvalsUtil.byChange(db, notes()); } return allApprovals; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>a.<END_MOD>accountCache, <START_MOD>a.<END_MOD>accounts, <START_MOD>a.<END_MOD>emails, this).getSubmitType(); } return submitTypeRecord; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(<START_MOD>a.<END_MOD>accountCache, <START_MOD>a.<END_MOD>accounts, <START_MOD>a.<END_MOD>emails, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public static void ensureCurrentPatchSetLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first<START_MOD>.a<END_MOD>.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentPatchSet(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentPatchSet) == null) && ((cd.patchSets) == null)) { missing.put(cd.change().currentPatchSetId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.reviewdb.client.PatchSet ps : first.db.patchSets().get(missing.keySet())) { missing.get(ps.getId()).currentPatchSet = ps; } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> patchSets() throws com.google.gwtorm.server.OrmException { if ((patchSets) == null) { patchSets = <START_MOD>a.<END_MOD>psUtil.byChange(db, notes()); } return patchSets; }
public static void ensureMessagesLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first<START_MOD>.a<END_MOD>.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.messages(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.messages) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.changeMessages().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage> result = results.get(i); if (result != null) { batch.get(i).messages = result.toList(); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.RobotComment> robotComments() throws com.google.gwtorm.server.OrmException { if ((robotComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } robotComments = <START_MOD>a.<END_MOD>commentsUtil.robotCommentsByChange(notes()); } return robotComments; }
public java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages() throws com.google.gwtorm.server.OrmException { if ((messages) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } messages = <START_MOD>a.<END_MOD>cmUtil.byChange(db, notes()); } return messages; }
public static com.google.gerrit.server.query.change.ChangeData createForTest(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, int currentPatchSetId) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, project, id); cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, currentPatchSetId)); return cd; }
public com.google.gerrit.server.ReviewerSet reviewers() throws com.google.gwtorm.server.OrmException { if ((reviewers) == null) { if (!(lazyLoad)) { return com.google.gerrit.server.ReviewerSet.empty(); } reviewers = <START_MOD>a.<END_MOD>approvalsUtil.getReviewers(notes(), approvals().values()); } return reviewers; }
public java.util.List<com.google.gerrit.server.ReviewerStatusUpdate> reviewerUpdates() throws com.google.gwtorm.server.OrmException { if ((reviewerUpdates) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } reviewerUpdates = <START_MOD>a.<END_MOD>approvalsUtil.getReviewerUpdates(notes()); } return reviewerUpdates; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> editRefs() throws com.google.gwtorm.server.OrmException { if ((editsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } editsByUser = new java.util.HashMap(); com.google.gerrit.reviewdb.client.Change.Id id = checkNotNull(change.getId()); try (org.eclipse.jgit.lib.Repository repo = <START_MOD>a.<END_MOD>repoManager.openRepository(project())) { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).entrySet()) { if (id.equals(Change.Id.fromEditRefPart(e.getKey()))) { editsByUser.put(Account.Id.fromRefPart(e.getKey()), e.getValue()); } } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } return editsByUser; }
private boolean loadCommitData() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return false; } java.lang.String sha1 = ps.getRevision().get(); try (org.eclipse.jgit.lib.Repository repo = <START_MOD>a.<END_MOD>repoManager.openRepository(project());org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); commitFooters = c.getFooterLines(); author = c.getAuthorIdent(); committer = c.getCommitterIdent(); } return true; }
public static void ensureCurrentApprovalsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first<START_MOD>.a<END_MOD>.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentApprovals(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.currentApprovals) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.patchSetApprovals().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval> result = results.get(i); if (result != null) { batch.get(i).currentApprovals = com.google.gerrit.server.ApprovalsUtil.sortApprovals(result); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.Comment> publishedComments() throws com.google.gwtorm.server.OrmException { if ((publishedComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } publishedComments = <START_MOD>a.<END_MOD>commentsUtil.publishedByChange(db, notes()); } return publishedComments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals() throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else { try { currentApprovals = com.google.common.collect.ImmutableList.copyOf(<START_MOD>a.<END_MOD>approvalsUtil.byPatchSet(db, changeControl(), c.currentPatchSetId(), null, null)); } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { currentApprovals = java.util.Collections.emptyList(); } else { throw e; } } } } return currentApprovals; }
public com.google.gerrit.server.notedb.ChangeNotes notes() throws com.google.gwtorm.server.OrmException { if ((notes) == null) { if (!(lazyLoad)) { throw new com.google.gwtorm.server.OrmException( not available, lazyLoad = false } notes = <START_MOD>a.<END_MOD>notesFactory.create(db, project(), legacyId); } return notes; }
public com.google.common.collect.ImmutableMap<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.StarredChangesUtil.StarRef> starRefs() throws com.google.gwtorm.server.OrmException { if ((starRefs) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableMap.of(); } starRefs = checkNotNull(<START_MOD>a.<END_MOD>starredChangesUtil).byChange(legacyId); } return starRefs; }
public com.google.gerrit.server.project.ChangeControl changeControl(com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if ((changeControl) != null) { com.google.gerrit.server.CurrentUser oldUser = user; if (com.google.gerrit.server.query.change.ChangeData.sameUser(user, oldUser)) { return changeControl; } throw new java.lang.IllegalStateException(( already specified:   + (changeControl.getUser()))); } try { if ((change) != null) { changeControl = <START_MOD>a.<END_MOD>changeControlFactory.controlFor(db, change, user); } else { changeControl = <START_MOD>a.<END_MOD>changeControlFactory.controlFor(db, project(), legacyId, user); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } return changeControl; }
public com.google.gerrit.server.project.ChangeControl changeControl() throws com.google.gwtorm.server.OrmException { if ((changeControl) == null) { com.google.gerrit.reviewdb.client.Change c = change(); try { changeControl = <START_MOD>a.<END_MOD>changeControlFactory.controlFor(db, c, <START_MOD>a.<END_MOD>userFactory.create(c.getOwner())); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } } return changeControl; }
public static void ensureAllPatchSetsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.<START_MOD>a.<END_MOD>notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.patchSets(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.patchSets) == null) { results.add(cd.db.patchSets().byChange(cd.getId())); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> result = results.get(i); if (result != null) { batch.get(i).patchSets = result.toList(); } } } }
<START_MOD>public com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> trackingFooters() throws com.google.gwtorm.server.OrmException, java.io.IOException { return a.trackingFooters.extract(commitFooters()); }<END_MOD>
public com.google.gerrit.reviewdb.client.Change reloadChange() throws com.google.gwtorm.server.OrmException { try { notes = <START_MOD>a.<END_MOD>notesFactory.createChecked(db, project, legacyId); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(( to load change   + (legacyId)), e); } change = notes.getChange(); setPatchSets(null); return change; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> draftRefs() throws com.google.gwtorm.server.OrmException { if ((draftsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } draftsByUser = new java.util.HashMap(); if (<START_MOD>a.<END_MOD>notesMigration.readChanges()) { for (org.eclipse.jgit.lib.Ref ref : <START_MOD>a.<END_MOD>commentsUtil.getDraftRefs(notes.getChangeId())) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefSuffix(ref.getName()); if ((account != null) && (!(notes().getDraftComments(account, ref).isEmpty()))) { draftsByUser.put(account, ref); } } } else { for (Comment sc : <START_MOD>a.<END_MOD>commentsUtil.draftByChange(db, notes())) { draftsByUser.put(sc.author.getId(), null); } } } return draftsByUser; }
public static void ensureChangeLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first<START_MOD>.a<END_MOD>.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.change(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if ((cd.change) == null) { missing.put(cd.getId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.server.notedb.ChangeNotes notes : first.<START_MOD>a.<END_MOD>notesFactory.create(first.db, missing.keySet())) { missing.get(notes.getChangeId()).change = notes.getChange(); } }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change; try { change = cd.change(); if (change == null) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); com.google.gerrit.server.project.ChangeControl cc = changeControl.controlFor(notes, user); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gwtorm.server.OrmException( to check permissions e); } if (visible) { cd.cacheVisibleTo(cc); return true; } <START_MOD>} catch (com.google.gerrit.server.project.NoSuchChangeException e) { <END_MOD>return false; }<START_MOD> return false; }<END_MOD>
<START_MOD>java.lang.String readString(java.lang.String def, java.lang.String fmt, java.lang.Object... args);<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String readString(java.lang.String def, java.util.Set<java.lang.String> allowedValues, java.lang.String fmt, java.lang.Object... args) { return ui.readString(def, allowedValues, fmt, args); }<END_MOD>
@java.lang.Override public java.<START_MOD>util.SortedMap<java.<END_MOD>lang.<START_MOD>String, com.google.gerrit.extensions.common.PluginInfo><END_MOD> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException { return <START_MOD>apply<END_MOD>(); }
@java.lang.Override public void run() throws java.lang.Exception { <START_MOD>list.setAll(all); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = list.apply(); if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } else { stdout.format( %-10s %-8s %s "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> p : output.entrySet()) { com.google.gerrit.extensions.common.PluginInfo info = p.getValue(); stdout.format( %-10s %-8s %s p.getKey(), com.google.common.base.Strings.nullToEmpty(info.version), status(info.disabled), com.google.common.base.Strings.nullToEmpty(info.filename)); } } stdout.flush(); }<END_MOD>
public boolean isDisabled() { return (<START_MOD>enforceVisibility) && <END_MOD>(<START_MOD>(permittedLimit<END_MOD>) <= 0<START_MOD>)<END_MOD>; }
<START_MOD>public <T> void updateQueryLimit(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.query.QueryProcessor<T> qp) { qp.setPermittedLimit(create(user).getRange(GlobalCapability.QUERY_LIMIT).getMax()); }<END_MOD>
private int getEffectiveLimit(com.google.gerrit.index.query.Predicate<T> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(4); possibleLimits.add(getBackendSupportedLimit()); <START_MOD>com.google.gerrit.server.query.QueryProcessor.checkState(((<END_MOD>permittedLimit<START_MOD>) > 0),   limit should have been positive possibleLimits.add<END_MOD>(permittedLimit<START_MOD>); if ((userProvidedLimit)<END_MOD> > 0)<START_MOD> { possibleLimits.add(userProvidedLimit<END_MOD>); } if ((limitField) != null) { java.lang.Integer limitFromPredicate = com.google.gerrit.index.query.LimitPredicate.getLimit(limitField, p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } } return com.google.common.collect.Ordering.natural().min(possibleLimits); }
<START_MOD>@java.lang.Override public java.lang.String toString() { return ((("(" + (a)) + " || ") + (b)) + ")"; }<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String toString() { return ((("(" + (a)) + " && ") + (b)) + ")"; }<END_MOD>
public <R extends com.google.gerrit.extensions.restapi.RestResource> <START_MOD>java.lang.Iterable<END_MOD><com.google.gerrit.extensions.webui.UiAction.Description> from(com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<R>> views, R resource) { <START_MOD>java.util.List<com.google.gerrit.extensions.webui.UiAction.Description> descs =<END_MOD> com.google.common.collect.<START_MOD>Streams.stream<END_MOD>(views).<START_MOD>map<END_MOD>(( e) -> describe(e, resource)).filter(java.util.Objects::nonNull)<START_MOD>.collect(java.util.stream.Collectors.toList()); java.util.List<com.google.gerrit.server.permissions.PermissionBackendCondition> visible = descs.stream().flatMap(( u) -> com.google.common.collect.Streams.stream(visibleCondition(u))).collect(java.util.stream.Collectors.toList()); java.util.List<com.google.gerrit.server.permissions.PermissionBackendCondition> enabled = descs.stream().flatMap(( u) -> com.google.common.collect.Streams.stream(enabledCondition(u))).collect(java.util.stream.Collectors.toList()); permissionBackend.user(userProvider).bulkEvaluateTest(com.google.common.collect.Iterables.concat(visible, enabled)); return descs.stream().filter(( u) -> u.isVisible()).collect(java.util.stream.Collectors.toList())<END_MOD>; }
static java.lang.String computeFromRequest(javax.servlet.http.HttpServletRequest req) { java.lang.StringBuffer url = req.getRequestURL(); <START_MOD>try { url = new java.lang.StringBuffer(java.net.URLDecoder.decode(url.toString(), "UTF-8")); <END_MOD>url.setLength(((url.length()) - (req.getServletPath().length()))); if ((url.charAt(((url.length()) - 1))) != '/') { url.append('/'); } return url.toString(); }<START_MOD> catch (java.io.UnsupportedEncodingException e) { throw new java.lang.IllegalStateException(( encoding for request URL   + url), e); } }<END_MOD>
<START_MOD>private boolean canReadRef(java.lang.String ref) { try { return permissionBackend.user(user).project(projectCtl.getProject().getNameKey()).ref(ref).test(RefPermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error("unable to check permissions", e); return false; } }<END_MOD>
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectControl projectControl = controlFor(project); return (shouldReplicate(projectControl)) && ((PushOne.ALL_REFS.equals(ref)) || (<START_MOD>permissionBackend.user(<END_MOD>projectControl.<START_MOD>getUser()).project(project).<END_MOD>ref<START_MOD>(ref).test(RefPermission.READ<END_MOD>))); } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format( project %s not available project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
private java.util.List<org.eclipse.jgit.lib.Ref> getBranchRefs(com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.project.ProjectControl projectControl) { org.eclipse.jgit.lib.Ref[] result = new org.eclipse.jgit.lib.Ref[showBranch.size()]; try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName)) { <START_MOD>com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(currentUser).project(projectName); <END_MOD>for (int i = 0; i < (showBranch.size()); i++) { org.eclipse.jgit.lib.Ref ref = git.findRef(showBranch.get(i)); if ((((ref != null) && ((ref.getObjectId()) != null)) && (<START_MOD>perm.ref<END_MOD>(ref.getLeaf().getName()).<START_MOD>test(RefPermission.READ<END_MOD>))) || ((all) && (projectControl.isOwner()))) { result[i] = ref; } } } catch (java.io.IOException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException e<END_MOD>) { } return java.util.Arrays.asList(result); }
<START_MOD>private java.lang.String getDriverFromUrl(java.lang.String url) { if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.POSTGRESQL)) { return "org.postgresql.Driver"; } if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.MYSQL)) { return "com.mysql.jdbc.Driver"; } if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.MARIADB)) { return "org.mariadb.jdbc.Driver"; } return "org.h2.Driver"; }<END_MOD>
public static com.google.gerrit.server.account.externalids.ExternalId createWithEmail(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(key, accountId, com.google.common.base.Strings.emptyToNull(email), null<START_MOD>, null<END_MOD>); }
public static com.google.gerrit.server.account.externalids.ExternalId create(java.lang.String scheme, java.lang.String id, com.google.gerrit.reviewdb.client.Account.Id accountId) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(com.google.gerrit.server.account.externalids.ExternalId.Key.create(scheme, id), accountId, null, null<START_MOD>, null<END_MOD>); }
private static com.google.gerrit.server.account.externalids.ExternalId parse(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; }<START_MOD> org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId);<END_MOD> byte[] raw = rw.getObjectReader().open(<START_MOD>noteData<END_MOD>, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); return com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), <START_MOD>noteData, <END_MOD>raw); }
public static void remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return; }<START_MOD> org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId);<END_MOD> byte[] raw = rw.getObjectReader().open(<START_MOD>noteData<END_MOD>, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name()<START_MOD>, noteData<END_MOD>, raw); checkState(extId.equals(actualExtId),   id %s should be removed, but it not matching the actual external id %s extId.toString(), actualExtId.toString()); noteMap.remove(noteId); }
public static com.google.gerrit.server.account.externalids.ExternalId create(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email, @com.google.gerrit.common.Nullable java.lang.String hashedPassword) { return new com.google.gerrit.server.account.externalids.AutoValue_ExternalId(key, accountId, com.google.common.base.Strings.emptyToNull(email), com.google.common.base.Strings.emptyToNull(hashedPassword)<START_MOD>, null<END_MOD>); }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; }<START_MOD> org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId);<END_MOD> byte[] raw = rw.getObjectReader().open(<START_MOD>noteData<END_MOD>, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name()<START_MOD>, noteData<END_MOD>, raw); if (expectedAccountId != null) { checkState(expectedAccountId.equals(extId.accountId()), ( id %s should be removed for account %s, +   but external id belongs to account %s extIdKey.get(), expectedAccountId.get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; }
private java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException { if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return com.google.common.collect.ImmutableSet.of(); } try (com.google.gerrit.metrics.Timer0.Context ctx = readAllLatency.start();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = rw.getObjectReader().open(note.getData(), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), <START_MOD>note.getData(), <END_MOD>raw)); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIdReader.log.error(java.lang.String.format( invalid external ID note %s note.getName()), e); } } return extIds; } }
<START_MOD>public java.lang.String toSubmodules() { java.lang.StringBuffer buf = new java.lang.StringBuffer(); sortByPath(); for (com.googlesource.gerrit.plugins.supermanifest.Project p : projects) { buf.append(p.toSubmodules()); buf.append("\n"); } return buf.toString(); }<END_MOD>
<START_MOD>public void sortByPath() { java.util.Arrays.sort(projects, new com.googlesource.gerrit.plugins.supermanifest.SortbyPath()); }<END_MOD>
<START_MOD>public com.googlesource.gerrit.plugins.supermanifest.Project[] getProjects() { return projects; }<END_MOD>
<START_MOD>@java.lang.Override public int compare(com.googlesource.gerrit.plugins.supermanifest.Project a, com.googlesource.gerrit.plugins.supermanifest.Project b) { java.lang.String p1 = com.googlesource.gerrit.plugins.supermanifest.StringUtil.stripAndaddCharsAtEnd(a.getPath(), "/"); java.lang.String p2 = com.googlesource.gerrit.plugins.supermanifest.StringUtil.stripAndaddCharsAtEnd(b.getPath(), "/"); return p1.compareTo(p2); }<END_MOD>
<START_MOD>@java.lang.Override public boolean equals(java.lang.Object obj) { com.googlesource.gerrit.plugins.supermanifest.Project p = ((com.googlesource.gerrit.plugins.supermanifest.Project) (obj)); if (!(name.equals(p.name))) { return false; } if (!(path.equals(p.path))) { return false; } if (!(remote.equals(p.remote))) { return false; } if (!(remotebranch.equals(p.remotebranch))) { if (!(((remotebranch.equals("master")) && (p.remotebranch.equals(""))) || ((p.remotebranch.equals("master")) && (remotebranch.equals(""))))) { return false; } } if (!(revision.equals(p.revision))) { return false; } return true; }<END_MOD>
@java.lang.Override public java.lang.String toString() { return java.lang.String.format( <START_MOD>-> %s <END_MOD>=> %s<START_MOD> toolType,<END_MOD> src(), dest()); }
<START_MOD>@java.lang.Override public java.lang.String toString() { java.lang.StringBuffer buf = new java.lang.StringBuffer(); if ((projects.length) > 0) { buf.append("projects:\n"); for (com.googlesource.gerrit.plugins.supermanifest.Project p : projects) { buf.append(com.googlesource.gerrit.plugins.supermanifest.StringUtil.addTab(p.toString())); } } return buf.toString(); }<END_MOD>
<START_MOD>public com.googlesource.gerrit.plugins.supermanifest.LocalImport[] getLocalImports() { return localImports; }<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String toString() { java.lang.StringBuffer buf = new java.lang.StringBuffer(""); if ((imports.length) > 0) { buf.append((("import: " + (imports.length)) + "\n")); } if ((localImports.length) > 0) { buf.append("localImports:\n"); for (com.googlesource.gerrit.plugins.supermanifest.LocalImport l : localImports) { buf.append(com.googlesource.gerrit.plugins.supermanifest.StringUtil.addTab(l.toString())); } } return buf.toString(); }<END_MOD>
<START_MOD>public com.googlesource.gerrit.plugins.supermanifest.Import[] getImports() { return imports; }<END_MOD>
public static com.google.gerrit.index.query.Predicate<com.google.gerrit.server.group.InternalGroup> name(java.lang.String name) { return new com.google.gerrit.server.query.group.GroupPredicates.GroupPredicate(com.google.gerrit.server.index.group.GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); <START_MOD>com.google.gerrit.extensions.common.<END_MOD>GroupInfo group = createGroup(name(<START_MOD>"Group"<END_MOD>)); assertQuery(("name:" + (group.name)), group); <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit<END_MOD>.<START_MOD>extensions.common.<END_MOD>GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen")); createGroup(name("group-no-match-with-hyphen")); assertQuery(("name:" + (groupWithHyphen.name)), groupWithHyphen); }
<START_MOD>public byte[] toByteArray() { checkState(((blobId()) != null), "Missing blobId in external ID %s", key().get()); byte[] b = new byte[(2 * (org.eclipse.jgit.lib.Constants.OBJECT_ID_STRING_LENGTH)) + 1]; key().sha1().copyTo(b, 0); java.lang.System.arraycopy(":".getBytes(java.nio.charset.StandardCharsets.UTF_8), 0, b, Constants.OBJECT_ID_STRING_LENGTH, 1); blobId().copyTo(b, ((org.eclipse.jgit.lib.Constants.OBJECT_ID_STRING_LENGTH) + 1)); return b; }<END_MOD>
<START_MOD>@com.google.gerrit.common.Nullable private java.lang.String canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.lang.String userId) throws com.google.gerrit.server.permissions.PermissionBackendException { if (refControl.getProjectControl().isReachableFromHeadsOrTags(repo, commit)) { return null; } else if (testAuditLogged(RefPermission.UPDATE)) { return null; } return ((userId + " lacks permission ") + (com.google.gerrit.common.data.Permission.PUSH)) + " for creating new commit object"; }<END_MOD>
<START_MOD>private boolean testAuditLogged(com.google.gerrit.server.permissions.RefPermission p) throws com.google.gerrit.server.permissions.PermissionBackendException { try { permForRef.check(p); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } return true; }<END_MOD>
boolean isProjectStatePermittingWrite() { return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((( object   + (cmd.getNewId().name())) +   for   + (cmd.getRefName())) +   creation err); reject(cmd,   object return; } logDebug( {} cmd); if ((com.google.gerrit.server.git.receive.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); java.lang.String rejectReason = <START_MOD>createRefControlFactory.create(<END_MOD>ctl<START_MOD>).canCreateRef<END_MOD>(rp.getRepository(), obj); if (rejectReason != null) { reject(cmd, ( by Gerrit:   + rejectReason)); return; } if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); actualCommands.add(cmd); }
<START_MOD>public boolean permitsRead() { return (this) != (com.google.gerrit.extensions.client.ProjectState.HIDDEN); }<END_MOD>
<START_MOD>public boolean permitsWrite() { return (this) == (com.google.gerrit.extensions.client.ProjectState.ACTIVE); }<END_MOD>
private boolean can(com.google.gerrit.server.permissions.ChangePermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { try { switch (perm) { case READ : return isVisible(db(), changeData()); case ABANDON : return canAbandon(db()); case DELETE : return canDelete(db(), getChange().getStatus()); case ADD_PATCH_SET : return canAddPatchSet(db()); case EDIT_ASSIGNEE : return canEditAssignee(); case EDIT_DESCRIPTION : return canEditDescription(); case EDIT_HASHTAGS : return canEditHashtags(); case EDIT_TOPIC_NAME : return canEditTopicName(); case <START_MOD>REMOVE_REVIEWER : return canRemoveReviewer(); case <END_MOD>REBASE : return canRebase(db()); case RESTORE : return canRestore(db()); case SUBMIT : return getRefControl().canSubmit(isOwner()); case SUBMIT_AS : return getRefControl().canPerform(perm.permissionName().get()); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.permissions.PermissionBackendException("unavailable", e); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { <START_MOD>com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(opts.listener()); <END_MOD>try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); <START_MOD>builder.withRetryListener(listener); <END_MOD>if (migration.disableChangeReviewDb()) { builder.withStopStrategy(com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeout(), defaultTimeout).toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS)).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); <START_MOD>} else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { <END_MOD>if (<START_MOD>e instanceof com.github.rholder.retry.RetryException) { metrics.timeoutCount.increment(); } if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } finally { if ((<END_MOD>listener<START_MOD>.getAttemptCount()) > 0) { metrics.attemptCounts.record(<END_MOD>listener<START_MOD>.getAttemptCount()); } } }<END_MOD>
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { <START_MOD>try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } catch (<END_MOD>com.google.gerrit.server.project.<START_MOD>NoSuchProjectException<END_MOD> e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
private java.util.List<com.google.gerrit.server.change.RevisionResource> loadEdit(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.reviewdb.client.RevId revid) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change.<START_MOD>getNotes(), change.getUser<END_MOD>()); if (edit.isPresent()) { com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 0)); com.google.gerrit.reviewdb.client.RevId editRevId = new com.google.gerrit.reviewdb.client.RevId(org.eclipse.jgit.lib.ObjectId.toString(edit.get().getEditCommit())); ps.setRevision(editRevId); if ((revid == null) || (editRevId.equals(revid))) { return java.util.Collections.singletonList(new com.google.gerrit.server.change.RevisionResource(change, ps, edit)); } } return java.util.Collections.emptyList(); }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(<START_MOD>control.getNotes(), control.getUser()<END_MOD>); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(change.getId()); }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), rsrc.getNotes()); com.google.gerrit.reviewdb.client.Project.NameKey project = <START_MOD>rsrc<END_MOD>.getProject(); return includedIn.apply(project, ps.getRevision().get()); }
@java.lang.Override protected com.google.gerrit.extensions.common.ChangeInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.AbandonInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { req.permissions().database(dbProvider).check(ChangePermission.ABANDON); com.google.gerrit.extensions.api.changes.NotifyHandling notify = ((input.notify) == null) ? defaultNotify(req.<START_MOD>getChange()) : input.notify; com.google.gerrit.reviewdb.client.Change change = abandon(updateFactory, req.<END_MOD>getControl()<START_MOD>, input.message, notify, notifyUtil.resolveAccounts(input.notifyDetails)); return json.noOptions().format(<END_MOD>change); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ChangeControl control) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, control, "", defaultNotify(control<START_MOD>.getChange()<END_MOD>), com.google.common.collect.ImmutableListMultimap.of()); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ChangeControl control, java.lang.String msgTxt) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, control, msgTxt, defaultNotify(control<START_MOD>.getChange()<END_MOD>), com.google.common.collect.ImmutableListMultimap.of()); }
private java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> lookupChangeEdit(com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> <START_MOD>notes<END_MOD>) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException { return changeEditUtil.byChange(<START_MOD>notes, currentUser.get()<END_MOD>); }
<START_MOD>private static void checkedAdd(com.google.gerrit.server.query.change.ChangeData cd, java.util.List<com.google.gerrit.server.project.ChangeControl> ctls, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { try { ctls.add(cd.changeControl(user)); } catch (com.google.gwtorm.server.OrmException e) { if (!(e instanceof com.google.gerrit.server.project.NoSuchChangeException)) { throw e; } } }<END_MOD>
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchForReviewIsRejectedOnSubmitIfPreferredEmailIsInvalid() throws java.lang.Exception { java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String noEmail = "no.email"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, noEmail); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + userRef)); r.assertOkStatus(); accountIndexedCounter.assertNoReindex(); assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format(("invalid account configuration: invalid preferred email '%s' for account '%s';" + " account '%s' has no external ID for its preferred email '%s'"), noEmail, admin.id, admin.id, noEmail)); gApi.changes().id(r.getChangeId()).current().submit(); }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(<START_MOD>rsrc.getUser().getAccountId(), ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return alreadyActive<END_MOD>.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( deactivate own account } java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(<START_MOD>rsrc.getUser().getAccountId(), ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } if (alreadyInactive<END_MOD>.get()) { throw new com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException<END_MOD>( not active } return com.google.gerrit.extensions.restapi.Response.none(); }
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchIsRejectedIfPreferredEmailIsInvalid() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, ((com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)) + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String noEmail = "no.email"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, noEmail); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(RefNames.REFS_USERS_SELF); r.assertErrorStatus("invalid account configuration"); r.assertMessage(java.lang.String.format("invalid preferred email '%s' for account '%s'", noEmail, admin.id)); r.assertMessage(java.lang.String.format("account '%s' has no external ID for its preferred email '%s'", admin.id, noEmail)); accountIndexedCounter.assertNoReindex(); }<END_MOD>
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchForReviewIsRejOnSubmitIfPrefEmailDoesNotExistAsExtId() throws java.lang.Exception { java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String email = "some.email@example.com"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + userRef)); r.assertOkStatus(); accountIndexedCounter.assertNoReindex(); assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format(("invalid account configuration:" + " account '%s' has no external ID for its preferred email '%s'"), admin.id, email)); gApi.changes().id(r.getChangeId()).current().submit(); }<END_MOD>
public com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.server.project.RefControl refctl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.revwalk.RevWalk rw) { com.google.gerrit.server.IdentifiedUser user = refctl.getUser().asIdentifiedUser(); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(perm), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(user, perm, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(user, perm, refctl.getProjectControl().getProjectState()), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refctl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refctl, rw, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new com.google.gerrit.server.git.validators.CommitValidators.<START_MOD>AccountCommitValidator<END_MOD>(allUsers<START_MOD>, accountValidator<END_MOD>))); }
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchPreferredEmailDoesNotExistAsExtIdButNotChanged() throws java.lang.Exception { TestAccount foo = accountCreator.create(name("foo")); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); java.lang.String email = "some.email@example.com"; accountsUpdate.create().update(foo.id, ( a) -> a.setPreferredEmail(email)); accountIndexedCounter.clear(); com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")); grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID()); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String status = "in vacation"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status); pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus(); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.email).isEqualTo(email); assertThat(info.name).isEqualTo(foo.fullName); assertThat(info.status).isEqualTo(status); }<END_MOD>
<START_MOD>@org.junit.Test public void pushAccountConfigToUserBranchIsRejectedIfPreferredEmailDoesNotExistAsExtId() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, ((com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)) + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String email = "some.email@example.com"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(RefNames.REFS_USERS_SELF); r.assertErrorStatus("invalid account configuration"); r.assertMessage(java.lang.String.format("account '%s' has no external ID for its preferred email '%s'", admin.id, email)); accountIndexedCounter.assertNoReindex(); }<END_MOD>
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException( should only have no more than one --project and -n with --suggest } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, <START_MOD>(!(projects.isEmpty()) ? <END_MOD>com.google.common.collect.Iterables.getFirst(projects,<START_MOD> null).getProjectState() :<END_MOD> null)), ((limit) <=   ? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupRefs.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic desc = groupBackend.get(ref.getUUID()); if (desc != null) { groupInfos.add(json.addOptions(options).format(desc)); } } return groupInfos; }
private org.eclipse.jgit.revwalk.RevCommit newMergeCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter oi, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.<START_MOD>ProjectState projectState<END_MOD>, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.extensions.common.MergeInput merge, org.eclipse.jgit.lib.PersonIdent authorIdent, java.lang.String commitMessage) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { if (com.google.common.base.Strings.isNullOrEmpty(merge.source)) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be non-empty } com.google.gerrit.server.project.ProjectState state = <START_MOD>projectState<END_MOD>; org.eclipse.jgit.revwalk.RevCommit sourceCommit = com.google.gerrit.server.git.MergeUtil.resolveCommit(repo, rw, merge.source); if (!(commits.canRead(state, repo, sourceCommit))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(( not have read permission for:   + (merge.source))); } com.google.gerrit.server.git.MergeUtil mergeUtil = mergeUtilFactory.create(state); java.lang.String mergeStrategy = com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(merge.strategy), mergeUtil.mergeStrategyName()); return com.google.gerrit.server.git.MergeUtil.createMergeCommit(oi, repo.getConfig(), mergeTip, sourceCommit, mergeStrategy, authorIdent, commitMessage, rw); }
<START_MOD>@java.lang.Override public java.lang.Void call() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { for (com.google.gerrit.server.notedb.ChangeNotes notes : notesFactory.scan(repo, db, project)) { try { indexer.index(changeDataFactory.create(db, notes)); done.update(1); verboseWriter.println(("Reindexed change " + (notes.getChangeId()))); } catch (java.util.concurrent.RejectedExecutionException e) { failSilently(); } catch (java.lang.Exception e) { fail(("Failed to index change " + (notes.getChangeId())), true, e); } } } return null; }<END_MOD>
com.google.gerrit.server.notedb.ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { checkState((!(args.migration.readChanges())),   not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled return new com.google.gerrit.server.notedb.ChangeNotes(args, change).load(); }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChangesByScan() { com.google.gerrit.reviewdb.client.Project.NameKey project = projectCtl.getProject().getNameKey(); try { java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChanges = new java.util.HashMap<>(); <START_MOD>com.google.gerrit.server.notedb.ChangeNotesIterator it = changeNotesFactory.scan(git, db.get(), project); while (it.hasNext()) { com.google.gerrit.server.notedb.ChangeNotes cn = it.next(); if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) { visibleChanges.put(cn.getChangeId(), cn.getChange().getDest()); } } return visibleChanges; } catch (java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error((( load changes <END_MOD>for project<START_MOD>   + project) +   assuming no changes are visible e);<END_MOD> return java.util.Collections.emptyMap(); } }
private com.google.gerrit.server.notedb.<START_MOD>NoteDbChangeNotesIterator<END_MOD> scanNoteDb(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) { <START_MOD>return<END_MOD> new com.google.gerrit.server.notedb.<START_MOD>NoteDbChangeNotesIterator<END_MOD>(<START_MOD>this<END_MOD>, <START_MOD>repo, db, project, args<END_MOD>.<START_MOD>migration.changePrimaryStorage<END_MOD>()); }
<START_MOD>public com.google.gerrit.server.notedb.ChangeNotesIterator scan(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) { return args.migration.readChanges() ? scanNoteDb(repo, db, project) : new com.google.gerrit.server.notedb.ReviewDbChangeNotesIterator(this, repo, db); }<END_MOD>
public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> create(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.function.Predicate<com.google.gerrit.server.notedb.ChangeNotes> predicate) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> m = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); if (args.migration.readChanges()) { for (com.google.gerrit.reviewdb.client.Project.NameKey project : projectCache.all()) { try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(project)) { <START_MOD>com.google.gerrit.server.notedb.ChangeNotesIterator it = scanNoteDb(repo, db, project); while (it.hasNext()) { <END_MOD>com.google.gerrit.server.notedb.ChangeNotes<START_MOD> cn = it.next(); if (predicate.test(cn)) { m.put(project, cn); } } } } } else { for (com.google.gerrit.reviewdb.client.Change change : com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db).<END_MOD>changes<START_MOD>().all()) { com.google.gerrit.server.notedb.ChangeNotes notes<END_MOD> = <START_MOD>createFromChangeOnlyWhenNoteDbDisabled(change);<END_MOD> if (predicate.test(<START_MOD>notes<END_MOD>)) { m.put(change<START_MOD>.getProject(),<END_MOD> notes<START_MOD>); } } } return com.google.common.collect.ImmutableListMultimap.copyOf(<END_MOD>m<START_MOD>); }<END_MOD>
static com.google.gerrit.server.notedb.ChangeNotes.Factory.ScanResult scanChangeIds(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromPs = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromMeta = com.google.common.collect.ImmutableSet.builder(); for (org.eclipse.jgit.lib.Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) { com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.fromRef(r.getName()); if (id != null) { (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id); } } return new com.google.gerrit.server.notedb.AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build()); }
@java.lang.Override public void stop() { if ((threadPool) != null) { threadPool = null; } }
<START_MOD>private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { com.google.gerrit.extensions.common.GroupInfo canSeeGroup = visibleGroups.get(id); if (canSeeGroup == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); canSeeGroup = (control.isVisible()) ? groupJson.format(control.getGroup()) : com.google.gerrit.server.project.GetAccess.invisibleSentinel; } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gwtorm.server.OrmException e) { canSeeGroup = com.google.gerrit.server.project.GetAccess.invisibleSentinel; } visibleGroups.put(id, canSeeGroup); } return canSeeGroup; }<END_MOD>
private com.google.gerrit.extensions.api.access.AccessSectionInfo createAccessSection(<START_MOD>java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions<END_MOD>.common.<START_MOD>GroupInfo> groups, com.google.gerrit.common.<END_MOD>data.AccessSection section) { com.google.gerrit.extensions.api.access.AccessSectionInfo accessSectionInfo = new com.google.gerrit.extensions.api.access.AccessSectionInfo(); accessSectionInfo.permissions = new java.util.HashMap(); for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { com.google.gerrit.extensions.api.access.PermissionInfo pInfo = new com.google.gerrit.extensions.api.access.PermissionInfo(p.getLabel(), (p.getExclusiveGroup() ? true : null)); pInfo.rules = new java.util.HashMap(); for (com.google.gerrit.common.data.PermissionRule r : p.getRules()) { com.google.gerrit.extensions.api.access.PermissionRuleInfo info = new com.google.gerrit.extensions.api.access.PermissionRuleInfo(com.google.gerrit.server.project.GetAccess.ACTION_TYPE.get(r.getAction()), r.getForce()); if (r.hasRange()) { info.max = r.getMax(); info.min = r.getMin(); } com.google.gerrit.reviewdb.client.AccountGroup.UUID group = r.getGroup().getUUID(); if (group != null) { pInfo.rules.put(group.get(), info); <START_MOD>loadGroup(groups, group); <END_MOD>} } accessSectionInfo.permissions.put(p.getName(), pInfo); } return accessSectionInfo; }
boolean isPatchSetLocked(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if ((getChange().getStatus()) == (Change.Status.MERGED)) { return false; } for (com.google.gerrit.reviewdb.client.PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId(), null, null)) { com.google.gerrit.common.data.LabelType type = <START_MOD>getProjectControl().getProjectState().<END_MOD>getLabelTypes().byLabel(ap.getLabel()); if (((type != null) && ((ap.getValue()) == 1)) && (type.getFunctionName().equalsIgnoreCase("PatchSetLock"))) { return true; } } return false; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { user = ctx.getIdentifiedUser(); notes = ctx.getNotes(); ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); boolean dirty = false; dirty |= insertComments(ctx); dirty |= insertRobotComments(ctx); dirty |= updateLabels(<START_MOD>projectCache.checkedGet(ctx.getProject()), <END_MOD>ctx); dirty |= insertMessage(ctx); return dirty; }
private void fireCommentAddedEvent(com.google.gerrit.server.update.Context ctx) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException<END_MOD> { if (approvals.isEmpty()) { return; } <START_MOD>java.util.List<<END_MOD>com.google.gerrit.<START_MOD>common.data.LabelType> labels<END_MOD> = <START_MOD>projectCache.checkedGet(ctx.getProject()).getLabelTypes(<END_MOD>notes<START_MOD>, ctx.getUser()).getLabelTypes(); java.util.Map<java.lang.String, java.lang.Short> allApprovals = new java.util.HashMap<>(); java.util.Map<java.lang.String, java.lang.Short> oldApprovals = new java.util.HashMap<>(); for (com.google.gerrit.common.data.LabelType lt : labels) { allApprovals.put(lt.getName(), ((short) (0))); oldApprovals.put(lt.getName(), null); } for (java.util.Map.Entry<java.lang.String, java.lang.Short> entry : approvals.entrySet()) { if ((entry.getValue()) != 0) { allApprovals.put(entry.getKey(), entry.getValue()); oldApprovals.put(entry.getKey(), ((short) (0))); } } commentAdded.fire(notes<END_MOD>.getChange(), <START_MOD>newPatchSet, ctx.getAccount(), null,<END_MOD> allApprovals<START_MOD>,<END_MOD> oldApprovals, ctx.getWhen()); }
public com.google.gerrit.server.git.LabelNormalizer.Result normalize(com.google.gerrit.server.project.ChangeControl ctl, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> unchanged = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> updated = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> deleted = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.<START_MOD>getProjectControl().getProjectState().<END_MOD>getLabelTypes(); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { com.google.gerrit.reviewdb.client.Change.Id changeId = psa.getKey().getParentKey().getParentKey(); checkArgument(changeId.equals(ctl.getId()),   %s does not match change %s psa.getKey(), ctl.getChange().getKey()); if (psa.isLegacySubmit()) { unchanged.add(psa); continue; } com.google.gerrit.common.data.LabelType label = labelTypes.byLabel(psa.getLabelId()); if (label == null) { deleted.add(psa); continue; } com.google.gerrit.reviewdb.client.PatchSetApproval copy = copy(psa); applyTypeFloor(label, copy); if (!(applyRightFloor(ctl, label, copy))) { deleted.add(psa); } else if ((copy.getValue()) != (psa.getValue())) { updated.add(copy); } else { unchanged.add(psa); } } return com.google.gerrit.server.git.LabelNormalizer.Result.create(unchanged, updated, deleted); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(com.google.gerrit.reviewdb.server.ReviewDb db, java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile(   if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.<START_MOD>externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, nameOrEmail)); if (extId != null) { com.google.gerrit.server.account.<END_MOD>AccountState who = byId.<START_MOD>get(extId.accountId()<END_MOD>); if (who != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } <START_MOD>} <END_MOD>return findAllByNameOrEmail(db, nameOrEmail); }
private boolean verify(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String username = com.google.gerrit.httpd.RemoteUserUtil.getRemoteUser(req, loginHttpHeader); if (username == null) { rsp.sendError(com.google.gerrit.httpd.SC_FORBIDDEN); return false; } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } <START_MOD>try {<END_MOD> com.google.gerrit.server.account.<START_MOD>externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.httpd.SCHEME_USERNAME, username)); if (extId == null) { rsp.sendError(com.google.gerrit.httpd.SC_UNAUTHORIZED); return false; } com.google.gerrit.server.account.<END_MOD>AccountState who = accountCache.<START_MOD>get(extId.accountId()<END_MOD>); if ((who == null) || (!(who.getAccount().isActive()))) { rsp.sendError(com.google.gerrit.httpd.SC_UNAUTHORIZED); return false; } com.google.gerrit.httpd.WebSession ws = session.get(); ws.setUserAccountId(who.getAccount().getId()); ws.setAccessPathOk(AccessPath.GIT, true); ws.setAccessPathOk(AccessPath.REST_API, true); return true; }<START_MOD> catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException( external ID config e); } }<END_MOD>
@java.lang.Override public boolean validateIdentity(org.apache.sshd.server.session.ServerSession session, java.lang.String identity) { final com.google.gerrit.sshd.SshSession sd = session.getAttribute(SshSession.KEY); int at = identity.indexOf('@'); java.lang.String username; if (at == (-1)) { username = identity; } else { username = identity.substring(0, at); } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } com.google.gerrit.server.account.<START_MOD>externalids.ExternalId.Key extIdKey = ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username); try { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(extIdKey); if (extId != null) { com.google.gerrit.server.account.<END_MOD>AccountState state = accounts.<START_MOD>get(extId.accountId()<END_MOD>); com.google.gerrit.reviewdb.client.Account account = (state == null) ? null : state.getAccount(); boolean active = (account != null) && (account.isActive()); if (active) { return com.google.gerrit.sshd.SshUtil.success(username, session, sshScope, sshLog, sd, com.google.gerrit.sshd.SshUtil.createUser(sd, userFactory, account.getId())); } <START_MOD>} <END_MOD>return false; }<START_MOD> catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.sshd.GerritGSSAuthenticator.log.error(java.lang.String.format( to read external ID %s extIdKey.get()), e); return false; } }<END_MOD>
<START_MOD>public java.util.List<java.lang.String> getPatterns() { return java.util.Collections.unmodifiableList(patterns); }<END_MOD>
void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.<START_MOD>io<END_MOD>.<START_MOD>IOException, org.eclipse.jgit.api.errors.GitAPIException<END_MOD>;
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.<START_MOD>io.IOException, org.eclipse.jgit.api.errors.GitAPIException<END_MOD> { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.getDestBranch().equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.repo.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.getDestBranch()); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.Utils.readBlob(srcRepo, ((srcRef + ":") + (c.getXmlPath())))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.isRecordSubmoduleLabels()).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setTargetURI(c.getDestRepoKey().toString()).setURI(c.getBaseUri().toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.repo.RepoUpdater.GerritIncludeReader(srcRepo, srcRef)); cmd.call(); }
<START_MOD>public synchronized void update(java.lang.String projectName, java.lang.String refName) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { if (projectName.equals(allProjectsName.get())) { if (refName.equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(projectName))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(refName)))) { continue; } if ((c.destBranch.equals("*")) && (!(refName.startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } com.googlesource.gerrit.plugins.supermanifest.SubModuleUpdater subModuleUpdater; switch (c.getToolType()) { case Repo : subModuleUpdater = new com.googlesource.gerrit.plugins.supermanifest.repo.RepoUpdater(serverIdent, canonicalWebUrl); break; default : throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("invalid toolType: %s", c.getToolType().name())); } try (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { subModuleUpdater.update(reader, c, refName); } } }<END_MOD>
@java.lang.Override public void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { <START_MOD>try { update<END_MOD>(event.getProjectName()<START_MOD>, <END_MOD>event.getRefName()<START_MOD>);<END_MOD> } catch (java.lang.Exception e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); java.io.StringWriter sw = new java.io.StringWriter(); java.io.PrintWriter pw = new java.io.PrintWriter(sw); e.printStackTrace(pw); error( for %s (ref %s) failed: %s <START_MOD>event.getProjectName<END_MOD>(), event.getRefName(), sw); } }
<START_MOD>public boolean getPreferIPv4() { return preferIPv4; }<END_MOD>
<START_MOD>public java.lang.String getJGroupsChannelName() { return jgroupsChannelName; }<END_MOD>
@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.common.base.Optional<com.ericsson.gerrit.plugins.highavailability.peers.PeerInfo>>() {}).toProvider(com.ericsson.gerrit.plugins.highavailability.peers.<START_MOD>JGroupsPeerInfoProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.peers.JGroupsPeerInfoProvider<END_MOD>.class); }
<START_MOD>@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { update(resource.getProjectState().getProject().getName(), resource.getRef()); return com.google.gerrit.extensions.restapi.Response.none(); }<END_MOD>
<START_MOD>void run() throws java.lang.Exception { com.google.gerrit.common.FileUtil.mkdirsOrDie(replica.site_path, ("cannot create " + (replica.site_path))); for (java.nio.file.Path dir : listDirsForCopy()) { copyFiles(dir); } com.ericsson.gerrit.plugins.highavailability.SetupLocalHAReplica.mkdir(replica.logs_dir); com.ericsson.gerrit.plugins.highavailability.SetupLocalHAReplica.mkdir(replica.tmp_dir); symlink(java.nio.file.Paths.get(masterConfig.getString("gerrit", null, "basePath"))); symlink(sharedDir); org.eclipse.jgit.storage.file.FileBasedConfig replicaConfig = new org.eclipse.jgit.storage.file.FileBasedConfig(replica.gerrit_config.toFile(), org.eclipse.jgit.util.FS.DETECTED); replicaConfig.load(); if (masterConfig.getString("database", null, "type").equals("h2")) { masterConfig.setBoolean("database", "h2", "autoServer", true); replicaConfig.setBoolean("database", "h2", "autoServer", true); symlinkH2ReviewDbDir(); } masterConfig.setString("httpd", null, "listenUrl", "http://localhost:8081"); replicaConfig.setString("httpd", null, "listenUrl", "http://localhost:8082"); masterConfig.setString("sshd", null, "listenAddress", "*:29419"); replicaConfig.setString("sshd", null, "listenAddress", "*:29420"); replicaConfig.save(); setPeerInfoUrl(master, "http://localhost:8082"); setPeerInfoUrl(replica, "http://localhost:8081"); writeHAProxyConfigFile(); }<END_MOD>
<START_MOD>private void createHAReplicaSite() throws java.lang.Exception { if (ui.yesno(true, "Create a local HA replica site")) { if ((sharedDir) == null) { ui.message(((SHARED_DIRECTORY_KEY) + " not set. Cannot setup HA replica")); return; } java.lang.String replicaPath = ui.readString("ha/1", "Location of the HA replica"); java.nio.file.Path replica = site.site_path.resolve(java.nio.file.Paths.get(replicaPath)); if (java.nio.file.Files.exists(replica)) { ui.message("%s already exists, exiting", replica); return; } new com.ericsson.gerrit.plugins.highavailability.SetupLocalHAReplica(pluginName, site, flags, sharedDir, new com.google.gerrit.server.config.SitePaths(replica)).run(); } }<END_MOD>
@java.lang.Override public void run() throws java.lang.Exception { ui.message("\n"); ui.header( Plugin pluginName); if (ui.yesno(true,   %s pluginName)) { ui.header( %s pluginName); java.nio.file.Path pluginConfigFile = site.etc_dir.resolve(((pluginName) + ".config")); config = new org.eclipse.jgit.storage.file.FileBasedConfig(pluginConfigFile.toFile(), org.eclipse.jgit.util.FS.DETECTED); config.load(); configureMainSection(); configurePeerInfoSection(); configureHttp(); configureCacheSection(); configureIndexSection(); configureWebsessiosSection(); config.save(); <START_MOD>flags.cfg.setBoolean("database", "h2", "autoServer", true); createHAReplicaSite(); <END_MOD>} }
<START_MOD>private void setPeerInfoUrl(SitePaths site, java.lang.String url) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(site.etc_dir.resolve(((pluginName) + ".config")).toFile(), org.eclipse.jgit.util.FS.DETECTED); cfg.load(); cfg.setString("peerInfo", null, "url", url); cfg.save(); }<END_MOD>
<START_MOD>private static final void mkdir(java.nio.file.Path dir) throws java.io.IOException { java.nio.file.Files.createDirectories(dir); }<END_MOD>
<START_MOD>private boolean shouldSkip(java.nio.file.Path p) throws java.io.IOException { java.nio.file.Path resolved = master.site_path.resolve(p); for (java.nio.file.Path skip : toSkip) { if (java.nio.file.Files.isSameFile(resolved, skip)) { return true; } } return false; }<END_MOD>
<START_MOD>private void writeHAProxyConfigFile() throws java.io.IOException { try (java.io.FileWriter out = new java.io.FileWriter(master.etc_dir.resolve("haproxy.config").toFile());java.io.PrintWriter w = new java.io.PrintWriter(out)) { w.println("global"); w.println(" daemon"); w.println(); w.println("defaults"); w.println(" timeout connect 5s"); w.println(" timeout client 50s"); w.println(" timeout server 50s"); w.println(); w.println("frontend http-in"); w.println(" bind localhost:8080"); w.println(" default_backend servers"); w.println(); w.println("backend servers"); w.println(" server gerrit1 localhost:8081"); w.println(" # server gerrit2 localhost:8082"); w.println(); w.println("listen ssh-in"); w.println(" bind localhost:29418"); w.println(" server gerrit1 localhost:29419"); w.println(" # server gerrit2 localhost:29420"); } }<END_MOD>
private void configureMainSection() { ui.header( section java.lang.String <START_MOD>sharedDirDefault = (ui.isBatch()) ? "shared" : null; java.lang.String shared<END_MOD> = promptAndSetString( directory com.ericsson.gerrit.plugins.highavailability.MAIN_SECTION, com.ericsson.gerrit.plugins.highavailability.SHARED_DIRECTORY_KEY, <START_MOD>sharedDirDefault<END_MOD>); if (!(com.google.common.base.Strings.isNullOrEmpty(<START_MOD>shared<END_MOD>))) {<START_MOD> sharedDir = java.nio.file.Paths.get(shared);<END_MOD> java.nio.file.Path <START_MOD>resolved<END_MOD> = site.site_path.resolve(sharedDir); com.google.gerrit.common.FileUtil.mkdirsOrDie(<START_MOD>resolved<END_MOD>, ( create   + <START_MOD>resolved<END_MOD>)); } }
private boolean applyRightFloor(com.google.gerrit.server.<START_MOD>notedb.ChangeNotes notes<END_MOD>, com.google.gerrit.common.data.LabelType lt, com.google.gerrit.reviewdb.client.PatchSetApproval a) <START_MOD>throws com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.ForChange forChange<END_MOD> = <START_MOD>permissionBackend.user(userFactory.create(a.getAccountId())).database(db).change(notes); try { forChange.check(new com.google.gerrit.server.permissions.LabelPermission(lt.getName())); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } short value = a.getValue(); while (value != 0) { try { forChange.check(new com.google.gerrit.server.permissions.LabelPermission.WithValue(lt.getName()<END_MOD>, <START_MOD>value)); break; } catch (com.google.gerrit.extensions.restapi.AuthException e) { if (value > 0) { value--; } else if (value < 0) { value++; } } }<END_MOD> a.<START_MOD>setValue(value);<END_MOD> return true; }
<START_MOD>@java.lang.Override public boolean isPureRevert(@com.google.gerrit.common.Nullable java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getPureRevert.setClaimedOriginal(claimedOriginal).apply(change); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot rebase change", e); } }<END_MOD>
<START_MOD>@org.junit.Test public void isPureRevertReturnsTrueForPureRevert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); approve(r.getChangeId()); gApi.changes().id(r.getChangeId()).current().submit(); java.lang.String revertId = gApi.changes().id(r.getChangeId()).revert().get().id; assertThat(gApi.changes().id(revertId).isPureRevert()).isTrue(); }<END_MOD>
<START_MOD>@java.lang.Override public boolean isPureRevert() throws com.google.gerrit.extensions.restapi.RestApiException { return isPureRevert(null); }<END_MOD>
<START_MOD>@java.lang.Override public boolean isPureRevert(java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }<END_MOD>
<START_MOD>boolean isPureRevert() throws com.google.gerrit.extensions.restapi.RestApiException;<END_MOD>
<START_MOD>@java.lang.Override public boolean isPureRevert() throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }<END_MOD>
<START_MOD>boolean isPureRevert(java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException;<END_MOD>
private java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents() { java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all()) { com.google.gerrit.server.project.ProjectState ps = projectCache.get(p); if (ps != null) { com.google.gerrit.reviewdb.client.Project.NameKey parent = ps.getParent(); if (parent != null) { parents.add(parent); } } } parents.add(allProjects); return parents; }
private void service() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.Failure, java.io.IOException { state = projectControl.getProjectState(); <START_MOD>projectName<END_MOD> = state.getProject().getNameKey(); try { repo = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.Failure(1, ((   + (<START_MOD>projectName<END_MOD>.<START_MOD>get<END_MOD>())) +   not a git archive e); } try { runImpl(); } finally { repo.close(); } }
private boolean validCommit(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.reviewdb.client.Branch.NameKey branch, org.eclipse.jgit.transport.ReceiveCommand cmd, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { if (validCommits.contains(id)) { return true; } org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(id); rw.parseBody(c); try (com.google.gerrit.server.events.CommitReceivedEvent receiveEvent = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, project<START_MOD>.getNameKey()<END_MOD>, branch.get(), rw.getObjectReader(), c, user)) { boolean isMerged = (((magicBranch) != null) && (cmd.getRefName().equals(magicBranch.cmd.getRefName()))) && (magicBranch.merged); com.google.gerrit.server.git.validators.CommitValidators validators = (isMerged) ? commitValidatorsFactory.forMergedCommits(perm, user.asIdentifiedUser()) : commitValidatorsFactory.forReceiveCommits(perm, branch, user.asIdentifiedUser(), sshInfo, repo, rw); messages.addAll(validators.validate(receiveEvent)); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { logDebug( validation failed on {} c.name()); messages.addAll(e.getMessages()); reject(cmd, e.getMessage()); return false; } validCommits.add(c.copy()); return true; }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, ctx.getProject()<START_MOD>, change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx<END_MOD>.getProject(), <START_MOD>refName), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo<END_MOD>(), ctx.getRevWalk()<START_MOD>).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw<END_MOD> new com.google.gerrit.<START_MOD>extensions.restapi.ResourceConflictException(e.getFullMessage()<END_MOD>); } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (checkAddPatchSetPermission) { permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(<START_MOD>origNotes<END_MOD>).check(ChangePermission.ADD_PATCH_SET); } if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(<START_MOD>origNotes<END_MOD>.getChange().getDest()); java.lang.String refName = getPatchSetId().toRefName(); try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commitId, ((refName.substring(0, ((refName.lastIndexOf('/')) + 1))) + "new")), <START_MOD>origNotes.getProjectName(), origNotes.getChange().getDest().get<END_MOD>(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, <START_MOD>origNotes.getChange().getDest(), ctx.getIdentifiedUser(), <END_MOD>new com.google.gerrit.<START_MOD>server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw<END_MOD> new com.google.gerrit.<START_MOD>extensions.restapi.ResourceConflictException(e.getFullMessage()<END_MOD>); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRef(receiveEvent.refName); if (accountId == null) { return java.util.Collections.emptyList(); } try { java.util.List<java.lang.String> errorMessages = accountValidator.validate(accountId, receiveEvent.revWalk, receiveEvent.command.getOldId(), receiveEvent.commit); if (!(errorMessages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException( account configuration errorMessages.stream().map(( m) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(m, true)).collect(java.util.stream.Collectors.toList())); } } catch (java.io.IOException e) { java.lang.String m = java.lang.String.format( update for account %s failed accountId.get()); com.google.gerrit.server.git.validators.CommitValidators.log.error(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } return java.util.Collections.emptyList(); }
@java.lang.Override public Project.NameKey getProjectNameKey() { return project; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(<START_MOD>com.google.gerrit.server.events.<END_MOD>CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if ((allUsers.equals(receiveEvent.project)) && (RefNames.REFS_EXTERNAL_IDS.equals(receiveEvent.refName))) { try { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = externalIdsConsistencyChecker.check(receiveEvent.commit); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> msgs = problems.stream().map(( p) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(p.message, (p.status == ConsistencyProblemInfo.Status.ERROR))).collect(java.util.stream.Collectors.toList()); if (msgs.stream().anyMatch(( m) -> m.isError())) { throw new com.google.gerrit.server.git.validators.CommitValidationException( external IDs msgs); } return msgs; } catch (java.io.IOException e) { java.lang.String m =   validating external IDs com.google.gerrit.server.git.validators.CommitValidators.log.warn(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } } return java.util.Collections.emptyList(); }
private void assertNoProblems(com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> <START_MOD>notes<END_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix) <START_MOD>throws com.google.gerrit.server.project.NoSuchChangeException <END_MOD>{ assertThat(checker.check(<START_MOD>controlForNotes(notes)<END_MOD>, fix).problems()).isEmpty(); }
<START_MOD>private com.google.gerrit.server.project.ChangeControl controlForNotes(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.server.project.NoSuchChangeException { return changeControlFactory.controlFor(notes, userFactory.create(admin.id)); }<END_MOD>
private com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> incrementPatchSet(com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> <START_MOD>notes<END_MOD>, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { com.google.gerrit.server.change.PatchSetInserter ins; try (com.google.gerrit.server.update.BatchUpdate bu = newUpdate(<START_MOD>notes<END_MOD>.getChange().getOwner())) { ins = patchSetInserterFactory.create(<START_MOD>controlForNotes(notes)<END_MOD>, nextPatchSetId(<START_MOD>notes<END_MOD>), commit).setValidate(false).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE); bu.addOp(<START_MOD>notes<END_MOD>.<START_MOD>getChangeId<END_MOD>(), ins).execute(); } return reload(<START_MOD>notes<END_MOD>); }
private void assertProblems(com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> <START_MOD>notes<END_MOD>, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix, com.google.gerrit.extensions.common.ProblemInfo first, com.google.gerrit.extensions.common.ProblemInfo... rest)<START_MOD> throws com.google.gerrit.server.project.NoSuchChangeException<END_MOD> { java.util.List<com.google.gerrit.extensions.common.ProblemInfo> expected = new java.util.ArrayList((1 + (rest.length))); expected.add(first); expected.addAll(java.util.Arrays.asList(rest)); assertThat(checker.check(<START_MOD>controlForNotes(notes)<END_MOD>, fix).problems()).containsExactlyElementsIn(expected).inOrder(); }
@org.junit.Test public void missingRepo() throws java.lang.Exception { assumeNoteDbDisabled(); com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD> <START_MOD>notes<END_MOD> = insertChange(); com.google.gerrit.reviewdb.client.Project.NameKey name = <START_MOD>notes<END_MOD>.<START_MOD>getProjectName<END_MOD>(); ((com.google.gerrit.testutil.InMemoryRepositoryManager) (repoManager)).deleteRepository(name); assertProblems(<START_MOD>notes<END_MOD>, null, com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem(( repository not found:   + name))); }
private void setUpChange() throws java.lang.Exception { change = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new com.google.gerrit.reviewdb.client.Change.Id(1), userId, new com.google.gerrit.reviewdb.client.Branch.NameKey(allProjects, "refs/heads/master"), com.google.gerrit.common.TimeUtil.nowTs()); <START_MOD>notes = changeNotesFactory.createFromIndexedChange(change); <END_MOD>com.google.gerrit.reviewdb.client.PatchSetInfo ps = new com.google.gerrit.reviewdb.client.PatchSetInfo(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 1)); ps.setSubject( change change.setCurrentPatchSet(ps); db.changes().insert(com.google.common.collect.ImmutableList.of(change)); }
private java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> asChangeControls(java.util.List<com.google.gerrit.server.query.change.ChangeData> cds) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes> notes<END_MOD> = new java.util.ArrayList(cds.size()); if (!(indexConfig.separateChangeSubIndexes())) { for (com.google.gerrit.server.query.change.ChangeData cd : cds) { <START_MOD>notes.add(cd.notes()<END_MOD>); } return <START_MOD>notes<END_MOD>; } java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> seen = com.google.common.collect.Sets.newHashSetWithExpectedSize(cds.size()); for (com.google.gerrit.server.query.change.ChangeData cd : cds) { if (seen.add(cd.getId())) { <START_MOD>notes.add(cd.notes()<END_MOD>); } } return <START_MOD>notes; }<END_MOD>
private com.google.gerrit.server.change.ChangeResource parseResource(com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { java.util.List<com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD>> <START_MOD>notes<END_MOD> = changeFinder.find(r.getChangeId()); assertThat(<START_MOD>notes<END_MOD>).hasSize(1); return changeResourceFactory.create(<START_MOD>changeControlFactory.controlFor(notes<END_MOD>.get(0)<START_MOD>, atrScope.get().getUser())<END_MOD>); }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> <START_MOD>notes<END_MOD> = changeFinder.find(id.encoded()<START_MOD>); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(changeControlFactory.controlFor(change<END_MOD>, user.get())); }
private java.util.List<com.google.gerrit.server.<START_MOD>notedb<END_MOD>.<START_MOD>ChangeNotes<END_MOD>> changeFromNotesFactory(java.lang.String id) throws com.google.gerrit.sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { return changeNotesFactory.create(db, parseId(id)).stream().collect(java.util.stream.Collectors.toList()); }
public java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(id.substring(0, z), n.intValue()); } } if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return find(new com.google.gerrit.reviewdb.client.Change.Id(n)); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeControls(query.byBranchKey(t.branch(), t.id())); } } return asChangeControls(query.byKeyPrefix(id)<START_MOD>); }<END_MOD>
private java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> fromProjectNumber(<START_MOD>java.lang.String project, int changeNumber) throws com.google.gwtorm.server.OrmException { <END_MOD>com.google.gerrit.<START_MOD>reviewdb.client.Change.Id cId = new com.google.gerrit.reviewdb.client.Change.Id(changeNumber); try { return com.google.common.collect.ImmutableList.of(changeNotesFactory.createChecked(reviewDb.get()<END_MOD>, <START_MOD>Project.NameKey.parse(project)<END_MOD>, cId)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return java.util.Collections.emptyList(); } catch (java.lang.IllegalArgumentException e) { java.lang.String changeNotFound = java.lang.String.format( %s not found in ReviewDb cId); java.lang.String projectNotFound = java.lang.String.format( project %s when creating ChangeNotes for %s, but actual project is project, cId); if ((e.getMessage().equals(changeNotFound)) || (e.getMessage().startsWith(projectNotFound))) { return java.util.Collections.emptyList(); } throw e; } catch (com.google.gwtorm.server.OrmException e) { if ((com.google.common.base.Throwables.getRootCause(e)) instanceof org.eclipse.jgit.errors.RepositoryNotFoundException) { return java.util.Collections.emptyList(); } throw e; } }
public java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> find(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gwtorm.server.OrmException { java.lang.String project = changeIdProjectCache.getIfPresent(id); if (project != null) { return fromProjectNumber(project, id.get()); } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); java.util.List<com.google.gerrit.server.query.change.ChangeData> r = query.byLegacyChangeId(id); if ((r.size()) == 1) { changeIdProjectCache.put(id, r.get(0).project().get()); } return asChangeControls(r); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.<START_MOD>notedb.ChangeNotes<END_MOD>> <START_MOD>notes<END_MOD> = changeFinder.find(id<START_MOD>); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(changeControlFactory.controlFor(change<END_MOD>, user.get())); }
<START_MOD>private java.lang.String formatChangeUrl(java.lang.String url, com.google.gerrit.server.git.Input input) { com.google.gerrit.reviewdb.client.Change change = input.getChange(); java.lang.StringBuilder m = new java.lang.StringBuilder().append(" ").append(com.google.gerrit.server.ChangeUtil.formatChangeUrl(url, change)).append(" ").append(com.google.gerrit.server.ChangeUtil.cropSubject(input.getSubject())); if (input.isDraft()) { m.append(" [DRAFT]"); } if (input.isEdit()) { m.append(" [EDIT]"); } if (change.isPrivate()) { m.append(" [PRIVATE]"); } if (change.isWorkInProgress()) { m.append(" [WIP]"); } return m.toString(); }<END_MOD>
@java.lang.Override public org.eclipse.jgit.lib.Config get() { org.eclipse.jgit.storage.file.FileBasedConfig <START_MOD>baseConfig<END_MOD> = new org.eclipse.jgit.storage.file.FileBasedConfig(site.gerrit_config.toFile(), org.eclipse.jgit.util.FS.DETECTED); <START_MOD>org.eclipse.jgit.storage.file.FileBasedConfig noteDbConfigOverBaseConfig = new org.eclipse.jgit.storage.file.FileBasedConfig(baseConfig, site.notedb_config.toFile(), org.eclipse.jgit.util.FS.DETECTED); <END_MOD>if (!(<START_MOD>baseConfig<END_MOD>.getFile().exists())) { com.google.gerrit.server.config.GerritServerConfigProvider.log.info(((   + (site.gerrit_config.toAbsolutePath())) +   assuming defaults <START_MOD>} else { com.google.gerrit.server.config.GerritServerConfigProvider.load(baseConfig); } if (noteDbConfigOverBaseConfig.getFile().exists()) { com.google.gerrit.server.config.GerritServerConfigProvider.load(noteDbConfigOverBaseConfig); com.google.gerrit.server.config.GerritServerConfigProvider.checkNoteDbConfig(noteDbConfigOverBaseConfig); } <END_MOD>return new com.google.gerrit.server.config.GerritConfig(<START_MOD>noteDbConfigOverBaseConfig, baseConfig<END_MOD>, secureStore); }
<START_MOD>private com.google.gerrit.acceptance.MergeableFileBasedConfig newConfig() { return new com.google.gerrit.acceptance.MergeableFileBasedConfig(new java.io.File(com.google.gerrit.acceptance.MergeableFileBasedConfigTest.tempDir, ((com.google.gerrit.acceptance.MergeableFileBasedConfigTest.counter.incrementAndGet()) + ".config")), org.eclipse.jgit.util.FS.detect()); }<END_MOD>
<START_MOD>private static void load(org.eclipse.jgit.storage.file.FileBasedConfig cfg) { try { cfg.load(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.inject.ProvisionException(e.getMessage(), e); } }<END_MOD>
<START_MOD>@<END_MOD>com.google.gerrit.<START_MOD>common<END_MOD>.<START_MOD>Nullable<END_MOD> <START_MOD>public abstract <END_MOD>java.lang.<START_MOD>Boolean<END_MOD> <START_MOD>wip(<END_MOD>);
<START_MOD>@<END_MOD>com.google.gerrit.<START_MOD>common<END_MOD>.<START_MOD>Nullable public abstract java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Boolean<END_MOD> edit<START_MOD>(<END_MOD>);
<START_MOD>@<END_MOD>com.google.gerrit.<START_MOD>common<END_MOD>.<START_MOD>Nullable public abstract java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Boolean<END_MOD> draft<START_MOD>(<END_MOD>);
public com.google.gerrit.reviewdb.client.Change getChange() { return change<START_MOD>()<END_MOD>; }
private boolean requestReplace(org.eclipse.jgit.transport.ReceiveCommand cmd, boolean checkMergedInto, com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.revwalk.RevCommit newCommit) { if (change.getStatus().isClosed()) { reject(cmd, changeFormatter.changeClosed(<START_MOD>ChangeReportFormatter.Input.builder().change(change).build())); return false; } com.google.gerrit.server.git.receive.ReceiveCommits.ReplaceRequest req = <END_MOD>new com.google.gerrit.server.git.<START_MOD>receive.ReceiveCommits.ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); if (replaceByChange.containsKey(req.ontoChange)) { reject(cmd,   request<END_MOD> return false; } replaceByChange.<START_MOD>put<END_MOD>(req.ontoChange<START_MOD>, req);<END_MOD> return <START_MOD>true<END_MOD>; }
<START_MOD>@<END_MOD>com.google.gerrit.<START_MOD>common<END_MOD>.<START_MOD>Nullable public abstract java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Boolean<END_MOD> <START_MOD>_private<END_MOD>();
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(db.get(), revision.<START_MOD>getNotes(), revision.getUser<END_MOD>()); return new java.util.HashSet(changeData.filePaths(revision.getPatchSet())); }
public Change.Id getId() { return <START_MOD>getNotes()<END_MOD>.<START_MOD>getChangeId<END_MOD>(); }
public boolean isUserOwner() { com.google.gerrit.reviewdb.client.Account.Id owner = getChange().getOwner(); return (<START_MOD>getUser()<END_MOD>.isIdentifiedUser()) && (<START_MOD>getUser()<END_MOD>.asIdentifiedUser().getAccountId().equals(owner)); }
@java.lang.Override public java.lang.String getETag() { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(<START_MOD>getUser()<END_MOD>.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, <START_MOD>getUser()<END_MOD>); return h.hash().toString(); }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException( rules are disabled } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.<START_MOD>getNotes(), rsrc.getUser<END_MOD>())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( %s produced invalid result: %s evaluator.getSubmitRuleName(), rec)); } return rec.type; }
private boolean isReviewer(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { if (ctx.getAccountId().equals(ctx.getChange().getOwner())) { return true; } com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), ctx.<START_MOD>getNotes(), ctx.getUser<END_MOD>()); com.google.gerrit.server.ReviewerSet reviewers = cd.reviewers(); if (reviewers.byState(com.google.gerrit.server.change.REVIEWER).contains(ctx.getAccountId())) { return true; } return false; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException( rules are disabled } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.<START_MOD>getNotes(), rsrc.getUser<END_MOD>())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(ctl);org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl<START_MOD>.getNotes(), ctl.getUser()<END_MOD>), in, repo, rw, true, null); accountLoader.fill(); return rev; } }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.<START_MOD>reviewdb.client.Project.NameKey <END_MOD>project = rsrc.getRevision().<START_MOD>getProject<END_MOD>(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(<START_MOD>projectCache.checkedGet(project)<END_MOD>, revstr, path, parent); }
public com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), rsrc.<START_MOD>getNotes(), rsrc.getUser<END_MOD>()); return format(cd, java.util.Optional.of(rsrc.getPatchSet().getId()), true); }
public PermissionBackend.ForChange permissions() { return permissionBackend.user(getUser()).change(getNotes()); }
public com.google.gerrit.reviewdb.client.Change getChange() { return <START_MOD>getNotes()<END_MOD>.getChange(); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { <START_MOD>return getPureRevert(rsrc<END_MOD>.<START_MOD>getNotes<END_MOD>(), rsrc.<START_MOD>getUser<END_MOD>()); }
<START_MOD>private void pushPureRevertSubmitRule() throws java.lang.Exception { java.lang.String oldHead = getRemoteHead().name(); com.google.gerrit.acceptance.GitUtil.fetch(testRepo, ((com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG) + ":config")); testRepo.reset("config"); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Configure", "rules.pl", ("submit_rule(submit(R)) :- \n" + ((((((("gerrit:pure_revert(1), \n" + "!,") + "gerrit:commit_author(A), \n") + "R = label(\'Is-Pure-Revert\', ok(A)).\n") + "submit_rule(submit(R)) :- \n") + "gerrit:pure_revert(U), \n") + "U \\= 1,") + "R = label(\'Is-Pure-Revert\', need(_)). \n\n"))); push.to(RefNames.REFS_CONFIG); testRepo.reset(oldHead); }<END_MOD>
<START_MOD>@com.google.gerrit.common.Nullable public java.lang.Boolean isPureRevert() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getPureRevert(notes(), userFactory.create(change().getOwner())).isPureRevert; } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new com.google.gwtorm.server.OrmException("could not compute pure revert", e); } }<END_MOD>
<START_MOD>@com.google.gerrit.acceptance.Sandboxed @org.junit.Test public void pureRevertFactAllowsSubmissionOfPureReverts() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master"); merge(r1); pushPureRevertSubmitRule(); java.lang.String revertId = gApi.changes().id(r1.getChangeId()).revert().get().changeId; approve(revertId); gApi.changes().id(revertId).current().submit(); }<END_MOD>
<START_MOD>@com.google.gerrit.acceptance.Sandboxed @org.junit.Test public void pureRevertFactBlocksSubmissionOfNonPureReverts() throws java.lang.Exception { pushPureRevertSubmitRule(); com.google.gerrit.acceptance.PushOneCommit.Result r1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master"); approve(r1.getChangeId()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(("Failed to submit 1 change due to the following problems:\n" + "Change 1: needs Is-Pure-Revert")); gApi.changes().id(r1.getChangeId()).current().submit(); }<END_MOD>
private java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> getMembers(final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seenGroups) throws com.google.gwtorm.server.OrmException { seenGroups.add(groupUUID); final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> members = new java.util.HashMap<>(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupUUID); if (group == null) { return java.util.Collections.emptyMap(); } final com.google.gerrit.common.data.GroupDetail groupDetail; try { groupDetail = groupDetailFactory.create(group.getGroupUUID()).call(); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { return java.util.Collections.emptyMap(); } for (com.google.gerrit.reviewdb.client.Account.Id member : groupDetail.getMembers()) { if (!(members.containsKey(member))) { members.put(member, accountLoader.get(member)); } } if (recursive) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID <START_MOD>subgroupUuid<END_MOD> : groupDetail.<START_MOD>getSubgroups<END_MOD>()) { if (!(seenGroups.contains(<START_MOD>subgroupUuid<END_MOD>))) { members.putAll(getMembers(<START_MOD>subgroupUuid<END_MOD>, seenGroups)); } } } accountLoader.fill(); return members; }
private void <START_MOD>addSubgroups<END_MOD>(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.<START_MOD>AddSubgroups<END_MOD>.Input input = <START_MOD>AddSubgroups<END_MOD>.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).collect(java.util.stream.Collectors.toList())); <START_MOD>addSubgroups<END_MOD>.apply(rsrc, input); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(final com.google.gerrit.reviewdb.client.AccountGroup group, com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { seen.add(group.getGroupUUID()); final com.google.gerrit.common.data.GroupDetail groupDetail = groupDetailFactory.create(group.getGroupUUID()).call(); final java.util.Set<com.google.gerrit.reviewdb.client.Account> members = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account.Id memberId : groupDetail.getMembers()) { members.add(accountCache.get(memberId).getAccount()); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID <START_MOD>subgroupUuid<END_MOD> : groupDetail.<START_MOD>getSubgroups<END_MOD>()) { com.google.gerrit.reviewdb.client.AccountGroup <START_MOD>subgroup<END_MOD> = groupCache.get(<START_MOD>subgroupUuid<END_MOD>); if ((<START_MOD>subgroup<END_MOD> != null) && (!(seen.contains(<START_MOD>subgroup<END_MOD>.getGroupUUID())))) { members.addAll(listAccounts(<START_MOD>subgroup<END_MOD>.getGroupUUID(), project, seen)); } } return members; }
public void <START_MOD>removeSubgroups<END_MOD>(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> <START_MOD>subgroupUuids<END_MOD>) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> <START_MOD>subgroupsToRemove<END_MOD> = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID <START_MOD>subgroupUuid<END_MOD> : <START_MOD>subgroupUuids<END_MOD>) { boolean <START_MOD>isSubgroup<END_MOD> = groups.<START_MOD>isSubgroup<END_MOD>(db, parentGroupUuid, <START_MOD>subgroupUuid<END_MOD>); if (<START_MOD>isSubgroup<END_MOD>) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, <START_MOD>subgroupUuid); subgroupsToRemove<END_MOD>.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (<START_MOD>subgroupsToRemove<END_MOD>.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), <START_MOD>subgroupsToRemove<END_MOD>); } db.accountGroupById().delete(<START_MOD>subgroupsToRemove<END_MOD>); for (com.google.gerrit.reviewdb.client.AccountGroupById groupToRemove : <START_MOD>subgroupsToRemove<END_MOD>) { groupIncludeCache.evictParentGroupsOf(groupToRemove.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }
public void <START_MOD>addSubgroups<END_MOD>(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> <START_MOD>subgroupUuids<END_MOD>) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> <START_MOD>newSubgroups<END_MOD> = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid : <START_MOD>subgroupUuids<END_MOD>) { boolean <START_MOD>isSubgroup<END_MOD> = groups.<START_MOD>isSubgroup<END_MOD>(db, parentGroupUuid, includedGroupUuid); if (!<START_MOD>isSubgroup<END_MOD>) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, includedGroupUuid); <START_MOD>newSubgroups<END_MOD>.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (<START_MOD>newSubgroups<END_MOD>.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), <START_MOD>newSubgroups<END_MOD>); } db.accountGroupById().insert(<START_MOD>newSubgroups<END_MOD>); for (com.google.gerrit.reviewdb.client.AccountGroupById newIncludedGroup : <START_MOD>newSubgroups<END_MOD>) { groupIncludeCache.evictParentGroupsOf(newIncludedGroup.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }
<START_MOD>@java.lang.Override public com.googlesource.gerrit.plugins.oauth.Verb getAccessTokenVerb() { return Verb.POST; }<END_MOD>
<START_MOD>@java.lang.Override public com.googlesource.gerrit.plugins.oauth.Token getAccessToken(com.googlesource.gerrit.plugins.oauth.Token requestToken, com.googlesource.gerrit.plugins.oauth.Verifier verifier) { com.googlesource.gerrit.plugins.oauth.OAuthRequest request = new com.googlesource.gerrit.plugins.oauth.OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint()); request.addBodyParameter(OAuthConstants.CLIENT_ID, config.getApiKey()); request.addBodyParameter(OAuthConstants.CLIENT_SECRET, config.getApiSecret()); request.addBodyParameter(OAuthConstants.CODE, verifier.getValue()); request.addBodyParameter(OAuthConstants.REDIRECT_URI, config.getCallback()); if (config.hasScope()) { request.addBodyParameter(OAuthConstants.SCOPE, config.getScope()); } request.addBodyParameter(com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService.GRANT_TYPE, com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService.GRANT_TYPE_VALUE); com.googlesource.gerrit.plugins.oauth.Response response = request.send(); return api.getAccessTokenExtractor().extract(response.getBody()); }<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String getAuthorizationUrl(com.googlesource.gerrit.plugins.oauth.Token requestToken) { return api.getAuthorizationUrl(config); }<END_MOD>
<START_MOD>@java.lang.Override public void signRequest(com.googlesource.gerrit.plugins.oauth.Token accessToken, com.googlesource.gerrit.plugins.oauth.OAuthRequest request) { request.addQuerystringParameter(OAuthConstants.ACCESS_TOKEN, accessToken.getToken()); }<END_MOD>
<START_MOD>@java.lang.Override public com.googlesource.gerrit.plugins.oauth.Token getRequestToken() { throw new java.lang.UnsupportedOperationException("Unsupported operation, please use 'getAuthorizationUrl' and redirect your users there"); }<END_MOD>
<START_MOD>@java.lang.Override public org.scribe.oauth.OAuthService createService(com.googlesource.gerrit.plugins.oauth.OAuthConfig config) { return new com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService(this, config); }<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String getAuthorizationUrl(com.googlesource.gerrit.plugins.oauth.OAuthConfig config) { return java.lang.String.format(com.googlesource.gerrit.plugins.oauth.DexApi.AUTHORIZE_URL, rootUrl, config.getApiKey(), org.scribe.utils.OAuthEncoder.encode(config.getCallback()), config.getScope().replaceAll(" ", "+")); }<END_MOD>
private void loadPublished(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, java.lang.String file) throws com.google.gwtorm.server.OrmException { <START_MOD>for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByChangeFile(db,<END_MOD> notes<START_MOD>, changeId, file)) { comments.include(change.getId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId<END_MOD> = <START_MOD>new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null<END_MOD>) { p.setCommentCount(((p.getCommentCount()) + 1)); } } }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(<START_MOD>notes<END_MOD>); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(change.getId()); }
private void loadDrafts(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.String file) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByChangeFileAuthor(db, <START_MOD>notes<END_MOD>, file, me)) { comments.include(change.getId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null) { p.setDraftCount(((p.getDraftCount()) + 1)); } } }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); oldTopicName = com.google.common.base.Strings.nullToEmpty(change.getTopic()); if (oldTopicName.equals(newTopicName)) { return false; } java.lang.String summary; if (oldTopicName.isEmpty()) { summary =   set to   + (newTopicName); } else if (newTopicName.isEmpty()) { summary = (   + (oldTopicName)) +   removed } else { summary = java.lang.String.format( changed from %s to %s oldTopicName, newTopicName); } change.setTopic(com.google.common.base.Strings.emptyToNull(newTopicName)); <START_MOD>com.google.gerrit.server.notedb.ChangeUpdate <END_MOD>update<START_MOD> = ctx.getUpdate(change.currentPatchSetId()); update<END_MOD>.setTopic(change.getTopic()); com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.TAG_SET_TOPIC); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); return true; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.server.change.PutTopic.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); <START_MOD>java.lang.String newTopicName = (input == null) ? "" : com.google.common.base.Strings.nullToEmpty(input.topic); if ((newTopicName.length()) > (<END_MOD>com.google.gerrit.server.change.PutTopic.<START_MOD>MAX_TOPIC_LENGTH)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( length exceeds the limit (%s) com.google.gerrit.server.change.PutTopic.MAX_TOPIC_LENGTH)); } com.google.gerrit.server.change.PutTopic.<END_MOD>Op op = new com.google.gerrit.server.change.PutTopic.Op(<START_MOD>newTopicName); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName)<END_MOD> ? <START_MOD>com.google.gerrit.extensions.restapi.Response.none()<END_MOD> : <START_MOD>com.google.gerrit.extensions.restapi.Response.ok(<END_MOD>op<START_MOD>.newTopicName<END_MOD>); }
<START_MOD>public static boolean isDefaultDashboard(com.google.gerrit.extensions.restapi.IdString id) { return (id != null) && (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id.toString())); }<END_MOD>
<START_MOD>public static boolean isDefaultDashboard(java.lang.String id) { return (id != null) && (id.equals(com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME)); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo get(boolean inherited) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.project.GetDashboard impl = getDashboard.get(); impl.setInherited(inherited); return impl.apply(resource()); } catch (java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot read dashboard", e); } }<END_MOD>
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectControl ctl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = ctl.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = ctl.getProject().getDefaultDashboard(); } if (<START_MOD>com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME<END_MOD>.equals(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(ctl, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : ctl.getProjectState().tree()) { id = ps.getProject().getDefaultDashboard(); if (<START_MOD>com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME<END_MOD>.equals(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { ctl = ps.controlFor(ctl.getUser()); return parse(ctl, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.project.ProjectControl myCtl = parent.getControl(); if (id.toString().equals(<START_MOD>com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME<END_MOD>)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(myCtl); } java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id.get())); if ((parts.size()) != 2) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.CurrentUser user = myCtl.getUser(); java.lang.String ref = parts.get(0); java.lang.String path = parts.get(1); for (com.google.gerrit.server.project.ProjectState ps : myCtl.getProjectState().tree()) { try { return parse(ps.controlFor(user), ref, path, myCtl); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (id.toString().equals(<START_MOD>com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME<END_MOD>)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
<START_MOD>@org.kohsuke.args4j.Option(name = "--inherited", usage = "include inherited dashboards") public void setInherited(boolean inherited) { this.inherited = inherited; }<END_MOD>
private void attemptToMergeAtomic(com.criteo.gerrit.plugins.automerge.Change change) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { final java.util.List<com.google.gerrit.extensions.common.ChangeInfo> related = com.google.common.collect.Lists.newArrayList(); related.addAll(api.changes().query(( open AND topic:   + (change.topic))).withOption(ListChangesOption.CURRENT_REVISION).get()); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { if (!(atomicityHelper.isSubmittable(info.project, info._number))) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info( {} is not submittable because same topic change {} has not all approvals. change.number, info._number); return; } } for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { boolean dependsOnNonMergedCommit = atomicityHelper.hasDependentReview(info.project, info._number); if ((!(info.mergeable)) || dependsOnNonMergedCommit) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info( {} is not mergeable because same topic change {} {} change.number, info._number, (!(info.mergeable) ?   non mergeable :   on a non merged commit. if (!(info.mergeable)) { reviewUpdater.commentOnReview(change.project, change.number, <START_MOD>config.cantMergeGitConflict<END_MOD>); } return; } } com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info( atomic change {}... change.number); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { atomicityHelper.mergeReview(info.project, info._number); } }
public void commentOnReview(java.lang.String project, int number, <START_MOD>com<END_MOD>.<START_MOD>criteo<END_MOD>.<START_MOD>gerrit.plugins.automerge.PluginComment<END_MOD> <START_MOD>pluginComment<END_MOD>) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput comment = createComment(<START_MOD>pluginComment<END_MOD>); applyComment(project, number, comment); }
private com.google.gerrit.extensions.api.changes.ReviewInput createComment(<START_MOD>com.criteo.gerrit.plugins.automerge.PluginComment<END_MOD> <START_MOD>pluginComment<END_MOD>) { return new com.google.gerrit.extensions.api.changes.ReviewInput().message(((com.criteo.gerrit.plugins.automerge.ReviewUpdater.commentsPrefix) + (<START_MOD>pluginComment.getCommentContent<END_MOD>()))); }
<START_MOD>java.lang.String getCommentContent() { if (templatePath.exists()) { try { return com.google.common.io.Files.toString(templatePath, Charsets.UTF_8); } catch (final java.io.IOException exc) { com.criteo.gerrit.plugins.automerge.PluginComment.log.error(("Not able to read " + (templatePath)), exc); } } return defaultMessage; }<END_MOD>
public void setMinusOne(java.lang.String project, int number, <START_MOD>com<END_MOD>.<START_MOD>criteo<END_MOD>.<START_MOD>gerrit.plugins.automerge.PluginComment<END_MOD> <START_MOD>pluginComment<END_MOD>) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput message = createComment(<START_MOD>pluginComment<END_MOD>).label("Code-Review", (-1)); applyComment(project, number, message); }
private void processNewAtomicPatchSet(com.criteo.gerrit.plugins.automerge.Change change) { try { checkReviewExists(change.number); if (atomicityHelper.hasDependentReview(change.project, change.number)) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format( the user by setting -1 on change %d, as other atomic changes exists on the same repository. change.number)); reviewUpdater.setMinusOne(change.project, change.number, <START_MOD>config.atomicReviewsSameRepo<END_MOD>); } else { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format( atomic review on change %d. change.number)); reviewUpdater.commentOnReview(change.project, change.number, <START_MOD>config.atomicReviewDetected<END_MOD>); } } catch (com.google.gerrit.extensions.restapi.RestApiException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException e) { throw new java.lang.RuntimeException(e); } }
public void ignore(com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>change<END_MOD>.<START_MOD>ChangeResource<END_MOD> <START_MOD>rsrc<END_MOD>) throws com.google.gwtorm.server.OrmException { star(<START_MOD>rsrc.getUser().getAccountId()<END_MOD>, <START_MOD>rsrc.getProject()<END_MOD>, <START_MOD>rsrc.getChange().getId()<END_MOD>, com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL), com.google.common.collect.ImmutableSet.of()); }
public void unignore(com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>change<END_MOD>.<START_MOD>ChangeResource<END_MOD> <START_MOD>rsrc<END_MOD>) throws com.google.gwtorm.server.OrmException { star(<START_MOD>rsrc.getUser().getAccountId()<END_MOD>, <START_MOD>rsrc.getProject()<END_MOD>, <START_MOD>rsrc.getChange().getId()<END_MOD>, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.Mute.Input input) throws com.google.gerrit.server.StarredChangesUtil.IllegalLabelException, com.google.gwtorm.server.OrmException { if ((rsrc.isUserOwner()) || (isMuted(rsrc.getChange()))) { return com.google.gerrit.extensions.restapi.Response.ok(""); } stars.mute(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange()); return com.google.gerrit.extensions.restapi.Response.ok(""); }
static java.util.Set<java.lang.String> extractTags(java.util.Set<java.lang.String> input) throws <START_MOD>com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagsException<END_MOD> { if (input == null) { return java.util.Collections.emptySet(); } java.util.HashSet<java.lang.String> result = new java.util.HashSet<>(); for (java.lang.String hashtag : input) { if (hashtag.contains(",")) { throw <START_MOD>com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagsException.hashtagsMayNotContainCommas();<END_MOD> } hashtag = com.google.gerrit.server.change.HashtagsUtil.cleanupHashtag(hashtag); if (!(hashtag.isEmpty())) { result.add(hashtag); } } return result; }
<START_MOD>static com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagsException hashtagsMayNotContainCommas() { return new com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagsException("hashtags may not contain commas"); }<END_MOD>
@org.junit.Test public void dashboardDoesNotExist() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name(project.get()).dashboard(<START_MOD>"default:dashboard"<END_MOD>).get(); }
<START_MOD>@java.lang.Override public com.google.gerrit.extensions.api.config.AccessCheckInfo checkAccess(com.google.gerrit.extensions.api.config.AccessCheckInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return checkAccess.apply(checkExists(), in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot post check access", e); } }<END_MOD>
@org.junit.Test public void invalidInputs() { java.util.List<com.google.gerrit.extensions.api.config.AccessCheckInput> inputs = com.google.common.collect.ImmutableList.of(new com.google.gerrit.extensions.api.config.AccessCheckInput(), new com.google.gerrit.extensions.api.config.AccessCheckInput(user.email, null<START_MOD>), new com.google.gerrit.extensions.api.config.AccessCheckInput(null<END_MOD>, null), new com.google.gerrit.extensions.api.config.AccessCheckInput("doesnotexist@invalid.com", null)); for (com.google.gerrit.extensions.api.config.AccessCheckInput input : inputs) { try { gApi.config().server().checkAccess(input); fail(java.lang.String.format( RestApiException for %s newGson().toJson(input))); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { } } }
<START_MOD>static com.google.gerrit.acceptance.rest.project.CheckAccessIT.TestCase newTestInput(java.lang.String mail, java.lang.String project, java.lang.String ref, int want) { com.google.gerrit.acceptance.rest.project.CheckAccessIT.TestCase tc = new com.google.gerrit.acceptance.rest.project.CheckAccessIT.TestCase(); tc.input = new com.google.gerrit.extensions.api.config.AccessCheckInput(mail, ref); tc.project = project; tc.want = want; return tc; }<END_MOD>
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException<END_MOD> { if (!visible) { return <START_MOD>projectCache.checkedGet(cd.project()<END_MOD>).getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((( to get submit type for   + (cd.getId())) +     + (str.errorMessage))); } return str.type; }
<START_MOD>public<END_MOD> java.lang.String <START_MOD>normalizeDashboardRef(<END_MOD>java.lang.String <START_MOD>ref<END_MOD>) { if (!(ref.startsWith(com.google.gerrit.server.project.REFS_DASHBOARDS))) { <START_MOD>return<END_MOD> (REFS_DASHBOARDS) + ref; } <START_MOD>return<END_MOD> ref; }
<START_MOD>private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.extensions.api.projects.DashboardInfo info, com.google.gerrit.server.project.ProjectControl myCtl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.AmbiguousObjectException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.IncorrectObjectTypeException { java.lang.String ref = normalizeDashboardRef(info.ref); try { permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(ref))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(ctl.getProject().getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.project.DashboardResource(myCtl, ref, info.path, cfg, false); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } }<END_MOD>
private boolean canImport() { com.google.gerrit.server.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackend.WithUser<END_MOD> <START_MOD>withUser<END_MOD> = <START_MOD>permissionBackend.user(<END_MOD>userProvider.get()); return (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>GlobalPermission.ADMINISTRATE_SERVER<END_MOD>)) || (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>new com.google.gerrit.extensions.api.access.PluginPermission<END_MOD>(pluginName<START_MOD>,<END_MOD> ImportCapability.ID))); }
private boolean canCompleteImport(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackend.WithUser<END_MOD> <START_MOD>withUser<END_MOD> = <START_MOD>permissionBackend.user(<END_MOD>currentUserProvider.get()); return (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>GlobalPermission.ADMINISTRATE_SERVER<END_MOD>)) || ((<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>new com.google.gerrit.extensions.api.access.PluginPermission<END_MOD>(pluginName<START_MOD>,<END_MOD> ImportCapability.ID))) && (rsrc.getControl().isOwner())); }
private boolean canCopy(<START_MOD>com.google.gerrit.server.project.ProjectResource rsrc<END_MOD>) { com.google.gerrit.server.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackend.WithUser<END_MOD> <START_MOD>withUser<END_MOD> = <START_MOD>permissionBackend.user(<END_MOD>currentUserProvider.get()); return (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>GlobalPermission.ADMINISTRATE_SERVER<END_MOD>)) || (<START_MOD>(withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>new com.google.gerrit.extensions.api.access.PluginPermission<END_MOD>(pluginName<START_MOD>,<END_MOD> CopyProjectCapability.ID)))<START_MOD> && (rsrc.getControl().isOwner())<END_MOD>); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Copy...").setTitle(java.lang.String.format( project %s rsrc.getName())).setVisible(canCopy(<START_MOD>rsrc<END_MOD>)); }
private boolean canResumeCopy(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackend.WithUser<END_MOD> <START_MOD>withUser<END_MOD> = <START_MOD>permissionBackend.user(<END_MOD>currentUserProvider.get()); return (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>GlobalPermission.ADMINISTRATE_SERVER<END_MOD>)) || ((<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>new com.google.gerrit.extensions.api.access.PluginPermission<END_MOD>(pluginName<START_MOD>,<END_MOD> CopyProjectCapability.ID))) && (rsrc.getControl().isOwner())); }
private boolean canResumeImport(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackend.WithUser<END_MOD> <START_MOD>withUser<END_MOD> = <START_MOD>permissionBackend.user(<END_MOD>currentUserProvider.get()); return (<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>GlobalPermission.ADMINISTRATE_SERVER<END_MOD>)) || ((<START_MOD>withUser<END_MOD>.<START_MOD>testOrFalse<END_MOD>(<START_MOD>new com.google.gerrit.extensions.api.access.PluginPermission<END_MOD>(pluginName<START_MOD>,<END_MOD> ImportCapability.ID))) && (rsrc.getControl().isOwner())); }
@java.lang.Override protected void run() throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.validators.ValidationException, com.google.gwtorm.server.OrmException, com.googlesource.gerrit.plugins.importer.UnloggedFailure, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { com.googlesource.gerrit.plugins.importer.ImportProject.Input input = new com.googlesource.gerrit.plugins.importer.ImportProject.Input(); input.from = url; input.name = name; input.user = user; input.pass = com.googlesource.gerrit.plugins.importer.PasswordUtil.readPassword(in, pass); if (!(com.google.common.base.Strings.isNullOrEmpty(parent))) { input.parent = parent; } try { com.googlesource.gerrit.plugins.importer.ImportProject importer = importProjectFactory.create(new com.google.gerrit.reviewdb.client.Project.NameKey(project)); if (!(quiet)) { importer.setErr(stderr); } com.googlesource.gerrit.plugins.importer.ImportStatistic stats = importer.apply(new com.google.gerrit.server.config.ConfigResource(), input); stdout.print((( Changes:   + (stats.numChangesCreated)) + "\n")); } catch (com.google.gerrit.<START_MOD>server.permissions.PermissionBackendException | com.google.gerrit.<END_MOD>extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
public static boolean isValidHttpUri(java.lang.String val) { return (((<START_MOD>(<END_MOD>val.startsWith("https://")) || (val.startsWith("http://"<START_MOD>))) || (val.startsWith("mailto:"<END_MOD>))) || (val.startsWith("//"))) && (com.google.gitiles.doc.html.HtmlBuilder.URI.getValueFilter().matcher(val).find()); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { <START_MOD>java.util.stream.Stream<com.google.gerrit.server.group.InternalGroup> internalGroupStream; if (groupIndexProvider.get().getSchema().hasField(GroupField.SUBGROUPS)) { internalGroupStream = groupQueryProvider.get().bySubgroup(key).stream(); } else { <END_MOD>try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { <START_MOD>internalGroupStream = com.google.gerrit.server.group.Groups.getParentGroupsFromReviewDb<END_MOD>(db, key).map(groupCache::get).flatMap(Streams::stream)<START_MOD>; } } return internalGroupStream<END_MOD>.map(InternalGroup::getGroupUUID).collect(toImmutableList()); }
@org.junit.Test public void getGroup() throws java.lang.Exception { com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>group<END_MOD>.<START_MOD>InternalGroup<END_MOD> adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")<START_MOD>).orElse(null<END_MOD>); testGetGroup(adminGroup.getGroupUUID().get(), adminGroup); testGetGroup(adminGroup.getName(), adminGroup); testGetGroup(adminGroup.getId().get(), adminGroup); }
@org.junit.Test public void branchDelegation2() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, fixers, "refs/heads/x/y/*"); com.google.gerrit.server.project.Util.doNotInherit(local, com.google.gerrit.server.project.OWNER, "refs/heads/x/y/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); com.google.gerrit.server.project.ProjectControl uFix = user(local, fixers); assertNotOwner(uFix); assertOwner("refs/heads/x/y/*", uFix); assertOwner("refs/heads/x/y/bar", uFix); assertNotOwner("refs/heads/x/*", uFix); assertNotOwner("refs/heads/x/y", uFix); assertNotOwner("refs/*", uFix); assertNotOwner("refs/heads/master", uFix); }
private boolean canAddRefs() { return (canPerformOnAnyRef(Permission.CREATE)) || (<START_MOD>isOwner<END_MOD>()); }
@org.junit.Test public void branchDelegation1() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); }
void cacheVisibleTo(com.google.gerrit.server.project.ChangeControl ctl) { visibleTo = ctl.getUser(); }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(<START_MOD>changeControlFactory.controlFor(db, change(), userFactory.create(c.getOwner())<END_MOD>).isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); <START_MOD>com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get()); <END_MOD>try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want && (<START_MOD>ctl.isPatchVisible(in, db.get()))) { res.put(in.getRevision().get(), toRevisionInfo(<END_MOD>cd<START_MOD>, <END_MOD>in, <START_MOD>repo, rw, false, changeInfo)); } } return<END_MOD> res<START_MOD>; } }<END_MOD>
private java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes()); if (messages.isEmpty()) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(messages.size()); <START_MOD>com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get()); <END_MOD>for (com.google.gerrit.reviewdb.client.ChangeMessage message : messages) { com.google.gerrit.reviewdb.client.PatchSet.Id patchNum = message.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet ps = (patchNum != null) ? map.get(patchNum) : null; if ((patchNum == null) || (<START_MOD>ctl<END_MOD>.isPatchVisible(ps, db.get()))) { com.google.gerrit.extensions.common.ChangeMessageInfo cmi = new com.google.gerrit.extensions.common.ChangeMessageInfo(); cmi.id = message.getKey().get(); cmi.author = accountLoader.get(message.getAuthor()); cmi.date = message.getWrittenOn(); cmi.message = message.getMessage(); cmi.tag = message.getTag(); cmi._revisionNumber = (patchNum != null) ? patchNum.get() : null; com.google.gerrit.reviewdb.client.Account.Id realAuthor = message.getRealAuthor(); if (realAuthor != null) { cmi.realAuthor = accountLoader.get(realAuthor); } result.add(cmi); } } return result; }
private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.index.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.index.query.QueryParseException( disabled } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.index.query.QueryParseException( of 10 queries } int cnt = queries.size(); java.util.List<com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); com.google.gerrit.server.change.ChangeJson cjson = json.create(options); cjson.setPluginDefinedAttributesFactory(this.imp); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = cjson.lazyLoad(com.google.gerrit.server.query.change.QueryChanges.containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if (<START_MOD>(<END_MOD>results.get(n).more()) <START_MOD>&& (!(<END_MOD>info.<START_MOD>isEmpty()))) { info.<END_MOD>get(((info.size()) - 1))._moreChanges = true; } } return res; }
<START_MOD>@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { try { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { org.eclipse.jgit.lib.ProgressMonitor pm = new org.eclipse.jgit.lib.TextProgressMonitor(); pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN); for (com.google.gerrit.reviewdb.client.Account.Id id : com.google.gerrit.server.account.Accounts.allIds(repo)) { if (removeMyDrafts(repo, id)) { pm.update(1); } } pm.endTask(); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Removing \"My Drafts\" menu items failed", e); } }<END_MOD>
<START_MOD>public static void throwIfNotStaleFileHandle(java.io.IOException e) throws java.io.IOException { if (!(com.googlesource.gerrit.plugins.events.fsstore.Nfs.isStaleFileHandle(e))) { throw e; } }<END_MOD>
<START_MOD>public static void throwIfNotStaleFileHandle(java.nio.file.DirectoryIteratorException e) { if (!(com.googlesource.gerrit.plugins.events.fsstore.Nfs.isStaleFileHandle(e.getCause()))) { throw e; } }<END_MOD>
<START_MOD>@org.junit.Test @org.junit.Ignore public void cannotUseInheritedWithNonDefault() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("inherited flag can only be used with default"); gApi.projects().name(project.get()).dashboard("dashboard").get(true); }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.server.project.SetDashboard.Input input) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { <START_MOD>com.google.gerrit.server.IdentifiedUser user; <END_MOD>who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId id = externalIds.get(who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (<START_MOD>supportAutomaticAccountActivityUpdate.get()) { user = genericUserFactory.create(act.getId()); if ((who.isActive()) && (<END_MOD>!(act.isActive()))<START_MOD>) { try { setInactiveFlag.activate(user); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e)<END_MOD> { throw new com.google.gerrit.server.account.AccountException( <START_MOD>to activate account. e); } } else if ((!(who.isActive())) && (act.isActive())) { try { setInactiveFlag.deactivate(user); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw new com.google.gerrit.server.account.AccountException( to deactivate account. e); } } } act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException( <END_MOD>error, account inactive } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.server.account.AccountException( error e); } }
<START_MOD>default java.lang.Boolean isActive(java.lang.String username) throws com.google.gerrit.server.account.AccountException, javax.naming.NamingException, javax.security.auth.login.LoginException { return true; }<END_MOD>
<START_MOD>@java.lang.Override public void start() { if (!(supportAutomaticAccountActivityUpdate)) { return; } com.google.gerrit.server.config.ScheduleConfig scheduleConfig = cfg.getScheduleConfig(); long interval = scheduleConfig.getInterval(); long delay = scheduleConfig.getInitialDelay(); if ((delay == (MISSING_CONFIG)) && (interval == (MISSING_CONFIG))) { com.google.gerrit.server.account.AccountDeactivator.log.info("Ignoring missing accountDeactivator schedule configuration"); } else if ((delay < 0) || (interval <= 0)) { com.google.gerrit.server.account.AccountDeactivator.log.warn(java.lang.String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig)); } else { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, java.util.concurrent.TimeUnit.MILLISECONDS); } }<END_MOD>
<START_MOD>public java.lang.Boolean isActive() { return active; }<END_MOD>
<START_MOD>@java.lang.Override public java.lang.Boolean isActive(java.lang.String username) throws com.google.gerrit.server.account.AccountException, javax.naming.NamingException, javax.security.auth.login.LoginException { try { final javax.naming.directory.DirContext ctx = helper.open(); final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema = helper.getSchema(ctx); helper.findAccount(schema, ctx, username, false); } catch (com.google.gerrit.server.auth.NoSuchUserException e) { return false; } return true; }<END_MOD>
<START_MOD>public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.server.IdentifiedUser user) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().atomicUpdate(dbProvider.get(), user.getAccountId(), ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }<END_MOD>
<START_MOD>public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.server.IdentifiedUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().atomicUpdate(dbProvider.get(), user.getAccountId(), ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( deactivate own account } com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>account<END_MOD>.<START_MOD>SetInactiveFlag<END_MOD> <START_MOD>sif<END_MOD> = new com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>account<END_MOD>.<START_MOD>SetInactiveFlag<END_MOD>(<START_MOD>dbProvider,<END_MOD> <START_MOD>accountsUpdate<END_MOD>)<START_MOD>;<END_MOD> return <START_MOD>sif<END_MOD>.<START_MOD>deactivate(rsrc<END_MOD>.<START_MOD>getUser<END_MOD>(<START_MOD>)<END_MOD>); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>account<END_MOD>.<START_MOD>SetInactiveFlag<END_MOD> <START_MOD>sif<END_MOD> = new com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>account<END_MOD>.<START_MOD>SetInactiveFlag<END_MOD>(<START_MOD>dbProvider,<END_MOD> <START_MOD>accountsUpdate);<END_MOD> return <START_MOD>sif<END_MOD>.<START_MOD>activate(rsrc.getUser<END_MOD>()); }
<START_MOD>@java.lang.Override public void run() { com.google.gerrit.server.account.AccountDeactivator.log.info("Running account deactivations."); try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { deactivationUtil.deactivateInactiveAccounts(); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error("Failed to deactivate inactive accounts.", e); } }<END_MOD>
<START_MOD>public void isActive(java.lang.Boolean isActive) { this.active = isActive; }<END_MOD>
<START_MOD>@org.junit.Test public void cannotMarkChangeThatWasMarkedAsUnreviewedAsReviewed() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); setApiUser(user); gApi.changes().id(changeId).markAsReviewed(false); assertThat(gApi.changes().id(changeId).get().reviewed).isNull(); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage((((("The labels " + (com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL)) + " and ") + (com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL)) + " are mutually exclusive. Only one of them can be set.")); gApi.accounts().self().setStars(changeId, new com.google.gerrit.extensions.api.changes.StarsInput(com.google.common.collect.ImmutableSet.of(((com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL) + "/1")))); }<END_MOD>
@org.junit.Test public void <START_MOD>cannotMarkChangeThatWasMarkedAsReviewedAsUnreviewed<END_MOD>() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); <START_MOD>setApiUser(user); gApi.changes().id(changeId).markAsReviewed(true); assertThat(gApi.changes().id(changeId).get().reviewed).isTrue(); <END_MOD>exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage(<START_MOD>(((( labels   + (com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL)) +   and   + (com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL)) +   are mutually exclusive. Only one of them can be set.<END_MOD> gApi.<START_MOD>accounts().self().setStars(changeId, new com.google.gerrit.extensions.api.<END_MOD>changes<START_MOD>.StarsInput(com.google.common.collect.ImmutableSet.of(((com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL) + "/1")))<END_MOD>); }
@java.lang.Override public void <START_MOD>markAsReviewed<END_MOD>(boolean <START_MOD>reviewed<END_MOD>) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (<START_MOD>reviewed<END_MOD>) { this.<START_MOD>markAsReviewed<END_MOD>.apply(change, new com.google.gerrit.server.change.<START_MOD>MarkAsReviewed<END_MOD>.Input()); } else { <START_MOD>markAsUnreviewed<END_MOD>.apply(change, new com.google.gerrit.server.change.<START_MOD>MarkAsUnreviewed<END_MOD>.Input()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(<START_MOD>(<END_MOD> <START_MOD>mark<END_MOD> change<START_MOD> as   + (reviewed ? "reviewed" : "unreviewed")),<END_MOD> e); } }
private static java.lang.String <START_MOD>getReviewedLabel<END_MOD>(com.google.gerrit.reviewdb.client.Change change) { return ((com.google.gerrit.server.StarredChangesUtil.<START_MOD>REVIEWED_LABEL<END_MOD>) + "/") + (change.currentPatchSetId().get()); }
<START_MOD>private<END_MOD> <START_MOD>static<END_MOD> <START_MOD>java.lang.String getUnreviewedLabel<END_MOD>(com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client.Change <END_MOD>change) { <START_MOD>return <END_MOD>((com.google.gerrit.server.StarredChangesUtil.<START_MOD>UNREVIEWED_LABEL) + "/") + <END_MOD>(<START_MOD>change<END_MOD>.<START_MOD>currentPatchSetId<END_MOD>().<START_MOD>get<END_MOD>()); }
private static void checkMutuallyExclusiveLabels(java.util.Set<java.lang.String> labels) throws com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException { if (labels.containsAll(com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL))) { throw new com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL); } <START_MOD>if ((labels.stream().filter(( l) -> l.startsWith(com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL)).findAny().isPresent()) && (labels.stream().filter(( l) -> l.startsWith(com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL)).findAny().isPresent())) { throw new com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException(com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL, com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL); <END_MOD>}<START_MOD> }<END_MOD>
<START_MOD>public<END_MOD> static com.google.gerrit.server.StarredChangesUtil.StarRef readLabels(org.eclipse.jgit.lib.Repository repo, java.lang.String refName) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); if (ref == null) { return com.google.gerrit.server.StarredChangesUtil.StarRef.MISSING; } try (org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader()) { org.eclipse.jgit.lib.ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB); return com.google.gerrit.server.StarredChangesUtil.StarRef.create(ref, com.google.common.base.Splitter.on(com.google.common.base.CharMatcher.whitespace()).omitEmptyStrings().split(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8))); } }
<START_MOD>@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Mark as Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc)); }<END_MOD>
<START_MOD>@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(git)) { org.eclipse.jgit.lib.BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate(); for (org.eclipse.jgit.lib.Ref ref : git.getRefDatabase().getRefs(RefNames.REFS_STARRED_CHANGES).values()) { com.google.gerrit.server.StarredChangesUtil.StarRef starRef = com.google.gerrit.server.StarredChangesUtil.readLabels(git, ref.getName()); if (starRef.labels().contains(com.google.gerrit.server.schema.Schema_159.MUTE_LABEL)) { org.eclipse.jgit.lib.ObjectId id = com.google.gerrit.server.StarredChangesUtil.writeLabels(git, starRef.labels().stream().map(( l) -> l.equals(com.google.gerrit.server.schema.Schema_159.MUTE_LABEL) ? StarredChangesUtil.REVIEWED_LABEL : l).collect(java.util.stream.Collectors.toSet())); bru.addCommand(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), id, ref.getName())); } } bru.execute(rw, new org.eclipse.jgit.lib.TextProgressMonitor()); } catch (java.io.IOException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException ex) { throw new com.google.gwtorm.server.OrmException(ex); } }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Mark as Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible((!(isReviewed(rsrc)))); }<END_MOD>
<START_MOD>protected java.lang.ClassLoader getMergedClassLoader(java.lang.ClassLoader beanCl, java.lang.ClassLoader dynamicBeanCl) { java.util.Map<java.lang.ClassLoader, java.lang.ref.WeakReference<java.lang.ClassLoader>> mergedClByCl = com.google.gerrit.server.DynamicOptions.mergedClByCls.get(beanCl); if (mergedClByCl == null) { mergedClByCl = java.util.Collections.synchronizedMap(new java.util.WeakHashMap<java.lang.ClassLoader, java.lang.ref.WeakReference<java.lang.ClassLoader>>()); com.google.gerrit.server.DynamicOptions.mergedClByCls.put(beanCl, mergedClByCl); } java.lang.ref.WeakReference<java.lang.ClassLoader> mergedClRef = mergedClByCl.get(dynamicBeanCl); java.lang.ClassLoader mergedCl = null; if (mergedClRef != null) { mergedCl = mergedClRef.get(); } if (mergedCl == null) { mergedCl = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); mergedClByCl.put(dynamicBeanCl, new java.lang.ref.WeakReference(mergedCl)); } return mergedCl; }<END_MOD>
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = <START_MOD>getMergedClassLoader<END_MOD>(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { try { com.google.gerrit.server.List<java.lang.Module> modules = new java.util.ArrayList(); com.google.inject.Injector modulesInjector = injector; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { modulesInjector = injector.createChildInjector(); for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { java.lang.Class<java.lang.Module> mClass = ((java.lang.Class<java.lang.Module>) (loader.loadClass(moduleName))); modules.add(modulesInjector.getInstance(mClass)); } } return modulesInjector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { <START_MOD>com.google.gerrit.server.List<java.lang.Module> modules = new java.util.ArrayList(); <END_MOD>try { <START_MOD>if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { try { <END_MOD>java.lang.Class<<START_MOD>?> moduleClass = loader.loadClass(moduleName); modules.add(((java.lang.Module) (moduleClass.getConstructor().newInstance()))); } catch (java.lang.NoSuchMethodException | java.lang.InstantiationException | java.lang.IllegalAccessException | java.lang.reflect.InvocationTargetException e) { } } } return injector.createChildInjector(modules).getInstance(((java.lang.Class<<END_MOD>com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { <START_MOD>try { <END_MOD>com.google.gerrit.server.List<java.lang.Module> modules = new java.util.ArrayList(); <START_MOD>com.google.inject.Injector modulesInjector = injector;<END_MOD> if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { <START_MOD>modulesInjector = injector.createChildInjector(); <END_MOD>for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { java.lang.Class<<START_MOD>java.lang.Module<END_MOD>> <START_MOD>mClass = <END_MOD>((java.lang.Class<<START_MOD>java.lang.Module>) (loader.loadClass(moduleName))); modules.add(modulesInjector.getInstance(mClass)); } } return modulesInjector.createChildInjector(modules).getInstance(((java.lang.Class<<END_MOD>com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1,   upload-pack not permitted on this server } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ( unable to check permissions   + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(projectControl.getProjectState(), repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); <START_MOD>for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(ctl.getProject().getNameKey(), rp); } <END_MOD>try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) { org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(preUploadHooks))); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); <START_MOD>for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(ctl.getProject().getNameKey(), rp); } <END_MOD>return up; }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(com.google.gerrit.acceptance.InProcessProtocol.Context req, org.eclipse.jgit.lib.Repository repo) throws org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException { threadContext.setContext(req); com.google.gerrit.acceptance.InProcessProtocol.current.set(req); try { permissionBackend.user(userProvider).project(req.project).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException(); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.RuntimeException(e); } com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(req.project); } catch (java.io.IOException e) { throw new java.lang.RuntimeException(e); } if (projectState == null) { throw new java.lang.RuntimeException(( load project state for   + (req.project.get()))); } org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(transferConfig.getPackConfig()); up.setTimeout(transferConfig.getTimeout()); up.setAdvertiseRefsHook(refFilterFactory.create(projectState, repo)); java.util.List<org.eclipse.jgit.transport.PreUploadHook> hooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); hooks.add(uploadValidatorsFactory.create(projectState.getProject(), repo, "localhost-test")); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(hooks)); <START_MOD>for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(ctl.getProject().getNameKey(), rp); } <END_MOD>return up; }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> out; try { out = query(); } catch (com.google.gerrit.server.query.QueryParseException e) { java.util.regex.Pattern p = java.util.regex.Pattern.compile( in operator (.*:self|is:watched|is:owner|is:reviewer)$ java.util.regex.Matcher m = p.matcher(e.getMessage()); if (m.matches()) { java.lang.String op = m.group(1); throw new com.google.gerrit.extensions.restapi.AuthException(( be signed-in to use   + op)); } throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage(), e); } return (out.size()) == 1 ? out.get(0) : out; }
<START_MOD>void assertRefUpdateFor(java.util.Map<java.lang.String, java.lang.Integer> expectedRefUpdateCounts) { for (java.util.Map.Entry<java.lang.String, java.lang.Integer> e : expectedRefUpdateCounts.entrySet()) { assertThat(getCount(e.getKey())).isEqualTo(e.getValue()); } assertThat(countsByRef).hasSize(expectedRefUpdateCounts.size()); clear(); }<END_MOD>
@org.junit.Test public void create() throws java.lang.Exception { <START_MOD>com.google.gerrit.reviewdb.client.Account.Id accountId = <END_MOD>create(2); <START_MOD>refUpdateCounter.assertRefUpdateFor(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId), RefNames.REFS_EXTERNAL_IDS); <END_MOD>}
<START_MOD>@java.lang.Override public void onGitReferenceUpdated(com.google.gerrit.acceptance.api.accounts.Event event) { countsByRef.incrementAndGet(event.getRefName()); }<END_MOD>
<START_MOD>void assertRefUpdateFor(java.lang.String... refs) { java.util.Map<java.lang.String, java.lang.Integer> expectedRefUpdateCounts = new java.util.HashMap<>(); for (java.lang.String ref : refs) { expectedRefUpdateCounts.put(ref, 1); } assertRefUpdateFor(expectedRefUpdateCounts); }<END_MOD>
<START_MOD>void clear() { countsByRef.clear(); }<END_MOD>
@org.junit.Test @com.google.gerrit.acceptance.UseSsh public void createWithSshKeys() throws java.lang.Exception { <START_MOD>com.google.gerrit.reviewdb.client.Account.Id accountId = <END_MOD>create(3); <START_MOD>refUpdateCounter.assertRefUpdateFor(com.google.common.collect.ImmutableMap.of(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId), 2, RefNames.REFS_EXTERNAL_IDS, 1)); <END_MOD>}
<START_MOD>long getCount(java.lang.String ref) { return countsByRef.get(ref); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.server.query.DataSource<com.google.gerrit.server.project.ProjectState> getSource(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.project.ProjectState> p, com.google.gerrit.server.index.QueryOptions opts) throws com.google.gerrit.server.query.QueryParseException { return new com.google.gerrit.lucene.LuceneProjectIndex.QuerySource(opts, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneProjectIndex.NAME_SORT_FIELD, SortField.Type.STRING, false))); }<END_MOD>
@com.google.inject.Provides java.util.Collection<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>> getIndexDefinitions(com.google.gerrit.server.index.account.AccountIndexDefinition accounts, com.google.gerrit.server.index.change.ChangeIndexDefinition changes, com.google.gerrit.server.index.group.GroupIndexDefinition groups<START_MOD>, com.google.gerrit.server.index.project.ProjectIndexDefinition projects<END_MOD>) { java.util.Collection<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>> result = com.google.common.collect.ImmutableList.<com.google.gerrit.server.index.IndexDefinition<?, ?, ?>>of(accounts, groups, changes<START_MOD>, projects<END_MOD>); java.util.Set<java.lang.String> expected = com.google.common.collect.FluentIterable.from(com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet(); java.util.Set<java.lang.String> actual = com.google.common.collect.FluentIterable.from(result).transform(IndexDefinition::getName).toSet(); if (!(expected.equals(actual))) { throw new com.google.inject.ProvisionException(((( index definitions for all schemas:   + expected) +   !=   + actual)); } return result; }
<START_MOD>public static java.util.Set<java.lang.String> projectFields(com.google.gerrit.server.index.QueryOptions opts) { java.util.Set<java.lang.String> fs = opts.fields(); return fs.contains(ProjectField.NAME.getName()) ? fs : com.google.common.collect.Sets.union(fs, com.google.common.collect.ImmutableSet.of(ProjectField.NAME.getName())); }<END_MOD>
<START_MOD>@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } com.google.gerrit.server.index.project.ProjectIndex searchIndex = indexes.getSearchIndex(); if (searchIndex == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("no project index"); } if ((start) != 0) { queryProcessor.setStart(start); } if ((limit) != 0) { queryProcessor.setLimit(limit); } try { com.google.gerrit.server.query.QueryResult<com.google.gerrit.server.project.ProjectState> result = queryProcessor.query(queryBuilder.parse(query)); java.util.List<com.google.gerrit.server.project.ProjectState> projects = result.entities(); java.util.ArrayList<com.google.gerrit.extensions.common.ProjectInfo> projectInfos = com.google.common.collect.Lists.newArrayListWithCapacity(projects.size()); for (com.google.gerrit.server.project.ProjectState projectState : projects) { projectInfos.add(json.format(projectState.getProject())); } return projectInfos; } catch (com.google.gerrit.server.query.QueryParseException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } }<END_MOD>
<START_MOD>private static org.apache.lucene.store.Directory dir(com.google.gerrit.server.index.Schema<com.google.gerrit.server.project.ProjectState> schema, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.SitePaths sitePaths) throws java.io.IOException { if (com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest(cfg)) { return new org.apache.lucene.store.RAMDirectory(); } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir(sitePaths, com.google.gerrit.lucene.LuceneProjectIndex.PROJECTS, schema); return org.apache.lucene.store.FSDirectory.open(indexDir); }<END_MOD>
<START_MOD>private Account.Id createAccount(java.lang.String username, java.lang.String fullName, java.lang.String email, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email != null) { accountManager.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(db, id, ( a) -> { a.setFullName(fullName); a.setPreferredEmail(email); a.setActive(active); }); return id; } }<END_MOD>
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug( tag cache on fast-forward of {} cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(cmd)) { logDebug( project in cache <START_MOD>try { <END_MOD>projectCache.evict(project); <START_MOD>} catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(( evict from project cache, name key:   + (project.getName())), e); } <END_MOD>com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug( project description repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(( update description of   + (project.getName())), e); } } }
@java.lang.Override public void evict(com.google.gerrit.reviewdb.client.Project p)<START_MOD> throws java.io.IOException<END_MOD> { if (p != null) { byName.invalidate(p.getNameKey().get()); } <START_MOD>indexer.get().index(p.getNameKey()); <END_MOD>}
<START_MOD>@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws java.io.IOException { for (com.google.gerrit.server.index.Index<?, com.google.gerrit.server.project.ProjectState> i : getWriteIndexes()) { i.replace(projectCache.get(nameKey)); } fireProjectIndexedEvent(nameKey.get()); }<END_MOD>
<START_MOD>@java.lang.Override public void replace(com.google.gerrit.server.project.ProjectState projectState) throws java.io.IOException { try { replace(com.google.gerrit.lucene.LuceneProjectIndex.idTerm(projectState), toDocument(projectState, null)).get(); } catch (java.util.concurrent.ExecutionException | java.lang.InterruptedException e) { throw new java.io.IOException(e); } }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.server.query.DataSource<com.google.gerrit.server.project.ProjectState> getSource(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.project.ProjectState> p, com.google.gerrit.server.index.QueryOptions opts) throws com.google.gerrit.server.query.QueryParseException { return new com.google.gerrit.elasticsearch.ElasticProjectIndex.QuerySource(p, opts); }<END_MOD>
private org.eclipse.jgit.lib.Repository openRepository(java.nio.file.Path path, com.google.gerrit.reviewdb.client.Project.NameKey name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(( name:   + name)); } <START_MOD>final org.eclipse.jgit.lib.RepositoryCache.FileKey loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.lenient(path.resolve(name.get()).toFile(), FS.DETECTED); try { return org.eclipse.jgit.lib.RepositoryCache.open(loc); } catch (<END_MOD>java.io.<START_MOD>IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2<END_MOD> = <START_MOD>new org.eclipse.jgit.errors.RepositoryNotFoundException(( open repository   + name)); e2.initCause(e1);<END_MOD> throw <START_MOD>e2; } }<END_MOD>
private void setAccount() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { user = genericUserFactory.create(id); rsrc = new com.google.gerrit.server.account.AccountResource(user); try { for (java.lang.String email : addEmails) { addEmail(email); } for (java.lang.String email : deleteEmails) { deleteEmail(email); } if ((preferredEmail) != null) { putPreferred(preferredEmail); } if ((fullName) != null) { com.google.gerrit.server.account.PutName.Input in = new com.google.gerrit.server.account.PutName.Input(); in.name = fullName; putName.apply(rsrc, in); } if (((httpPassword) != null) || (clearHttpPassword)) { com.google.gerrit.server.account.<START_MOD>HttpPasswordInput<END_MOD> in = new com.google.gerrit.server.account.<START_MOD>HttpPasswordInput<END_MOD>(); in.httpPassword = httpPassword; putHttpPassword.apply(rsrc, in); } if (active) { putActive.apply(rsrc, null); } else if (inactive) { try { deleteActive.apply(rsrc, null); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } addSshKeys = readSshKey(addSshKeys); if (!(addSshKeys.isEmpty())) { addSshKeys(addSshKeys); } deleteSshKeys = readSshKey(deleteSshKeys); if (!(deleteSshKeys.isEmpty())) { deleteSshKeys(deleteSshKeys); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.<START_MOD>HttpPasswordInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } if (input == null) { input = new com.google.gerrit.server.account.HttpPasswordInput(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { newPassword = com.google.gerrit.server.account.<END_MOD>PutHttpPassword.<START_MOD>generate(); } else<END_MOD> if ((<START_MOD>input.httpPassword) == null) { newPassword = null; } else { permissionBackend.user(<END_MOD>self<START_MOD>).check(GlobalPermission.ADMINISTRATE_SERVER); newPassword = input.httpPassword; } return apply<END_MOD>(rsrc.getUser()<START_MOD>, newPassword); }<END_MOD>
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> load(com.google.gerrit.reviewdb.client.AccountGroup.Id key) throws java.lang.Exception { <START_MOD>if ((groupIndexProvider.get()) != null) { <END_MOD>return groupQueryProvider.get().byId(key); }<START_MOD> try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return groups.getGroup(db, key); } }<END_MOD>
<START_MOD>@org.junit.Test public void pushToPublishMagicBranchIsAllowed() throws java.lang.Exception { createChange("refs/publish/master"); com.google.gerrit.acceptance.PushOneCommit.Result result = pushTo("refs/publish/master"); result.assertOkStatus(); assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* will be deprecated, use refs/for/* instead.\n"); }<END_MOD>
@java.lang.Override public java.lang.String formQueryFromRequestParameters(java.util.Map<java.lang.String, java.lang.String> params) throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { if (params == null) { return getDefaultQuery(); } java.<START_MOD>lang.String<END_MOD>[] dates; try { dates = parseDates(params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_ONE), params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_TWO)); } catch (java.<START_MOD>time.format.DateTimeParseException<END_MOD> e) { throw new com.ericsson.gerrit.plugins.eventslog.MalformedQueryException(e); } return java.lang.String.format( * FROM %s WHERE %s BETWEEN '%s' and '%s' LIMIT %d com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME, com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.DATE_ENTRY, dates[0]<START_MOD>, <END_MOD>dates[1]<START_MOD>, java.lang.Integer.valueOf(<END_MOD>returnLimit)<START_MOD>); }<END_MOD>
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error( fire event e); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException<START_MOD>, com.google.gerrit.server.permissions.PermissionBackendException<END_MOD>, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want<START_MOD>) { res.put(in.getRevision()<END_MOD>.get()<START_MOD>, toRevisionInfo(cd, in, repo, rw, false, changeInfo)); } } return<END_MOD> res<START_MOD>; } }<END_MOD>
<START_MOD>private boolean isWorldReadable(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(anonymous).database(db); com.google.gerrit.server.permissions.PermissionBackend.ForChange forChange = (lazyLoad) ? perm.change(cd) : perm.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change())); try { forChange.check(ChangePermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException ae) { return false; } }<END_MOD>
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.<START_MOD>gerrit.server.permissions.PermissionBackendException, com.google.<END_MOD>gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null); accountLoader.fill(); return rev; } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> makeFetchMap(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws<START_MOD> com.google.gerrit.server.permissions.PermissionBackendException,<END_MOD> com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> r = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.registration.DynamicMap.Entry<com.google.gerrit.extensions.config.DownloadScheme> e : downloadSchemes) { java.lang.String schemeName = e.getExportName(); com.google.gerrit.extensions.config.DownloadScheme scheme = e.getProvider().get(); if ((!(scheme.isEnabled())) || ((scheme.isAuthRequired()) && (!(userProvider.get().isIdentifiedUser())))) { continue; } if ((!(scheme.isAuthSupported())) && (!(<START_MOD>isWorldReadable(cd)))) { continue; } java.lang.String projectName = cd.project()<END_MOD>.get()<START_MOD>; java.lang.String url = scheme.getUrl(projectName); java.lang.String refName = in.getRefName(); com.google.gerrit.extensions.common.FetchInfo fetchInfo = new com.google.gerrit.extensions.common.FetchInfo(url, refName); r.put(schemeName, fetchInfo); if (has(com.google.gerrit.server.change.DOWNLOAD_COMMANDS<END_MOD>)) { <START_MOD>com.google.gerrit.server.change.ChangeJson.populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo)<END_MOD>; } <START_MOD>} return<END_MOD> r; }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException <START_MOD>| com.google.gerrit.server.permissions.PermissionBackendException <END_MOD>e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error( fire event e); } }
<START_MOD>com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List all() { return to.union(cc, bcc); }<END_MOD>
<START_MOD>private com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List union(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List... others) { com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List union = new com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List(); for (com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List other : com.google.common.collect.Lists.asList(this, others)) { union.accounts.addAll(other.accounts); union.emails.addAll(other.emails); } return union; }<END_MOD>
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case <START_MOD>READ_PRIVATE_CHANGES : return canViewPrivateChanges(); case READ_ACCESS : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_ACCESS : return isOwner(); case <END_MOD>SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().isUseSignedOffBy())); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
private boolean isOwnerOfProjectOrBranch(com.google.gerrit.reviewdb.client.Account.Id <START_MOD>userId<END_MOD>) { return <START_MOD>permissionBackend.user<END_MOD>(identifiedUserFactory.create(<START_MOD>userId<END_MOD>)).<START_MOD>ref<END_MOD>(change.getDest()).<START_MOD>testOrFalse<END_MOD>(<START_MOD>RefPermission.WRITE_ACCESS<END_MOD>); }
<START_MOD>private boolean canWriteConfig() throws com.google.gerrit.server.permissions.PermissionBackendException { checkNotNull(user); if ((canWriteConfig) != null) { return canWriteConfig; } try { permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_ACCESS); canWriteConfig = true; } catch (com.google.gerrit.extensions.restapi.AuthException e) { canWriteConfig = false; } return canWriteConfig; }<END_MOD>
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isInternalUser()) || (canPerformOnAnyRef(Permission.READ)))) || (isOwner()); case READ : return (!(isHidden())) && (allRefsAreVisible(java.util.Collections.emptySet())); case READ_NO_CONFIG : return (!(isHidden())) && (allRefsAreVisible(com.google.common.collect.ImmutableSet.of(RefNames.REFS_CONFIG))); case CREATE_REF : return canAddRefs(); case CREATE_CHANGE : return canCreateChanges(); case RUN_RECEIVE_PACK : return canRunReceivePack(); case RUN_UPLOAD_PACK : return canRunUploadPack(); <START_MOD>case BAN_COMMIT : case READ_REF_LOG : case SET_DEFAULT_DASHBOARD : case READ_ACCESS : case WRITE_ACCESS : return isOwner(); <END_MOD>} throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.RestApiException<START_MOD>, com.google.gerrit.server.permissions.PermissionBackendException<END_MOD>, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } try { com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } } return r; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.FixInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { <START_MOD>com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(user); <END_MOD>if (!(rsrc.isUserOwner())) <START_MOD>{ perm.project<END_MOD>(rsrc.getProject()).check(<START_MOD>ProjectPermission.READ_ACCESS<END_MOD>); } return com.google.gerrit.extensions.restapi.Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc)); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException<START_MOD>,<END_MOD> com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionBackendException { permissionBackend.user<END_MOD>(<START_MOD>user).<END_MOD>project<START_MOD>(rsrc.getNameKey()).check(ProjectPermission.WRITE_ACCESS);<END_MOD> return apply(rsrc.getProjectState(), input); }
@org.junit.Test public void nonOwnerCannotSetConfig() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ConfigInput input = createTestConfigInput(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage( <START_MOD>access<END_MOD> <START_MOD>not<END_MOD> <START_MOD>permitted<END_MOD> gApi.projects().name(project.get()).config(input); }
@java.lang.Override public java.lang.String format(org.apache.log4j.spi.LoggingEvent event) { final java.lang.StringBuffer buf = new java.lang.StringBuffer(128); buf.append('['); <START_MOD>buf.append(<END_MOD>formatDate(event.getTimeStamp()<START_MOD>)<END_MOD>); buf.append(']'); buf.append(   buf.append(event.getLevel().toString()); req(DeleteLog.ACCOUNT_ID, buf, event); req(DeleteLog.USER_NAME, buf, event); buf.append(   buf.append(event.getMessage()); req(DeleteLog.PROJECT_NAME, buf, event); opt(DeleteLog.OPTIONS, buf, event); opt(DeleteLog.ERROR, buf, event); buf.append('\n'); return buf.toString(); }
private java.lang.<START_MOD>String<END_MOD> <START_MOD>formatDate(long now<END_MOD>) { <START_MOD>java.time.Instant<END_MOD> <START_MOD>when<END_MOD> = <START_MOD>java.time.Instant.ofEpochMilli<END_MOD>(now<START_MOD>);<END_MOD> <START_MOD>java.time.ZonedDateTime<END_MOD> <START_MOD>zdt = java.time.ZonedDateTime.ofInstant(when, java.time.ZoneId.systemDefault(<END_MOD>)); <START_MOD>return<END_MOD> <START_MOD>zdt<END_MOD>.<START_MOD>format<END_MOD>(java.<START_MOD>time<END_MOD>.<START_MOD>format<END_MOD>.<START_MOD>DateTimeFormatter<END_MOD>.<START_MOD>ofPattern<END_MOD>( <START_MOD>HH:mm:ss,SSS<END_MOD> <START_MOD>xxxx<END_MOD> }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change = cd.change(); if (change == null) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { <START_MOD>if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchProjectException) { com.google.gerrit.server.query.change.ChangeIsVisibleToPredicate.logger.info(java.lang.String.format( such project: %s. Index data might be stale. cd.project())); return false; } <END_MOD>throw new com.google.gwtorm.server.OrmException( to check permissions e); } if (visible) { cd.cacheVisibleTo(user); return true; } return false; }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> toAccounts(java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, com.google.gerrit.extensions.common.AccountInfo uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); <START_MOD>for (java.lang.String r : in) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(r); if (account != null) { reviewers.add(account); continue; } } catch (com.google.gwtorm<END_MOD>.server.<START_MOD>OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.error(( to resolve <END_MOD>account<START_MOD>   + r), e); continue; } if ((<END_MOD>groupMembers<START_MOD>) ==<END_MOD> null<START_MOD>) { try { reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p)); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn<END_MOD>(java.lang.String.format( %s<START_MOD> is neither an account nor a group r));<END_MOD> } catch (com.google.<START_MOD>gerrit<END_MOD>.server.<START_MOD>project.NoSuchProjectException<END_MOD> e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format( to list accounts for group %s<START_MOD> and project<END_MOD> %s r, <START_MOD>p)); } catch (java.io.IOException | com.google.gwtorm.server.OrmException<END_MOD> e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format( to list accounts for group %s<START_MOD> r)<END_MOD>, e); } } } return reviewers; }
com.google.gerrit.server.git.receive.ReplaceOp create(com.google.gerrit.server.project.<START_MOD>ProjectState projectState, com.google.gerrit.server.CurrentUser user<END_MOD>, com.google.gerrit.reviewdb.client.Branch.NameKey dest, boolean checkMergedInto, @com.google.inject.assistedinject.Assisted("priorPatchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id priorPatchSetId, @com.google.inject.assistedinject.Assisted("priorCommitId") org.eclipse.jgit.lib.ObjectId priorCommit, @com.google.inject.assistedinject.Assisted("patchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, @com.google.inject.assistedinject.Assisted("commitId") org.eclipse.jgit.lib.ObjectId commitId, com.google.gerrit.reviewdb.client.PatchSetInfo info, java.util.List<java.lang.String> groups, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.receive.ReceiveCommits.MagicBranchInput magicBranch, @com.google.gerrit.common.Nullable org.eclipse.jgit.transport.PushCertificate pushCertificate);
void addOps(com.google.gerrit.server.update.BatchUpdate bu, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.MultiProgressMonitor.Task progress) throws java.io.IOException { if (((magicBranch) != null) && ((magicBranch.edit) || (magicBranch.draft))) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ReceiveCommits.ReindexOnlyOp()); if ((prev) != null) { bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(prev)); } bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(cmd)); return; } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit newCommit = rw.parseCommit(newCommitId); rw.parseBody(newCommit); org.eclipse.jgit.revwalk.RevCommit priorCommit = revisions.inverse().get(priorPatchSet); replaceOp = replaceOpFactory.create(<START_MOD>projectState, user<END_MOD>, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator); bu.addOp(notes.getChangeId(), replaceOp); if (progress != null) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ChangeProgressOp(progress)); } }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(<START_MOD>userProvider.get<END_MOD>()).project(<START_MOD>projectState<END_MOD>.getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1,   upload-pack not permitted on this server } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ( unable to check permissions   + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(<START_MOD>projectState<END_MOD>, repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(<START_MOD>projectState<END_MOD>.getNameKey(), up); } try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
private void index(com.google.gerrit.server.project.<START_MOD>ProjectState<END_MOD> <START_MOD>projectState<END_MOD>) { try { index.apply(new com.google.gerrit.server.project.ProjectResource(<START_MOD>projectState<END_MOD>, <START_MOD>userProvider<END_MOD>.<START_MOD>get<END_MOD>()), null); } catch (java.lang.Exception e) { writeError("error", java.lang.String.format( to index %s: %s <START_MOD>projectState<END_MOD>.getName(), e.getMessage())); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(<START_MOD>projectState, user.get<END_MOD>()), input); printCommits(r.newlyBanned,   following commits were banned printCommits(r.alreadyBanned,   following commits were already banned printCommits(r.ignored,   following ids do not represent commits and were ignored } catch (java.lang.Exception e) { throw die(e); } }
<START_MOD>private java.util.List<com.google.gerrit.extensions.common.GroupInfo> getGroupsOwnedBy(com.google.gerrit.reviewdb.client.AccountGroup.UUID owner) { return groupCache.ownedBy(owner).stream().map(( g) -> toGroupInfo(g)).collect(java.util.stream.Collectors.toList()); }<END_MOD>
public java.util.List<com.google.gerrit.extensions.common.GroupInfo> get() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (!(com.google.common.base.Strings.isNullOrEmpty(suggest))) { return suggestGroups(); } if ((!(com.google.common.base.Strings.isNullOrEmpty(matchSubstring))) && (!(com.google.common.base.Strings.isNullOrEmpty(matchRegex)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( one of m/r } if (<START_MOD>(ownedBy) != null) { return getGroupsOwnedBy(ownedBy); } if (<END_MOD>owned) { return getGroupsOwnedBy(((user) != null ? userFactory.create(user) : identifiedUser.get())); } if ((user) != null) { return accountGetGroups.apply(new com.google.gerrit.server.account.AccountResource(userFactory.create(user))); } return getAllGroups(); }
<START_MOD>private com.google.gerrit.extensions.common.GroupInfo toGroupInfo(com.google.gerrit.reviewdb.client.AccountGroup group) { com.google.gerrit.extensions.common.GroupInfo info = new com.google.gerrit.extensions.common.GroupInfo(); info.description = group.getDescription(); info.name = group.getName(); info.id = group.getId().toString(); return info; }<END_MOD>
<START_MOD>@org.kohsuke.args4j.Option(name = "--owned-by", usage = "list groups owned by the given group") public void setOwnedBy(com.google.gerrit.reviewdb.client.AccountGroup.UUID ownedBy) { this.ownedBy = ownedBy; }<END_MOD>
<START_MOD>public AccountGroup.UUID getOwnedBy() { return ownedBy; }<END_MOD>
<START_MOD>public com.google.gerrit.extensions.api.groups.Groups.ListRequest withOwnedBy(com.google.gerrit.reviewdb.client.AccountGroup.UUID ownedBy) { this.ownedBy = ownedBy; return this; }<END_MOD>
<START_MOD>@org.junit.Test public void getGroupsByOwner() throws java.lang.Exception { java.lang.String parent = createGroup("test-parent"); java.util.List<java.lang.String> children = java.util.Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent)); for (java.lang.String c : children) { assertThat(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(c)).isPresent()).isTrue(); assertThat(gApi.groups().id(c).owner().name).isEqualTo(parent); } java.util.List<com.google.gerrit.extensions.common.GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID()).get(); assertThat(owned).hasSize(2); assertThat(owned.stream().map(( g) -> g.name).collect(java.util.stream.Collectors.toList())).containsExactlyElementsIn(children); }<END_MOD>
private void checkLabels(com.google.gerrit.server.change.RevisionResource rsrc, java.util.Map<java.lang.String, java.lang.Short> labels) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.common.data.LabelTypes types = rsrc.getControl().getLabelTypes(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions(); java.util.Iterator<java.util.Map.Entry<java.lang.String, java.lang.Short>> itr = labels.entrySet().iterator(); while (itr.hasNext()) { java.util.Map.Entry<java.lang.String, java.lang.Short> ent = itr.next(); com.google.gerrit.common.data.LabelType lt = types.byLabel(ent.getKey()); if (lt == null) { <START_MOD>throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format(   is not a configured label ent.getKey())); } <END_MOD>if (<START_MOD>((ent.getValue()) == null) || ((ent.getValue()) == 0)) {<END_MOD> continue; } if ((<START_MOD>lt<END_MOD>.getValue(<START_MOD>ent.getValue()<END_MOD>)) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format(   %d is not a valid value ent.getKey(), ent.getValue())); } short val = ent.getValue(); try { perm.check(new com.google.gerrit.server.permissions.LabelPermission.WithValue(lt, val)); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format( label   %d is restricted lt.getName(), val)); } <START_MOD>} }<END_MOD>
protected static com.google.gerrit.acceptance.AbstractNotificationTest.FakeEmailSenderSubject assertThat(com.google.gerrit.testutil.FakeEmailSender sender) { return assertAbout(com.google.gerrit.acceptance.FAKE_EMAIL_SENDER_SUBJECT_FACTORY).that(sender); }
public static com.google.gerrit.extensions.common.EditInfoSubject assertThat(com.google.gerrit.extensions.common.EditInfo editInfo) { return assertAbout(com.google.gerrit.extensions.common.EDIT_INFO_SUBJECT_FACTORY).that(editInfo); }
public static com.google.gerrit.extensions.common.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common.FixSuggestionInfoSubject assertThat(com.google.gerrit.extensions.common.FixSuggestionInfo fixSuggestionInfo) { return assertAbout(com.google.gerrit.extensions.common.FIX_SUGGESTION_INFO_SUBJECT_FACTORY).that(fixSuggestionInfo); }
public static com.google.gerrit.extensions.common.GitPersonSubject assertThat(com.google.gerrit.extensions.common.GitPerson gitPerson) { return assertAbout(com.google.gerrit.extensions.common.GIT_PERSON_SUBJECT_FACTORY).that(gitPerson); }
public static com.google.gerrit.extensions.common.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo); }
public static com.google.gerrit.extensions.restapi.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult); }
public static com.google.gerrit.server.edit.tree.ChangeFileContentModificationSubject assertThat(com.google.gerrit.server.edit.tree.ChangeFileContentModification modification) { return assertAbout(com.google.gerrit.server.edit.tree.MODIFICATION_SUBJECT_FACTORY).that(modification); }
public static com.google.gerrit.extensions.common.ContentEntrySubject assertThat(com.google.gerrit.extensions.common.DiffInfo.ContentEntry contentEntry) { return assertAbout(com.google.gerrit.extensions.common.DIFF_INFO_SUBJECT_FACTORY).that(contentEntry); }
public static com.google.gerrit.server.edit.tree.TreeModificationSubject assertThat(com.google.gerrit.server.edit.tree.TreeModification treeModification) { return assertAbout(com.google.gerrit.server.edit.tree.TREE_MODIFICATION_SUBJECT_FACTORY).that(treeModification); }
public static com.google.gerrit.extensions.common.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo); }
public static com.google.gerrit.extensions.client.RangeSubject assertThat(com.google.gerrit.extensions.client.Comment.Range range) { return assertAbout(com.google.gerrit.extensions.client.RANGE_SUBJECT_FACTORY).that(range); }
public static com.google.gerrit.extensions.common.FileInfoSubject assertThat(com.google.gerrit.extensions.common.FileInfo fileInfo) { return assertAbout(com.google.gerrit.extensions.common.FILE_INFO_SUBJECT_FACTORY).that(fileInfo); }
public static com.google.gerrit.extensions.common.PathSubject assertThat(java.nio.file.Path path) { return assertAbout(com.google.gerrit.extensions.common.PATH_SUBJECT_FACTORY).that(path); }
public static com.google.gerrit.extensions.common.DiffInfoSubject assertThat(com.google.gerrit.extensions.common.DiffInfo diffInfo) { return assertAbout(com.google.gerrit.extensions.common.DIFF_INFO_SUBJECT_FACTORY).that(diffInfo); }
static java.lang.String getOwnersFileName(com.google.gerrit.reviewdb.client.Project.NameKey project<START_MOD>, com.google.gerrit.reviewdb.client.Change.Id id<END_MOD>) { if (((com.googlesource.gerrit.plugins.findowners.Config.config) != null) && (project != null)) { try { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS); if (name.trim().equals("")) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((((((   + (project.get())) +   has wrong   + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) +     + name) + "\"")); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.findowners.Config.log.error(<START_MOD>java.lang.String.format<END_MOD>( find project<START_MOD> %s for change   project, id.get()<END_MOD>), e); } } return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { <START_MOD>java.sql.Connection connection = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); try (java.sql.PreparedStatement uuidRetrieval = connection.prepareStatement( group_uuid FROM account_groups WHERE group_id = ? groupDeletion = connection.prepareStatement( account_groups WHERE group_id = ? groupNameDeletion = connection.prepareStatement( account_group_names WHERE group_id = ? { <END_MOD>for (com.google.gerrit.reviewdb.client.AccountGroup.Id id : <START_MOD>com.google.gerrit.server.schema.Schema_87.<END_MOD>scanSystemGroups(db)) { <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.reviewdb.client.AccountGroup<START_MOD>.UUID> groupUuid = com.google.gerrit.server.schema.Schema_87.getUuid(uuidRetrieval, id); if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) { groupDeletion.setInt(1, id<END_MOD>.get(<START_MOD>)); groupDeletion.executeUpdate(); groupNameDeletion.setInt(1, <END_MOD>id<START_MOD>.get()); groupNameDeletion.executeUpdate(<END_MOD>); } } }<START_MOD> }<END_MOD>
@org.junit.Before public void setUp() throws java.lang.Exception { testEnv.getInjector().injectMembers(this); db = testEnv.getDb(); <START_MOD>connection = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); createdOnRetrieval = connection.prepareStatement( created_on FROM account_groups WHERE group_id = ? createdOnUpdate = connection.prepareStatement( account_groups SET created_on = ? WHERE group_id = ? auditEntryDeletion = connection.prepareStatement( account_group_members_audit WHERE group_id = ? <END_MOD>}
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException<START_MOD>, java.sql.SQLException { java.sql.Connection connection = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); try (java.sql.PreparedStatement groupUpdate = connection.prepareStatement( account_groups SET created_on = ? WHERE group_id = ? addedOnRetrieval = connection.prepareStatement(( added_on FROM account_group_members_audit WHERE group_id = ? +   ORDER BY added_on ASC<END_MOD> { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup<START_MOD>.Id<END_MOD>> accountGroups = <START_MOD>com.google.gerrit.server.schema.Schema_151.getAllGroupIds(<END_MOD>db<START_MOD>); for (com.google.gerrit.reviewdb.client.AccountGroup.Id groupId : <END_MOD>accountGroups) { java.util.Optional<java.sql.Timestamp> firstTimeMentioned = com.google.<START_MOD>gerrit.server.schema.Schema_151.getFirstTimeMentioned(addedOnRetrieval, groupId); java.sql.Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup<END_MOD>::<START_MOD>auditCreationInstantTs); groupUpdate.setTimestamp(1,<END_MOD> createdOn<START_MOD>); groupUpdate.setInt(2, groupId.get()); groupUpdate.executeUpdate(<END_MOD>); } }<START_MOD> }<END_MOD>
public java.lang.String getChangeMessageThreadId() { return <START_MOD>""<END_MOD>; }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); }
<START_MOD>private void setReviewer(boolean add, java.lang.String id) throws java.lang.Exception { adminSshSession.exec(java.lang.String.format("gerrit set-reviewers -%s %s %s", (add ? "a" : "r"), user.email, id)); assert_().withFailureMessage(adminSshSession.getError()).that(adminSshSession.hasError()).isFalse(); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> reviewers = change.getChange().getReviewers().all(); if (add) { assertThat(reviewers).contains(user.id); } else { assertThat(reviewers).isEmpty(); } }<END_MOD>
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn( event for a non-existing project {}, {} projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections(<START_MOD>com.googlesource.gerrit.plugins.webhooks.SECTION<END_MOD>)) { java.lang.String url = cfg.getString(<START_MOD>com.googlesource.gerrit.plugins.webhooks.SECTION<END_MOD>, name, "url"); if (com.google.common.base.Strings.isNullOrEmpty(url)) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn( not defined, skipping this remote name); continue; } <START_MOD>java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Factory> factory = provider.getFactory(cfg, name); <END_MOD>if (<START_MOD>!(factory.isPresent())) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn( not recognized, skipping this remote name); continue; } com.googlesource.gerrit.plugins.webhooks.EventProcessor processor = factory.get().create(projectEvent); if (processor.<END_MOD>shouldPost(cfg.getStringList(<START_MOD>com.googlesource.gerrit.plugins.webhooks.SECTION<END_MOD>, name, "event"))) { post(url, <START_MOD>processor); } } }<END_MOD>
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); <START_MOD>when(processor.process()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY); <END_MOD>task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, <START_MOD>processor<END_MOD>); }
@org.junit.Test public void nonProjectEventNotPosted() { com.google.gerrit.server.events.Event nonProjectEvent = new com.google.gerrit.server.events.Event("non-project-event") {}; eventHandler.onEvent(nonProjectEvent); verifyZeroInteractions(<START_MOD>processor); verifyZeroInteractions(<END_MOD>postTask); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(@com.google.inject.assistedinject.Assisted("url") java.lang.String url, com.<START_MOD>googlesource<END_MOD>.<START_MOD>gerrit<END_MOD>.<START_MOD>plugins<END_MOD>.<START_MOD>webhooks.EventProcessor<END_MOD> <START_MOD>processor<END_MOD>);
@org.junit.Test public void remoteUrlUndefinedEventsNotPosted() { eventHandler.onEvent(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_CREATED); verifyZeroInteractions(<START_MOD>processor); verifyZeroInteractions(<END_MOD>postTask); }
@org.junit.Test public void <START_MOD>shouldNotCallProcessWhenWebhookTypeIsMisconfigured<END_MOD>() { <START_MOD>mockConfig(); when(provider.getFactory(eq(<END_MOD>config<START_MOD>), eq<END_MOD>(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.<START_MOD>FOO)))<END_MOD>.<START_MOD>thenReturn(java<END_MOD>.<START_MOD>util<END_MOD>.<START_MOD>Optional<END_MOD>.<START_MOD>empty(<END_MOD>)); eventHandler.onEvent(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_CREATED); <START_MOD>verifyZeroInteractions(processor); verifyZeroInteractions<END_MOD>(postTask); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(<START_MOD>provider.getFactory(eq(config), eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO))).thenReturn(java.util.Optional.of(factory)); when(factory.create(any(com.google.gerrit.server.events.ProjectEvent.class))).thenReturn(processor); when(<END_MOD>taskFactory.create(anyString(), <START_MOD>eq(processor<END_MOD>))).thenReturn(postTask); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, taskFactory<START_MOD>, provider<END_MOD>); }
<START_MOD>boolean shouldPost(java.lang.String[] wantedEvents);<END_MOD>
<START_MOD>@java.lang.Override public java.lang.String process() { return com.googlesource.gerrit.plugins.webhooks.processors.JenkinsEventProcessor.GSON.toJson(event); }<END_MOD>
<START_MOD>@java.lang.Override public boolean shouldPost(java.lang.String[] wantedEvents) { if ((wantedEvents.length) == 0) { return true; } for (java.lang.String type : wantedEvents) { if ((!(com.google.common.base.Strings.isNullOrEmpty(type))) && (type.equals(event.getType()))) { return true; } } return false; }<END_MOD>
@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class); bind(com.googlesource.gerrit.plugins.webhooks.Configuration.class).in(Scopes.SINGLETON); bind(org.apache.http.impl.client.CloseableHttpClient.class).toProvider(com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class).in(Scopes.SINGLETON); factory(PostTask.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); <START_MOD>com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), EventProcessor.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), EventProcessor.Factory.class).to(JenkinsEventProcessor.Factory.class); <END_MOD>}
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if (<START_MOD>(!(id.isEmpty())) && ((id.charAt(0)) != '0')) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return asChangeControls(query.byLegacyChangeId(new com.google.gerrit.reviewdb.client.Change.Id(n)), user); } } if (<END_MOD>id.matches((("^([0-9a-fA-F]{4," + (com.google.gerrit.reviewdb.client.RevId.LEN)) + "})$"))) { return asChangeControls(query.byCommit(id), user); } if (!(id.contains("~"))) { return asChangeControls(query.byKeyPrefix(id), user); } java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id); if (triplet.isPresent()) { return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user); } return java.util.Collections.emptyList(); }
@java.lang.Override public void setStatus(java.lang.String status) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>common<END_MOD>.<START_MOD>StatusInput<END_MOD> in = new com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>common<END_MOD>.<START_MOD>StatusInput<END_MOD>(status); try { putStatus.apply(account, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( set status e); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.<START_MOD>extensions.common.StatusInput<END_MOD> input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.<START_MOD>extensions.common.StatusInput<END_MOD>(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> a.setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getStatus()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>common<END_MOD>.<START_MOD>StatusInput<END_MOD> input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } return apply(rsrc.getUser(), input); }
<START_MOD>protected void configLabel(java.lang.String label, com.google.gerrit.common.data.LabelValue... value) throws java.lang.Exception { configLabel(project, label, value); }<END_MOD>
<START_MOD>protected void configLabel(java.lang.String label) throws java.lang.Exception { configLabel(project, label, value(1, "Passes"), value(0, "No score"), value((-1), "Failed")); }<END_MOD>
@org.junit.Test public void <START_MOD>noNormalizeByPermission<END_MOD>() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); allow(pc, forLabel("Verified"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 2); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(<START_MOD>cr, <END_MOD>v), com.google.gerrit.server.git.LabelNormalizerTest.list(<START_MOD>), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list<END_MOD>(cr, v))); }
@org.junit.Test public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 0); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 0); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(cr<START_MOD>, <END_MOD>v)<START_MOD>, com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list()<END_MOD>), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
<START_MOD>protected void configLabel(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String label, com.google.gerrit.common.data.LabelValue... value) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.common.data.LabelType verified = category(label, value); cfg.getLabelSections().put(verified.getName(), verified); saveProjectConfig(project, cfg); }<END_MOD>
@org.junit.Test public void <START_MOD>emptyPermissionRangeKeepsResult<END_MOD>() throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 1); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(<START_MOD>cr, v<END_MOD>), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(change, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.common.data.LabelFunction<END_MOD> <START_MOD>getFunction<END_MOD>() { return <START_MOD>function<END_MOD>; }
public void <START_MOD>setFunction<END_MOD>(<START_MOD>@com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.common.Nullable<END_MOD> <START_MOD>com.google.gerrit.common.data.LabelFunction function<END_MOD>) { this.<START_MOD>function<END_MOD> = <START_MOD>function<END_MOD>; }
@org.junit.Test public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()<START_MOD>, com.google.gerrit.acceptance.git.DETAILED_LABELS, com.google.gerrit.acceptance.git.MESSAGES<END_MOD>); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(2); int indexAdmin = (admin.fullName.equals(cr.all.get(0).name)) ?   : 1; int indexUser = (indexAdmin == 0) ? 1 : 0; assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName); assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1); assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName); assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo( patch set 1: Code-Review+1. assertThatUserIsOnlyReviewer(ci, admin); }
@org.junit.Test public void pushNewPatchSetForMasterWithApprovals() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master"); r.assertOkStatus(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to("refs/for/master/%l=Code-Review+2"); ChangeInfo ci = get(r.getChangeId()<START_MOD>, com.google.gerrit.acceptance.git.DETAILED_LABELS, com.google.gerrit.acceptance.git.MESSAGES<END_MOD>); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo( patch set 2: Code-Review+2. assertThatUserIsOnlyReviewer(ci, admin); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value).isEqualTo(2); }
@org.junit.Test public void pushWithMultipleApprovals() throws java.lang.Exception { com.google.gerrit.common.data.LabelType Q = category("Custom-Label", value(1, "Positive"), value(0,   score value((-1), "Negative")); com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet(project).getConfig(); com.google.gerrit.reviewdb.client.AccountGroup.UUID anon = systemGroupBackend.getGroup(com.google.gerrit.acceptance.git.ANONYMOUS_USERS).getUUID(); java.lang.String heads = "refs/heads/*"; com.google.gerrit.server.project.Util.allow(config, com.google.gerrit.common.data.Permission.forLabel("Custom-Label"), (-1), 1, anon, heads); config.getLabelSections().put(Q.getName(), Q); saveProjectConfig(project, config); org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()<START_MOD>, com.google.gerrit.acceptance.git.DETAILED_LABELS<END_MOD>); com.google.gerrit.extensions.common.LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); cr = ci.labels.get("Custom-Label"); assertThat(cr.all).hasSize(1); assertThatUserIsOnlyReviewer(ci, admin); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create(<START_MOD>"patchSetNumber", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create(<END_MOD>"ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create(<START_MOD>"createdOn", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create(<END_MOD>"parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeDeletions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("is-draft", java.lang.Boolean.toString(patchSetAttribute.isDraft))); properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "author")); return properties; }
<START_MOD>private com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getGroupsWithMember(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id memberId) throws com.google.gwtorm.server.OrmException { java.util.stream.Stream<com.google.gerrit.server.group.InternalGroup> internalGroupStream; if (groupIndexProvider.get().getSchema().hasField(GroupField.MEMBER)) { internalGroupStream = groupQueryProvider.get().byMember(memberId).stream(); } else { internalGroupStream = com.google.gerrit.server.group.Groups.getGroupsWithMemberFromReviewDb(db, memberId).map(groupCache::get).flatMap(Streams::stream); } return internalGroupStream.map(InternalGroup::getGroupUUID).collect(toImmutableSet()); }<END_MOD>
<START_MOD>private com.google.gerrit.reviewdb.client.PatchSet findBasePatchSet(java.lang.String baseChange) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(baseChange); if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(("Base change not found: " + baseChange)); } com.google.gerrit.server.notedb.ChangeNotes change = com.google.common.collect.Iterables.getOnlyElement(notes); if (!(permissionBackend.user(user).change(change).database(db).test(ChangePermission.READ))) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(("Base change not found: " + baseChange)); } return psUtil.current(db.get(), change); }<END_MOD>
<START_MOD>@org.junit.Test public void createMergePatchSetCannotBaseOnInvisibleChange() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); createBranch("foo"); createBranch("bar"); merge(createChange("refs/for/foo")); testRepo.reset(initialHead); java.lang.String baseChange = createChange("refs/for/bar").getChangeId(); gApi.changes().id(baseChange).setPrivate(true, "set private"); setApiUser(user); testRepo.reset(initialHead); java.lang.String changeId = createChange().getChangeId(); exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); exception.expectMessage("Base change not found"); gApi.changes().id(changeId).createMergePatchSet(createMergePatchSetInput(baseChange)); }<END_MOD>
<START_MOD>private java.lang.String getPreviousRevision(com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gerrit.extensions.restapi.RestApiException { ChangeInfo info = gApi.changes().id(psId.getParentKey().get()).get(java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS)); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> e : info.revisions.entrySet()) { if ((e.getValue()._number) == ((psId.get()) - 1)) { return e.getKey(); } } return null; }<END_MOD>
public java.util.Map<java.lang.String, java.util.Set<java.lang.String>> getIssueIds(java.lang.String projectName, java.lang.String commitId, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> current = getIssueIds(projectName, commitId); if (patchSetId != null) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> previous = com.google.common.collect.Maps.newHashMap(); if ((patchSetId.get()) != 1) { <START_MOD>try { java.lang.String previousRevision = getPreviousRevision(patchSetId); if (previousRevision != null) { previous = getIssueIds(projectName, previousRevision); } } catch (<END_MOD>com.google.gerrit.<START_MOD>extensions.restapi.RestApiException e) { } } for (java.lang.String issue : current.keySet()) { java.util.Set<java.lang.String> currentOccurrences = current.get(issue); java.util.Set<java.lang.String> previousOccurrences = previous.get(issue); java.util.Set<java.lang.String> newOccurrences; if ((previousOccurrences == null) || (previousOccurrences.isEmpty())) { newOccurrences =<END_MOD> com.google.<START_MOD>common.collect.Sets.newHashSet(currentOccurrences); } else { newOccurrences =<END_MOD> com.google.<START_MOD>common.collect.Sets.newHashSet(currentOccurrences); newOccurrences.removeAll(previousOccurrences);<END_MOD> } for (java.lang.String <START_MOD>occurrence<END_MOD> : <START_MOD>newOccurrences) { currentOccurrences.add(("added@" + occurrence)); } } } return <END_MOD>current<START_MOD>; }<END_MOD>
@java.lang.Override protected void configure() { itsConfig = createMock(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class); bind(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(itsConfig); commitMessageFetcher = createMock(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class); bind(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class).toInstance(commitMessageFetcher); <START_MOD>com.google.gerrit.extensions.api.GerritApi gApi<END_MOD> = createMock(com.google.gerrit.<START_MOD>extensions.api.GerritApi.class); expect(gApi.changes()).andReturn(new com.google.gerrit.extensions.api.changes.Changes.NotImplemented() { @java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi id(int id) { com.google.gerrit.extensions.api.changes.ChangeApi cApi = changeApis.get(new com.google.gerrit.<END_MOD>reviewdb.<START_MOD>client.Change.Id(id)); assertNotNull(cApi); return cApi; } }).anyTimes(<END_MOD>); bind(com.google.gerrit.<START_MOD>extensions.api.GerritApi<END_MOD>.class).toInstance(<START_MOD>gApi<END_MOD>); }
@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp<START_MOD>(); changeApis = new java.util.HashMap(); changeInfos = new java.util.HashMap<END_MOD>(); injector = com.google.inject.Guice.createInjector(new com.googlesource.gerrit.plugins.its.base.util.IssueExtractorTest.TestModule()); }
<START_MOD>@org.junit.Test public void notesMigrationStateListener() throws java.lang.Exception { com.google.gerrit.server.notedb.rebuild.NotesMigrationStateListener listener = createStrictMock(com.google.gerrit.server.notedb.rebuild.NotesMigrationStateListener.class); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.REVIEW_DB, NotesMigrationState.WRITE); expectLastCall(); listener.preStateChange(NotesMigrationState.WRITE, com.google.gerrit.acceptance.server.notedb.READ_WRITE_NO_SEQUENCE); expectLastCall(); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_NO_SEQUENCE, com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); expectLastCall(); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY, com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY, com.google.gerrit.acceptance.server.notedb.NOTE_DB); expectLastCall(); replay(listener); addListener(listener); createChange(); migrate(( b) -> b); assertNotesMigrationState(com.google.gerrit.acceptance.server.notedb.NOTE_DB, false, false); verify(listener); }<END_MOD>
com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(java.lang.String endpoint, java.<START_MOD>util.Map<java.lang.String, java.lang.String> headers, java.<END_MOD>lang.String content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(endpoint); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); <START_MOD>headers.entrySet().stream().forEach(( e) -> { post.addHeader(e.getKey(), e.getValue()); }); <END_MOD>post.setEntity(new org.apache.http.entity.StringEntity(content, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL<START_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS<END_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public void run() { try { java.<START_MOD>util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Output><END_MOD> content = <START_MOD>processor<END_MOD>.get(); if (<START_MOD>!(content.isPresent()<END_MOD>)) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug( content. Webhook [{}] skipped. url); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(url, content<START_MOD>.get().headers, content.get().body<END_MOD>); if ((!(result.successful)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error( to post: {} toString(), e); } } }
@java.lang.Override public java.lang.String toString() { <START_MOD>java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Output><END_MOD> <START_MOD>content = processor<END_MOD>.get(); <START_MOD>return content.isPresent() ? content.get().toString() :   content <END_MOD>}
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<START_MOD>HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<END_MOD>BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL<START_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS<END_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public java.<START_MOD>util<END_MOD>.<START_MOD>Optional<com.googlesource.gerrit.plugins.webhooks.processors.Output><END_MOD> process() { return <START_MOD>java.util.Optional.of(new com.googlesource.gerrit.plugins.webhooks.EventProcessor.Output(<END_MOD>com.googlesource.gerrit.plugins.webhooks.processors.JenkinsEventProcessor.GSON.toJson(event)<START_MOD>))<END_MOD>; }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<START_MOD>HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<END_MOD>BODY)).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<START_MOD>HEADERS, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<END_MOD>BODY)).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(processor.process()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.<START_MOD>CONTENT<END_MOD>); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, processor); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws java.io.IOException {<START_MOD> com.google.gerrit.server.project.ProjectState projectState = projectCache.get(nameKey); if (projectState != null) { com.google.gerrit.server.project.ProjectData projectData = projectState.toProjectData();<END_MOD> for (com.google.gerrit.index.Index<?, com.google.gerrit.server.project.ProjectData> i : getWriteIndexes()) { i.replace(<START_MOD>projectData<END_MOD>); } fireProjectIndexedEvent(nameKey.get()); }<START_MOD> }<END_MOD>
@org.junit.Test public void addReviewerThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); <START_MOD>assert_().<END_MOD>fail( ResourceNotFoundException } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } setApiUser(admin); com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = user.email; com.google.gerrit.extensions.api.changes.AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in); assertThat(r.input).isEqualTo(user.email); assertThat(r.error).contains( not have permission to see this change assertThat(r.reviewers).isNull(); }
@org.junit.Test public void fetchExternalIdsBranch() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, user); try { com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); <START_MOD>assert_().<END_MOD>fail( TransportException } catch (org.eclipse.jgit.api.errors.TransportException e) { assertThat(e.getMessage()).isEqualTo((( does not have   + (com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS)) +   available for fetch. } allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); allUsersRepo = cloneProject(allUsers, user); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); }
@org.junit.Test public void addInvalidEmail() throws java.lang.Exception { java.util.List<java.lang.String> emails = com.google.common.collect.ImmutableList.of("new.email", "new.email@", "@example.com", "new.email@example.africa"); for (java.lang.String email : emails) { com.google.gerrit.extensions.api.accounts.EmailInput input = newEmailInput(email); try { gApi.accounts().self().addEmail(input); <START_MOD>assert_().<END_MOD>fail(( BadRequestException for invalid email address:   + email)); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { assertThat(e).hasMessageThat().isEqualTo( email address } } accountIndexedCounter.assertNoReindex(); }
@org.junit.Test public void deactivateNotActive() throws java.lang.Exception { assertThat(gApi.accounts().id("user").getActive()).isTrue(); gApi.accounts().id("user").setActive(false); assertThat(gApi.accounts().id("user").getActive()).isFalse(); try { gApi.accounts().id("user").setActive(false); <START_MOD>assert_().<END_MOD>fail( exception } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e.getMessage()).isEqualTo( not active } gApi.accounts().id("user").setActive(true); }
@org.junit.Test public void failWhenWritesDisabled() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); assertThat(gApi.changes().id(id.get()).info().topic).isNull(); setNotesMigration(false, true); try { gApi.changes().id(id.get()).topic(name("a-topic")); <START_MOD>assert_().<END_MOD>fail( write to fail } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isNull(); assertChangeUpToDate(true, id); }
@org.junit.Test public void rebuildWhenWritesDisabledWorksButDoesNotWrite() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); setNotesMigration(false, false); gApi.changes().id(id.get()).topic(name("a-topic")); setInvalidNoteDbState(id); assertChangeUpToDate(false, id); setNotesMigration(false, true); assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); try { gApi.changes().id(id.get()).topic(name("other-topic")); <START_MOD>assert_().<END_MOD>fail( write to fail } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); }
private void assertBadRequest(com.google.gerrit.extensions.api.plugins.Plugins.ListRequest req) throws java.lang.Exception { try { req.get(); <START_MOD>assert_().<END_MOD>fail( BadRequestException } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.TagInfo> req) throws java.lang.Exception { try { req.get(); <START_MOD>assert_().<END_MOD>fail( BadRequestException } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.BranchInfo> req) throws java.lang.Exception { try { req.get(); <START_MOD>assert_().<END_MOD>fail( BadRequestException } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
@org.junit.Test public void deleteBranchesNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); branches.add("refs/heads/does-not-exist"); input.branches = branches; try { project().deleteBranches(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void pushCommitOfOtherUserThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); ChangeInfo change = gApi.changes().id(result.getChangeId()).get(); assertThat(change.owner._accountId).isEqualTo(admin.id.get()); com.google.gerrit.extensions.common.CommitInfo commit = change.revisions.get(change.currentRevision).commit; assertThat(commit.author.email).isEqualTo(user.email); assertThat(commit.committer.email).isEqualTo(user.email); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); <START_MOD>assert_().<END_MOD>fail( ResourceNotFoundException } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.REVIEWER)).isNull(); assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.CC)).isNull(); assertThat(sender.getMessages()).isEmpty(); }
@org.junit.Test public void deleteBranchesNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList("refs/heads/does-not-exist"); branches.addAll(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); input.branches = branches; try { project().deleteBranches(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void mixingSubmitTypesOnOneBranchFails() throws java.lang.Exception { setRulesPl(com.google.gerrit.acceptance.api.change.SubmitTypeRuleIT.SUBMIT_TYPE_FROM_SUBJECT); com.google.gerrit.acceptance.PushOneCommit.Result r1 = createChange("master",   1 com.google.gerrit.acceptance.PushOneCommit.Result r2 = createChange("master",   2 gApi.changes().id(r1.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r2.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); try { gApi.changes().id(r2.getChangeId()).current().submit(); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(((((((( to submit 2 changes due to the following problems: +     + (r1.getChange().getId())) +   Change has submit type   +   but previously chose submit type MERGE_IF_NECESSARY   +   change   + (r2.getChange().getId())) +   in the same batch } }
@org.junit.Test public void deleteTagsNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList("refs/tags/does-not-exist"); tags.addAll(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); input.tags = tags; try { project().deleteTags(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); tags.add("refs/tags/does-not-exist"); input.tags = tags; try { project().deleteTags(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); input.tags = com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS; setApiUser(user); try { project().deleteTags(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS)); } setApiUser(admin); assertTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); }
private java.lang.String cherryPick(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case REWORK : case TRIVIAL_REBASE : break; case NO_CODE_CHANGE : case NO_CHANGE : case MERGE_FIRST_PARENT_UPDATE : default : <START_MOD>assert_().<END_MOD>fail(( change kind:   + changeKind)); } testRepo.reset(getRemoteHead()); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "other.txt", ( content   + (java.lang.System.nanoTime()))).to("refs/for/master"); r.assertOkStatus(); vote(admin, r.getChangeId(), 2, 1); merge(r); java.lang.String subject = (com.google.gerrit.acceptance.api.change.TRIVIAL_REBASE.equals(changeKind)) ? com.google.gerrit.acceptance.PushOneCommit.SUBJECT :   change   + (java.lang.System.nanoTime()); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "master"; in.message = java.lang.String.format( %s subject, changeId); com.google.gerrit.extensions.common.ChangeInfo c = gApi.changes().id(changeId).revision("current").cherryPick(in).get(); return c.changeId; }
private void updateChange(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case NO_CODE_CHANGE : noCodeChange(changeId); return; case REWORK : rework(changeId); return; case TRIVIAL_REBASE : trivialRebase(changeId); return; case MERGE_FIRST_PARENT_UPDATE : updateFirstParent(changeId); return; case NO_CHANGE : noChange(changeId); return; default : <START_MOD>assert_().<END_MOD>fail(( change kind:   + changeKind)); } }
private void assertBadRequest(com.google.gerrit.extensions.api.groups.Groups.ListRequest req) throws java.lang.Exception { try { req.get(); <START_MOD>assert_().<END_MOD>fail( BadRequestException } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
protected void submit(java.lang.String changeId, com.google.gerrit.extensions.api.changes.SubmitInput input, java.lang.Class<? extends com.google.gerrit.extensions.restapi.RestApiException> expectedExceptionType, java.lang.String expectedExceptionMsg) throws java.lang.Exception { approve(changeId); if (expectedExceptionType == null) { assertSubmittable(changeId); } try { gApi.changes().id(changeId).current().submit(input); if (expectedExceptionType != null) { <START_MOD>assert_().<END_MOD>fail(( exception of type   + (expectedExceptionType.getSimpleName()))); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { if (expectedExceptionType == null) { throw e; } if ((!(expectedExceptionType.isAssignableFrom(e.getClass()))) || (!(e.getMessage().equals(expectedExceptionMsg)))) { throw new java.lang.AssertionError((((((((( exception of type   + (expectedExceptionType.getSimpleName())) +   with message:   + expectedExceptionMsg) +   but got exception of type   + (e.getClass().getSimpleName())) +   with message   + (e.getMessage())) + "\""), e); } return; } com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).info(); assertMerged(change.changeId); }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.Projects.ListRequest req) throws java.lang.Exception { try { req.get(); <START_MOD>assert_().<END_MOD>fail( BadRequestException } catch (com.google.gerrit.extensions.restapi.BadRequestException expected) { } }
@org.junit.Test public void deleteBranchesForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); input.branches = com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES; setApiUser(user); try { project().deleteBranches(input); <START_MOD>assert_().<END_MOD>fail( ResourceConflictException } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES)); } setApiUser(admin); assertBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); }
@org.junit.Test public void createChangeRespectsCLA() throws java.lang.Exception { assume().that(isContributorAgreementsEnabled()).isTrue(); setUseContributorAgreements(InheritableBoolean.FALSE); gApi.changes().create(newChangeInput()); setUseContributorAgreements(InheritableBoolean.TRUE); try { gApi.changes().create(newChangeInput()); <START_MOD>assert_().<END_MOD>fail( AuthException } catch (com.google.gerrit.extensions.restapi.AuthException e) { assertThat(e.getMessage()).contains( Contributor Agreement must be completed } gApi.accounts().self().signAgreement(caAutoVerify.getName()); setApiUser(user); gApi.changes().create(newChangeInput()); }
<START_MOD>private java.util.List<com.google.gerrit.extensions.common.AccountInfo> getTransitiveMembers(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> members = getTransitiveMemberIds(group, groupControl, new java.util.HashSet(com.google.common.collect.ImmutableSet.of(group.getGroupUUID()))); return toAccountInfos(members); }<END_MOD>
<START_MOD>public java.util.List<com.google.gerrit.extensions.common.AccountInfo> getDirectMembers(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> directMembers = com.google.gerrit.server.group.ListMembers.getDirectMemberIds(group, groupControl); return toAccountInfos(directMembers); }<END_MOD>
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.<START_MOD>EXTERNAL_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.<END_MOD>AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); } }; }
<START_MOD>com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getSubgroups();<END_MOD>
@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.<START_MOD>EXTERNAL_NAME, java.lang.String<END_MOD>.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.<START_MOD>AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); <END_MOD>}
<START_MOD>com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> getMembers();<END_MOD>
<START_MOD>private java.lang.String shortenSubject(java.lang.String subject) { if ((subject.length()) < 73) { return subject; } else { return (subject.substring(0, 69)) + "..."; } }<END_MOD>
public static com.google.gerrit.extensions.common<START_MOD>.testing<END_MOD>.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.<START_MOD>testing.<END_MOD>RobotCommentInfoSubject.ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup( group for schema migration setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.<START_MOD>testing<END_MOD>.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup( for schema migration setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.<START_MOD>testing<END_MOD>.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isAtLeast(testStartTime); }
public static com.google.gerrit.extensions.common<START_MOD>.testing<END_MOD>.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.<START_MOD>testing.<END_MOD>FixReplacementInfoSubject.FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common<START_MOD>.testing<END_MOD>.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.<START_MOD>testing.<END_MOD>CommitInfoSubject.COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo); }
public static com.google.gerrit.extensions.restapi<START_MOD>.testing<END_MOD>.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.<START_MOD>testing.<END_MOD>BinaryResultSubject.BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult); }
private void createSubmoduleCommitMsg(java.lang.StringBuilder msgbuf, com.google.gerrit.reviewdb.client.SubmoduleSubscription s, com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo subOr, org.eclipse.jgit.revwalk.RevCommit newCommit, org.eclipse.jgit.revwalk.RevCommit oldCommit) throws com.google.gerrit.server.git.SubmoduleException { msgbuf.append(( Update   + (s.getPath()))); msgbuf.append((( from branch   + (s.getSubmodule().getShortName())) + "'")); <START_MOD>msgbuf.append(( to   + (newCommit.getName()))); <END_MOD>if (oldCommit == null) { return; } try { subOr.rw.resetRetain(subOr.canMergeFlag); subOr.rw.markStart(newCommit); subOr.rw.markUninteresting(oldCommit); for (org.eclipse.jgit.revwalk.RevCommit c : subOr.rw) { subOr.rw.parseBody(c); if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.SUBJECT_ONLY)) { msgbuf.append(( -   + (c.getShortMessage()))); } else if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.TRUE)) { msgbuf.append(( -   + (c.getFullMessage().replace("\n",     } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException( not perform a revwalk to create superproject commit message e); } }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn( event for a non-existing project {}, {} projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections(com.googlesource.gerrit.plugins.webhooks.<START_MOD>RemoteConfig<END_MOD>.REMOTE)) { <START_MOD>com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote<END_MOD> = <START_MOD>remoteFactory.create(<END_MOD>cfg, name); if (com.google.common.base.Strings.isNullOrEmpty(<START_MOD>remote.getUrl()<END_MOD>)) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn( not defined, skipping this remote name); continue; } com.googlesource.gerrit.plugins.webhooks.EventProcessor processor = processorFactory.create(projectEvent, <START_MOD>remote<END_MOD>); if (processor.shouldProcess()) { post(<START_MOD>remote<END_MOD>, processor); } } }
@org.junit.Test public void eventsNotSpecifiedAllEventsShouldPost() throws java.lang.Exception { when(<START_MOD>remote<END_MOD>.<START_MOD>getEvents<END_MOD>()).thenReturn(new java.lang.String[]{ }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, <START_MOD>remote<END_MOD>); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, <START_MOD>remote<END_MOD>); actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(com.<START_MOD>googlesource<END_MOD>.<START_MOD>gerrit<END_MOD>.<START_MOD>plugins<END_MOD>.<START_MOD>webhooks.RemoteConfig<END_MOD> <START_MOD>remote<END_MOD>, com.googlesource.gerrit.plugins.webhooks.EventProcessor processor);
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Result> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug( content. Webhook [{}] skipped. <START_MOD>remote.getUrl()<END_MOD>); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(<START_MOD>remote.getUrl()<END_MOD>, content.get().headers, <START_MOD>remote, <END_MOD>content.get().body); if ((!(result.successful)) && ((execCnt) < (<START_MOD>remote<END_MOD>.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (<START_MOD>remote<END_MOD>.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error( to post: {} toString(), e); } } }
<START_MOD>public org.eclipse.jgit.lib.Config getConfig() { return config; }<END_MOD>
<START_MOD>public java.lang.String getUrl() { return url.get(); }<END_MOD>
@java.lang.Override public boolean shouldProcess() { java.lang.String[] wantedEvents = <START_MOD>remote<END_MOD>.<START_MOD>getEvents<END_MOD>(); if ((wantedEvents.length) == 0) { return true; } for (java.lang.String type : wantedEvents) { if ((!(com.google.common.base.Strings.isNullOrEmpty(type))) && (type.equals(event.getType()))) { return true; } } return false; }
@org.junit.Test public void specifiedEventTypesShouldPost() throws java.lang.Exception { when(<START_MOD>remote<END_MOD>.<START_MOD>getEvents<END_MOD>()).thenReturn(new java.lang.String[]{ "project-created" }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, <START_MOD>remote<END_MOD>); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isTrue(); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS<START_MOD>, remote<END_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, <START_MOD>remote, <END_MOD>com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS<START_MOD>, remote<END_MOD>, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(<START_MOD>remote<END_MOD>.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(<START_MOD>remote<END_MOD>.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES<START_MOD>); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL<END_MOD>); when(processor.process()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.CONTENT); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, <START_MOD>remote<END_MOD>, processor); }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, <START_MOD>remote, <END_MOD>com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(java.lang.String endpoint, java.util.Map<java.lang.String, java.lang.String> headers, <START_MOD>com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote, <END_MOD>java.lang.String content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(endpoint); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); <START_MOD>post.setConfig(getConfig(remote)); <END_MOD>headers.entrySet().stream().forEach(( e) -> { post.addHeader(e.getKey(), e.getValue()); }); post.setEntity(new org.apache.http.entity.StringEntity(content, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(factory.create(any(com.google.gerrit.server.events.ProjectEvent.class), eq(<START_MOD>remote))).thenReturn(processor); when(taskFactory.create(eq(remote), eq(processor))).thenReturn(postTask); when(remoteFactory.create(any(org.eclipse.jgit.lib.Config.class<END_MOD>), eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO))).thenReturn(<START_MOD>remote); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, <END_MOD>taskFactory, factory<START_MOD>, remoteFactory<END_MOD>); }
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS, <START_MOD>remote, <END_MOD>com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY)).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void nonSpecifiedProjectEventTypesNotPosted() throws java.lang.Exception { when(<START_MOD>remote<END_MOD>.<START_MOD>getEvents<END_MOD>()).thenReturn(new java.lang.String[]{ "project-created" }); com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessor objectUnderTest = new com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.TestEventProcessor(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, <START_MOD>remote<END_MOD>); boolean actual = objectUnderTest.shouldProcess(); assertThat(actual).isFalse(); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Result> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug( content. Webhook [{}] skipped. remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.<START_MOD>get().<END_MOD>post(remote.getUrl(), content.get().headers, remote, content.get().body); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error( to post: {} toString(), e); } } }
@org.junit.Before public void setup() { when(remote.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(remote.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.CONTENT); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, <START_MOD>com.google.inject.util.Providers.of(<END_MOD>session<START_MOD>)<END_MOD>, processor, projectCreated, remote); }
<START_MOD>@org.junit.Test public void version() { boolean eclipse = java.util.Arrays.stream(java.lang.Thread.currentThread().getStackTrace()).anyMatch(( e) -> e.getClassName().startsWith("org.eclipse.jdt.")); java.util.regex.Pattern expected = (eclipse) ? com.google.gerrit.common.VersionTest.DEV_PATTERN : com.google.gerrit.common.VersionTest.GIT_DESCRIBE_PATTERN; assertThat(com.google.gerrit.common.Version.getVersion()).matches(expected); assertThat(com.google.gerrit.common.Version.getVersion()).matches(expected); }<END_MOD>
<START_MOD>@org.junit.Test public void pushToGroupBranchIsRejected() throws java.lang.Exception { grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); java.lang.String groupRefName = (com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo")); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update group config", "group.config", "some content").setParents(com.google.common.collect.ImmutableList.of()).to(groupRefName); r.assertErrorStatus("group update not allowed"); createGroupBranch(groupRefName); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (groupRefName + ":groupRef")); allUsersRepo.reset("groupRef"); r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update group config", "group.config", "some content").to(groupRefName); r.assertErrorStatus("group update not allowed"); }<END_MOD>
<START_MOD>private void createGroupBranch(java.lang.String ref) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(allUsers);org.eclipse.jgit.lib.ObjectInserter oi = r.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyTree = oi.insert(Constants.OBJ_TREE, new byte[]{ }); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(emptyTree); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage("Create group"); org.eclipse.jgit.lib.ObjectId emptyCommit = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(ref); updateRef.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.update(rw)).isEqualTo(RefUpdate.Result.NEW); } }<END_MOD>
<START_MOD>@org.junit.Test public void pushToGroupBranchForReviewIsRejectedOnSubmit() throws java.lang.Exception { grantLabel("Code-Review", (-2), 2, allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS, false); grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.SUBMIT, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); java.lang.String groupRefName = (com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo")); createGroupBranch(groupRefName); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (groupRefName + ":groupRef")); allUsersRepo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update group config", "group.config", "some content").to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + groupRefName)); r.assertOkStatus(); assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRefName); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("group update not allowed"); gApi.changes().id(r.getChangeId()).current().submit(); }<END_MOD>
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> additions) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(( edit global capabilities for projects other than   + (allProjects.get()))); }<START_MOD> } if (section.getName().startsWith(RefNames.REFS_GROUPS)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( on %s is managed by Gerrit and cannot be modified RefNames.REFS_GROUPS));<END_MOD> } } for (com.google.gerrit.common.data.AccessSection section : additions) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (!isGlobalCapabilities) { if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( section name } com.google.gerrit.server.project.RefPattern.validate(name); } else { for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isCapability(p.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException((( add non-global capability   + (p.getName())) +   to global capabilities } } } } }
<START_MOD>@org.junit.Test public void updateGroupRefPermissions() throws java.lang.Exception { ProjectAccessInput accessInput = newProjectAccessInput(); accessInput.add.put(((RefNames.REFS_GROUPS) + "*"), createDefaultAccessSectionInfo()); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("Permissions on refs/groups/ is managed by Gerrit and cannot be modified"); gApi.projects().name(project.get()).access(accessInput); }<END_MOD>
@java.lang.Override public RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); next = seed.get(); } else { oldId = ref.getObjectId(); next = parse(<START_MOD>rw, <END_MOD>oldId); } return store(repo, rw, oldId, ((next) + (count))); }
<START_MOD>@java.lang.Override public RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); } else { oldId = ref.getObjectId(); int next = parse(rw, oldId); if (next >= (value)) { return RefUpdate.Result.NO_CHANGE; } } return store(repo, rw, oldId, value); }<END_MOD>
<START_MOD>@org.junit.Test public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r1 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "groups", "global:Registered-Users\tRegistered Users").to(RefNames.REFS_CONFIG); r1.assertOkStatus(); com.google.gerrit.acceptance.PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG); r2.assertOkStatus(); }<END_MOD>
<START_MOD>@org.junit.Test public void pushGroupsAccessSectionChangeToAllUsersFails() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG); r.assertErrorStatus("invalid project configuration"); r.assertMessage("permissions on refs/groups/ is managed by gerrit and cannot be modified"); }<END_MOD>
<START_MOD>@org.junit.Test public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig(); com.google.gerrit.common.data.AccessSection as = new com.google.gerrit.common.data.AccessSection(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo")); com.google.gerrit.common.data.Permission perm = new com.google.gerrit.common.data.Permission("push"); perm.add(new com.google.gerrit.common.data.PermissionRule(systemGroupBackend.getGroup(com.google.gerrit.acceptance.api.group.ANONYMOUS_USERS))); as.addPermission(perm); projectConfig.replace(as); saveProjectConfig(allUsers, projectConfig); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString(); assertThat(config).contains("[access \"refs/groups/foo\"]"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG); r.assertOkStatus(); }<END_MOD>
<START_MOD>@org.junit.Test public void allUsersCanOnlyInheritFromAllProjects() throws java.lang.Exception { com.google.gerrit.extensions.api.access.ProjectAccessInput accessInput = newProjectAccessInput(); accessInput.parent = project.get(); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("All-Users must inherit from All-Projects"); gApi.projects().name("All-Users").access(accessInput); }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "user.writeGroupsToNoteDb", value = "true") public void createGroupWithPropertiesWithWriteToNoteDb() throws java.lang.Exception { testCreateGroupWithProperties(true); }<END_MOD>
<START_MOD>private void assertGroupOwnerPermissions(java.lang.String groupUuid, java.lang.String expectedOwnerUuid) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.access.PermissionInfo newPermissionInfo = new com.google.gerrit.extensions.api.access.PermissionInfo(null, null); newPermissionInfo.rules = com.google.common.collect.ImmutableMap.of(expectedOwnerUuid, new com.google.gerrit.extensions.api.access.PermissionRuleInfo(com.google.gerrit.extensions.api.access.PermissionRuleInfo.Action.ALLOW, false)); ProjectAccessInfo access = gApi.projects().name(allUsersName.get()).access(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(AccountGroup.UUID.parse(groupUuid)); assertThat(access.local).containsKey(groupRef); assertThat(access.local.get(groupRef).permissions).containsExactly(Permission.PUSH, newPermissionInfo, Permission.READ, newPermissionInfo); }<END_MOD>
<START_MOD>private void testCreateGroup(boolean writeGroupsToNoteDb) throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(newGroupName).get(); com.google.gerrit.acceptance.api.group.GroupAssert.assertGroupInfo(getFromCache(newGroupName), g); if (writeGroupsToNoteDb) { assertGroupOwnerPermissions(g.id, g.id); } }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "user.writeGroupsToNoteDb", value = "true") public void groupOwnerWithWriteToNoteDb() throws java.lang.Exception { testGroupOwner(true); }<END_MOD>
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws<START_MOD> com.google.gwtorm.server.OrmException,<END_MOD> java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = loadFor(groupUuid); if (!(groupConfig.getLoadedGroup().isPresent())) { return java.util.Optional.empty(); } return updateGroupInNoteDb(groupConfig, groupUpdate); }
<START_MOD>private void testGroupOwner(boolean writeGroupsToNoteDb) throws java.lang.Exception { java.lang.String name = name("group"); com.google.gerrit.extensions.common.GroupInfo info = gApi.groups().create(name).get(); java.lang.String adminUUID = getFromCache("Administrators").getGroupUUID().get(); java.lang.String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get(); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id); gApi.groups().id(name).owner("Registered Users"); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID); if (writeGroupsToNoteDb) { assertGroupOwnerPermissions(info.id, registeredUUID); } gApi.groups().id(name).owner(adminUUID); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID); if (writeGroupsToNoteDb) { assertGroupOwnerPermissions(info.id, adminUUID); } exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); gApi.groups().id(name).owner("Non-Existing Group"); }<END_MOD>
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.server.group.db.GroupConfig groupConfig, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws<START_MOD> com.google.gwtorm.server.OrmException,<END_MOD> java.io.IOException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> originalGroup = groupConfig.getLoadedGroup(); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(groupConfig); com.google.gerrit.server.group.InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( group wasn automatically loaded <START_MOD>updateOwnerPermissions(updatedGroup, (originalGroup.isPresent() ? originalGroup.get().getOwnerGroupUUID() : null)); <END_MOD>java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> modifiedMembers = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedMembers(originalGroup, updatedGroup); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> modifiedSubgroups = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedSubgroups(originalGroup, updatedGroup); java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> previousName = com.google.gerrit.server.group.db.GroupsUpdate.getPreviousNameIfModified(originalGroup, updatedGroup); com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.Builder resultBuilder = com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups); previousName.ifPresent(resultBuilder::setPreviousGroupName); return java.util.Optional.of(resultBuilder.build()); }
<START_MOD>private void testCreateGroupWithProperties(boolean writeGroupsToNoteDb) throws java.lang.Exception { com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("newGroup"); in.description = "Test description"; in.visibleToAll = true; in.ownerId = getFromCache("Administrators").getGroupUUID().get(); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(in).detail(); assertThat(g.description).isEqualTo(in.description); assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll); assertThat(g.ownerId).isEqualTo(in.ownerId); if (writeGroupsToNoteDb) { assertGroupOwnerPermissions(g.id, in.ownerId); } }<END_MOD>
@org.junit.Test public void createGroup() throws java.lang.Exception { <START_MOD>testCreateGroup<END_MOD>(<START_MOD>false<END_MOD>); }
@org.junit.Test public void createGroupWithProperties() throws java.lang.Exception { <START_MOD>testCreateGroupWithProperties<END_MOD>(<START_MOD>false<END_MOD>); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "user.writeGroupsToNoteDb", value = "true") public void createGroupWithWriteToNoteDb() throws java.lang.Exception { testCreateGroup(true); }<END_MOD>
@org.junit.Test public void groupOwner() throws java.lang.Exception { <START_MOD>testGroupOwner<END_MOD>(<START_MOD>false<END_MOD>); }
private com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData load(int expectedValue) throws java.lang.Exception { <START_MOD>return<END_MOD> load(<START_MOD>"refs/meta/config",<END_MOD> expectedValue); }
<START_MOD>@org.junit.Test public void sharedBatchRefUpdate() throws java.lang.Exception { com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData d1 = load("refs/meta/1", 0); com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData d2 = load("refs/meta/2", 0); org.eclipse.jgit.lib.BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate(); try (com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch1 = d1.openUpdate(newMetaDataUpdate(bru));com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch2 = d2.openUpdate(newMetaDataUpdate(bru))) { d1.setIncrement(1); batch1.write(d1, newCommitBuilder()); d2.setIncrement(2); batch2.write(d2, newCommitBuilder()); d1.setIncrement(2); batch1.write(d1, newCommitBuilder()); d2.setIncrement(1); batch2.write(d2, newCommitBuilder()); batch1.commit(); batch2.commit(); } assertMyMetaData(d1.getRefName(), 0); assertMyMetaData(d2.getRefName(), 0); assertThat(bru.getCommands().stream().map(ReceiveCommand::getRefName)).containsExactly("refs/meta/1", "refs/meta/2"); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.update.RefUpdateUtil.executeChecked(bru, rw); } assertMyMetaData(d1.getRefName(), 3, "Increment conf.value by 1", "Increment conf.value by 2"); assertMyMetaData(d2.getRefName(), 3, "Increment conf.value by 2", "Increment conf.value by 1"); }<END_MOD>
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Repository <START_MOD>destRepo<END_MOD> = reader.openRepository(c.<START_MOD>getDestRepoKey().toString()); com.googlesource.gerrit.plugins.supermanifest.JiriProjects projects = com.googlesource.gerrit.plugins.supermanifest.JiriManifestParser.getProjects(reader, c.<END_MOD>getSrcRepoKey().toString()<START_MOD>, srcRef, c.getXmlPath()); java.lang.String targetRef = (c.getDestBranch().equals("*")) ? srcRef : (REFS_HEADS) + (c.getDestBranch()); updateSubmodules(<END_MOD>destRepo<START_MOD>, targetRef, java.net.URI.create((<END_MOD>(c.getDestRepoKey().toString())<START_MOD> + "/")),<END_MOD> projects, reader); }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.<START_MOD>ProjectState<END_MOD> <START_MOD>projectState<END_MOD> = <START_MOD>projectCache<END_MOD>.<START_MOD>checkedGet<END_MOD>(name); if (<START_MOD>(projectState<END_MOD>.getProject().getState()<START_MOD>) == (com<END_MOD>.<START_MOD>google.gerrit.server.project.<END_MOD>ProjectState.HIDDEN)) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(<START_MOD>projectState, userProvider.get()<END_MOD>, repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }
@org.junit.Test public void createBranchByAdmin() throws java.lang.Exception { assertCreateSucceeds(<START_MOD>branch<END_MOD>); }
@org.junit.Test public void createBranchByAdminCreateReferenceBlocked_Forbidden() throws java.lang.Exception { blockCreateReference(); assertCreateFails(<START_MOD>branch, <END_MOD>com.google.gerrit.extensions.restapi.AuthException.class,   not permitted for refs/heads/test }
@org.junit.Test public void createBranchByProjectOwnerCreateReferenceBlocked_Forbidden() throws java.lang.Exception { grantOwner(); blockCreateReference(); setApiUser(user); assertCreateFails(<START_MOD>branch, <END_MOD>com.google.gerrit.extensions.restapi.AuthException.class,   not permitted for refs/heads/test }
@org.junit.Test public void createBranchByProjectOwner() throws java.lang.Exception { grantOwner(); setApiUser(user); assertCreateSucceeds(<START_MOD>branch<END_MOD>); }
@org.junit.Test public void createBranch_Forbidden() throws java.lang.Exception { setApiUser(user); assertCreateFails(<START_MOD>branch, <END_MOD>com.google.gerrit.extensions.restapi.AuthException.class,   not permitted for refs/heads/test }
@org.junit.Test public void branchAlreadyExists_Conflict() throws java.lang.Exception { assertCreateSucceeds(<START_MOD>branch<END_MOD>); assertCreateFails(<START_MOD>branch, <END_MOD>com.google.gerrit.extensions.restapi.ResourceConflictException.class); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(cfg.getBoolean("user", "writeGroupsToNoteDb", false)).isTrue(); grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.DELETE, true, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); com.google.gerrit.server.group.InternalGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null); assertThat(adminGroup).isNotNull(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroup.getGroupUUID()); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains("Not allowed to delete group branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNotNull(); } }<END_MOD>
@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).<START_MOD>maximumWeight(4096).<END_MOD>loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); } }; }
@java.lang.Override public void viewAccepted(org.jgroups.View view) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info( {}) called view); synchronized(this) { if ((view.getMembers().size()) > 2) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.warn( members joined the jgroups <START_MOD>cluster<END_MOD> {}. Only two members are supported. Members: {} view.getMembers().size(), <START_MOD>jgroupsConfig.clusterName(), view.getMembers()); } if (((peerAddress) != null) && (!(view.getMembers().contains(peerAddress)))) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info( removed peerInfo peerAddress = null; peerInfo = java.util.Optional.empty(); } } if ((view.size()) > 1) { try { <END_MOD>channel.<START_MOD>send(new org.jgroups.Message(null, myUrl)); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error( a message over channel {} to cluster {} failed channel.<END_MOD>getName(), <START_MOD>jgroupsConfig.clusterName(),<END_MOD> e)<START_MOD>; } } }<END_MOD>
public void connect() { try { channel = new org.jgroups.JChannel(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { channel.getProtocolStack().getTransport().setBindAddress(address.get()); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info( <START_MOD>{} succesfully <END_MOD>joined jgroups <START_MOD>cluster {} channel.getName(), jgroupsConfig.clusterName()<END_MOD>); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error( <START_MOD>cluster {} for<END_MOD> channel {} failed <START_MOD>jgroupsConfig.clusterName(), channel.getName(), <END_MOD>e); } }
@java.lang.Override public void cleanUp() { for (java.nio.file.Path path : listFiles()) { com.google.gerrit.httpd.WebSessionManager.Val val = readFile(path); if (val != null) { <START_MOD>java<END_MOD>.time.<START_MOD>Instant<END_MOD> expires = <START_MOD>java<END_MOD>.time.<START_MOD>Instant.ofEpochMilli<END_MOD>(val.getExpiresAt()); if (expires.isBefore(<START_MOD>java<END_MOD>.time.<START_MOD>Instant.now<END_MOD>())) { deleteFile(path); } } } }
<START_MOD>@java.lang.Override public <V> java.util.Collection<V> readField(com.google.gerrit.index.FieldDef<com.google.gerrit.server.query.change.ChangeData, V> field) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(); }<END_MOD>
<START_MOD>default <T> java.util.Collection<T> getField(K key, com.google.gerrit.index.QueryOptions opts, com.google.gerrit.index.FieldDef<V, T> fieldDef) throws java.io.IOException { opts = opts.withStart(0).withLimit(2); try { return getSource(keyPredicate(key), opts).readField(fieldDef); } catch (com.google.gerrit.index.query.QueryParseException e) { throw new java.io.IOException("Unexpected QueryParseException during get()", e); } catch (com.google.gwtorm.server.OrmException e) { throw new java.io.IOException(e); } }<END_MOD>
<START_MOD>@java.lang.Override public <V> java.util.Collection<V> readField(com.google.gerrit.index.FieldDef<T, V> field) throws com.google.gwtorm.server.OrmException { return null; }<END_MOD>
<START_MOD>@java.lang.Override public <V> java.util.Collection<V> readField(com.google.gerrit.index.FieldDef<com.google.gerrit.server.project.ProjectData, V> field) throws com.google.gwtorm.server.OrmException { return null; }<END_MOD>
<START_MOD><V> java.util.Collection<V> readField(com.google.gerrit.index.FieldDef<T, V> field) throws com.google.gwtorm.server.OrmException;<END_MOD>
<START_MOD>@java.lang.Override public <V> java.util.Collection<V> readField(com.google.gerrit.index.FieldDef<T, V> field) throws com.google.gwtorm.server.OrmException { return source.readField(field); }<END_MOD>
<START_MOD>@org.junit.Test public void advertisedReferencesOmitUserBranchedOfOtherUsers() throws java.lang.Exception { allow(allUsersName, ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + "*"), Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<?> userTestRepository = cloneProject(allUsers, user); try (org.eclipse.jgit.api.Git git = userTestRepository.git()) { java.util.List<java.lang.String> refs = git.lsRemote().call().stream().map(Ref::getName).collect(java.util.stream.Collectors.toList()); java.util.List<java.lang.String> userRefs = refs.stream().filter(RefNames::isRefsUsers).collect(java.util.stream.Collectors.toList()); assertThat(userRefs).containsExactly(RefNames.REFS_USERS_SELF, com.google.gerrit.reviewdb.client.RefNames.refsUsers(user.id)); } }<END_MOD>
<START_MOD>@org.junit.Test public void advertisedReferencesIncludeAllUserBranchesWithAccessDatabase() throws java.lang.Exception { allow(allUsersName, ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + "*"), Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); allowGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); try { org.eclipse.jgit.junit.TestRepository<?> userTestRepository = cloneProject(allUsers, user); try (org.eclipse.jgit.api.Git git = userTestRepository.git()) { java.util.List<java.lang.String> refs = git.lsRemote().call().stream().map(Ref::getName).collect(java.util.stream.Collectors.toList()); java.util.List<java.lang.String> userRefs = refs.stream().filter(RefNames::isRefsUsers).collect(java.util.stream.Collectors.toList()); assertThat(userRefs).containsExactly(RefNames.REFS_USERS_SELF, com.google.gerrit.reviewdb.client.RefNames.refsUsers(user.id), com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)); } } finally { removeGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); } }<END_MOD>
@java.lang.Override protected void configure() { if (!(enabled)) { bind(com.google.gerrit.server.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiModule.NoGpgApi.class); return; } bind(com.google.gerrit.server.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiAdapterImpl.class); factory(GpgKeyApiImpl.Factory.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.gpg.api.GPG_KEY_KIND); child(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.GpgKeys.class); post(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.PostGpgKeys.class); get(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(GpgKeys.Get.class); delete(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(com.google.gerrit.gpg.server.DeleteGpgKey.class); }
<START_MOD>@org.junit.Test public void stalenessChecker() throws java.lang.Exception { assume().that(isNoteDbConfig()).isTrue(); com.google.gerrit.extensions.common.GroupInfo groupInfo = gApi.groups().create(name("foo")).get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupInfo.id); assertThat(stalenessChecker.isStale(groupUuid)).isFalse(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(groupUuid); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId()); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(commit.getTree()); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage(commit.getFullMessage()); org.eclipse.jgit.lib.ObjectId emptyCommit = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate updateRef = repo.updateRef(groupRef); updateRef.setExpectedOldObjectId(commit.toObjectId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED); } assertThat(stalenessChecker.isStale(groupUuid)).isTrue(); gApi.groups().id(groupInfo.id).index(); assertThat(stalenessChecker.isStale(groupUuid)).isFalse(); }<END_MOD>
<START_MOD>private boolean isNoteDbConfig() { return baseConfig.getBoolean("user", "writeGroupsToNoteDb", false); }<END_MOD>
<START_MOD>public boolean isStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(config.getBoolean("user", "readGroupsFromNoteDb", false))) { return false; } com.google.gerrit.server.index.group.GroupIndex i = indexes.getSearchIndex(); if (i == null) { return false; } if (!(i.getSchema().hasField(GroupField.REF_STATE))) { return false; } java.util.Optional<com.google.gerrit.server.group.InternalGroup> result = i.get(id, com.google.gerrit.server.index.group.IndexedGroupQuery.createOptions(indexConfig, 0, 1, com.google.gerrit.server.index.group.StalenessChecker.FIELDS)); if (!(result.isPresent())) { return true; } com.google.gerrit.server.group.InternalGroup group = result.get(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ref = repo.findRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(id)); org.eclipse.jgit.lib.ObjectId head = (ref == null) ? org.eclipse.jgit.lib.ObjectId.zeroId() : ref.getObjectId(); return !(head.equals(group.getRefState())); } }<END_MOD>
@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getOldFilePath(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit.create(edit.getOldFilePath(), adjustedFilePath, edit.getBeginA(), edit.getEndA(), ((edit.getBeginB()) + shiftedAmount), ((edit.getEndB()) + shiftedAmount), (!(java.util.Objects.equals(edit.getNewFilePath(), adjustedFilePath)))); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList listFor(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { return patchListCache.get(key, notes.getProjectName()); }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList list, org.eclipse.jgit.lib.Repository git) { final com.google.gerrit.server.patch.PatchScriptBuilder b = builderFactory.get(); b.setRepository(git, notes.getProjectName()); b.setChange(notes.getChange()); b.setDiffPrefs(diffPrefs); b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId()); return b; }
public java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.<START_MOD>DiffSummary<END_MOD>.ChangedLines> changedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((changedLines) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } changedLines = computeChangedLines(); } return changedLines; }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey keyFor(com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { if ((parentNum) < 0) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstCommit(aId, bId, whitespace); } return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstParentNum(((parentNum) + 1), bId, whitespace); }
@org.junit.Test public void empty1() { final java.lang.String name = "empty-file"; final com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.empty(name); assertNull(e.getOldName()); assertEquals(name, e.getNewName()); assertSame(PatchType.UNIFIED, e.getPatchType()); assertSame(Patch.ChangeType.MODIFIED, e.getChangeType()); assertTrue(e.getEdits().isEmpty()); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree); if (tw == null) { return Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB)); } else if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_COMMIT)) { java.lang.String str =   commit   + (org.eclipse.jgit.lib.ObjectId.toString(tw.getObjectId(0))); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(str.getBytes(java.nio.charset.StandardCharsets.UTF_8)); } else { return Text.EMPTY; } }
private static boolean isBlankLineGap(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text a, int b, int e) { for (; b < e; b++) { if (!(com.google.gerrit.server.patch.IntraLineLoader.BLANK_LINE_RE.matcher(a.getString(b)).matches())) { return false; } } return true; }
private static boolean isControlBlockStart(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text a, int idx) { return com.google.gerrit.server.patch.IntraLineLoader.CONTROL_BLOCK_START_RE.matcher(a.getString(idx)).find(); }
com.google.gerrit.server.patch.IntraLineLoader create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs args);
private static void combineLineEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.server.<START_MOD>patchlib.Text a, com.google.gerrit.server.patchlib.Text b) { for (int j = 0; j < ((edits.size()) - 1);) { org.eclipse.jgit.diff.Edit c = edits.get(j); org.eclipse.jgit.diff.Edit n = edits.get((j + 1)); final int ad = (n.getBeginA()) - (c.getEndA()); final int bd = (n.getBeginB()) - (c.getEndB()); if ((((1 <= ad) && (com.google.gerrit.server.<END_MOD>patch.<START_MOD>IntraLineLoader.isBlankLineGap(<END_MOD>a, <START_MOD>c.getEndA(), n.getBeginA()))) || ((1 <= bd) && (<END_MOD>com.google.gerrit.server.patch.<START_MOD>IntraLineLoader.isBlankLineGap(<END_MOD>b<START_MOD>, c.getEndB(), n.getBeginB())))) || (((ad == 1) && (bd == 1)) && (com.google.gerrit.server.patch.IntraLineLoader.isControlBlockStart(a, c.getEndA())))<END_MOD>) { <START_MOD>int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); edits.set(j, new<END_MOD> org.eclipse.jgit.diff.Edit<START_MOD>(ab, ae, bb, be)); edits.remove<END_MOD>((j + 1)); continue; } j++; } }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary call() throws java.lang.Exception { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList patchList = patchListCache.get(key.toPatchListKey(), project); return com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(patchList); }
void setTrees(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType ct, org.eclipse.jgit.lib.ObjectId a, org.eclipse.jgit.lib.ObjectId b) { comparisonType = ct; aId = a; bId = b; }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public static java.util.stream.Stream<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> toEdits(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry) { com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> edits = patchListEntry.getEdits(); if (edits.isEmpty()) { return java.util.stream.Stream.of(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit.createForNoContentEdit(patchListEntry)); } return edits.stream().map(( edit) -> com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ContextAwareEdit.create(patchListEntry, edit)); }
private static org.eclipse.jgit.diff.Edit copy(org.eclipse.jgit.diff.Edit edit) { if (edit instanceof org.eclipse.jgit.diff.ReplaceEdit) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.copy(((org.eclipse.jgit.diff.ReplaceEdit) (edit))); } return new org.eclipse.jgit.diff.Edit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB()); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeEnum(out, status); writeVarInt32(out, edits.size()); for (org.eclipse.jgit.diff.Edit e : edits) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.writeEdit(out, e); if (e instanceof org.eclipse.jgit.diff.ReplaceEdit) { org.eclipse.jgit.diff.ReplaceEdit r = ((org.eclipse.jgit.diff.ReplaceEdit) (e)); writeVarInt32(out, r.getInternalEdits().size()); for (org.eclipse.jgit.diff.Edit i : r.getInternalEdits()) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.writeEdit(out, i); } } else { writeVarInt32(out, 0); } } }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey create(org.eclipse.jgit.lib.ObjectId aId, org.eclipse.jgit.lib.ObjectId bId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.AutoValue_IntraLineDiffKey(aId, bId, whitespace); }
public java.util.List<java.lang.String> currentFilePaths() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((currentFiles) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary> p = getDiffSummary(); currentFiles = p.map(DiffSummary::getPaths).orElse(java.util.Collections.emptyList()); } return currentFiles; }
private java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.<START_MOD>DiffSummary<END_MOD>.ChangedLines> computeChangedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary> ds = getDiffSummary(); if (ds.isPresent()) { return java.util.Optional.of(ds.get().getChangedLines()); } return java.util.Optional.empty(); }
@java.lang.Override public int hash(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.CharText seq, int ptr) { return seq.charAt(ptr); }
public void setChangedLines(int insertions, int deletions) { changedLines = java.util.Optional.of(new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.<START_MOD>DiffSummary<END_MOD>.ChangedLines(insertions, deletions)); }
private java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary> getDiffSummary() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((diffSummary) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Change c = change(); com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (((c == null) || (ps == null)) || (!(loadCommitData()))) { return java.util.Optional.empty(); } org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey pk = ((parentCount) > 1) ? com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstParentNum(1, id, ws) : com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstDefaultBase(id, ws); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey.fromPatchListKey(pk); try { diffSummary = java.util.Optional.of(patchListCache.getDiffSummary(key, c.getProject())); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { diffSummary = java.util.Optional.empty(); } } return diffSummary; }
private static org.eclipse.jgit.diff.ReplaceEdit copy(org.eclipse.jgit.diff.ReplaceEdit edit) { java.util.List<org.eclipse.jgit.diff.Edit> internalEdits = edit.getInternalEdits().stream().map(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff::copy).collect(java.util.stream.Collectors.toList()); return new org.eclipse.jgit.diff.ReplaceEdit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), internalEdits); }
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.Status getStatus() { return status; }
public void transformReferencesOfSideA(java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.SideAStrategy.INSTANCE); }
@java.lang.Override public int getEnd(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getEndB(); }
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit create(java.lang.String oldFilePath, java.lang.String newFilePath, int beginA, int endA, int beginB, int endB, boolean filePathAdjusted) { java.lang.String adjustedOldFilePath = com.google.common.base.MoreObjects.firstNonNull(oldFilePath, newFilePath); boolean implicitRename = (!(java.util.Objects.equals(oldFilePath, newFilePath))) && filePathAdjusted; return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.AutoValue_EditTransformer_ContextAwareEdit(adjustedOldFilePath, newFilePath, beginA, endA, beginB, endB, implicitRename); }
private static java.lang.String newName(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry entry) { switch (entry.getChangeType()) { case DELETED : return null; case ADDED : case MODIFIED : case COPIED : case RENAMED : case REWRITE : default : return entry.getNewName(); } }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit.create(adjustedFilePath, edit.getNewFilePath(), ((edit.getBeginA()) + shiftedAmount), ((edit.getEndA()) + shiftedAmount), edit.getBeginB(), edit.getEndB(), (!(java.util.Objects.equals(edit.getOldFilePath(), adjustedFilePath)))); }
@java.lang.Override public int getBegin(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getBeginA(); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); } }; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary getDiffSummary(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { try { return diffSummaryCache.get(key, diffSummaryLoaderFactory.create(key, project)); } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(( computing   + key), e); throw new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { PatchListLoader.log.warn(( computing   + key), e); throw new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException(e); } throw e; } }
@java.lang.Override public int getBegin(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getBeginB(); }
private static boolean isModify(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry content) { switch (content.getChangeType()) { case MODIFIED : case COPIED : case RENAMED : case REWRITE : return true; case ADDED : case DELETED : default : return false; } }
private java.lang.String getLine(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchFile fileInfo, short side, int lineNbr) { try { return fileInfo.getLine(side, lineNbr); } catch (java.io.IOException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format( to read file on side %d side), err); return ""; } catch (java.lang.IndexOutOfBoundsException err) { com.google.gerrit.server.mail.send.CommentSender.log.debug(java.lang.String.format( to get line number of file on side %d side), err); return ""; } catch (com.google.gerrit.common.errors.NoSuchEntityException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format( %d of file didn exist side), err); return ""; } }
private java.util.List<java.lang.String> getLinesByRange(com.google.gerrit.reviewdb.client.Comment.Range range, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchFile fileData, short side) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); for (int n = range.startLine; n <= (range.endLine); n++) { java.lang.String s = getLine(fileData, side, n); if (((n == (range.startLine)) && (n == (range.endLine))) && ((range.startChar) < (range.endChar))) { s = s.substring(java.lang.Math.min(range.startChar, s.length()), java.lang.Math.min(range.endChar, s.length())); } else if (n == (range.startLine)) { s = s.substring(java.lang.Math.min(range.startChar, s.length())); } else if (n == (range.endLine)) { s = s.substring(0, java.lang.Math.min(range.endChar, s.length())); } lines.add(s); } return lines; }
private static java.util.stream.Stream<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> transformEdits(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.SideStrategy sideStrategy, java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> originalEdits, java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> transformingEntries) { if (transformingEntries.isEmpty()) { return originalEdits.stream(); } return transformingEntries.stream().flatMap(( transEntry) -> transformEdits(sideStrategy, originalEdits, transEntry.getEdits(), transEntry.getNewName()).stream()); }
int getBegin(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib.PatchList get(com.google.gerrit.server.patchlib.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patchlib.PatchListNotAvailableException { try { com.google.gerrit.server.patchlib.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if (pl instanceof com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListCacheImpl.LargeObjectTombstone) { throw new <END_MOD>com.google.gerrit.server.patch.<START_MOD>PatchListObjectTooLargeException((( computing   + key) +   Previous attempt failed with LargeObjectException } if ((key.getAlgorithm()) == (<END_MOD>PatchListKey<START_MOD>.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.patchlib.DiffSummaryKey.fromPatchListKey(key),<END_MOD> com.google.gerrit.server.patch.<START_MOD>DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(( computing   + key), e); throw new com.google.gerrit.server.patchlib.<END_MOD>PatchListNotAvailableException<START_MOD>(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { fileCache.put(key, new<END_MOD> com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone<START_MOD>()); PatchListLoader.log.warn(( computing   + key), e);<END_MOD> throw new com.google.gerrit.server.<START_MOD>patchlib.PatchListNotAvailableException(e); }<END_MOD> throw <START_MOD>e; } }<END_MOD>
@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getNewFilePath(); }
private java.util.List<java.lang.String> getLinesOfComment(com.google.gerrit.reviewdb.client.Comment comment, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchFile fileData) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); if ((comment.lineNbr) == 0) { return lines; } if ((comment.range) == null) { lines.add(getLine(fileData, comment.side, comment.lineNbr)); } else { lines.addAll(getLinesByRange(comment.range, fileData, comment.side)); } return lines; }
@java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey.class, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); }
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry, org.eclipse.jgit.diff.Edit edit) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), false); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path, org.eclipse.jgit.lib.ObjectReader reader) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(reader, path, tree); if (tw == null) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) != (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.EMPTY; } return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB)); }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { status = readEnum(in, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.Status.values()); int editCount = readVarInt32(in); org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { editArray[i] = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.readEdit(in); int innerCount = readVarInt32(in); if ( < innerCount) { org.eclipse.jgit.diff.Edit[] inner = new org.eclipse.jgit.diff.Edit[innerCount]; for (int j = 0; j < innerCount; j++) { inner[j] = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.readEdit(in); } editArray[i] = new org.eclipse.jgit.diff.ReplaceEdit(editArray[i], com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.toList(inner)); } } edits = com.google.common.collect.ImmutableList.copyOf(editArray); }
com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath);
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListCache getPatchListCache() { return patchListCache; }
private static java.lang.String oldName(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry entry) { switch (entry.getChangeType()) { case ADDED : return null; case DELETED : case MODIFIED : case REWRITE : return entry.getNewName(); case COPIED : case RENAMED : default : return entry.getOldName(); } }
@java.lang.Override public org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { return get(change, patchSet, parentNum).getOldId(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { return get(change, patchSet, null); }
private void transformEdits(java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> transformingEntries, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.SideStrategy sideStrategy) { java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit>> editsPerFilePath = edits.stream().collect(java.util.stream.Collectors.groupingBy(sideStrategy::getFilePath)); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry>> transEntriesPerPath = transformingEntries.stream().collect(java.util.stream.Collectors.groupingBy(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer::getOldFilePath)); edits = editsPerFilePath.entrySet().stream().flatMap(( pathAndEdits) -> { java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> transEntries = transEntriesPerPath.getOrDefault(pathAndEdits.getKey(), com.google.common.collect.ImmutableList.of()); return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.transformEdits(sideStrategy, pathAndEdits.getValue(), transEntries); }).collect(java.util.stream.Collectors.toList()); }
com.google.gerrit.common.data.PatchScript toPatchScript(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry content, com.google.gerrit.common.data.CommentDetail comments, java.util.List<com.google.gerrit.reviewdb.client.Patch> history) throws java.io.IOException { reader = db.newObjectReader(); try { return build(content, comments, history); } finally { reader.close(); } }
public com.google.gerrit.reviewdb.client.PatchType getPatchType() { return com.google.gerrit.reviewdb.client.PatchType.forCode(patchType); }
public void setPatchType(com.google.gerrit.reviewdb.client.PatchType type) { patchType = type.getCode(); }
int getEnd(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit);
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit createForNoContentEdit(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), (-1), (-1), (-1), (-1), false); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs args) { if (computeIntraline) { try { return intraCache.get(key, intraLoaderFactory.create(key, args)); } catch (java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e) { IntraLineLoader.log.warn(( computing   + key), e); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff(IntraLineDiff.Status.ERROR); } } return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff(IntraLineDiff.Status.DISABLED); }
public void transformReferencesOfSideB(java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.SideBStrategy.INSTANCE); }
private static boolean canCoalesce(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.CharText a, int b, int e) { while (b < e) { if ((a.charAt((b++))) == '\n') { return false; } } return true; }
java.lang.String getFilePath(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff call() throws java.lang.Exception { java.util.concurrent.Future<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff> result = diffExecutor.submit(() -> com.google.gerrit.server.patch.IntraLineLoader.compute(args.aText(), args.bText(), args.edits())); try { return result.get(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.InterruptedException | java.util.concurrent.TimeoutException e) { com.google.gerrit.server.patch.IntraLineLoader.log.warn(((((((((((((timeoutMillis) +   ms timeout reached for IntraLineDiff +   in project   + (args.project())) +   on commit   + (args.commit().name())) +   for path   + (args.path())) +   comparing   + (key.getBlobA().name())) + "..") + (key.getBlobB().name()))); result.cancel(true); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff(IntraLineDiff.Status.TIMEOUT); } catch (java.util.concurrent.ExecutionException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.lang.Exception.class); throw new java.lang.Exception(e.getMessage(), e.getCause()); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error( fire event e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error( fire event e); } }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); if ((patchSet.getRevision()) == null) { throw new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException(( is null for   + (patchSet.getId()))); } org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; if (parentNum != null) { return get(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstParentNum(parentNum, b, ws), project); } return get(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstDefaultBase(b, ws), project); }
public com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> getEditsPerFilePath() { return edits.stream().collect(toMultimap(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit::getNewFilePath, java.util.function.Function.identity(), ArrayListMultimap::create)); }
public com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> getEdits() { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff.deepCopyEdits(edits); }
@java.lang.Override public boolean equals(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.CharText a, int ai, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.CharText b, int bi) { return (a.charAt(ai)) == (b.charAt(bi)); }
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary toDiffSummary(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList patchList) { java.util.List<java.lang.String> r = new java.util.ArrayList(patchList.getPatches().size()); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : case REWRITE : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; } } java.util.Collections.sort(r); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary(r.toArray(new java.lang.String[r.size()]), patchList.getInsertions(), patchList.getDeletions()); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey againstCommit(org.eclipse.jgit.lib.AnyObjectId otherCommitId, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey(otherCommitId, newId, whitespace, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
protected com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList getPatchList() throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { if ((patchSet) != null) { return args.patchListCache.get(change, patchSet); } throw new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException( patchSet specified }
public java.lang.String getUnifiedDiff() { com.google.gerrit.server.<START_MOD>patchlib.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return   merge; cannot be formatted as a diff.] } } catch (com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListObjectTooLargeException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn(( format patch   + (e.getMessage()))); return "";<END_MOD> } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error( format patch e); return ""; } int maxSize = args.settings.maximumDiffSize; org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(java.lang.Math.min(com.google.gerrit.server.mail.send.ChangeEmail.HEAP_EST_SIZE, maxSize), maxSize); try (org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf)) { try (org.eclipse.jgit.lib.Repository git = args.server.openRepository(change.getProject())) { try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.send.ChangeEmail.log.error( format patch e); return ""; } } catch (java.io.IOException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error( open repository to format patch e); return ""; } } }
public java.lang.String getChangeDetail() { try { java.lang.StringBuilder detail = new java.lang.StringBuilder(); if ((patchSetInfo) != null) { detail.append(patchSetInfo.getMessage().trim()).append("\n"); } else { detail.append(change.getSubject().trim()).append("\n"); } if ((patchSet) != null) { detail.append("---\n"); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList patchList = getPatchList(); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry p : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(p.getNewName())) { continue; } detail.append(p.getChangeType().getCode()).append( ").append(p.getNewName()).append(" } detail.append(java.text.MessageFormat.format(("" + ((( files|1 file|1<{0} files} changed,   +   insertions|1 insertion|1<{1} insertions}(+),   +   deletions|1 deletion|1<{2} deletions}(-) + "\n")), ((patchList.getPatches().size()) - 1), patchList.getInsertions(), patchList.getDeletions())); detail.append("\n"); } return detail.toString(); } catch (java.lang.Exception err) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn( format change detail err); return ""; } }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) { com.googlecode.prolog_cafe.lang.Term a5 = engine.r5; @java.lang.SuppressWarnings("unchecked") java.util.Iterator<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> iter = ((java.util.Iterator<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry>) (((com.googlecode.prolog_cafe.lang.JavaObjectTerm) (a5)).object())); if (!(iter.hasNext())) { return engine.fail(); } return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.cont = cont; engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); if (a1 instanceof com.googlecode.prolog_cafe.lang.VariableTerm) { throw new com.googlecode.prolog_cafe.exceptions.PInstantiationException(this, 1); } if (!(a1 instanceof com.googlecode.prolog_cafe.lang.SymbolTerm)) { throw new com.googlecode.prolog_cafe.exceptions.IllegalTypeException(this, 1, "symbol", a1); } java.util.regex.Pattern regex = java.util.regex.Pattern.compile(a1.name()); engine.r1 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(regex); engine.r2 = arg2; engine.r3 = arg3; engine.r4 = arg4; com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList pl = StoredValues.PATCH_LIST.get(engine); java.util.Iterator<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> iter = pl.getPatches().iterator(); engine.r5 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(iter); return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@org.junit.Test public void largeObjectTombstoneGetsCached() { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstDefaultBase(org.eclipse.jgit.lib.ObjectId.zeroId(), Whitespace.IGNORE_ALL); com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone tombstone = new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone(); abstractPatchListCache.put(key, tombstone); assertThat(abstractPatchListCache.getIfPresent(key)).isSameAs(tombstone); }
private static void assertAdded(java.lang.String expectedNewName, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.ADDED); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey getKey(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstCommit(revisionIdA, revisionIdB, Whitespace.IGNORE_NONE); }
private static void assertDeleted(java.lang.String expectedNewName, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.DELETED); }
private static void assertName(java.lang.String expectedNewName, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e) { assertThat(e.getNewName()).isEqualTo(expectedNewName); assertThat(e.getOldName()).isNull(); }
private java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> getCurrentPatches(java.lang.String changeId) throws java.lang.Exception { return patchListCache.get(getKey(null, getCurrentRevisionId(changeId)), project).getPatches(); }
private java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> getPatches(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) throws java.lang.Exception { return patchListCache.get(getKey(revisionIdA, revisionIdB), project).getPatches(); }
private static void assertModified(java.lang.String expectedNewName, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.MODIFIED); }
public void addPatchSetFileNames(com.google.gerrit.server.data.PatchSetAttribute patchSetAttribute, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) { try { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList patchList = patchListCache.get(change, patchSet); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patch : patchList.getPatches()) { if ((patchSetAttribute.files) == null) { patchSetAttribute.files = new java.util.ArrayList(); } com.google.gerrit.server.data.PatchAttribute p = new com.google.gerrit.server.data.PatchAttribute(); p.file = patch.getNewName(); p.fileOld = patch.getOldName(); p.type = patch.getChangeType(); p.deletions -= patch.getDeletions(); p.insertions = patch.getInsertions(); patchSetAttribute.files.add(p); } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.events.EventFactory.log.warn(( get patch list:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { com.google.gerrit.server.events.EventFactory.log.warn( get patch list e); } }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.lib.ObjectId objectId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId a = (base == null) ? null : org.eclipse.jgit.lib.ObjectId.fromString(base.getRevision().get()); return toFileInfoMap(change, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstCommit(a, objectId, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { return toFileInfoMap(change, patchSet.getRevision(), null); }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList list = patchListCache.get(key, change.getProject()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> files = new java.util.TreeMap<>(); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e : list.getPatches()) { com.google.gerrit.extensions.common.FileInfo d = new com.google.gerrit.extensions.common.FileInfo(); d.status = ((e.getChangeType()) != (Patch.ChangeType.MODIFIED)) ? e.getChangeType().getCode() : null; d.oldPath = e.getOldName(); d.sizeDelta = e.getSizeDelta(); d.size = e.getSize(); if ((e.getPatchType()) == (<START_MOD>com.google.gerrit.reviewdb.client.PatchType.BINARY)) { d.binary = true; } else { d.linesInserted = ((e.getInsertions()) > 0) ? e.getInsertions() : null; d.linesDeleted = ((e.getDeletions()) > 0) ? e.getDeletions() : null; } com.google.gerrit.extensions.common.FileInfo o = files.put(e.getNewName(), d); if (o != null) { d.status = <END_MOD>Patch.<START_MOD>ChangeType.REWRITE.getCode(); d.sizeDelta = o.sizeDelta; d.size = o.size; if (((o<END_MOD>.binary<START_MOD>) != null) && (o.binary)) { d.binary<END_MOD> = true; } <START_MOD>if ((o<END_MOD>.linesInserted<START_MOD>) != null) { d.linesInserted = o.linesInserted; } if ((o<END_MOD>.linesDeleted<START_MOD>) != null) { d.linesDeleted = o.linesDeleted; } } } return<END_MOD> files<START_MOD>; }<END_MOD>
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, int parent) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstParentNum((parent + 1), b, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId objectId = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, objectId, base); }
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.<START_MOD>DiffSummary<END_MOD>.ChangedLines getChangedLines() { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.<START_MOD>DiffSummary<END_MOD>.ChangedLines(insertions, deletions); }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null, isWorldReadable(cd)); accountLoader.fill(); return rev; } }
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType readFrom(java.io.InputStream in) throws java.io.IOException { int p = readVarInt32(in); java.lang.Integer parentNum = (p > 0) ? p : null; boolean autoMerge = (readVarInt32(in)) != 0; return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType(parentNum, autoMerge); }
private com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.query.change.ChangeData cd, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws com.google.gwtorm.server.OrmException { try { if (fillAccountLoader) { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); com.google.gerrit.extensions.common.ChangeInfo res = toChangeInfo(cd, limitToPsId); accountLoader.fill(); return res; } return toChangeInfo(cd, limitToPsId); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (!(has(com.google.gerrit.server.change.CHECK))) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(e); } return checkOnly(cd); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); java.lang.Boolean isWorldReadable = null; try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want) { if (isWorldReadable == null) { isWorldReadable = isWorldReadable(cd); } res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo, isWorldReadable)); } } return res; } }
private java.util.List<com.google.gerrit.extensions.common.ChangeInfo> toChangeInfo(java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.extensions.common.ChangeInfo> out, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { com.google.gerrit.extensions.common.ChangeInfo i = out.get(cd.getId()); if (i == null) { try { i = toChangeInfo(cd, java.util.Optional.empty()); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (has(com.google.gerrit.server.change.CHECK)) { i = checkOnly(cd); } else if (e instanceof com.google.gerrit.server.project.NoSuchChangeException) { com.google.gerrit.server.change.ChangeJson.log.info((( Omitting corrupt change   + (cd.getId())) +   from results. Seems to be stale in the index. continue; } else { com.google.gerrit.server.change.ChangeJson.log.warn((( corrupt change   + (cd.getId())) +   from results e); continue; } } out.put(cd.getId(), i); } info.add(i); } return info; }
@java.lang.Override public int weigh(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 16) + 8) + (2 * 4)) + 16) + 8; for (java.lang.String p : value.getPaths()) { size += ((((16 + 8) + (4 * 4)) + 16) + 8) + ((p.length()) * 2); } return size; }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType againstAutoMerge() { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType(null, true); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeCanBeNull(out, oldId); out.writeInt(((parentNum) == null ?   : parentNum)); writeNotNull(out, newId); java.lang.Character c = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.WHITESPACE_TYPES.get(whitespace); if (c == null) { throw new java.io.IOException(( whitespace type:   + (whitespace))); } out.writeChar(c); out.writeChar(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.ALGORITHM_TYPES.get(algorithm)); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType againstParent(int parentNum) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType(parentNum, false); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey k = ((com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey) (o)); return ((((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace))) && ((algorithm) == (k.algorithm)); } return false; }
public static void setCommentRevId(com.google.gerrit.reviewdb.client.Comment c, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListCache cache, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { checkArgument(((c.key.patchSetId) == (ps.getId().get())),   set RevId for patch set %s on comment %s ps.getId(), c); if ((c.revId) == null) { try { if ((com.google.gerrit.extensions.client.Side.fromShort(c.side)) == (com.google.gerrit.extensions.client.Side.PARENT)) { if ((c.side) < 0) { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, (-(c.side)))); } else { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, null)); } } else { c.revId = ps.getRevision().get(); } } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { throw new com.google.gwtorm.server.OrmException(e); } } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.changes.ReviewResult> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply(updateFactory, revision, input, com.google.gerrit.common.TimeUtil.nowTs()); }
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId newId = org.eclipse.jgit.lib.ObjectId.fromString(revision.getPatchSet().getRevision().get()); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey.fromPatchListKey(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstDefaultBase(newId, Whitespace.IGNORE_NONE)); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary ds = patchListCache.getDiffSummary(key, revision.getProject()); return new java.util.HashSet(ds.getPaths()); }
private <T extends com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput> void checkComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<T>> commentsPerPath) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { java.util.Set<java.lang.String> revisionFilePaths = getAffectedFilePaths(revision); for (java.util.Map.Entry<java.lang.String, java.util.List<T>> entry : commentsPerPath.entrySet()) { java.lang.String path = entry.getKey(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = revision.getChange().currentPatchSetId(); com.google.gerrit.server.change.PostReview.ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId); java.util.List<T> comments = entry.getValue(); for (T comment : comments) { com.google.gerrit.server.change.PostReview.ensureLineIsNonNegative(comment.line, path); com.google.gerrit.server.change.PostReview.ensureCommentNotOnMagicFilesOfAutoMerge(path, comment); com.google.gerrit.server.change.PostReview.ensureRangeIsValid(path, comment.range); } } }
private void checkRobotComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> in) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException { com.google.gerrit.server.change.PostReview.cleanUpComments(in); for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> e : in.entrySet()) { java.lang.String commentPath = e.getKey(); for (com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput c : e.getValue()) { ensureSizeOfJsonInputIsWithinBounds(c); com.google.gerrit.server.change.PostReview.ensureRobotIdIsSet(c.robotId, commentPath); com.google.gerrit.server.change.PostReview.ensureRobotRunIdIsSet(c.robotRunId, commentPath); com.google.gerrit.server.change.PostReview.ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath); } } checkComments(revision, in); }
com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList get(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException;
com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs args);
org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException;
com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummary getDiffSummary(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException;
com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException;
private java.util.Collection<java.lang.String> reviewed(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( required } com.google.gerrit.reviewdb.client.Account.Id userId = user.getAccountId(); com.google.gerrit.reviewdb.client.PatchSet patchSetId = resource.getPatchSet(); java.util.Optional<com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId); if (o.isPresent()) { com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles res = o.get(); if (res.patchSetId().equals(patchSetId.getId())) { return res.files(); } try { return copy(res.files(), res.patchSetId(), resource, userId); } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn(( copy patch review flags:   + (e.getMessage()))); } catch (java.io.IOException | com.google.gerrit.server.<START_MOD>patchlib.PatchListNotAvailableException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn( copy <END_MOD>patch<START_MOD> review flags<END_MOD> e); } } return java.util.Collections.emptyList(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { checkOptions(); if (reviewed) { return com.google.gerrit.extensions.restapi.Response.ok(reviewed(resource)); } else if ((query) != null) { return com.google.gerrit.extensions.restapi.Response.ok(query(resource)); } com.google.gerrit.extensions.restapi.Response<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo>> r; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(resource.getChangeResource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), baseResource.getPatchSet())); } else if ((parentNum) > 0) { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), ((parentNum) - 1))); } else { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet())); } if (resource.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; }
private static java.nio.charset.Charset charset(byte[] content, java.lang.String encoding) { if (encoding == null) { org.mozilla.universalchardet.UniversalDetector d = new org.mozilla.universalchardet.UniversalDetector(null); d.handleData(content, 0, content.length); d.dataEnd(); encoding = d.getDetectedCharset(); } if (encoding == null) { return java.nio.charset.StandardCharsets.ISO_8859_1; } try { return java.nio.charset.Charset.forName(encoding); } catch (java.nio.charset.IllegalCharsetNameException err) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.log.error(((( detected charset name   + encoding) +     + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } catch (java.nio.charset.UnsupportedCharsetException err) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.log.error(((( charset   + encoding) +   not supported:   + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error( fire event e); } }
public static byte[] asByteArray(org.eclipse.jgit.lib.ObjectLoader ldr) throws java.io.IOException, org.eclipse.jgit.errors.LargeObjectException, org.eclipse.jgit.errors.MissingObjectException { return ldr.getCachedBytes(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.bigFileThreshold); }
@java.lang.Override protected java.lang.String decode(int s, int e) { if ((charset) == null) { charset = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.charset(content, null); } return org.eclipse.jgit.util.RawParseUtils.decode(charset, content, s, e); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text forMergeList(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType comparisonType, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(commitId); java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case   : break; case 1 : { break; } default : int uniterestingParent = (comparisonType.isAgainstParent()) ? comparisonType.getParentNum() : 1; b.append( List: for (org.eclipse.jgit.revwalk.RevCommit commit : com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.MergeListBuilder.build(rw, c, uniterestingParent)) { b.append(   b.append(reader.abbreviate(commit, 8).name()); b.append(   b.append(commit.getShortMessage()); b.append("\n"); } } return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
@org.junit.Test public void fileOrder() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@org.junit.Test public void fileOrderNoMerge() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.comparePaths(o1, o2); }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { return revisionInfo(project.getNameKey(), ps); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error( fire event e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 8) + 16) + (3 * 8)) + (3 * 4)) + 20; for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e : value.getPatches()) { size += e.weigh(); } return size; }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { oldId = readCanBeNull(in); int n = in.readInt(); parentNum = (n == 0) ? null : java.lang.Integer.valueOf(n); newId = readNotNull(in); char t = in.readChar(); whitespace = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.WHITESPACE_TYPES.inverse().get(t); if ((whitespace) == null) { throw new java.io.IOException(( whitespace type code:   + t)); } char algorithmCharacter = in.readChar(); algorithm = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.ALGORITHM_TYPES.inverse().get(algorithmCharacter); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey againstParentNum(int parentNum, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey(parentNum, newId, ws, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.Algorithm getAlgorithm() { return algorithm; }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey()); return changeJson.getRevisionInfo(cd, ps); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey againstDefaultBase(org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey(null, newId, ws, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text forCommit(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c; if (commitId instanceof org.eclipse.jgit.revwalk.RevCommit) { c = ((org.eclipse.jgit.revwalk.RevCommit) (commitId)); } else { c = rw.parseCommit(commitId); } java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case   : break; case 1 : { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(0); rw.parseBody(p); b.append(   b.append(reader.abbreviate(p, 8).name()); b.append( ( b.append(p.getShortMessage()); b.append(")\n"); break; } default : for (int i = 0; i < (c.getParentCount()); i++) { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(i); rw.parseBody(p); b.append((i ==   ?   Of:   :     b.append(reader.abbreviate(p, 8).name()); b.append( ( b.append(p.getShortMessage()); b.append(")\n"); } } com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.appendPersonIdent(b, "Author", c.getAuthorIdent()); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.appendPersonIdent(b, "Commit", c.getCommitterIdent()); b.append("\n"); b.append(c.getFullMessage()); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
com.google.gerrit.server.patch.DiffSummaryLoader create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); com.googlecode.prolog_cafe.lang.Term a2 = arg2.dereference(); com.googlecode.prolog_cafe.lang.Term a3 = arg3.dereference(); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList pl = StoredValues.PATCH_LIST.get(engine); if (!(a1.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(((pl.getPatches().size()) - (countMagicFiles(pl.getPatches())))), engine.trail))) { return engine.fail(); } if (!(a2.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getInsertions()), engine.trail))) { return engine.fail(); } if (!(a3.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getDeletions()), engine.trail))) { return engine.fail(); } return cont; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser()); if (!(edit.isPresent())) { return com.google.gerrit.extensions.restapi.Response.none(); } com.google.gerrit.extensions.common.EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands); if (list) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = null; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(rsrc, com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); basePatchSet = baseResource.getPatchSet(); } try { editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getEditCommit(), basePatchSet); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } } return com.google.gerrit.extensions.restapi.Response.ok(editInfo); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error( fire event e); } }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public abstract com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText();
public abstract com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text bText();
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text bText, java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId commit, java.lang.String path) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.AutoValue_IntraLineDiffArgs(aText, bText, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffArgs.deepCopyEdits(edits), project, commit, path); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey k = ((com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey) (o)); return (((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace)); } return false; }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey fromPatchListKey(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey plk) { com.google.common.base.Preconditions.checkArgument(((plk.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF))); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace()); }
<START_MOD>public <END_MOD>com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey toPatchListKey() { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey(oldId, parentNum, newId, whitespace, PatchListKey.Algorithm.OPTIMIZED_DIFF); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry newCommitMessage(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit) throws java.io.IOException { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText = (aCommit != null) ? com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.forCommit(reader, aCommit) : <START_MOD>com.google.gerrit.server.patchlib.<END_MOD>Text.EMPTY; com.google.gerrit.server.<START_MOD>patchlib.Text bText = com.google.gerrit.server.patchlib.Text.forCommit(reader, bCommit); return com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListLoader.createPatchListEntry(cmp, aCommit, aText,<END_MOD> bText<START_MOD>, Patch.COMMIT_MSG<END_MOD>); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList call() throws com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter ins = newInserter(repo);org.eclipse.jgit.lib.ObjectReader reader = ins.newReader();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { return readPatchList(repo, rw, ins); } }
private java.util.Optional<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> getPatchListEntry(org.eclipse.jgit.lib.ObjectReader objectReader, org.eclipse.jgit.diff.DiffFormatter diffFormatter, org.eclipse.jgit.diff.DiffEntry diffEntry, org.eclipse.jgit.revwalk.RevTree treeA, org.eclipse.jgit.revwalk.RevTree treeB, java.util.Set<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> editsDueToRebase) throws java.io.IOException { org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(key.getNewId(), diffFormatter, diffEntry); long oldSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getOldMode(), diffEntry.getOldPath(), treeA); long newSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getNewMode(), diffEntry.getNewPath(), treeB); java.util.Set<org.eclipse.jgit.diff.Edit> contentEditsDueToRebase = com.google.gerrit.server.patch.PatchListLoader.getContentEdits(editsDueToRebase); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry = com.google.gerrit.server.patch.PatchListLoader.newEntry(treeA, fileHeader, contentEditsDueToRebase, newSize, (newSize - oldSize)); if (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.toEdits(patchListEntry).allMatch(editsDueToRebase::contains)) { return java.util.Optional.empty(); } return java.util.Optional.of(patchListEntry); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType getComparisonType(org.eclipse.jgit.revwalk.RevObject a, org.eclipse.jgit.revwalk.RevCommit b) { for (int i = 0; i < (b.getParentCount()); i++) { if (b.getParent(i).equals(a)) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType.againstParent((i + 1)); } } if (((key.getOldId()) == null) && ((b.getParentCount()) > 0)) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType.againstAutoMerge(); } return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType.againstOtherPatchSet(); }
private com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry newMergeList(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType comparisonType) throws java.io.IOException { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText = (aCommit != null) ? com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.forMergeList(comparisonType, reader, aCommit) : <START_MOD>com.google.gerrit.server.patchlib.<END_MOD>Text.EMPTY; com.google.gerrit.server.<START_MOD>patchlib.Text bText = com.google.gerrit.server.patchlib.Text.forMergeList(comparisonType, reader, bCommit); return com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListLoader.createPatchListEntry(cmp, aCommit, aText,<END_MOD> bText<START_MOD>, Patch.MERGE_LIST<END_MOD>); }
private static java.util.Set<org.eclipse.jgit.diff.Edit> getContentEdits(java.util.Set<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> editsDueToRebase) { return editsDueToRebase.stream().map(ContextAwareEdit::toEdit).filter(java.util.Optional::isPresent).map(java.util.Optional::get).collect(java.util.stream.Collectors.toSet()); }
private static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry newEntry(org.eclipse.jgit.revwalk.RevTree aTree, org.eclipse.jgit.patch.FileHeader fileHeader, java.util.Set<org.eclipse.jgit.diff.Edit> editsDueToRebase, long size, long sizeDelta) { if (((aTree == null) || ((fileHeader.getPatchType()) != (org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED))) || (fileHeader.getHunks().isEmpty())) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } java.util.List<org.eclipse.jgit.diff.Edit> edits = fileHeader.toEditList(); if (edits.isEmpty()) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(fileHeader, edits, editsDueToRebase, size, sizeDelta); }
private org.eclipse.jgit.revwalk.RevObject aFor(com.google.gerrit.server.<START_MOD>patchlib.PatchListKey key, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.revwalk.RevCommit b) throws java.io.IOException { if ((key.getOldId()) != null) { return rw.parseAny(key.getOldId()); } switch (b.getParentCount()) { case   : return rw.parseAny(com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListLoader.emptyTree(ins)); case 1 : { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(0); rw.parseBody(r); return r; } case 2 : if ((key.getParentNum()) != null) { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(((key.getParentNum()) - 1)); rw.parseBody(r); return r; } return autoMerger.merge(<END_MOD>repo, <START_MOD>rw,<END_MOD> ins, <START_MOD>b, mergeStrategy); default : return<END_MOD> null<START_MOD>; } }<END_MOD>
private java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> getRelevantPatchListEntries(java.util.List<org.eclipse.jgit.diff.DiffEntry> parentDiffEntries, org.eclipse.jgit.revwalk.RevCommit parentCommitA, org.eclipse.jgit.revwalk.RevCommit parentCommitB, java.util.Set<java.lang.String> touchedFilePaths, org.eclipse.jgit.diff.DiffFormatter diffFormatter) throws java.io.IOException { java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> parentPatchListEntries = new java.util.ArrayList(parentDiffEntries.size()); for (org.eclipse.jgit.diff.DiffEntry parentDiffEntry : parentDiffEntries) { if (!(com.google.gerrit.server.patch.PatchListLoader.isTouched(touchedFilePaths, parentDiffEntry))) { continue; } org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry); com.google.gerrit.server.<START_MOD>patchlib.PatchListEntry patchListEntry = com.google.gerrit.server.<END_MOD>patch.<START_MOD>PatchListLoader.newEntry(parentCommitA.getTree(), fileHeader, com.google.common.collect.ImmutableSet.of(), 0, 0); parentPatchListEntries.add(<END_MOD>patchListEntry<START_MOD>); } return<END_MOD> parentPatchListEntries; }
private static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry createPatchListEntry(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.revwalk.RevCommit aCommit, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text bText, java.lang.String fileName) { byte[] rawHdr = com.google.gerrit.server.patch.PatchListLoader.getRawHeader((aCommit != null), fileName); byte[] aContent = aText.getContent(); byte[] bContent = bText.getContent(); long size = bContent.length; long sizeDelta = (bContent.length) - (aContent.length); org.eclipse.jgit.diff.RawText aRawText = new org.eclipse.jgit.diff.RawText(aContent); org.eclipse.jgit.diff.RawText bRawText = new org.eclipse.jgit.diff.RawText(bContent); org.eclipse.jgit.diff.EditList edits = new org.eclipse.jgit.diff.HistogramDiff().diff(cmp, aRawText, bRawText); org.eclipse.jgit.patch.FileHeader fh = new org.eclipse.jgit.patch.FileHeader(rawHdr, edits, org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(fh, edits, com.google.common.collect.ImmutableSet.of(), size, sizeDelta); }
private static java.util.Set<java.lang.String> getTouchedFilePaths(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry) { java.lang.String oldFilePath = patchListEntry.getOldName(); java.lang.String newFilePath = patchListEntry.getNewName(); return oldFilePath == null ? com.google.common.collect.ImmutableSet.of(newFilePath) : com.google.common.collect.ImmutableSet.of(oldFilePath, newFilePath); }
public abstract com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> getEditsDueToRebasePerFilePath();
com.google.gerrit.server.patch.PatchListLoader create(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
private static java.util.Set<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> getEditsDueToRebase(com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath, org.eclipse.jgit.diff.DiffEntry diffEntry) { if (editsDueToRebasePerFilePath.isEmpty()) { return com.google.common.collect.ImmutableSet.of(); } java.lang.String filePath = diffEntry.getNewPath(); if ((diffEntry.getChangeType()) == (org.eclipse.jgit.diff.DiffEntry.ChangeType.DELETE)) { filePath = diffEntry.getOldPath(); } return com.google.common.collect.ImmutableSet.copyOf(editsDueToRebasePerFilePath.get(filePath)); }
public static com.google.gerrit.server.patch.PatchListLoader.EditsDueToRebaseResult create(java.util.List<org.eclipse.jgit.diff.DiffEntry> relevantDiffEntries, com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath) { return new com.google.gerrit.server.patch.AutoValue_PatchListLoader_EditsDueToRebaseResult(relevantDiffEntries, editsDueToRebasePerFilePath); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error( fire event e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiffKey key, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff value) { return ((((((((16 + (8 * 8)) + (2 * 36)) + 16) + (2 * 8)) + 16) + 8) + 4) + 20) + (((8 + 16) + (4 * 4)) * (value.getEdits().size())); }
private int search(java.lang.String fileName) { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry want = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.empty(fileName); return java.util.Arrays.binarySearch(patches, 0, patches.length, want, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.PATCH_CMP); }
private int countMagicFiles(java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> entries) { int count = 0; for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e : entries) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { count++; } } return count; }
private static java.lang.String getOldFilePath(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry patchListEntry) { return com.google.common.base.MoreObjects.firstNonNull(patchListEntry.getOldName(), patchListEntry.getNewName()); }
static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry readFrom(java.io.InputStream in) throws java.io.IOException { com.google.gerrit.reviewdb.client.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.ChangeType.values()); com.google.gerrit.reviewdb.client.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.client.PatchType.values()); java.lang.String oldName = readString(in); java.lang.String newName = readString(in); byte[] hdr = readBytes(in); int ins = readVarInt32(in); int del = readVarInt32(in); long size = readFixInt64(in); long sizeDelta = readFixInt64(in); org.eclipse.jgit.diff.Edit[] editArray = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.readEditArray(in); org.eclipse.jgit.diff.Edit[] editsDueToRebase = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.readEditArray(in); return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.common.collect.ImmutableList.copyOf(editArray), com.google.common.collect.ImmutableSet.copyOf(editsDueToRebase), ins, del, size, sizeDelta); }
@java.lang.Override public int getEnd(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.EditTransformer.ContextAwareEdit edit) { return edit.getEndA(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList createValue(com.googlecode.prolog_cafe.lang.Prolog engine) { com.google.gerrit.server.rules.PrologEnvironment env = ((com.google.gerrit.server.rules.PrologEnvironment) (engine.control)); com.google.gerrit.reviewdb.client.PatchSet ps = com.google.gerrit.server.rules.StoredValues.getPatchSet(engine); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListCache plCache = env.getArgs().getPatchListCache(); com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.rules.StoredValues.getChange(engine); com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey plKey = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListKey.againstDefaultBase(b, ws); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList patchList; try { patchList = plCache.get(plKey, project); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException e) { throw new com.googlecode.prolog_cafe.exceptions.SystemException(( create   + plKey)); } return patchList; }
private void writeObject(java.io.ObjectOutputStream output) throws java.io.IOException { final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); try (java.util.zip.DeflaterOutputStream out = new java.util.zip.DeflaterOutputStream(buf)) { writeCanBeNull(out, oldId); writeNotNull(out, newId); writeVarInt32(out, (isMerge ? 1 : 0)); comparisonType.writeTo(out); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeVarInt32(out, patches.length); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry p : patches) { p.writeTo(out); } } writeBytes(output, buf.toByteArray()); }
public static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType againstOtherPatchSet() { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType(null, false); }
private static com.google.gerrit.reviewdb.client.PatchType toPatchType(org.eclipse.jgit.patch.FileHeader hdr) { com.google.gerrit.reviewdb.client.PatchType pt; switch (hdr.getPatchType()) { case UNIFIED : pt = com.google.gerrit.reviewdb.client.PatchType.UNIFIED; break; case GIT_BINARY : case BINARY : pt = com.google.gerrit.reviewdb.client.PatchType.BINARY; break; default : throw new java.lang.IllegalArgumentException(( type   + (hdr.getPatchType()))); } if (pt != (com.google.gerrit.reviewdb.client.PatchType.BINARY)) { final byte[] buf = hdr.getBuffer(); for (int ptr = hdr.getStartOffset(); ptr < (hdr.getEndOffset()); ptr++) { if ((buf[ptr]) == ' ') { pt = com.google.gerrit.reviewdb.client.PatchType.BINARY; break; } } } return pt; }
void writeTo(java.io.OutputStream out) throws java.io.IOException { writeEnum(out, changeType); writeEnum(out, patchType); writeString(out, oldName); writeString(out, newName); writeBytes(out, header); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeFixInt64(out, size); writeFixInt64(out, sizeDelta); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.writeEditArray(out, edits); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.writeEditArray(out, editsDueToRebase); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error( fire event e); } }
public java.util.List<com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry> getPatches() { return java.util.Collections.unmodifiableList(java.util.Arrays.asList(patches)); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.warn(( fire event:   + (e.getMessage()))); } catch (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error( fire event e); } }
@java.lang.Override public int compare(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry a, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry b) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchList.comparePaths(a.getNewName(), b.getNewName()); }
public com.google.gerrit.reviewdb.client.PatchType getPatchType() { return patchType; }
private static byte[] compact(org.eclipse.jgit.patch.FileHeader h) { final int end = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.end(h); if (((h.getStartOffset()) == 0) && (end == (h.getBuffer().length))) { return h.getBuffer(); } final byte[] buf = new byte[end - (h.getStartOffset())]; java.lang.System.arraycopy(h.getBuffer(), h.getStartOffset(), buf, 0, buf.length); return buf; }
public java.util.List<com.google.gerrit.reviewdb.client.Patch> toPatchList(com.google.gerrit.reviewdb.client.PatchSet.Id setId) { final java.util.ArrayList<com.google.gerrit.reviewdb.client.Patch> r = new java.util.ArrayList(patches.length); for (com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry e : patches) { r.add(e.toPatch(setId)); } return r; }
int weigh() { int size = ((((((16 + (6 * 8)) + (2 * 4)) + 20) + 16) + 8) + 4) + 20; size += com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.stringSize(oldName); size += com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.stringSize(newName); size += header.length; size += ((8 + 16) + (4 * 4)) * (edits.size()); size += ((8 + 16) + (4 * 4)) * (editsDueToRebase.size()); return size; }
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry get(java.lang.String fileName) { final int index = search(fileName); return   <= index ? patches[index] : com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.empty(fileName); }
<START_MOD>public <END_MOD>static com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry empty(java.lang.String fileName) { return new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry(com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.client.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.EMPTY_HEADER, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), 0, 0, 0, 0); }
private byte[] getMergeList(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change.Id changeId = notes.getChangeId(); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), notes); if (ps == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(notes.getProjectName());org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(git)) { return com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text.forMergeList(com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType.againstAutoMerge(), revWalk.getObjectReader(), org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())).getContent(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
public com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType getComparisonType() { return comparisonType; }
private void readObject(java.io.ObjectInputStream input) throws java.io.IOException { final java.io.ByteArrayInputStream buf = new java.io.ByteArrayInputStream(readBytes(input)); try (java.util.zip.InflaterInputStream in = new java.util.zip.InflaterInputStream(buf)) { oldId = readCanBeNull(in); newId = readNotNull(in); isMerge = (readVarInt32(in)) != 0; comparisonType = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.ComparisonType.readFrom(in); insertions = readVarInt32(in); deletions = readVarInt32(in); final int cnt = readVarInt32(in); final com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry[] all = new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry[cnt]; for (int i = 0; i < (all.length); i++) { all[i] = com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.PatchListEntry.readFrom(in); } patches = all; } }
private static java.util.List<org.eclipse.jgit.diff.Edit> intraline(java.lang.String a, java.lang.String b, org.eclipse.jgit.diff.Edit lines) throws java.lang.Exception { com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text aText = new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(a.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text bText = new com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.Text(b.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.<START_MOD>patchlib<END_MOD>.IntraLineDiff diff = com.google.gerrit.server.patch.IntraLineLoader.compute(aText, bText, com.google.common.collect.ImmutableList.of(lines)); assertThat(diff.getStatus()).isEqualTo(IntraLineDiff.Status.EDIT_LIST); java.util.List<org.eclipse.jgit.diff.Edit> actualEdits = diff.getEdits(); assertThat(actualEdits).hasSize(1); org.eclipse.jgit.diff.Edit actualEdit = actualEdits.get(0); assertThat(actualEdit.getBeginA()).isEqualTo(lines.getBeginA()); assertThat(actualEdit.getEndA()).isEqualTo(lines.getEndA()); assertThat(actualEdit.getBeginB()).isEqualTo(lines.getBeginB()); assertThat(actualEdit.getEndB()).isEqualTo(lines.getEndB()); assertThat(actualEdit).isInstanceOf(org.eclipse.jgit.diff.ReplaceEdit.class); return ((org.eclipse.jgit.diff.ReplaceEdit) (actualEdit)).getInternalEdits(); }
@java.lang.SuppressWarnings("deprecation") static org.eclipse.jgit.lib.ObjectId getNoteKey(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { return org.eclipse.jgit.lib.ObjectId.fromRaw(com.google.common.hash.Hashing.sha1().hashString(groupName.get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()); }
<START_MOD>private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log(java.lang.String refName) throws java.lang.Exception { com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> result = com.google.common.collect.ImmutableList.of(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); if (ref != null) { rw.sort(RevSort.REVERSE); rw.setRetainBody(true); rw.markStart(rw.parseCommit(ref.getObjectId())); result = com.google.common.collect.Streams.stream(rw).map(CommitUtil::toCommitInfo).collect(toImmutableList()); } } return result; }<END_MOD>
<START_MOD>private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> logGroupNames() throws java.lang.Exception { return log(RefNames.REFS_GROUPNAMES); }<END_MOD>
private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log(com.google.gerrit.reviewdb.client.AccountGroup g) throws java.lang.Exception { <START_MOD>return<END_MOD> <START_MOD>log<END_MOD>(com.google.gerrit.reviewdb.client.RefNames.refsGroups(g.getGroupUUID())); }
static java.lang.String getAsNoteData(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM, uuid.get()); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM, groupName.get()); return config.toText(); }
static com.google.gerrit.common.data.GroupReference getGroupReference(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.ObjectId noteDataBlobId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { byte[] noteData = reader.open(noteDataBlobId, com.google.gerrit.server.group.db.OBJ_BLOB).getCachedBytes(); return com.google.gerrit.server.group.db.GroupNameNotes.getFromNoteData(noteData); }
@java.lang.Override public void run() { com.google.gerrit.server.account.AccountDeactivator.log.<START_MOD>info( account deactivations try { int numberOfAccountsDeactivated = 0; for (com.google.gerrit.server.account.AccountState acc : accountQueryProvider.get().query(com.google.gerrit.server.query.account.AccountPredicates.isActive())) { com.google.gerrit.server.account.AccountDeactivator.log.<END_MOD>debug(<START_MOD>( account   + (acc.getUserName()))); if (((acc.getUserName()) != null) && (!(realm.isActive(acc.getUserName())))) {<END_MOD> try { <START_MOD>sif.deactivate(acc.getAccount().getId()); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error( deactivating account<END_MOD>: <START_MOD>{} ({}) {} <END_MOD>acc.getUserName()<START_MOD>, <END_MOD>acc.getAccount().getId()<START_MOD>, e.getMessage(), e); } com.google.gerrit.server.account.AccountDeactivator.log.info(( account<END_MOD>   + (acc.getUserName()))); numberOfAccountsDeactivated++; } } com.google.gerrit.server.account.AccountDeactivator.log.info( complete, {} account(s) were deactivated numberOfAccountsDeactivated); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error(( to deactivate inactive accounts   + (e.getMessage())), e); } }
private boolean matchCriteria(com.google.gerrit.server.config.PluginConfig config, java.lang.String criteria,<START_MOD> @com.google.gerrit.common.Nullable<END_MOD> java.lang.String value, boolean allowRegex, boolean refMatcher) { boolean match = true; for (java.lang.String s : config.getStringList(criteria)) {<START_MOD> if (value == null) { return false; }<END_MOD> if ((allowRegex && (com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.match(value, s, refMatcher))) || ((!allowRegex) && (s.equals(value)))) { return true; } match = false; } return match; }
@java.lang.Override public org.apache.http.impl.client.CloseableHttpClient get() { return org.apache.http.impl.client.HttpClients.custom().setConnectionManager(<START_MOD>mgr.get<END_MOD>()).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build(); }
<START_MOD>public boolean getDisableSslVerification() { return disableSslVerification; }<END_MOD>
<START_MOD>public boolean getDisableSslVerification() { return config.getBoolean(com.googlesource.gerrit.plugins.webhooks.RemoteConfig.REMOTE, name, com.googlesource.gerrit.plugins.webhooks.RemoteConfig.DISABLE_SSL_VERIFICATION, global.getDisableSslVerification()); }<END_MOD>
@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class); <START_MOD>factory(PostTask.Factory.class); factory(RemoteConfig.Factory.class); factory(HttpClientConnectionManagerProvider.Factory.class); factory(HttpSession.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); <END_MOD>bind(org.apache.http.impl.client.CloseableHttpClient.class).<START_MOD>annotatedWith(com.google.inject.name.Names.named(com.googlesource.gerrit.plugins.webhooks.DefaultHttpClientProvider.DEFAULT)).<END_MOD>toProvider(com.googlesource.gerrit.plugins.webhooks.<START_MOD>DefaultHttpClientProvider<END_MOD>.class).in(Scopes.SINGLETON); <START_MOD>bind(org.apache.http.impl.client.CloseableHttpClient.class).annotatedWith(<END_MOD>com.google.<START_MOD>inject.name.Names.named(com.googlesource.gerrit.plugins.webhooks.SslVerifyingHttpClientProvider.SSL_VERIFY)).toProvider(com.googlesource.gerrit.plugins.webhooks.SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON); bind(com.googlesource.gerrit.plugins.webhooks.HttpClientConfigurator.class).in(Scopes.SINGLETON<END_MOD>); install(processors); }
@org.junit.Test public void <START_MOD>pushToGroupsBranchForNonAllUsersRepo<END_MOD>() throws java.lang.Exception { <START_MOD>assertCreateGroupBranch<END_MOD>(project, null<START_MOD>); assertPushToGroupBranch(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo")))<END_MOD>, null); }
private void <START_MOD>assertPushToGroupBranch<END_MOD>(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String <START_MOD>groupRefName<END_MOD>, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*")<START_MOD>, Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, RefNames.REFS_GROUPNAMES, Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, RefNames.REFS_GROUPNAMES<END_MOD>, Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); <START_MOD>if (((!(groupRefName.equals(RefNames.REFS_GROUPNAMES))) || (!(groupsInNoteDb()))) || (!(allUsers.equals(project)))) { createGroupBranch(project, groupRefName); } com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); <END_MOD>com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo,   group config "group.config",   content if (<START_MOD>expectedErrorOnUpdate<END_MOD> != null) { r.assertErrorStatus(<START_MOD>expectedErrorOnUpdate<END_MOD>); } else { r.assertOkStatus(); } }
<START_MOD>@org.junit.Test public void pushToGroupNamesBranchForNonAllUsersRepo() throws java.lang.Exception { assertPushToGroupBranch(project, RefNames.REFS_GROUPNAMES, null); }<END_MOD>
<START_MOD>@org.junit.Test public void pushToGroupNamesBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); assertPushToGroupBranch(allUsers, RefNames.REFS_GROUPNAMES, "group update not allowed"); }<END_MOD>
<START_MOD>private void assertCreateGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").setParents(com.google.common.collect.ImmutableList.of()).to(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("bar")))); if (expectedErrorOnCreate != null) { r.assertErrorStatus(expectedErrorOnCreate); } else { r.assertOkStatus(); } }<END_MOD>
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { <START_MOD>assertCreateGroupBranch<END_MOD>(allUsers,   allowed to create group branch. <START_MOD>assertPushToGroupBranch(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo"))), <END_MOD>  update not allowed }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { for (com.google.gerrit.index.Index<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.account.AccountState> i : getWriteIndexes()) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull(id); if (accountState != null) { i.replace(accountState); <START_MOD>autoReindexIfStale(id, false); <END_MOD>} else { i.delete(id<START_MOD>); autoReindexIfStale(id, true<END_MOD>); } } fireAccountIndexedEvent(id.get()); }
<START_MOD>private void autoReindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id, boolean deleted) { if (autoReindexIfStale) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = reindexIfStale(id, deleted); } }<END_MOD>
<START_MOD>@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id, boolean deleted) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(id, deleted)) { index(id); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }<END_MOD>
<START_MOD>private void assertStaleAccountAndReindex(com.google.gerrit.reviewdb.client.Account.Id accountId, boolean deleted) throws java.io.IOException { accountsCache.invalidate(accountId); assertThat(stalenessChecker.isStale(accountId, deleted)).isTrue(); accountIndexer.index(accountId); assertThat(stalenessChecker.isStale(accountId, deleted)).isFalse(); }<END_MOD>
<START_MOD>private void expectWriteGroupToReviewDbBlockedException() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.RestApiException.class); exception.expectCause(new org.hamcrest.BaseMatcher<java.lang.Throwable>() { @java.lang.Override public boolean matches(java.lang.Object item) { return (item instanceof com.google.gwtorm.server.OrmException) && ("Updates to groups in ReviewDb are blocked".equals(((com.google.gwtorm.server.OrmException) (item)).getMessage())); } @java.lang.Override public void describeTo(org.hamcrest.Description description) { description.appendText("OrmException: Updates to groups in ReviewDb are blocked"); } }); }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void blockReviewDbUpdatesOnGroupUpdate() throws java.lang.Exception { assume().that(groupsInNoteDb()).isFalse(); java.lang.String group1 = gApi.groups().create(name("foo")).get().id; java.lang.String group2 = gApi.groups().create(name("bar")).get().id; cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true); expectWriteGroupToReviewDbBlockedException(); gApi.groups().id(group1).addGroups(group2); }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void blockReviewDbUpdatesOnGroupCreation() throws java.lang.Exception { assume().that(groupsInNoteDb()).isFalse(); cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true); expectWriteGroupToReviewDbBlockedException(); gApi.groups().create(name("foo")); }<END_MOD>
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.project.ProjectData> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.project.ProjectData> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.<START_MOD>LuceneQuerySource<END_MOD>(opts<START_MOD>.filterFields(IndexUtils::projectFields)<END_MOD>, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneProjectIndex.NAME_SORT_FIELD, SortField.Type.STRING, false))<START_MOD>, this::toProjectData<END_MOD>); }
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<V> read() throws com.google.gwtorm.server.OrmException { return readImpl(fromDocumentMapper); }<END_MOD>
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.group.InternalGroup> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.group.InternalGroup> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.<START_MOD>LuceneQuerySource<END_MOD>(opts<START_MOD>.filterFields(IndexUtils::groupFields)<END_MOD>, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneGroupIndex.UUID_SORT_FIELD, SortField.Type.STRING, false))<START_MOD>, this::toInternalGroup<END_MOD>); }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.account.AccountState> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.account.AccountState> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.<START_MOD>LuceneQuerySource<END_MOD>(opts<START_MOD>.filterFields(IndexUtils::accountFields)<END_MOD>, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneAccountIndex.ID_SORT_FIELD, SortField.Type.<START_MOD>STRING<END_MOD>, <START_MOD>false<END_MOD>))<START_MOD>, this::toAccountState<END_MOD>); }
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupById get(com.google.gerrit.reviewdb.client.AccountGroupById.Key key) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> iterateAllEntities() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> all() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id id) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupById.Key> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.Id> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> byUUID(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> iterateAllEntities() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> byAccount(com.google.gerrit.reviewdb.client.Account.Id id) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupName get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byGroupInclude(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.AccountGroup.UUID incGroupUUID) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupMember get(com.google.gerrit.reviewdb.client.AccountGroupMember.Key key) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupByIdAud get(com.google.gerrit.reviewdb.client.AccountGroupByIdAud.Key key) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupMemberAudit get(com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key key) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> all() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> iterateAllEntities() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupByIdAud.Key> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> all() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroup get(com.google.gerrit.reviewdb.client.AccountGroup.Id id) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> iterateAllEntities() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> iterateAllEntities() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id id) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupMember.Key> keys) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> iterateAllEntities() throws com.google.gwtorm.server.OrmException { return delegate.iterateAllEntities(); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> byIncludeUUID(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> byGroupAccount(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }<END_MOD>
<START_MOD>static com.google.gerrit.server.group.db.GroupConfig loadforGroup(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId id, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupUuid); groupConfig.load(rw, id); return groupConfig; }<END_MOD>
@org.junit.Test public void getAuditLog() throws java.lang.Exception { com.google.gerrit.extensions.api.groups.GroupApi g = gApi.groups().create(name("group")); java.util.List<? extends com.google.gerrit.extensions.common.GroupAuditEventInfo> auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(1); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, admin.id); g.addMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(2); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id); g.removeMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(3); assertAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id); java.lang.String otherGroup = name("otherGroup"); gApi.groups().create(otherGroup); g.addGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(4); assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup); g.removeGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(5); assertAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup); java.sql.Timestamp lastDate = null; for (com.google.gerrit.extensions.common.GroupAuditEventInfo auditEvent : auditEvents) { if (lastDate != null) { assertThat(lastDate).isGreaterThan(auditEvent.date); } lastDate = auditEvent.date; } }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException<END_MOD> { if (readFromNoteDb) { <START_MOD>return auditLogReader.getMembersAudit(groupUuid);<END_MOD> } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException<END_MOD> { if (readFromNoteDb) { <START_MOD>return auditLogReader.getSubgroupsAudit(groupUuid);<END_MOD> } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); }
<START_MOD>final com.google.common.collect.ImmutableList<T> parseAuditLog(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)); if (ref == null) { return com.google.common.collect.ImmutableList.of(); } com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = com.google.gerrit.server.group.db.GroupConfig.loadforGroup(rw, ref.getObjectId(), uuid).getLoadedGroup().get().getId(); rw.reset(); rw.markStart(rw.parseCommit(ref.getObjectId())); rw.setRetainBody(true); rw.sort(RevSort.REVERSE); com.google.common.collect.ImmutableList.Builder<T> result = com.google.common.collect.ImmutableList.builder(); org.eclipse.jgit.revwalk.RevCommit c; while ((c = rw.next()) != null) { parse(uuid, c).ifPresent(( pc) -> visit(groupId, pc, result)); } return result.build(); } }<END_MOD>
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getSubgroupsAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> audits = db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); <START_MOD>return <END_MOD>audits; }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getMembersAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> audits = db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); <START_MOD>return <END_MOD>audits; }