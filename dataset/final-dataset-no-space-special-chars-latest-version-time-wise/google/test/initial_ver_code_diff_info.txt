<START_MOD>@java.lang.Override protected com.google.gerrit.server.group.InternalGroup fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(source.getAsJsonObject().get(GroupField.UUID.getName()).getAsString()); return groupCache.get().get(uuid).orElse(null); }<END_MOD>
<START_MOD>@java.lang.Override protected com.google.gerrit.server.project.ProjectData fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(source.getAsJsonObject().get(ProjectField.NAME.getName()).getAsString()); return projectCache.get().get(nameKey).toProjectData(); }<END_MOD>
<START_MOD>protected abstract V fromDoc(com.google.gson.JsonObject doc, java.util.Set<java.lang.String> fields);<END_MOD>
<START_MOD>@java.lang.Override protected com.google.gerrit.server.account.AccountState fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(source.getAsJsonObject().get(com.google.gerrit.elasticsearch.ID.getName()).getAsInt()); return accountCache.get().get(id); }<END_MOD>
<START_MOD>@java.lang.Override public com.google.gwtorm.server.ResultSet<V> read() throws com.google.gwtorm.server.OrmException { return readImpl(( doc) -> this.fromDoc(doc, opts.fields())); }<END_MOD>
@java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb open() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = delegate.open(); if (migration.readChanges()) { if (migration.disableChangeReviewDb()) { db = new com.google.gerrit.server.schema.NoChangesReviewDbWrapper(db); } db = new com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper(db); } if (groupsMigration.readFromNoteDb()) { <START_MOD>if (groupsMigration.disableGroupReviewDb()) { db = new com.google.gerrit.server.schema.NoGroupsReviewDbWrapper(db); } <END_MOD>db = new com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper(db); } return db; }
static java.lang.String getGroupName(com.google.gerrit.server.account.GroupCache groupCache, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { <START_MOD>java.lang.String uuid = groupUuid.get(); java.lang.String name =<END_MOD> groupCache.get(groupUuid).map(InternalGroup::getName).<START_MOD>orElse<END_MOD>(<START_MOD>uuid);<END_MOD> <START_MOD>return<END_MOD> <START_MOD>com.google.gerrit.server.group.db.GroupsUpdate.<END_MOD>formatNameEmail(name, <START_MOD>uuid<END_MOD>); }
<START_MOD>@org.junit.Test public void includeExternalGroup() throws java.lang.Exception { java.lang.String g = createGroup("group"); java.lang.String subgroupUuid = SystemGroupBackend.REGISTERED_USERS.get(); gApi.groups().id(g).addGroups(subgroupUuid); java.util.List<com.google.gerrit.extensions.common.GroupInfo> subgroups = gApi.groups().id(g).includedGroups(); assertThat(subgroups).hasSize(1); assertThat(subgroups.get(0).id).isEqualTo(subgroupUuid.replace(":", "%3A")); assertThat(subgroups.get(0).groupId).isNull(); if (groupsMigration.writeToNoteDb()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().id(g).get().id); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = com.google.gerrit.server.group.db.testing.GroupTestUtil.log(repo, com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)); assertThat(log).hasSize(2); assertThat(log.get(0)).message().isEqualTo("Create group"); assertThat(log.get(1)).message().isEqualTo("Update group\n\nAdd-group: global:Registered-Users <global:Registered-Users>"); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> audit = groups.getSubgroupsAudit(db, repo, uuid); assertThat(audit).hasSize(1); assertThat(audit.get(0).getIncludeUUID()).isEqualTo(SystemGroupBackend.REGISTERED_USERS); } } }<END_MOD>
@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(MonitoringCapability.ID)).to(com.googlesource.gerrit.plugins.javamelody.MonitoringCapability.class); if (cfg.getBoolean("allowTopMenu", true)) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.javamelody.MonitoringTopMenu.class); } <START_MOD>final java.nio.file.Path directory = TEMPORARY_DIRECTORY.resolve(pluginName); final java.nio.file.Path storage_directory; if ((java.nio.file.Files.exists(directory)) && (java.nio.file.Files.isDirectory(directory))) { storage_directory = directory; } else { storage_directory = tmpDir.resolve(pluginName); } if ((java.lang.System.getProperty(((pluginName) + ".storage-directory"))) == null) { java.lang.System.setProperty(((pluginName) + ".storage-directory"), cfg.getString("storage_directory", storage_directory.toString())); } }<END_MOD>
<START_MOD>private java.lang.String getStorageDir() { final java.nio.file.Path tmp = com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.TEMPORARY_DIRECTORY.resolve(com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.JAVAMELODY_PREFIX); if (java.nio.file.Files.isDirectory(tmp)) { return tmp.toString(); } if (!(java.nio.file.Files.isDirectory(defaultDataDir))) { try { java.nio.file.Files.createDirectories(defaultDataDir); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.log.error("Creation of javamelody data dir [{}] failed.", defaultDataDir, e); throw new java.lang.RuntimeException(e); } } return defaultDataDir.toString(); }<END_MOD>
<START_MOD>private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage) throws java.io.IOException { return createCommit(repo, commitMessage, null); }<END_MOD>
<START_MOD>private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage, @com.google.gerrit.common.Nullable org.eclipse.jgit.lib.ObjectId treeId) throws java.io.IOException { try (org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter()) { if (treeId == null) { treeId = oi.insert(Constants.OBJ_TREE, new byte[]{ }); } org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(treeId); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage(commitMessage); org.eclipse.jgit.lib.ObjectId commit = oi.insert(cb); oi.flush(); return commit; } }<END_MOD>
<START_MOD>@org.junit.Test public void pushToDeletedGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(allUsers, groupRef, true, "group update not allowed"); }<END_MOD>
@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); com.google.gerrit.server.group.InternalGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null); assertThat(adminGroup).isNotNull(); <START_MOD>testCannotDeleteGroupBranch(((com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.reviewdb.client.RefNames.REFS_GROUPS)<END_MOD> <START_MOD>+<END_MOD> <START_MOD>"*"),<END_MOD> com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroup.getGroupUUID())); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if ((<START_MOD>(<END_MOD>receiveEvent.command.getRefName().startsWith(RefNames.REFS_GROUPS)) || (receiveEvent.command.getRefName().<START_MOD>startsWith(RefNames.REFS_DELETED_GROUPS))) || (receiveEvent.command.getRefName().<END_MOD>equals(RefNames.REFS_GROUPNAMES))) { throw new com.google.gerrit.server.git.validators.CommitValidationException( update not allowed } return java.util.Collections.emptyList(); }
<START_MOD>private void createBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, java.lang.String commitMessage) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter oi = r.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyCommit = createCommit(r, commitMessage); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(ref); updateRef.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.update(rw)).isEqualTo(RefUpdate.Result.NEW); } }<END_MOD>
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || ((<START_MOD>(<END_MOD>!(destBranch.get().startsWith(RefNames.REFS_GROUPS<START_MOD>))) && (!(destBranch.get().startsWith(RefNames.REFS_DELETED_GROUPS)<END_MOD>))) && (!(destBranch.get().equals(RefNames.REFS_GROUPNAMES))))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException( update not allowed }
<START_MOD>@org.junit.Test public void pushToDeletedGroupsBranchForNonAllUsersRepo() throws java.lang.Exception { assertCreateGroupBranch(project, null); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(project, groupRef, true, null); }<END_MOD>
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = <START_MOD>tr<END_MOD>.commit(<START_MOD>).add<END_MOD>("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))<START_MOD>.add<END_MOD>("project.config", ((("" + (   +   =   + (staff.toConfigValue())) + "\n"))<START_MOD>.create(<END_MOD>); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationErrors()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()).isEqualTo(((( group   + (staff.getName())) +   not in   + (GroupList.FILE_NAME))); }
@org.junit.Test public void readConfigLabelScores() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = <START_MOD>tr<END_MOD>.commit(<START_MOD>).add<END_MOD>("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))<START_MOD>.add<END_MOD>("project.config", (("" +     + (com.google.gerrit.server.git.ProjectConfigTest.LABEL_SCORES_CONFIG)))<START_MOD>.create(<END_MOD>); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> labels = cfg.getLabelSections(); com.google.gerrit.common.data.LabelType type = labels.entrySet().iterator().next().getValue(); assertThat(type.isCopyMinScore()).isNotEqualTo(LabelType.DEF_COPY_MIN_SCORE); assertThat(type.isCopyMaxScore()).isNotEqualTo(LabelType.DEF_COPY_MAX_SCORE); assertThat(type.isCopyAllScoresOnMergeFirstParentUpdate()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE); assertThat(type.isCopyAllScoresOnTrivialRebase()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE); assertThat(type.isCopyAllScoresIfNoCodeChange()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE); assertThat(type.isCopyAllScoresIfNoChange()).isNotEqualTo(LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE); }
@org.junit.Test public void editPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = <START_MOD>tr<END_MOD>.commit(<START_MOD>).add<END_MOD>("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))<START_MOD>.add<END_MOD>("project.config", ((("" + (   +   =   + (developers.toConfigValue())) + "\n"))<START_MOD>.create(<END_MOD>); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginCfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(developers); pluginCfg.setGroupReference("key1", staff); rev = commit(cfg); assertThat(text(rev, "project.config")).isEqualTo(((("" + (   +   =   + (staff.toConfigValue())) + "\n")); assertThat(text(rev, "groups")).isEqualTo(((((( UUID Name + "#\n") + (staff.getUUID().get())) +     + (staff.getName())) + "\n")); }
@org.junit.Test public void readPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = <START_MOD>tr<END_MOD>.commit(<START_MOD>).add<END_MOD>("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))<START_MOD>.add<END_MOD>("project.config", ((("" + (   +   =   + (developers.toConfigValue())) + "\n"))<START_MOD>.create(<END_MOD>); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginCfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(developers); }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = java.nio.file.Paths.get(java.lang.System.getProperty("java.io.tmpdir")).resolve(com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.JAVAMELODY_PREFIX); if (java.nio.file.Files.isDirectory(tmp)) { return tmp.toString(); } <START_MOD>java.nio.file.Path storageDir = java.util.Optional.ofNullable(cfg.getString(com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.STORAGE_DIR)).map(( path) -> { <END_MOD>if (<START_MOD>path == null) { return defaultDataDir; } return java.nio.file.Paths.get(path); }).get(); if (<END_MOD>!(java.nio.file.Files.isDirectory(<START_MOD>storageDir<END_MOD>))) { try { java.nio.file.Files.createDirectories(<START_MOD>storageDir<END_MOD>); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.log.error( of javamelody data dir [{}] failed. <START_MOD>storageDir<END_MOD>, e); throw new java.lang.RuntimeException(e); } } return <START_MOD>storageDir<END_MOD>.toString(); }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo apply(com.google.gerrit.server.config.ConfigResource resource, com.google.gerrit.extensions.api.config.ConsistencyCheckInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE); if ((input == null) || (((input.checkAccounts) == null) && ((input.checkAccountExternalIds) == null))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( required } com.google.gerrit.extensions.api.config.ConsistencyCheckInfo consistencyCheckInfo = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(); if ((input.checkAccounts) != null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountsResultInfo(accountsConsistencyChecker.check()); } if ((input.checkAccountExternalIds) != null) { consistencyCheckInfo.checkAccountExternalIdsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountExternalIdsResultInfo(externalIdsConsistencyChecker.check()); } <START_MOD>if ((input.checkGroups) != null) { consistencyCheckInfo.checkGroupsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckGroupsResultInfo(groupsConsistencyChecker.check()); } <END_MOD>return consistencyCheckInfo; }
<START_MOD>void setAllowSaveEmptyName(boolean allowSaveEmptyName) { this.allowSaveEmptyName = allowSaveEmptyName; }<END_MOD>
<START_MOD>private GroupBundle.Builder newBundle() { java.sql.Timestamp ts = new java.sql.Timestamp(TestTimeUtil.START.toEpochMilli()); com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.Id(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("group-1"), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.Account.Id(1000), group.getId())); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(member, new com.google.gerrit.reviewdb.client.Account.Id(2000), ts); com.google.gerrit.reviewdb.client.AccountGroupById byId = new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup"))); com.google.gerrit.reviewdb.client.AccountGroupByIdAud byIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(byId, new com.google.gerrit.reviewdb.client.Account.Id(3000), ts); return com.google.gerrit.server.group.db.GroupBundle.builder().group(group).members(member).memberAudit(memberAudit).byId(byId).byIdAudit(byIdAudit); }<END_MOD>
private static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM); java.lang.String name = <START_MOD>com.google.common.base.Strings.nullToEmpty(<END_MOD>config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM)<START_MOD>)<END_MOD>; if (uuid == null) <START_MOD>{ throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format( for group '%s' <END_MOD>name<START_MOD>)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid),<END_MOD> name); }
<START_MOD>@java.lang.Override public int hashCode() { return java.lang.System.identityHashCode(this); }<END_MOD>
<START_MOD>private java.util.Optional<java.lang.String> getNewName() { if (groupUpdate.isPresent()) { return groupUpdate.get().getName().map(( n) -> com.google.common.base.Strings.nullToEmpty(n.get())); } else if (groupCreation.isPresent()) { return java.util.Optional.of(com.google.common.base.Strings.nullToEmpty(groupCreation.get().getNameKey().get())); } return java.util.Optional.empty(); }<END_MOD>
<START_MOD>default boolean accBelongsToRealm(@java.lang.SuppressWarnings("unused") java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { return false; }<END_MOD>
<START_MOD>@java.lang.Override public boolean accBelongsToRealm(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { for (com.google.gerrit.server.account.externalids.ExternalId id : externalIds) { if (id.toString().contains(com.google.gerrit.server.auth.ldap.SCHEME_GERRIT)) { return true; } } return false; }<END_MOD>
<START_MOD>@java.lang.Override public boolean accBelongsToRealm(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { for (com.google.gerrit.server.account.externalids.ExternalId id : externalIds) { if (id.toString().contains(com.google.gerrit.server.auth.oauth.SCHEME_EXTERNAL)) { return true; } } return false; }<END_MOD>
private boolean processAccount(com.google.gerrit.server.account.AccountState account) { com.google.gerrit.server.account.AccountDeactivator.log.debug(( account   + (account.getUserName()))); try { if (((account.getUserName()) != null) && (!(realm.isActive(account.getUserName())))) { <START_MOD>java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> ids = externalIds.byAccount(account.getAccount().getId()); if (realm.accBelongsToRealm(ids)) { <END_MOD>sif.deactivate(account.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivator.log.info(( account   + (account.getUserName()))); return true;<START_MOD> }<END_MOD> } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { com.google.gerrit.server.account.AccountDeactivator.log.info( {} already deactivated, continuing... account.getUserName()); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error( deactivating account: {} ({}) {} account.getUserName(), account.getAccount().getId(), e.getMessage(), e); } return false; }
<START_MOD>private static boolean areByIdAuditsConsideredEqual(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> reviewDbByIdAudits, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> noteDbByIdAudits) { com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> reviewDbByIdAuditsById = com.google.gerrit.server.group.db.GroupBundle.toByIdAuditEntriesById(reviewDbByIdAudits); com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> noteDbByIdAuditsById = com.google.gerrit.server.group.db.GroupBundle.toByIdAuditEntriesById(noteDbByIdAudits); return com.google.gerrit.server.group.db.GroupBundle.areConsideredEqual(reviewDbByIdAuditsById, noteDbByIdAuditsById); }<END_MOD>
<START_MOD>private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> toMemberAuditEntriesByMemberId(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> memberAudits) { return memberAudits.stream().flatMap(com.google.gerrit.server.group.db.GroupBundle::toAuditEntries).collect(com.google.common.collect.Multimaps.toMultimap(com.google.gerrit.server.group.db.GroupBundle.AuditEntry::getTarget, java.util.function.Function.identity(), com.google.common.collect.MultimapBuilder.hashKeys().treeSetValues(com.google.gerrit.server.group.db.GroupBundle.AUDIT_ENTRY_COMPARATOR)::build)); }<END_MOD>
<START_MOD>private static boolean areMemberAuditsConsideredEqual(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDbMemberAudits, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> noteDbMemberAudits) { com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> reviewDbMemberAuditsByMemberId = com.google.gerrit.server.group.db.GroupBundle.toMemberAuditEntriesByMemberId(reviewDbMemberAudits); com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> noteDbMemberAuditsByMemberId = com.google.gerrit.server.group.db.GroupBundle.toMemberAuditEntriesByMemberId(noteDbMemberAudits); return com.google.gerrit.server.group.db.GroupBundle.areConsideredEqual(reviewDbMemberAuditsByMemberId, noteDbMemberAuditsByMemberId); }<END_MOD>
<START_MOD>private static boolean areConsideredEqual(com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> reviewDbMemberAuditsByMemberId, com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> noteDbMemberAuditsByMemberId) { for (java.lang.String memberId : reviewDbMemberAuditsByMemberId.keySet()) { java.util.List<com.google.gerrit.server.group.db.GroupBundle.AuditEntry> reviewDbAuditEntries = com.google.common.collect.ImmutableList.copyOf(reviewDbMemberAuditsByMemberId.get(memberId)); java.util.SortedSet<com.google.gerrit.server.group.db.GroupBundle.AuditEntry> noteDbAuditEntries = noteDbMemberAuditsByMemberId.get(memberId); int reviewDbIndex = 0; for (com.google.gerrit.server.group.db.GroupBundle.AuditEntry noteDbAuditEntry : noteDbAuditEntries) { java.util.Set<com.google.gerrit.server.group.db.GroupBundle.AuditEntry> redundantReviewDbAuditEntries = new java.util.HashSet<>(); while (reviewDbIndex < (reviewDbAuditEntries.size())) { com.google.gerrit.server.group.db.GroupBundle.AuditEntry reviewDbAuditEntry = reviewDbAuditEntries.get(reviewDbIndex); if (!(reviewDbAuditEntry.getAction().equals(noteDbAuditEntry.getAction()))) { break; } redundantReviewDbAuditEntries.add(reviewDbAuditEntry); reviewDbIndex++; } if (!(redundantReviewDbAuditEntries.contains(noteDbAuditEntry))) { return false; } } if (reviewDbIndex < (reviewDbAuditEntries.size())) { return false; } } return true; }<END_MOD>
<START_MOD>private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.db.GroupBundle.AuditEntry> toByIdAuditEntriesById(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byIdAudits) { return byIdAudits.stream().flatMap(com.google.gerrit.server.group.db.GroupBundle::toAuditEntries).collect(com.google.common.collect.Multimaps.toMultimap(com.google.gerrit.server.group.db.GroupBundle.AuditEntry::getTarget, java.util.function.Function.identity(), com.google.common.collect.MultimapBuilder.hashKeys().treeSetValues(com.google.gerrit.server.group.db.GroupBundle.AUDIT_ENTRY_COMPARATOR)::build)); }<END_MOD>
public java.lang.String getName() { if ((fullName) != null) { return fullName; } if ((preferredEmail) != null) { return preferredEmail; } return <START_MOD>    + <END_MOD>(<START_MOD>accountId<END_MOD>); }
private static org.eclipse.jgit.lib.PersonIdent ident(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String anonymousCowardName, com.google.gerrit.server.CurrentUser u, java.util.Date when) { com.google.gerrit.server.notedb.AbstractChangeUpdate.checkUserType(u); if (u instanceof com.google.gerrit.server.IdentifiedUser) { return noteUtil.newIdent(u.asIdentifiedUser().getAccount(), when, serverIdent); } else if (u instanceof com.google.gerrit.server.InternalUser) { return serverIdent; } throw new java.lang.IllegalStateException(); }
<START_MOD>public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check(org.eclipse.jgit.lib.Repository repo, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(groupsMigration.writeToNoteDb())) { return new java.util.ArrayList<>(); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getAllRefs(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); com.google.common.collect.BiMap<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> nameMap = com.google.common.collect.HashBiMap.create(); readGroups(repo, refs, problems, byUUID); readGroupNames(repo, refs, problems, nameMap); if (!(problems.isEmpty())) { return problems; } problems = checkGlobalConsistency(byUUID, nameMap); return problems; }<END_MOD>
public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check() throws com.google.gwtorm.server.OrmException, java.io.IOException { <START_MOD>try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> groups = new java.util.HashMap<>(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = globalChecker.check(repo, groups); <END_MOD>if (!(<START_MOD>problems.isEmpty<END_MOD>())) { return <START_MOD>problems; } for (com.google.gerrit.server.group.InternalGroup g : groups.values()) { problems.addAll(checkGroup(g, groups)); }<END_MOD> return <START_MOD>problems; } }<END_MOD>
@com.google.gerrit.common.Nullable public com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result check(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result r = doCheck(repo); if (!(r.problems.isEmpty())) { r.uuidToGroupMap = null; } return r; }
<START_MOD>@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (healthy) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_OK); } else { try { rsp.sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.LOG.error("Failed to send error response", e); } } }<END_MOD>
<START_MOD>@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { this.healthy = true; }<END_MOD>
@org.junit.Before public void setUp() throws java.lang.Exception {<START_MOD> when(currentUserProviderMock.get()).thenReturn(currentUserMock); when(currentUserMock.getCapabilities()).thenReturn(capabilityControlMock); when(capabilityControlMock.canAdministrateServer()).thenReturn(true);<END_MOD> servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet(tempFolder.getRoot().toPath()<START_MOD>, currentUserProviderMock<END_MOD>); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, <START_MOD>com<END_MOD>.<START_MOD>ericsson<END_MOD>.<START_MOD>gerrit.plugins.highavailability.health<END_MOD>.HttpServletResponse rsp) {<START_MOD> if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_FORBIDDEN); return; }<END_MOD> try { setUnhealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error( to set unhealthy e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, <START_MOD>com<END_MOD>.<START_MOD>ericsson<END_MOD>.<START_MOD>gerrit.plugins.highavailability.health<END_MOD>.HttpServletResponse rsp) {<START_MOD> if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_FORBIDDEN); return; }<END_MOD> try { setHealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error( to set healthy e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }
private void sendError(<START_MOD>com<END_MOD>.<START_MOD>ericsson<END_MOD>.<START_MOD>gerrit.plugins.highavailability.health<END_MOD>.HttpServletResponse rsp, int statusCode) { try { rsp.sendError(statusCode); } catch (java.io.IOException e) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error( to send error response e); } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, <START_MOD>com<END_MOD>.<START_MOD>ericsson<END_MOD>.<START_MOD>gerrit.plugins.highavailability.health<END_MOD>.HttpServletResponse rsp) { if (unhealthyFile.exists()) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_SERVICE_UNAVAILABLE); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }
<START_MOD>@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { this.healthy = false; }<END_MOD>
private static int getInt(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, int defaultValue) { try { return cfg.getInt(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error( value for <START_MOD>{}<END_MOD>; using default value <START_MOD>{}<END_MOD> name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(( to retrieve integer value:   + (e.getMessage())), e); return defaultValue; } }
private static boolean getBoolean(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, boolean defaultValue) { try { return cfg.getBoolean(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error( value for <START_MOD>{}<END_MOD>; using default value <START_MOD>{}<END_MOD> name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(( to retrieve boolean value:   + (e.getMessage())), e); return defaultValue; } }
private void evictCache(com.google.common.cache.Cache<?, ?> cache, java.lang.String cacheName, java.lang.Object key) { if (Constants.PROJECT_LIST.equals(cacheName)) { cache.invalidateAll(); <START_MOD>com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug( all {} cacheName); <END_MOD>} else { cache.invalidate(key); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug( {} <START_MOD>from {} key, <END_MOD>cacheName); }<START_MOD> }<END_MOD>
public java.lang.String[] getIssueIds(java.lang.String haystack) { java.util.regex.Pattern pattern = itsConfig.getIssuePattern(); if (pattern == null) return new java.lang.String[]{ }; com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.log.debug(<START_MOD> '{}' against  <END_MOD> haystack<START_MOD>, pattern.pattern(<END_MOD>)); java.util.Set<java.lang.String> issues = com.google.common.collect.Sets.newHashSet(); java.util.regex.Matcher matcher = pattern.matcher(haystack); int groupIdx = itsConfig.getIssuePatternGroupIndex(); while (matcher.find()) { java.lang.String issueId = matcher.group(groupIdx); if (!(com.google.common.base.Strings.isNullOrEmpty(issueId))) { issues.add(issueId); } } return issues.toArray(new java.lang.String[issues.size()]); }
public boolean isEnabled(com.google.gerrit.reviewdb.client.Project.NameKey projectNK, java.lang.String refName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectNK); if (projectState == null) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig.log.error( to check if <START_MOD>{} is enabled for project {}: Project not found <END_MOD>pluginName<START_MOD>, <END_MOD>projectNK.get()<START_MOD>, <END_MOD>projectNK.get())<START_MOD>;<END_MOD> return false; } if (isEnforcedByAnyParentProject(refName, projectState)) { return true; } return (!("false".equals(pluginCfgFactory.getFromProjectConfigWithInheritance(projectState, pluginName).getString("enabled", "false")))) && (isEnabledForBranch(projectState, refName)); }
<START_MOD>@org.junit.Test public void rebuild() throws java.lang.Exception { assume().that(groupsMigration.writeToNoteDb()).isTrue(); assume().that(groupsMigration.readFromNoteDb()).isFalse(); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(name("group")).get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g.id); java.lang.String refName = com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid); org.eclipse.jgit.lib.ObjectId oldId; com.google.gerrit.server.group.db.GroupBundle oldBundle; try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { oldId = repo.exactRef(refName).getObjectId(); oldBundle = bundleFactory.fromNoteDb(repo, uuid); new org.eclipse.jgit.junit.TestRepository(repo).delete(refName); } assertThat(adminRestSession.postOK((("/groups/" + uuid) + "/rebuild"), "").getEntityContent()).isEqualTo("No differences between ReviewDb and NoteDb"); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); assertThat(ref).isNotNull(); assertThat(ref.getObjectId()).isNotEqualTo(oldId); com.google.gerrit.server.group.db.GroupBundle newBundle = bundleFactory.fromNoteDb(repo, uuid); assertThat(newBundle.group()).isEqualTo(oldBundle.group()); assertThat(newBundle.members()).isEqualTo(oldBundle.members()); assertThat(newBundle.memberAudit()).isEqualTo(oldBundle.memberAudit()); assertThat(newBundle.byId()).isEqualTo(oldBundle.byId()); assertThat(newBundle.byIdAudit()).isEqualTo(oldBundle.byIdAudit()); } }<END_MOD>
private java.lang.String getCommentChangeEvent(java.lang.String action, java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = ""; java.lang.String changeNumber = com.google.common.base.Strings.nullToEmpty(map.get(<START_MOD>"changeNumber")); if (!(<END_MOD>changeNumber<START_MOD>.isEmpty())) { changeNumber +=     } ret += (   + changeNumber) + action; java.lang.String submitter = formatPerson(prefix, map); if (!(submitter.isEmpty())) { ret +=   by   + submitter; } java.lang.String subject<END_MOD> = com.google.common.base.Strings.nullToEmpty(map.get(<START_MOD>"subject")); if (!(<END_MOD>subject<START_MOD>.isEmpty())) { ret += ":\n" + subject; } java.lang.String reason<END_MOD> = com.google.common.base.Strings.nullToEmpty(map.get(<START_MOD>"reason")); if (!(<END_MOD>reason<START_MOD>.isEmpty())) { ret += "\n\nReason:\n" + reason; } java.lang.String url<END_MOD> = com.google.common.base.Strings.nullToEmpty(map.get(<START_MOD>"changeUrl")); if (!(<END_MOD>url<START_MOD>.isEmpty())) { ret += "\n\n" + (its.createLinkForWebui(<END_MOD>url<START_MOD>, <END_MOD>url)); } return ret; }
private java.lang.String formatPerson(java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Name"))); if (ret.isEmpty()) { ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Username"))); } return ret; }
static java.lang.String getOwnersFileName(com.google.gerrit.<START_MOD>server.<END_MOD>project<START_MOD>.ProjectState projectState<END_MOD>, com.google.gerrit.server.query.change.ChangeData c) { if (((com.googlesource.gerrit.plugins.findowners.Config.config) != null) && (<START_MOD>projectState<END_MOD> != null)) { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(<START_MOD>projectState<END_MOD>, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS); if (name.trim().equals("")) { com.googlesource.gerrit.plugins.findowners.Config.log.error((((((((   + <START_MOD>(c.<END_MOD>project<START_MOD>())<END_MOD>) +   has wrong   + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) +     + name) +   for   + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(c)))); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } <START_MOD>return com.googlesource.gerrit.plugins.findowners.Config.OWNERS<END_MOD>; }
private boolean shouldReplicate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { <START_MOD>com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (java.io.IOException e) { <END_MOD>return <START_MOD>false; } if (projectState == null) { throw <END_MOD>new com.google.gerrit.server.project.NoSuchProjectException<START_MOD>(project); }<END_MOD> return shouldReplicate(<START_MOD>projectState, userProvider.get()<END_MOD>); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format( project %s not available project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
public java.util.regex.Pattern getIssuePattern() { java.util.Optional<java.lang.String> match = <START_MOD>com.googlesource.gerrit.plugins.its.base.its.FluentIterable.from(getCommentLinkInfo(getCommentLinkName())).filter(new com.googlesource.gerrit.plugins.its.base.its.Predicate<com.google.gerrit.extensions.api.projects.CommentLinkInfo>() { @java.lang.Override public boolean apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return ((input.match) != null) && (!(input.match.trim().isEmpty())); } }).transform(new com.googlesource.gerrit.plugins.its.base.its.Function<com.google.gerrit.extensions.api.projects.CommentLinkInfo, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return input.match; } }).last(); java.lang.String defPattern = gerritConfig.getString("commentlink", getCommentLinkName(), "match"); }<END_MOD>
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("patchSetNumber", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("createdOn", patchSetAttribute.createdOn.toString())); <START_MOD>properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeDeletions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "author")<END_MOD>); }
public static com.google.common.collect.ImmutableList<java.lang.String> compare(com.google.gerrit.server.group.db.GroupBundle reviewDbBundle, com.google.gerrit.server.group.db.GroupBundle noteDbBundle) { <START_MOD>return<END_MOD> com.google.gerrit.server.group.db.GroupBundle.<START_MOD>compare(<END_MOD>reviewDbBundle, noteDbBundle<START_MOD>,<END_MOD> <START_MOD>true<END_MOD>); }
<START_MOD>private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.IOException, com.google.gerrit.server.project.NoSuchProjectException { if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, reviewer, val)) { return; } permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER); }<END_MOD>
<START_MOD>public void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.IOException, com.google.gerrit.server.project.NoSuchProjectException { checkRemoveReviewer(notes, currentUser, reviewer, 0); }<END_MOD>
<START_MOD>@org.junit.Test public void testHealthCheckEnabled() throws java.lang.Exception { when(configMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HEALTH_CHECK_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.ENABLE, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HEALTH_CHECK_ENABLED)).thenReturn(false); initializeConfiguration(); assertThat(configuration.healthCheck().enabled()).isFalse(); }<END_MOD>
@java.lang.Override public org.junit.runners.model.Statement apply(org.junit.runners.model.Statement base, org.junit.runner.Description description) { return new org.junit.runners.model.Statement() { @java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); try <START_MOD>(com.google.gerrit.acceptance.ProjectConfigResetter resetter = resetProjects(allProjects, allUsers)) <END_MOD>{ base.evaluate(); } finally { afterTest(); } } }; }
<START_MOD>protected com.google.gerrit.acceptance.ProjectConfigResetter resetProjects(com.google.gerrit.reviewdb.client.Project... projects) throws java.lang.Exception { return new com.google.gerrit.acceptance.ProjectConfigResetter(repoManager, metaDataUpdateFactory, projectCache, projects); }<END_MOD>
@java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); try <START_MOD>(com.google.gerrit.acceptance.ProjectConfigResetter resetter = resetProjects(allProjects, allUsers)) <END_MOD>{ base.evaluate(); } finally { afterTest(); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPNAMES); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.common.data.GroupReference> groupReferences = com.google.common.collect.ImmutableSet.builder(); <START_MOD>java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> uuidMap = new java.util.HashMap<>(); java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.AccountGroup.UUID> nameMap = new java.util.HashMap<>(); <END_MOD>for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.common.data.GroupReference groupReference = com.google.gerrit.server.group.db.GroupNameNotes.getGroupReference(reader, note.getData()); groupReferences.add(groupReference); <START_MOD>com.google.gerrit.server.group.db.GroupNameNotes.checkConsistency(groupReference, uuidMap, nameMap); <END_MOD>} return groupReferences.build(); } }
public static com.google.gerrit.server.group.db.GroupConfig createForNewGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupCreation.getGroupUUID()<START_MOD>, repository<END_MOD>); groupConfig.load(repository); groupConfig.setGroupCreation(groupCreation); return groupConfig; }
public static com.google.gerrit.server.group.db.GroupConfig loadForGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupUuid<START_MOD>, repository<END_MOD>); groupConfig.load(repository); return groupConfig; }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> getLoadedGroup() { checkLoaded(); <START_MOD>loadedGroup.ifPresent(( t) -> checkConsistencyWithGroupNameNotes(t)); <END_MOD>return loadedGroup; }
public static com.google.gerrit.server.group.db.GroupConfig loadForGroupSnapshot(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, org.eclipse.jgit.lib.ObjectId commitId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = new com.google.gerrit.server.group.db.GroupConfig(groupUuid<START_MOD>, repository<END_MOD>); groupConfig.load(repository, commitId); return groupConfig; }
private java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> loadGroup(com.google.gerrit.common.data.GroupReference groupReference) { <START_MOD>java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> group =<END_MOD> groupCache.get(groupReference.getUUID()).map(InternalGroupDescription::new); <START_MOD>if (!(group.isPresent())) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning( %s (%s) from group name notes is failed to load from group ref <END_MOD>}<START_MOD> return group; }<END_MOD>
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException( should only have no more than one --project and -n with --suggest } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().orElse(null)), ((limit) <=   ? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupRefs.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic desc = groupBackend.get(ref.getUUID()); if (desc != null) { groupInfos.add(json.addOptions(options).format(desc)); } <START_MOD>else if ((groupBackend) instanceof com.google.gerrit.server.account.InternalGroupBackend) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning( %s (%s) from group name notes is failed to load from group ref ref.getName(), ref.getUUID()); <END_MOD>} <START_MOD>} <END_MOD>return groupInfos; }
int findApproval(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Emails emails) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExemptFromOwnerApproval(changeData)) { return 0; } com.googlesource.gerrit.plugins.findowners.OwnersDb db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(projectState, accountCache, emails, repository, changeData); if ((db.getNumOwners()) <= 0) { return 0; } if ((minVoteLevel) <= 0) { minVoteLevel = com.googlesource.gerrit.plugins.findowners.Config.getMinOwnerVoteLevel(<START_MOD>projectState<END_MOD>); } com.googlesource.gerrit.plugins.findowners.Checker.log.trace(( db key =   + (db.key))); return findApproval(accountCache, db); }
static int getMinOwnerVoteLevel(com.google.gerrit.server.<START_MOD>project<END_MOD>.<START_MOD>ProjectState<END_MOD> <START_MOD>projectState<END_MOD>) throws com.google.gwtorm.server.OrmException { return ((com.googlesource.gerrit.plugins.findowners.Config.config) == null) || (<START_MOD>projectState<END_MOD> == null) ? com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteLevel : com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(<START_MOD>projectState<END_MOD>, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_LEVEL, com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteLevel); }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.WebLinks links) throws java.io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); boolean canDelete = perm.testOrFalse(RefPermission.DELETE); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (tagger != null ? com.google.gerrit.server.CommonConverters.toGitPerson(<START_MOD>tagger<END_MOD>) : null), canDelete, (<START_MOD>tagger != null ? new java.sql.Timestamp(tagger.getWhen().getTime()) : null), (<END_MOD>webLinks.isEmpty() ? null : webLinks)); } <START_MOD>java.sql.Timestamp timestamp = (object instanceof org.eclipse.jgit.revwalk.RevCommit) ? new java.sql.Timestamp(((org.eclipse.jgit.revwalk.RevCommit) (object)).getCommitterIdent().getWhen().getTime()) : null; <END_MOD>return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), ref.getObjectId().getName(), canDelete, <START_MOD>timestamp, <END_MOD>(webLinks.isEmpty() ? null : webLinks)); }
@org.junit.Test public void lightweightTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/heads/master"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInput input = new com.google.gerrit.extensions.api.projects.TagInput(); input.ref = "v1.0"; input.revision = r.getCommit().getName(); com.google.gerrit.extensions.api.projects.TagInfo result = tag(input.ref).create(input).get(); assertThat(result.ref).isEqualTo(((R_TAGS) + (input.ref))); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.canDelete).isTrue(); <START_MOD>assertThat(result.created).isEqualTo(timestamp(r)); <END_MOD>input.ref = "refs/tags/v2.0"; result = tag(input.ref).create(input).get(); assertThat(result.ref).isEqualTo(input.ref); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.canDelete).isTrue(<START_MOD>); assertThat(result.created).isEqualTo(timestamp(r)<END_MOD>); setApiUser(user); result = tag(input.ref).get(); assertThat(result.canDelete).isFalse(); eventRecorder.assertRefUpdatedEvents(project.get(), result.ref, null, result.revision); }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.<START_MOD>loadedAccount<END_MOD> = <START_MOD>java.util.Optional.of(<END_MOD>checkNotNull(account<START_MOD>)<END_MOD>); this.registeredOn = account.getRegisteredOn(); }
@com.google.gerrit.common.Nullable public <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.reviewdb.client.Account<START_MOD>><END_MOD> <START_MOD>getLoadedAccount<END_MOD>() { checkLoaded(); return <START_MOD>loadedAccount<END_MOD>; }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision) != null) { rw.reset(); rw.markStart(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); <START_MOD>loadedAccount<END_MOD> = <START_MOD>java.util.Optional.of(<END_MOD>parse(cfg<START_MOD>,<END_MOD> revision.name(<START_MOD>)<END_MOD>)); } isLoaded = true; }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.<START_MOD>Id<END_MOD>, com.google.gerrit.server.notedb.ChangeNotes> <START_MOD>openChangesByIdByBranch<END_MOD>(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.Change.<START_MOD>Id<END_MOD>, com.google.gerrit.server.notedb.ChangeNotes> r = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchOpen(branch)) { r.put(cd.change().<START_MOD>getId<END_MOD>(), cd.notes()); } return r; }
<START_MOD>@org.junit.Test public void testErrorDuringTransitionToHealty() throws java.io.IOException { java.nio.file.Files.createFile(tempFolder.newFolder("unhealthy.txt").toPath().resolve("child")); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doPost(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); }<END_MOD>
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (<START_MOD>unhealthyFile.exists()<END_MOD>) {<START_MOD> sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_SERVICE_UNAVAILABLE); }<END_MOD> rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }
<START_MOD>@org.junit.Test public void testErrorDuringTransitionToUnhealty() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); }<END_MOD>
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { <START_MOD>try<END_MOD> <START_MOD>{<END_MOD> <START_MOD>setHealthy()<END_MOD>; rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }<START_MOD> catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error( to set healthy e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }<END_MOD>
@org.junit.Before public void setUp() throws java.lang.Exception { servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet(<START_MOD>tempFolder.getRoot().toPath()<END_MOD>); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { <START_MOD>try<END_MOD> <START_MOD>{<END_MOD> <START_MOD>setUnhealthy()<END_MOD>; rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.health.SC_NO_CONTENT); }<START_MOD> catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error( to set unhealthy e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); } }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert(@com.google.gerrit.common.Nullable java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { try { return <START_MOD>calculatePureRevert.<END_MOD>getPureRevert(change<START_MOD>.getNotes(), claimedOriginal<END_MOD>); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( compute pure revert e); } }
@com.google.gerrit.common.Nullable public java.lang.Boolean isPureRevert() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getPureRevert(notes()<START_MOD>, null<END_MOD>).isPureRevert; } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new com.google.gwtorm.server.OrmException( not compute pure revert e); } }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { return <START_MOD>calculatePureRevert.<END_MOD>getPureRevert(rsrc.getNotes()<START_MOD>, claimedOriginal<END_MOD>); }
private void setUp(<START_MOD>java.lang.Object target<END_MOD>) throws java.lang.Exception { injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testing.InMemoryModule()); injector.injectMembers(this); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); lifecycle.start(); try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); setApiUser(accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId()); <START_MOD>injector.injectMembers(target); <END_MOD>}
@org.junit.Test public void <START_MOD>testErrorDuringTransitionToUnHealthy<END_MOD>() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.health.SC_INTERNAL_SERVER_ERROR); }
<START_MOD>private java.lang.String getProtocolStack(org.eclipse.jgit.lib.Config cfg, SitePaths site) { java.lang.String location = cfg.getString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PROTOCOL_STACK_KEY); if (location == null) { return null; } java.nio.file.Path p = java.nio.file.Paths.get(location); if (p.isAbsolute()) { return location; } return site.etc_dir.resolve(location).toString(); }<END_MOD>
<START_MOD>public java.lang.String protocolStack() { return protocolStack; }<END_MOD>
<START_MOD>private org.jgroups.JChannel getChannel() { java.lang.String protocolStack = ""; try { protocolStack = jgroupsConfig.protocolStack(); return protocolStack == null ? new org.jgroups.JChannel() : new org.jgroups.JChannel(protocolStack); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("Unable to create a new channel with {}", protocolStack, e); return null; } }<END_MOD>
public void connect() { try { channel = <START_MOD>getChannel<END_MOD>(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { <START_MOD>com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.debug(( stack:   + (channel.getProtocolStack()))); <END_MOD>channel.getProtocolStack().getTransport().setBindAddress(address.get()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.debug( bound to {} address.get()); } else { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.warn( not bound: address not present } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info( {} successfully joined jgroups cluster {} channel.getName(), jgroupsConfig.clusterName()); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error( cluster {} for channel {} failed jgroupsConfig.clusterName(), channel.getName(), e); } }
protected void setUseSignedOffBy(com.google.gerrit.extensions.client.InheritableBoolean value) throws java.lang.Exception { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.getProject().<START_MOD>setBooleanConfig<END_MOD>(<START_MOD>BooleanProjectConfig.USE_SIGNED_OFFBY, <END_MOD>value); config.commit(md); projectCache.evict(config.getProject()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(state.<START_MOD>is(BooleanProjectConfig.USE_SIGNED_OFFBY<END_MOD>))) { return java.util.Collections.emptyList(); } org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); org.eclipse.jgit.lib.PersonIdent author = commit.getAuthorIdent(); boolean sboAuthor = false; boolean sboCommitter = false; boolean sboMe = false; for (org.eclipse.jgit.revwalk.FooterLine footer : commit.getFooterLines()) { if (footer.matches(FooterKey.SIGNED_OFF_BY)) { java.lang.String e = footer.getEmailAddress(); if (e != null) { sboAuthor |= author.getEmailAddress().equals(e); sboCommitter |= committer.getEmailAddress().equals(e); sboMe |= user.hasEmailAddress(e); } } } if (((!sboAuthor) && (!sboCommitter)) && (!sboMe)) { try { perm.check(RefPermission.FORGE_COMMITTER); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.server.git.validators.CommitValidationException( Signed-off-by author/committer/uploader in commit message footer } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.validators.CommitValidators.log.error( check FORGE_COMMITTER e); throw new com.google.gerrit.server.git.validators.CommitValidationException( auth error } } return java.util.Collections.emptyList(); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case READ_PRIVATE_CHANGES : return canViewPrivateChanges(); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().<START_MOD>is(BooleanProjectConfig.USE_SIGNED_OFFBY<END_MOD>))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
@org.junit.Test public void createProjectWithProperties() throws java.lang.Exception { java.lang.String newProjectName = name("newProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = newProjectName; in.description =   description in.submitType = com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useSignedOffBy = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.requireChangeId = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects().create(in).get(); assertThat(p.name).isEqualTo(newProjectName); com.google.gerrit.reviewdb.client.Project project = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newProjectName)).getProject(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertThat(project.getDescription()).isEqualTo(in.description); assertThat(project.getSubmitType()).isEqualTo(in.submitType); assertThat(project.<START_MOD>getBooleanConfig(BooleanProjectConfig.USE_CONTRIBUTOR_AGREEMENTS<END_MOD>)).isEqualTo(in.useContributorAgreements); assertThat(project.<START_MOD>getBooleanConfig(BooleanProjectConfig.USE_SIGNED_OFFBY<END_MOD>)).isEqualTo(in.useSignedOffBy); assertThat(project.<START_MOD>getBooleanConfig(BooleanProjectConfig.USE_CONTENT_MERGE<END_MOD>)).isEqualTo(in.useContentMerge); assertThat(project.<START_MOD>getBooleanConfig(BooleanProjectConfig.REQUIRE_CHANGE_ID<END_MOD>)).isEqualTo(in.requireChangeId); }
<START_MOD>private java.util.Set<java.util.Map.Entry<java.lang.String, com.google.gerrit.server.schema.Schema_154.AccountSetter>> getFields(com.google.gerrit.reviewdb.server.ReviewDb db) throws java.sql.SQLException { com.google.gwtorm.jdbc.JdbcSchema schema = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); java.sql.Connection connection = schema.getConnection(); java.util.Set<java.lang.String> columns = schema.getDialect().listColumns(connection, com.google.gerrit.server.schema.Schema_154.TABLE); return com.google.gerrit.server.schema.Schema_154.ACCOUNT_FIELDS_MAP.entrySet().stream().filter(( e) -> columns.contains(e.getKey())).collect(java.util.stream.Collectors.toSet()); }<END_MOD>
private java.util.Set<com.google.gerrit.reviewdb.client.Account> scanAccounts(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.ProgressMonitor pm) throws java.sql.SQLException { <START_MOD>java.util.Set<java.util.Map.Entry<java.lang.String, com.google.gerrit.server.schema.Schema_154.AccountSetter>> fields = getFields(db); if (fields.isEmpty()) { return java.util.Collections.emptySet(); } java.lang.String query = fields.stream().map(( f) -> f.getKey()).collect(java.util.stream.Collectors.joining(     account_id, registered_on,   java.lang.String.format( FROM %s com.google.gerrit.server.schema.Schema_154.TABLE))); <END_MOD>try (java.sql.Statement stmt = newStatement(db);java.sql.ResultSet rs = stmt.executeQuery(<START_MOD>query))<END_MOD> { java.util.Set<com.google.gerrit.reviewdb.client.Account> s = new java.util.HashSet<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)), rs.getTimestamp(2)); <START_MOD>for (java.util.Map.Entry<java.lang.String, com.google.gerrit.server.schema.Schema_154.AccountSetter> field : fields) { field.getValue().set(<END_MOD>a<START_MOD>, <END_MOD>rs<START_MOD>, field.getKey()); } s.add(<END_MOD>a<START_MOD>); pm.update(1); } return<END_MOD> s; } }
<START_MOD>protected boolean isRest(javax.servlet.ServletRequest req) { return resturi.matcher(getURI(req)).matches(); }<END_MOD>
<START_MOD>public synchronized boolean inGracePeriod() { if ((gracepermits) < 0) { gracepermits = 0; } return ((gracepermits)--) > 0; }<END_MOD>
<START_MOD>private final com.googlesource.gerrit.plugins.quota.Module.Holder createWithBurstyRateLimiter(com.google.gerrit.reviewdb.client.Account.Id key) throws java.lang.Exception { return createWithBurstyRateLimiter(finder.firstMatching(limitsConfigType, userFactory.create(key))); }<END_MOD>
<START_MOD>@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.httpd.AllRequestFilter.class).to(com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnforcer.class); cache(com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_RESTAPI_ACCOUNTID, Account.Id.class, .class).loader(com.googlesource.gerrit.plugins.quota.HttpModule.RestApiLoaderAccountId.class); cache(com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_RESTAPI_REMOTEHOST, java.lang.String.class, .class).loader(com.googlesource.gerrit.plugins.quota.HttpModule.RestApiLoaderRemoteHost.class); bindConstant().annotatedWith(com.google.inject.name.Names.named(RateMsgHelper.RESTAPI_CONFIGURABLE_MSG_ANNOTATION)).to(RESTAPI_LIMIT_EXCEEDED_MSG); }<END_MOD>
<START_MOD>@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if (isRest(req)) { com.googlesource.gerrit.plugins.quota.Module.Holder rateLimiterHolder = null; com.google.gerrit.server.CurrentUser u = user.get(); com.google.gerrit.reviewdb.client.Account.Id accountId = null; if (u.isIdentifiedUser()) { accountId = u.asIdentifiedUser().getAccountId(); try { rateLimiterHolder = limitsPerAccount.get(accountId); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.text.MessageFormat.format("Cannot get rate limits for account ''{}''", accountId); com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnforcer.log.warn(msg, e); } } else { try { rateLimiterHolder = limitsPerRemoteHost.get(req.getRemoteHost()); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.text.MessageFormat.format("Cannot get rate limits for anonymous access from remote host ''{0}''", req.getRemoteHost()); com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnforcer.log.warn(msg, e); } } if (((!(rateLimiterHolder.inGracePeriod())) && ((rateLimiterHolder.get()) != null)) && (!(rateLimiterHolder.get().tryAcquire()))) { java.lang.String msg = java.text.MessageFormat.format(limitExceededMsg, ((rateLimiterHolder.get().getRate()) * (com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnforcer.SECONDS_PER_HOUR)), rateLimiterHolder.getBurst()); ((javax.servlet.http.HttpServletResponse) (res)).sendError(com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnforcer.SC_TOO_MANY_REQUESTS, msg); return; } } chain.doFilter(req, res); }<END_MOD>
<START_MOD>private<END_MOD> <START_MOD>final<END_MOD> com.googlesource.gerrit.plugins.quota.Module.Holder <START_MOD>createWithBurstyRateLimiter<END_MOD>(com.google.common.base.Optional<com.googlesource.gerrit.plugins.quota.AccountLimitsConfig.RateLimit> limit<START_MOD>)<END_MOD> <START_MOD>throws<END_MOD> <START_MOD>java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Exception<END_MOD> <START_MOD>{<END_MOD> if (limit.isPresent()) { return com.googlesource.gerrit.plugins.quota.Module.Holder.createWithBurstyRateLimiter(limit); } return com.googlesource.gerrit.plugins.quota.Module.Holder.EMPTY; }
<START_MOD>@java.lang.Override public final com.googlesource.gerrit.plugins.quota.Module.Holder load(Key key) throws java.lang.Exception { if (((kind) == (com.googlesource.gerrit.plugins.quota.Module.AbstractHolderCacheLoader.LoaderType.ANONYMOUS)) && (key instanceof java.lang.String)) { return createWithBurstyRateLimiter(); } if (((kind) == (com.googlesource.gerrit.plugins.quota.Module.AbstractHolderCacheLoader.LoaderType.ACCOUNTID)) && (key instanceof com.google.gerrit.reviewdb.client.Account.Id)) { return createWithBurstyRateLimiter(((com.google.gerrit.reviewdb.client.Account.Id) (key))); } return com.googlesource.gerrit.plugins.quota.Module.Holder.EMPTY; }<END_MOD>
public <T> T execute(com.google.gerrit.server.update.Action<<START_MOD>com.google.gerrit.server.update.BatchUpdate.Factory, <END_MOD>T> action) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return execute(action, defaults()); }
<START_MOD>@java.lang.Override<END_MOD> <START_MOD>protected<END_MOD> boolean <START_MOD>retryOn<END_MOD>(java.lang.Throwable t) { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } return t instanceof com.google.gerrit.server.git.LockFailureException; }
public <T> T execute(com.google.gerrit.server.update.Action<<START_MOD>com.google.gerrit.server.update.BatchUpdate.Factory, <END_MOD>T> action, com.google.gerrit.server.update.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { <START_MOD>if (!(migration.disableChangeReviewDb())) { return doExecute(updateFactory, action, <END_MOD>com.github.rholder.retry.RetryerBuilder<START_MOD>.<END_MOD><T>newBuilder()<START_MOD>.build()); } return doExecute(updateFactory, action, opts); } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.extensions.restapi.RestApiException.class); throw<END_MOD> new com.google.gerrit.server.update.UpdateException<START_MOD>(t); } }<END_MOD>
private com.google.gerrit.server.account.externalids.ExternalIdsUpdate.RefsMetaExternalIdsUpdate updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { <START_MOD>return retryHelper.execute(updater, ( i) -> { <END_MOD>try <START_MOD>(org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName);org.eclipse.jgit.lib.ObjectInserter ins = repo.newObjectInserter()) <END_MOD>{ <START_MOD>org.eclipse.jgit.lib.ObjectId rev = readRevision(repo); afterReadRevision.run(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = readNoteMap(rw, rev); com.google.gerrit.server.account.externalids.UpdatedExternalIds updatedExtIds = i.update(com.google.gerrit.server.account.externalids.OpenRepo.create(repo, rw, ins, noteMap)); <END_MOD>return <START_MOD>commit(repo, rw,<END_MOD> ins<START_MOD>,<END_MOD> rev<START_MOD>,<END_MOD> noteMap<START_MOD>,<END_MOD> updatedExtIds); } } }); }
<START_MOD>public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> recursiveChildProjects(com.google.gerrit.reviewdb.client.Project.NameKey parent) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project> projects = readAllProjects(); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project.NameKey> children = parentToChildren(projects); com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(user); java.util.List<com.google.gerrit.extensions.common.ProjectInfo> results = new java.util.ArrayList<>(); depthFirstFormat(results, perm, projects, children, parent); return results; }<END_MOD>
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return <START_MOD>childProjectLister.<END_MOD>recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, <START_MOD>childProjectLister<END_MOD>, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData> parentproject(java.lang.String name) { return new com.google.gerrit.server.query.change.ParentProjectPredicate(args.projectCache, args.<START_MOD>childProjectLister<END_MOD>, args.self, name); }
<START_MOD>public boolean isReachableFrom(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { refs = refFilter.create(state, repo).filter(refs, true); return com.google.gerrit.server.change.IncludedInResolver.includedInAny(repo, rw, commit, refs.values()); } catch (java.io.IOException e) { com.google.gerrit.server.project.Reachable.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getNameKey()), e); return false; } }<END_MOD>
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((( look up change for commit   + (commit.name())) +   in   + project), e); } return <START_MOD>reachable.<END_MOD>isReachableFrom(state, repo, commit, repo.getAllRefs()); }
boolean isReachableFromHeadsOrTags(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.RefDatabase refdb = repo.getRefDatabase(); java.util.Collection<org.eclipse.jgit.lib.Ref> heads = refdb.getRefs(Constants.R_HEADS).values(); java.util.Collection<org.eclipse.jgit.lib.Ref> tags = refdb.getRefs(Constants.R_TAGS).values(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Maps.newHashMapWithExpectedSize(((heads.size()) + (tags.size()))); for (org.eclipse.jgit.lib.Ref r : com.google.common.collect.Iterables.concat(heads, tags)) { refs.put(r.getName(), r); } return <START_MOD>reachable<END_MOD>.isReachableFrom(state, repo, commit, refs); } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(java.lang.String.format( verify permissions to commit object %s in repository %s commit.name(), getProject().getNameKey()), e); return false; } }
protected static java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.gerrit.server.project.<START_MOD>ChildProjectLister childProjectLister<END_MOD>, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.project.ProjectResource(projectState, self.get()); for (com.google.gerrit.extensions.common.ProjectInfo p : <START_MOD>childProjectLister.recursiveChildProjects<END_MOD>(proj<START_MOD>.getNameKey()<END_MOD>)) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn( check permissions to expand child projects e); } return r; }
<START_MOD>public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.sql.Timestamp when, boolean isPrivate) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.PrivateStateChanged.Event event = new com.google.gerrit.server.extensions.events.PrivateStateChanged.Event(util.changeInfo(change), util.accountInfo(account), isPrivate, when); for (com.google.gerrit.extensions.events.PrivateStateChangedListener l : listeners) { try { l.onPrivateStateChanged(event); } catch (java.lang.Exception e) { util.logEventListenerError(event, l, e); } } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.PrivateStateChanged.log.error("Couldn't fire event", e); } }<END_MOD>
<START_MOD>@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { privateStateChanged.fire(change, ctx.getAccount(), ctx.getWhen(), isPrivate); }<END_MOD>
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canDeletePrivate(rsrc).value())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to unmark private } if (!(rsrc.getChange().isPrivate())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is not private } com.google.gerrit.server.change.SetPrivateOp op = <START_MOD>setPrivateOpFactory.create<END_MOD>(cmUtil, false, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.data.ChangeAttribute asChangeAttribute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.data.ChangeAttribute a = new com.google.gerrit.server.data.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.topic = change.getTopic(); a.id = change.getKey().get(); a.number = change.getId().get(); a.subject = change.getSubject(); try { a.commitMessage = changeDataFactory.create(db, change).commitMessage(); } catch (java.lang.Exception e) { com.google.gerrit.server.events.EventFactory.log.error(( while getting full commit message for change   + (a.number))); } a.url = getChangeUrl(change); a.owner = asAccountAttribute(change.getOwner()); a.assignee = asAccountAttribute(change.getAssignee()); a.status = change.getStatus(); a.createdOn = (change.getCreatedOn().getTime()) / 1000L; <START_MOD>a.isWip = (change.isWorkInProgress()) ? true : null; a.isPrivate = (change.isPrivate()) ? true : null; <END_MOD>return a; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canSetPrivate(rsrc).value())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to mark private } if (rsrc.getChange().isPrivate()) { return com.google.gerrit.extensions.restapi.Response.ok(""); } com.google.gerrit.server.change.SetPrivateOp op = <START_MOD>setPrivateOpFactory.create<END_MOD>(cmUtil, true, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (recursive) { return <START_MOD>groupMembers.<END_MOD>getTransitiveMembers(group, resource.getControl()); } return <START_MOD>groupMembers.<END_MOD>getDirectMembers(group, resource.getControl()); }
private void addInternalDetails(com.google.gerrit.extensions.common.GroupInfo info, com.google.gerrit.common.data.GroupDescription.Internal internalGroup, java.util.function.Supplier<com.google.gerrit.server.account.GroupControl> groupControlSupplier) throws com.google.gwtorm.server.OrmException { info.description = com.google.common.base.Strings.emptyToNull(internalGroup.getDescription()); info.groupId = internalGroup.getId().get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerGroupUUID = internalGroup.getOwnerGroupUUID(); if (ownerGroupUUID != null) { info.ownerId = com.google.gerrit.extensions.restapi.Url.encode(ownerGroupUUID.get()); com.google.gerrit.common.data.GroupDescription.Basic o = groupBackend.get(ownerGroupUUID); if (o != null) { info.owner = o.getName(); } } info.createdOn = internalGroup.getCreatedOn(); if (options.contains(com.google.gerrit.server.group.MEMBERS)) { info.members = <START_MOD>groupMembers<END_MOD>.getDirectMembers(internalGroup, groupControlSupplier.get()); } if (options.contains(com.google.gerrit.server.group.INCLUDES)) { info.includes = listSubgroups.get().getDirectSubgroups(internalGroup, groupControlSupplier.get()); } }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, childProjects, submitDryRun, conflictsCache, index, indexConfig, <START_MOD>groupMembers<END_MOD>, starredChangesUtil, accountCache, allowsDrafts, notesMigration); }
void display(java.io.PrintWriter writer) throws com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(name)); java.lang.String errorText =   not found or not visible if (!(group.isPresent())) { writer.write(errorText); writer.flush(); return; } java.util.List<com.google.gerrit.extensions.common.AccountInfo> members = <START_MOD>groupMembers.<END_MOD>getDirectMembers(group.get()); com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(writer, '\t'); formatter.addColumn("id"); formatter.addColumn("username"); formatter.addColumn( name formatter.addColumn("email"); formatter.nextLine(); for (com.google.gerrit.extensions.common.AccountInfo member : members) { if (member == null) { continue; } formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.username, "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(member.name), "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.email, "n/a")); formatter.nextLine(); } formatter.finish(); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.api.allowedIdentifiers", values = { "PROJECT_NUMERIC_ID", "NUMERIC_ID" }) public void deprecatedChangeIdReturnsBadRequest() throws java.lang.Exception { com.google.gerrit.extensions.api.changes.ChangeApi cApi1 = gApi.changes().id(project.get(), changeInfo._number); assertThat(cApi1.get().changeId).isEqualTo(changeInfo.changeId); com.google.gerrit.extensions.api.changes.ChangeApi cApi2 = gApi.changes().id(changeInfo._number); assertThat(cApi2.get().changeId).isEqualTo(changeInfo.changeId); com.google.gerrit.extensions.common.ChangeInfo ci = gApi.changes().create(new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "different message")).get(); exception.expect(com.google.gerrit.extensions.restapi.DeprecatedIdentifierException.class); exception.expectMessage((("The provided change identifier " + (ci.changeId)) + " is deprecated. Use 'project~changeNumber' instead.")); gApi.changes().id(ci.changeId); }<END_MOD>
<START_MOD>private void checkIdType(com.google.gerrit.server.ChangeFinder.ChangeIdType type, boolean enforceDeprecation, java.lang.String val) throws com.google.gerrit.extensions.restapi.DeprecatedIdentifierException { if (enforceDeprecation && (!(allowedIdTypes.contains(type)))) { throw new com.google.gerrit.extensions.restapi.DeprecatedIdentifierException(java.lang.String.format(("The provided change identifier %s is deprecated. " + "Use 'project~changeNumber' instead."), val)); } changeIdCounter.increment(type); }<END_MOD>
public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { <START_MOD>try<END_MOD> { return <START_MOD>find<END_MOD>(<START_MOD>id, false<END_MOD>); } <START_MOD>catch<END_MOD> (com.google.gerrit.<START_MOD>extensions<END_MOD>.<START_MOD>restapi<END_MOD>.<START_MOD>DeprecatedIdentifierException<END_MOD> <START_MOD>e<END_MOD>) { return com.google.<START_MOD>common<END_MOD>.<START_MOD>collect<END_MOD>.<START_MOD>ImmutableList<END_MOD>.<START_MOD>of<END_MOD>(); } }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Star parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws<START_MOD> com.google.gerrit.extensions.restapi.DeprecatedIdentifierException,<END_MOD> com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); java.util.Set<java.lang.String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId()); return new com.google.gerrit.server.account.AccountResource.Star(user, change, labels); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>DeprecatedIdentifierException, com.google.gerrit.extensions.restapi.<END_MOD>UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( %s not found id.get())); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error( resolve change e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( server error } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>DeprecatedIdentifierException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded()<START_MOD>, true<END_MOD>); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
@java.lang.Override public AccountResource.StarredChange parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>DeprecatedIdentifierException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) { return new com.google.gerrit.server.account.AccountResource.StarredChange(user, change); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
<START_MOD>public void delete(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extId); removedExtIds.add(extId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); }); }<END_MOD>
private void addExtId(org.eclipse.jgit.junit.TestRepository<?> testRepo, com.google.gerrit.server.account.externalids.ExternalId... extIds) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { <START_MOD>com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes<END_MOD> = <START_MOD>externalIdNotesFactory.load<END_MOD>(testRepo.getRepository()); <START_MOD>extIdNotes.insert(java.util.Arrays.asList(extIds)); <END_MOD>try (<START_MOD>com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate<END_MOD> = <START_MOD>new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, null, <END_MOD>testRepo.getRepository())) { <START_MOD>metaDataUpdate.getCommitBuilder().setAuthor(admin.getIdent()); metaDataUpdate.getCommitBuilder().setCommitter(admin.getIdent()); extIdNotes.commit(metaDataUpdate<END_MOD>); } }
@org.junit.Test public void retryOnLockFailure() throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId.Key fooId = ExternalId.Key.create("foo", "foo"); com.google.gerrit.server.account.externalids.ExternalId.Key barId = ExternalId.Key.create("bar", "bar"); final java.util.concurrent.atomic.AtomicBoolean doneBgUpdate = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.server.account.externalids.ExternalIdsUpdate update = new com.google.gerrit.server.account.externalids.ExternalIdsUpdate(repoManager, <START_MOD>() -> com.google.gerrit.acceptance.rest.account.metaDataUpdateFactory.create(com.google.gerrit.acceptance.rest.account.allUsers), <END_MOD>accountCache, allUsers, metricMaker, externalIds, new com.google.gerrit.server.account.externalids.DisabledExternalIdCache(), new com.google.gerrit.server.update.RetryHelper(cfg, retryMetrics, null, null, null, ( r) -> r.withBlockStrategy(new com.github.rholder.retry.BlockStrategy() { @java.lang.Override public void block(long sleepTime) { } })), () -> { if (!(doneBgUpdate.getAndSet(true))) { try { extIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.create(barId, admin.id)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException | com.google.gwtorm.server.OrmException e) { } } }); assertThat(doneBgUpdate.get()).isFalse(); update.insert(com.google.gerrit.server.account.externalids.ExternalId.create(fooId, admin.id)); assertThat(doneBgUpdate.get()).isTrue(); assertThat(externalIds.get(fooId)).isNotNull(); assertThat(externalIds.get(barId)).isNotNull(); }
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.<START_MOD>ExternalIdNotes<END_MOD>.<START_MOD>loadReadOnly(repo).get<END_MOD>(key); } }
private <START_MOD>void updateNoteMap(<END_MOD>com.google.gerrit.server.account.externalids.ExternalIdsUpdate.<START_MOD>ExternalIdUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { retryHelper.<<END_MOD>com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdater<START_MOD>, java.lang.Object>execute(<END_MOD>updater<START_MOD>, ( i) -> { try (<END_MOD>org.eclipse.jgit.<START_MOD>lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes = new com.google.gerrit.server.account.externalids.ExternalIdNotes(externalIdCache, accountCache, repo).setAfterReadRevision(afterReadRevision).load(); i.update(extIdNotes); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create()) { extIdNotes.commit(metaDataUpdate); } updateCount.increment();<END_MOD> return <START_MOD>null; } }); }<END_MOD>
<START_MOD>public void upsert(com.google.gerrit.server.account.externalids.ExternalId extId) { upsert(java.util.Collections.singleton(extId)); }<END_MOD>
<START_MOD>public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all() throws java.io.IOException { checkLoaded(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = com.google.gerrit.server.account.externalids.ExternalIdNotes.readNoteData(rw, note.getData()); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw, note.getData())); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIdNotes.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; } }<END_MOD>
<START_MOD>private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); checkState(extId.equals(actualExtId), "external id %s should be removed, but it's not matching the actual external id %s", extId.toString(), actualExtId.toString()); noteMap.remove(noteId); return actualExtId; }<END_MOD>
<START_MOD>public void delete(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extIdKey, accountId); removedExtIds.add(removedExtId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); }); }<END_MOD>
<START_MOD>public void replace(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkLoaded(); com.google.gerrit.server.account.externalids.ExternalIdNotes.checkSameAccount(toAdd, accountId); checkExternalIdKeysDontExist(ExternalId.Key.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : toDelete) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extIdKey, accountId); removedExtIds.add(removedExtId); } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { com.google.gerrit.server.account.externalids.ExternalId insertedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.upsert(rw, inserter, noteMap, extId); updatedExtIds.add(insertedExtId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onReplace(o, n, accountId, removedExtIds, updatedExtIds); evictAccount(accountId); }); }<END_MOD>
<START_MOD>public void deleteByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extIdKey, null); removedExtIds.add(extId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); }); }<END_MOD>
<START_MOD>@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (readOnly) { throw new java.io.IOException("Updating external IDs is disabled"); } if (noteMapUpdates.isEmpty()) { return false; } if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Update external IDs\n"); } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { for (com.google.gerrit.server.account.externalids.ExternalIdNotes.NoteMapUpdate noteMapUpdate : noteMapUpdates) { try { noteMapUpdate.execute(rw, noteMap); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new java.io.IOException(e); } } org.eclipse.jgit.revwalk.RevTree oldTree = ((revision) != null) ? rw.parseTree(revision) : null; org.eclipse.jgit.lib.ObjectId newTreeId = noteMap.writeTree(inserter); if (newTreeId.equals(oldTree)) { return false; } commit.setTreeId(newTreeId); return true; } }<END_MOD>
<START_MOD>private void evictAccounts(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws java.io.IOException { if ((accountCache) != null) { for (com.google.gerrit.reviewdb.client.Account.Id id : extIds.stream().map(ExternalId::accountId).collect(java.util.stream.Collectors.toSet())) { accountCache.evict(id); } } }<END_MOD>
<START_MOD>private static com.google.gerrit.server.account.externalids.ExternalId upsert(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); org.eclipse.jgit.lib.Config c = new org.eclipse.jgit.lib.Config(); if (noteMap.contains(extId.key().sha1())) { byte[] raw = rw.getObjectReader().open(noteMap.get(noteId), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); try { c.fromText(new java.lang.String(raw, java.nio.charset.StandardCharsets.UTF_8)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Invalid external id config for note %s: %s", noteId, e.getMessage())); } } extId.writeToConfig(c); byte[] raw = c.toText().getBytes(java.nio.charset.StandardCharsets.UTF_8); org.eclipse.jgit.lib.ObjectId noteData = ins.insert(com.google.gerrit.server.account.externalids.OBJ_BLOB, raw); noteMap.set(noteId, noteData); return com.google.gerrit.server.account.externalids.ExternalId.create(extId, noteData); }<END_MOD>
<START_MOD>public com.google.gerrit.server.account.InternalAccountUpdate.Builder updateExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { updatedExternalIdsBuilder().add(extId); return this; }<END_MOD>
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.<START_MOD>ExternalIdNotes<END_MOD>.<START_MOD>loadReadOnly<END_MOD>(<START_MOD>repo<END_MOD>, rev<START_MOD>).get(key<END_MOD>); } }
<START_MOD>public void upsert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalId updatedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.upsert(rw, inserter, noteMap, extId); updatedExtIds.add(updatedExtId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onUpdate(o, n, updatedExtIds); evictAccounts(updatedExtIds); }); }<END_MOD>
<START_MOD>public void insert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkLoaded(); checkExternalIdsDontExist(extIds); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> newExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalId insertedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.upsert(rw, inserter, noteMap, extId); newExtIds.add(insertedExtId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onCreate(o, n, newExtIds); evictAccounts(newExtIds); }); }<END_MOD>
<START_MOD>public void replaceByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkLoaded(); checkExternalIdKeysDontExist(ExternalId.Key.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : toDelete) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extIdKey, null); removedExtIds.add(removedExtId); } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { com.google.gerrit.server.account.externalids.ExternalId insertedExtId = com.google.gerrit.server.account.externalids.ExternalIdNotes.upsert(rw, inserter, noteMap, extId); updatedExtIds.add(insertedExtId); } }); cacheUpdates.add(( o, n) -> { externalIdCache.onReplace(o, n, removedExtIds, updatedExtIds); evictAccounts(com.google.common.collect.Streams.concat(removedExtIds.stream(), updatedExtIds.stream()).collect(java.util.stream.Collectors.toSet())); }); }<END_MOD>
<START_MOD>public com.google.gerrit.server.account.InternalAccountUpdate.Builder addExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { createdExternalIdsBuilder().add(extId); return this; }<END_MOD>
<START_MOD>public com.google.gerrit.server.account.InternalAccountUpdate.Builder deleteExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { deletedExternalIdsBuilder().add(extId); return this; }<END_MOD>
<START_MOD>@com.google.gerrit.common.Nullable public com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId noteDataId = noteMap.get(noteId); byte[] raw = com.google.gerrit.server.account.externalids.ExternalIdNotes.readNoteData(rw, noteDataId); return com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteDataId); } }<END_MOD>
<START_MOD>public static java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> from(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { return extIds.stream().map(com.google.gerrit.server.account.externalids.ExternalId::key).collect(java.util.stream.Collectors.toSet()); }<END_MOD>
<START_MOD>private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); if (expectedAccountId != null) { checkState(expectedAccountId.equals(extId.accountId()), ("external id %s should be removed for account %s," + " but external id belongs to account %s"), extIdKey.get(), expectedAccountId.get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; }<END_MOD>
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.api.accounts.StatusInput input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.api.accounts.StatusInput(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getStatus()); }
<START_MOD>public static com.google.gerrit.server.account.InternalAccountUpdate.Builder builder() { return new com.google.gerrit.server.account.AutoValue_InternalAccountUpdate.Builder(); }<END_MOD>
private void updateAccountInfo() { if ((setFullNameTo) == null) { return; } logDebug( full name of caller try { com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( <START_MOD>u<END_MOD>) -> { if (com.google.common.base.Strings.isNullOrEmpty(<START_MOD>u.account()<END_MOD>.getFullName())) { <START_MOD>u.update()<END_MOD>.setFullName(setFullNameTo); } }); if (account != null) { user.getAccount().setFullName(account.getFullName()); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { logWarn( to update full name of caller e); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException(((   + (extId.key().get())) +   in use by another account } update(who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { accountsUpdateFactory.create().update(to, ( <START_MOD>u<END_MOD>) -> { if ((<START_MOD>u.account()<END_MOD>.getPreferredEmail()) == null) { <START_MOD>u.update()<END_MOD>.setPreferredEmail(who.getEmailAddress()); } }); } } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public void unlink(com.google.gerrit.reviewdb.client.Account.Id from, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (extIdKeys.isEmpty()) { return; } java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.ArrayList(extIdKeys.size()); for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(extIdKey); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException(((   + (extIdKey.get())) +   in use by another account } extIds.add(extId); } else { throw new com.google.gerrit.server.account.AccountException(((   + (extIdKey.get())) +   not found } } externalIdsUpdateFactory.create().delete(extIds); if (extIds.stream().anyMatch(( e) -> (e.email()) != null)) { accountsUpdateFactory.create().update(from, ( <START_MOD>u<END_MOD>) -> { if ((<START_MOD>u.account()<END_MOD>.getPreferredEmail()) != null) { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if (<START_MOD>u.account()<END_MOD>.getPreferredEmail().equals(extId.email())) { <START_MOD>u.update()<END_MOD>.setPreferredEmail(<START_MOD>""<END_MOD>); break; } } } }); } }
public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( <START_MOD>u<END_MOD>) -> { if (!(<START_MOD>u.account()<END_MOD>.isActive())) { alreadyInactive.set(true); } else { <START_MOD>u.update()<END_MOD>.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( not active } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( <START_MOD>u<END_MOD>) -> { if (<START_MOD>u.account()<END_MOD>.isActive()) { alreadyActive.set(true); } else { <START_MOD>u.update()<END_MOD>.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
@org.junit.Before public void setUpInjector() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = com.google.gerrit.testing.InMemoryModule.newDefaultConfig(); cfg.setInt("receive", null, "maxTrustDepth", 2); cfg.setStringList("receive", null, "trustedKey", com.google.common.collect.ImmutableList.of(com.google.gerrit.gpg.Fingerprint.toString(keyB().getPublicKey().getFingerprint()), com.google.gerrit.gpg.Fingerprint.toString(keyD().getPublicKey().getFingerprint()))); com.google.inject.Injector injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testing.InMemoryModule(cfg, com.google.gerrit.testing.NoteDbMode.newNotesMigrationFromEnv())); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); injector.injectMembers(this); lifecycle.start(); db = schemaFactory.open(); schemaCreator.create(db); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); accountsUpdate.create().update(userId, ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setPreferredEmail("user@example.com")); user = reloadUser(); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getUser() { return user; } @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } }); storeRepo = new org.eclipse.jgit.internal.storage.dfs.InMemoryRepository(new org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription("repo")); store = new com.google.gerrit.gpg.PublicKeyStore(storeRepo); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyPreferred = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( <START_MOD>u<END_MOD>) -> { if (email.equals(<START_MOD>u.account()<END_MOD>.getPreferredEmail())) { alreadyPreferred.set(true); } else { <START_MOD>u.update()<END_MOD>.setPreferredEmail(email); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return alreadyPreferred.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); java.lang.String email = "user@example.com"; externalIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createEmail(userId, email)); accountsUpdate.create().update(userId, ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setPreferredEmail(email)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userId)); }
@org.junit.Test public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws java.lang.Exception { TestAccount foo = accountCreator.create(name("foo"), ((name("foo")) + "@example.com"), "Foo"); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); java.lang.String noEmail = "no.email"; accountsUpdate.create().update(foo.id, ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setPreferredEmail(noEmail)); accountIndexedCounter.clear(); grant(allUsers, userRef, Permission.PUSH, false, com.google.gerrit.acceptance.api.accounts.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, foo); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String status =   vacation org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status); pushFactory.create(db, foo.getIdent(), allUsersRepo,   account config AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus(); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.email).isEqualTo(noEmail); assertThat(info.name).isEqualTo(foo.fullName); assertThat(info.status).isEqualTo(status); }
@org.junit.Test public void updateAccountWithoutAccountConfigNoteDb() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount anonymousCoward = accountCreator.create(); assertUserBranchWithoutAccountConfig(anonymousCoward.getId()); java.lang.String status = "OOO"; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(anonymousCoward.getId(), ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setStatus(status)); assertThat(account).isNotNull(); assertThat(account.getFullName()).isNull(); assertThat(account.getStatus()).isEqualTo(status); assertUserBranch(anonymousCoward.getId(), null, status); }
@org.junit.Test public void lookUpByPreferredEmail() throws java.lang.Exception { java.lang.String prefix = "foo.preferred"; java.lang.String prefEmail = prefix + "@example.com"; com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); accountsUpdate.create().update(foo.id, ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setPreferredEmail(prefEmail)); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail); assertThat(accountsByPrefEmail).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id); accountsByPrefEmail = emails.getAccountFor(prefix); assertThat(accountsByPrefEmail).isEmpty(); accountsByPrefEmail = emails.getAccountFor(prefEmail.toUpperCase(java.util.Locale.US)); assertThat(accountsByPrefEmail).isEmpty(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.common.NameInput input) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.common.NameInput(); } if (!(realm.allowsEdit(AccountFieldName.FULL_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( does not allow editing name } java.lang.String newName = input.name; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setFullName(<START_MOD>com.google.common.base.Strings.nullToEmpty(<END_MOD>newName))<START_MOD>)<END_MOD>; if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException( not found } return com.google.common.base.Strings.isNullOrEmpty(account.getFullName()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getFullName()); }
public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.function.Consumer<com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>account<END_MOD>.<START_MOD>AccountUpdate<END_MOD>> consumer) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return update(accountId, com.google.common.collect.ImmutableList.of(consumer)); }
@com.google.gerrit.common.Nullable public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.List<java.util.function.Consumer<com.google.gerrit.<START_MOD>server.account.AccountUpdate>> consumers) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (consumers.isEmpty()) { return null; } com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); java.util.Optional<com.google.gerrit.<END_MOD>reviewdb.client.Account><START_MOD> account = accountConfig.getLoadedAccount(); if (account.isPresent()) { com.google.gerrit.server.account.AccountUpdate accountUpdate = com.google.gerrit.server.account.AccountUpdate.create(account.get());<END_MOD> consumers<START_MOD>.stream().forEach(( c) -> c.accept(accountUpdate)); accountConfig.setAccountUpdate(accountUpdate.buildUpdate()); commit(accountConfig); }<END_MOD> return <START_MOD>accountConfig.getLoadedAccount().orElse(<END_MOD>null<START_MOD>)<END_MOD>; }
public com.google.gerrit.reviewdb.client.Account insert(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.function.Consumer<com.google.gerrit.<START_MOD>server.account.AccountUpdate<END_MOD>> init) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(); <START_MOD>com.google.gerrit.server.account.AccountUpdate accountUpdate = com.google.gerrit.server.account.AccountUpdate.create(account); <END_MOD>init.accept(<START_MOD>accountUpdate); accountConfig.setAccountUpdate(accountUpdate.buildUpdate()<END_MOD>); commitNew(accountConfig); return <START_MOD>accountConfig.getLoadedAccount().get()<END_MOD>; }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if (<START_MOD>(revision) != null) { commit.setMessage( account } else { commit.setMessage( account commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); commit.setCommitter(new org.eclipse.jgit.lib.PersonIdent(commit.getCommitter(), registeredOn)); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); if (accountUpdate.isPresent()) { com.google.gerrit.server.account.AccountConfig.writeToConfig(accountUpdate.get(), cfg); } saveConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); <END_MOD>loadedAccount<START_MOD> = java.util.Optional.of(parse(cfg, null));<END_MOD> return true; }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.loadedAccount = java.util.Optional.of(account); this.<START_MOD>accountUpdate = java.util.Optional.of(com.google.gerrit.server.account.InternalAccountUpdate.builder().setActive(account.isActive()).setFullName(com.google.common.base.Strings.nullToEmpty(account.getFullName())).setPreferredEmail(com.google.common.base.Strings.nullToEmpty(account.getPreferredEmail())).setStatus(com.google.common.base.Strings.nullToEmpty(account.getStatus())).build()); this.<END_MOD>registeredOn = account.getRegisteredOn(); }
private Account.Id createAccountOutsideRequestContext(java.lang.String username, java.lang.String fullName, java.lang.String email, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email != null) { accountManager.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, ( <START_MOD>u<END_MOD>) -> { <START_MOD>u.update()<END_MOD>.setFullName(<START_MOD>com.google.common.base.Strings.nullToEmpty(<END_MOD>fullName)<START_MOD>)<END_MOD>.setPreferredEmail(<START_MOD>com.google.common.base.Strings.nullToEmpty(email))<END_MOD>.setActive(active); }); return id; } }
@org.junit.Test public void checkMetaId() throws java.lang.Exception { assertThat(accounts.get(admin.getId()).getMetaId()).isEqualTo(getMetaId(admin.getId())); com.google.gerrit.server.account.AccountsUpdate au = accountsUpdate.create(); com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(seq.nextAccountId()); com.google.gerrit.reviewdb.client.Account account = au.insert(accountId, ( <START_MOD>u<END_MOD>) -> { }); assertThat(account.getMetaId()).isEqualTo(getMetaId(accountId)); com.google.gerrit.reviewdb.client.Account updatedAccount = au.update(accountId, ( <START_MOD>u<END_MOD>) -> <START_MOD>u.update()<END_MOD>.setFullName("foo")); assertThat(account.getMetaId()).isNotEqualTo(updatedAccount.getMetaId()); assertThat(updatedAccount.getMetaId()).isEqualTo(getMetaId(accountId)); }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser,   FAILED: input file missing } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } if ((revnumberFile) != null) { try (java.io.BufferedReader reader = <START_MOD>java.nio.file.Files.newBufferedReader<END_MOD>(revnumberFile<START_MOD>.toPath(<END_MOD>))) { revnumber = reader.readLine(); } } if (mktmp) { tmpdir = java.nio.file.Files.createTempDirectory("asciidoctor-").toFile(); } if (bazel) { renderFiles(inputFiles, null); } else { try (java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(java.nio.file.Files.newOutputStream(java.nio.file.Paths.get(zipFile)))) { renderFiles(inputFiles, zip); java.io.File[] cssFiles = tmpdir.listFiles(new java.io.FilenameFilter() { @java.lang.Override public boolean accept(java.io.File dir, java.lang.String name) { return name.endsWith(".css"); } }); for (java.io.File css : cssFiles) { AsciiDoctor.zipFile(css, css.getName(), zip); } } } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { <START_MOD>com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.RetryHelper.defaults(), ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); <END_MOD>try { return <START_MOD>retryerBuilder.build().call(() -> <END_MOD>action<START_MOD>.call()<END_MOD>); } catch (java.<START_MOD>util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { java.<END_MOD>lang.Throwable t<START_MOD> = e; if ((e.getCause()) != null<END_MOD>) { <START_MOD>t = e.getCause(); } <END_MOD>com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private <T> T execute(com.google.gerrit.server.update.RetryHelper.<START_MOD>ChangeAction<END_MOD><T> <START_MOD>changeAction<END_MOD>, com.<START_MOD>github<END_MOD>.<START_MOD>rholder<END_MOD>.<START_MOD>retry<END_MOD>.<START_MOD>Retryer<END_MOD><<START_MOD>T<END_MOD>> <START_MOD>retryer<END_MOD>) throws java.lang.Throwable { <START_MOD>try { return retryer<END_MOD>.<START_MOD>call(() -> changeAction<END_MOD>.<START_MOD>call<END_MOD>(<START_MOD>updateFactory)<END_MOD>); <START_MOD>}<END_MOD> <START_MOD>catch (java.util.concurrent.ExecutionException |<END_MOD> com.github.rholder.retry.<START_MOD>RetryException<END_MOD> <START_MOD>e)<END_MOD> <START_MOD>{<END_MOD> <START_MOD>if <END_MOD>(<START_MOD>e<END_MOD> <START_MOD>instanceof com.github.rholder.retry.RetryException<END_MOD>) <START_MOD>{ metrics<END_MOD>.<START_MOD>timeoutCount.increment<END_MOD>(); } <START_MOD>if ((e.getCause()) != null)<END_MOD> { <START_MOD>throw e<END_MOD>.<START_MOD>getCause<END_MOD>(); } <START_MOD>throw e; <END_MOD>}<START_MOD> }<END_MOD>
<START_MOD>public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.RetryHelper.defaults(), exceptionPredicate); try { return retryerBuilder.build().call(() -> action.call()); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { java.lang.Throwable t = e; if ((e.getCause()) != null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }<END_MOD>
public <T> T execute(com.google.gerrit.server.update.RetryHelper.ChangeAction<T> changeAction, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { if (!(migration.disableChangeReviewDb())) { return execute(changeAction, com.github.rholder.retry.RetryerBuilder.<T>newBuilder().build()); } <START_MOD>com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, ( t) -> { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } <END_MOD>return <START_MOD>t instanceof com.google.gerrit.server.git.LockFailureException; }); retryerBuilder.withRetryListener(listener); return <END_MOD>execute(changeAction<START_MOD>, retryerBuilder.build()); } finally { metrics.attemptCounts.record(listener.getAttemptCount()); } } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t,<END_MOD> com.google.gerrit.server.update.UpdateException<START_MOD>.class);<END_MOD> com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.<START_MOD>extensions.restapi.RestApiException.class); throw new com.google.gerrit.<END_MOD>server.update.UpdateException<START_MOD>(t); } }<END_MOD>
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { <START_MOD>return<END_MOD> <START_MOD>execute<END_MOD>(<START_MOD>action<END_MOD>, ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); }
private void recursivelyExpandGroups(final java.util.Set<java.lang.String> groupDNs, final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema, final javax.naming.directory.DirContext ctx, final java.lang.String groupDN) { if (((groupDNs.add(groupDN)) && ((schema.accountMemberField) != null)) && (schema.accountMemberExpandGroups)) { com.google.common.collect.ImmutableSet<java.lang.String> cachedParentsDNs = parentGroups.getIfPresent(groupDN); if (cachedParentsDNs == null) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> dns = com.google.common.collect.ImmutableSet.builder(); try { final javax.naming.Name compositeGroupName = new javax.naming.CompositeName().add(groupDN); final javax.naming.directory.Attribute in = ctx.getAttributes(compositeGroupName, schema.accountMemberFieldArray).get(schema.accountMemberField); if (in != null) { final javax.naming.NamingEnumeration<?> groups = in.getAll(); try { while (groups.hasMore()) { dns.add(((java.lang.String) (groups.next()))); } } catch (javax.naming.PartialResultException e) { } } } catch (javax.naming.NamingException e) { LdapRealm.log.warn(( not find <START_MOD>account<END_MOD>   + groupDN), e); } cachedParentsDNs = dns.build(); parentGroups.put(groupDN, cachedParentsDNs); } for (java.lang.String dn : cachedParentsDNs) { recursivelyExpandGroups(groupDNs, schema, ctx, dn); } } }
com.google.gerrit.server.api.changes.FileApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FileResource r);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.SubgroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc.getMemberDescription()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.VoteResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.VoteResource parse(com.google.gerrit.server.change.ReviewerResource reviewer, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((reviewer.getRevisionResource()) != null) && (!(reviewer.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( access on non-current patch set } return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.VoteResource(reviewer, id.get()); }
@java.lang.Override public GroupDescription.Basic get(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { if (!(handles(uuid))) { return null; } java.lang.String groupDn = uuid.get().substring(com.google.gerrit.server.auth.ldap.Helper.LDAP_UUID.length()); com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((!(user.isIdentifiedUser())) || (!(membershipsOf(user.asIdentifiedUser()).contains(uuid)))) { try { if (!(existsCache.get(groupDn))) { return null; } } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.auth.ldap.LdapGroupBackend.log.warn(java.lang.String.format( lookup <START_MOD>account<END_MOD> %s in LDAP groupDn), e); return null; } } final java.lang.String name = (com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME) + (com.google.gerrit.server.auth.ldap.LdapGroupBackend.cnFor(groupDn)); return new com.google.gerrit.common.data.GroupDescription.Basic() { @java.lang.Override public AccountGroup.UUID getGroupUUID() { return uuid; } @java.lang.Override public java.lang.String getName() { return name; } @java.lang.Override @com.google.gerrit.common.Nullable public java.lang.String getEmailAddress() { return null; } @java.lang.Override @com.google.gerrit.common.Nullable public java.lang.String getUrl() { return null; } }; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { com.google.gerrit.extensions.common.SetDashboardInput in = new com.google.gerrit.extensions.common.SetDashboardInput(); in.commitMessage = (input != null) ? input.commitMessage : null; return defaultSetter.get().apply(resource, in); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@org.junit.Test public void updateGroupNamesWithEmptyCollectionClearsAllNotes() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(); updateGroupNames(ident, g1, g2); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2"); updateGroupNames(ident); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).isEmpty(); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(2); assertThat(log.get(1)).message().isEqualTo(   <START_MOD>account<END_MOD> names }
@org.junit.Test public void emptyGroupName() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g = newGroup(""); updateGroupNames(com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(), g); assertThat(com.google.gerrit.server.group.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("", "-1"); assertThat(readNameNote(g)).isEqualTo( = -1 =   }
@org.junit.Test public void updateGroupNames() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = com.google.gerrit.server.group.db.GroupNameNotesTest.newPersonIdent(); updateGroupNames(ident, g1, g2); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(1); assertThat(log.get(0)).parents().isEmpty(); assertThat(log.get(0)).message().isEqualTo( 2 <START_MOD>account names assertThat(log.get(0)).author().matches(ident); assertThat(log.get(0)).committer().matches(ident); assertThat(com.google.gerrit.server.<END_MOD>group<START_MOD>.db.testing.GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2"); java.lang.String commit = log.get(0).commit; updateGroupNames<END_MOD>(com.google.gerrit.server.group.db.<START_MOD>GroupNameNotesTest.newPersonIdent(), g1, g2); log = log(); assertThat(log).hasSize(1); assertThat(log.get(0)).<END_MOD>commit<START_MOD>().isEqualTo(<END_MOD>commit); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MemberResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.PutMember create(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.PutMember(put, id.get()); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MemberResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal group = parent.asInternalGroup().orElseThrow(MethodNotAllowedException::new); com.google.gerrit.server.IdentifiedUser user = accounts.parse(TopLevelResource.INSTANCE, id).getUser(); if ((parent.getControl().canSeeMember(user.getAccountId())) && (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MembersCollection.isMember(group, user))) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MemberResource(parent, user); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource> list() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { return list.get(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FixResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.FixResource parse(com.google.gerrit.server.change.RevisionResource revisionResource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String fixId = id.get(); com.google.gerrit.server.notedb.ChangeNotes changeNotes = revisionResource.getNotes(); java.util.List<com.google.gerrit.reviewdb.client.RobotComment> robotComments = commentsUtil.robotCommentsByPatchSet(changeNotes, revisionResource.getPatchSet().getId()); for (com.google.gerrit.reviewdb.client.RobotComment robotComment : robotComments) { for (com.google.gerrit.reviewdb.client.FixSuggestion fixSuggestion : robotComment.fixSuggestions) { if (java.util.Objects.equals(fixId, fixSuggestion.fixId)) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FixResource(revisionResource, fixSuggestion.replacements); } } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.ChangeResource req, TopicInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); if (((input != null) && ((input.topic) != null)) && ((input.topic.length()) > (com.google.gerrit.server.ChangeUtil.TOPIC_MAX_LENGTH))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( length exceeds the limit (%s) ChangeUtil.TOPIC_MAX_LENGTH)); } com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PutTopic.Op op = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PutTopic.Op((input != null ? input : new TopicInput())); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(op.newTopicName); }
@org.junit.Test public void byLabelGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); createAccount("user2"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testing.InMemoryRepositoryManager.Repo> repo = createProject("repo"); java.lang.String g1 = createGroup("group1", "Administrators"); java.lang.String g2 = createGroup("group2", "Administrators"); gApi.groups().id(g1).addMembers("user1"); gApi.groups().id(g2).addMembers("user2"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo), user1); requestContext.setContext(newRequestContext(user1)); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput().label("Code-Review", 1)); requestContext.setContext(newRequestContext(userId)); assertQuery("label:Code-Review=+1,group1", change1); assertQuery(<START_MOD>"label:Code-Review=+1,account=group1"<END_MOD>, change1); assertQuery("label:Code-Review=+1,user=user1", change1); assertQuery("label:Code-Review=+1,user=user2"); assertQuery(<START_MOD>"label:Code-Review=+1,account=group2"<END_MOD>); }
@org.junit.Test public void submitRecords() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testing.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); gApi.changes().id(change1.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); requestContext.setContext(newRequestContext(user1)); gApi.changes().id(change2.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); requestContext.setContext(newRequestContext(user.getAccountId())); assertQuery("is:submittable", change1); assertQuery("-is:submittable", change2); assertQuery("submittable:ok", change1); assertQuery("submittable:not_ready", change2); assertQuery("label:CodE-RevieW=ok", change1); assertQuery("label:CodE-RevieW=ok,user=user", change1); assertQuery("label:CodE-RevieW=ok,Administrators", change1); assertQuery(<START_MOD>"label:CodE-RevieW=ok,account=Administrators"<END_MOD>, change1); assertQuery("label:CodE-RevieW=ok,owner", change1); assertQuery("label:CodE-RevieW=ok,user1"); assertQuery("label:CodE-RevieW=need", change2); assertQuery("label:CodE-RevieW=need,user1"); assertQuery("label:CodE-RevieW=need,user"); }
@java.lang.Override public com.google.gerrit.extensions.common.CommitInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.CommitResource rsrc) throws java.io.IOException { return com.google.gerrit.server.git.CommitUtil.toCommitInfo(rsrc.getCommit()); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CreateTag create(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString name) { return createTagFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource, com.google.gerrit.extensions.api.groups.GroupInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( already exists }
public static java.lang.String describe(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { return user.getAccountId().toString(); } if (user instanceof com.google.gerrit.server.query.change.SingleGroupUser) { return <START_MOD>"account:"<END_MOD> + (user.getEffectiveGroups().getKnownGroups().iterator().next().toString()); } return user.toString(); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.MemberResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.AccountLoader loader = infoFactory.create(true); com.google.gerrit.extensions.common.AccountInfo info = loader.get(rsrc.getMember().getAccountId()); loader.fill(); return info; }
private java.lang.String getGroupName(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { return groupCache.get(groupId).map(InternalGroup::getName).orElse(( <START_MOD>account<END_MOD>   + groupId)); }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById m : values) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = m.getIncludeUUID(); java.lang.String groupName = groupBackend.get(groupUuid).getName(); com.google.gerrit.reviewdb.client.AccountGroup.Id targetGroupId = m.getGroupId(); java.lang.String targetGroupName = getGroupName(targetGroupId); descriptions.add(java.text.MessageFormat.format( {0}/{1}, <START_MOD>account<END_MOD> {2}/{3} groupUuid, groupName, targetGroupId, targetGroupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, removedOn); audit.removedLegacy(); auditInserts.add(audit); } } db.accountGroupMembersAudit().update(auditUpdates); db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts( log delete accounts from <START_MOD>account<END_MOD> event performed by user me, removed, e); } }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, addedOn); auditInserts.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts( log add accounts to <START_MOD>account<END_MOD> event performed by user me, added, e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } } db.accountGroupByIdAud().update(auditUpdates); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups( log delete groups from <START_MOD>account<END_MOD> event performed by user me, removed, e); } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel( Topic }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, addedOn); includesAudit.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups( log add groups to <START_MOD>account<END_MOD> event performed by user me, added, e); } }
public static void logFailToLoadFromGroupRefAsWarning(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblem(warning( with UUID %s from <START_MOD>account<END_MOD> name notes failed to load from <START_MOD>account<END_MOD> ref uuid)); }
@com.google.common.annotations.VisibleForTesting static java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkWithGroupNameNotes(org.eclipse.jgit.lib.Repository allUsersRepo, java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException { try { java.util.Optional<com.google.gerrit.common.data.GroupReference> groupRef = com.google.gerrit.server.group.db.GroupNameNotes.loadOneGroupReference(allUsersRepo, groupName); if (!(groupRef.isPresent())) { return com.google.common.collect.ImmutableList.of(warning( with name '%s' doesn exist in the list of all names groupName)); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = groupRef.get().getUUID(); java.lang.String name = groupRef.get().getName(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); if (!(java.util.Objects.equals(groupUUID, uuid))) { problems.add(warning( with name '%s' has UUID '%s' in <START_MOD>'account.config'<END_MOD> but '%s' in <START_MOD>account<END_MOD> name notes groupName, groupUUID, uuid)); } if (!(java.util.Objects.equals(groupName, name))) { problems.add(warning( note of name '%s' claims to represent name of '%s' groupName, name)); } return problems; } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { return com.google.common.collect.ImmutableList.of(warning( to check consistency with <START_MOD>account<END_MOD> name notes: %s e.getMessage())); } }
private void readGroups(org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs, com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.Result result) throws java.io.IOException { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : refs.entrySet()) { if (!(entry.getKey().startsWith(RefNames.REFS_GROUPS))) { continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey()); if (uuid == null) { result.problems.add(error( UUID from %s entry.getKey())); continue; } try { com.google.gerrit.server.group.db.GroupConfig cfg = com.google.gerrit.server.group.db.GroupConfig.loadForGroupSnapshot(repo, uuid, entry.getValue().getObjectId()); result.uuidToGroupMap.put(uuid, cfg.getLoadedGroup().get()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { result.problems.add(error( %s does not parse: %s uuid, e.getMessage())); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ParentInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return apply(rsrc, input, true); }
public void validateParentUpdate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser user, java.lang.String newParent, boolean checkIfAdmin) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException { if (checkIfAdmin) { permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); } if ((project.equals(allUsers)) && (!(allProjects.get().equals(newParent)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format( must inherit from %s allUsers.get(), allProjects.get())); } if (project.equals(allProjects)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( set parent of   + (allProjects.get()))); } newParent = com.google.common.base.Strings.emptyToNull(newParent); if (newParent != null) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectState parent = cache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newParent)); if (parent == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException((( project   + newParent) +   not found } if (parent.getName().equals(project.get())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( set parent to self } if (com.google.common.collect.Iterables.tryFind(parent.tree(), ( p) -> { return p.getNameKey().equals(project); }).isPresent()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((( exists between   + (project.get())) +   and   + (parent.getName()))); } } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.TagResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.TagResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.TagResource(rsrc.getProjectState(), rsrc.getUser(), list.get().get(rsrc, id)); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AgreementInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( agreements disabled } if (!(self.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to get contributor agreements } com.google.gerrit.server.IdentifiedUser user = self.get().asIdentifiedUser(); if (user != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to get contributor agreements } java.util.List<com.google.gerrit.extensions.common.AgreementInfo> results = new java.util.ArrayList<>(); java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> cas = projectCache.getAllProjects().getConfig().getContributorAgreements(); for (com.google.gerrit.common.data.ContributorAgreement ca : cas) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupIds = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.PermissionRule rule : ca.getAccepted()) { if (((rule.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW)) && ((rule.getGroup()) != null)) { if ((rule.getGroup().getUUID()) != null) { groupIds.add(rule.getGroup().getUUID()); } else { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>account.GetAgreements.log.warn((((((   + (rule.getGroup().getName())) +   does not   +   referenced in CLA   + (ca.getName())) + "\"")); } } } if (user.getEffectiveGroups().containsAnyOf(groupIds)) { results.add(agreementJson.format(ca)); } } return results; }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.get(accountId).getUserName(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format( {0}/{1}, <START_MOD>account<END_MOD> {2}/{3} accountId, userName, groupId, groupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.access.AccessCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.<START_MOD>restapi.<END_MOD>access.AccessResource.ACCESS_KIND); }
private void testCannotCreateGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, Permission.CREATE); grant(allUsers, refPattern, Permission.PUSH); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo).to(groupRef); r.assertErrorStatus(); assertThat(r.getMessage()).contains( allowed to create <START_MOD>account<END_MOD> branch. try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNull(); } }
private static <T> com.google.common.collect.ImmutableSet<T> logIfNotUnique(com.google.gerrit.server.group.db.GroupBundle.Source source, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.Iterable<T> iterable, java.util.Comparator<T> comparator, java.lang.Class<T> clazz) { java.util.List<T> list = com.google.common.collect.Streams.stream(iterable).sorted(comparator).collect(java.util.stream.Collectors.toList()); com.google.common.collect.ImmutableSet<T> set = com.google.common.collect.ImmutableSet.copyOf(list); if ((set.size()) != (list.size())) { com.google.gerrit.server.group.db.GroupBundle.log.warn( {} in {} has duplicate {} entities: {} uuid, source, clazz.getSimpleName(), iterable); } return set; }
public static void updateGroupFile(org.eclipse.jgit.lib.Repository allUsersRepo, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String refName, java.lang.String fileName, java.lang.String contents) throws java.lang.Exception { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo)) { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.lib.Repository> testRepository = new org.eclipse.jgit.junit.TestRepository(allUsersRepo, rw); TestRepository<Repository>.CommitBuilder builder = testRepository.branch(refName).commit().add(fileName, contents).message( <START_MOD>account<END_MOD> file org.eclipse.jgit.lib.Ref ref = allUsersRepo.exactRef(refName); if (ref != null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); if (c != null) { builder.parent(c); } } builder.create(); } }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc) { return json.format(rsrc.getProjectState()); }
com.google.gerrit.server.api.projects.BranchApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project, java.lang.String ref);
private com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return branches.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult file(java.lang.String path) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.FileResource resource = filesCollection.parse(resource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); return getContent.apply(resource); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( retrieve file e); } }
@org.junit.Test public void groupNameNoteHasDifferentUUID() throws java.lang.Exception { updateGroupNamesRef("g-1",   = uuid-2 = g-1 java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning(( with name 'g-1' has UUID 'uuid-1' in <START_MOD>'account.config'<END_MOD> but 'uuid-2' in <START_MOD>account<END_MOD>   +   notes }
@org.junit.Test public void groupNameNoteIsConsistent() throws java.lang.Exception { updateGroupNamesRef("g-1",   = uuid-1 = g-1 java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).isEmpty(); }
@org.junit.Test public void groupNameNoteFailToParse() throws java.lang.Exception { updateGroupNamesRef("g-1", "[invalid"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning( to check consistency with <START_MOD>account<END_MOD> name notes: Unexpected end of config file }
@org.junit.Test public void groupNameNoteIsMissing() throws java.lang.Exception { updateGroupNamesRef("g-2",   = uuid-2 = g-2 java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning( with name 'g-1' doesn exist in the list of all names }
@org.junit.Test public void groupNameNoteHasDifferentName() throws java.lang.Exception { updateGroupNamesRef("g-1",   = uuid-1 = g-2 java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning( note of name 'g-1' claims to represent name of 'g-2' }
@org.junit.Test public void groupNameNoteHasDifferentNameAndUUID() throws java.lang.Exception { updateGroupNamesRef("g-1",   = uuid-2 = g-2 java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning(( with name 'g-1' has UUID 'uuid-1' in <START_MOD>'account.config'<END_MOD> but 'uuid-2' in <START_MOD>account<END_MOD>   +   notes warning( note of name 'g-1' claims to represent name of 'g-2' }
com.google.gerrit.server.api.projects.ChildProjectApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ChildProjectResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project, DeleteTagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.tags) == null)) || (input.tags.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be specified } deleteRefFactory.create(project).refs(input.tags).prefix(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.R_TAGS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static void logInvalid(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, org.eclipse.jgit.revwalk.RevCommit c, org.eclipse.jgit.revwalk.FooterLine line) { com.google.gerrit.server.group.db.AuditLogReader.log.debug( footer line in commit {} while parsing audit log for <START_MOD>account<END_MOD> {}: {} c.name(), uuid, line); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ChildProjectResource parse(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc, BanCommitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.BanResultInfo r = new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getNameKey(), rsrc.getUser(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } return r; }
private GroupBundle.Builder newBundle() { com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.Id(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(<START_MOD>"account-1"<END_MOD>), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.Account.Id(1000), group.getId())); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(member, new com.google.gerrit.reviewdb.client.Account.Id(2000), ts); com.google.gerrit.reviewdb.client.AccountGroupById byId = new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup"))); com.google.gerrit.reviewdb.client.AccountGroupByIdAud byIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(byId, new com.google.gerrit.reviewdb.client.Account.Id(3000), ts); return com.google.gerrit.server.group.db.GroupBundle.builder().group(group).members(member).memberAudit(memberAudit).byId(byId).byIdAudit(byIdAudit); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.global:Anonymous-Users.name", value =   Users public void createGroupWithDefaultNameOfSystemGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage( name   Users is reserved gApi.groups().create( users }
com.google.gerrit.server.api.changes.RobotCommentApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.RobotCommentResource c);
private com.google.gerrit.extensions.common.AuthInfo getAuthInfo(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.config.AuthConfig cfg, com.google.gerrit.server.account.Realm realm) { com.google.gerrit.extensions.common.AuthInfo info = new com.google.gerrit.extensions.common.AuthInfo(); info.authType = cfg.getAuthType(); info.useContributorAgreements = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.isUseContributorAgreements()); info.editableAccountFields = new java.util.ArrayList(realm.getEditableFields()); info.switchAccountUrl = cfg.getSwitchAccountUrl(); info.gitBasicAuthPolicy = cfg.getGitBasicAuthPolicy(); if ((info.useContributorAgreements) != null) { java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> agreements = projectCache.getAllProjects().getConfig().getContributorAgreements(); if (!(agreements.isEmpty())) { info.contributorAgreements = com.google.common.collect.Lists.newArrayListWithCapacity(agreements.size()); for (com.google.gerrit.common.data.ContributorAgreement agreement : agreements) { info.contributorAgreements.add(agreementJson.format(agreement)); } } } switch (info.authType) { case LDAP : case LDAP_BIND : info.registerUrl = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterText(); info.editFullNameUrl = cfg.getEditFullNameUrl(); break; case CUSTOM_EXTENSION : info.registerUrl = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterText(); info.editFullNameUrl = cfg.getEditFullNameUrl(); info.httpPasswordUrl = cfg.getHttpPasswordUrl(); break; case HTTP : case HTTP_LDAP : info.loginUrl = cfg.getLoginUrl(); info.loginText = cfg.getLoginText(); break; case CLIENT_SSL_CERT_LDAP : case DEVELOPMENT_BECOME_ANY_ACCOUNT : case OAUTH : case OPENID : case OPENID_SSO : break; } return info; }
@org.junit.Test public void pushToGroupBranchForReviewForAllUsersRepoIsRejectedOnSubmit() throws java.lang.Exception { pushToGroupBranchForReviewAndSubmit(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()),   update not allowed }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.global:Anonymous-Users.name", value =   Users public void createGroupWithConfiguredNameOfSystemGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(   Users already exists gApi.groups().create( users }
@org.junit.Test public void createDuplicateSystemGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String newGroupName =   Users exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(   Users already exists gApi.groups().create(newGroupName); }
private void testCannotDeleteGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, Permission.DELETE, true, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains( allowed to delete <START_MOD>account<END_MOD> branch. try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNotNull(); } }
private void pushToGroupBranchForReviewAndSubmit(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRef, java.lang.String expectedError) throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grantLabel("Code-Review", (-2), 2, project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS, false); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.SUBMIT, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRef + ":groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo,   <START_MOD>account<END_MOD> config <START_MOD>"account.config"<END_MOD>,   content + groupRef)); r.assertOkStatus(); assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); if (expectedError != null) { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage( update not allowed } gApi.changes().id(r.getChangeId()).current().submit(); }
@org.junit.Test public void pushToGroupNamesBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); allowGlobalCapabilities(com.google.gerrit.acceptance.api.group.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); assertPushToGroupBranch(allUsers, RefNames.REFS_GROUPNAMES,   update not allowed }
@org.junit.Test public void pushToDeletedGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("foo")).get().id)); createBranch(allUsers, groupRef); assertPushToGroupBranch(allUsers, groupRef,   update not allowed }
@org.junit.Test public void createDuplicateInternalGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String dupGroupName = name("dupGroup"); gApi.groups().create(dupGroupName); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(((   + dupGroupName) +   already exists gApi.groups().create(dupGroupName); }
private void assertPushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRefName, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_DELETED_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_DELETED_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, RefNames.REFS_GROUPNAMES, Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo,   <START_MOD>account<END_MOD> config GroupConfig.GROUP_CONFIG_FILE,   content if (expectedErrorOnUpdate != null) { r.assertErrorStatus(expectedErrorOnUpdate); } else { r.assertOkStatus(); } }
private void assertCreateGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo,   <START_MOD>account<END_MOD> config GroupConfig.GROUP_CONFIG_FILE,   content + (name("bar")))); if (expectedErrorOnCreate != null) { r.assertErrorStatus(expectedErrorOnCreate); } else { r.assertOkStatus(); } }
@org.junit.Test public void onlyVisibleGroupsReturned() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = newGroupName; in.description =   hidden <START_MOD>account<END_MOD> in.visibleToAll = false; in.ownerId = adminGroupUuid().get(); gApi.groups().create(in); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName); setApiUser(admin); gApi.groups().id(newGroupName).addMembers(user.username); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName); }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); assertPushToGroupBranch(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()),   update not allowed }
@org.junit.Test public void groupDescription() throws java.lang.Exception { java.lang.String name = name("group"); gApi.groups().create(name); assertThat(gApi.groups().id(name).description()).isEmpty(); java.lang.String desc =   description for the <START_MOD>account<END_MOD>. gApi.groups().id(name).description(desc); assertThat(gApi.groups().id(name).description()).isEqualTo(desc); gApi.groups().id(name).description(null); assertThat(gApi.groups().id(name).description()).isEmpty(); gApi.groups().id(name).description(""); assertThat(gApi.groups().id(name).description()).isEmpty(); }
@org.junit.Test public void reindexPermissions() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount groupOwner = accountCreator.user2(); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("group"); in.members = java.util.Collections.singleton(groupOwner).stream().map(( u) -> u.id.toString()).collect(java.util.stream.Collectors.toList()); in.visibleToAll = true; com.google.gerrit.extensions.common.GroupInfo group = gApi.groups().create(in).get(); setApiUser(admin); gApi.groups().id(group.id).index(); setApiUser(groupOwner); gApi.groups().id(group.id).index(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage( allowed to index <START_MOD>account<END_MOD> gApi.groups().id(group.id).index(); }
@org.junit.Test public void createDuplicateSystemGroupCaseInsensitiveName_Conflict() throws java.lang.Exception { java.lang.String newGroupName =   users exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(   Users already exists gApi.groups().create(newGroupName); }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE); info.showAssigneeInChangesTable = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)) && hasAssigneeInIndex)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.privateByDefault = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "privateByDefault", false)); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse( and score +   (Shortcut: a) info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply")) + ""; info.updateDelay = ((int) (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>config.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.<START_MOD>git.MergeSuperSet<END_MOD>.wholeTopicEnabled(cfg); return info; }
private com.google.gerrit.extensions.common.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>config.AllProjectsName allProjectsName, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>config.AllUsersName allUsersName) { com.google.gerrit.extensions.common.GerritInfo info = new com.google.gerrit.extensions.common.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugText"); info.docUrl = getDocUrl(cfg); info.docSearch = docSearcher.isAvailable(); info.editGpgKeys = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(((enableSignedPush) && (cfg.getBoolean("gerrit", null, "editGpgKeys", true)))); info.webUis = java.util.EnumSet.noneOf(com.google.gerrit.extensions.client.UiType.class); if (gerritOptions.enableGwtUi()) { info.webUis.add(UiType.GWT); } if (gerritOptions.enablePolyGerrit()) { info.webUis.add(UiType.POLYGERRIT); } return info; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.accounts = getAccountsInfo(accountVisibilityProvider); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.restapi.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.defaultTheme = "/static/" + (SitePaths.THEME_FILENAME); } info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ChildProjectResource>> views() { return views; }
@java.lang.Override public void check() throws com.google.gerrit.server.StartupException { java.lang.String invalid = cfg.getSubsections("groups").stream().filter(( sub) -> { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(sub); com.google.gerrit.server.account.GroupBackend groupBackend = universalGroupBackend.backend(uuid); return (groupBackend == null) || ((groupBackend.get(uuid)) == null); }).map(( u) -> ("'" + u) + "'").collect(java.util.stream.Collectors.joining(",")); if (!(invalid.isEmpty())) { throw new com.google.gerrit.server.StartupException(java.lang.String.format((((( for 'groups' in gerrit.config must be valid <START_MOD>account<END_MOD> +   UUIDs. The following <START_MOD>account<END_MOD> UUIDs could not be resolved:   + invalid) +   Please remove/fix these 'groups' subsections in +   gerrit.config. } }
@java.lang.Deprecated @org.kohsuke.args4j.Option(name = "--query", aliases = { "-q" }, usage =   to inspect (deprecated: use --<START_MOD>account<END_MOD>/-g instead) void addGroup_Deprecated(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { addGroup(uuid); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromDecoded(groupName)); com.google.gerrit.extensions.common.NameInput input = new com.google.gerrit.extensions.common.NameInput(); input.name = newGroupName; putName.apply(rsrc, input); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw die(e); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> getGroupFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUuid).toList(); if ((accountGroups.size()) == 1) { return java.util.Optional.of(com.google.common.collect.Iterables.getOnlyElement(accountGroups)); } else if (accountGroups.isEmpty()) { return java.util.Optional.empty(); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(( <START_MOD>account<END_MOD> UUID   + groupUuid)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource.create(repoManager, parent.getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(parent.getRevision()), id.get()); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("project.config", (   =   + (staff.toConfigValue()))).create(); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationErrors()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationErrors()).getMessage()).isEqualTo(((( <START_MOD>account<END_MOD>   + (staff.getName())) +   not in   + (GroupList.FILE_NAME))); }
@org.junit.Test public void editConfigMissingGroupTableEntry() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("project.config", (   + ((( exclusiveGroupPermissions = read submit +   submit = <START_MOD>account<END_MOD> People Who Can Submit +   upload = <START_MOD>account<END_MOD> Developers +   read = <START_MOD>account<END_MOD> Developers update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.common.data.AccessSection section = cfg.getAccessSection("refs/heads/*"); com.google.gerrit.common.data.Permission submit = section.getPermission(Permission.SUBMIT); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))); rev = commit(cfg); assertThat(text(rev, "project.config")).isEqualTo((   + (((( exclusiveGroupPermissions = read submit +   submit = <START_MOD>account<END_MOD> People Who Can Submit +   = <START_MOD>account<END_MOD> Staff +   upload = <START_MOD>account<END_MOD> Developers +   read = <START_MOD>account<END_MOD> Developers }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>access.AccessResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.access.AccessResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.TagResource resource, com.google.gerrit.extensions.api.projects.TagInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((   + (resource.getTagInfo().ref)) +   already exists }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).ref(rsrc.getBranchKey()).check(RefPermission.DELETE); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((   + (rsrc.getBranchKey())) +   has open changes } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource) { return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupJson.createOptions(resource.getGroup()); }
@org.kohsuke.args4j.Option(name = "-o", usage =   options per <START_MOD>account<END_MOD> public void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--query2", aliases = { "-q2" }, usage =   query public void setQuery(java.lang.String query) { this.query = query; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if ((inherited) && (!(rsrc.isProjectDefault()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( flag can only be used with default } if (rsrc.isProjectDefault()) { try { rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } } return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.parse(rsrc.getProjectState().getProject(), rsrc.getRefName().substring(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.REFS_DASHBOARDS.length()), rsrc.getPathName(), rsrc.getConfig(), rsrc.getProjectState().getName(), true); }
private com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
private com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.IdString.fromUrl(((ref + ':') + path))); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.RobotCommentResource>> views() { return views; }
@org.junit.Test public void byOwner() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo ownerGroup = createGroup(name(<START_MOD>"owner-account"<END_MOD>)); com.google.gerrit.extensions.common.GroupInfo group = createGroupWithOwner(name("group"), ownerGroup); createGroup(name("group2")); assertQuery(("owner:" + (group.id))); assertQuery(("owner:" + (ownerGroup.id)), group, ownerGroup); assertQuery(("owner:" + (ownerGroup.name)), group, ownerGroup); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.RobotCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.RobotComment c : commentsUtil.robotCommentsByPatchSet(notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.RobotCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); GroupInfo group = createGroup(name("Group")); assertQuery(("name:" + (group.name)), group); assertQuery(("name:" + (group.name.toLowerCase(Locale.US)))); GroupInfo groupWithHyphen = createGroup(name(<START_MOD>"account-with-hyphen"<END_MOD>)); createGroup(name(<START_MOD>"account-no-match-with-hyphen"<END_MOD>)); assertQuery(("name:" + (groupWithHyphen.name)), groupWithHyphen); }
@org.junit.Test public void byDefaultField() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name(<START_MOD>"foo-account"<END_MOD>)); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroupWithDescription(name("group3"), ( that contains foo and the UUID of group2:   + (group2.id))); assertQuery("non-existing"); assertQuery("foo", group1, group3); assertQuery(group2.id, group2, group3); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64(); } else if (Patch.MERGE_LIST.equals(path)) { byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64(); } return fileContentUtil.getContent(projectCache.checkedGet(rsrc.getRevision().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent); }
@org.junit.Test public void fixupCommitPostDatesAllAuditEventsEvenIfAuditEventsAreInTheFuture() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.util.stream.IntStream.range(0, 20).forEach(( i) -> com.google.gerrit.common.TimeUtil.nowTs()); java.sql.Timestamp future = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.testing.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, future)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Group <x>   8 "8@server-id"); assertServerCommit(log.get(2),   <START_MOD>account<END_MOD> Group <y> Group <z> assertThat(log.stream().map(( c) -> c.committer.date).collect(toImmutableList())).named("%s", log).isOrdered(); assertThat(com.google.gerrit.common.TimeUtil.nowTs()).isLessThan(future); }
@org.junit.Test public void memberAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = GroupRebuilderTest.builder().group(g).members(member(g, 1)).memberAudit(addMember(g, 1, 8, t2), addAndRemoveMember(g, 2, 8, t1, 9, t3)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Account 2 <2@server-id>   8 "8@server-id"); assertCommit(log.get(2),   <START_MOD>account<END_MOD> Account 1 <1@server-id>   8 "8@server-id"); assertCommit(log.get(3),   <START_MOD>account<END_MOD> Account 2 <2@server-id>   9 "9@server-id"); }
@org.junit.Test public void unauditedByIdAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Group <x>   8 "8@server-id"); assertServerCommit(log.get(2),   <START_MOD>account<END_MOD> Group <y> Group <z> }
@org.junit.Test public void redundantByIdAuditsAreIgnored() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t4 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t5 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).byId().byIdAudit(addById(g, "x", 8, t1), addById(g, "x", 8, t3), addById(g, "x", 9, t4), addAndRemoveById(g, "x", 8, t2, 9, t5)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Group <x>   8 "8@server-id"); assertCommit(log.get(2),   <START_MOD>account<END_MOD> Group <x>   9 "9@server-id"); }
@org.junit.Test public void unauditedMembershipsAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Account 1 <1@server-id>   8 "8@server-id"); assertServerCommit(log.get(2),   <START_MOD>account<END_MOD> Account 2 <2@server-id> Account 3 <3@server-id> }
@org.junit.Test public void auditsAtSameTimestampBrokenDownByUserAndType() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp ts = com.google.gerrit.common.TimeUtil.nowTs(); int user1 = 8; int user2 = 9; com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2), member(g, 3)).memberAudit(addMember(g, 1, user1, ts), addMember(g, 2, user2, ts), addMember(g, 3, user1, ts)).byId(byId(g, "x"), byId(g, "y"), byId(g, "z")).byIdAudit(addById(g, "x", user1, ts), addById(g, "y", user2, ts), addById(g, "z", user1, ts)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(5); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1), ( <START_MOD>account<END_MOD> + (("\n" +   Account 1 <1@server-id> +   Account 3 <3@server-id>   8 "8@server-id"); assertCommit(log.get(2),   <START_MOD>account<END_MOD> Group <x> Group <z>   8 "8@server-id"); assertCommit(log.get(3),   <START_MOD>account<END_MOD> Account 2 <2@server-id>   9 "9@server-id"); assertCommit(log.get(4),   <START_MOD>account<END_MOD> Group <y>   9 "9@server-id"); }
@org.junit.Test public void byIdAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.db.GroupBundle b = GroupRebuilderTest.builder().group(g).byId(byId(g, "x")).byIdAudit(addById(g, "x", 8, t2), addAndRemoveById(g, "y", 8, t1, 9, t3)).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Group <y>   8 "8@server-id"); assertCommit(log.get(2),   <START_MOD>account<END_MOD> Group <x>   8 "8@server-id"); assertCommit(log.get(3),   <START_MOD>account<END_MOD> Group <y>   9 "9@server-id"); }
@org.junit.Test public void membersAndSubgroups() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 1), member(g, 2)).byId(byId(g, "x"), byId(g, "y")).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(2); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertServerCommit(log.get(1), ( <START_MOD>account<END_MOD> + (((("\n" +   Account 1 <1@server-id> +   Account 2 <2@server-id> +   Group <x> +   Group <y> }
@org.junit.Test public void allGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); g.setDescription("Description"); g.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("owner")); g.setVisibleToAll(true); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> }
@org.junit.Test public void memberAuditLegacyRemoved() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).members(member(g, 2)).memberAudit(addAndLegacyRemoveMember(g, 1, 8, com.google.gerrit.common.TimeUtil.nowTs()), addMember(g, 2, 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(0),   <START_MOD>account<END_MOD> assertCommit(log.get(1),   <START_MOD>account<END_MOD> Account 1 <1@server-id>   8 "8@server-id"); assertCommit(log.get(2),   <START_MOD>account<END_MOD> Account 1 <1@server-id>   8 "8@server-id"); assertCommit(log.get(3),   <START_MOD>account<END_MOD> Account 2 <2@server-id>   8 "8@server-id"); }
@org.junit.Test public void minimalGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.db.GroupBundle b = com.google.gerrit.server.group.db.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigratedCleanly(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertCommit(log.get(0),   <START_MOD>account<END_MOD> com.google.gerrit.server.group.db.SERVER_NAME, com.google.gerrit.server.group.db.SERVER_EMAIL); assertThat(logGroupNames()).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return fileContentUtil.getContent(rsrc.getProjectState(), rsrc.getRev(), rsrc.getPath(), null); }
@org.junit.Test public void byDescription() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroupWithDescription(name("group1"),   is a test <START_MOD>account<END_MOD>. com.google.gerrit.extensions.common.GroupInfo group2 = createGroupWithDescription(name("group2"),   TEST GROUP. createGroupWithDescription(name("group3"),   of project foo. assertQuery("description:test", group1, group2); assertQuery("description:non-existing"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage( operator requires a value assertQuery("description:\"\""); }
@org.junit.Test public void bySubgroups() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(GroupField.SUBGROUP); assertFailingQuery("subgroup:someGroupName",   operator is not supported by <START_MOD>account<END_MOD> index version return; } com.google.gerrit.extensions.common.GroupInfo superParentGroup = createGroup(name("superParentGroup")); com.google.gerrit.extensions.common.GroupInfo parentGroup1 = createGroup(name("parentGroup1")); com.google.gerrit.extensions.common.GroupInfo parentGroup2 = createGroup(name("parentGroup2")); com.google.gerrit.extensions.common.GroupInfo subGroup = createGroup(name("subGroup")); gApi.groups().id(superParentGroup.id).addGroups(parentGroup1.id, parentGroup2.id); gApi.groups().id(parentGroup1.id).addGroups(subGroup.id); gApi.groups().id(parentGroup2.id).addGroups(subGroup.id); assertQuery(("subgroup:" + (subGroup.id)), parentGroup1, parentGroup2); assertQuery(("subgroup:" + (parentGroup1.id)), superParentGroup); gApi.groups().id(superParentGroup.id).addGroups(subGroup.id); gApi.groups().id(parentGroup1.id).removeGroups(subGroup.id); assertQuery(("subgroup:" + (subGroup.id)), superParentGroup, parentGroup2); }
@org.junit.Test public void byMember() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(GroupField.MEMBER); assertFailingQuery("member:someName",   operator is not supported by <START_MOD>account<END_MOD> index version return; } com.google.gerrit.extensions.common.AccountInfo user1 = createAccount("user1", "User1", "user1@example.com"); com.google.gerrit.extensions.common.AccountInfo user2 = createAccount("user2", "User2", "user2@example.com"); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("group1"), user1); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2"), user2); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup(name("group3"), user1); assertQuery(("member:" + (user1.name)), group1, group3); assertQuery(("member:" + (user1.email)), group1, group3); gApi.groups().id(group3.id).removeMembers(user1.username); gApi.groups().id(group2.id).addMembers(user1.username); assertQuery(("member:" + (user1.name)), group1, group2); }
@org.junit.Test public void byInname() throws java.lang.Exception { java.lang.String namePart = getSanitizedMethodName(); namePart = com.google.common.base.CharMatcher.is('_').removeFrom(namePart); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup((<START_MOD>"account-"<END_MOD> + namePart)); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(((<START_MOD>"account-"<END_MOD> + namePart) + "-2")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup(((<START_MOD>"account-"<END_MOD> + namePart) + "3")); assertQuery(("inname:" + namePart), group1, group2, group3); assertQuery(("inname:" + (namePart.toUpperCase(java.util.Locale.US))), group1, group2, group3); assertQuery(("inname:" + (namePart.toLowerCase(java.util.Locale.US))), group1, group2, group3); }
@org.junit.Test public void byIsVisibleToAll() throws java.lang.Exception { assertQuery("is:visibletoall"); com.google.gerrit.extensions.common.GroupInfo groupThatIsVisibleToAll = createGroupThatIsVisibleToAll(name(<START_MOD>"account-that-is-visible-to-all"<END_MOD>)); createGroup(name("group")); assertQuery("is:visibletoall", groupThatIsVisibleToAll); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void deleteGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage( allowed to delete <START_MOD>account<END_MOD> branch. branch(new com.google.gerrit.reviewdb.client.Branch.NameKey(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()))).delete(); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource rsrc, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((   + (rsrc.getRef())) +   already exists }
com.google.gerrit.server.api.changes.CommentApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.CommentResource c);
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel( Change").setTitle("Move change to a different branch and(permissionBackend.user(rsrc.getUser()).ref(change.getDest()).testCond(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.CREATE_CHANGE), rsrc.permissions().database(dbProvider).testCond(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.ABANDON)))); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getProjectState().getProject().getDescription()); }
private com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource checkExists() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((project) == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(name); } return project; }
com.google.gerrit.server.api.projects.ProjectApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project);
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || (!(com.google.gerrit.reviewdb.client.RefNames.isGroupRef(destBranch.get())))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException( update not allowed }
public static AccountGroup.UUID make(java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent creator) { java.security.MessageDigest md = org.eclipse.jgit.lib.Constants.newMessageDigest(); md.update(org.eclipse.jgit.lib.Constants.encode(((   + groupName) + "\n"))); md.update(org.eclipse.jgit.lib.Constants.encode(((   + (creator.toExternalString())) + "\n"))); md.update(org.eclipse.jgit.lib.Constants.encode(java.lang.String.valueOf(java.lang.Math.random()))); return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(org.eclipse.jgit.lib.ObjectId.fromRaw(md.digest()).name()); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup( <START_MOD>account<END_MOD> for schema migration setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId()) != null) ? ref.getObjectId().name() : null; info.canDelete = ((!(targets.contains(ref.getName()))) && (perm.testOrFalse(RefPermission.DELETE))) ? true : null; com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BranchResource rsrc = new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
com.google.gerrit.extensions.api.projects.BranchInfo toBranchInfo(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.lib.Ref r = db.exactRef(rsrc.getRef()); if (r == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, com.google.common.collect.ImmutableList.of(r)).get(0); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> allBranches(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.util.List<org.eclipse.jgit.lib.Ref> refs; try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { java.util.Collection<org.eclipse.jgit.lib.Ref> heads = db.getRefDatabase().getRefs(Constants.R_HEADS).values(); refs = new java.util.ArrayList(((heads.size()) + 3)); refs.addAll(heads); refs.addAll(db.getRefDatabase().exactRef(Constants.HEAD, RefNames.REFS_CONFIG, RefNames.REFS_USERS_DEFAULT).values()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noGitRepository) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, refs); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.BranchInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring).regex(matchRegex).start(start).limit(limit).filter(allBranches(rsrc)); }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> toBranchInfo(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc, java.util.List<org.eclipse.jgit.lib.Ref> refs) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Set<java.lang.String> targets = com.google.common.collect.Sets.newHashSetWithExpectedSize(1); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { targets.add(ref.getTarget().getName()); } } com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey()); java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> branches = new java.util.ArrayList(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { java.lang.String target = ref.getTarget().getName(); if (!(perm.ref(target).test(RefPermission.READ))) { continue; } if (target.startsWith(Constants.R_HEADS)) { target = target.substring(Constants.R_HEADS.length()); } com.google.gerrit.extensions.api.projects.BranchInfo b = new com.google.gerrit.extensions.api.projects.BranchInfo(); b.ref = ref.getName(); b.revision = target; branches.add(b); if (!(Constants.HEAD.equals(ref.getName()))) { b.canDelete = (perm.ref(ref.getName()).testOrFalse(RefPermission.DELETE)) ? true : null; } continue; } if (perm.ref(ref.getName()).test(RefPermission.READ)) { branches.add(createBranchInfo(perm.ref(ref.getName()), ref, rsrc.getProjectState(), rsrc.getUser(), targets)); } } java.util.Collections.sort(branches, new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ListBranches.BranchComparator()); return branches; }
@java.lang.Override public Response.Accepted apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) { com.google.gerrit.reviewdb.client.Project.NameKey project = resource.getNameKey(); com.google.gerrit.server.git.MultiProgressMonitor.Task mpt = new com.google.gerrit.server.git.MultiProgressMonitor(com.google.common.io.ByteStreams.nullOutputStream(),   project").beginSubTask(" MultiProgressMonitor.UNKNOWN); com.google.gerrit.server.index.change.AllChangesIndexer allChangesIndexer = allChangesIndexerProvider.get(); allChangesIndexer.setVerboseOut(NullOutputStream.INSTANCE); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<java.lang.Void> ignored = executor.submit(allChangesIndexer.reindexProject(indexer, project, mpt, mpt)); return com.google.gerrit.extensions.restapi.Response.accepted(((   + project) +   submitted for reindexing }
@org.kohsuke.args4j.Option(name = "--owned-by", usage =   groups owned by the given <START_MOD>account<END_MOD> uuid public void setOwnedBy(java.lang.String ownedBy) { this.ownedBy = ownedBy; }
@org.kohsuke.args4j.Option(name = <START_MOD>"--account"<END_MOD>, aliases = { "-g" }, usage =   to inspect public void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { groupsToInspect.add(uuid); }
@org.kohsuke.args4j.Option(name = "-o", usage =   options per <START_MOD>account<END_MOD> void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--regex", aliases = { "-r" }, metaVar = "REGEX", usage =   <START_MOD>account<END_MOD> regex public void setMatchRegex(java.lang.String matchRegex) { this.matchRegex = matchRegex; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); permissionBackend.user(user).project(resource.getNameKey()).ref(tag).check(RefPermission.DELETE); deleteRefFactory.create(resource).ref(tag).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.index.query.QueryParseException getExceptionForUnsupportedOperator(java.lang.String operatorName) { return new com.google.gerrit.index.query.QueryParseException(java.lang.String.format( operator is not supported by <START_MOD>account<END_MOD> index version operatorName)); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( must be set } com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>account.SCHEME_USERNAME, user.getUserName())); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId newExtId = com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword); externalIdsUpdate.create().upsert(newExtId); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { int id = config.getInt(com.google.gerrit.server.group.db.GroupConfigEntry.SECTION_NAME, super.keyName, (-1)); if (id < 0) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format( of the <START_MOD>account<END_MOD> %s must not be negative, found %d groupUuid.get(), id)); } group.setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(id)); }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ChildProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((recursive) || (rsrc.isDirectChild())) { return json.format(rsrc.getChild().getProject()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getChild().getName()); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.GroupInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new); return getDirectSubgroups(group, rsrc.getControl()); }
private java.util.List<com.google.gerrit.reviewdb.client.Account.Id> suggestAccounts(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.SuggestReviewers suggestReviewers) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.metrics.Timer0.Context ctx = metrics.queryAccountsLatency.start()) { try { com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.account.AccountState> result = queryProvider.get().setUserProvidedLimit(((suggestReviewers.getLimit()) * (com.google.gerrit.server.<START_MOD>restapi.change.<END_MOD>ReviewersUtil.CANDIDATE_LIST_MULTIPLIER))).query(com.google.gerrit.server.query.account.AccountPredicates.andActive(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()))); return result.entities().stream().map(( a) -> a.getAccount().getId()).collect(java.util.stream.Collectors.toList()); } catch (com.google.gerrit.index.query.QueryParseException e) { return com.google.common.collect.ImmutableList.of(); } } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.PutSubgroup create(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.PutSubgroup(addSubgroups, id.get()); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.common.data.GroupDescription.Internal parent = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); com.google.gerrit.common.data.GroupDescription.Basic member = groupsCollection.parse(TopLevelResource.INSTANCE, id).getGroup(); if ((resource.getControl().canSeeGroup()) && (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupsCollection.isSubgroup(parent, member))) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupResource(resource, member); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource> list() { return list; }
com.google.gerrit.server.api.changes.DraftApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource d);
@org.kohsuke.args4j.Option(name = "--match", aliases = { "-m" }, metaVar = "MATCH", usage =   <START_MOD>account<END_MOD> substring public void setMatchSubstring(java.lang.String matchSubstring) { this.matchSubstring = matchSubstring; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource, com.google.gerrit.extensions.common.GroupOptionsInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( <START_MOD>account<END_MOD> owner } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException( are required } if ((input.visibleToAll) == null) { input.visibleToAll = false; } if ((internalGroup.isVisibleToAll()) != (input.visibleToAll)) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setVisibleToAll(input.visibleToAll).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format( %s not found groupUuid)); } } com.google.gerrit.extensions.common.GroupOptionsInfo options = new com.google.gerrit.extensions.common.GroupOptionsInfo(); if (input.visibleToAll) { options.visibleToAll = true; } return options; }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource) { com.google.gerrit.reviewdb.client.Project project = resource.getProjectState().getProject(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = project.getParent(allProjectsName); return parentName != null ? parentName.get() : ""; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.GarbageCollect.Input input) { com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getNameKey(); if (input.async) { return applyAsync(project, input); } return applySync(project, input); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel( GC").setTitle("Triggers the Git Garbage Collection for this project. }
protected com.google.gerrit.common.data.ContributorAgreement configureContributorAgreement(boolean autoVerify) throws java.lang.Exception { com.google.gerrit.common.data.ContributorAgreement ca; if (autoVerify) { java.lang.String g = createGroup(<START_MOD>"cla-test-account"<END_MOD>); com.google.gerrit.extensions.api.groups.GroupApi groupApi = gApi.groups().id(g); groupApi.description( test <START_MOD>account<END_MOD> com.google.gerrit.server.group.InternalGroup caGroup = group(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupApi.detail().id)); com.google.gerrit.common.data.GroupReference groupRef = new com.google.gerrit.common.data.GroupReference(caGroup.getGroupUUID(), caGroup.getName()); com.google.gerrit.common.data.PermissionRule rule = new com.google.gerrit.common.data.PermissionRule(groupRef); rule.setAction(PermissionRule.Action.ALLOW); ca = new com.google.gerrit.common.data.ContributorAgreement("cla-test"); ca.setAutoVerify(groupRef); ca.setAccepted(com.google.common.collect.ImmutableList.of(rule)); } else { ca = new com.google.gerrit.common.data.ContributorAgreement("cla-test-no-auto-verify"); } ca.setDescription("description"); ca.setAgreementUrl("agreement-url"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig(); cfg.replace(ca); saveProjectConfig(allProjects, cfg); return ca; }
@java.lang.Override public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.FileResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FileResource(rev, id.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FileResource>> views() { return views; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.extensions.api.projects.BanCommitInput input = com.google.gerrit.extensions.api.projects.BanCommitInput.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(projectState, user), input); printCommits(r.newlyBanned,   following commits were banned printCommits(r.alreadyBanned,   following commits were already banned printCommits(r.ignored,   following ids do not represent commits and were ignored } catch (java.lang.Exception e) { throw die(e); } }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ownerGroupUuid = config.getString(com.google.gerrit.server.group.db.GroupConfigEntry.SECTION_NAME, null, super.keyName); if (com.google.common.base.Strings.isNullOrEmpty(ownerGroupUuid)) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format( UUID of the <START_MOD>account<END_MOD> %s must be defined groupUuid.get())); } group.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(ownerGroupUuid)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project, DeleteBranchesInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.branches) == null)) || (input.branches.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be specified } deleteRefFactory.create(project).refs(input.branches).prefix(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource rsrc, DraftInput in) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException { if (((in == null) || ((in.message) == null)) || (in.message.trim().isEmpty())) { return delete.applyImpl(updateFactory, rsrc, null); } else if (((in.id) != null) && (!(rsrc.getId().equals(in.id)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must match URL } else if (((in.line) != null) && ((in.line) < 0)) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be >= 0 } else if ((((in.line) != null) && ((in.range) != null)) && ((in.line) != (in.range.endLine))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( endLine must be on the same line as the comment } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PutDraftComment.Op op = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PutDraftComment.Op(rsrc.getComment().key, in); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(commentJson.get().setFillAccounts(false).newCommentFormatter().format(op.comment)); } }
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(allUsersRepo, groupUuid); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); if (!(groupConfig.getLoadedGroup().isPresent())) { if (groupsMigration.readFromNoteDb()) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupUuid); } return java.util.Optional.empty(); } com.google.gerrit.server.group.InternalGroup originalGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = null; if (groupUpdate.getName().isPresent()) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = originalGroup.getNameKey(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey newName = groupUpdate.getName().get(); groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName); } commit(allUsersRepo, groupConfig, groupNameNotes); com.google.gerrit.server.group.InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( <START_MOD>account<END_MOD> wasn automatically loaded return java.util.Optional.of(com.google.gerrit.server.group.db.GroupsUpdate.getUpdateResult(originalGroup, updatedGroup)); } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddGroupsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log add groups to <START_MOD>account<END_MOD> event e); } } }
private void addMembers(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddMembers.Input input = AddMembers.Input.fromMembers(initialMembers.stream().map(java.lang.Object::toString).collect(java.util.stream.Collectors.toList())); addMembers.apply(rsrc, input); }
private void addSubgroups(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddSubgroups.Input input = AddSubgroups.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).collect(java.util.stream.Collectors.toList())); addSubgroups.apply(rsrc, input); }
@org.kohsuke.args4j.Option(name = <START_MOD>"--account"<END_MOD>, aliases = "-g", metaVar = "GROUP", usage =   set of groups to be included in the <START_MOD>account<END_MOD> void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { initialGroups.add(id); }
@java.lang.Override public void replace(com.google.gerrit.server.group.InternalGroup group) throws java.io.IOException { io.searchbox.core.Bulk bulk = new io.searchbox.core.Bulk.Builder().defaultIndex(indexName).defaultType(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS).addAction(insert(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS, group)).refresh(true).build(); io.searchbox.client.JestResult result = client.execute(bulk); if (!(result.isSucceeded())) { throw new java.io.IOException(java.lang.String.format( to replace <START_MOD>account<END_MOD> %s in index %s: %s group.getGroupUUID().get(), indexName, result.getErrorMessage())); } }
private void reportGroupsAction(java.lang.String action, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupUuidList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = groupUuidList.stream().map(( uuid) -> groupCache.get(uuid).map(com.google.gerrit.server.group.InternalGroup::getName)).flatMap(Streams::stream).collect(java.util.stream.Collectors.joining(   out.write(java.lang.String.format( %s <START_MOD>account<END_MOD> %s: %s action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gerrit.sshd.commands.UnloggedFailure, java.lang.Exception { try { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid : groups) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(groupUuid.get())); if (!(accountsToRemove.isEmpty())) { deleteMembers.apply(resource, fromMembers(accountsToRemove)); reportMembersAction( from resource, accountsToRemove); } if (!(groupsToRemove.isEmpty())) { deleteSubgroups.apply(resource, fromGroups(groupsToRemove)); reportGroupsAction( from resource, groupsToRemove); } if (!(accountsToAdd.isEmpty())) { addMembers.apply(resource, fromMembers(accountsToAdd)); reportMembersAction( to resource, accountsToAdd); } if (!(groupsToInclude.isEmpty())) { addSubgroups.apply(resource, fromGroups(groupsToInclude)); reportGroupsAction( to resource, groupsToInclude); } } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountCache.get(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(   out.write(java.lang.String.format( %s <START_MOD>account<END_MOD> %s: %s action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((   + (resource.getName())) +   already exists }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { com.google.gerrit.extensions.api.projects.ConfigInput configInput = new com.google.gerrit.extensions.api.projects.ConfigInput(); configInput.requireChangeId = requireChangeID; configInput.submitType = submitType; configInput.useContentMerge = contentMerge; configInput.useContributorAgreements = contributorAgreements; configInput.useSignedOffBy = signedOffBy; configInput.state = state.getProject().getState(); configInput.maxObjectSizeLimit = maxObjectSizeLimit; if ((com.google.common.base.Strings.emptyToNull(projectDescription)) != null) { configInput.description = projectDescription; } else { configInput.description = projectState.getProject().getDescription(); } try { putConfig.apply(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(projectState, user), configInput); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw die(e); } }
com.google.gerrit.server.api.groups.GroupApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo owner() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getOwner.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( get <START_MOD>account<END_MOD> owner e); } }
@java.lang.Override public void options(com.google.gerrit.extensions.common.GroupOptionsInfo options) throws com.google.gerrit.extensions.restapi.RestApiException { try { putOptions.apply(rsrc, options); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( put <START_MOD>account<END_MOD> options e); } }
@java.lang.Override public void index() throws com.google.gerrit.extensions.restapi.RestApiException { try { index.apply(rsrc, new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( index <START_MOD>account<END_MOD> e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> members(boolean recursive) throws com.google.gerrit.extensions.restapi.RestApiException { listMembers.setRecursive(recursive); try { return listMembers.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( list <START_MOD>account<END_MOD> members e); } }
@java.lang.Override public void removeMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( remove <START_MOD>account<END_MOD> members e); } }
@java.lang.Override public void name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.NameInput in = new com.google.gerrit.extensions.common.NameInput(); in.name = name; try { putName.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( put <START_MOD>account<END_MOD> name e); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo detail() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDetail.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( retrieve <START_MOD>account<END_MOD> e); } }
@java.lang.Override public void addMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { addMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( add <START_MOD>account<END_MOD> members e); } }
@java.lang.Override public void description(java.lang.String description) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.DescriptionInput in = new com.google.gerrit.extensions.common.DescriptionInput(); in.description = description; try { putDescription.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( put <START_MOD>account<END_MOD> description e); } }
@org.kohsuke.args4j.Option(name = "--member", aliases = { "-m" }, metaVar = "USERNAME", usage =   set of users to become members of the <START_MOD>account<END_MOD> void addMember(com.google.gerrit.reviewdb.client.Account.Id id) { initialMembers.add(id); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc = createGroup(); if (!(initialMembers.isEmpty())) { addMembers(rsrc); } if (!(initialGroups.isEmpty())) { addSubgroups(rsrc); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e); } }
private com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource createGroup() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.groups.GroupInput input = new com.google.gerrit.extensions.api.groups.GroupInput(); input.description = groupDescription; input.visibleToAll = visibleToAll; if ((ownerGroupId) != null) { input.ownerId = java.lang.String.valueOf(ownerGroupId.get()); } com.google.gerrit.extensions.common.GroupInfo group = createGroupFactory.create(groupName).apply(TopLevelResource.INSTANCE, input); return groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(group.id)); }
@java.lang.Override public com.google.gerrit.extensions.api.groups.GroupApi create(com.google.gerrit.extensions.api.groups.GroupInput in) throws com.google.gerrit.extensions.restapi.RestApiException { if ((checkNotNull(in, "GroupInput").name) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must specify name } try { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.CreateGroup impl = createGroup.create(in.name); permissionBackend.user(user).checkAny(com.google.gerrit.server.permissions.GlobalPermission.fromAnnotation(impl.getClass())); com.google.gerrit.extensions.common.GroupInfo info = impl.apply(TopLevelResource.INSTANCE, in); return id(info.id); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(( create <START_MOD>account<END_MOD>   + (in.name)), e); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPNAMES); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); java.util.Set<com.google.gerrit.common.data.GroupReference> groupReferences = new java.util.LinkedHashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.common.data.GroupReference groupReference = com.google.gerrit.server.group.db.GroupNameNotes.getGroupReference(reader, note.getData()); boolean result = groupReferences.add(groupReference); if (!result) { com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning( UUID of <START_MOD>account<END_MOD> %s (%s) is duplicate in <START_MOD>account<END_MOD> name notes groupReference.getName(), groupReference.getUUID()); } } return com.google.common.collect.ImmutableSet.copyOf(groupReferences); } }
private java.lang.String getCommitMessage() { if ((oldGroupName.isPresent()) && (newGroupName.isPresent())) { return java.lang.String.format( <START_MOD>account<END_MOD> from '%s' to '%s' oldGroupName.get(), newGroupName.get()); } if (newGroupName.isPresent()) { return java.lang.String.format( <START_MOD>account<END_MOD> '%s' newGroupName.get()); } if (oldGroupName.isPresent()) { return java.lang.String.format( <START_MOD>account<END_MOD> '%s' oldGroupName.get()); } return "No-op"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource resource, com.google.gerrit.extensions.common.AgreementInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( agreements disabled } if ((self.get()) != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to enter contributor agreement } java.lang.String agreementName = com.google.common.base.Strings.nullToEmpty(input.name); com.google.gerrit.common.data.ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName); if (ca == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( agreement not found } if ((ca.getAutoVerify()) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException( enter a non-autoVerify agreement } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = ca.getAutoVerify().getUUID(); if (uuid == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( <START_MOD>account<END_MOD> uuid not found } com.google.gerrit.reviewdb.client.Account account = self.get().getAccount(); try { addMembers.addMembers(uuid, com.google.common.collect.ImmutableSet.of(account.getId())); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( <START_MOD>account<END_MOD> not found } agreementSignup.fire(account, agreementName); return com.google.gerrit.extensions.restapi.Response.ok(agreementName); }
@org.junit.Test public void sharedGroupID() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "id", g2.groupId); cfg.setString("group", null, "ownerGroupUuid", gAdmin.id); updateGroupFile(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), GroupConfig.GROUP_CONFIG_FILE, cfg.toText()); assertError( <START_MOD>account<END_MOD> id }
@org.junit.Test public void missingGroupNameRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(RefNames.REFS_GROUPNAMES); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError( does not exist }
@org.junit.Test public void nameWithoutGroupRef() throws java.lang.Exception { java.lang.String bogusName =   name org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString("group", null, "uuid", com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID); config.setString("group", null, "name", bogusName); updateGroupFile(RefNames.REFS_GROUPNAMES, com.google.gerrit.server.group.db.GroupNameNotes.getNoteKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(bogusName)).getName(), config.toText()); assertError( missing as <START_MOD>account<END_MOD> ref }
@org.junit.Test public void missingNameEntry() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefRename ru = repo.renameRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID))); org.eclipse.jgit.lib.RefUpdate.Result result = ru.rename(); assertThat(result).isEqualTo(Result.RENAMED); } assertError(((   + (com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID)) +   has no entry in name map }
@org.junit.Test public void unknownOwnerGroup() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "id", g1.groupId); cfg.setString("group", null, "ownerGroupUuid", com.google.gerrit.acceptance.api.group.GroupsConsistencyIT.BOGUS_UUID); updateGroupFile(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), GroupConfig.GROUP_CONFIG_FILE, cfg.toText()); assertError( owner <START_MOD>account<END_MOD> }
@org.junit.Test public void missingGroupRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError( as <START_MOD>account<END_MOD> ref }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo get() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getGroup.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( retrieve <START_MOD>account<END_MOD> e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { if (name == null) { return java.util.Optional.empty(); } try { return byName.get(name.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format( look up <START_MOD>account<END_MOD> %s by name name.get()), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { try { return byId.get(groupId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(( load <START_MOD>account<END_MOD>   + groupId), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { if (groupUuid == null) { return java.util.Optional.empty(); } try { return byUUID.get(groupUuid.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format( look up <START_MOD>account<END_MOD> %s by uuid groupUuid.get()), e); return java.util.Optional.empty(); } }
private void index(com.google.gerrit.server.project.ProjectState projectState) { try { index.apply(new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource(projectState, user), null); } catch (java.lang.Exception e) { writeError("error", java.lang.String.format( to index %s: %s projectState.getName(), e.getMessage())); } }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); if ((ref != null) && (!(visibleTags(resource.getProjectState(), repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty()))) { return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ListTags.createTagInfo(permissionBackend.user(resource.getUser()).project(resource.getNameKey()).ref(ref.getName()), ref, rw, resource.getNameKey(), links); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(resource.getNameKey()); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getProjectState(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ListTags.createTagInfo(perm.ref(ref.getName()), ref, rw, resource.getNameKey(), links)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.Set<java.lang.String>> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.ChangeResource req) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = req.getNotes().load(); java.util.Set<java.lang.String> hashtags = notes.getHashtags(); if (hashtags == null) { hashtags = java.util.Collections.emptySet(); } return com.google.gerrit.extensions.restapi.Response.ok(hashtags); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void createGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); assertCreateFails(new com.google.gerrit.reviewdb.client.Branch.NameKey(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("foo"))), com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUuid()), com.google.gerrit.extensions.restapi.ResourceConflictException.class,   allowed to create <START_MOD>account<END_MOD> branch. }
private java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> list(com.google.gerrit.server.api.groups.ListRequest req) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.restapi.TopLevelResource tlr = com.google.gerrit.extensions.restapi.TopLevelResource.INSTANCE; com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.ListGroups list = listGroups.get(); list.setOptions(req.getOptions()); for (java.lang.String project : req.getProjects()) { try { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc = projects.parse(tlr, com.google.gerrit.extensions.restapi.IdString.fromDecoded(project)); list.addProject(rsrc.getProjectState()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(( looking up project   + project), e); } } for (java.lang.String group : req.getGroups()) { list.addGroup(groups.parse(group).getGroupUUID()); } list.setVisibleToAll(req.getVisibleToAll()); if ((req.getOwnedBy()) != null) { list.setOwnedBy(req.getOwnedBy()); } if ((req.getUser()) != null) { try { list.setUser(accounts.parse(req.getUser()).getAccountId()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(( looking up user   + (req.getUser())), e); } } list.setOwned(req.getOwned()); list.setLimit(req.getLimit()); list.setStart(req.getStart()); list.setMatchSubstring(req.getSubstring()); list.setMatchRegex(req.getRegex()); list.setSuggest(req.getSuggest()); try { return list.apply(tlr); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( list groups e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.List<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.extensions.restapi.Response.ok(java.util.Collections.emptyList()); } com.google.gerrit.server.account.AccountLoader accountLoader = accountLoaderFactory.create(true); java.util.List<com.google.gerrit.extensions.common.AccountInfo> infos = pastAssignees.stream().map(accountLoader::get).collect(java.util.stream.Collectors.toList()); accountLoader.fill(); return com.google.gerrit.extensions.restapi.Response.ok(infos); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData> visibleto(java.lang.String who) throws com.google.gerrit.index.query.QueryParseException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (isSelf(who)) { return is_visible(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); if (!(m.isEmpty())) { java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { return visibleto(args.userFactory.create(id)); } return com.google.gerrit.index.query.Predicate.or(p); } java.util.Collection<com.google.gerrit.common.data.GroupReference> suggestions = args.groupBackend.suggest(who, null); if (!(suggestions.isEmpty())) { java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> ids = new java.util.HashSet<>(); for (com.google.gerrit.common.data.GroupReference ref : suggestions) { ids.add(ref.getUUID()); } return visibleto(new com.google.gerrit.server.query.change.SingleGroupUser(ids)); } throw error((( user or <START_MOD>account<END_MOD> matches   + who) + "\".")); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException( required } else if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.common.data.GroupDescription.Basic group = parseId(id.get()); if (group == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id.get()); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(group); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource(ctl); }
public void visit(org.eclipse.jgit.revwalk.RevCommit c) { checkState((!(done)),   called after getGroups() java.util.Set<org.eclipse.jgit.revwalk.RevCommit> interestingParents = getInterestingParents(c); if ((interestingParents.size()) == 0) { groups.put(c, c.name()); return; } else if ((interestingParents.size()) == 1) { groups.putAll(c, groups.get(interestingParents.iterator().next())); return; } java.util.Set<java.lang.String> thisCommitGroups = new java.util.TreeSet<>(); java.util.Set<java.lang.String> parentGroupsNewInThisPush = com.google.common.collect.Sets.newLinkedHashSetWithExpectedSize(interestingParents.size()); for (org.eclipse.jgit.revwalk.RevCommit p : interestingParents) { java.util.Collection<java.lang.String> parentGroups = groups.get(p); if (parentGroups.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format( <START_MOD>account<END_MOD> assigned to parent %s of commit %s p.name(), c.name())); } for (java.lang.String parentGroup : parentGroups) { if (isGroupFromExistingPatchSet(p, parentGroup)) { thisCommitGroups.add(parentGroup); } else { parentGroupsNewInThisPush.add(parentGroup); } } } java.lang.Iterable<java.lang.String> toAlias; if (thisCommitGroups.isEmpty()) { java.lang.String firstParentGroup = parentGroupsNewInThisPush.iterator().next(); thisCommitGroups = com.google.common.collect.ImmutableSet.of(firstParentGroup); toAlias = com.google.common.collect.Iterables.skip(parentGroupsNewInThisPush, 1); } else { toAlias = parentGroupsNewInThisPush; } groups.putAll(c, thisCommitGroups); for (java.lang.String pg : toAlias) { groupAliases.putAll(pg, thisCommitGroups); } }
private org.eclipse.jgit.lib.ObjectId parseGroup(org.eclipse.jgit.lib.ObjectId forCommit, java.lang.String group) { try { return org.eclipse.jgit.lib.ObjectId.fromString(group); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.git.GroupCollector.log.warn( for commit {} is not a SHA-1: {} forCommit.name(), group); return null; } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc); }
@org.junit.Test public void createGroupAsUserIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, <START_MOD>"test-account"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit = createExpMemberAudit(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit); }
private com.google.gerrit.server.group.InternalGroup updateGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.lang.Exception { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(allUsersRepo, uuid); groupConfig.setGroupUpdate(groupUpdate, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName); groupConfig.commit(createMetaDataUpdate(userIdent)); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( <START_MOD>account<END_MOD> failed }
@org.junit.Test public void addMultiSubgroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, <START_MOD>"test-account"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroup subgroup1 = createGroupAsUser(2, <START_MOD>"test-account-2"<END_MOD>); com.google.gerrit.server.group.InternalGroup subgroup2 = createGroupAsUser(3, <START_MOD>"test-account-3"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid1 = subgroup1.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid2 = subgroup2.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid1, subgroupUuid2)); assertTipCommit(uuid, ((( <START_MOD>account<END_MOD> + "\n") + (java.lang.String.format( Group <%s> subgroupUuid1))) + (java.lang.String.format( Group <%s> subgroupUuid2)))); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit1 = createExpGroupAudit(group.getId(), subgroupUuid1, userId, getTipTimestamp(uuid)); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit2 = createExpGroupAudit(group.getId(), subgroupUuid2, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); }
@org.junit.Test public void createGroupAsServerIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroup(1, <START_MOD>"test-account"<END_MOD>, serverIdent, null); assertThat(auditLogReader.getMembersAudit(allUsersRepo, group.getGroupUUID())).hasSize(0); }
private com.google.gerrit.server.group.InternalGroup createGroup(int next, java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent authorIdent, com.google.gerrit.reviewdb.client.Account.Id authorId) throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = com.google.gerrit.server.group.db.InternalGroupCreation.builder().setGroupUUID(com.google.gerrit.server.account.GroupUUID.make(groupName, serverIdent)).setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName)).setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(next)).build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = (authorIdent.equals(serverIdent)) ? com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setDescription("Groups").build() : com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setDescription("Groups").setMemberModification(( members) -> com.google.common.collect.ImmutableSet.of(authorId)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, AbstractGroupTest::getAccountNameEmail, AbstractGroupTest::getGroupName); org.eclipse.jgit.revwalk.RevCommit commit = groupConfig.commit(createMetaDataUpdate(authorIdent)); assertCreateGroup(authorIdent, commit); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( <START_MOD>account<END_MOD> failed }
private void assertCreateGroup(org.eclipse.jgit.lib.PersonIdent authorIdent, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { if (authorIdent.equals(serverIdent)) { assertServerCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit),   <START_MOD>account<END_MOD> } else { assertCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), java.lang.String.format( <START_MOD>account<END_MOD> Account %s <%s@%s> userId, userId, com.google.gerrit.server.group.db.SERVER_ID), getAccountName(userId), getAccountEmail(userId)); } }
void validateNewProject(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException;
@org.junit.Test public void addAndRemoveSubgroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, <START_MOD>"test-account"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroup subgroup = createGroupAsUser(2, <START_MOD>"test-account-2"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid = subgroup.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format( <START_MOD>account<END_MOD> Group <%s> subgroupUuid)); com.google.gerrit.reviewdb.client.AccountGroupByIdAud expAudit = createExpGroupAudit(group.getId(), subgroupUuid, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit); removeSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format( <START_MOD>account<END_MOD> Group <%s> subgroupUuid)); expAudit.removed(userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expAudit); }
@org.junit.Test public void addMultiMembers() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, <START_MOD>"test-account"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit1 = createExpMemberAudit(groupId, userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id1 = new com.google.gerrit.reviewdb.client.Account.Id(100002); com.google.gerrit.reviewdb.client.Account.Id id2 = new com.google.gerrit.reviewdb.client.Account.Id(100003); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id1, id2)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit2 = createExpMemberAudit(groupId, id1, userId, getTipTimestamp(uuid)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit3 = createExpMemberAudit(groupId, id2, userId, getTipTimestamp(uuid)); assertTipCommit(uuid, ( <START_MOD>account<END_MOD> + (("\n" +   Account 100002 <100002@server-id> +   Account 100003 <100003@server-id> assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2, expAudit3).inOrder(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.CommitResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.CommitResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { if (com.google.gerrit.reviewdb.client.Patch.isMagic(id.get())) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource(parent.getProjectState(), parent.getCommit(), id.get()); } return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource.create(repoManager, parent.getProjectState(), parent.getCommit(), id.get()); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input in = new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddMembers.Input(); in._oneMember = id; try { java.util.List<com.google.gerrit.extensions.common.AccountInfo> list = put.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MemberResource resource, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddMembers.Input input) throws com.google.gwtorm.server.OrmException { return get.apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return list.get().toBranchInfo(rsrc); }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(org.eclipse.jgit.lib.Repository allUsersRepo, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( <START_MOD>account<END_MOD> wasn automatically loaded }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug( tag cache on fast-forward of {} cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.receive.ReceiveCommits.isConfig(cmd)) { logDebug( project in cache try { projectCache.evict(project); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(( evict from project cache, name key:   + (project.getName())), e); } com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug( project description repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(( update description of   + (project.getName())), e); } if (allProjectsName.equals(project.getNameKey())) { try { createGroupPermissionSyncer.syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.error( sync create <START_MOD>account<END_MOD> permissions e); } } } }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.RepositoryStatistics apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.RepositoryStatistics(gc.getStatistics()); } catch (org.eclipse.jgit.api.errors.GitAPIException | org.eclipse.jgit.api.errors.JGitInternalException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getName()); } }
@org.junit.Test public void addAndRemoveMember() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, <START_MOD>"test-account"<END_MOD>); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit1 = createExpMemberAudit(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(100002); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit2 = createExpMemberAudit(group.getId(), id, userId, getTipTimestamp(uuid)); assertTipCommit(uuid,   <START_MOD>account<END_MOD> Account 100002 <100002@server-id> assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); removeMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); assertTipCommit(uuid,   <START_MOD>account<END_MOD> Account 100002 <100002@server-id> expAudit2.removed(userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, expAudit2).inOrder(); }
static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM); java.lang.String name = com.google.common.base.Strings.nullToEmpty(config.getString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM)); if (uuid == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format( for <START_MOD>account<END_MOD> '%s' must be defined name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FixResource fixResource, java.lang.Void nothing) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.RevisionResource revisionResource = fixResource.getRevisionResource(); com.google.gerrit.reviewdb.client.Project.NameKey project = revisionResource.getProject(); com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(project); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); org.eclipse.jgit.lib.ObjectId patchSetCommitId = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); try (org.eclipse.jgit.lib.Repository repository = gitRepositoryManager.openRepository(project)) { java.util.List<com.google.gerrit.server.edit.tree.TreeModification> treeModifications = fixReplacementInterpreter.toTreeModifications(repository, projectState, patchSetCommitId, fixResource.getFixReplacements()); com.google.gerrit.server.edit.ChangeEdit changeEdit = changeEditModifier.combineWithModifiedPatchSetTree(repository, revisionResource.getNotes(), patchSet, treeModifications); return com.google.gerrit.extensions.restapi.Response.ok(changeEditJson.toEditInfo(changeEdit, false)); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
com.google.gerrit.server.api.projects.DashboardApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project, java.lang.String id);
public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String reviewer = input.reviewer; com.google.gerrit.extensions.client.ReviewerState state = input.state(); com.google.gerrit.extensions.api.changes.NotifyHandling notify = input.notify; com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify = null; try { accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { return fail(reviewer, e.getMessage()); } boolean confirmed = input.confirmed(); boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail(); com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PostReviewers.Addition byAccountId = addByAccountId(reviewer, rsrc, state, notify, accountsToNotify, allowGroup, allowByEmail); if (byAccountId != null) { return byAccountId; } com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.PostReviewers.Addition wholeGroup = addWholeGroup(reviewer, rsrc, state, notify, accountsToNotify, confirmed, allowGroup, allowByEmail); if (wholeGroup != null) { return wholeGroup; } return addByEmail(reviewer, rsrc, state, notify, accountsToNotify); }
private java.lang.String createCommitMessage(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> originalMembers, java.util.Optional<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id>> updatedMembers, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> originalSubgroups, java.util.Optional<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>> updatedSubgroups) { java.lang.String summaryLine = (groupCreation.isPresent()) ?   <START_MOD>account<END_MOD> :   <START_MOD>account<END_MOD> java.util.StringJoiner footerJoiner = new java.util.StringJoiner("\n", "\n\n", ""); footerJoiner.setEmptyValue(""); getCommitFooterForRename().ifPresent(footerJoiner::add); updatedMembers.ifPresent(( newMembers) -> getCommitFootersForMemberModifications(originalMembers, newMembers).forEach(footerJoiner::add)); updatedSubgroups.ifPresent(( newSubgroups) -> getCommitFootersForSubgroupModifications(originalSubgroups, newSubgroups).forEach(footerJoiner::add)); java.lang.String footer = footerJoiner.toString(); return summaryLine + footer; }
@java.lang.Override protected void run() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.HeadInput input = new com.google.gerrit.extensions.api.projects.HeadInput(); input.ref = newHead; try { setHead.apply(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(project, user), input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw die(e); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.DraftCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> getChildrenForReparenting(com.google.gerrit.server.project.ProjectState parent) throws com.google.gerrit.server.permissions.PermissionBackendException { final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> childProjects = new java.util.ArrayList<>(); final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> excluded = new java.util.ArrayList(excludedChildren.size()); for (com.google.gerrit.server.project.ProjectState excludedChild : excludedChildren) { excluded.add(excludedChild.getProject().getNameKey()); } final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> automaticallyExcluded = new java.util.ArrayList(excludedChildren.size()); if ((newParentKey) != null) { automaticallyExcluded.addAll(getAllParents(newParentKey)); } for (com.google.gerrit.extensions.common.ProjectInfo child : listChildProjects.apply(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(parent, user))) { final com.google.gerrit.reviewdb.client.Project.NameKey childName = new com.google.gerrit.reviewdb.client.Project.NameKey(child.name); if (!(excluded.contains(childName))) { if (!(automaticallyExcluded.contains(childName))) { childProjects.add(childName); } else { stdout.println((((((( excluded   + childName) +     +   reparenting because it is in the parent   +   of the new parent   + (newParentKey)) + "'.")); } } } return childProjects; }
public com.google.gerrit.extensions.common.AgreementInfo format(com.google.gerrit.common.data.ContributorAgreement ca) { com.google.gerrit.extensions.common.AgreementInfo info = new com.google.gerrit.extensions.common.AgreementInfo(); info.name = ca.getName(); info.description = ca.getDescription(); info.url = ca.getAgreementUrl(); com.google.gerrit.common.data.GroupReference autoVerifyGroup = ca.getAutoVerify(); if ((autoVerifyGroup != null) && (self.get().isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser user = identifiedUserFactory.create(self.get().getAccountId()); try { com.google.gerrit.server.account.GroupControl gc = genericGroupControlFactory.controlFor(user, autoVerifyGroup.getUUID()); com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource group = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource(gc); info.autoVerifyGroup = groupJson.format(group); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>config.AgreementJson.log.warn((((( <START_MOD>account<END_MOD>   + (autoVerifyGroup.getName())) +   does not exist, referenced in CLA   + (ca.getName())) + "\"")); } } return info; }
public static com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DashboardResource projectDefault(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource(projectState, user, null, null, null, true); }
@java.lang.Override public com.google.gerrit.extensions.common.RobotCommentInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.RobotCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newRobotCommentFormatter().format(rsrc.getComment()); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource) throws com.google.gwtorm.server.OrmException { return json.format(resource.getGroup()); }
@org.junit.Test public void createProjectWithNonExistingOwner_UnprocessableEntity() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name("newProjectName"); in.owners = java.util.Collections.singletonList(<START_MOD>"non-existing-account"<END_MOD>); assertCreateFails(in, com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); }
@org.kohsuke.args4j.Option(name = "--has-acl-for", metaVar = "GROUP", usage =   only projects on which access rights for this <START_MOD>account<END_MOD> are directly assigned public void setGroupUuid(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { this.groupUuid = groupUuid; }
com.google.gerrit.server.api.projects.TagApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource project, java.lang.String ref);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input in = new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddSubgroups.Input(); in.groups = com.google.common.collect.ImmutableList.of(id); try { java.util.List<com.google.gerrit.extensions.common.GroupInfo> list = addSubgroups.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupResource resource, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddSubgroups.Input input) throws com.google.gwtorm.server.OrmException { return get.get().apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.CommentResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.CommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByPatchSet(dbProvider.get(), notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.CommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public static com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource create(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.project.ProjectState projectState, org.eclipse.jgit.lib.ObjectId rev, java.lang.String path) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectState.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree(rev); if ((org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree)) != null) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.FileResource(projectState, rev, path); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, git)) { md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); md.setMessage(com.google.gerrit.server.schema.Schema_164.COMMIT_MSG); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection groups = config.getAccessSection(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), true); com.google.gerrit.server.schema.AclUtil.grant(config, groups, Permission.READ, false, true, systemGroupBackend.getGroup(com.google.gerrit.server.schema.REGISTERED_USERS)); config.commit(md); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException( to grant read permissions on <START_MOD>account<END_MOD> branches e); } }
private com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
@java.lang.Override public void setDefault() throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInput(); input.id = id; try { set.apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DashboardResource.projectDefault(project.getProjectState(), project.getUser()), input); } catch (java.lang.Exception e) { java.lang.String msg = java.lang.String.format( %s default dashboard ((id) != null ? "set" : "remove")); throw com.google.gerrit.server.api.ApiUtil.asRestApiException(msg, e); } }
private com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.TagResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { return tags.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); input = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(( delete members from <START_MOD>account<END_MOD>   + (internalGroup.getName()))); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = new java.util.HashSet<>(); for (java.lang.String nameOrEmail : input.members) { com.google.gerrit.reviewdb.client.Account a = accounts.parse(nameOrEmail).getAccount(); membersToRemove.add(a.getId()); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); try { removeGroupMembers(groupUuid, membersToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format( %s not found groupUuid)); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public void owner(java.lang.String owner) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.groups.OwnerInput in = new com.google.gerrit.extensions.api.groups.OwnerInput(); in.owner = owner; try { putOwner.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( put <START_MOD>account<END_MOD> owner e); } }
@org.junit.Test public void rejectWhenFeatureIsDisabled() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.api.projects.ConfigInput conf = new com.google.gerrit.extensions.api.projects.ConfigInput(); conf.enableReviewerByEmail = com.google.gerrit.extensions.client.InheritableBoolean.FALSE; gApi.projects().name(project.get()).config(conf); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.AddReviewerResult result = gApi.changes().id(r.getChangeId()).addReviewer( Bar <foo.bar@gerritcodereview.com> assertThat(result.error).isEqualTo( Bar <foo.bar@gerritcodereview.com> does not identify a registered user or <START_MOD>account<END_MOD> assertThat(result.reviewers).isNull(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource, ?> create(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource parse(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.newDashboardInfo(id.get()); } catch (com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.InvalidDashboardId e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource) { return new com.google.gerrit.server.project.ConfigInfoImpl(serverEnableSignedPush, resource.getProjectState(), resource.getUser(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); try { com.google.gerrit.server.account.GroupControl c = controlFactory.validateFor(group.getOwnerGroupUUID()); return json.format(c.getGroup()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.CommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkGroup(com.google.gerrit.server.group.InternalGroup g, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) throws java.io.IOException { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); problems.addAll(checkCycle(g, byUUID)); if (((byUUID.get(g.getOwnerGroupUUID())) == null) && ((groupBackend.get(g.getOwnerGroupUUID())) == null)) { problems.add(error( %s (%s) has nonexistent owner <START_MOD>account<END_MOD> %s g.getName(), g.getGroupUUID(), g.getOwnerGroupUUID())); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : g.getSubgroups()) { if (((byUUID.get(subUuid)) == null) && ((groupBackend.get(subUuid)) == null)) { problems.add(error( %s (%s) has nonexistent subgroup %s g.getName(), g.getGroupUUID(), subUuid)); } } for (com.google.gerrit.reviewdb.client.Account.Id id : g.getMembers().asList()) { com.google.gerrit.reviewdb.client.Account account; try { account = accounts.get(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { problems.add(error( %s (%s) has member %s with invalid configuration: %s g.getName(), g.getGroupUUID(), id, e.getMessage())); continue; } if (account == null) { problems.add(error( %s (%s) has nonexistent member %s g.getName(), g.getGroupUUID(), id)); } } return problems; }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkCycle(com.google.gerrit.server.group.InternalGroup root, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> todo = new java.util.LinkedHashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); todo.add(root); while (!(todo.isEmpty())) { com.google.gerrit.server.group.InternalGroup t = todo.iterator().next(); todo.remove(t); if (seen.contains(t)) { continue; } seen.add(t); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : t.getSubgroups()) { com.google.gerrit.server.group.InternalGroup g = byUUID.get(subUuid); if (g == null) { continue; } if (java.util.Objects.equals(g, root)) { problems.add(warning( %s (%s) contains a cycle: %s (%s) points to it as subgroup. root.getName(), root.getGroupUUID(), t.getName(), t.getGroupUUID())); } todo.add(g); } } return problems; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.TagResource resource) { return resource.getTagInfo(); }
private com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource parse(com.google.gerrit.server.project.ProjectState parent, com.google.gerrit.server.project.ProjectState current, com.google.gerrit.server.CurrentUser user, com.google.gerrit.extensions.api.projects.DashboardInfo info) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.AmbiguousObjectException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.IncorrectObjectTypeException { java.lang.String ref = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardsCollection.normalizeDashboardRef(info.ref); try { permissionBackend.user(user).project(parent.getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(ref))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource(current, user, ref, info.path, cfg, false); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } }
com.google.gerrit.server.api.projects.CommitApiImpl create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CommitResource r);
@org.junit.Test public void idInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = owners expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void ownerUuidOfNewGroupMustNotBeNull() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( UUID of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameOfNewGroupMustNotBeNull() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void ownerUuidCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( UUID of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void idInConfigMustNotBeNegative() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = -5 = owners expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void ownerUuidInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = 42 expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage( UUID of the <START_MOD>account<END_MOD> users-XYZ com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); }
@org.junit.Test public void nameInConfigMayBeUndefined() throws java.lang.Exception { populateGroupConfig(groupUuid,   = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().getName()).isEmpty(); }
@org.junit.Test public void nameCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@org.junit.Test public void nameOfNewGroupMustNotBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
private void populateGroupConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.String fileContent) throws java.lang.Exception { testRepository.branch(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)).commit().message( <START_MOD>account<END_MOD>.config fileContent).create(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if (com.google.gerrit.reviewdb.client.RefNames.isGroupRef(receiveEvent.command.getRefName())) { throw new com.google.gerrit.server.git.validators.CommitValidationException( update not allowed } return java.util.Collections.emptyList(); }
private static com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.PostReview.CommentSetEntry create(java.lang.String filename, int patchSetId, java.lang.Integer line, com.google.gerrit.extensions.client.Side side, com.google.common.hash.HashCode message, com.google.gerrit.reviewdb.client.Comment.Range range) { return new com.google.gerrit.server.change.AutoValue_PostReview_CommentSetEntry(filename, patchSetId, line, side, message, range); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log delete accounts from <START_MOD>account<END_MOD> event e); } } }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(actor, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log delete groups from <START_MOD>account<END_MOD> event e); } } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddAccountsToGroup(actor, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log add accounts to <START_MOD>account<END_MOD> event e); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.ChangeResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getChange().getTopic()); }
private void loadPluginSections(org.eclipse.jgit.lib.Config rc) { pluginConfigs = new java.util.HashMap(); for (java.lang.String plugin : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)) { org.eclipse.jgit.lib.Config pluginConfig = new org.eclipse.jgit.lib.Config(); pluginConfigs.put(plugin, pluginConfig); for (java.lang.String name : rc.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = rc.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); java.lang.String groupName = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if (groupName != null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if (ref == null) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((   + groupName) +   not in   + (GroupList.FILE_NAME)))); } rc.setString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, value); } pluginConfig.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } }
private void loadPermissionRules(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String varName, java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName, com.google.gerrit.common.data.Permission perm, boolean useRange) { for (java.lang.String ruleString : rc.getStringList(section, subsection, varName)) { com.google.gerrit.common.data.PermissionRule rule; try { rule = com.google.gerrit.common.data.PermissionRule.fromString(ruleString, useRange); } catch (java.lang.IllegalArgumentException notRule) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((((( rule in   + section) + (subsection != null ? "." + subsection : "")) + ".") + varName) +     + (notRule.getMessage())))); continue; } com.google.gerrit.common.data.GroupReference ref = groupsByName.get(rule.getGroup().getName()); if (ref == null) { ref = rule.getGroup(); groupsByName.put(ref.getName(), ref); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((   + (ref.getName())) +   not in   + (GroupList.FILE_NAME)))); } rule.setGroup(ref); perm.add(rule); } }
private void savePluginSections(org.eclipse.jgit.lib.Config rc, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> keepGroups) { java.util.List<java.lang.String> existing = com.google.common.collect.Lists.newArrayList(rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)); for (java.lang.String name : existing) { rc.unsetSection(com.google.gerrit.server.git.ProjectConfig.PLUGIN, name); } for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Config> e : pluginConfigs.entrySet()) { java.lang.String plugin = e.getKey(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); for (java.lang.String name : pluginConfig.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = pluginConfig.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); java.lang.String groupName = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if (groupName != null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if ((ref != null) && ((ref.getUUID()) != null)) { keepGroups.add(ref.getUUID()); pluginConfig.setString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, (   + (ref.getName()))); } } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(pluginConfig.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.MemberResource resource, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input in = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddMembers.Input(); in._oneMember = resource.getMember().getAccountId().toString(); return delete.get().apply(resource, in); }
public com.google.gerrit.common.data.GroupReference getGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return checkNotNull(uuids.get(uuid),   %s not found uuid.get()); }
public static com.google.gerrit.server.git.GroupList parse(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String text, com.google.gerrit.server.git.ValidationError.Sink errors) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.Row> rows = com.google.gerrit.server.git.GroupList.parse(text, com.google.gerrit.server.git.GroupList.FILE_NAME, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, errors); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.common.data.GroupReference> groupsByUUID = new java.util.HashMap(rows.size()); for (com.google.gerrit.server.git.Row row : rows) { if ((row.left) == null) { com.google.gerrit.server.git.GroupList.log.warn( field in <START_MOD>account<END_MOD> list for {}: project, text); continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(row.left); java.lang.String name = row.right; com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); } return new com.google.gerrit.server.git.GroupList(groupsByUUID); }
private static java.lang.String getAmbiguousNameMessage(java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.reviewdb.client.AccountGroup.UUID systemGroupUuid) { return java.lang.String.format(( configured name '%s' for system <START_MOD>account<END_MOD> '%s' is ambiguous + (( with the name '%s' of existing <START_MOD>account<END_MOD> '%s'. +   Please remove/change the value for groups.%s.name in +   gerrit.config. groupName, systemGroupUuid.get(), groupName, groupUuid.get(), systemGroupUuid.get()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); return com.google.common.base.Strings.nullToEmpty(group.getDescription()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gwtorm.server.OrmException { if (accountPatchReviewStore.get().markReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getPatchKey().getFileName())) { return com.google.gerrit.extensions.restapi.Response.created(""); } return com.google.gerrit.extensions.restapi.Response.ok(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gwtorm.server.OrmException { accountPatchReviewStore.get().clearReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getPatchKey().getFileName()); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, java.io.IOException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to index <START_MOD>account<END_MOD> } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID(); if (!(rsrc.isInternalGroup())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( Group Not Allowed: %s groupUuid.get())); } java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(groupUuid); if (group.isPresent()) { groupCache.evict(group.get().getGroupUUID(), group.get().getId(), group.get().getNameKey()); } return com.google.gerrit.extensions.restapi.Response.none(); }
public static void assertGroups(java.lang.Iterable<java.lang.String> expected, java.util.Set<java.lang.String> actual) { for (java.lang.String g : expected) { assertWithMessage(( <START_MOD>account<END_MOD>   + g)).that(actual.remove(g)).isTrue(); } assertWithMessage(( groups:   + actual)).that(actual).isEmpty(); }
public com.google.gerrit.extensions.api.access.ProjectAccessInfo apply(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(nameKey.get()); } return apply(new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(state, user.get())); }
private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo group = visibleGroups.get(id); if (group == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); group = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.GetAccess.INVISIBLE_SENTINEL; if (control.isVisible()) { group = groupJson.format(control.getGroup()); group.id = null; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.GetAccess.LOG.warn(( ignoring <START_MOD>account<END_MOD>   + id), e); group = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.GetAccess.INVISIBLE_SENTINEL; } visibleGroups.put(id, group); } return group; }
private java.util.Collection<com.google.gerrit.server.project.ProjectState> tree(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.project.ProjectState> tree = new java.util.LinkedHashMap<>(); for (com.google.gerrit.server.project.ProjectState ps : rsrc.getProjectState().tree()) { tree.put(ps.getNameKey(), ps); } tree.keySet().retainAll(permissionBackend.user(user).filter(ProjectPermission.ACCESS, tree.keySet())); return tree.values(); }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.lang.String project = rsrc.getName(); if (!(inherited)) { return scan(rsrc.getProjectState(), project, true); } java.util.List<java.util.List<com.google.gerrit.extensions.api.projects.DashboardInfo>> all = new java.util.ArrayList<>(); boolean setDefault = true; for (com.google.gerrit.server.project.ProjectState ps : tree(rsrc)) { java.util.List<com.google.gerrit.extensions.api.projects.DashboardInfo> list = scan(ps, project, setDefault); for (com.google.gerrit.extensions.api.projects.DashboardInfo d : list) { if (((d.isDefault) != null) && (java.lang.Boolean.TRUE.equals(d.isDefault))) { setDefault = false; } } if (!(list.isEmpty())) { all.add(list); } } return all; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource, com.google.gerrit.extensions.api.groups.OwnerInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( <START_MOD>account<END_MOD> owner } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( is required } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); if (!(internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID()))) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(owner.getGroupUUID()).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format( %s not found groupUuid)); } } return json.format(owner); }
@org.junit.Test public void ownerUuidOfNewGroupMustNotBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( UUID of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public void onChangeMerged(com.google.gerrit.server.Event event) { if ((!(allProjects.get().equals(event.getChange().project))) || (!(RefNames.REFS_CONFIG.equals(event.getChange().branch)))) { return; } try { syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.CreateGroupPermissionSyncer.log.error( sync create <START_MOD>account<END_MOD> permissions e); } }
@org.junit.Test public void nameInConfigMayBeEmpty() throws java.lang.Exception { populateGroupConfig(groupUuid,   = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().getName()).isEmpty(); }
protected static java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.index.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource proj = new com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource(projectState, self.get()); com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.extensions.common.ProjectInfo p : children.apply(proj)) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn( check permissions to expand child projects e); } return r; }
public com.google.gerrit.extensions.common.GroupInfo format(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return createGroupInfo(rsrc.getGroup(), rsrc::getControl); }
private static void checkSameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) { checkState(group.equals(groupControl.getGroup()),   <START_MOD>account<END_MOD> and groupControl do not match }
@java.lang.Override public void setReviewed(java.lang.String path, boolean reviewed) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FileResource, com.google.gerrit.extensions.common.Input> view; if (reviewed) { view = putReviewed; } else { view = deleteReviewed; } view.apply(files.parse(revision, com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)), new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException( update reviewed flag e); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CommitResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CommitResource parse(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId objectId; try { objectId = org.eclipse.jgit.lib.ObjectId.fromString(id.get()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(parent.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(objectId); rw.parseBody(commit); if (!(canRead(parent.getProjectState(), repo, commit))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (int i = 0; i < (commit.getParentCount()); i++) { rw.parseBody(rw.parseCommit(commit.getParent(i))); } return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CommitResource(parent, commit); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CommitsCollection.log.error(((( look up change for commit   + (commit.name())) +   in   + project), e); } return isReachableFrom(state, repo, commit, repo.getAllRefs()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BranchResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { checkIdentifiedUser(); java.lang.String uuid = id.get(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByPatchSetAuthor(dbProvider.get(), rev.getPatchSet().getId(), rev.getAccountId(), rev.getNotes())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource> list() { return list.get(); }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.CreateBranch create(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString name) { return createBranchFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource>> views() { return views; }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(0, ((id.length()) - (Constants.DOT_GIT_EXT.length()))); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } } return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource(state, user.get()); }
public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( Not Found: %s id)); } return rsrc; }
public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
@java.lang.Override public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DeleteDraftComment.Op op = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DeleteDraftComment.Op(rsrc.getComment().key); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.reviewdb.client.AccountGroup getExistingGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUuid).toList(); if ((accountGroups.size()) == 1) { return com.google.common.collect.Iterables.getOnlyElement(accountGroups); } else if (accountGroups.isEmpty()) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupUuid); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(( <START_MOD>account<END_MOD> UUID   + groupUuid)); } }
@org.junit.Test public void ownerUuidCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUuid,   = users = 42 = owners com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( UUID of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BranchResource parse(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic() ? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DraftCommentResource>> views() { return views; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (recursive) { return getTransitiveMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
public com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource getParent() { return parent; }
@org.junit.Test public void idOfNewGroupMustNotBeNegative() throws java.lang.Exception { com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id((-2))).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { expectedException.expectCause(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage( of the <START_MOD>account<END_MOD> users-XYZ groupConfig.commit(metaDataUpdate); } }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( <START_MOD>account<END_MOD> wasn automatically loaded } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource, com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); input = com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveGroup())) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format( delete groups from <START_MOD>account<END_MOD> %s internalGroup.getName())); } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupsToRemove = new java.util.HashSet<>(); for (java.lang.String subgroupIdentifier : input.groups) { com.google.gerrit.common.data.GroupDescription.Basic subgroup = groupsCollection.parse(subgroupIdentifier); subgroupsToRemove.add(subgroup.getGroupUUID()); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); try { removeSubgroups(groupUuid, subgroupsToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format( %s not found groupUuid)); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.SubgroupResource resource, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input in = new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.AddSubgroups.Input(); in.groups = com.google.common.collect.ImmutableList.of(resource.getMember().get()); return delete.get().apply(resource, in); }
com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.DeleteRef create(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.ProjectResource r);
private void postDeletion(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount()); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG); return apply(rsrc.getProjectState(), input); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { if (input == null) { input = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); } if (((input.label) != null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must match URL } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); if (((r.getRevisionResource()) != null) && (!(r.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( delete vote on non-current patch set } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), r.getChangeResource().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.DeleteVote.Op(projectCache.checkedGet(r.getChange().getProject()), r.getReviewerUser().getAccount(), rsrc.getLabel(), input)); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
@java.lang.Override public void run() { java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> names = (tryingAgain) ? retryOn : projectCache.all(); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : names) { com.google.gerrit.server.git.ProjectConfig config = projectCache.get(projectName).getConfig(); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { continue; } try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) { rename(md); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noProject) { continue; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException err) { com.google.gerrit.server.git.RenameGroupOp.log.error(((( rename <START_MOD>account<END_MOD>   + (oldName)) +   in   + projectName), err); } } if ((!(retryOn.isEmpty())) && (!(tryingAgain))) { tryingAgain = true; @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = start(5, java.util.concurrent.TimeUnit.MINUTES); } }
private void rename(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { boolean success = false; for (int attempts = 0; (!success) && (attempts < (com.google.gerrit.server.git.RenameGroupOp.MAX_TRIES)); attempts++) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { projectCache.evict(config.getProject()); return; } ref.setName(newName); md.getCommitBuilder().setAuthor(author); md.setMessage((((( <START_MOD>account<END_MOD>   + (oldName)) +   to   + (newName)) + "\n")); try { config.commit(md); projectCache.evict(config.getProject()); success = true; } catch (java.io.IOException e) { com.google.gerrit.server.git.RenameGroupOp.log.error(((((( not commit rename of <START_MOD>account<END_MOD>   + (oldName)) +   to   + (newName)) +   in   + (md.getProjectName().get())), e); try { java.lang.Thread.sleep(25); } catch (java.lang.InterruptedException wakeUp) { continue; } } } if (!success) { if (tryingAgain) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((( not rename <START_MOD>account<END_MOD>   + (oldName)) +   to   + (newName)) +   in   + (md.getProjectName().get()))); } else { retryOn.add(md.getProjectName()); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.ProjectResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.SetDefaultDashboard set = setDefault.get(); set.inherited = inherited; return set.apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>project.DashboardResource.projectDefault(resource.getProjectState(), resource.getUser()), input); }
private void renameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, java.lang.String newName) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = group.getGroupUUID(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(newName)).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, groupUpdate); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format( %s not found groupUuid)); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((( with name   + newName) +   already exists } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.project.CommitResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rsrc.getCommit(); com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getProjectState().getNameKey(); return includedIn.apply(project, commit.getId().getName()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server<START_MOD>.restapi<END_MOD>.group.GroupResource rsrc, NameInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException( <START_MOD>account<END_MOD> owner } else if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( is required } java.lang.String newName = input.name.trim(); if (newName.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException( is required } if (internalGroup.getName().equals(newName)) { return newName; } renameGroup(internalGroup, newName); return newName; }
@java.lang.Override java.lang.String groupPattern() { return <START_MOD>"(&(objectClass=account)(cn=${groupname}))"<END_MOD>; }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, path, parent); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byName(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.name(groupName.get()), (( name   + groupName) + "'")); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.<START_MOD>restapi.<END_MOD>group.GroupResource resource) { return resource.getName(); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byId(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.id(groupId), (( id   + groupId) + "'")); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(rejectEmptyCommit = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_NoFastForward() throws java.lang.Exception { assume().that(getSubmitType()).isNotEqualTo(SubmitType.FAST_FORWARD_ONLY); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); com.google.gerrit.extensions.api.changes.ChangeApi revert1 = gApi.changes().id(change.getChangeId()).revert(); approve(revert1.id()); revert1.current().submit(); com.google.gerrit.extensions.api.changes.ChangeApi revert2 = gApi.changes().id(change.getChangeId()).revert(); approve(revert2.id()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(((("Change " + (revert2.get()._number)) + ": Change could not be merged because the commit is empty. ") + "Project policy requires all commits to contain modifications to at least one file.")); revert2.current().submit(); }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(rejectEmptyCommit = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_FastForward() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput ci = new com.google.gerrit.extensions.common.ChangeInput(); ci.subject = "Empty change"; ci.project = project.get(); ci.branch = "master"; com.google.gerrit.extensions.api.changes.ChangeApi change = gApi.changes().create(ci); approve(change.id()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(((("Change " + (change.get()._number)) + ": Change could not be merged because the commit is empty. ") + "Project policy requires all commits to contain modifications to at least one file.")); change.current().submit(); }<END_MOD>
<START_MOD>public final com.google.gerrit.extensions.client.SubmitType configuredSubmitType() { java.lang.String raw = configuredSubmitTypeRaw(); return raw != null ? com.google.gerrit.extensions.client.SubmitType.valueOf(raw) : null; }<END_MOD>
<START_MOD>private native java.lang.String configuredSubmitTypeRaw();<END_MOD>
private void setSubmitType(com.google.gerrit.extensions.client.SubmitType newSubmitType<START_MOD>, com.google.gerrit.extensions.client.SubmitType newConfiguredSubmitType<END_MOD>) { int index = -1; if ((submitType) != null) { for (int i = 0; i < (submitType.getItemCount()); i++) { if (<START_MOD>newConfiguredSubmitType<END_MOD>.name().equals(submitType.getValue(i))) { index = i; <START_MOD>if (newConfiguredSubmitType == (com.google.gerrit.extensions.client.SubmitType.INHERIT)) { } <END_MOD>break; } } submitType.setSelectedIndex(index); setEnabledForUseContentMerge(); } }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(signedOffBy, result.useSignedOffBy()); setBool(contentMerge, result.useContentMerge()); setBool(newChangeForAllNotInTarget, result.createNewChangeForAllNotInTarget()); setBool(requireChangeID, result.requireChangeId()); if (com.google.gerrit.client.Gerrit.info().receive().enableSignedPush()) { setBool(enableSignedPush, result.enableSignedPush()); setBool(requireSignedPush, result.requireSignedPush()); } setBool(rejectImplicitMerges, result.rejectImplicitMerges()); setBool(privateByDefault, result.privateByDefault()); setBool(enableReviewerByEmail, result.enableReviewerByEmail()); setBool(matchAuthorToCommitterDate, result.matchAuthorToCommitterDate()); setSubmitType(result.submitType()<START_MOD>, result.configuredSubmitType()<END_MOD>); setState(result.state()); maxObjectSizeLimit.setText(result.maxObjectSizeLimit().configuredValue()); if ((result.maxObjectSizeLimit().inheritedValue()) != null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setText(AdminMessages.I.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value())); effectiveMaxObjectSizeLimit.setTitle(AdminMessages.I.globalMaxObjectSizeLimit(result.maxObjectSizeLimit().inheritedValue())); } else { effectiveMaxObjectSizeLimit.setVisible(false); } saveProject.setEnabled(false); initPluginOptions(result); initProjectActions(result); }
private <START_MOD>com.google.gerrit.server.account.externalids.ExternalId createUsername<END_MOD>(com.google.gerrit.reviewdb.client.Account<START_MOD>.Id accountId, java.lang.String username) throws com.google.gerrit.server.account.AccountUserNameException { if (com.google.common.base.Strings.isNullOrEmpty(username)) { return null; } if (!(com.google.gerrit.server.account.PutUsername.isValidUsername(username))) { throw new com.google.gerrit.server.account.AccountUserNameException(java.lang.String.format( assign user name   to account %s; name does not conform. username, accountId)); } return<END_MOD> com.google.gerrit.server.account.externalids.ExternalId<START_MOD>.create(com.google.gerrit.server.account.SCHEME_USERNAME, username, accountId<END_MOD>); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivateChanges", value = "true") public void createChangeWithDisablePrivateChangesTrue() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not supported"); gApi.changes().create(input); }<END_MOD>
<START_MOD>@org.junit.Test public void createChangeWithDisablePrivateChangesFalse() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true); }<END_MOD>
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivateChanges", value = "true") public void createChangeWithPrivateByDefaultAndDisablePrivateChangesTrue() throws java.lang.Exception { setPrivateByDefault(project2, InheritableBoolean.TRUE); com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project2.get(), "master", "empty change"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not supported"); gApi.changes().create(input); }<END_MOD>
@java.lang.Override public java.<START_MOD>util.SortedSet<END_MOD><com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String pfx) { com.google.gerrit.reviewdb.client.Project.NameKey start = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx); com.google.gerrit.reviewdb.client.Project.NameKey end = new com.google.gerrit.reviewdb.client.Project.NameKey((pfx + (java.lang.Character.MAX_VALUE))); try { return list.get(com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL).subSet(start, end); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn(( look up projects for prefix   + pfx), e); return java.util.Collections.<START_MOD>emptySortedSet<END_MOD>(); } }
@java.lang.Override public java.<START_MOD>util<END_MOD>.<START_MOD>SortedSet<END_MOD><com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { return java.util.Collections.<START_MOD>emptySortedSet<END_MOD>(); }
java.<START_MOD>util<END_MOD>.<START_MOD>SortedSet<END_MOD><com.google.gerrit.reviewdb.client.Project.NameKey> all();
@java.lang.Override public java.<START_MOD>util<END_MOD>.<START_MOD>SortedSet<END_MOD><com.google.gerrit.reviewdb.client.Project.NameKey> all() { return java.util.Collections.<START_MOD>emptySortedSet<END_MOD>(); }
java.<START_MOD>util<END_MOD>.<START_MOD>SortedSet<END_MOD><com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix);
public java.<START_MOD>util.stream.Stream<END_MOD><T> search(java.util.List<T> list) { com.google.gerrit.server.util.RegexListSearcher.checkNotNull(list); int begin; int end; if ( < (prefixLen)) { begin = find(list, prefixBegin); end = find(list, prefixEnd); } else { begin = 0; end = list.size(); } if (prefixOnly) { return <START_MOD>(<END_MOD>begin < end ? list.subList(begin, end) : com.google.common.collect.ImmutableList.<T>of()<START_MOD>).stream()<END_MOD>; } return <START_MOD>list.subList(begin, end).stream()<END_MOD>.filter(( x) -> pattern.run(<START_MOD>toStringFunc.<END_MOD>apply(x))); }
public static com.google.gerrit.server.util.RegexListSearcher<java.lang.String> ofStrings(java.lang.String re) { return new com.google.gerrit.server.util.RegexListSearcher(re<START_MOD>,<END_MOD> ( in) <START_MOD>-><END_MOD> in<START_MOD>)<END_MOD>; }
private int find(java.util.List<T> list, java.lang.String p) { int r = java.util.Collections.binarySearch(com.google.common.collect.Lists.transform(list, <START_MOD>toStringFunc<END_MOD>), p); return r <   ? -(r + 1) : r; }
private org.eclipse.jgit.internal.storage.dfs.InMemoryRepository add(com.google.gerrit.server.git.ProjectConfig pc) { com.google.gerrit.server.rules.PrologEnvironment.Factory envFactory = null; com.google.gerrit.server.rules.RulesCache rulesCache = null; com.google.gerrit.server.config.SitePaths sitePaths = null; java.util.List<com.google.gerrit.extensions.api.projects.CommentLinkInfo> commentLinks = null; org.eclipse.jgit.internal.storage.dfs.InMemoryRepository repo; try { repo = repoManager.createRepository(pc.getName()); if ((pc.getProject()) == null) { pc.load(repo); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(e); } all.put(pc.getName(), new com.google.gerrit.server.project.ProjectState(sitePaths, projectCache, allProjectsName, allUsersName, <START_MOD>null<END_MOD>, envFactory, repoManager, rulesCache, commentLinks, capabilityCollectionFactory, pc)); return repo; }
<START_MOD>public com.google.gerrit.server.account.AccountConfig setEagerLoading(boolean eagerLoading) { checkState(((loadedAccount) == null), "Account %s already loaded", accountId.get()); this.eagerLoading = eagerLoading; return this; }<END_MOD>
private java.util.Optional<com.google.gerrit.reviewdb.client.Account> loadAccount(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId commit<START_MOD>, @com.google.gerrit.common.Nullable java.util.List<java.lang.String> messages<END_MOD>) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { rw.reset(); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId); accountConfig.<START_MOD>setEagerLoading(true).<END_MOD>load(rw, commit); <START_MOD>if (messages != null) { messages.addAll(accountConfig.getValidationErrors().stream().map(ValidationError::getMessage).collect(java.util.stream.Collectors.toSet())); } <END_MOD>return accountConfig.getLoadedAccount(); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision) != null) { rw.reset(); rw.markStart(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config <START_MOD>accountConfig<END_MOD> = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadedAccount = java.util.Optional.of(parse(<START_MOD>accountConfig<END_MOD>, revision.name())); <START_MOD>watchConfig = new com.google.gerrit.server.account.WatchConfig(accountId, readConfig(WatchConfig.WATCH_CONFIG), this); if (eagerLoading) { watchConfig.parse(); } <END_MOD>} else { loadedAccount = java.util.Optional.empty(); } }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { <START_MOD>java.lang.String template = actionRequest.getParameter(1); if (!(template.isEmpty())) { java.lang.String comment = soyTextTemplate(<END_MOD>com.google.template.soy.SoyFileSet.builder<START_MOD>(), template, properties); its.addComment(issue, comment); } else { com.googlesource.gerrit.plugins.its.base.workflow.action.AddSoyComment.log.error( template name given in {}<END_MOD> actionRequest<START_MOD>); } }<END_MOD>
<START_MOD>@java.lang.Override<END_MOD> void logProperty(com.googlesource.gerrit.plugins.its.base.workflow.Property property) { com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.log.debug(<START_MOD>property.toString()<END_MOD>); }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level level = com.googlesource.gerrit.plugins.its.base.workflow.action.LogEvent.Level.<START_MOD>fromString<END_MOD>(<START_MOD>actionRequest<END_MOD>.<START_MOD>getParameter<END_MOD>(<START_MOD>1<END_MOD>)); for (com.googlesource.gerrit.plugins.its.base.workflow.Property property : properties) { <START_MOD>level.<END_MOD>logProperty(property); } }
public void BROKEN_testIsEnabledUnknownEvent() { com.google.gerrit.server.events.<START_MOD>ChangeEvent<END_MOD> event = <START_MOD>createMock(<END_MOD>com.google.gerrit.server.events.<START_MOD>ChangeEvent.class<END_MOD>); com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig(); replayMocks(); assertFalse(itsConfig.isEnabled(event)); assertLogMessageContains( recognised and ignored }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(<START_MOD>event instanceof com.google.gerrit.server.events.RefEvent)) { return; } com.google.gerrit.server.events.RefEvent refEvent = ((com.google.gerrit.server.events.RefEvent) (event)); if (!(<END_MOD>itsConfig.isEnabled(<START_MOD>refEvent<END_MOD>))) { return; } java.util.Set<java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property>> propertiesCollections = propertyExtractor.extractFrom(<START_MOD>refEvent<END_MOD>); for (java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties : propertiesCollections) { java.util.Collection<com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest> actions = ruleBase.actionRequestsFor(properties); if (!(actions.isEmpty())) { for (com.googlesource.gerrit.plugins.its.base.workflow.Property property : properties) { if ("issue".equals(property.getKey())) { java.lang.String issue = property.getValue(); actionExecutor.execute(issue, actions, properties); } } } } }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException<START_MOD>, java.io.IOException<END_MOD> { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( required } try { permissionBackend.user(currentUser).database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET); <START_MOD>projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite(); <END_MOD>} catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException( not permitted denied); } }
boolean canAddPatchSet() { return projectControl.controlForRef(("refs/for/" + (refName))).canPerform(Permission.ADD_PATCH_SET); }
private void ensureCanEditCommitMessage(com.google.gerrit.server.notedb.ChangeNotes changeNotes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException<START_MOD>, java.io.IOException<END_MOD> { if (!(currentUserProvider.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( required } try { permissionBackend.user(currentUserProvider.get()).database(db.get()).change(changeNotes).check(ChangePermission.ADD_PATCH_SET); <START_MOD>projectCache.checkedGet(changeNotes.getProjectName()).checkStatePermitsWrite(); <END_MOD>} catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException( commit message not permitted denied); } }
<START_MOD>public void checkStatePermitsWrite() throws com.google.gerrit.extensions.restapi.AuthException { if (!(getProject().getState().permitsWrite())) { throw new com.google.gerrit.extensions.restapi.AuthException("project state does not permit write"); } }<END_MOD>
@java.lang.Override public com.google.gerrit.server.restapi.change.Submit.Output apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { input.onBehalfOf = com.google.common.base.Strings.emptyToNull(input.onBehalfOf); com.google.gerrit.server.IdentifiedUser submitter; if ((input.onBehalfOf) != null) { submitter = onBehalfOf(rsrc, input); } else { rsrc.permissions().check(ChangePermission.SUBMIT); submitter = rsrc.getUser().asIdentifiedUser(); } <START_MOD>projectCache.checkedGet(rsrc.getProject()).statePermitsWrite(); <END_MOD>return new com.google.gerrit.server.restapi.change.Submit.Output(mergeChange(rsrc, submitter, input)); }
@org.junit.Test public void unblockForceEditTopicName() { block(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForce(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.DEVS); assertThat(u.controlForRef("refs/heads/master").<START_MOD>canPerform<END_MOD>(<START_MOD>Permission.EDIT_TOPIC_NAME<END_MOD>)).named( can edit topic name }
@org.junit.Test public void unblockInLocalForceEditTopicName_Fails() { block(parent, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForce(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.REGISTERED_USERS); assertThat(u.controlForRef("refs/heads/master").<START_MOD>canPerform<END_MOD>(<START_MOD>Permission.EDIT_TOPIC_NAME<END_MOD>)).named( can edit topic name }
private boolean canEditTopicName() { if (getChange().getStatus().isOpen()) { return ((((isOwner()) || (refControl.isOwner())) || (getProjectControl().isOwner())) || (refControl.<START_MOD>canPerform<END_MOD>(<START_MOD>Permission.EDIT_TOPIC_NAME<END_MOD>))) || (getProjectControl().isAdmin()); } return refControl.<START_MOD>canPerform<END_MOD>(<START_MOD>Permission.EDIT_TOPIC_NAME<END_MOD>); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case CREATE_TAG : return canPerform(Permission.CREATE_TAG); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + (refName))).canSubmit(true); case READ_PRIVATE_CHANGES : return <START_MOD>canPerform(Permission.VIEW_PRIVATE_CHANGES<END_MOD>); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().is(BooleanProjectConfig.USE_SIGNED_OFF_BY))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
private void loadExtensionPanelSections(org.eclipse.jgit.lib.Config rc) { java.util.Map<java.lang.String, java.lang.String> lowerNames = <START_MOD>new java.util.HashMap<><END_MOD>(2); extensionPanelSections = <START_MOD>new java.util.LinkedHashMap<><END_MOD>(); for (java.lang.String name : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANELS)) { java.lang.String lower = name.toLowerCase(); if (lowerNames.containsKey(lower)) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, java.lang.String.format( Panels   conflicts with   name, lowerNames.get(lower)))); } lowerNames.put(lower, name); extensionPanelSections.put(name, new java.util.ArrayList(java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANELS, name, com.google.gerrit.server.git.ProjectConfig.KEY_PANEL)))); } }
@java.lang.Override public org.eclipse.jgit.lib.Config getConfig() throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = com.googlesource.gerrit.plugins.gitiles.Resolver.getNameKey(req); com.google.gerrit.server.project.ProjectState state = projectCache.get(nameKey); if (state != null) { org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").getWithInheritance(); if (<START_MOD>(<END_MOD>cfg != null) <START_MOD>&& ((cfg.getSections().size()) > 0)) <END_MOD>{ return cfg; } } else { state = projectCache.getAllProjects(); org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").get(); if (<START_MOD>(<END_MOD>cfg != null) <START_MOD>&& ((cfg.getSections().size()) > 0)) <END_MOD>{ return cfg; } } <START_MOD>try { org.eclipse.jgit.lib.Config cfg = getGlobalConfig(); <END_MOD>return <START_MOD>cfg; } catch (java.lang.Exception e) { } return <END_MOD>new org.eclipse.jgit.lib.Config(); }
<START_MOD>private org.eclipse.jgit.lib.Config getGlobalConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.io.File sitePath = new java.io.File(".").getAbsoluteFile(); if (".".equals(sitePath.getName())) { sitePath = sitePath.getParentFile(); } java.io.File cfgFile = new java.io.File(sitePath, "etc/gitiles.config"); org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(cfgFile, org.eclipse.jgit.util.FS.DETECTED); if (cfg.getFile().exists()) { cfg.load(); } return cfg; }<END_MOD>
<START_MOD>@java.lang.Override public boolean equals(java.lang.Object o) { if (o == (this)) { return true; } if (o instanceof com.google.gerrit.extensions.api.projects.CommentLinkInfo) { com.google.gerrit.extensions.api.projects.CommentLinkInfo that = ((com.google.gerrit.extensions.api.projects.CommentLinkInfo) (o)); return ((((this.match) == null ? (that.match) == null : this.match.equals(that.match)) && ((this.link) == null ? (that.link) == null : this.link.equals(that.link))) && ((this.html) == null ? (that.html) == null : this.html.equals(that.html))) && ((this.enabled) == null ? (that.enabled) == null : this.enabled.equals(that.enabled)); } return false; }<END_MOD>
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(name); <START_MOD>try { <END_MOD>if (!(projectState.getProject().getState().permitsRead())) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } <START_MOD>} catch (java.lang.Exception e) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } <END_MOD>return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }
<START_MOD>@java.lang.Override public int hashCode() { int h = 1; h *= 1000003; h ^= ((this.message) == null) ? 0 : this.message.hashCode(); return h; }<END_MOD>
<START_MOD>@java.lang.Override public boolean equals(java.lang.Object o) { if (o == (this)) { return true; } if (o instanceof com.google.gerrit.server.git.ValidationError) { com.google.gerrit.server.git.ValidationError that = ((com.google.gerrit.server.git.ValidationError) (o)); return (this.message) == null ? (that.message) == null : this.message.equals(that.message); } return false; }<END_MOD>
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws<START_MOD> com.google.gerrit.extensions.restapi.ResourceConflictException,<END_MOD> com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws<START_MOD> com.google.gerrit.extensions.restapi.ResourceConflictException,<END_MOD> com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws<START_MOD> com.google.gerrit.extensions.restapi.ResourceConflictException,<END_MOD> com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( Not Found: %s id)); } return rsrc; }
<START_MOD>public void checkStatePermitsRead() throws com.google.gerrit.extensions.restapi.ResourceConflictException { if (!(statePermitsWrite())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("project state " + (getProject().getState().name())) + " does not permit read")); } }<END_MOD>
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return (isVisible()) && (getProjectControl().getProjectState().statePermitsRead()); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case SET_HEAD : return projectControl.isOwner(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case CREATE_TAG : <START_MOD>case CREATE_SIGNED_TAG : <END_MOD>return canPerform(<START_MOD>perm.name()); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + (refName))).canSubmit(true); case READ_PRIVATE_CHANGES : return canPerform(<END_MOD>Permission.<START_MOD>VIEW_PRIVATE_CHANGES); case READ_CONFIG<END_MOD> : return projectControl.controlForRef(<START_MOD>RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().is(BooleanProjectConfig.USE_SIGNED_OFF_BY))); } throw new <END_MOD>com.google.gerrit.server.<START_MOD>permissions.PermissionBackendException((perm<END_MOD> + <START_MOD>  unsupported<END_MOD> }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())<END_MOD>); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), <START_MOD>com.google.common.base.Suppliers.memoize(() -> <END_MOD>accountConfig.getProjectWatches()<START_MOD>)<END_MOD>,<START_MOD> com.google.common.base.Suppliers.memoize(() -><END_MOD> accountConfig.getGeneralPreferences())<START_MOD>)<END_MOD>; }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences())<START_MOD>, com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences())<END_MOD>)); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<END_MOD>))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<END_MOD>); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<END_MOD>); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<END_MOD>); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.<START_MOD>base.Suppliers.ofInstance(com.google.common.<END_MOD>collect.ImmutableMap.of()<START_MOD>)<END_MOD>, <START_MOD>com.google.common.base.Suppliers.ofInstance(<END_MOD>com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>)<END_MOD>; }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), <START_MOD>com.google.common.base.Suppliers.memoize(() -> <END_MOD>accountConfig.getProjectWatches()<START_MOD>), com.google.common.base.Suppliers.memoize(() -><END_MOD> accountConfig.getGeneralPreferences()))<START_MOD>)<END_MOD>; }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.<START_MOD>base.Suppliers.ofInstance(com.google.common.<END_MOD>collect.ImmutableMap.of()<START_MOD>), com.google.common.base.Suppliers.ofInstance(<END_MOD>com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())))<START_MOD>)<END_MOD>; assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences())<START_MOD>, com.google.common.base.Suppliers.memoize(() -> accountConfig.getEditPreferences())<END_MOD>); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision()) != null ? externalIds.byAccount(account.getId(), extIdNotes.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences())<START_MOD>, com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences())<END_MOD>); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.AccountConfig accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIdsRev().isPresent() ? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getProjectWatches()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getGeneralPreferences()), com.google.common.base.Suppliers.memoize(() -> accountConfig.getDiffPreferences())<START_MOD>, com.google.common.base.Suppliers.memoize(() -> accountConfig.getEditPreferences())<END_MOD>)); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39795bb25dc914118224995c53c5c36923a461"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())<END_MOD>))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())<END_MOD>); }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate.AccountUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<END_MOD>); com.google.gerrit.server.account.InternalAccountUpdate.Builder updateBuilder = com.google.gerrit.server.account.InternalAccountUpdate.builder(); updater.update(accountState, updateBuilder); com.google.gerrit.server.account.InternalAccountUpdate update = updateBuilder.build(); accountConfig.setAccountUpdate(update); com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes = createExternalIdNotes(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount updatedAccounts = new com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount(allUsersName, externalIds, message, accountConfig, extIdNotes); updatedAccounts.setCreated(true); return updatedAccounts; }).get(); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.<START_MOD>base.Suppliers.ofInstance(com.google.common.<END_MOD>collect.ImmutableMap.of()<START_MOD>), com.google.common.base.Suppliers.ofInstance(<END_MOD>com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>)<END_MOD>; }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())<START_MOD>, com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())<END_MOD>); }
private void saveProjectWatches() throws java.io.IOException { if ((accountUpdate.isPresent()) && ((!(accountUpdate.get().getDeletedProjectWatches().isEmpty())) || (!(accountUpdate.get().getUpdatedProjectWatches().isEmpty())))) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = <START_MOD>new java.util.HashMap(<END_MOD>watchConfig.getProjectWatches()<START_MOD>)<END_MOD>; accountUpdate.get().getDeletedProjectWatches().forEach(( pw) -> projectWatches.remove(pw)); accountUpdate.get().getUpdatedProjectWatches().forEach(( pw, nt) -> projectWatches.put(pw, nt)); saveConfig(WatchConfig.WATCH_CONFIG, watchConfig.save(<START_MOD>com.google.common.collect.ImmutableMap.copyOf(projectWatches)<END_MOD>)); } }
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>common.collect.ImmutableMap<END_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { checkLoaded(); return watchConfig.getProjectWatches(); }
@com.google.common.annotations.VisibleForTesting public static <START_MOD>com.google.common.collect.ImmutableMap<END_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.git.ValidationError.Sink validationErrorSink) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = new java.util.HashMap<>(); for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { java.lang.String[] notifyValues = cfg.getStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName, com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY); for (java.lang.String nv : notifyValues) { if (com.google.common.base.Strings.isNullOrEmpty(nv)) { continue; } com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue = com.google.gerrit.server.account.WatchConfig.NotifyValue.parse(accountId, projectName, nv, validationErrorSink); if (notifyValue == null) { continue; } com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key = com.google.gerrit.server.account.WatchConfig.ProjectWatchKey.create(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), notifyValue.filter()); if (!(projectWatches.containsKey(key))) { projectWatches.put(key, java.util.EnumSet.noneOf(com.google.gerrit.server.account.WatchConfig.NotifyType.class)); } projectWatches.get(key).addAll(notifyValue.notifyTypes()); } } return <START_MOD>com.google.common.collect.ImmutableMap.copyOf(<END_MOD>projectWatches<START_MOD>)<END_MOD>; }
public org.eclipse.jgit.lib.Config save(<START_MOD>com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches) { this.projectWatches = projectWatches; for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { cfg.unsetSection(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName); } com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> notifyValuesByProject = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (<END_MOD>java.util.Map<START_MOD>.Entry<END_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> <START_MOD>e : <END_MOD>projectWatches<START_MOD>.entrySet()<END_MOD>) { <START_MOD>com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue<END_MOD> = <START_MOD>com.google.gerrit.server.account.WatchConfig.NotifyValue.create(e.getKey().filter(), e.getValue()); notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString()); }<END_MOD> for (java.<START_MOD>util.Map.Entry<java.<END_MOD>lang.String<START_MOD>, java.util.Collection<java.lang.String>> e<END_MOD> : <START_MOD>notifyValuesByProject.asMap().entrySet()) { <END_MOD>cfg.<START_MOD>setStringList<END_MOD>(com.google.gerrit.server.account.WatchConfig.PROJECT<START_MOD>, e.getKey(), com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY, new java.util.ArrayList(e.getValue())); } return<END_MOD> cfg; }
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>common.collect.ImmutableMap<END_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { if ((projectWatches) == null) { parse(); } return projectWatches; }
public <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>common.collect.ImmutableMap<END_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { return projectWatches; }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate.AccountUpdater updater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.<START_MOD>base.Suppliers.ofInstance(com.google.common.<END_MOD>collect.ImmutableMap.of()<START_MOD>), com.google.common.base.Suppliers.ofInstance(<END_MOD>com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>)<END_MOD>; com.google.gerrit.server.account.InternalAccountUpdate.Builder updateBuilder = com.google.gerrit.server.account.InternalAccountUpdate.builder(); updater.update(accountState, updateBuilder); com.google.gerrit.server.account.InternalAccountUpdate update = updateBuilder.build(); accountConfig.setAccountUpdate(update); com.google.gerrit.server.account.externalids.ExternalIdNotes extIdNotes = createExternalIdNotes(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount updatedAccounts = new com.google.gerrit.server.account.AccountsUpdate.UpdatedAccount(allUsersName, externalIds, message, accountConfig, extIdNotes); updatedAccounts.setCreated(true); return updatedAccounts; }); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile(   if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (accounts.get(id)<START_MOD>.isPresent()) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); if (accounts.get(id).isPresent()) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.AccountState who = byId.getByUsername(nameOrEmail); if (who<END_MOD> != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(nameOrEmail); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.<START_MOD>base.Suppliers.ofInstance(com.google.common.<END_MOD>collect.ImmutableMap.of()<START_MOD>)<END_MOD>, <START_MOD>com.google.common.base.Suppliers.ofInstance(<END_MOD>com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())<START_MOD>)<END_MOD>; }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (<START_MOD>com.google.gerrit.server.project.RemoveReviewerControl.<END_MOD>canRemoveReviewerWithoutPermissionCheck(<START_MOD>permissionBackend, <END_MOD>notes.getChange(), currentUser, reviewer, val)) { return; } permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER); }
private <START_MOD>static <END_MOD>boolean canRemoveReviewerWithoutPermissionCheck(com.google.gerrit.<START_MOD>server.permissions.PermissionBackend permissionBackend, com.google.gerrit.<END_MOD>reviewdb.client.Change change, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.<START_MOD>permissions.PermissionBackendException, com.google.gerrit.server.<END_MOD>project.NoSuchProjectException, java.io.IOException { if (!(change.getStatus().isOpen())) { return false; } if (currentUser.isIdentifiedUser()) { com.google.gerrit.reviewdb.client.Account.Id aId = currentUser.getAccountId(); if (aId.equals(reviewer)) { return true; } else if ((aId.equals(change.getOwner())) && ( <= value)) { return true; } } com.google.gerrit.server.<START_MOD>permissions.PermissionBackend.WithUser withUser = permissionBackend.user(currentUser); com.google.gerrit.server.permissions.PermissionBackend.ForProject forProject = withUser.<END_MOD>project(change.getProject()); if (<START_MOD>(<END_MOD>com.google.gerrit.server.project.<START_MOD>RemoveReviewerControl.check(forProject.ref(change.getDest().get()), RefPermission.WRITE_CONFIG)) || (<END_MOD>com.google.gerrit.server.project.<START_MOD>RemoveReviewerControl.check(withUser, GlobalPermission.ADMINISTRATE_SERVER<END_MOD>))) { return true; } return false; }
public boolean testRemoveReviewer(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { if (<START_MOD>com.google.gerrit.server.project.RemoveReviewerControl.<END_MOD>canRemoveReviewerWithoutPermissionCheck(<START_MOD>permissionBackend, <END_MOD>cd.change(), currentUser, reviewer, value)) { return true; } return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { <START_MOD>parent.getProjectState().checkStatePermitsRead(); <END_MOD>if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void testSuggestedNonMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> ret; com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment ivc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.SUGGESTED<START_MOD>).atLeastOnce(); expect(itsConfig.getDummyIssuePattern()).andReturn(java.util.regex.Pattern.compile("x^")<END_MOD>).atLeastOnce(); expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce(); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getName()).andReturn("TestCommit").anyTimes(); expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new java.lang.String[]{ }).atLeastOnce(); replayMocks(); ret = ivc.onCommitReceived(event); assertEquals( of returned CommitValidationMessages does not match 1, ret.size()); assertTrue(( CommitValidationMessages does not contain     + "issue'"), ret.get(0).getMessage().contains( issue }
public java.lang.String getCommentLinkName() { java.lang.String ret; ret = getPluginConfigString("commentlink"<START_MOD>, null<END_MOD>); if (ret == null) { ret = pluginName; } return ret; }
<START_MOD>public java.util.regex.Pattern getDummyIssuePattern() { return java.util.regex.Pattern.compile(getPluginConfigString("dummyIssuePattern", "x^")); }<END_MOD>
public void testMandatoryNonMatching() { com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment ivc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY<START_MOD>).atLeastOnce(); expect(itsConfig.getDummyIssuePattern()).andReturn(java.util.regex.Pattern.compile("x^")<END_MOD>).atLeastOnce(); expect(commit.getFullMessage()).andReturn("TestMessage").atLeastOnce(); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getName()).andReturn("TestCommit").anyTimes(); expect(issueExtractor.getIssueIds("TestMessage")).andReturn(new java.lang.String[]{ }).atLeastOnce(); replayMocks(); try { ivc.onCommitReceived(event); fail( did not throw any exception } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { assertTrue(( of thrown CommitValidationException does not   +     issue e.getMessage().contains( issue } }
private java.lang.String getPluginConfigString(java.lang.String key<START_MOD>, java.lang.String defaultValue<END_MOD>) { <START_MOD>java.lang.String val =<END_MOD> getCurrentPluginConfig().getString(key, gerritConfig.getString(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.PLUGIN, pluginName, key)); <START_MOD>return val == null ? defaultValue : val; <END_MOD>}
<START_MOD>public void testOnlySkipMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> ret; com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment ivc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validation.ItsValidateComment.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDATORY).atLeastOnce(); expect(itsConfig.getDummyIssuePattern()).andReturn(java.util.regex.Pattern.compile("SKIP")).atLeastOnce(); expect(commit.getFullMessage()).andReturn("TestMessage SKIP").atLeastOnce(); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getName()).andReturn("TestCommit").anyTimes(); expect(issueExtractor.getIssueIds("TestMessage SKIP")).andReturn(new java.lang.String[]{ }).atLeastOnce(); replayMocks(); ret = ivc.onCommitReceived(event); assertEmptyList(ret); }<END_MOD>
@java.lang.Override @com.google.gerrit.common.Nullable public synchronized <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.server.account.AccountState<START_MOD>><END_MOD> getByUsername(java.lang.String username) { return <START_MOD>java.util.Optional.ofNullable(<END_MOD>byUsername.get(username)<START_MOD>)<END_MOD>; }
<START_MOD>private java.util.Optional<java.lang.String> readProjectConfig(java.lang.String projectName) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName))) { org.eclipse.jgit.junit.TestRepository<?> tr = new org.eclipse.jgit.junit.TestRepository(repo); org.eclipse.jgit.revwalk.RevWalk rw = tr.getRevWalk(); org.eclipse.jgit.lib.Ref ref = repo.exactRef(RefNames.REFS_CONFIG); if (ref == null) { return java.util.Optional.empty(); } org.eclipse.jgit.lib.ObjectLoader obj = rw.getObjectReader().open(tr.get(rw.parseTree(ref.getObjectId()), com.google.gerrit.acceptance.rest.project.PROJECT_CONFIG), com.google.gerrit.acceptance.rest.project.OBJ_BLOB); return java.util.Optional.of(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8)); } }<END_MOD>
<START_MOD>public <T> T executeIndexQuery(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException { try { return retryHelper.execute(ActionType.INDEX_QUERY, action, ( t) -> t instanceof com.google.gwtorm.server.OrmException); } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfUnchecked(t); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }<END_MOD>
<START_MOD>private <T> T executeWithAttempCount<END_MOD>(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action<START_MOD>, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate<END_MOD>) throws java.<START_MOD>lang.Throwable<END_MOD> { <START_MOD>com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); <END_MOD>return <START_MOD>executeWithTimeoutCount<END_MOD>(actionType, action, <START_MOD>retryerBuilder.build()<END_MOD>); }<START_MOD> finally { metrics.attemptCounts.record(actionType, listener.getAttemptCount()); } }<END_MOD>
<START_MOD>public<END_MOD> <T> T execute(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.<START_MOD>Exception { try { return executeWithAttempCount(actionType, action, opts, exceptionPredicate); } catch (java.lang.<END_MOD>Throwable<START_MOD> t)<END_MOD> { com.google.<START_MOD>common<END_MOD>.<START_MOD>base<END_MOD>.<START_MOD>Throwables<END_MOD>.<START_MOD>throwIfUnchecked(t);<END_MOD> com.google.<START_MOD>common<END_MOD>.<START_MOD>base<END_MOD>.<START_MOD>Throwables<END_MOD>.<START_MOD>throwIfInstanceOf(t, java<END_MOD>.<START_MOD>lang.Exception.class<END_MOD>); <START_MOD>throw<END_MOD> <START_MOD>new<END_MOD> <START_MOD>java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>IllegalStateException<END_MOD>(<START_MOD>t<END_MOD>); } }
<START_MOD>private com.google.gerrit.server.group.InternalGroup createGroupInNoteDbWithRetry(com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryHelper.ActionType.GROUP_UPDATE, () -> createGroupInNoteDb(groupCreation, groupUpdate), com.google.gerrit.server.git.LockFailureException.class::isInstance); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmDuplicateKeyException.class); throw new java.io.IOException(e); } }<END_MOD>
<START_MOD>private <T> T executeAccountUpdate(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(ActionType.ACCOUNT_UPDATE, action, ( t) -> t instanceof com.google.gerrit.server.git.LockFailureException); } catch (java.lang.Exception t) { com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }<END_MOD>
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.<START_MOD>OrmDuplicateKeyException<END_MOD>, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.db.GroupNameNotes groupNameNotes = com.google.gerrit.server.group.db.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(allUsersRepo, groupConfig, groupNameNotes); return groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException( group wasn automatically loaded } }
<START_MOD>private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDbWithRetry(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryHelper.ActionType.GROUP_UPDATE, () -> updateGroupInNoteDb(groupUuid, groupUpdate), com.google.gerrit.server.git.LockFailureException.class::isInstance); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmDuplicateKeyException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.common.errors.NoSuchGroupException.class); throw new java.io.IOException(e); } }<END_MOD>
private com.google.gerrit.reviewdb.client.Account updateAccount(com.google.gerrit.server.account.AccountsUpdate.AccountUpdate accountUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return <START_MOD>executeAccountUpdate<END_MOD>(() -> { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.UpdatedAccount updatedAccount = accountUpdate.update(allUsersRepo); if (updatedAccount == null) { return null; } commit(allUsersRepo, updatedAccount); return updatedAccount.getAccount(); } }); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); <START_MOD>parent.getProjectState().checkStatePermitsRead(); <END_MOD>try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic() ? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException {<START_MOD> rsrc.getProjectState().checkStatePermitsRead();<END_MOD> return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.BranchInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring).regex(matchRegex).start(start).limit(limit).filter(allBranches(rsrc)); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws<START_MOD> com.google.gerrit.extensions.restapi.ResourceConflictException,<END_MOD> com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.IdString.fromUrl(((ref + ':') + path))); }
private com.google.gerrit.server.project.DashboardResource resource() throws<START_MOD> com.google.gerrit.extensions.restapi.ResourceConflictException,<END_MOD> com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.<START_MOD>ResourceConflictException, com.google.gerrit.extensions.restapi.<END_MOD>ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.restapi.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.restapi.project.DashboardsCollection.newDashboardInfo(id.get()); } catch (com.google.gerrit.server.restapi.project.DashboardsCollection.InvalidDashboardId e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException<END_MOD> { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.restapi.change.ChangesCollection.toIdString(id)); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.restapi.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(change, user.get()); }
@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage =   to modify void addChange(java.lang.String token) { try { changeArgumentParser.addChange(token, changes, projectState); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { throw new java.lang.IllegalArgumentException(e.getMessage(), e); } catch (<START_MOD>java.io.IOException | <END_MOD>com.google.gwtorm.server.OrmException e) { throw new java.lang.IllegalArgumentException( is down e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.IllegalArgumentException( check permissions e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.restapi.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( %s not found id.get())); } catch (<START_MOD>java.io.IOException | <END_MOD>com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.restapi.account.StarredChanges.log.error( resolve change e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( server error } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException<START_MOD>, java.io.IOException<END_MOD> { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( changes found for   + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
private boolean isVisible(com.google.gerrit.server.restapi.change.RelatedChangesSorter.PatchSetData psd<START_MOD>) throws com.google.gerrit.server.permissions.PermissionBackendException<END_MOD>,<START_MOD> java.io.IOException {<END_MOD> com.google.gerrit.server.permissions.PermissionBackend.WithUser perm<START_MOD> = permissionBackend.user(currentUserProvider<END_MOD>).<START_MOD>database(dbProvider);<END_MOD> try { perm.change(psd.data()).check(ChangePermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } <START_MOD>return projectCache.checkedGet(psd.data().project()).statePermitsRead(); <END_MOD>}
<START_MOD>public <END_MOD>void sort(java.lang.String ref, java.util.List<com.google.gerrit.common.data.AccessSection> sections) { final int cnt = sections.size(); if (cnt <= 1) { return; } com.google.gerrit.server.project.SectionSortCache.EntryKey key = com.google.gerrit.server.project.SectionSortCache.EntryKey.create(ref, sections); com.google.gerrit.server.project.SectionSortCache.EntryVal val = cache.getIfPresent(key); if (val != null) { int[] srcIdx = val.order; if (srcIdx != null) { com.google.gerrit.common.data.AccessSection[] srcList = com.google.gerrit.server.project.SectionSortCache.copy(sections); for (int i = 0; i < cnt; i++) { sections.set(i, srcList[srcIdx[i]]); } } else { } } else { boolean poison = false; java.util.IdentityHashMap<com.google.gerrit.common.data.AccessSection, java.lang.Integer> srcMap = new java.util.IdentityHashMap<>(); for (int i = 0; i < cnt; i++) { poison |= (srcMap.put(sections.get(i), i)) != null; } java.util.Collections.sort(sections, new com.google.gerrit.server.util.MostSpecificComparator(ref)); int[] srcIdx; if (com.google.gerrit.server.project.SectionSortCache.isIdentityTransform(sections, srcMap)) { srcIdx = null; } else { srcIdx = new int[cnt]; for (int i = 0; i < cnt; i++) { srcIdx[i] = srcMap.get(sections.get(i)); } } if (poison) { com.google.gerrit.server.project.SectionSortCache.log.error( duplicate AccessSection instances, not caching sort } else { cache.put(key, new com.google.gerrit.server.project.SectionSortCache.EntryVal(srcIdx)); } } }
@org.junit.Test public void noteDbCommit() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.common.ChangeInfo c = assertCreateSucceeds(newChangeInput(ChangeStatus.NEW)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(repo.exactRef(changeMetaRef(new com.google.gerrit.reviewdb.client.Change.Id(c._number))).getObjectId()); assertThat(commit.getShortMessage()).isEqualTo( change org.eclipse.jgit.lib.PersonIdent expectedAuthor = changeNoteUtil.newIdent(accountCache.<START_MOD>maybeGet(admin.id).<END_MOD>get().getAccount(), c.created, serverIdent.get()); assertThat(commit.getAuthorIdent()).isEqualTo(expectedAuthor); assertThat(commit.getCommitterIdent()).isEqualTo(new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), c.created)); assertThat(commit.getParentCount()).isEqualTo(0); } }
@org.junit.Test public void getExternalIdsOfOtherUserWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.<START_MOD>maybeGet(admin.getId()).<END_MOD>get().getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get((("/accounts/" + (admin.id)) + "/external.ids")); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@org.junit.Test public void getExternalIds() throws java.lang.Exception { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.<START_MOD>maybeGet(user.getId()).<END_MOD>get().getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
private void assertUserBranch(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String name, @com.google.gerrit.common.Nullable java.lang.String status) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader()) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); assertThat(ref).isNotNull(); org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); long timestampDiffMs = java.lang.Math.abs((((c.getCommitTime()) * 1000L) - (accountCache.<START_MOD>maybeGet(accountId).<END_MOD>get().getAccount().getRegisteredOn().getTime()))); assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(or, AccountProperties.ACCOUNT_CONFIG, c.getTree())) { if ((name != null) || (status != null)) { assertThat(tw).isNotNull(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(new java.lang.String(or.open(tw.getObjectId(0), com.google.gerrit.acceptance.api.accounts.OBJ_BLOB).getBytes(), java.nio.charset.StandardCharsets.UTF_8)); assertThat(cfg.getString(AccountProperties.ACCOUNT, null, AccountProperties.KEY_FULL_NAME)).isEqualTo(name); assertThat(cfg.getString(AccountProperties.ACCOUNT, null, AccountProperties.KEY_STATUS)).isEqualTo(status); } else { assertThat(tw).isNull(); } } } }
@org.junit.Test public void getDetail() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/accounts/" + (admin.username)) + "/detail/")); com.google.gerrit.server.restapi.account.GetDetail.AccountDetailInfo info = newGson().fromJson(r.getReader(), com.google.gerrit.server.restapi.account.GetDetail.AccountDetailInfo.class); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.reviewdb.client.Account account = accountCache.<START_MOD>maybeGet<END_MOD>(admin.getId()<START_MOD>).get(<END_MOD>).getAccount(); assertThat(info.registeredOn).isEqualTo(account.getRegisteredOn()); }
private void addNoteDbCommit(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String commitMessage) throws java.lang.Exception { if (!(notesMigration.commitChangeWrites())) { return; } org.eclipse.jgit.lib.PersonIdent committer = serverIdent.get(); org.eclipse.jgit.lib.PersonIdent author = noteUtil.newIdent(accountCache.<START_MOD>maybeGet<END_MOD>(admin.getId()<START_MOD>).get(<END_MOD>).getAccount(), committer.getWhen(), committer); serverSideTestRepo.branch(com.google.gerrit.reviewdb.client.RefNames.changeMetaRef(id)).commit().author(author).committer(committer).message(commitMessage).create(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.<START_MOD>maybeGet<END_MOD>(id).<START_MOD>map(AccountState::<END_MOD>getEditPreferences<START_MOD>).orElseThrow<END_MOD>(<START_MOD>ResourceNotFoundException::new<END_MOD>); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.<START_MOD>maybeGet<END_MOD>(id).<START_MOD>map(AccountState::<END_MOD>getDiffPreferences<START_MOD>).orElseThrow<END_MOD>(<START_MOD>ResourceNotFoundException::new<END_MOD>); }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.server.permissions.PermissionBackendException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.<START_MOD>maybeGet<END_MOD>(id).<START_MOD>map(AccountState::<END_MOD>getGeneralPreferences<START_MOD>).orElseThrow<END_MOD>(<START_MOD>ResourceNotFoundException::new<END_MOD>); }
public java.time.Duration getDefaultTimeout(<START_MOD>com.google.gerrit.server.update.RetryHelper.ActionType actionType<END_MOD>) {<START_MOD> switch (actionType) { case ACCOUNT_UPDATE : case CHANGE_UPDATE : return noteDbDefaultTimeout; case INDEX_QUERY : default :<END_MOD> return defaultTimeout; }<START_MOD> }<END_MOD>
private <T> T executeWithAttemptCount(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Throwable { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.github.rholder.retry.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(<START_MOD>actionType, <END_MOD>opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return executeWithTimeoutCount(actionType, action, retryerBuilder.build()); } finally { metrics.attemptCounts.record(actionType, listener.getAttemptCount()); } }
<START_MOD>private static java.util.Optional<com.google.gerrit.reviewdb.client.Account> getAccount(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState accountState = accountCache.getOrNull(accountId); return java.util.Optional.ofNullable(accountState).map(AccountState::getAccount); }<END_MOD>
<START_MOD>@org.junit.Test public void createdOnOfNewGroupMatchesCreatedOnOfReloadedGroup() throws java.lang.Exception { java.sql.Timestamp createdOn = java.sql.Timestamp.from(java.time.LocalDateTime.of(2017, java.time.Month.DECEMBER, 1, 17, 49, 13, 123).atOffset(java.time.ZoneOffset.UTC).toInstant()); com.google.gerrit.server.group.db.InternalGroupCreation groupCreation = getPrefilledGroupCreationBuilder().build(); com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.db.InternalGroupUpdate.builder().setUpdatedOn(createdOn).build(); com.google.gerrit.server.group.db.GroupConfig groupConfig = com.google.gerrit.server.group.db.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate()) { groupConfig.commit(metaDataUpdate); } com.google.gerrit.server.group.InternalGroup createdGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.server.group.InternalGroup loadedGroup = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repository, createdGroup.getGroupUUID()).getLoadedGroup().get(); assertThat(createdGroup.getCreatedOn()).isEqualTo(loadedGroup.getCreatedOn()); }<END_MOD>
public com.google.gerrit.server.IdentifiedUser parseOnBehalfOf(@com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseIdOnBehalfOf(caller, id); if (<START_MOD>(<END_MOD>user == null) <START_MOD>|| (!(accountControlFactory.get().canSee(user.getAccount())))) <END_MOD>{ throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format( <START_MOD>doesn represent an account or is ambiguous<END_MOD> id)); } <START_MOD>return user<END_MOD>; }
@java.lang.Override public com.google.gerrit.server.account.AccountResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseId(id.get()); if (<START_MOD>(<END_MOD>user == null) <START_MOD>|| (!(accountControlFactory.get().canSee(user.getAccount())))) <END_MOD>{ throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(<START_MOD>java.lang.String.format( doesn represent an account or is ambiguous <END_MOD>id)<START_MOD>)<END_MOD>; } <START_MOD>return<END_MOD> new com.google.gerrit.<START_MOD>server.account.AccountResource(user<END_MOD>); }
<START_MOD>@org.junit.Test public void reduceComplexTreeToSingleValue() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.and(com.google.gerrit.extensions.conditions.BooleanCondition.or(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION), com.google.gerrit.extensions.conditions.BooleanCondition.not(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true))).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)); }<END_MOD>
<START_MOD>@org.junit.Test public void reduceOr() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.or(true, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.or(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION, com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true)).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.or(false, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.or(false, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION)); }<END_MOD>
<START_MOD>@org.junit.Test public void reduceNot() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.not(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true)).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.not(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.not(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.not(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION)); }<END_MOD>
<START_MOD>@org.junit.Test public void reduceAnd() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.and(false, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.and(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION, com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false)); assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.and(true, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.and(true, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION)); }<END_MOD>
<START_MOD>@org.junit.Test public void reduceComplexTreeToSmallerTree() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.conditions.BooleanCondition.and(com.google.gerrit.extensions.conditions.BooleanCondition.or(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION), com.google.gerrit.extensions.conditions.BooleanCondition.or(com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true), com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(false))).reduce()).isEqualTo(com.google.gerrit.extensions.conditions.BooleanCondition.and(com.google.gerrit.extensions.conditions.BooleanCondition.or(com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION, com.google.gerrit.extensions.conditions.BooleanConditionTest.NO_TRIVIAL_EVALUATION), com.google.gerrit.extensions.conditions.BooleanCondition.valueOf(true))); }<END_MOD>
<START_MOD>private static boolean evaluatesTriviallyToExpectedValue(com.google.gerrit.extensions.conditions.BooleanCondition cond, boolean expectedValue) { if (!(cond.evaluatesTrivially())) { return false; } return (cond.value()) == expectedValue; }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.GeneralPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } checkDownloadScheme(input.downloadScheme); com.google.gerrit.server.account.Preferences.validateMy(input.my); com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); <START_MOD>accountsUpdateProvider.get<END_MOD>().update( General Preferences via API id, ( u) -> u.setGeneralPreferences(input)); return cache.get(id).getGeneralPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.EditPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be provided } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); <START_MOD>accountsUpdateProvider.get<END_MOD>().update( Diff Preferences via API id, ( u) -> u.setEditPreferences(input)); return accountCache.get(id).getEditPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.DiffPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException( must be provided } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); <START_MOD>accountsUpdateProvider.get<END_MOD>().update( Diff Preferences via API id, ( u) -> u.setDiffPreferences(input)); return accountCache.get(id).getDiffPreferences(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::<START_MOD>maybeGet).filter(java.util.Optional::isPresent).map(java.util.Optional::<END_MOD>get).map(AccountState::getAccount).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((user != null) && (user.isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser who = user.asIdentifiedUser(); req.setAttribute(com.google.gerrit.httpd.GetUserFilter.REQ_ATTR_KEY, who.getUserName().<START_MOD>orElse<END_MOD>(("a/" + (who.getAccountId())))<START_MOD>)<END_MOD>; } chain.doFilter(req, resp); }
public org.eclipse.jgit.lib.PersonIdent newCommitterIdent(java.util.Date when, java.util.TimeZone tz) { final com.google.gerrit.reviewdb.client.Account ua = getAccount(); java.lang.String name = ua.getFullName(); java.lang.String email = ua.getPreferredEmail(); if ((email == null) || (email.isEmpty())) { java.lang.String user = getUserName()<START_MOD>.orElse((<END_MOD>"account-" + (ua.getId().toString())<START_MOD>));<END_MOD> java.lang.String host; if ((canonicalUrl.get()) != null) { try { host = new java.net.URL(canonicalUrl.get()).getHost(); } catch (java.net.MalformedURLException e) { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } } else { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } email = (user + "@") + host; } if ((name == null) || (name.isEmpty())) { final int at = email.indexOf('@'); if ( < at) { name = email.substring(0, at); } else { name = anonymousCowardName; } } return new org.eclipse.jgit.lib.PersonIdent(name, email, when, tz); }
private java.lang.Iterable<java.lang.String> getUsernames(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { java.util.Set<java.lang.String> emails = user.asIdentifiedUser().getEmailAddresses(); if (<START_MOD>!(user.getUserName().isPresent())<END_MOD>) { return emails; } else if (emails.isEmpty()) { return com.google.common.collect.<START_MOD>Streams.stream(user.getUserName()).collect(toImmutableSet()); } return com.google.common.collect.Streams<END_MOD>.concat(emails<START_MOD>.stream()<END_MOD>, com.google.common.collect.<START_MOD>Streams.stream(user.getUserName())).collect(toImmutableSet()); } return com.google.common.collect.Streams.stream(user.getUserName()).collect(toImmutableSet()); }<END_MOD>
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd<START_MOD>, com.google.common.collect.ListMultimap<java.lang.String, ?> parameters<END_MOD>) { if (dcmd == null) { return   was already destroyed } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] args = dcmd.getArguments(); commandName.append(".").append(args[<START_MOD>1<END_MOD>]); <START_MOD>for (java.lang.String key : parameters.keys()) { for (java.lang.Object value : parameters.get(key)) { if (key.toString().startsWith("$")) { commandName.append(".").append(value); } } } for (java.lang.String key : parameters.keys()) { for (java.lang.Object value : parameters.get(key)) { if (!(key.toString().startsWith("$"))) { commandName.append(".").append(key).append(".").append(value); } } <END_MOD>} return commandName.toString(); }
<START_MOD>public boolean isSensitiveParameters(java.lang.String params) { return (this.sensitiveParameters) == null ? false : sensitiveParameters.contains(params); }<END_MOD>
<START_MOD>public void addSensitiveParameters(java.lang.String sensitiveParameters) { if ((this.sensitiveParameters) == null) { this.sensitiveParameters = new java.util.HashSet<>(); } this.sensitiveParameters.add(sensitiveParameters); }<END_MOD>
<START_MOD>public java.util.Set<java.lang.String> getSensitiveParamters() { return this.sensitiveParameters; }<END_MOD>
<START_MOD>public void setSensitiveParamaters(java.util.Set<java.lang.String> set) { this.sensitiveParameters = set; }<END_MOD>
private com.google.common.collect.ListMultimap<java.lang.String, ?> extractParameters(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return com.google.common.collect.MultimapBuilder.hashKeys(0).arrayListValues(0).build(); } java.lang.String[] cmdArgs = dcmd.getArguments(); java.lang.String paramName = null; int argPos = 0; com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> parms = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (int i = 2; i < (cmdArgs.length); i++) { java.lang.String arg = cmdArgs[i]; if (arg.equals("--")) { for (i++; i < (cmdArgs.length); i++) { parms.put(("$" + (argPos++)), cmdArgs[i]); } break; } int eqPos = arg.indexOf('='); if ((arg.startsWith("--")) && (eqPos > 0)) { <START_MOD>java.lang.String parm = arg.substring(0, eqPos); <END_MOD>parms.put(<START_MOD>parm, (dcmd.isSensitiveParameters(parm) ? com.google.gerrit.sshd.SshLog.MASK : <END_MOD>arg.substring(<START_MOD>(<END_MOD>eqPos + 1<START_MOD>)<END_MOD>))); continue; } if (arg.startsWith("-")) { if (paramName != null) { parms.put(paramName, null); } paramName = arg; continue; } if (paramName == null) { parms.put(("$" + (argPos++)), arg); } else { parms.put(paramName, <START_MOD>(dcmd.isSensitiveParameters(paramName) ? com.google.gerrit.sshd.SshLog.MASK : arg)<END_MOD>); paramName = null; } } if (paramName != null) { parms.put(paramName, null); } return parms; }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw die(msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty() ?   Code Review : getName()) +     + (commandName)) +   not found throw die(msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) { bc.setName(commandName); } else { bc.setName((((getName()) +     + (commandName))); }<START_MOD> checkSensitiveData(bc);<END_MOD> bc.setArguments(args.toArray(new java.lang.String[args.size()])); } else if (!(args.isEmpty())) { throw die(((commandName) +   does not take arguments } provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); <START_MOD>this.setSensitiveParamaters(((com.google.gerrit.sshd.BaseCommand) (cmd)).getSensitiveParamters()); <END_MOD>} catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes(com.google.gerrit.sshd.ENC)); err.flush(); onExit(e.exitCode); } }
void onExecute(com.google.gerrit.sshd.DispatchCommand dcmd, int exitValue, com.google.gerrit.sshd.SshSession sshSession) { final com.google.gerrit.sshd.SshScope.Context ctx = context.get(); ctx.finished = com.google.gerrit.common.TimeUtil.nowMs(); <START_MOD>com.google.common.collect.ListMultimap<<END_MOD>java.lang.String<START_MOD>, ?> parameters = extractParameters(dcmd); java.lang.String<END_MOD> cmd = extractWhat(dcmd<START_MOD>, parameters<END_MOD>); final org.apache.log4j.spi.LoggingEvent event = log(cmd); event.setProperty(com.google.gerrit.sshd.SshLog.P_WAIT, (((ctx.started) - (ctx.created)) + "ms")); event.setProperty(com.google.gerrit.sshd.SshLog.P_EXEC, (((ctx.finished) - (ctx.started)) + "ms")); final java.lang.String status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status = "killed"; break; case BaseCommand.STATUS_NOT_FOUND : status = "not-found"; break; case BaseCommand.STATUS_NOT_ADMIN : status = "not-admin"; break; default : status = java.lang.String.valueOf(exitValue); break; } event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, status); java.lang.String peerAgent = sshSession.getPeerAgent(); if (peerAgent != null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_AGENT, peerAgent); } if ((async) != null) { async.append(event); } audit(<START_MOD>ctx, status, extractWhat(<END_MOD>dcmd<START_MOD>, parameters), parameters<END_MOD>); }
<START_MOD>private com.google.gerrit.common.data.SubmitTypeRecord logActionRuleError(java.lang.String err) { com.google.gerrit.server.project.ChangeControl.log.error(err); return actionRuleError("Error evaluating project action rules, check server log"); }<END_MOD>
<START_MOD>private com.google.gerrit.common.data.SubmitTypeRecord logInvalidAction(com.googlecode.prolog_cafe.lang.Term rule, com.googlecode.prolog_cafe.lang.Term record) { return logActionRuleError(((((((("Submit action rule " + rule) + " for change ") + (change.getId())) + " of ") + (getProject().getName())) + " output invalid result: ") + record)); }<END_MOD>
<START_MOD>private com.google.gerrit.common.data.SubmitTypeRecord logActionRuleError(java.lang.String err, java.lang.Exception e) { com.google.gerrit.server.project.ChangeControl.log.error(err, e); return actionRuleError("Error evaluating project action rules, check server log"); }<END_MOD>
<START_MOD>private com.google.gerrit.common.data.SubmitTypeRecord actionRuleError(java.lang.String err) { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.common.data.SubmitTypeRecord(); rec.status = SubmitTypeRecord.Status.RULE_ERROR; rec.errorMessage = err; return rec; }<END_MOD>
@java.lang.Override protected void configure() { if ((gerritConfig.getString(pluginName, null, "url")) != null) { com.googlesource.gerrit.plugins.its.jira.JiraModule.LOG.info( is configured as ITS bind(com.googlesource.gerrit.plugins.its.<START_MOD>jira.JiraConfig.class); bind(com.googlesource.gerrit.plugins.its.<END_MOD>base.its.ItsFacade.class).<START_MOD>to<END_MOD>(com.googlesource.gerrit.plugins.its.jira.JiraItsFacade<START_MOD>.class).asEagerSingleton<END_MOD>(); install(new com.googlesource.gerrit.plugins.its.base.ItsHookModule(pluginName, pluginCfgFactory)); } }
<START_MOD>@org.junit.Test public void gerritConfigContainsSaneValues() throws java.lang.Exception { when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "username")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER); when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "password")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PASS); when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "url")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.URL); jiraConfig = new com.googlesource.gerrit.plugins.its.jira.JiraConfig(cfg, com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME); assertThat(jiraConfig.getUsername()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PASS); assertThat(jiraConfig.getUrl()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.URL); }<END_MOD>
private com.googlesource.gerrit.plugins.its.jira.JiraClient client() throws java.net.MalformedURLException { if ((client) == null) { log.debug( to jira at {} <START_MOD>jiraConfig.<END_MOD>getUrl()); client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(<START_MOD>jiraConfig.<END_MOD>getUrl(), <START_MOD>jiraConfig.<END_MOD>getUsername(), <START_MOD>jiraConfig.<END_MOD>getPassword()); log.debug( as User {} <START_MOD>jiraConfig.<END_MOD>getUsername()); } return client; }
<START_MOD>public java.lang.String getUrl() { return jiraUrl; }<END_MOD>
private void authorizeUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.project.ProjectState state, java.lang.String operation) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { com.google.gerrit.reviewdb.client.Project.NameKey projectName = state.getNameKey(); if (((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD)) && (!(permissionBackend.user(user).project(projectName).testOrFalse(com.googlesource.gerrit.plugins.lfs.READ)))) || ((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD)) && (!(permissionBackend.user(user).project(projectName).testOrFalse(com.googlesource.gerrit.plugins.lfs.PUSH_AT_LEAST_ONE_REF))))) { java.lang.String op = operation.toLowerCase(); java.lang.String project = state.getProject().getName(); java.lang.String userName = (user.getUserName()<START_MOD>.isPresent(<END_MOD>)) ? <START_MOD>user.getUserName().get() : <END_MOD>"anonymous"; com.googlesource.gerrit.plugins.lfs.LfsApiServlet.log.debug(java.lang.String.format( %s unauthorized for user %s on project %s op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); } }
@org.junit.Test public void testVerifyDecodeAgainstEncodedInput() throws java.lang.Exception { java.lang.String plain =   text java.lang.String encrypted = cipher.encrypt(plain); <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<java.lang.String> decrypted = cipher.decrypt(encrypted); assertThat(decrypted.isPresent()).isTrue(); assertThat(decrypted.get()).isEqualTo(plain); }
private void throwUnauthorizedOp(java.lang.String op, com.google.gerrit.server.project.ProjectState state, com.google.gerrit.server.CurrentUser user) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { java.lang.String project = state.getProject().getName(); java.lang.String userName = (user.getUserName()<START_MOD>.isPresent(<END_MOD>)) ? <START_MOD>user.getUserName().get() : <END_MOD>"anonymous"; com.googlesource.gerrit.plugins.lfs.locks.LfsLocksAction.log.debug(java.lang.String.format( %s unauthorized for user %s on project %s op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); }
@org.junit.Test public void testTokenSerializationDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor(cipher); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(0); java.lang.String serialized = processor.serialize(token); assertThat(serialized).isNotEmpty(); <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> deserialized = processor.deserialize(serialized); assertThat(deserialized.isPresent()).isTrue(); assertThat(token.expiresAt).isEqualTo(deserialized.get().expiresAt); }
public <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<T> deserialize(java.lang.String input) { <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<java.lang.String> decrypted = cipher.decrypt(input); if (!(decrypted.isPresent())) { return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.<START_MOD>empty<END_MOD>(); } return createToken(com.google.common.base.Splitter.on(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.Processor.DELIMETER).splitToList(decrypted.get())); }
protected abstract <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<T> createToken(java.util.List<java.lang.String> values);
public boolean verifyAuthInfo(java.lang.String authToken, java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return false; } return new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.Verifier(token.get(), operation, id).verify(); }
@java.lang.Override protected <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 3) { return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.<START_MOD>empty<END_MOD>(); } return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1)), values.get(2))); }
@java.lang.Override protected <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 4) { return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.<START_MOD>empty<END_MOD>(); } return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3))); }
<START_MOD>java.util<END_MOD>.Optional<java.lang.String> getUserFromValidToken(java.lang.String authToken, java.lang.String project, java.lang.String operation) { <START_MOD>java.util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return <START_MOD>java.util.Optional.empty<END_MOD>(); } com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier(token.get(), project, operation); if (!(verifier.verify())) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.log.error( data was provided with auth token {}. authToken); return <START_MOD>java.util.Optional.empty<END_MOD>(); } return <START_MOD>java.util<END_MOD>.Optional.of(token.get().user); }
@java.lang.Override protected <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.util.List<java.lang.String> values) { return <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0))); }
public <START_MOD>java.util<END_MOD>.Optional<java.lang.String> decrypt(java.lang.String input) { if (com.google.common.base.Strings.isNullOrEmpty(input)) { return <START_MOD>java.util.Optional.empty<END_MOD>(); } byte[] bytes = org.eclipse.jgit.util.Base64.decode(input); byte[] initVector = java.util.Arrays.copyOf(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH); try { javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.DECRYPT_MODE); return <START_MOD>java.util<END_MOD>.Optional.of(new java.lang.String(cipher.doFinal(java.util.Arrays.copyOfRange(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH, bytes.length)), java.nio.charset.StandardCharsets.UTF_8)); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.LfsCipher.log.error( was thrown during token verification e); } return <START_MOD>java.util.Optional.empty(); }<END_MOD>
@org.junit.Test public void testVerifyDecodeAgainstInvalidInput() throws java.lang.Exception { java.lang.String plain =   text java.lang.String encrypted = cipher.encrypt(plain); while ((encrypted.charAt(0)) == (encrypted.charAt(1))) { encrypted = cipher.encrypt(plain); } <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.Optional<java.lang.String> decrypted = cipher.decrypt((((encrypted.substring(1, 2)) + (encrypted.substring(0, 1))) + (encrypted.substring(2)))); assertThat(decrypted.isPresent()).isTrue(); assertThat(decrypted.get()).isNotEqualTo(plain); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (!(com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { <START_MOD>java.util<END_MOD>.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.server.account.AccountState<START_MOD>><END_MOD> acc = accounts.getByUsername(user.get()); if (acc<START_MOD>.isPresent()<END_MOD>) { return userFactory.create(acc<START_MOD>.get()<END_MOD>); } } } } return anonymous.get(); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (!(com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { <START_MOD>java.util<END_MOD>.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc != null) { return userFactory.create(acc); } } } } return anonymous.get(); }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.<START_MOD>format<END_MOD>(now<START_MOD>()<END_MOD>.plusMillis(1)))).isTrue(); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.<START_MOD>format<END_MOD>(now<START_MOD>()<END_MOD>.minusMillis(1)))).isFalse(); }
static boolean onTime(java.lang.String dateTime) { java.lang.String now = com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.<START_MOD>format<END_MOD>(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now()); return (now.compareTo(dateTime)) <= 0; }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.<START_MOD>format<END_MOD>(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now().plusSeconds(expirationSeconds)); }
void appendSubmittedBy(com.google.gerrit.reviewdb.client.Account<START_MOD>.Id<END_MOD> <START_MOD>accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account<END_MOD>) { sb.append(   appendUserData(<START_MOD>accountId, account<END_MOD>); sb.append("\n"); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkState(((account == null) || (accountId.equals(account.getId()))),   account IDs boolean needSpace = false; boolean wroteData = false; if (account != null) { if (<START_MOD>!(com.google.common.base.Strings.isNullOrEmpty<END_MOD>(account.getFullName())<START_MOD>)) { sb.append(account.getFullName()); needSpace = true; wroteData = true; } if<END_MOD> (!(<START_MOD>com.google.common.base.Strings.isNullOrEmpty(account.getPreferredEmail()))) { if (<END_MOD>needSpace<START_MOD>) { sb.append(   } sb.append("<").append(account.getPreferredEmail()).append(">"); wroteData<END_MOD> = true; <START_MOD>} } if<END_MOD> (!wroteData) { sb.append(anonymousCowardName).append(   } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null, null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type != null) { fmt.appendApproval(type, a.getValue(), <START_MOD>a.getAccountId(), <END_MOD>accountCache.<START_MOD>maybeGet(a.getAccountId()).map(AccountState::getAccount).orElse(null)); } } } if (submit != null) { fmt.appendSubmittedBy(submit.getAccountId(), accountCache.maybeGet(submit.getAccountId()).map(AccountState::getAccount).orElse(null)); fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl) != null) { fmt.appendReviewedOn(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.<END_MOD>get(<START_MOD>)); fmt.appendBranch(change.getDest()<END_MOD>.get(<START_MOD>)); }<END_MOD>
private void appendUserData(com.google.gerrit.reviewdb.client.Account<START_MOD>.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkState(((account == null) || (accountId.equals(account.getId()))),   account IDs<END_MOD> boolean needSpace = false; boolean wroteData = false; if (<START_MOD>account != null) { if (((account<END_MOD>.getFullName()) != null) && (!(<START_MOD>account<END_MOD>.getFullName().isEmpty()))) { sb.append(<START_MOD>account<END_MOD>.getFullName()); needSpace = true; wroteData = true; } if (((<START_MOD>account<END_MOD>.getPreferredEmail()) != null) && (!(<START_MOD>account<END_MOD>.getPreferredEmail().isEmpty()))) { if (needSpace) { sb.append(   } sb.append("<").append(<START_MOD>account<END_MOD>.getPreferredEmail()).append(">"); wroteData = true; } <START_MOD>} <END_MOD>if (!wroteData) { sb.append(anonymousCowardName).append(   } }
void appendApproval(com.google.gerrit.common.data.LabelType label, short value, com.google.gerrit.reviewdb.client.Account<START_MOD>.Id<END_MOD> <START_MOD>accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account<END_MOD>) { sb.append(label.getName()); sb.append(com.google.gerrit.common.data.LabelValue.formatValue(value)); sb.append(   appendUserData(<START_MOD>accountId, account<END_MOD>); sb.append("\n"); }
public org.eclipse.jgit.lib.PersonIdent newIdent(com.google.gerrit.reviewdb.client.Account.Id authorId, java.util.Date when, org.eclipse.jgit.lib.PersonIdent serverIdent) { <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.reviewdb.client.Account<START_MOD>><END_MOD> author = accountCache.<START_MOD>maybeGet<END_MOD>(authorId).<START_MOD>map(AccountState::<END_MOD>getAccount); return new org.eclipse.jgit.lib.PersonIdent(author.<START_MOD>map(Account::<END_MOD>getName<START_MOD>).orElse<END_MOD>(<START_MOD>(   + authorId)<END_MOD>), (((<START_MOD>authorId<END_MOD>.get()) + "@") + (serverId)), when, serverIdent.getTimeZone()); }
java.<START_MOD>lang<END_MOD>.<START_MOD>String<END_MOD> getBaseUrl() { return baseUrl; }
private java.net.HttpURLConnection prepHttpConnection(java.lang.String spec, boolean isPostRequest) throws java.io.IOException { java.<START_MOD>lang.String urlWithSpec = (baseUrl) + spec; java.<END_MOD>net.URL url = new java.net.URL(<START_MOD>urlWithSpec<END_MOD>); java.net.ProxySelector proxySelector = java.net.ProxySelector.getDefault(); java.net.Proxy proxy = org.eclipse.jgit.util.HttpSupport.proxyFor(proxySelector, url); java.net.HttpURLConnection conn = ((java.net.HttpURLConnection) (url.openConnection(proxy))); conn.setRequestProperty("Authorization", (   + (auth))); conn.setRequestProperty("Content-Type", "application/json"); if (isPostRequest) { conn.setRequestMethod("POST"); conn.setDoOutput(true); } else { conn.setRequestMethod("GET"); } return conn; }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug( creation of {} name); <START_MOD>if (name.contains(   { throw new com.google.gerrit.server.validators.ValidationException(java.lang.String.format(<END_MOD>com.ericsson.gerrit.plugins.projectgroupstructure.<START_MOD>ProjectCreationValidator.PROJECT_CANNOT_CONTAINS_SPACES_MSG, documentationUrl)); }<END_MOD> com.google.gerrit.server.project.ProjectControl parentCtrl; try { parentCtrl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.error(((((( to create project   + name) +   Cannot retrieve info about parent project   + (args.newParent.get())) +     + (e.getMessage())), e); throw new com.google.gerrit.server.validators.ValidationException(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.AN_ERROR_OCCURRED_MSG); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug( is creating project, bypassing all rules return; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { } if (allProjectsName.get().equals(parentCtrl.getProject().getNameKey())) { validateRootProject(name, args.permissionsOnly); } else { validateProject(name, parentCtrl); } if ((!(parentCtrl.isOwner())) && (!(configDisableGrantingOwnership(parentCtrl)))) { args.ownerIds.add(createGroup((name + "-admins"))); } }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug( creation of {} name); com.google.gerrit.server.project.ProjectControl parentCtrl<START_MOD>; try { parentCtrl<END_MOD> = <START_MOD>projectControlFactory.controlFor(<END_MOD>args.newParent<START_MOD>, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.error(((((( to create project   + name) +   Cannot retrieve info about parent project   + (args.newParent.get())) +     + (e.getMessage())), e); throw new com.google.gerrit.server.validators.ValidationException(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.AN_ERROR_OCCURRED_MSG); }<END_MOD> try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidator.log.debug( is creating project, bypassing all rules return; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { } if (allProjectsName.get().equals(parentCtrl.getProject().getNameKey())) { validateRootProject(name, args.permissionsOnly); } else { validateProject(name, parentCtrl); } if ((!(parentCtrl.isOwner())) && (!(configDisableGrantingOwnership(parentCtrl)))) { args.ownerIds.add(createGroup((name + "-admins"))); } }
public boolean issueExists(java.lang.String issueKey) throws java.io.IOException { com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApi<com.googlesource.gerrit.plugins.its.jira.restapi.JiraIssue> api = apiBuilder.getIssue(); api.doGet(<START_MOD>issueKey<END_MOD>, java.net.HttpURLConnection.HTTP_OK, <START_MOD>null); java.lang.Integer code = api.getResponseCode(); switch (code) { case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_NOT_FOUND : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error( {} not found issueKey); return false; case java.net.HttpURLConnection.HTTP_FORBIDDEN : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error( permission to read Issue {} issueKey); return false; default : throw <END_MOD>new java.io.IOException(( HTTP code received: + (code.toString()))); } }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.<START_MOD>getEvenIfMissing<END_MOD>(r.iterator().next()).getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = byId.maybeGet(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.get().isActive()))) { continue; } if (match != null) { return null; } match = account.get(); } return match; }
protected java.lang.String getFromLine() { final com.google.gerrit.reviewdb.client.Account account = args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(fromId).getAccount(); final java.lang.String name = account.getFullName(); final java.lang.String email = account.getPreferredEmail(); java.lang.StringBuilder f = new java.lang.StringBuilder(); if (((name != null) && (!(name.isEmpty()))) || ((email != null) && (!(email.isEmpty())))) { f.append("From"); if ((name != null) && (!(name.isEmpty()))) { f.append(   } if ((email != null) && (!(email.isEmpty()))) { f.append( <").append(email).append("> } f.append(":\n\n"); } return f.toString(); }
private void appendIdent(java.io.PrintWriter writer, java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id id, java.sql.Timestamp ts) { org.eclipse.jgit.lib.PersonIdent ident = newIdent(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(id).getAccount(), ts, serverIdent); java.lang.StringBuilder name = new java.lang.StringBuilder(); org.eclipse.jgit.lib.PersonIdent.appendSanitized(name, ident.getName()); name.append( < org.eclipse.jgit.lib.PersonIdent.appendSanitized(name, ident.getEmailAddress()); name.append('>'); appendHeaderField(writer, header, name.toString()); }
public com.google.gerrit.reviewdb.client.Account findByNameOrEmail(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAllByNameOrEmail(nameOrEmail); return (r.size()) == 1 ? byId.<START_MOD>getEvenIfMissing<END_MOD>(r.iterator().next()).getAccount() : null; }
private void addSubmitRecordLabels(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecordAttribute sa) { if (((submitRecord.labels) != null) && (!(submitRecord.labels.isEmpty()))) { sa.labels = new java.util.ArrayList(); for (SubmitRecord.Label lbl : submitRecord.labels) { com.google.gerrit.server.data.SubmitLabelAttribute la = new com.google.gerrit.server.data.SubmitLabelAttribute(); la.label = lbl.label; la.status = lbl.status.name(); if ((lbl.appliedBy) != null) { com.google.gerrit.server.account.AccountState accountState = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(lbl.appliedBy); la.by = asAccountAttribute(accountState); } sa.labels.add(la); } } }
public com.google.gerrit.server.data.AccountAttribute asAccountAttribute(com.google.gerrit.reviewdb.client.Account.Id id) { if (id == null) { return null; } return asAccountAttribute(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(id)); }
protected com.google.gerrit.server.account.AccountState getAccountState(com.google.gerrit.reviewdb.client.Account.Id accountId) { return accountCache.<START_MOD>get<END_MOD>(accountId).get(); }
protected void removeUsersThatIgnoredTheChange() { for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.util.Collection<java.lang.String>> e : stars.asMap().entrySet()) { if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) { args.accountCache.<START_MOD>get<END_MOD>(e.getKey()).map(AccountState::getAccount).ifPresent(( a) -> removeUser(a)); } } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { opResult = com.google.gerrit.server.restapi.change.PostReviewersOp.Result.builder().setAddedReviewers(com.google.common.collect.ImmutableList.copyOf(addedReviewers)).setAddedCCs(com.google.common.collect.ImmutableList.copyOf(addedCCs)).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.Lists.transform(addedReviewers, ( r) -> r.getAccountId()), ((addedCCs) == null ? com.google.common.collect.ImmutableList.of() : addedCCs), reviewersByEmail, addedCCsByEmail, notify, accountsToNotify); if (!(addedReviewers.isEmpty())) { java.util.List<com.google.gerrit.server.account.AccountState> reviewers = addedReviewers.stream().map(( r) -> accountCache.<START_MOD>getEvenIfMissing<END_MOD>(r.getAccountId())).collect(java.util.stream.Collectors.toList()); reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen()); } }
private void logOrmException(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.Iterable<?> values, com.google.gwtorm.server.OrmException e) { java.lang.StringBuilder message = new java.lang.StringBuilder(header); message.append(   message.append(me); message.append("/"); message.append(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(me).getUserName().orElse(null)); message.append(   message.append(com.google.common.base.Joiner.on(   com.google.gerrit.server.group.DbGroupMemberAuditListener.log.error(message.toString(), e); }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId).getUserName().orElse(null); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format( {0}/{1}, group {2}/{3} accountId, userName, groupId, groupName)); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { java.lang.String senderName; if (fromId != null) { com.google.gerrit.reviewdb.client.Account a = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(fromId).getAccount(); java.lang.String fullName = a.getFullName(); java.lang.String userEmail = a.getPreferredEmail(); if (canRelay(userEmail)) { return new com.google.gerrit.server.mail.Address(fullName, userEmail); } if ((fullName == null) || ("".equals(fullName.trim()))) { fullName = anonymousCowardName; } senderName = nameRewriteTmpl.replace("user", fullName).toString(); } else { senderName = serverAddress.getName(); } java.lang.String senderEmail; com.google.gerrit.common.data.ParameterizedString senderEmailPattern = new com.google.gerrit.common.data.ParameterizedString(serverAddress.getEmail()); if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { final java.lang.String senderName; if (fromId != null) { final com.google.gerrit.reviewdb.client.Account account = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(fromId).getAccount(); java.lang.String fullName = account.getFullName(); if ((fullName == null) || ("".equals(fullName))) { fullName = anonymousCowardName; } senderName = namePattern.replace("user", fullName).toString(); } else { senderName = serverAddress.getName(); } java.lang.String senderEmail; if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
private org.eclipse.jgit.lib.PersonIdent newAuthorIdent(com.google.gerrit.server.notedb.rebuild.EventList<?> events) { com.google.gerrit.reviewdb.client.Account.Id id = events.getAccountId(); if (id == null) { return new org.eclipse.jgit.lib.PersonIdent(serverIdent, events.getWhen()); } return changeNoteUtil.newIdent(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(id).getAccount(), events.getWhen(), serverIdent); }
public java.lang.String getUserNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if ((name != null) && (email != null)) { return ((name +   < + email) + ">"; } else if (email != null) { return email; } else if (name != null) { return name; } return who.getUserName().orElse(null); }
private java.lang.StringBuilder addIdent(java.lang.StringBuilder sb, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId).getAccount(); org.eclipse.jgit.lib.PersonIdent ident = newIdent(account, when); org.eclipse.jgit.lib.PersonIdent.appendSanitized(sb, ident.getName()); sb.append( < org.eclipse.jgit.lib.PersonIdent.appendSanitized(sb, ident.getEmailAddress()); sb.append('>'); return sb; }
public java.lang.String getNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if ((name != null) && (email != null)) { return ((name +   < + email) + ">"; } else if (name != null) { return name; } else if (email != null) { return email; } else { return ((args.anonymousCowardName) +     + accountId; } }
private com.google.gerrit.server.mail.Address toAddress(com.google.gerrit.reviewdb.client.Account.Id id) { final com.google.gerrit.reviewdb.client.Account a = args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(id).getAccount(); final java.lang.String e = a.getPreferredEmail(); if ((!(a.isActive())) || (e == null)) { return null; } return new com.google.gerrit.server.mail.Address(a.getFullName(), e); }
protected java.lang.String getNameFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { if (accountId == null) { return args.gerritPersonIdent.getName(); } final com.google.gerrit.reviewdb.client.Account userAccount = args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId).getAccount(); java.lang.String name = userAccount.getFullName(); if (name == null) { name = userAccount.getPreferredEmail(); } if (name == null) { name = ((args.anonymousCowardName) +     + accountId; } return name; }
private Account.Id user(java.lang.String name, java.lang.String email) { final com.google.gerrit.server.account.AccountState s = makeUser(name, email); expect(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(eq(s.getAccount().getId()))).andReturn(s); return s.getAccount().getId(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::<START_MOD>getEvenIfMissing<END_MOD>).map(AccountState::getAccount).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.getEvenIfMissing(r.iterator().next()).getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = byId.<START_MOD>get<END_MOD>(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.get().isActive()))) { continue; } if (match != null) { return null; } match = account.get(); } return match; }
@java.lang.Override public final void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if (changeAlreadyMerged) { logDebug( post-update steps for change {} getId()); return; } postUpdateImpl(ctx); if ((command) != null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject())) { git.setGitwebDescription(p.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(( update description of   + (p.getName())), e); } } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput.notify, args.accountsToNotify).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(( email merged notification for   + (getId())), e); } if (((mergeResultRev) != null) && (!(args.dryrun))) { args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.<START_MOD>getEvenIfMissing<END_MOD>(submitter.getAccountId()), args.mergeTip.getCurrentTip().name(), ctx.getWhen()); } }
@java.lang.Override public void fillAccountInfo(java.lang.Iterable<? extends com.google.gerrit.extensions.common.AccountInfo> in, java.util.Set<com.google.gerrit.server.account.FillOptions> options) throws com.google.gerrit.server.account.DirectoryException { if (options.equals(com.google.gerrit.server.account.InternalAccountDirectory.ID_ONLY)) { return; } for (com.google.gerrit.extensions.common.AccountInfo info : in) { com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(info._accountId); com.google.gerrit.server.account.AccountState state = accountCache.<START_MOD>getEvenIfMissing<END_MOD>(id); fill(info, state, state.getExternalIds(), options); } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null, null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type != null) { fmt.appendApproval(type, a.getValue(), a.getAccountId(), accountCache.<START_MOD>get<END_MOD>(a.getAccountId()).map(AccountState::getAccount).orElse(null)); } } } if (submit != null) { fmt.appendSubmittedBy(submit.getAccountId(), accountCache.<START_MOD>get<END_MOD>(submit.getAccountId()).map(AccountState::getAccount).orElse(null)); fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl) != null) { fmt.appendReviewedOn(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.get()); fmt.appendBranch(change.getDest().get()); }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountCache.<START_MOD>getEvenIfMissing<END_MOD>(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(   out.write(java.lang.String.format( %s group %s: %s action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@org.junit.Test public void blockPushDrafts() { allow(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/for/refs/*"); block(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.ANONYMOUS_USERS, "refs/drafts/*"); <START_MOD>allow(local, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/drafts/*"); <END_MOD>com.google.gerrit.server.permissions.ProjectControl u = user(local); assertCreateChange("refs/heads/master", u); <START_MOD>assertThat(u.controlForRef("refs/drafst/master").canPerform<END_MOD>(com.google.gerrit.server.permissions.PUSH<START_MOD>)).isFalse(<END_MOD>); }
private static java.util.Optional<com.google.gerrit.server.notedb.NoteDbChangeState.RefState> parse(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> parts) { checkArgument((!(parts.isEmpty())),   state string for change %s changeId); org.eclipse.jgit.lib.ObjectId changeMetaId = org.eclipse.jgit.lib.ObjectId.fromString(parts.get(0)); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> draftIds = com.google.common.collect.Maps.newHashMapWithExpectedSize(((parts.size()) - 1)); com.google.common.base.Splitter s = com.google.common.base.Splitter.on('='); for (int i = 1; i < (parts.size()); i++) { java.lang.String p = parts.get(i); java.util.List<java.lang.String> draftParts = s.splitToList(p); checkArgument(((draftParts.size()) == 2),   draft state part for change %s: %s changeId, p); <START_MOD>java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> accountId = Account.Id.parse(draftParts.get(0)); checkArgument(accountId.isPresent(),   account ID in draft state part for change %s: %s changeId, p); <END_MOD>draftIds.put(<START_MOD>accountId.get(), org.eclipse.jgit.lib.ObjectId.fromString<END_MOD>(draftParts.get(1))); } return java.util.Optional.of(com.google.gerrit.server.notedb.NoteDbChangeState.RefState.create(changeMetaId, draftIds)); }
private java.util.Optional<com.google.gerrit.server.account.AuthResult> byAccountId(java.lang.String idStr) { <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.reviewdb.client.Account.Id<START_MOD>><END_MOD> id = Account.Id.parse(idStr); <START_MOD>if<END_MOD> (<START_MOD>!(id<END_MOD>.<START_MOD>isPresent())<END_MOD>) { return java.util.Optional.empty(); } try { return auth(accounts.get(id<START_MOD>.get()<END_MOD>)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { getServletContext().log( query database e); return java.util.Optional.empty(); } }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile(   if (m.matches()) { java.util.Optional<com.google.gerrit.<START_MOD>reviewdb.client.Account.Id> id = Account.Id.parse(m.group(1)); if (id.isPresent()) { return com.google.common.collect.Streams.stream(accounts.get(id.get())).map(( a) -> id.get()).collect(toImmutableSet()); } } if (nameOrEmail.matches("^[1-9][0-9]*$")) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> id = Account.Id.parse(nameOrEmail); if (id.isPresent()) { return com.google.common.collect.Streams.stream(accounts.get(id.get())).map(( a) -> id.get()).collect(toImmutableSet()); } } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { java.util.Optional<com.google.gerrit.<END_MOD>server.account.AccountState> who = byId.getByUsername(nameOrEmail); if (who.isPresent()) { return com.google.common.collect.ImmutableSet.of(who.map(( a) -> a.getAccount().getId()).get()); } } return findAllByNameOrEmail(nameOrEmail); }
@java.lang.Override public com.google.gerrit.server.mail.ParsedToken decode(java.lang.String tokenString) throws com.google.gerrit.server.mail.InvalidTokenException { checkEmailRegistrationToken(); com.google.gwtjsonrpc.server.ValidToken token; try { token = emailRegistrationToken.checkToken(tokenString, null); } catch (com.google.gwtjsonrpc.server.XsrfException err) { throw new com.google.gerrit.server.mail.InvalidTokenException(err); } if (((token == null) || ((token.getData()) == null)) || (token.getData().isEmpty())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } java.lang.String payload = new java.lang.String(org.eclipse.jgit.util.Base64.decode(token.getData()), java.nio.charset.StandardCharsets.UTF_8); java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("^([0-9]+):(.+@.+)$").matcher(payload); if (!(matcher.matches())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(matcher.group(1))<START_MOD>.orElseThrow(InvalidTokenException::new);<END_MOD> java.lang.String newEmail = matcher.group(2); return new com.google.gerrit.server.mail.ParsedToken(id, newEmail); }
public static <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.reviewdb.client.Account.Id<START_MOD>><END_MOD> parse(java.lang.String str) { <START_MOD>try { return java<END_MOD>.<START_MOD>util<END_MOD>.<START_MOD>Optional<END_MOD>.<START_MOD>of(<END_MOD>new com.google.gerrit.reviewdb.client.Account.Id(<START_MOD>java.lang.Integer.parseInt(str))<END_MOD>); <START_MOD>} catch (java<END_MOD>.<START_MOD>lang.NumberFormatException e) { return java.util.Optional.empty<END_MOD>(); <START_MOD>}<END_MOD> }
private static void dashboard(java.lang.String token) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); <START_MOD>java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> accountId = Account.Id.parse(rest); <END_MOD>if (<START_MOD>accountId.isPresent(<END_MOD>)) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(<START_MOD>accountId.get(<END_MOD>))); return; } if (rest.equals("self")) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(com.google.gerrit.client.Gerrit.getUserAccount().getId())); } else { com.google.gerrit.client.ui.Screen s = new com.google.gerrit.client.changes.AccountDashboardScreen(null); s.setRequiresSignIn(true); com.google.gerrit.client.Gerrit.display(token, s); } return; } if (rest.startsWith("?")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.CustomDashboardScreen(rest.substring(1))); return; } com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); }
private java.lang.String changeKindMessage(com.google.gerrit.extensions.client.ChangeKind changeKind) { switch (changeKind) { case MERGE_FIRST_PARENT_UPDATE : <START_MOD>return ( New merge patch set was added with a new first parent relative to   + (priorPatchSetId.get())) + "."; <END_MOD>case TRIVIAL_REBASE : <START_MOD>return ( Patch Set   + (priorPatchSetId.get())) +   was rebased. <END_MOD>case NO_CHANGE : return (<START_MOD>(( New patch set was added with same tree, parent + ((commit.getParentCount()) != 1 ? "s" : "")) +   and commit message as<END_MOD> Patch Set   + (priorPatchSetId.get())) + <START_MOD>".";<END_MOD> case NO_CODE_CHANGE : return   Commit message was updated. case REWORK : default : return null; } }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> <START_MOD>addedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId<END_MOD>, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = <START_MOD>addedSubgroups.stream().map(( t) -> toAccountGroupByIdAud(t, parentGroupId, addedOn, me)).collect(<END_MOD>java.util.<START_MOD>stream.Collectors.toList()<END_MOD>); <START_MOD>try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())<END_MOD>) { <START_MOD>db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups( log add groups to group event performed by user<END_MOD> me, <START_MOD>addedSubgroups, parentGroupId, e<END_MOD>); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> removed<START_MOD>, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId<END_MOD>, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID uuid<END_MOD> : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(<START_MOD>parentGroupId, uuid<END_MOD>)) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, removedOn); auditUpdates.add(audit); } } db.accountGroupByIdAud().update(auditUpdates); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups( log delete groups from group event performed by user me, removed, <START_MOD>parentGroupId, <END_MOD>e); } }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>Account.Id<END_MOD>> <START_MOD>accounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.<START_MOD>Account.Id id<END_MOD> : <START_MOD>accounts) { java.lang.String userName<END_MOD> = <START_MOD>accountCache.get(id).getUserName(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format( {0}/{1}, group {2}/{3} id,<END_MOD> userName<START_MOD>,<END_MOD> groupId<START_MOD>,<END_MOD> groupName<START_MOD>)); } logOrmException(header, me,<END_MOD> descriptions, e); }
<START_MOD>private static com.google.gerrit.reviewdb.client.AccountGroupMemberAudit toAccountGroupMemberAudit(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.Account.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key(id, groupId, ts), me); }<END_MOD>
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>Account.Id<END_MOD>> <START_MOD>removedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(actor, <START_MOD>removedAccounts, groupId<END_MOD>, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log delete accounts from group event e); } } }
@java.lang.Override public void onAddSubgroups(com.google.gerrit.server.audit.group.GroupSubgroupAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(com.google.gerrit.server.group.<START_MOD>DbGroupAuditListener<END_MOD>.toAccountGroupByIdAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForSubgroupsEvent( log add groups to group event performed by user event, e); } }
private void removeSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> subgroupsToRemove = subgroupUuids.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), <START_MOD>subgroupUuids, parentGroupId, removedOn); } db.accountGroupById().delete(<END_MOD>subgroupsToRemove); }
<START_MOD>private static com.google.gerrit.reviewdb.client.AccountGroupByIdAud toAccountGroupByIdAud(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.Account.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(new com.google.gerrit.reviewdb.client.AccountGroupByIdAud.Key(groupId, uuid, ts), me); }<END_MOD>
private void addSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newSubgroups = subgroupUuids.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), <START_MOD>subgroupUuids, parentGroupId, addedOn); } db.accountGroupById().insert(<END_MOD>newSubgroups); }
@java.lang.Override public void onAddMembers(com.google.gerrit.server.audit.group.GroupMemberAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(com.google.gerrit.server.group.<START_MOD>DbGroupAuditListener<END_MOD>.toAccountGroupMemberAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForMembersEvent( log add accounts to group event performed by user event, e); } }
private void removeGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = accountIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), <START_MOD>accountIds, groupId, removedOn); } db.accountGroupMembers().delete(<END_MOD>membersToRemove); }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>Account.Id<END_MOD>> <START_MOD>addedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = <START_MOD>addedAccounts.stream().map(( t) -> toAccountGroupMemberAudit(t, groupId, addedOn, me)).collect(<END_MOD>java.util.<START_MOD>stream.Collectors.toList()<END_MOD>); <START_MOD>try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())<END_MOD>) { <START_MOD>db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts( log add accounts to group event performed by user<END_MOD> me, <START_MOD>addedAccounts, groupId, e<END_MOD>); } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>Account.Id<END_MOD>> <START_MOD>addedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddAccountsToGroup(actor, <START_MOD>addedAccounts, groupId<END_MOD>, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log add accounts to group event e); } } }
private void addGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> newMemberIds, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> newMembers = newMemberIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(toImmutableSet()); if ((currentUser) != null) { auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), <START_MOD>newMemberIds, groupId, addedOn); } db.accountGroupMembers().insert(<END_MOD>newMembers); }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> <START_MOD>removedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(actor, <START_MOD>removedSubgroups, groupId<END_MOD>, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log delete groups from group event e); } } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id actor, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> <START_MOD>addedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddGroupsToGroup(actor, <START_MOD>addedSubgroups, groupId<END_MOD>, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error( to log add groups to group event e); } } }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID<END_MOD>> <START_MOD>uuids, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId<END_MOD>, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.<START_MOD>AccountGroup.UUID uuid<END_MOD> : <START_MOD>uuids) { java.lang.String groupName<END_MOD> = <START_MOD>groupBackend.get(uuid).getName(); java.lang.String targetGroupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format( {0}/{1}, group {2}/{3} uuid,<END_MOD> groupName<START_MOD>, groupId,<END_MOD> targetGroupName<START_MOD>)); } logOrmException(header, me,<END_MOD> descriptions, e); }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { <START_MOD>try { <END_MOD>if (stalenessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; }<START_MOD> } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug( was deleted, aborting reindexing the change } return false; }<END_MOD>
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { try { if (stalenessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; } } catch (com.google.gerrit.server.project.NoSuchChangeException <START_MOD>nsce) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug( {} was deleted, aborting reindexing the change. id.get()); } catch (java.lang.Exception <END_MOD>e) { <START_MOD>if (!(isCausedByRepositoryNotFoundException(e))) { throw e; } <END_MOD>com.google.gerrit.server.index.change.ChangeIndexer.log.debug( {} <START_MOD>belong to a<END_MOD> deleted<START_MOD> project<END_MOD>, aborting reindexing the change. id.get()); } return false; }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(publisherThread.isAlive())) { publisherThread.start(); } <START_MOD>if (!(<END_MOD>queue.<START_MOD>offer<END_MOD>(event)<START_MOD>)) { if (!(fullQueue)) { com.googlesource.gerrit.plugins.rabbitmq.message.MessagePublisher.LOGGER.error( receive events, Queue is full. fullQueue = true<END_MOD>; } <START_MOD>} else if<END_MOD> (<START_MOD>fullQueue<END_MOD>) { com.googlesource.gerrit.plugins.rabbitmq.message.MessagePublisher.LOGGER.warn( <START_MOD>is<END_MOD> <START_MOD>processable<END_MOD> <START_MOD>again<END_MOD> <START_MOD>fullQueue = false<END_MOD>; } }
<START_MOD>@java.lang.Override public java.util.Set<com.google.gerrit.server.change.SuggestedReviewer> suggestReviewers(com.google.gerrit.reviewdb.client.Project.NameKey projectName, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change.Id changeId, @com.google.gerrit.common.Nullable java.lang.String query, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> candidates) { java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> sections = getSections(projectName); if (!(sections.isEmpty())) { try (com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schemaFactory.open()) { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(reviewDb, projectName, changeId); java.util.Set<java.lang.String> reviewers = findReviewers(sections, changeData); if (!(reviewers.isEmpty())) { return toAccounts(reviewDb, reviewers, projectName, null).stream().map(( a) -> suggestedReviewer(a)).collect(java.util.stream.Collectors.toSet()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException x) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.error(x.getMessage(), x); } } return new java.util.HashSet<>(); }<END_MOD>
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(<START_MOD>() -> new com.google.gerrit.extensions.restapi.<END_MOD>MethodNotAllowedException<START_MOD>( a Gerrit internal group<END_MOD> if (recursive) { return getTransitiveMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
@java.lang.Override @com.google.gerrit.common.Nullable public synchronized <T> <START_MOD>java.util.Optional<<END_MOD>T<START_MOD>><END_MOD> get(com.google.gerrit.server.PropertyKey<T> key) { if ((properties) != null) { @java.lang.SuppressWarnings("unchecked") T value = ((T) (properties.get(key))); return <START_MOD>java.util.Optional.ofNullable(<END_MOD>value<START_MOD>)<END_MOD>; } return <START_MOD>java.util.Optional.empty()<END_MOD>; }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupNameOrUUID) { <START_MOD>java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = java.util.Optional.ofNullable(groupCache.get(new <END_MOD>com.google.gerrit.reviewdb.client.AccountGroup<START_MOD>.NameKey(groupNameOrUUID))).orElse(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupNameOrUUID))); if (!(group.isPresent())) { com.vmware.gerrit.owners.common.AccountsImpl.log.warn( {} was not found groupNameOrUUID); return java.util.Collections.emptySet(); } try (com.google.gerrit.server.util.ManualRequestContext ctx<END_MOD> = <START_MOD>oneOffRequestContext.openAs(adminUser.getAccountId())) { return groupMembers.create(adminUser).listAccounts(group<END_MOD>.get(<START_MOD>)<END_MOD>.getGroupUUID(), null).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gerrit.server.project.NoSuchProjectException | com.google.gwtorm.server.OrmException | java.io.IOException e) { com.vmware.gerrit.owners.common.AccountsImpl.log.error(( to list accounts in group   + group), e); return java.util.Collections.emptySet(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); <START_MOD>com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.log.info( trigger for %s:%s by %d. Config: %s resource.getBranchKey().getParentKey().get(), resource.getBranchKey().get(), identifiedUser.get().getAccountId().get(), configurationToString()); <END_MOD>update(resource.getProjectState().getProject().getName(), resource.getRef(), false); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupNameOrUUID) { <START_MOD>java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = java.util.Optional.ofNullable(groupCache.get(new <END_MOD>com.google.gerrit.reviewdb.client.AccountGroup<START_MOD>.NameKey(groupNameOrUUID))).orElse<END_MOD>(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.<START_MOD>UUID<END_MOD>(groupNameOrUUID)))<START_MOD>; if (!(group.isPresent())) { com.vmware.gerrit.owners.common.AccountsImpl.log.warn( {} was not found groupNameOrUUID); return java.util.Collections.emptySet(); } try { return groupMembers.listAccounts(group<END_MOD>.get(<START_MOD>)<END_MOD>.getGroupUUID(), null).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.<START_MOD>server.project.NoSuchProjectException | java.io.IOException e) { com.vmware.gerrit.owners.<END_MOD>common.<START_MOD>AccountsImpl.log.error(( to list accounts in group   + group),<END_MOD> e); return java.util.Collections.emptySet(); } }
private java.util.Map<java.lang.String, java.lang.Object> toFooterSoyData(com.google.gitiles.Paginator paginator, @javax.annotation.Nullable java.lang.String revision<START_MOD>, com.google.gitiles.LogSoyData.FooterBehavior behavior<END_MOD>) { <START_MOD>switch (behavior) { case NEXT : org.eclipse.jgit.lib.ObjectId next<END_MOD> = <START_MOD>paginator.getNextStart(); if (next == null) { return <END_MOD>com.google.common.collect.<START_MOD>ImmutableMap.of(); } return com.google.common.collect.ImmutableMap.of("nextUrl", copyAndCanonicalizeView(revision).replaceParam(LogServlet.START_PARAM,<END_MOD> next<START_MOD>.name()).toUrl(), "nextText", "Next"); case LOG_HEAD : return com.google.common.collect.ImmutableMap.of<END_MOD>("nextUrl", <START_MOD>com.google.gitiles.GitilesView.log().copyFrom(view<END_MOD>).toUrl()<START_MOD>, "nextText", "Log"); default : throw new java.lang.IllegalStateException(( footer behavior:   + behavior)<END_MOD>); } }
@java.lang.Override public java.lang.String authenticate(com.google.gerrit.server.CurrentUser user, java.util.List<java.lang.String> args) throws com.google.gerrit.sshd.BaseCommand.Failure, com.google.gerrit.sshd.BaseCommand.UnloggedFailure { <START_MOD>if ((args.size()) != 2) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1,   number of arguments } <END_MOD>try { java.net.URL url = new java.net.URL(canonicalWebUrl); java.lang.String path = url.getPath(); java.lang.String project = args.get(0); java.lang.String operation = args.get(1); java.lang.StringBuilder href = new java.lang.StringBuilder(url.getProtocol()).append("://").append(url.getAuthority()).append(path).append((path.endsWith("/") ? "" : "/")).append(project).append("/info/lfs"); com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo info = auth.generateAuthInfo(user, project, operation); com.googlesource.gerrit.plugins.lfs.ExpiringAction action = new com.googlesource.gerrit.plugins.lfs.ExpiringAction(href.toString(), info); return gson.toJson(action); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, ((( configuration error:   +   Git LFS endpoint URL from canonicalWebUrl [ + (canonicalWebUrl)) +   failed. } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { final org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; final org.eclipse.jgit.lib.AbbreviatedObjectId id = commit.abbreviate(7); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.ArrayList<>(); if ((this.maxSubjectLength) < (commit.getShortMessage().length())) { onLineTooLong(id, messages, (( subject > + (this.maxSubjectLength)) +   characters; use shorter first paragraph } int longLineCnt = 0; int nonEmptyCnt = 0; for (java.lang.String line : <START_MOD>com.google.gwt.thirdparty.guava.common.base.Splitter.on('\n').split(<END_MOD>commit.getFullMessage())) { if (!(line.trim().isEmpty())) { nonEmptyCnt++; } if ((this.maxLineLength) < (line.length())) { longLineCnt++; } } if (longLineCnt > (((longLinesThreshold) * nonEmptyCnt) / 100)) { onLineTooLong(id, messages, (( many commit message lines longer than   + (this.maxLineLength)) +   characters; manually wrap lines } return messages; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> tokens = <START_MOD>com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(',').split(<END_MOD>token<START_MOD>)<END_MOD>); if ((tokens.<START_MOD>size()<END_MOD>) != 3) { throw new org.kohsuke.args4j.CmdLineException(owner,   should be specified as <project>,<branch>,<change-id> } try { final com.google.gerrit.reviewdb.client.Change.Key key = Change.Key.parse(tokens<START_MOD>.get(<END_MOD>2<START_MOD>)<END_MOD>); final com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(tokens<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>); final com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, tokens<START_MOD>.get(<END_MOD>1<START_MOD>)<END_MOD>); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchKey(branch, key)) { setter.addValue(cd.getId()); return 1; } } catch (java.lang.IllegalArgumentException e) { throw new org.kohsuke.args4j.CmdLineException(owner,   is not valid } catch (com.google.gwtorm.server.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, ( error:   + (e.getMessage()))); } throw new org.kohsuke.args4j.CmdLineException(owner, (("\"" + token) +   change not found }
private static java.util.Map<java.lang.String, java.lang.String> getParameters(javax.servlet.http.HttpServletRequest req) { final java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); for (java.lang.String pair : <START_MOD>com.google.common.base.Splitter.on(com.google.gerrit.httpd.gitweb.GitwebServlet.QUERY_SPLIT_PATTERN).split(<END_MOD>req.getQueryString())) { final int eq = pair.indexOf('='); if ( < eq) { java.lang.String name = pair.substring(0, eq); java.lang.String value = pair.substring((eq + 1)); name = com.google.gerrit.extensions.restapi.Url.decode(name); value = com.google.gerrit.extensions.restapi.Url.decode(value); params.put(name, value); } } return params; }
private void init() { java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> varParts = <START_MOD>com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('.')<END_MOD>.split(<START_MOD>sectionAndKey)<END_MOD>); if ((varParts.<START_MOD>size()<END_MOD>) != 2) { throw new java.lang.IllegalArgumentException((( name   + (sectionAndKey)) +   expected section.key format } section = varParts<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>; key = varParts<START_MOD>.get(<END_MOD>1<START_MOD>)<END_MOD>; }
private java.lang.String getPublicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = getSshPublicKey(); if ((s != null) && ((s.length()) > 0)) { java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> parts = <START_MOD>com<END_MOD>.<START_MOD>google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on<END_MOD>(   if ((parts.<START_MOD>size()<END_MOD>) > index) { return parts<START_MOD>.get(<END_MOD>index<START_MOD>)<END_MOD>; } } return defaultValue; }
public static java.lang.String trimQuotation(java.lang.String comment) { java.util.StringJoiner j = new java.util.StringJoiner("\n"); java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> lines = <START_MOD>com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('\n').split(<END_MOD>comment<START_MOD>)<END_MOD>); for (int i = 0; i < ((lines.<START_MOD>size()<END_MOD>) - 2); i++) { j.add(lines<START_MOD>.get(<END_MOD>i<START_MOD>)<END_MOD>); } java.lang.String lastLine = lines<START_MOD>.get(((lines.size()<END_MOD>) - 1)<START_MOD>)<END_MOD>; if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLine)) { if ((lines.<START_MOD>size()<END_MOD>) > 1) { j.add(lines<START_MOD>.get(((lines.size()<END_MOD>) - 2)<START_MOD>)<END_MOD>); } return j.toString().trim(); } if ((lines.<START_MOD>size()<END_MOD>) > 1) { java.lang.String lastLines = (lines<START_MOD>.get(((lines.size()<END_MOD>) - 2)<START_MOD>)<END_MOD>) + lastLine; if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLines)) { return j.toString().trim(); } } if ((lines.<START_MOD>size()<END_MOD>) > 1) { j.add(lines<START_MOD>.get(((lines.size()<END_MOD>) - 2)<START_MOD>)<END_MOD>); } j.add(lines<START_MOD>.get(((lines.size()<END_MOD>) - 1)<START_MOD>)<END_MOD>); return j.toString().trim(); }
private void readCgiHeaders(javax.servlet.http.HttpServletResponse res, java.io.InputStream in) throws java.io.IOException { java.lang.String line; while (!((line = readLine(in)).isEmpty())) { if (line.startsWith("HTTP")) { throw new java.io.IOException(( CGI not supported:   + line)); } final int sep = line.indexOf(':'); if (sep < 0) { throw new java.io.IOException(( returned invalid header:   + line)); } final java.lang.String key = line.substring(0, sep).trim(); final java.lang.String value = line.substring((sep + 1)).trim(); if ("Location".equalsIgnoreCase(key)) { res.sendRedirect(value); } else if ("Status".equalsIgnoreCase(key)) { final java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> token = <START_MOD>com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on<END_MOD>(   final int status = java.lang.Integer.parseInt(token<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>); res.setStatus(status); } else { res.addHeader(key, value); } } }
private void configureAliases() { com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); for (java.util.Map.Entry<java.lang.String, java.lang.String> e : aliases.entrySet()) { java.lang.String name = e.getKey(); java.<START_MOD>util.List<java.lang.String> dest = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(com.google.gerrit.sshd.SshModule.ALIAS_SPLIT_PATTEN).split(<END_MOD>e.getValue()<START_MOD>));<END_MOD> com.google.gerrit.sshd.CommandName cmd = com.google.gerrit.sshd.Commands.named(dest<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>); for (int i = 1; i < (dest.<START_MOD>size()<END_MOD>); i++) { cmd = com.google.gerrit.sshd.Commands.named(cmd, dest<START_MOD>.get(i)<END_MOD>); } bind(com.google.gerrit.sshd.Commands.key(gerrit, name)).toProvider(new com.google.gerrit.sshd.AliasCommandProvider(cmd)); } }
public static com.google.gerrit.server.account.HashedPassword decode(java.lang.String encoded) throws org.apache.commons.codec.DecoderException { if (!(encoded.startsWith(com.google.gerrit.server.account.HashedPassword.ALGORITHM_PREFIX))) { throw new org.apache.commons.codec.DecoderException( algorithm } java.<START_MOD>util.List<java.<END_MOD>lang.String<START_MOD>><END_MOD> fields = <START_MOD>com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(<END_MOD>encoded<START_MOD>)<END_MOD>); if ((fields.<START_MOD>size()<END_MOD>) != 4) { throw new org.apache.commons.codec.DecoderException( 4 fields } java.lang.Integer cost = com.google.common.primitives.Ints.tryParse(fields<START_MOD>.get(<END_MOD>1<START_MOD>)<END_MOD>); if (cost == null) { throw new org.apache.commons.codec.DecoderException( parse failed } if (!((cost >= 4) && (cost < 32))) { throw new org.apache.commons.codec.DecoderException(( should be 4..31 inclusive, got   + cost)); } byte[] salt = com.google.gerrit.server.account.HashedPassword.codec.decode(fields<START_MOD>.get(<END_MOD>2<START_MOD>)<END_MOD>); if ((salt.length) != 16) { throw new org.apache.commons.codec.DecoderException(( should be 16 bytes, got   + (salt.length))); } return new com.google.gerrit.server.account.HashedPassword(com.google.gerrit.server.account.HashedPassword.codec.decode(fields<START_MOD>.get(<END_MOD>3<START_MOD>)<END_MOD>), salt, cost); }
@java.lang.<START_MOD>Override<END_MOD> public <START_MOD>boolean<END_MOD> reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) <START_MOD>throws java.io.IOException <END_MOD>{ <START_MOD>try { return reindexIfStaleAsync(id).get(); } catch (<END_MOD>java.util.concurrent.<START_MOD>ExecutionException | <END_MOD>java.lang.<START_MOD>InterruptedException<END_MOD> <START_MOD>e<END_MOD>) { <START_MOD>com.google.gerrit.server.<END_MOD>index<START_MOD>.account.AccountIndexerImpl.log.warn<END_MOD>(<START_MOD> of possibly stale account {} failed <END_MOD>id<START_MOD>.get()<END_MOD>); com.google.common.<START_MOD>base<END_MOD>.<START_MOD>Throwables<END_MOD>.<START_MOD>throwIfInstanceOf(e<END_MOD>.<START_MOD>getCause<END_MOD>(), <START_MOD>java<END_MOD>.<START_MOD>io.IOException.class); throw new java.io.IOException(e<END_MOD>); }<START_MOD> }<END_MOD>
<START_MOD>@java.lang.SuppressWarnings("deprecation") private com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(uuid)) { index(uuid); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }<END_MOD>
@java.lang.<START_MOD>Override<END_MOD> public <START_MOD>boolean<END_MOD> reindexIfStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) <START_MOD>throws java.io.IOException <END_MOD>{ <START_MOD>try { return reindexIfStaleAsync(uuid).get(); } catch (<END_MOD>java.util.concurrent.<START_MOD>ExecutionException | <END_MOD>java.lang.<START_MOD>InterruptedException<END_MOD> <START_MOD>e<END_MOD>) { <START_MOD>com.google.gerrit.server.<END_MOD>index<START_MOD>.group.GroupIndexerImpl.log.warn<END_MOD>(<START_MOD> of possibly stale group {} failed <END_MOD>uuid<START_MOD>.get()<END_MOD>); com.google.common.<START_MOD>base<END_MOD>.<START_MOD>Throwables<END_MOD>.<START_MOD>throwIfInstanceOf(e<END_MOD>.<START_MOD>getCause<END_MOD>(), <START_MOD>java<END_MOD>.<START_MOD>io.IOException.class); throw new java.io.IOException(e<END_MOD>); }<START_MOD> }<END_MOD>
<START_MOD>@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.Account.Id id) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(id)) { index(id); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }<END_MOD>
private com.google.inject.Injector createSysInjector(<START_MOD>int actualThreads<END_MOD>) { return dbInjector.createChildInjector(new com.google.gerrit.extensions.config.FactoryModule() { @java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); install(getIndexModule(<START_MOD>actualThreads<END_MOD>)); factory(ChangeResource.Factory.class); } }); }
@java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); install(getIndexModule(<START_MOD>actualThreads<END_MOD>)); factory(ChangeResource.Factory.class); }
private java.lang.Module getIndexModule(<START_MOD>int actualThreads<END_MOD>) { switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : return com.google.gerrit.lucene.LuceneIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), <START_MOD>actualThreads<END_MOD>); case ELASTICSEARCH : return com.google.gerrit.elasticsearch.ElasticIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), <START_MOD>actualThreads<END_MOD>); default : throw new java.lang.IllegalStateException( index.type } }
private java.util.Set<com.google.gerrit.reviewdb.client.Account<START_MOD>.Id<END_MOD>> toAccounts(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p) { return toAccounts(reviewDb, in, p, null); }
<START_MOD>@java.lang.Override protected java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getAdvertisedRefs(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk revWalk) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { try { return perm.filter(repo.getRefDatabase().getRefs(RefDatabase.ALL), repo, opts); } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { throw e; } catch (java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(); ex.initCause(e); throw ex; } }<END_MOD>
<START_MOD>public static com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions defaults() { return com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.builder().setFilterMeta(false).setFilterTagsSeparately(false).build(); }<END_MOD>
<START_MOD>@org.junit.Test public void testEmailVaildListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailValidListed, com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailDomainWhitelist)).isTrue(); }<END_MOD>
<START_MOD>@org.junit.Test public void testEmailInvaildNotListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailInvalidNotListed, com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailDomainWhitelist)).isFalse(); }<END_MOD>
<START_MOD>@org.junit.Test public void testEmailVaildNotListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailValidNotListed, com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistTest.emailDomainWhitelist)).isFalse(); }<END_MOD>
<START_MOD>@org.junit.Test public void testGetEmailWhitelist() throws java.lang.Exception { }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting private static java.util.List<java.lang.String> getEmailDomainWhiteList(com.google.gerrit.server.config.PluginConfig cfg) { return java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.KEY_EMAIL_DOMAIN_WHITELIST)); }<END_MOD>
<START_MOD>static boolean isActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.KEY_EMAIL_DOMAIN_WHITELIST).length) > 0; }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.util.List<java.lang.String> emailDomainWhitelist) { java.net.URI uri = null; try { uri = new java.net.URI(email); } catch (java.net.URISyntaxException | java.lang.NullPointerException e) { return false; } return emailDomainWhitelist.contains(uri.getHost()); }<END_MOD>
<START_MOD>@org.junit.Test public void validatorInactiveWhenConfigEmpty() { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.isActive(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG)).isFalse(); }<END_MOD>
@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor(BATCH) com.google.common.util.concurrent.ListeningExecutorService getBatchIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { if ((batchExecutor) != null) { return batchExecutor; } int <START_MOD>batchThreads = this.<END_MOD>threads<START_MOD>; if (batchThreads <= 0) batchThreads<END_MOD> = config.getInt("index", null, "batchThreads", 0); if (<START_MOD>batchThreads<END_MOD> <= 0) { <START_MOD>batchThreads<END_MOD> = java.lang.Runtime.getRuntime().availableProcessors(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(<START_MOD>batchThreads<END_MOD>, "Index-Batch")); }
<START_MOD>@org.junit.Test public void indexStalenessIsNotDerivedFromCacheStaleness() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = createGroup("verifiers"); groupIndexer.index(groupUuid); updateGroupWithoutCacheOrIndex(groupUuid, com.google.gerrit.acceptance.api.group.GroupIndexerIT.newGroupUpdate().setDescription("Modified").build()); reloadGroupToCache(groupUuid); boolean reindexed = groupIndexer.reindexIfStale(groupUuid); assertWithMessage("Group should have been reindexed").that(reindexed).isTrue(); }<END_MOD>
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = cfg.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(runner, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
@java.lang.Override public void start() { if (!(supportAutomaticAccountActivityUpdate)) { return; } java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (schedule.isPresent()) { queue.getDefaultQueue().scheduleAtFixedRate(deactivator, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
<START_MOD>public static com.google.gerrit.server.config.ScheduleConfig create(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection) { return com.google.gerrit.server.config.ScheduleConfig.builder(config, section, subsection).build(); }<END_MOD>
<START_MOD>public static com.google.gerrit.server.config.ScheduleConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return com.google.gerrit.server.config.ScheduleConfig.builder(config, section, null); }<END_MOD>
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = gcConfig.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(gcRunner, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
public <START_MOD>com.google.gerrit.server.config.ScheduleConfig.Schedule<END_MOD> <START_MOD>schedule<END_MOD>() { if ((<START_MOD>schedule<END_MOD>) == null) { <START_MOD>schedule = loadSchedule<END_MOD>(); } return <START_MOD>schedule<END_MOD>; }
private static long interval(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyInterval) { try { <START_MOD>return<END_MOD> com.google.gerrit.server.config.ConfigUtil.getTimeUnit(rc, section, subsection, keyInterval, <START_MOD>com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG<END_MOD>, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.IllegalArgumentException e) { <START_MOD>return<END_MOD> com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } }
public <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.server.config.ScheduleConfig.Schedule<START_MOD>><END_MOD> schedule() { if ((schedule) == null) { schedule = loadSchedule(); } return schedule; }
<START_MOD>private boolean isInvalidOrMissing(long interval, long initialDelay) { java.lang.String key = (section()) + ((subsection()) != null ? "." + (subsection()) : ""); if ((interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) && (initialDelay == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG))) { com.google.gerrit.server.config.ScheduleConfig.log.info("No schedule configuration for \"{}\".", key); return true; } if (interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) { com.google.gerrit.server.config.ScheduleConfig.log.error("Incomplete schedule configuration for \"{}\" is ignored. Missing value for \"{}\".", key, ((key + ".") + (keyInterval()))); return true; } if (initialDelay == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) { com.google.gerrit.server.config.ScheduleConfig.log.error("Incomplete schedule configuration for \"{}\" is ignored. Missing value for \"{}\".", key, ((key + ".") + (keyStartTime()))); return true; } if ((interval <= 0) && (initialDelay < 0)) { com.google.gerrit.server.config.ScheduleConfig.log.error("Invalid schedule configuration for \"{}\" is ingnored. ", key); return true; } return false; }<END_MOD>
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertThat(s.schedule()).<START_MOD>isPresent(); assertThat(s.schedule().get()).<END_MOD>isEqualTo(com.google.gerrit.server.config.ScheduleConfig.Schedule.create(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS))); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertThat(s.schedule()).<START_MOD>isEmpty(<END_MOD>); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); <START_MOD>assertThat(s.getInterval()).isEqualTo<END_MOD>(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS)<START_MOD>); assertThat(s.getInitialDelay()).isEqualTo(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS)); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertThat(<END_MOD>s.getInterval())<START_MOD>.isEqualTo(ScheduleConfig.MISSING_CONFIG); assertThat(<END_MOD>s.getInitialDelay())<START_MOD>.isEqualTo(<END_MOD>ScheduleConfig.MISSING_CONFIG); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig.builder(ScheduleConfigTest.config(startTime, interval), "section", "subsection").setNow(ScheduleConfigTest.NOW).build().<START_MOD>schedule().initialDelay<END_MOD>(); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig<START_MOD>.builder<END_MOD>(com.google.gerrit.server.config.ScheduleConfigTest.config(startTime, interval), "section", "subsection"<START_MOD>).setNow(<END_MOD>com.google.gerrit.server.config.ScheduleConfigTest.NOW).<START_MOD>build().<END_MOD>getInitialDelay(); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("i").setKeyStartTime("s").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.<START_MOD>schedule().interval<END_MOD>()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.<START_MOD>schedule().initialDelay<END_MOD>()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setNow(com.google.gerrit.server.config.ScheduleConfigTest.NOW).build(); assertEquals(s.<START_MOD>schedule().interval<END_MOD>(), ScheduleConfig.MISSING_CONFIG); assertEquals(s.<START_MOD>schedule().initialDelay<END_MOD>(), ScheduleConfig.MISSING_CONFIG); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "i", "1h"); rc.setString("a", "b", "s", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = <START_MOD>com.google.gerrit.server.config.ScheduleConfig.builder<END_MOD>(rc, "a", "b"<START_MOD>).setKeyInterval(<END_MOD>"i"<START_MOD>).setKeyStartTime(<END_MOD>"s"<START_MOD>).setNow(<END_MOD>com.google.gerrit.server.config.ScheduleConfigTest.NOW)<START_MOD>.build()<END_MOD>; assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInterval()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = <START_MOD>com.google.gerrit.server.config.ScheduleConfig.builder<END_MOD>(rc, "a", "b"<START_MOD>).setKeyInterval(<END_MOD>"myInterval"<START_MOD>).setKeyStartTime(<END_MOD>"myStart"<START_MOD>).setNow(<END_MOD>com.google.gerrit.server.config.ScheduleConfigTest.NOW)<START_MOD>.build()<END_MOD>; assertEquals(s.getInterval(), ScheduleConfig.MISSING_CONFIG); assertEquals(s.getInitialDelay(), ScheduleConfig.MISSING_CONFIG); }
private static long initialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start != null) { java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern( ]HH:mm java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } <START_MOD>} catch (java.lang.IllegalArgumentException e2) { delay =<END_MOD> com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }
public long getInitialDelay() { <START_MOD>if ((initialDelay) == null) { load(); } <END_MOD>return initialDelay; }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { <START_MOD>java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule =<END_MOD> com.google.gerrit.server.config.ScheduleConfig.builder(ScheduleConfigTest.config(startTime, interval), "section", "subsection").setNow(ScheduleConfigTest.NOW).build().schedule()<START_MOD>; assertThat(schedule).isPresent(); return schedule.get()<END_MOD>.initialDelay(); }
private static void doCreateTable(java.sql.Statement stmt) throws java.sql.SQLException { stmt.executeUpdate(( TABLE IF NOT EXISTS account_patch_reviews ( + (((((( INTEGER DEFAULT   NOT NULL,   +   INTEGER DEFAULT   NOT NULL,   +   INTEGER DEFAULT   NOT NULL,   +   VARCHAR(<START_MOD>256<END_MOD>) DEFAULT '' NOT NULL,   +   primary_key_account_patch_reviews   +   KEY (change_id, patch_set_id, account_id, file_name) + ")"))); }
<START_MOD>public<END_MOD> com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.<START_MOD>ForProject forProject(com.google.gerrit.reviewdb.client.Project.NameKey projectName<END_MOD>)<START_MOD> throws com.google.gerrit.extensions.restapi.ResourceNotFoundException<END_MOD> { <START_MOD>try { return new com<END_MOD>.<START_MOD>googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject<END_MOD>(<START_MOD>cfgFactory.getProjectPluginConfigWithInheritance<END_MOD>(<START_MOD>projectName, pluginName<END_MOD>)); } <START_MOD>catch<END_MOD> <START_MOD>(com<END_MOD>.<START_MOD>google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException((("Project" + (projectName.get<END_MOD>()<START_MOD>)) +   not found<END_MOD> }<START_MOD> }<END_MOD>
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage( reviewers configuration } saveConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.<START_MOD>ForProject.<END_MOD>FILENAME, cfg); return true; }
<START_MOD>java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getReviewerFilterSections() { com.google.common.collect.ImmutableList.Builder<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> b = com.google.common.collect.ImmutableList.builder(); for (java.lang.String f : cfg.getSubsections(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER)) { b.add(newReviewerFilterSection(f)); } return b.build(); }<END_MOD>
<START_MOD>void removeReviewer(java.lang.String filter, java.lang.String reviewer) { if (newReviewerFilterSection(filter).getReviewers().contains(reviewer)) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.REVIEWER))); values.remove(reviewer); if (values.isEmpty()) { cfg.unsetSection(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter); } else { cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.REVIEWER, values); } } }<END_MOD>
<START_MOD>private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection(java.lang.String filter) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> b = com.google.common.collect.ImmutableSet.builder(); for (java.lang.String reviewer : cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.REVIEWER)) { b.add(reviewer); } return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection(filter, b.build()); }<END_MOD>
<START_MOD>@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { cfg = readConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILENAME); }<END_MOD>
private java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getSections(com.google.gerrit.reviewdb.client.Project.NameKey projectName) { <START_MOD>try { <END_MOD>return <START_MOD>config<END_MOD>.<START_MOD>forProject<END_MOD>(projectName).getReviewerFilterSections(); }<START_MOD> catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.error( to get config for project {} projectName.get()); return com.google.common.collect.ImmutableList.of(); } }<END_MOD>
<START_MOD>void addReviewer(java.lang.String filter, java.lang.String reviewer) { if (!(newReviewerFilterSection(filter).getReviewers().contains(reviewer))) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.REVIEWER))); values.add(reviewer); cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.REVIEWER, values); } }<END_MOD>
@java.lang.Override public int compareTo(com.googlesource.gerrit.plugins.importer.GerritApi.Version o) { if (((major) == null) || ((o.major) == null)) { return -1; } if (<START_MOD>major.equals(o.major)) { if (minor.equals(o.minor)) { if (patch.equals(<END_MOD>o.patch)) { return 0; } if ((o.patch) == null) { return 1; } if ((patch) == null) { return -1; } return (patch) - (o.patch); } if ((o.minor) == null) { return 1; } if ((minor) == null) { return -1; } return (minor) - (o.minor); } return (major) - (o.major); }
@org.junit.Test public void validPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.VALID_CHARACTERS.toCharArray()) { <START_MOD>assertThat<END_MOD>(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c))<START_MOD>.isTrue()<END_MOD>; } }
@org.junit.Test public void inalidPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.SOME_INVALID_CHARACTERS.toCharArray()) { <START_MOD>assertThat<END_MOD>(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c))<START_MOD>.isFalse()<END_MOD>; } }
@java.lang.Override public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getRefs(java.lang.String prefix) throws java.io.IOException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs<START_MOD>; try { refs<END_MOD> = <START_MOD>perm<END_MOD>.filter(delegate.getRefs(prefix), <START_MOD>git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); }<END_MOD> java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = com.google.common.collect.Maps.newHashMapWithExpectedSize(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { result.put(ref.getName().substring(prefix.length()), ref); } return refs; }
@java.lang.Override public org.eclipse.jgit.lib.Ref exactRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.exactRef(name); if (ref == null) { return null; } <START_MOD>try { <END_MOD>return <START_MOD>perm<END_MOD>.filter(com.google.common.collect.ImmutableMap.of(name, ref), <START_MOD>git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()<END_MOD>).get(name); }<START_MOD> catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }<END_MOD>
@java.lang.Override public org.eclipse.jgit.lib.Ref getRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.getRef(name); if (ref == null) { return null; } <START_MOD>try { <END_MOD>return <START_MOD>perm<END_MOD>.filter(com.google.common.collect.ImmutableMap.of(ref.getName(), ref), <START_MOD>git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()<END_MOD>).get(ref.getName()); }<START_MOD> catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }<END_MOD>
public static void loadSiteLib(java.nio.file.Path libdir) { try { <START_MOD>java<END_MOD>.<START_MOD>util<END_MOD>.<START_MOD>List<java<END_MOD>.<START_MOD>nio<END_MOD>.<START_MOD>file<END_MOD>.<START_MOD>Path> jars = <END_MOD>com.google.gerrit.common.SiteLibraryLoaderUtil.listJars(libdir<START_MOD>); com.google.gerrit.common.IoUtil.loadJARs(jars); com.google.gerrit.common.SiteLibraryLoaderUtil.log.info( site libraries: {} com.google.gerrit.common.SiteLibraryLoaderUtil.jarList(jars<END_MOD>)); } catch (java.io.IOException e) { com.google.gerrit.common.SiteLibraryLoaderUtil.log.error(( scanning lib directory   + libdir), e); } }
<START_MOD>private static com.google.gerrit.common.data.GroupReference accountToGroup(com.google.gerrit.server.account.AccountState s) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid; if (s.getUserName().isPresent()) { uuid = com.googlesource.gerrit.plugins.singleusergroup.SingleUserGroup.uuid(s.getUserName().get()); } else { uuid = com.googlesource.gerrit.plugins.singleusergroup.SingleUserGroup.uuid(s.getAccount().getId()); } return new com.google.gerrit.common.data.GroupReference(uuid, com.googlesource.gerrit.plugins.singleusergroup.SingleUserGroup.nameOf(uuid, s)); }<END_MOD>
<START_MOD>private void warnErrorEmail(com.google.gerrit.server.mail.receive.MailMessage message, java.lang.String reason) { try { com.google.gerrit.server.mail.send.ErrorEmail em = createErrorEmailFactory.create(); em.setTo(message.from()); em.setReplyTo(message.id()); em.setReason(reason); em.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.mail.receive.MailProcessor.log.error("Cannot send email for erroneous email", e); throw new java.lang.Error(e); } }<END_MOD>
protected void init() throws com.google.gerrit.common.errors.EmailException { setupSoyContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new com.google.gerrit.server.mail.send.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); setHeader("Message-ID", ""); <START_MOD>setHeader("Auto-Submitted", "auto-generated"); <END_MOD>for (com.google.gerrit.extensions.api.changes.RecipientType recipientType : accountsToNotify.keySet()) { add(recipientType, accountsToNotify.get(recipientType)); } setHeader("X-Gerrit-MessageType", messageClass); textBody = new java.lang.StringBuilder(); htmlBody = new java.lang.StringBuilder(); if (((fromId) != null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { appendText(getFromLine()); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.mode", value = "WHITELIST") @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" }) public void listFilterWhitelistFiltersNotListedUser() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo changeInfo = createChangeAndReplyByEmail(); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages; assertThat(messages).hasSize(2); <START_MOD>assertThat(sender.getMessages()).hasSize(0); <END_MOD>}
<START_MOD>@org.junit.Test public void sendNotificationOnMissingMetadatas() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); assertThat(comments).hasSize(2); java.lang.String ts = "null"; java.lang.String txt = newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), "Test Message", null, null, null); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields().from(user.emailAddress).textContent((txt + (textFooterForChange(changeInfo._number, ts)))); sender.clear(); mailProcessor.process(b.build()); assertNotifyTo(user); com.google.gerrit.testing.FakeEmailSender.Message message = sender.nextMessage(); assertThat(message.body()).contains("missing required metadata"); }<END_MOD>
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start != null) { java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern( ]HH:mm java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } } catch (java.<START_MOD>time.format.DateTimeParseException | java.<END_MOD>lang.IllegalArgumentException <START_MOD>e<END_MOD>) { delay = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }
<START_MOD>public static com.google.gerrit.server.config.ScheduleConfig.Schedule createOrFail(long interval, java.lang.String startTime) { return com.google.gerrit.server.config.ScheduleConfig.Schedule.create(interval, startTime).orElseThrow(java.lang.IllegalStateException::new); }<END_MOD>
<START_MOD>private static long computeInitialDelay(long interval, java.lang.String start) { return com.google.gerrit.server.config.ScheduleConfig.computeInitialDelay(interval, start, com.google.gerrit.server.config.ScheduleConfig.NOW); }<END_MOD>
<START_MOD>private static long computeInitialDelay(long interval, java.lang.String start, java.time.ZonedDateTime now) { checkNotNull(start); java.time.format.DateTimeFormatter formatter = java.time.format.DateTimeFormatter.ofPattern("[E ]HH:mm").withLocale(java.util.Locale.US); java.time.LocalTime firstStartTime = java.time.LocalTime.parse(start, formatter); java.time.ZonedDateTime startTime = now.with(firstStartTime); try { java.time.DayOfWeek dayOfWeek = formatter.parse(start, java.time.DayOfWeek::from); startTime = startTime.with(dayOfWeek); } catch (java.time.format.DateTimeParseException ignored) { } startTime = startTime.truncatedTo(java.time.temporal.ChronoUnit.MINUTES); long delay = (java.time.Duration.between(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } return delay; }<END_MOD>
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.time.ZonedDateTime now, long interval) { java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start <START_MOD>==<END_MOD> null) { <START_MOD>return com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit<END_MOD>.<START_MOD>server<END_MOD>.<START_MOD>config<END_MOD>.<START_MOD>ScheduleConfig<END_MOD>.<START_MOD>MISSING_CONFIG<END_MOD>; } <START_MOD>return<END_MOD> <START_MOD>com.google.gerrit.server.config.ScheduleConfig.computeInitialDelay<END_MOD>(<START_MOD>interval,<END_MOD> <START_MOD>start,<END_MOD> <START_MOD>now<END_MOD>); } catch (java.lang.IllegalArgumentException e2) { <START_MOD>return<END_MOD> com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } }
public static com.google.gerrit.server.config.ScheduleConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return new com.google.gerrit.server.config.AutoValue_ScheduleConfig.Builder().setNow(<START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit<END_MOD>.<START_MOD>server<END_MOD>.<START_MOD>config<END_MOD>.<START_MOD>ScheduleConfig<END_MOD>.<START_MOD>NOW<END_MOD>).setKeyInterval(com.google.gerrit.server.config.ScheduleConfig.KEY_INTERVAL).setKeyStartTime(com.google.gerrit.server.config.ScheduleConfig.KEY_STARTTIME).setConfig(config).setSection(section); }
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isInternalUser()) || (canPerformOnAnyRef(Permission.READ)))) || (isOwner()); case READ : return (!(isHidden())) && (allRefsAreVisible(java.util.Collections.emptySet())); case CREATE_REF : return canAddRefs(); case CREATE_CHANGE : return canCreateChanges(); case RUN_RECEIVE_PACK : return canRunReceivePack(); case RUN_UPLOAD_PACK : return canRunUploadPack(); case PUSH_AT_LEAST_ONE_REF : return canPushToAtLeastOneRef(); case <START_MOD>READ_CONFIG : return controlForRef(RefNames.REFS_CONFIG).canPerform(Permission.READ); case <END_MOD>BAN_COMMIT : case READ_REFLOG : case WRITE_CONFIG : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm +   unsupported }
<START_MOD>private void reindexAllGroups() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.Iterable<com.google.gerrit.common.data.GroupReference> allGroups = groups.getAllGroupReferences(db)::iterator; for (com.google.gerrit.common.data.GroupReference group : allGroups) { groupCache.onCreateGroup(group.getUUID()); } }<END_MOD>
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return   was already destroyed } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] <START_MOD>trimmedArgs<END_MOD> = dcmd.<START_MOD>getTrimmedArguments<END_MOD>();<START_MOD> if (trimmedArgs != null) {<END_MOD> for (int i = 1; i < (<START_MOD>trimmedArgs<END_MOD>.length); i++) { commandName.append(".").append(<START_MOD>trimmedArgs<END_MOD>[i]);<START_MOD> }<END_MOD> } return commandName.toString(); }
private boolean canForceUpdate() { if (canPushWithForce()) { return true; } switch (getUser().getAccessPath()) { case GIT : return false; case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return ((isOwner()) && (!(<START_MOD>canPerform<END_MOD>(Permission.PUSH<START_MOD>, true, true<END_MOD>)))) || (projectControl.isAdmin()); } }
private boolean canDelete() { if (RefNames.REFS_CONFIG.equals(refName)) { return false; } switch (getUser().getAccessPath()) { case GIT : return (canPushWithForce()) || (canPerform(Permission.DELETE)); case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return (((isOwner()) || (canPushWithForce())) || (canPerform(Permission.DELETE))) || (projectControl.isAdmin()); } }
<START_MOD>private boolean canPerform(java.lang.String permissionName, boolean isChangeOwner, boolean withForce) { for (com.google.gerrit.server.permissions.PermissionCollection.BlockAccessSection s : relevant.getBlocks(permissionName)) { boolean blocked = false; for (com.google.gerrit.common.data.PermissionRule pr : s.blocks) { if (projectControl.match(pr, isChangeOwner)) { blocked = true; break; } } if (blocked) { for (com.google.gerrit.common.data.PermissionRule pr : s.overrides) { if (projectControl.match(pr, isChangeOwner)) { return (pr.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW); } } } } for (com.google.gerrit.common.data.PermissionRule pr : relevant.getRules(permissionName)) { if (projectControl.match(pr, isChangeOwner)) { if ((pr.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.DENY)) { return false; } if (withForce) { if (((pr.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW)) && (pr.getForce())) { return true; } } else if ((pr.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW)) { return true; } } } return false; }<END_MOD>
boolean canForceEditTopicName() { return <START_MOD>canPerform<END_MOD>(Permission.EDIT_TOPIC_NAME); }
<START_MOD>public java<END_MOD>.<START_MOD>util<END_MOD>.<START_MOD>List<<END_MOD>com.google.gerrit.common.data.PermissionRule<START_MOD>><END_MOD> <START_MOD>getRules(java.lang.String perm<END_MOD>) { return <START_MOD>rulesByPermission<END_MOD>.get(<START_MOD>perm<END_MOD>); }
public java.util.List<com.google.gerrit.<START_MOD>server<END_MOD>.<START_MOD>permissions<END_MOD>.<START_MOD>PermissionCollection.BlockAccessSection<END_MOD>> <START_MOD>getBlocks<END_MOD>(<START_MOD>java.lang.String perm<END_MOD>) { return <START_MOD>blockByPermission<END_MOD>.<START_MOD>get<END_MOD>(<START_MOD>perm<END_MOD>); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getPermission(java.lang.String permissionName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = <START_MOD>rulesByPermission<END_MOD>.get(permissionName); return r != null ? r : java.util.Collections.<com.google.gerrit.common.data.PermissionRule>emptyList(); }
private com.google.gerrit.common.data.PermissionRange toRange(java.lang.String permissionName, java.util.List<com.google.gerrit.common.data.PermissionRule> ruleList) { return new com.google.gerrit.common.data.PermissionRange(permissionName, <START_MOD>(-1)<END_MOD>, <START_MOD>1<END_MOD>); }
<START_MOD>static <END_MOD>java.util.List<com.google.gerrit.common.data.PermissionRule> <START_MOD>findRules(java.util.List<com.google.gerrit.common.data.AccessSection> sections, <END_MOD>java.lang.String <START_MOD>permName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.AccessSection s : sections) { com.google.gerrit.common.data.Permission p = s.getPermission(permName); if (p == null) { continue; } for (com.google.gerrit.common.data.PermissionRule pr : p.getRules()) { r.add(pr); } if (p.getExclusiveGroup()) { break; } }<END_MOD> return <START_MOD>r; }<END_MOD>
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.<START_MOD>WORK_IN_PROGRESS<END_MOD>; if (ui.yesno(false,   draft changes to<START_MOD> private changes (default is<END_MOD> work-in-progress)? { strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.<START_MOD>PRIVATE<END_MOD>; } ui.message(java.lang.String.format( draft changes with %s changes ... strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE)) ? "is_private" : "work_in_progress"; e.execute(java.lang.String.format(( changes SET %s = 'Y', created_on = created_on WHERE status = 'd' OR   + ( (SELECT * FROM patch_sets WHERE   +   = changes.change_id AND patch_sets.draft = 'Y') column)); e.execute( changes SET status = 'n', created_on = created_on WHERE status = 'd' } ui.message("done"); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS; if (ui.yesno(false,   draft changes to private changes (default is work-in-progress)? { strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE; } ui.message(java.lang.String.format( draft changes with %s changes ... strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE)) ? "is_private" : "work_in_progress"; e.execute(java.lang.String.format(( changes <START_MOD>  + (((((((((<END_MOD> %s = 'Y', <START_MOD>  +   status = 'n'   +   <END_MOD>created_on = created_on <START_MOD>  +   status = 'd'   +   OR (status = 'n'   +   AND EXISTS   +   (SELECT *   +   FROM patch_sets   +   <END_MOD>WHERE patch_sets.change_id <START_MOD>= changes.change_id   +   <END_MOD>AND patch_sets.draft = 'Y')<START_MOD>)  <END_MOD> column)); } ui.message("done"); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return   was already destroyed } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] <START_MOD>trimmedArgs<END_MOD> = dcmd.<START_MOD>getTrimmedArguments<END_MOD>(); <START_MOD>if<END_MOD> (<START_MOD>trimmedArgs<END_MOD> <START_MOD>!=<END_MOD> <START_MOD>null<END_MOD>) { commandName.append(<START_MOD>com.google.gerrit.sshd.Joiner.on(<END_MOD>".").<START_MOD>join<END_MOD>(<START_MOD>trimmedArgs)<END_MOD>); } return commandName.toString(); }
<START_MOD>public java.lang.String myUrl() { throw new java.lang.UnsupportedOperationException("peerInfo.jgroups.myUrl not supported"); }<END_MOD>
@org.junit.Test public void testHealthCheckEnabled() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration()<END_MOD>.<START_MOD>healthCheck().enabled()).isTrue(); globalPluginConfig.setBoolean<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.HEALTH_CHECK_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.ENABLE_KEY, false); assertThat(<START_MOD>getConfiguration()<END_MOD>.healthCheck().enabled()).isFalse(); <START_MOD>globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HEALTH_CHECK_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.ENABLE_KEY, true); assertThat(getConfiguration().healthCheck().enabled()).isTrue(); <END_MOD>}
@org.junit.Test public void testGetJGroupsSkipInterface() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration<END_MOD>().jgroups().skipInterface()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SKIP_INTERFACE_LIST); <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setStringList<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SKIP_INTERFACE_KEY<START_MOD>, wiremock<END_MOD>.<START_MOD>com.google.common.collect.Lists.newArrayList<END_MOD>("lo*", "eth0")); assertThat(<START_MOD>getConfiguration()<END_MOD>.jgroups().skipInterface()).containsAllOf("lo*", "eth0").inOrder(); }
@org.junit.Test public void testGetJGroupsCluster() throws java.lang.Exception { <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setString<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUSTER_NAME_KEY<START_MOD>, <END_MOD>"foo"); assertThat(<START_MOD>getConfiguration()<END_MOD>.jgroups().clusterName()).isEqualTo("foo"); }
@org.junit.Test public void testGetWebsessionSynchronize() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration()<END_MOD>.<START_MOD>websession().synchronize()).isTrue(); globalPluginConfig.setBoolean<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>false<END_MOD>); assertThat(<START_MOD>getConfiguration()<END_MOD>.websession().synchronize()).<START_MOD>isFalse<END_MOD>(); <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setString<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>"invalidBoolean"<END_MOD>); assertThat(<START_MOD>getConfiguration<END_MOD>().websession().synchronize()).isTrue(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { <START_MOD>globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, wiremock.com.google.common.collect.Lists.newArrayList("^my_cache.*", "other")<END_MOD>); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(<START_MOD>getConfiguration()<END_MOD>); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) { assertThat(matcher.matches(cache)).isTrue(); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo")) { assertThat(matcher.matches(cache)).isFalse(); } }
@org.junit.Test public void testGetEventSynchronize() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration()<END_MOD>.<START_MOD>event().synchronize()).isTrue(); globalPluginConfig.setBoolean<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>false<END_MOD>); assertThat(<START_MOD>getConfiguration()<END_MOD>.event().synchronize()).<START_MOD>isFalse<END_MOD>(); <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setString<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>"invalidBoolean"<END_MOD>); assertThat(<START_MOD>getConfiguration<END_MOD>().event().synchronize()).isTrue(); }
@org.junit.Test public void testGetIndexSynchronize() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration()<END_MOD>.<START_MOD>index().synchronize()).isTrue(); globalPluginConfig.setBoolean<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>false<END_MOD>); assertThat(<START_MOD>getConfiguration()<END_MOD>.index().synchronize()).<START_MOD>isFalse<END_MOD>(); <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setString<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>"invalidBoolean"<END_MOD>); assertThat(<START_MOD>getConfiguration<END_MOD>().index().synchronize()).isTrue(); }
<START_MOD>@org.junit.Test public void testCachePatternMatcher() throws java.lang.Exception { when(configurationMock.cache().patterns()).thenReturn(wiremock.com.google.common.collect.Lists.newArrayList("^my_cache.*", "other")); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(configurationMock); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_groups", "project_list", "my_cache_a", "my_cache_b", "other")) { assertThat(matcher.matches(cache)).isTrue(); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo")) { assertThat(matcher.matches(cache)).isFalse(); } }<END_MOD>
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, com.google.common.collect.Lists.newArrayList("^my_cache.*", "other")); <START_MOD>assertThat<END_MOD>(getConfiguration()<START_MOD>.cache(<END_MOD>)<START_MOD>.patterns<END_MOD>(<START_MOD>))<END_MOD>.<START_MOD>containsExactly<END_MOD>(<START_MOD>"^my_cache.*"<END_MOD>, "other"); }
@org.junit.Test public void testGetCacheSynchronize() throws java.lang.Exception { <START_MOD>assertThat<END_MOD>(<START_MOD>getConfiguration()<END_MOD>.<START_MOD>cache().synchronize()).isTrue(); globalPluginConfig.setBoolean<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>false<END_MOD>); assertThat(<START_MOD>getConfiguration()<END_MOD>.cache().synchronize()).<START_MOD>isFalse<END_MOD>(); <START_MOD>globalPluginConfig<END_MOD>.<START_MOD>setString<END_MOD>(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION<START_MOD>, null<END_MOD>, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, <START_MOD>"invalidBoolean"<END_MOD>); assertThat(<START_MOD>getConfiguration<END_MOD>().cache().synchronize()).isTrue(); }
static boolean onTime(java.lang.String dateTime) { <START_MOD>return<END_MOD> (com.googlesource.gerrit.plugins.lfs.LfsAuthToken.<START_MOD>FORMAT.<END_MOD>now().compareTo(dateTime)) <= 0; }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(Verifier.onTime(<START_MOD>formatter<END_MOD>.<START_MOD>format<END_MOD>(now<START_MOD>()<END_MOD>.plusMillis(1)))).isTrue(); }
<START_MOD>public java.lang.String format(java.time.Instant instant) { return format.format(instant); }<END_MOD>
<START_MOD>public java.lang.String now(int secondsToAdd) { return format.format(java.time.Instant.now().plusSeconds(secondsToAdd)); }<END_MOD>
<START_MOD>public java.lang.String now() { return format.format(java.time.Instant.now()); }<END_MOD>
<START_MOD>@org.junit.Test public void formatWithDefaultTimezone() throws java.lang.Exception { org.joda.time.DateTime now = org.joda.time.DateTime.now(); java.lang.String jodaFormat = org.joda.time.format.ISODateTimeFormat.dateTime().print(now); com.googlesource.gerrit.plugins.lfs.LfsDateTime formatter = com.googlesource.gerrit.plugins.lfs.LfsDateTime.instance(); java.lang.String javaFormat = formatter.format(java.time.Instant.ofEpochMilli(now.getMillis())); assertThat(javaFormat).isEqualTo(jodaFormat); }<END_MOD>
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.<START_MOD>FORMAT<END_MOD>.now(expirationSeconds); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(Verifier.onTime(<START_MOD>formatter<END_MOD>.<START_MOD>format<END_MOD>(now<START_MOD>()<END_MOD>.minusMillis(1)))).isFalse(); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if ((request instanceof javax.servlet.http.HttpServletRequest) && (response instanceof javax.servlet.http.HttpServletResponse)) { java.lang.String method = ((javax.servlet.http.HttpServletRequest) (request)).getMethod(); if (((method == "POST") || (method == "PUT")) || (method == "DELETE")) { ((javax.servlet.http.HttpServletResponse) (response)).sendError(com.googlesource.gerrit.plugins.readonly.SC_SERVICE_UNAVAILABLE, <START_MOD>this.message<END_MOD>); return; } } chain.doFilter(request, response); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { throw new com.google.gerrit.server.git.validators.CommitValidationException(<START_MOD>this<END_MOD>.<START_MOD>message<END_MOD>); }
<START_MOD>@java.lang.Override public java.lang.String toString() { return name().toLowerCase(java.util.Locale.US); }<END_MOD>
<START_MOD>@org.junit.After <END_MOD>public void tearDown() throws java.lang.Exception { stat.execute(( TABLE   + (com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME))); store.stop(); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(<START_MOD>boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet<END_MOD>) throws java.lang.Exception { return getConfig("^WIP.*", <START_MOD>publishOnPatchSetCreated, ignoreRebaseEmptyPatchSet<END_MOD>); }
<START_MOD>@org.junit.Test public void doesNotPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesNotPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenNoCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesNotPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }<END_MOD>
<START_MOD>public boolean getIgnoreRebaseEmptyPatchSet() { return ignoreRebaseEmptyPatchSet; }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated<START_MOD>, boolean ignoreRebaseEmptyPatchSet<END_MOD>) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore); when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated); <START_MOD>when(mockPluginConfig.getBoolean("ignore-rebase-empty-patch-set", true)).thenReturn(ignoreRebaseEmptyPatchSet); <END_MOD>return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
<START_MOD>@org.junit.Test public void doesNotPublishWhenNoCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenRework() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttr); mockAttr.kind = com.google.gerrit.extensions.client.ChangeKind.REWORK; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } <START_MOD>try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmptyPatchSet()) && (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE)))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn( checking patch set kind e); } <END_MOD>boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.regex.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result = !(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn( specified ignore pattern was invalid e); } return result; }
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug( {} {} operation.name().toLowerCase(java.util.Locale.US), type, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.atomic.AtomicInteger idLock = getAndIncrementIdLock(id); synchronized(<START_MOD>this<END_MOD>) { index(id, operation); } if ((idLock.decrementAndGet()) == 0) { removeIdLock(id); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_CONFLICT, e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.error( to update {} index type, e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format( trying to find %s   type); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, msg); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }
<START_MOD>public static com.google.inject.AbstractModule module() { return new com.google.inject.AbstractModule() { @java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHOR_EMAIL_WHITELIST)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Author Email Whitelist", null, com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY, null, false, "Whitelist of author email addresses that will be permitted.")); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_COMMITTER_EMAIL_WHITELIST)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Committter Email Whitelist", null, com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY, null, false, "Whitelist of committer email addresses that will be permitted.")); } }; }<END_MOD>
@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.uploadvalidator.PatternCacheModule()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FooterValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.<START_MOD>EmailWhitelistValidator<END_MOD>.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.module()); bind(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactory.class).to(com.googlesource.gerrit.plugins.uploadvalidator.PluginConfigWithInheritanceFactory.class).in(Scopes.SINGLETON); }
<START_MOD>@com.google.common.annotations.VisibleForTesting static boolean isCommitterActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_COMMITTER_EMAIL_WHITELIST).length) > 0; }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.lang.String[] emailWhitelist) { return java.util.Arrays.stream(emailWhitelist).anyMatch(( s) -> java.util.regex.Pattern.matches(s, com.google.common.base.Strings.nullToEmpty(email))); }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting static java.lang.String[] getAuthorEmailWhiteList(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHOR_EMAIL_WHITELIST); }<END_MOD>
<START_MOD>@java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHOR_EMAIL_WHITELIST)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Author Email Whitelist", null, com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY, null, false, "Whitelist of author email addresses that will be permitted.")); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_COMMITTER_EMAIL_WHITELIST)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Committter Email Whitelist", null, com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY, null, false, "Whitelist of committer email addresses that will be permitted.")); }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting static boolean isAuthorActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHOR_EMAIL_WHITELIST).length) > 0; }<END_MOD>
<START_MOD>@com.google.common.annotations.VisibleForTesting static java.lang.String[] getCommitterEmailWhiteList(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_COMMITTER_EMAIL_WHITELIST); }<END_MOD>
@java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance("ItsTestName"); <START_MOD>itsPath<END_MOD> = randomTargetPath()<START_MOD>.resolve("etc").resolve("its")<END_MOD>; assertFalse((( <START_MOD>( + (itsPath)) +   <END_MOD>already exists java.nio.file.Files.exists(<START_MOD>itsPath<END_MOD>)); cleanupSitePath = true; rulesConfigReader = createMock(com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.class); bind(com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.class).toInstance(rulesConfigReader); rulesProjectCache = createMock(com.googlesource.gerrit.plugins.its.base.workflow.ItsRulesProjectCache.class); bind(com.googlesource.gerrit.plugins.its.base.workflow.ItsRulesProjectCache.class).toInstance(rulesProjectCache); bind(java.nio.file.Path.class).annotatedWith(com.<START_MOD>googlesource.gerrit.plugins.its.base.ItsPath.class).toInstance(itsPath<END_MOD>); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.GlobalRulesFileName.class).toInstance(com.googlesource.gerrit.plugins.its.base.workflow.RuleBaseTest.RuleBaseKind.GLOBAL.fileName); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.PluginRulesFileName.class).toInstance(com.googlesource.gerrit.plugins.its.base.workflow.RuleBaseTest.RuleBaseKind.ITS.fileName); }
<START_MOD>@com.google.inject.Provides @com.googlesource.gerrit.plugins.its.base.ItsPath @com.google.inject.Inject java.nio.file.Path itsPath(@com.google.gerrit.server.config.SitePath java.nio.file.Path sitePath) { return sitePath.normalize().resolve("etc").resolve("its"); }<END_MOD>
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} successfully indexed id); break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} successfully deleted from index id); break; } <START_MOD>indexTs.update("change"); }<END_MOD>
@java.lang.Override protected void configure() { bind(java.util.concurrent.Executor.class).annotatedWith(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutor.class).toProvider(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.ChangeIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.AccountIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); <START_MOD>com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.LifecycleListener.class).to(com.ericsson.gerrit.plugins.highavailability.AutoReindexAtStart.class); <END_MOD>}
<START_MOD>public boolean autoReindexAtStart() { return autoReindexAtStart; }<END_MOD>
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Account.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug( {} successfully indexed id); <START_MOD>indexTs.update("account"); <END_MOD>}
@java.lang.Override void index(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(uuid); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug( {} successfully indexed uuid); <START_MOD>indexTs.update("group"); <END_MOD>}
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { <START_MOD>com.google.gerrit.reviewdb.client.Change change = null; <END_MOD>switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { change = db.changes().get(id); if (change <START_MOD>!=<END_MOD> null) { indexer.index(db, change); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} successfully indexed id); } <START_MOD>} <END_MOD>catch (java.lang.Exception e) { if (!(isCausedByNoSuchChangeException(e))) { throw e; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} was deleted, aborting forwarded indexing the change. id.get()); } <START_MOD>if (change == null) { indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} not found, deleted from index id); } <END_MOD>break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug( {} successfully deleted from index id); break; } }
public void setLastLoginExternalIdKey(com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.Key externalIdKey) { put(lastLoginExternalIdPropertyKey, externalIdKey); }
private void convertLocalUserToLowerCase(<START_MOD>final com.google.gerrit.reviewdb<END_MOD>.server.<START_MOD>ReviewDb db, final com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD> extId) { if (extId.isScheme(<START_MOD>AccountExternalId<END_MOD>.SCHEME_GERRIT)) { <START_MOD>final <END_MOD>java.lang.String localUser = extId.<START_MOD>getSchemeRest(); final<END_MOD> java.lang.String localUserLowerCase = localUser.toLowerCase(java.util.Locale.US); if (!(localUser.equals(localUserLowerCase))) { <START_MOD>final com.google.gerrit.reviewdb.client.AccountExternalId.Key extIdKeyLowerCase<END_MOD> = <START_MOD>new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD>.SCHEME_GERRIT, localUserLowerCase<START_MOD>); final com.google.gerrit.reviewdb.client.AccountExternalId extIdLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId(extId.getAccountId()<END_MOD>, <START_MOD>extIdKeyLowerCase); try { db.accountExternalIds().insert(java.util.Collections.singleton(<END_MOD>extIdLowerCase)<START_MOD>); db.accountExternalIds().delete(java.util.Collections.singleton(extId)); } catch (com.google.gwtorm.server.OrmException error) { java.lang.System.err.println((   + (error.getMessage()))); } } } }<END_MOD>
@java.lang.Override public int run() throws java.lang.Exception { <START_MOD>if ((threads) <= 0) { threads = 1; }<END_MOD> dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); manager.add(dbInjector, dbInjector.createChildInjector(com.google.gerrit.server.schema.SchemaVersionCheck.module())); manager.start(); dbInjector.injectMembers(this); try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { <START_MOD>todo = db.accountExternalIds().all().toList(); synchronized(monitor) { monitor.beginTask( local usernames todo.size()); } } final <END_MOD>java.util.<START_MOD>List<END_MOD><com.google.gerrit.<START_MOD>pgm.LocalUsernamesToLowerCase.Worker<END_MOD>> <START_MOD>workers = new java.util.ArrayList<>(threads); for (int tid = 0; tid < (threads); tid++) { com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker t = new com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker(); t.start(); workers.add(t); } for (com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker t : workers) { t.join(); } synchronized(<END_MOD>monitor<START_MOD>) {<END_MOD> monitor.endTask(); <START_MOD>} <END_MOD>manager.stop(); return 0; }
<START_MOD>private com.google.gerrit.reviewdb.client.AccountExternalId next() { synchronized(todo) { if (todo.isEmpty()) { return null; } return todo.remove(((todo.size()) - 1)); } }<END_MOD>
private static boolean correctUser(java.lang.String user, com.google.gerrit.httpd.WebSession session) { com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.Key id = session.getLastLoginExternalId(); return (id != null) && (id.equals(<START_MOD>new <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.<START_MOD>Key(<END_MOD>SCHEME_GERRIT, user))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.ConfirmEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( required } if (input == null) { input = new com.google.gerrit.server.config.ConfirmEmail.Input(); } if ((input.token) == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( token } try { com.google.gerrit.server.mail.EmailTokenVerifier.ParsedToken token = emailTokenVerifier.decode(input.token); com.google.gerrit.reviewdb.client.Account.Id accId = user.getAccountId(); if (accId.equals(token.getAccountId())) { accountManager.link(accId, token.toAuthRequest()); return com.google.gerrit.extensions.restapi.Response.none(); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( token } catch (com.google.gerrit.server.mail.EmailTokenVerifier e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( token } catch (com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } }
private com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators))); }
private com.google.gerrit.server.git.validators.CommitValidators forReceiveCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(repo, rw); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.CommitterUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.BannedCommitsValidator(rejectCommits), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators))); } }
private void writeObject(final java.io.ObjectOutputStream out) throws java.io.IOException { writeVarInt32(out, 1); writeVarInt32(out, accountId.get()); writeVarInt32(out, 2); writeFixInt64(out, refreshCookieAt); writeVarInt32(out, 3); writeVarInt32(out, (persistentCookie ? 1 : 0)); if ((externalId) != null) { writeVarInt32(out, 4); writeString(out, externalId.<START_MOD>get<END_MOD>()); } if ((sessionId) != null) { writeVarInt32(out, 5); writeString(out, sessionId); } writeVarInt32(out, 6); writeFixInt64(out, expiresAt); if ((auth) != null) { writeVarInt32(out, 7); writeString(out, auth); } writeVarInt32(out, 0); }
<START_MOD>AccountExternalId<END_MOD>.Key getExternalId() { return externalId; }
private <START_MOD>AccountExternalId<END_MOD>.Key toExtIdKey(byte[] fp) { return <START_MOD>new com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD>.Key(com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client.AccountExternalId<END_MOD>.SCHEME_GPGKEY, com.google.common.io.BaseEncoding.base16().encode(fp)); }
com.google.gerrit.httpd.WebSessionManager.Val createVal(<START_MOD>final <END_MOD>com.google.gerrit.httpd.WebSessionManager.Key key, <START_MOD>final <END_MOD>com.google.gerrit.reviewdb.client.Account.Id who, <START_MOD>final <END_MOD>boolean remember, <START_MOD>final com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD>.Key lastLogin, java.lang.String sid, java.lang.String auth) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long now = nowMs(); final long refreshCookieAt = now + refresh; final long expiresAt = now + (sessionMaxAgeMillis); if (sid == null) { sid = newUniqueToken(who); } if (auth == null) { auth = newUniqueToken(who); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth); self.put(key.token, val); return val; }
public java.util.List<java.lang.String> getSecondaryEmails(com.google.gerrit.reviewdb.client.Account account, java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> externalIds) { java.util.List<java.lang.String> emails = new java.util.ArrayList(com.google.gerrit.server.account.AccountState.getEmails(externalIds)); if ((account.getPreferredEmail()) != null) { emails.remove(account.getPreferredEmail()); } java.util.Collections.sort(emails); return emails; }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(<START_MOD>new <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.<START_MOD>Key(<END_MOD>SCHEME_GERRIT, username))).map(<START_MOD>AccountExternalId<END_MOD>::<START_MOD>getAccountId<END_MOD>); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException( in use by another account } update(db, who, extId); } else { <START_MOD>extId = com.google.gerrit.server.account.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()); db.accountExternalIds<END_MOD>().insert(<START_MOD>java.util.Collections.singleton(extId.asAccountExternalId())); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress()) != null) { byEmailCache.evict(who.getEmailAddress()); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, <END_MOD>who.getExternalIdKey(), false); } }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { <START_MOD>com.google.gerrit.reviewdb.client.AccountExternalId.Key key = who.getExternalIdKey().asAccountExternalIdKey(); <END_MOD>java.util.<START_MOD>List<END_MOD><com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId.Key<END_MOD>> <START_MOD>filteredKeysByScheme<END_MOD> = <START_MOD>filterKeysByScheme(key.getScheme(), <END_MOD>db.accountExternalIds().byAccount(to)<START_MOD>); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.size()) > 1) || (!(filteredKeysByScheme.contains(key))))) { db.accountExternalIds().deleteKeys(filteredKeysByScheme); } byIdCache.evict(to); return link(to, <END_MOD>who); } }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException(((   + (who.getExternalIdKey().get())) +   in use by another account } <START_MOD>db.accountExternalIds<END_MOD>().delete(<START_MOD>java.util.Collections.singleton(extId.asAccountExternalId())); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = <END_MOD>db<START_MOD>.accounts().get(from<END_MOD>); if ((<START_MOD>(a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(<END_MOD>who.getEmailAddress())<START_MOD>)) { a.setPreferredEmail(<END_MOD>null)<START_MOD>; db.accounts().update(java.util.Collections.singleton(<END_MOD>a<START_MOD>)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException(((   + (who.getExternalIdKey<END_MOD>().get(<START_MOD>))) +   not found } return new com.google.gerrit.server.account.AuthResult(<END_MOD>from<START_MOD>, <END_MOD>who.getExternalIdKey(), false); } }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.server.account.ExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); <START_MOD>db.accountExternalIds<END_MOD>().delete(<START_MOD>java.util.Collections.singleton(<END_MOD>extId<START_MOD>.asAccountExternalId())<END_MOD>); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId id = findExternalId(db, who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException( error, account inactive } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException( error e); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> putGpgKeys(com.google.gerrit.server.account.AccountResource account, java.util.List<java.lang.String> add, java.util.List<java.lang.String> delete) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.GpgException { com.google.gerrit.gpg.server.PostGpgKeys.Input in = new com.google.gerrit.gpg.server.PostGpgKeys.Input(); in.add = add; in.delete = delete; try { return postGpgKeys.apply(account, in); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.server.GpgException(e); } }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.FluentIterable<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> getGpgExtIds(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(db.accountExternalIds().byAccount(accountId)).filter(( in) -> in.isScheme(com.google.gerrit.gpg.server.SCHEME_GPGKEY)); }
static byte[] parseFingerprint(java.lang.String str, java.lang.Iterable<com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD>> existingExtIds) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { str = com.google.common.base.CharMatcher.whitespace().removeFrom(str).toUpperCase(); if ((((str.length()) != 8) && ((str.length()) != 40)) || (!(com.google.common.base.CharMatcher.anyOf("0123456789ABCDEF").matchesAllOf(str)))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } byte[] fp = null; for (com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD> extId : existingExtIds) { java.lang.String fpStr = extId.<START_MOD>getSchemeRest<END_MOD>(); if (!(fpStr.endsWith(str))) { continue; } else if (fp != null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(( keys found for   + str)); } fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); if ((str.length()) == 40) { break; } } if (fp == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } return fp; }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { com.google.gerrit.gpg.server.GpgKeys.checkVisible(self, rsrc); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keys = new java.util.HashMap<>(); try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { for (com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD> extId : getGpgExtIds(rsrc)) { java.lang.String fpStr = extId.<START_MOD>getSchemeRest<END_MOD>(); byte[] fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); boolean found = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(com.google.gerrit.gpg.server.GpgKeys.keyId(fp))) { if (java.util.Arrays.equals(keyRing.getPublicKey().getFingerprint(), fp)) { found = true; com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing.getPublicKey(), checkerFactory.create(rsrc.getUser(), store), store); keys.put(info.id, info); info.id = null; break; } } if (!found) { com.google.gerrit.gpg.server.GpgKeys.log.warn( public key stored for fingerprint {} com.google.gerrit.gpg.Fingerprint.toString(fp)); } } } return keys; }
com.google.gerrit.httpd.WebSessionManager.Val createVal(<START_MOD>final <END_MOD>com.google.gerrit.httpd.WebSessionManager.Key key,<START_MOD> final<END_MOD> com.google.gerrit.httpd.WebSessionManager.Val val) {<START_MOD> final<END_MOD> com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId(); <START_MOD>final <END_MOD>boolean remember = val.isPersistentCookie(); <START_MOD>final <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.Key lastLogin = val.getExternalId(); return createVal(key, who, remember, lastLogin, val.sessionId, val.auth); }
private com.google.gerrit.gpg.CheckResult checkIdsForArbitraryUser(org.bouncycastle.openpgp.PGPPublicKey key) throws com.google.gwtorm.server.OrmException, org.bouncycastle.openpgp.PGPException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key<START_MOD>).get(<END_MOD>)); if (accountStates.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad( is not associated with any users } if ((accountStates.size()) > 1) { return com.google.gerrit.gpg.CheckResult.bad( is associated with multiple users } com.google.gerrit.server.IdentifiedUser user = userFactory.create(accountStates.get(0)); java.util.Set<java.lang.String> allowedUserIds = getAllowedUserIds(user); if (allowedUserIds.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad( identities found for user } if (hasAllowedUserId(key, allowedUserIds)) { return com.google.gerrit.gpg.CheckResult.trusted(); } return com.google.gerrit.gpg.CheckResult.bad( does not contain any valid certifications for user identities }
private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException { PARSE : for (; ;) { final int tag = readVarInt32(in); switch (tag) { case   : break PARSE; case 1 : accountId = new com.google.gerrit.reviewdb.client.Account.Id(readVarInt32(in)); continue; case 2 : refreshCookieAt = readFixInt64(in); continue; case 3 : persistentCookie = (readVarInt32(in)) != 0; continue; case 4 : externalId = <START_MOD>new com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD>.Key(readString(in)); continue; case 5 : sessionId = readString(in); continue; case 6 : expiresAt = readFixInt64(in); continue; case 7 : auth = readString(in); continue; default : throw new java.io.IOException(( tag found in object:   + tag)); } } if ((expiresAt) == 0) { expiresAt = (refreshCookieAt) + (java.util.concurrent.TimeUnit.HOURS.toMillis(2)); } }
private boolean isTrusted(<START_MOD>final <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> id) { if (id.isScheme(<START_MOD>AccountExternalId<END_MOD>.SCHEME_MAILTO)) { return true; } if (id.isScheme(<START_MOD>AccountExternalId<END_MOD>.SCHEME_UUID)) { return true; } if (id.isScheme(<START_MOD>AccountExternalId<END_MOD>.SCHEME_USERNAME)) { return true; } for (<START_MOD>final <END_MOD>com.google.gerrit.server.auth.openid.OpenIdProviderPattern p : trustedOpenIDs) { if (p.matches(id)) { return true; } } return false; }
private java.util.Set<com.google.gerrit.gpg.Fingerprint> readKeysToRemove(com.google.gerrit.gpg.server.PostGpgKeys.Input input, java.util.<START_MOD>List<END_MOD><com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD>> existingExtIds) { if (((input.delete) == null) || (input.delete.isEmpty())) { return com.google.common.collect.ImmutableSet.of(); } java.util.Set<com.google.gerrit.gpg.Fingerprint> fingerprints = com.google.common.collect.Sets.newHashSetWithExpectedSize(input.delete.size()); for (java.lang.String id : input.delete) { try { fingerprints.add(new com.google.gerrit.gpg.Fingerprint(com.google.gerrit.gpg.server.GpgKeys.parseFingerprint(id, existingExtIds))); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } return fingerprints; }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.<START_MOD><com.google.gerrit.reviewdb.client.AccountGroup.UUID><END_MOD>of(), com.google.common.collect.ImmutableSet.<START_MOD><com.google.gerrit.reviewdb.client.AccountExternalId><END_MOD>of(), new java.util.HashMap<START_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>><END_MOD>()); }
public boolean matches(com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> <START_MOD>id<END_MOD>) { return matches(<START_MOD>id<END_MOD>.<START_MOD>getExternalId<END_MOD>()); }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.<START_MOD><com.google.gerrit.reviewdb.client.AccountGroup.UUID><END_MOD>emptySet(), java.util.Collections.<START_MOD><com.google.gerrit.reviewdb.client.AccountExternalId><END_MOD>emptySet(), new java.util.HashMap<START_MOD><com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>><END_MOD>()); }
java.util.List<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> create(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String username, java.lang.String email);
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.server.account.AccountState accountState : accountQueryProvider.get().byEmailPrefix(email)) { if (accountState.getExternalIds().stream().filter(( e) -> email.equals(e.<START_MOD>getEmailAddress<END_MOD>())).findAny().isPresent()) { r.add(accountState.getAccount().getId()); } } return com.google.common.collect.ImmutableSet.copyOf(r); } }
public boolean checkPassword(java.lang.String password, java.lang.String username) { if (password == null) { return false; } for (com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD> id : getExternalIds()) { if ((!(id.isScheme(<START_MOD>AccountExternalId<END_MOD>.SCHEME_USERNAME))) || (!(username.equals(id.<START_MOD>getSchemeRest<END_MOD>())))) { continue; } java.lang.String hashedStr = id.<START_MOD>getPassword<END_MOD>(); if (!(com.google.common.base.Strings.isNullOrEmpty(hashedStr))) { try { return com.google.gerrit.server.account.HashedPassword.decode(hashedStr).checkPassword(password); } catch (org.apache.commons.codec.DecoderException e) { com.google.gerrit.server.account.AccountState.logger.error(java.lang.String.format( for user %s: %s   username, e.getMessage())); return false; } } } return false; }
public static java.util.Set<java.lang.String> getEmails(java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> ids) { java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> <START_MOD>id<END_MOD> : ids) { if (<START_MOD>id<END_MOD>.isScheme(com.google.gerrit.server.account.SCHEME_MAILTO)) { emails.add(<START_MOD>id<END_MOD>.<START_MOD>getSchemeRest<END_MOD>()); } } return emails; }
public java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> getExternalIds() { return externalIds; }
public static java.lang.String getUserName(java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> ids) { for (com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> <START_MOD>id<END_MOD> : ids) { if (<START_MOD>id<END_MOD>.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME)) { return <START_MOD>id<END_MOD>.<START_MOD>getSchemeRest<END_MOD>(); } } return null; }
private void addExternalId(java.lang.String scheme, java.lang.String id, java.lang.String email) throws java.lang.Exception { <START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.reviewdb.client.AccountExternalId extId = new<END_MOD> com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>(user.getAccountId(), <START_MOD>new com.google.gerrit.reviewdb.client.AccountExternalId.Key(scheme, id)); if (<END_MOD>email<START_MOD> != null) { extId.setEmailAddress(email); } db.accountExternalIds().insert(java.util.Collections.singleton(extId<END_MOD>)); reloadUser(); }
public java.util.List<com.google.gerrit.server.account.AccountState> byExternalId(java.lang.String <START_MOD>externalId<END_MOD>) throws com.google.gwtorm.server.OrmException { return <START_MOD>query<END_MOD>(<START_MOD>com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.server.query.account.AccountPredicates.externalId<END_MOD>(<START_MOD>externalId<END_MOD>)); }
public com.google.gerrit.server.account.AccountState oneByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { <START_MOD>java.util.List<com.google.gerrit.server.account.AccountState> accountStates = byExternalId(externalId); if ((accountStates.size()) == 1) { <END_MOD>return <START_MOD>accountStates.get(0<END_MOD>); }<START_MOD> else if ((accountStates.size()) > 0) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append( external ID ").append(externalId).append("for accounts:   com.google.common.base.Joiner.on(   com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); com.google.gerrit.server.query.account.InternalAccountQuery.log.warn(msg.toString()); } return null; }<END_MOD>
@java.lang.Override public void addEmail(com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), input.email); try { createEmailFactory.create(input.email).apply(rsrc, input); } catch (com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException( add email e); } }
private void addExternalIdEmail(com.google.gerrit.acceptance.TestAccount account, java.lang.String email) throws java.lang.Exception { checkNotNull(email); <START_MOD>com<END_MOD>.<START_MOD>google.gerrit.reviewdb.client.AccountExternalId extId = new<END_MOD> com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client.AccountExternalId(<END_MOD>account.<START_MOD>getId(), new com<END_MOD>.<START_MOD>google.gerrit.reviewdb.client.AccountExternalId.Key<END_MOD>(name("test"), email<START_MOD>));<END_MOD> <START_MOD>extId<END_MOD>.<START_MOD>setEmailAddress(email); db.accountExternalIds<END_MOD>()<START_MOD>.insert(java.util.Collections.singleton(extId<END_MOD>)); accountCache.evict(account.getId()); setApiUser(account); }
@org.junit.Before public void saveExternalIds() throws java.lang.Exception { savedExternalIds = new java.util.ArrayList(); savedExternalIds.addAll(getExternalIds(admin)); savedExternalIds.addAll(getExternalIds(user)); }
@org.junit.Test public void deleteEmailFromCustomExternalIdSchemes() throws java.lang.Exception { java.lang.String email = "foo.bar@example.com"; java.lang.String extId1 = "foo:bar"; java.lang.String extId2 = "foo:baz"; <START_MOD>db.accountExternalIds().insert(com.google.common.collect.ImmutableList.of(createExternalIdWithEmail(extId1, email), createExternalIdWithEmail(extId2, email))); accountCache.evict(admin.id); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identity).collect(<END_MOD>java.util.<START_MOD>stream.Collectors.toSet())).containsAllOf(extId1, extId2); resetCurrentApiUser(); assertThat(getEmails()).contains(email); gApi.accounts().self().deleteEmail(email); resetCurrentApiUser(); assertThat(getEmails()).doesNotContain(email); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identity)<END_MOD>.collect(java.util.stream.Collectors.toSet())).containsNoneOf(extId1, extId2); }
private java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> getExternalIds(com.google.gerrit.acceptance.TestAccount account) throws java.lang.Exception { return accountCache.get(account.getId()).getExternalIds(); }
@org.junit.Test public void noExternalIds() throws java.lang.Exception { db<START_MOD>.accountExternalIds().delete(db.accountExternalIds().byAccount(<END_MOD>user.getAccountId(<START_MOD>)<END_MOD>)); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD,   identities found for user; check http: checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD,   is not associated with any users <START_MOD>db.accountExternalIds()<END_MOD>.insert(<START_MOD>java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), <END_MOD>com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey())))); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD,   identities found for user }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if ((self.get()) != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to get external IDs } java.util.Collection<com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD>> ids = db.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList(); if (ids.isEmpty()) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(ids.size()); for (com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId id : ids) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.getExternalId(); info.emailAddress = id.getEmailAddress(); info.trusted = com.google.gerrit.<END_MOD>server.account.<START_MOD>GetExternalIds.toBoolean(authConfig.isIdentityTrustable(java.util.Collections.singleton(<END_MOD>id<START_MOD>))); if (!(id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME))<END_MOD>) { com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId.Key last = resource.getUser().getLastLoginExternalIdKey(); info.canDelete = com.google.gerrit.server.account.GetExternalIds.toBoolean(((last == null) || (!(last.get().equals(<END_MOD>info.identity))))); } result.add(info); } return result; }
@org.junit.Test public void addOtherUsersGpgKey_Conflict() throws java.lang.Exception { addExternalIdEmail(admin, "test5@example.com"); <START_MOD>com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key("foo:myId")); db.accountExternalIds()<END_MOD>.insert(<START_MOD>java.util.Collections.singleton(extId)); accountCache.evict(user.getId()); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); addGpgKey(key.getPublicKeyArmored()); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage( key already associated with another <END_MOD>account addGpgKey(key.getPublicKeyArmored()); }
@org.junit.After public void restoreExternalIds() throws java.lang.Exception { if ((savedExternalIds) != null) { <START_MOD>db.accountExternalIds()<END_MOD>.delete(getExternalIds(admin)); <START_MOD>db.accountExternalIds()<END_MOD>.delete(getExternalIds(user)); <START_MOD>db.accountExternalIds()<END_MOD>.insert(savedExternalIds); } accountCache.evict(admin.getId()); accountCache.evict(user.getId()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutUsername.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set username } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( does not allow editing username } if (input == null) { input = new com.google.gerrit.server.account.PutUsername.Input(); } try { changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call(); } catch (java.lang.IllegalStateException e) { if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(e.getMessage()); } throw e; } catch (com.google.gerrit.server.account.InvalidUserNameException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException( username } catch (com.google.gerrit.common.errors.NameAlreadyUsedException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( already used } return input.username; }
private com.google.gerrit.server.account.AuthResult auth(<START_MOD>final <END_MOD>com.google.gerrit.reviewdb.client.<START_MOD>AccountExternalId<END_MOD> account) { if (account != null) { return new com.google.gerrit.server.account.AuthResult(account<START_MOD>.getAccountId()<END_MOD>, null, false); } return null; }
private com.google.gerrit.server.account.AuthResult byUserName(final java.lang.String userName) { try {<START_MOD> com.google.gerrit.reviewdb.client.AccountExternalId.Key extKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, userName);<END_MOD> java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQuery.byExternalId(<START_MOD>extKey.get()); if (accountStates.isEmpty()) { getServletContext().log((( accounts with username   + userName) +   found return null; } if ((accountStates.size()) > 1) { getServletContext().log((( accounts with username   + userName) +   found return null; } return <END_MOD>auth<START_MOD>(new com.google.gerrit.reviewdb.client.AccountExternalId(accountStates.get(0).getAccount().getId()<END_MOD>, <START_MOD>extKey)); } catch (com.google.gwtorm.server.OrmException e<END_MOD>) { getServletContext().log(<START_MOD> query account index e);<END_MOD> return null; } <START_MOD>}<END_MOD>
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertEmail(byEmailCache.get(admin.email), admin); java.lang.String email = "foo.bar@example.com"; <START_MOD>db<END_MOD>.<START_MOD>accountExternalIds<END_MOD>().insert(com.google.<START_MOD>common<END_MOD>.<START_MOD>collect<END_MOD>.<START_MOD>ImmutableList<END_MOD>.<START_MOD>of<END_MOD>(<START_MOD>createExternalIdWithEmail<END_MOD>("foo:bar", email<START_MOD>)<END_MOD>)); accountCache.evict(admin.id); assertEmail(byEmailCache.get(email), admin); assertThat(byEmailCache.get(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(byEmailCache.get(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(byEmailCache.get("non-existing@example.com")).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.Email rsrc, com.google.gerrit.server.account.DeleteEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to delete email address } return apply(rsrc.getUser(), rsrc.getEmail()); }
<START_MOD>AccountExternalId<END_MOD>.Key getLastLoginExternalId();
private void assertKeys(java.lang.Iterable<com.google.gerrit.gpg.testutil.TestKey> expectedKeys) throws java.lang.Exception { com.google.common.collect.FluentIterable<com.google.gerrit.gpg.testutil.TestKey> expected = com.google.common.collect.FluentIterable.from(expectedKeys); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keyMap = gApi.accounts().self().listGpgKeys(); assertThat(keyMap.keySet()).named( returned by listGpgKeys() for (com.google.gerrit.gpg.testutil.TestKey key : expected) { com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyEquals(key, gApi.accounts().self().gpgKey(key.getKeyIdString()).get()); com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyEquals(key, gApi.accounts().self().gpgKey(com.google.gerrit.gpg.Fingerprint.toString(key.getPublicKey().getFingerprint())).get()); com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyMapContains(key, keyMap); } com.google.gerrit.reviewdb.client.Account.Id currAccountId = atrScope.get().getUser().getAccountId(); java.lang.Iterable<java.lang.String> expectedFps = expected.transform(( k) -> com.google.common.io.BaseEncoding.base16().encode(k.getPublicKey().getFingerprint())); java.lang.Iterable<java.lang.String> actualFps = com.google.gerrit.gpg.server.GpgKeys.getGpgExtIds(db, currAccountId).transform(<START_MOD>AccountExternalId::getSchemeRest<END_MOD>); assertThat(actualFps).named( IDs in database for (com.google.gerrit.gpg.testutil.TestKey key : expected) { getOnlyKeyFromStore(key); } }
public boolean isIdentityTrustable(<START_MOD>final <END_MOD>java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> ids) { switch (getAuthType()) { case DEVELOPMENT_BECOME_ANY_ACCOUNT : case HTTP : case HTTP_LDAP : case LDAP : case LDAP_BIND : case CLIENT_SSL_CERT_LDAP : case CUSTOM_EXTENSION : case OAUTH : return true; case OPENID_SSO : return true; case OPENID : for (<START_MOD>final <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> e : ids) { if (!(isTrusted(e))) { return false; } } return true; default : return false; } }
private com.google.gerrit.reviewdb.client.Account getAccountByExternalId(<START_MOD>java.lang.String externalId<END_MOD>) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(<START_MOD>externalId<END_MOD>); if (accountStates.isEmpty()) { return null; } if ((accountStates.size()) > 1) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append( key <START_MOD>").append(externalId).append("<END_MOD> associated with multiple accounts:   com.google.common.base.Joiner.on(   com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); log.error(msg.toString()); throw new java.lang.IllegalStateException(msg.toString()); } return accountStates.get(0).getAccount(); }
@java.lang.Override public void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), email); try { deleteEmail.apply(rsrc, null); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException( delete email e); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME, username); com.google.gerrit.<END_MOD>server.account.AccountState accountState = accountQueryProvider.get().oneByExternalId(<START_MOD>key<END_MOD>.<START_MOD>get()<END_MOD>); return java.util.Optional.ofNullable(accountState).map(( s) -> s.getAccount().getId()); }
private static com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); java.util.<START_MOD>Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = java.util.Collections.emptySet(); java.util.<END_MOD>Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> anon = com.google.common.collect.ImmutableSet.of(); return new com.google.gerrit.server.account.AccountState(account, anon, <START_MOD>ids<END_MOD>, new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private java.util.Optional<com.google.gerrit.server.account.AccountState> load(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = db.accounts().get(who); if (account == null) { return java.util.Optional.empty(); } java.util.<START_MOD>Collection<END_MOD><com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId<END_MOD>> externalIds = <START_MOD>java.util.Collections.unmodifiableCollection<END_MOD>(db.accountExternalIds().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> internalGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if ((group != null) && ((group.getGroupUUID()) != null)) { internalGroups.add(group.getGroupUUID()); } } internalGroups = java.util.Collections.unmodifiableSet(internalGroups); try { account.setGeneralPreferences(loader.load(who)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.AccountCacheImpl.log.warn((( load GeneralPreferences for   + who) +   (using default) e); account.setGeneralPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); } return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(account, internalGroups, externalIds, watchConfig.get().getProjectWatches(who))); }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key((((ExternalId.SCHEME_USERNAME) + ":") + username)))).map(AccountExternalId::getAccountId); } }
@java.lang.Override public boolean hasEmailAddress(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) { for (com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> ext : user.state().getExternalIds()) { if ((email != null) && (email.equalsIgnoreCase(ext.<START_MOD>getEmailAddress<END_MOD>()))) { return true; } } return false; }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { delete.apply(rsrc, new com.google.gerrit.gpg.server.DeleteGpgKey.Input()); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException( delete GPG key e); } }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.extensions.common.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.extensions.common.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, e.email), new com.google.gerrit.server.account.DeleteEmail.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }
private void addEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput(); in.email = email; in.noConfirmation = true; try { createEmailFactory.create(email).apply(rsrc, in); } catch (com.google.gerrit.common.errors.EmailException e) { throw die(e.getMessage()); } }
@java.lang.Override public java.util.Set<java.lang.String> getEmailAddresses(com.google.gerrit.server.IdentifiedUser user) { java.util.Collection<com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>> ids = user.state().getExternalIds(); java.util.Set<java.lang.String> emails = com.google.common.collect.Sets.newHashSetWithExpectedSize(ids.size()); for (com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD> ext : ids) { if (!(com.google.common.base.Strings.isNullOrEmpty(ext.<START_MOD>getEmailAddress<END_MOD>()))) { emails.add(ext.<START_MOD>getEmailAddress<END_MOD>()); } } return emails; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to add email address } if (input == null) { input = new com.google.gerrit.extensions.api.accounts.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( email address } if ((input.noConfirmation) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to use no_confirmation } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( does not allow adding emails } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to generate HTTP password } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException( allowed to clear HTTP password } newPassword = null; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(( allowed to set HTTP password directly,   +   the Administrate Server permission } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( must be set } com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId id = dbProvider.get().accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, user.getUserName())); if (id == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } id.setPassword(com.google.gerrit.<END_MOD>server.account.<START_MOD>HashedPassword.fromPassword(newPassword).encode()); <END_MOD>dbProvider.get().accountExternalIds().<START_MOD>update(java.util.Collections.singleton(id)<END_MOD>); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId.Key key<END_MOD> = <START_MOD>new com.google.gerrit.reviewdb.client.AccountExternalId<END_MOD>.Key<START_MOD>(<END_MOD>SCHEME_USERNAME, username)<START_MOD>; com.google.gerrit.reviewdb.client.AccountExternalId user = db.accountExternalIds().get(key<END_MOD>); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : authorizedKeys.getKeys(user.<START_MOD>getAccountId<END_MOD>())) { if (k.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
@org.junit.Test public void getExternalIDs() throws java.lang.Exception { java.util.Collection<com.google.gerrit.<START_MOD>reviewdb.client.AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId id : expectedIds) { id.setCanDelete((!(id.getExternalId().equals(("username:" + (user.username)))))); id.setTrusted(true); expectedIdInfos.add(com.google.gerrit.acceptance.rest<END_MOD>.account.<START_MOD>ExternalIdIT.toInfo(id)<END_MOD>); } com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@java.lang.Override public void deleteExternalIds(java.util.List<java.lang.String> externalIds) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteExternalIds.apply(account, externalIds); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException( delete external IDs e); } }
@java.lang.Override public void login(<START_MOD>final <END_MOD>com.google.gerrit.server.account.AuthResult res, <START_MOD>final <END_MOD>boolean rememberMe) {<START_MOD> final<END_MOD> com.google.gerrit.reviewdb.client.Account.Id id = res.getAccountId(); <START_MOD>final <END_MOD>com.google.gerrit.<START_MOD>reviewdb<END_MOD>.<START_MOD>client<END_MOD>.<START_MOD>AccountExternalId<END_MOD>.Key identity = res.getExternalId<START_MOD>().asAccountExternalIdKey<END_MOD>(); if ((val) != null) { manager.destroy(key); } key = manager.createKey(id); val = manager.createVal(key, id, rememberMe, identity, null, null); saveCookie(); user = identified.create(val.getAccountId()); }
private java.lang.String readResponse(java.io.InputStream responseStream) { try <START_MOD>(<END_MOD>java.util.Scanner scanner = new java.util.Scanner(responseStream, "UTF-8").useDelimiter("\\A")<START_MOD>) {<END_MOD> return scanner.next(); } catch (java.lang.Exception e) { throw new java.lang.RuntimeException((( reading response: [ + (e.getMessage())) + "]."), e); } }
<START_MOD>private void addSubmitRecordRequirements(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecordAttribute sa) { if (((submitRecord.requirements) != null) && (!(submitRecord.requirements.isEmpty()))) { sa.requirements = new java.util.ArrayList(); for (com.google.gerrit.common.data.SubmitRequirement req : submitRecord.requirements) { com.google.gerrit.server.data.SubmitRequirementAttribute re = new com.google.gerrit.server.data.SubmitRequirementAttribute(); re.shortReason = req.shortReason(); re.fullReason = req.fullReason(); re.label = req.label(); sa.requirements.add(re); } } }<END_MOD>
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() { if ((submitTypeRecord) == null) { submitTypeRecord = submitRuleEvaluatorFactory.create(<START_MOD>com.google.gerrit.server.query.change.DEFAULT_OPTIONS<END_MOD>).getSubmitType(<START_MOD>this<END_MOD>); } return submitTypeRecord; }
<START_MOD>private com.google.gerrit.server.project.SubmitRuleEvaluator makeEvaluator() { com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey("project"); com.google.gerrit.server.query.change.ChangeData cd = com.google.gerrit.server.query.change.ChangeData.createForTest(project, new com.google.gerrit.reviewdb.client.Change.Id(1), 1); cd.setChange(com.google.gerrit.testing.TestChanges.newChange(project, com.google.gerrit.server.project.SubmitRulesEvaluatorTest.ADMIN_USER)); return evaluatorFactory.create(cd); }<END_MOD>
<START_MOD>@org.junit.Test public void convertsPrologToSubmitRecord() { com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = makeEvaluator(); java.util.List<com.googlecode.prolog_cafe.lang.Term> terms = new java.util.ArrayList<>(); com.googlecode.prolog_cafe.lang.StructureTerm verifiedLabel = makeLabel("Verified", "may"); com.googlecode.prolog_cafe.lang.StructureTerm labels = new com.googlecode.prolog_cafe.lang.StructureTerm("label", verifiedLabel); terms.add(makeTerm("ok", labels)); java.util.Collection<com.google.gerrit.common.data.SubmitRecord> records = evaluator.resultsToSubmitRecord(null, terms); assertThat(records).hasSize(1); }<END_MOD>
<START_MOD>private com.googlecode.prolog_cafe.lang.Term makeTerm(java.lang.String status, com.googlecode.prolog_cafe.lang.StructureTerm labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm(status, labels); }<END_MOD>
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : submitRuleEvaluatorFactory.create(<START_MOD>com.google.gerrit.server.restapi.change.DEFAULT_OPTIONS).evaluate(<END_MOD>cd)) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
public <START_MOD>java.util.List<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; <END_MOD>com.google.gerrit.server.project.<START_MOD>ProjectState projectState; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException( change found } projectState = projectCache.get(cd<END_MOD>.project<START_MOD>()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchProjectException e) { return ruleError(( looking up change   + (cd.getId())), e); } if ((!(<END_MOD>opts<START_MOD>.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", cd, projectState); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); }<END_MOD> if (<START_MOD>results.isEmpty()) {<END_MOD> return <START_MOD>ruleError(java.lang.String.format( rule '%s' for change %s of %s has no solution. getSubmitRuleName(), cd.getId(), projectState.getName())); } return resultsToSubmitRecord(getSubmitRule(), results, cd); }<END_MOD>
<START_MOD>public abstract java.lang.String fullReason();<END_MOD>
<START_MOD>private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status) { return new com.googlecode.prolog_cafe.lang.StructureTerm("label", new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status)); }<END_MOD>
<START_MOD>public abstract java.lang.String shortReason();<END_MOD>
public static com.google.gerrit.server.project.SubmitRuleOptions.Builder builder() { return com.google.gerrit.server.project.<START_MOD>SubmitRuleOptions<END_MOD>.<START_MOD>DEFAULT_OPTIONS.toBuilder<END_MOD>(); }
<START_MOD>public abstract com.google.gerrit.common.data.SubmitRequirement build();<END_MOD>
<START_MOD>@com.google.gerrit.common.Nullable public abstract java.lang.String label();<END_MOD>
<START_MOD>public abstract com.google.gerrit.common.data.SubmitRequirement.Builder setLabel(@com.google.gerrit.common.Nullable java.lang.String label);<END_MOD>
<START_MOD>public abstract com.google.gerrit.common.data.SubmitRequirement.Builder setFullReason(java.lang.String fullReason);<END_MOD>
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(<START_MOD>com.google.gerrit.server.restapi.change.DEFAULT_OPTIONS<END_MOD>).getSubmitType(<START_MOD>cd<END_MOD>); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(( type rule failed:   + rec)); } return rec.type; }
<START_MOD>private com.googlecode.prolog_cafe.lang.StructureTerm makeLabels(com.googlecode.prolog_cafe.lang.StructureTerm... labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm("label", labels); }<END_MOD>
public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.server.project.ProjectState projectState; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException( change found } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchProjectException e) { return ruleError(( looking up change   + (cd.getId())), e); } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } <START_MOD>return prologRule.evaluate(cd<END_MOD>, <START_MOD>opts); }<END_MOD>
<START_MOD>@java.lang.Override public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.project.SubmitRuleOptions opts) { return getEvaluator(cd, opts).evaluate(); }<END_MOD>
public static void checkSubmitRule(com.google.gerrit.server.query.change.ChangeData cd, boolean allowClosed) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet patchSet = cd.currentPatchSet(); if (patchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( current patch set for change   + (cd.getId()))); } java.util.List<com.google.gerrit.common.data.SubmitRecord> results = com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd, allowClosed); if (com.google.gerrit.common.data.SubmitRecord.<START_MOD>canBeSubmitted<END_MOD>(results)) { return; } else if (results.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format( for change %s returned empty list for %s in %s cd.getId(), patchSet.getId(), cd.change().getProject().get())); } for (com.google.gerrit.common.data.SubmitRecord record : results) { switch (record.status) { case <START_MOD>OK : break; case <END_MOD>CLOSED : throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is closed case RULE_ERROR : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( rule error:   + (record.errorMessage))); case NOT_READY : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(com.google.gerrit.server.git.MergeOp.describeLabels(cd, record.labels)); case FORCED : default : throw new java.lang.IllegalStateException(java.lang.String.format( SubmitRecord status %s for %s in %s record.status, patchSet.getId().getId(), cd.change().getProject().get())); } } throw new java.lang.IllegalStateException(); }
private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) { return com.google.gerrit.common.data.SubmitRecord.<START_MOD>canBeSubmitted<END_MOD>(cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)); }
public static <START_MOD>boolean<END_MOD> <START_MOD>canBeSubmitted<END_MOD>(java.util.<START_MOD>List<END_MOD><com.google.gerrit.common.data.SubmitRecord> in) { if (<START_MOD>(<END_MOD>in == null) <START_MOD>|| (in.isEmpty())) <END_MOD>{ return <START_MOD>true<END_MOD>; } <START_MOD>if<END_MOD> <START_MOD>(<END_MOD>in.stream().<START_MOD>noneMatch<END_MOD>(( r) -> (r.status) == (com.google.gerrit.common.data.SubmitRecord.Status.OK))<START_MOD>) { return false; } return in<END_MOD>.<START_MOD>stream<END_MOD>(<START_MOD>).noneMatch(( r) -> (r.status) == (com.google.gerrit.common.data.SubmitRecord.Status.NOT_READY)<END_MOD>); }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(( type rule failed:   + rec)); } return rec.type; }
<START_MOD>private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status, com.google.gerrit.reviewdb.client.Account.Id account) { com.googlecode.prolog_cafe.lang.StructureTerm user = new com.googlecode.prolog_cafe.lang.StructureTerm("user", new com.googlecode.prolog_cafe.lang.IntegerTerm(account.get())); return new com.googlecode.prolog_cafe.lang.StructureTerm("label", new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status, user)); }<END_MOD>
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels) != null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord.Label(); srl.label = label.label; srl.status = label.status; srl.appliedBy = ((label.appliedBy) != null) ? new com.google.gerrit.reviewdb.client.Account.Id(label.appliedBy) : null; rec.labels.add(srl); } } <START_MOD>if ((requirements) != null) { rec.requirements = new java.util.ArrayList(requirements.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredRequirement requirement : requirements) { com.google.gerrit.common.data.SubmitRequirement.Builder srb = com.google.gerrit.common.data.SubmitRequirement.builder(); srb.setFullReason(requirement.fullReason); srb.setShortReason(requirement.shortReason); if ((requirement.label) != null) { srb.setLabel(requirement.label); } rec.requirements.add(srb.build()); } } <END_MOD>return rec; }
@java.lang.Override protected void configure() { install(new com.google.gerrit.server.rules.PrologModule.EnvironmentModule()); bind(PrologEnvironment.Args.class); <START_MOD>factory(PrologRuleEvaluator.Factory.class); <END_MOD>}
<START_MOD>public boolean getIgnoreWipPrivate() { return ignoreWipPrivate; }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded) throws java.lang.Exception { <START_MOD>return<END_MOD> <START_MOD>getConfig<END_MOD>(<START_MOD>publishOnReviewerAdded<END_MOD>, true); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet<START_MOD>, boolean ignoreWipPrivate<END_MOD>) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn(ignore); when(mockPluginConfig.getBoolean("publish-on-patch-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("ignore-rebase-empty-patch-set", true)).thenReturn(ignoreRebaseEmptyPatchSet); <START_MOD>when(mockPluginConfig.getBoolean("ignore-wip-private", true)).thenReturn(ignoreWipPrivate); <END_MOD>return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(<START_MOD>boolean publishOnReviewerAdded, boolean ignoreWipPrivate<END_MOD>) throws java.lang.Exception { <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-on-reviewer-added", true)).thenReturn(publishOnReviewerAdded); when(mockPluginConfig.getBoolean("ignore-wip-private", true)).thenReturn(ignoreWipPrivate); <END_MOD>return <START_MOD>new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME<END_MOD>); }
<START_MOD>@org.junit.Test public void publishesWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; mockChange.wip = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore) throws java.lang.Exception { return getConfig(ignore, true, true<START_MOD>, true<END_MOD>); }
<START_MOD>@org.junit.Test public void publishesWhenWorkInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; mockChange.wip = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
<START_MOD>private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig("^WIP.*", true, true, true); }<END_MOD>
<START_MOD>@org.junit.Test public void publishesWhenExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
@java.lang.Override public boolean shouldPublish() { <START_MOD>if<END_MOD> <START_MOD>((!<END_MOD>(config.isEnabled())<START_MOD>)<END_MOD> <START_MOD>||<END_MOD> <START_MOD>(!<END_MOD>(config.shouldPublishOnReviewerAdded())<START_MOD>)) { return false<END_MOD>; }<START_MOD> try { if ((config.getIgnoreWipPrivate()) && ((event.change.get().isPrivate) || (event.change.get().wip))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGenerator.LOGGER.warn( checking private and work-in-progress status e); } return true; }<END_MOD>
<START_MOD>@org.junit.Test public void doesPublishWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmptyPatchSet()) && (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE)))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn( checking patch set kind e); } <START_MOD>try { if ((config.getIgnoreWipPrivate()) && ((event.change.get().isPrivate) || (event.change.get().wip))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn( checking private and work-in-progress status e); } <END_MOD>boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.regex.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result = !(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn( specified ignore pattern was invalid e); } return result; }
<START_MOD>@org.junit.Test public void publishesWhenExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.wip = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
@java.lang.Override public boolean shouldPublish() { <START_MOD>if<END_MOD> <START_MOD>((!<END_MOD>(config.isEnabled())<START_MOD>)<END_MOD> <START_MOD>||<END_MOD> <START_MOD>(!<END_MOD>(config.shouldPublishOnCommentAdded())<START_MOD>)) { return false<END_MOD>; }<START_MOD> try { if ((config.getIgnoreWipPrivate()) && ((event.change.get().isPrivate) || (event.change.get().wip))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGenerator.LOGGER.warn( checking private and work-in-progress status e); } return true; }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded) throws java.lang.Exception { <START_MOD>return<END_MOD> <START_MOD>getConfig<END_MOD>(<START_MOD>publishOnCommentAdded<END_MOD>, true); }
<START_MOD>@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnWipReady()))) { return false; } if (event.change.get().wip) { return false; } return true; }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(<START_MOD>boolean publishOnCommentAdded, boolean ignoreWipPrivate<END_MOD>) throws java.lang.Exception { <START_MOD>com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(publishOnCommentAdded); when(mockPluginConfig.getBoolean("ignore-wip-private", true)).thenReturn(ignoreWipPrivate); <END_MOD>return <START_MOD>new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME<END_MOD>); }
<START_MOD>@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPrivateToPublic()))) { return false; } if (event.change.get().isPrivate) { return false; } return true; }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(<START_MOD>boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet, boolean ignoreWipPrivate<END_MOD>) throws java.lang.Exception { return getConfig("^WIP.*", <START_MOD>publishOnPatchSetCreated<END_MOD>, <START_MOD>ignoreRebaseEmptyPatchSet, ignoreWipPrivate<END_MOD>); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, true<START_MOD>, true<END_MOD>); }
<START_MOD>@org.junit.Test public void doesPublishWhenWorkInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.wip = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }<END_MOD>
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebaseEmptyPatchSet) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreRebaseEmptyPatchSet<START_MOD>, true<END_MOD>); }
<START_MOD>public static void useFixedClockAt(java.time.Instant instant) { com.ericsson.gerrit.plugins.highavailability.websession.file.FileBasedWebsessionCache.TimeMachine.clock = java.time.Clock.fixed(instant, java.time.ZoneId.systemDefault()); }<END_MOD>
<START_MOD>public static void useSystemDefaultZoneClock() { com.ericsson.gerrit.plugins.highavailability.websession.file.FileBasedWebsessionCache.TimeMachine.clock = java.time.Clock.systemDefaultZone(); }<END_MOD>
<START_MOD>public static java.time.Instant now() { return java.time.Instant.now(com.ericsson.gerrit.plugins.highavailability.websession.file.FileBasedWebsessionCache.TimeMachine.getClock()); }<END_MOD>
@java.lang.Override public void run() throws java.io.IOException { com.google.gerrit.server.index.IndexModule.IndexType type = com.google.gerrit.server.index.IndexModule.IndexType.LUCENE; if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) > 1) { ui.header("Index"); type = index.select("Type", "type", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.ELASTICSEARCH)) { <START_MOD>java.lang.String name = index.string( Name "name", "gerrit"); com.google.gerrit.pgm.init.api.Section elasticsearch = sections.get("elasticsearch", name); elasticsearch<END_MOD>.select( protocol "protocol", "http", com.google.common.collect.Sets.newHashSet("http", "https")); <START_MOD>elasticsearch<END_MOD>.string("Hostname", "hostname", "localhost"); <START_MOD>elasticsearch<END_MOD>.string("Port", "port", "9200"); } if (((site.isNew) || (isEmptySite())) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { for (com.google.gerrit.server.index.SchemaDefinitions<?> def : com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS) { com.google.gerrit.server.index.IndexUtils.setReady(site, def.getName(), def.getLatest().getVersion(), true); } } else { if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) <= 1) { ui.header("Index"); } java.lang.String message = java.lang.String.format(( index must be %sbuilt before starting Gerrit: +   java -jar gerrit.war reindex -d site_path (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }
<START_MOD>protected static void setContentAndEncoding(javax.servlet.http.HttpServletResponse rsp) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); }<END_MOD>
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); <START_MOD>logger.debug( {} {} operation, indexName, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.locks.Lock idLock = idLocks.get(id); idLock.lock(); try { index(id, operation); } finally { idLock.unlock(); } rsp.setStatus(<END_MOD>com.ericsson.gerrit.plugins.highavailability.forwarder.rest.<START_MOD>SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, <END_MOD>com.ericsson.gerrit.plugins.highavailability.forwarder.rest.<START_MOD>SC_CONFLICT,<END_MOD> e.getMessage()); logger.error( to update {} index indexName, e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format( trying to find %s   indexName); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, msg); logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { <START_MOD>setContentAndEncoding(rsp<END_MOD>); try { java.util.List<java.lang.String> params = com.google.common.base.Splitter.on('/').splitToList(req.getPathInfo()); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.CACHENAME_INDEX); java.lang.String json = req.getReader().readLine(); forwardedCacheEvictionHandler.evict(com.ericsson.gerrit.plugins.highavailability.forwarder.CacheEntry.from(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.fromJson(cacheName, json))); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (com.ericsson.gerrit.plugins.highavailability.forwarder.CacheNotFoundException e) { logger.error( to process eviction request: {} e.getMessage()); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } catch (java.io.IOException e) { logger.error( to process eviction request: {} e.getMessage(), e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { <START_MOD>setContentAndEncoding(rsp<END_MOD>); try { if (!(com.google.common.net.MediaType.parse(req.getContentType()).is(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8))) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_UNSUPPORTED_MEDIA_TYPE, ((   + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8.toString())) +   content type return; } forwardedEventHandler.dispatch(getEventFromRequest(req)); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (com.google.gwtorm.server.OrmException e) { logger.debug( trying to find a change   e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND,   not found } catch (java.io.IOException e) { logger.error( to re-trigger event e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } }
<START_MOD>@org.junit.Test public void indexingUpdatesTheIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String preferredEmail = "foo@example.com"; updateAccountWithoutCacheOrIndex(accountId, com.google.gerrit.acceptance.api.accounts.AccountIndexerIT.newAccountUpdate().setPreferredEmail(preferredEmail).build()); assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty(); accountIndexer.index(accountId); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchedAccountSates).hasSize(1); assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId); }<END_MOD>
<START_MOD>private void updateAccountWithoutCacheOrIndex(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.InternalAccountUpdate acountUpdate) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo)) { org.eclipse.jgit.lib.PersonIdent ident = serverIdent.get(); md.getCommitBuilder().setAuthor(ident); md.getCommitBuilder().setCommitter(ident); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId, allUsersRepo).load(); accountConfig.setAccountUpdate(acountUpdate); accountConfig.commit(md); } }<END_MOD>
@org.junit.Test public void accountEvictionFromAccountCreatorIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); com.google.gerrit.acceptance.AccountCreator accountCreator = org.easymock.EasyMock.createNiceMock(com.google.gerrit.acceptance.AccountCreator.class); accountCreator.evict(com.google.common.collect.ImmutableSet.of(accountId)); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCreator); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(accountCreator, null, null<START_MOD>, null<END_MOD>).reset(project).reset(allUsers).build()) { createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); } org.easymock.EasyMock.verify(accountCreator); }
@org.junit.Test public void accountEvictionIfUserBranchIsReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); org.eclipse.jgit.lib.Ref userBranch = createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); com.google.gerrit.server.account.AccountCache accountCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCache); <START_MOD>com.google.gerrit.server.index.account.AccountIndexer accountIndexer = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.index.account.AccountIndexer.class); accountIndexer.index(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountIndexer); <END_MOD>org.eclipse.jgit.lib.Ref nonUserBranch = createRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, accountCache, <START_MOD>accountIndexer, <END_MOD>null).reset(project).reset(allUsers).build()) { updateRef(nonUserBranch); updateRef(allUsersRepo, userBranch); } org.easymock.EasyMock.verify(accountCache); }
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createRepository(project2); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(projectCache); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, null, <START_MOD>null, <END_MOD>projectCache).reset(project).reset(project2).build()) { createRef("refs/heads/master"); createRef(repo2, RefNames.REFS_CONFIG); } org.easymock.EasyMock.verify(projectCache); }
@org.junit.Test public void accountEvictionIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); com.google.gerrit.server.account.AccountCache accountCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountCache<START_MOD>); com.google.gerrit.server.index.account.AccountIndexer accountIndexer = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.index.account.AccountIndexer.class); accountIndexer.index(accountId); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(accountIndexer<END_MOD>); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, accountCache, <START_MOD>accountIndexer, <END_MOD>null).reset(project).reset(allUsers).build()) { createRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); } org.easymock.EasyMock.verify(accountCache); }
<START_MOD>@org.junit.Test public void reindexingStaleAccountUpdatesTheIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String preferredEmail = "foo@example.com"; updateAccountWithoutCacheOrIndex(accountId, com.google.gerrit.acceptance.api.accounts.AccountIndexerIT.newAccountUpdate().setPreferredEmail(preferredEmail).build()); assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty(); accountIndexer.reindexIfStale(accountId); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchedAccountSates).hasSize(1); assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId); }<END_MOD>
public com.google.gerrit.acceptance.ProjectResetter build() throws java.io.IOException { return new com.google.gerrit.acceptance.ProjectResetter(repoManager, allUsersName, accountCreator, accountCache, <START_MOD>accountIndexer, <END_MOD>projectCache, refsByProject); }
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createRepository(project2); org.eclipse.jgit.lib.Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.easymock.EasyMock.expectLastCall(); org.easymock.EasyMock.replay(projectCache); org.eclipse.jgit.lib.Ref nonMetaConfig = createRef("refs/heads/master"); try (com.google.gerrit.acceptance.ProjectResetter resetProject = builder(null, null, <START_MOD>null, <END_MOD>projectCache).reset(project).reset(project2).build()) { updateRef(nonMetaConfig); updateRef(repo2, metaConfig); } org.easymock.EasyMock.verify(projectCache); }
<START_MOD>@org.junit.Test public void indexCannotBeCorruptedByStaleCache() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); loadAccountToCache(accountId); java.lang.String preferredEmail = "foo@example.com"; updateAccountWithoutCacheOrIndex(accountId, com.google.gerrit.acceptance.api.accounts.AccountIndexerIT.newAccountUpdate().setPreferredEmail(preferredEmail).build()); assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail)).isEmpty(); accountIndexer.index(accountId); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccountSates = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchedAccountSates).hasSize(1); assertThat(matchedAccountSates.get(0).getAccount().getId()).isEqualTo(accountId); }<END_MOD>
<START_MOD>@org.junit.Test public void missingPatchSetCommitOmitsCommentsOnParentSide() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); com.google.gerrit.extensions.common.CommentInfo draftInfo = putDraft(user, id, 1, "draft comment", null, Side.PARENT); putComment(user, id, 1, "published comment", null, Side.PARENT); com.google.gerrit.extensions.common.CommentInfo commentInfo = gApi.changes().id(id.get()).comments().values().stream().flatMap(java.util.List::stream).findFirst().get(); com.google.gerrit.reviewdb.server.ReviewDb db = getUnwrappedDb(); com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().get(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, 1)); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef")); db.patchSets().update(java.util.Collections.singleton(ps)); try { patchListCache.getOldId(db.changes().get(id), ps, null); assert_().fail("Expected PatchListNotAvailableException"); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { } checker.rebuildAndCheckChange(id, com.google.common.collect.ImmutableList.of((((((((((((("PatchLineComment.Key sets differ: [" + id) + ",1,") + (com.google.gerrit.acceptance.PushOneCommit.FILE_NAME)) + ",") + (draftInfo.id)) + ", ") + id) + ",1,") + (com.google.gerrit.acceptance.PushOneCommit.FILE_NAME)) + ",") + (commentInfo.id)) + "] only in A; [] only in B"))); }<END_MOD>
<START_MOD>public void rebuildAndCheckChange(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> expectedDiff) throws java.lang.Exception { ImmutableListMultimap.Builder<com.google.gerrit.reviewdb.client.Change.Id, java.lang.String> b = com.google.common.collect.ImmutableListMultimap.builder(); b.putAll(changeId, expectedDiff); rebuildAndCheckChanges(java.util.stream.Stream.of(changeId), b.build()); }<END_MOD>
@org.junit.Test public void deleteItems() throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId oldMetaId = metaRef(accountId); <START_MOD>com.google.common.collect.ImmutableSet<END_MOD><java.lang.String> defaultNames = myMenusFromApi(accountId); GeneralPreferencesInfo prefs = gApi.accounts().id(accountId.get()).getPreferences(); prefs.my.add(0, new com.google.gerrit.extensions.client.MenuItem( else ((com.google.gerrit.server.schema.Schema_160.<START_MOD>DEFAULT_DRAFT_ITEMS.get(0)<END_MOD>) + "+is:mergeable"))); <START_MOD>for (int i = 0; i < (com.google.gerrit.server.schema.Schema_160.DEFAULT_DRAFT_ITEMS.size()); i++) { <END_MOD>prefs.my.add(new com.google.gerrit.extensions.client.MenuItem(<START_MOD>( entry   + i)<END_MOD>, com.google.gerrit.server.schema.Schema_160.<START_MOD>DEFAULT_DRAFT_ITEMS.get(i))); }<END_MOD> gApi.accounts().id(accountId.get()).setPreferences(prefs); java.util.List<java.lang.String> oldNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add( else").addAll(defaultNames).add("<START_MOD>Draft entry 0<END_MOD>").add("<START_MOD>Draft entry 1").add("Draft entry 2").add("Draft entry 3<END_MOD> assertThat(myMenusFromApi(accountId)).containsExactlyElementsIn(oldNames).inOrder(); schema160.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); accountCache.evict(accountId); testEnv.setApiUser(accountId); assertThat(metaRef(accountId)).isNotEqualTo(oldMetaId); java.util.List<java.lang.String> newNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add( else assertThat(myMenusFromNoteDb(accountId)).containsExactlyElementsIn(newNames).inOrder(); assertThat(myMenusFromApi(accountId)).containsExactlyElementsIn(newNames).inOrder(); }
<START_MOD>private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers groupMembers, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::isActive).map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: reviewer {} is neither an account nor a group.", changeNumber, p, r); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}.", changeNumber, p, r, e); } }<END_MOD>
<START_MOD>private boolean resolveAccount(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, java.lang.String r) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(reviewDb, r); if ((account != null) && (account.isActive())) { if ((uploader == null) || ((uploader._accountId) != (account.getId().get()))) { reviewers.add(account.getId()); } return true; } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.error("For the change {} of project {}: failed to resolve account {}.", changeNumber, p, r, e); return true; } return false; }<END_MOD>
java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> resolve(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.AccountInfo uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); com.google.gerrit.server.account.GroupMembers groupMembers = null; for (java.lang.String r : in) { <START_MOD>if (resolveAccount(reviewDb, p, changeNumber, uploader, reviewers, r)) { continue; } if ((groupMembers == null) && (uploader != null)) { groupMembers = createGroupMembers(reviewDb, p, changeNumber, uploader, r); } if (groupMembers != null) { resolveGroup(p, changeNumber, reviewers, groupMembers, r); } else { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn( the change {} of project {}: failed to list accounts for group {}; cannot retrieve uploader<END_MOD> account <START_MOD>for {}. changeNumber, p, r<END_MOD>, uploader.email); } } return reviewers; }
<START_MOD>private com.google.gerrit.server.account.GroupMembers createGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { java.lang.String uploaderNameEmail = java.lang.String.format("%s <%s>", uploader.name, uploader.email); try { com.google.gerrit.reviewdb.client.Account uploaderAccount = accountResolver.findByNameOrEmail(reviewDb, uploaderNameEmail); if (uploaderAccount != null) { return groupMembersFactory.create(identifiedUserFactory.create(uploaderAccount.getId())); } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: failed to list accounts for group {}, cannot retrieve uploader account {}.", changeNumber, p, r, uploaderNameEmail, e); } return null; }<END_MOD>
private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers groupMembers, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::isActive).map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn( the change {} of project {}: reviewer {} is neither an account nor a group. changeNumber, p, r); } catch (com.google.gerrit.server.project.NoSuchProjectException <START_MOD>| java.io.IOException | com.google.gwtorm.server.OrmException <END_MOD>e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn( the change {} of project {}: failed to list accounts for group {}. changeNumber, p, r<START_MOD>, e<END_MOD>); } <START_MOD>}<END_MOD>
private void run(java.util.function.Consumer<java.lang.String> logOneLine, @com.google.gerrit.common.Nullable java.io.PrintWriter progressWriter) { if (!((repoManager) instanceof com.google.gerrit.server.git.LocalDiskRepositoryManager)) { logOneLine.accept((( GC of   + (allUsers)) +   not a local disk repo return; } if (<START_MOD>!(enableAutoGc(logOneLine))) { logOneLine.accept(java.lang.String.format(((((( GC of   + (allUsers)) +   due to disabling   + (CONFIG_GC_SECTION)) + ".") + (CONFIG_KEY_AUTO)))); logOneLine.accept((( loading accounts is slow after the NoteDb migration, run   gc on   + (allUsers)) +   manually return; } if (<END_MOD>progressWriter == null) { logOneLine.accept((( garbage for   + (allUsers)) + "\":\n")); } com.google.gerrit.common.data.GarbageCollectionResult result = gcFactory.create().run(com.google.common.collect.ImmutableList.of(allUsers), progressWriter); if (!(result.hasErrors())) { return; } for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case GC_ALREADY_SCHEDULED : logOneLine.accept(( already scheduled for   + (e.getProjectName()))); break; case GC_FAILED : logOneLine.accept(( failed for   + (e.getProjectName()))); break; case REPOSITORY_NOT_FOUND : logOneLine.accept(((e.getProjectName()) +   repo not found break; default : logOneLine.accept(((( failed for   + (e.getProjectName())) +     + (e.getType()))); break; } } }
public java.util.Set<java.lang.String> getUpstreamBranches(java.lang.String toBranch, java.lang.String project) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<java.lang.String> upstreamBranches = new java.util.HashSet<java.lang.String>(); java.util.Set<java.lang.String> subsections = getConfig().getSubsections(pluginName); for (java.lang.String subsection : subsections) { java.<START_MOD>util.List<java.lang.String><END_MOD> branchPair = <START_MOD>com.google.common.base.Splitter.on(com.googlesource.gerrit.plugins.automerger.ConfigLoader.BRANCH_DELIMITER).trimResults().omitEmptyStrings().splitToList(<END_MOD>subsection); if ((branchPair.<START_MOD>size()<END_MOD>) != 2) { throw new org.eclipse.jgit.errors.ConfigInvalidException(( config branch pair malformed:   + subsection)); } if (toBranch.equals(branchPair<START_MOD>.get(<END_MOD>1<START_MOD>)<END_MOD>)) { java.util.Set<java.lang.String> projectsInScope = getProjectsInScope(branchPair<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>, branchPair<START_MOD>.get(<END_MOD>1<START_MOD>)<END_MOD>); if (projectsInScope.contains(project)) { upstreamBranches.add(branchPair<START_MOD>.get(<END_MOD>0<START_MOD>)<END_MOD>); } } } return upstreamBranches; }
@org.junit.Test public void basicGroupProperties() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups().create(name("group")).get(); com.google.gerrit.server.group.InternalGroup reviewDbGroup = groups.getGroup(db, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(createdGroup.id)).get(); deleteGroupRefs(reviewDbGroup); assertThat(com.google.gerrit.acceptance.api.group.GroupRebuilderIT.removeRefState(rebuild(reviewDbGroup))).isEqualTo(roundToSecond(reviewDbGroup)); }
private com.google.gerrit.server.group.InternalGroup createGroupInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.group.db.InternalGroupCreation groupCreation, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName gn = new com.google.gerrit.reviewdb.client.AccountGroupName(groupCreation.getNameKey(), groupCreation.getId()); db.accountGroupNames().insert(com.google.common.collect.ImmutableList.of(gn)); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.db.GroupsUpdate.createAccountGroup(groupCreation); com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult updateResult = updateGroupInReviewDb(db, group, groupUpdate); return com.google.gerrit.server.group.InternalGroup.create(group, updateResult.getModifiedMembers(), updateResult.getModifiedSubgroups(), updateResult.getRefState()); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(3); values.add(token.operation); values.add(token.id.getName()); values.add(token.expiresAt<START_MOD>()); values.add(java.lang.String.valueOf(token.expiresIn)<END_MOD>); return values; }
@org.junit.Test public void testTokenSerializationDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenProessor(cipher); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(<START_MOD>java.time.Instant.now(), <END_MOD>0); java.lang.String serialized = processor.serialize(token); assertThat(serialized).isNotEmpty(); java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> deserialized = processor.deserialize(serialized); assertThat(deserialized.isPresent()).isTrue(); assertThat(token.expiresAt<START_MOD>()<END_MOD>).isEqualTo(deserialized.get().expiresAt<START_MOD>()<END_MOD>); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != <START_MOD>4<END_MOD>) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1)), values.get(2)<START_MOD>, java.lang.Integer.valueOf(values.get(3))<END_MOD>)); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(4); values.add(token.user); values.add(token.project); values.add(token.operation); values.add(token.expiresAt<START_MOD>()); values.add(java.lang.String.valueOf(token.expiresIn)<END_MOD>); return values; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size()) != 4) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(3)<START_MOD>, java.lang.Integer.valueOf(values.get(4))<END_MOD>)); }
com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo generateAuthInfo(com.google.gerrit.server.CurrentUser user, java.lang.String project, java.lang.String operation) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(user.getUserName(), project, operation, <START_MOD>java.time.Instant.now(), expiresIn<END_MOD>); return new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(processor.serialize(token), token.expiresAt<START_MOD>(), token.expiresIn<END_MOD>); }
public com.googlesource.gerrit.plugins.lfs.AuthInfo generateAuthInfo(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id, <START_MOD>java.time.Instant now, <END_MOD>int <START_MOD>expiresIn<END_MOD>) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token = new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(operation, id, <START_MOD>now, expiresIn<END_MOD>); return new com.googlesource.gerrit.plugins.lfs.AuthInfo(processor.serialize(token), token.expiresAt<START_MOD>(), token.expiresIn<END_MOD>); }
<START_MOD>public<END_MOD> boolean onTime(java.<START_MOD>time<END_MOD>.<START_MOD>Instant<END_MOD> <START_MOD>when<END_MOD>) { return <START_MOD>when.isBefore<END_MOD>(<START_MOD>token<END_MOD>.<START_MOD>issued<END_MOD>.<START_MOD>plusMillis(token<END_MOD>.<START_MOD>expiresIn<END_MOD>)); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.util.List<java.lang.String> values) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0)<START_MOD>, java.lang.Integer.valueOf(values.get(1))<END_MOD>)); }
@org.junit.Test public void testTokenOnTime() throws java.lang.Exception {<START_MOD> java.time.Instant when = java.time.Instant.now();<END_MOD> com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(<START_MOD>when, 1000<END_MOD>); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier(token); assertThat(verifier.<START_MOD>onTime<END_MOD>(<START_MOD>when.plusMillis(999)<END_MOD>)).isTrue(); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(2); values.add(token.expiresAt<START_MOD>()); values.add(java.lang.String.valueOf(token.expiresIn)<END_MOD>); return values; }
@org.junit.Test public void testTokenExpired() throws java.lang.Exception {<START_MOD> java.time.Instant when = java.time.Instant.now();<END_MOD> com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(<START_MOD>when, 1000<END_MOD>); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestTokenVerifier(token); assertThat(verifier.<START_MOD>onTime<END_MOD>(<START_MOD>when.plusMillis(1001)<END_MOD>)).isFalse(); }
@org.junit.Test public void testVerifyAuthInfo() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), <START_MOD>java.time.Instant.now(), <END_MOD>1); assertThat(auth.verifyAuthInfo(info.authToken, "o", zeroId())).isTrue(); }
@org.junit.Test public void testVerifyAgainstDifferentOperation() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), <START_MOD>java.time.Instant.now(), <END_MOD>1); assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse(); }
@org.junit.Test public void testVerifyAgainstDifferentObjectId() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId<START_MOD>(), java.time.Instant.now<END_MOD>(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "o", org.eclipse.jgit.lfs.lib.LongObjectId.fromString(("123456789012345678901234567890" + ("123456789012345678901234567890" + "1234"))))).isFalse(); }
private boolean isRecoverable(java.<START_MOD>lang<END_MOD>.<START_MOD>Exception<END_MOD> e) { return <START_MOD>(<END_MOD>!(e instanceof javax.net.ssl.SSLException)<START_MOD>) && (e instanceof java.io.IOException)<END_MOD>; }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug( content. Webhook [{}] skipped. remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.get().post(remote, content.get()); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.<START_MOD>lang.RuntimeException | java.<END_MOD>io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error( to post: {} toString(), e); } } }
private void createRepository() { <START_MOD>if (pool.isCreateMissingRepos()) { try { <END_MOD>org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); <START_MOD>if (replicationQueue.createProject(projectName, (head != null ? head.getName() : null))) {<END_MOD> com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event = new com.google.gerrit.extensions.events.NewProjectCreatedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return projectName.get(); } @java.lang.Override public java.lang.String getHeadName() { return head != null ? head.getTarget().getName() : null; } @java.lang.Override public com.google.gerrit.extensions.api.changes.NotifyHandling getNotify() { return com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } }; replicationQueue.onNewProjectCreated(event); <START_MOD>pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING); } else { <END_MOD>com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(( repository <START_MOD>could not be <END_MOD>created<START_MOD> when replicating {}.   + ( can only create missing repositories locally, over SSH or when   +   adminUrl in<END_MOD> replication<START_MOD>.config. See documentation for more information. uri); } } catch (java.io.IOException ioe) { stateLog.error((( replicate<END_MOD> to   + (uri))<START_MOD> +   failed to create missing repository ioe, getStatesAsArray()); } } else { stateLog.error((( replicate to   + (uri)) +   repository not found getStatesAsArray()); } }<END_MOD>
<START_MOD>private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupById> readAccountGroupSubgroupsFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery(((("SELECT include_uuid" + (" FROM account_group_by_id" + " WHERE group_id = '")) + (groupId.get())) + "'"))) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupById> subgroups = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(rs.getString(1)); subgroups.add(new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(groupId, includedGroupUuid))); } return subgroups; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read subgroups of account group %s from ReviewDb", groupId.get()), e); } }<END_MOD>
<START_MOD>private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> readAccountGroupMembersFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery(((("SELECT account_id" + (" FROM account_group_members" + " WHERE group_id = '")) + (groupId.get())) + "'"))) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> members = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)); members.add(new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId))); } return members; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read members of account group %s from ReviewDb", groupId.get()), e); } }<END_MOD>
public static com.google.gerrit.server.group.db.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.<START_MOD>UUID groupUuid) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupFromReviewDb(db, groupUuid); com.google.gerrit.reviewdb.client.AccountGroup.<END_MOD>Id groupId = <START_MOD>group.getId(<END_MOD>); return com.google.gerrit.server.group.db.GroupBundle.create(com.google.gerrit.server.group.db.GroupBundle.Source.REVIEW_DB, group, com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMembersFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupAuditsFromReviewDb(db, groupId)); }
<START_MOD>public com.google.gerrit.server.group.db.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupFromReviewDb(db, groupId); return com.google.gerrit.server.group.db.GroupBundle.create(com.google.gerrit.server.group.db.GroupBundle.Source.REVIEW_DB, group, com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMembersFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupsFromReviewDb(db, groupId), com.google.gerrit.server.group.db.GroupBundle.Factory.readAccountGroupSubgroupAuditsFromReviewDb(db, groupId)); }<END_MOD>
<START_MOD>@org.junit.Test public void shouldSetAndUnsetForwardedContextEvenIfExceptionIsThrown() throws java.lang.Exception { doAnswer(((org.mockito.stubbing.Answer<java.lang.Void>) (( invocation) -> { assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isTrue(); throw new java.io.IOException("someMessage"); }))).when(indexerMock).index(id); assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); try { handler.index(id, Operation.INDEX); fail("should have throw an IOException"); } catch (java.io.IOException e) { assertThat(e.getMessage()).isEqualTo("someMessage"); } assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); verify(indexerMock).index(id); }<END_MOD>
<START_MOD>@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expectMessage("Delete from index not supported"); handler.index(Account.Id.parse("34"), Operation.DELETE); }<END_MOD>
<START_MOD>@org.junit.Before public void setUp() throws java.lang.Exception { handler = new com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexAccountHandler(indexerMock); id = Account.Id.parse("123"); }<END_MOD>
<START_MOD>@org.junit.Test public void shouldSetAndUnsetForwardedContextEvenIfExceptionIsThrown() throws java.lang.Exception { doAnswer(((org.mockito.stubbing.Answer<java.lang.Void>) (( invocation) -> { assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isTrue(); throw new java.io.IOException("someMessage"); }))).when(indexerMock).index(uuid); assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); try { handler.index(uuid, Operation.INDEX); fail("should have throw an IOException"); } catch (java.io.IOException e) { assertThat(e.getMessage()).isEqualTo("someMessage"); } assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); verify(indexerMock).index(uuid); }<END_MOD>
<START_MOD>@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expectMessage("Delete from index not supported"); handler.index(AccountGroup.UUID.parse("34"), Operation.DELETE); }<END_MOD>
<START_MOD>@org.junit.Before public void setUp() throws java.lang.Exception { handler = new com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexGroupHandler(indexerMock); uuid = AccountGroup.UUID.parse("123"); }<END_MOD>
<START_MOD>@org.junit.Test public void changeToIndexDoNotExist() throws java.lang.Exception { setupChangeAccessRelatedMocks(com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexChangeHandlerTest.CHANGE_DOES_NOT_EXIST); handler.index(id, Operation.INDEX); verify(indexerMock, times(1)).delete(id); }<END_MOD>
<START_MOD>@org.junit.Test public void shouldSetAndUnsetForwardedContextEvenIfExceptionIsThrown() throws java.lang.Exception { setupChangeAccessRelatedMocks(com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexChangeHandlerTest.CHANGE_EXISTS); doAnswer(((org.mockito.stubbing.Answer<java.lang.Void>) (( invocation) -> { assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isTrue(); throw new java.io.IOException("someMessage"); }))).when(indexerMock).index(dbMock, change); assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); try { handler.index(id, Operation.INDEX); fail("should have throw an IOException"); } catch (java.io.IOException e) { assertThat(e.getMessage()).isEqualTo("someMessage"); } assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); verify(indexerMock, times(1)).index(dbMock, change); }<END_MOD>
<START_MOD>private void setupChangeAccessRelatedMocks(boolean changeExist, boolean ormException, boolean ioException) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (ormException) { doThrow(new com.google.gwtorm.server.OrmException("")).when(schemaFactoryMock).open(); } else { when(schemaFactoryMock.open()).thenReturn(dbMock); com.google.gerrit.reviewdb.server.ChangeAccess ca = mock(com.google.gerrit.reviewdb.server.ChangeAccess.class); when(dbMock.changes()).thenReturn(ca); if (changeExist) { when(ca.get(id)).thenReturn(change); if (ioException) { doThrow(new java.io.IOException("io-error")).when(indexerMock).index(dbMock, change); } } else { when(ca.get(id)).thenReturn(null); } } }<END_MOD>
<START_MOD>@org.junit.Before public void setUp() throws java.lang.Exception { when(schemaFactoryMock.open()).thenReturn(dbMock); when(dbMock.changes()).thenReturn(changeAccessMock); id = Change.Id.parse("123"); change = new com.google.gerrit.reviewdb.client.Change(null, id, null, null, com.google.gerrit.common.TimeUtil.nowTs()); handler = new com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexChangeHandler(indexerMock, schemaFactoryMock); }<END_MOD>
@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); java.lang.String projectName = branch.getParentKey().get(); soyContext.put("projectName", projectName); soyContext.put("shortProjectName", projectName.replaceAll("/.*/", "..."<START_MOD>)); java.lang.String prefix = ""; if ((args.addInstanceNameInSubject) && ((args.instanceNameProvider) != null)) { prefix = (com.google.common.base.Strings.nullToEmpty(args.instanceNameProvider.get())) + "/"; } soyContext.put("instanceAndProjectName", (prefix + (soyContext.get("shortProjectName"))<END_MOD>)); soyContextEmailData.put("sshHost", getSshHost()); java.util.Map<java.lang.String, java.lang.String> branchData = new java.util.HashMap<>(); branchData.put("shortName", branch.getShortName()); soyContext.put("branch", branchData); footers.add(((MailHeader.PROJECT.withDelimiter()) + (branch.getParentKey().get()))); footers.add((   + (branch.getShortName()))); }
<START_MOD>private java.lang.String getInstanceName(org.eclipse.jgit.lib.Config config, @com.google.gerrit.common.Nullable com.google.inject.Provider<java.lang.String> canonicalUrlProvider) { java.lang.String instanceName = config.getString("gerrit", null, "shortName"); if ((instanceName != null) || (canonicalUrlProvider == null)) { return instanceName; } return canonicalUrlProvider.get(); }<END_MOD>
<START_MOD>private java.lang.String getInstanceName() { java.lang.System.out.println(args.instanceNameProvider); java.lang.System.out.println(args.instanceNameProvider.get()); return args.instanceNameProvider.get(); }<END_MOD>
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.<START_MOD>permissions.PermissionBackendException, com.google.gerrit.server.<END_MOD>update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { <START_MOD>if (!(permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER))) { <END_MOD>throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set work in progress } <START_MOD>} <END_MOD>if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( is   + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is already work in progress } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.<START_MOD>permissions.PermissionBackendException, com.google.gerrit.server.<END_MOD>update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { <START_MOD>if (!(permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER))) { <END_MOD>throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set ready for review } <START_MOD>} <END_MOD>if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( is   + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is not work in progress } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
protected <T> org.elasticsearch.index.query.QueryBuilder toQueryBuilder(com.google.gerrit.server.query.Predicate<T> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<T>) (p))); } else <START_MOD>if (p instanceof com.google.gerrit.server.query.AnyPredicate) { return org.elasticsearch.index.query.QueryBuilders.matchAllQuery(); } else <END_MOD>{ throw new com.google.gerrit.server.query.QueryParseException(( create query for index:   + p)); } }
public org.apache.lucene.search.Query toQuery(com.google.gerrit.server.query.Predicate<V> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<V>) (p))); } else <START_MOD>if (p instanceof com.google.gerrit.server.query.AnyPredicate) { return new org.apache.lucene.search.MatchAllDocsQuery(); } else <END_MOD>{ throw new com.google.gerrit.server.query.QueryParseException(( create query for index:   + p)); } }
<START_MOD>@java.lang.Override public boolean match(com.google.gerrit.server.account.AccountState accountState) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.account.AccountState> pred = getChild(0); checkState(pred.isMatchable(), ("match invoked, but child predicate %s " + "doesn't implement %s"), pred, com.google.gerrit.server.query.Matchable.class.getName()); return pred.asMatchable().match(accountState); }<END_MOD>
private boolean canRead(org.eclipse.jgit.lib.ObjectId revId) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try { <START_MOD>com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); checkNotNull(projectState,   to load project %s projectName); projectState.checkStatePermitsRead(); <END_MOD>permissionBackend.user(user).project(projectName).check(ProjectPermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException <START_MOD>| com.google.gerrit.extensions.restapi.ResourceConflictException <END_MOD>e) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(revId); return commits.canRead(projectState, repo, commit); } } }
<START_MOD>@org.junit.Test public void checkMaxWorks() { com.google.gerrit.common.data.LabelFunctionTest.checkMaxIsEnforced(LabelFunction.MAX_NO_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkMaxIsEnforced(LabelFunction.MAX_WITH_BLOCK); checkMaxValidatesTheLabel(LabelFunction.MAX_NO_BLOCK); checkMaxValidatesTheLabel(LabelFunction.MAX_WITH_BLOCK); }<END_MOD>
<START_MOD>private static void checkLabelIsRequired(com.google.gerrit.common.data.LabelFunction function) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED); assertThat(myLabel.appliedBy).isNull(); }<END_MOD>
<START_MOD>private static void checkMaxIsEnforced(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_1, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_0); com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.NEED); }<END_MOD>
<START_MOD>@org.junit.Test public void checkMaxNoBlockIgnoresMin() { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_M2, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_2, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_M2); com.google.gerrit.common.data.SubmitRecord.Label myLabel = LabelFunction.MAX_NO_BLOCK.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK); assertThat(myLabel.appliedBy).isEqualTo(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_2.getAccountId()); }<END_MOD>
<START_MOD>private static com.google.gerrit.reviewdb.client.PatchSetApproval makeApproval(short value) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id((10000 + value)); com.google.gerrit.reviewdb.client.PatchSetApproval.Key key = com.google.gerrit.common.data.LabelFunctionTest.makeKey(com.google.gerrit.common.data.LabelFunctionTest.PS_ID, accountId, com.google.gerrit.common.data.LabelFunctionTest.LABEL_ID); return new com.google.gerrit.reviewdb.client.PatchSetApproval(key, value, java.sql.Date.from(java.time.Instant.now())); }<END_MOD>
<START_MOD>@org.junit.Test public void checkLabelNameIsCorrect() { for (com.google.gerrit.common.data.LabelFunction function : com.google.gerrit.common.data.LabelFunction.values()) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.label).isEqualTo("Verified"); } }<END_MOD>
<START_MOD>@org.junit.Test public void checkFunctionDoesNothing() { com.google.gerrit.common.data.LabelFunctionTest.checkNothingHappens(LabelFunction.NO_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkNothingHappens(LabelFunction.NO_OP); com.google.gerrit.common.data.LabelFunctionTest.checkNothingHappens(LabelFunction.PATCH_SET_LOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabelIsRequired(LabelFunction.ANY_WITH_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabelIsRequired(LabelFunction.MAX_WITH_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabelIsRequired(LabelFunction.MAX_NO_BLOCK); }<END_MOD>
<START_MOD>private static void checkBlockWorks(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_1, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_M2, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_2); com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.REJECT); assertThat(myLabel.appliedBy).isEqualTo(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_M2.getAccountId()); }<END_MOD>
<START_MOD>public boolean isMaxValueMandatory() { return requiresMaxValue; }<END_MOD>
<START_MOD>public SubmitRecord.Label check(com.google.gerrit.common.data.LabelType t, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { com.google.gerrit.common.data.SubmitRecord.Label l = new com.google.gerrit.common.data.SubmitRecord.Label(); l.label = t.getName(); l.status = SubmitRecord.Label.Status.MAY; if (isMandatory) { l.status = SubmitRecord.Label.Status.NEED; } for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvals) { if ((a.getValue()) == 0) { continue; } if ((isBlock) && (t.isMaxNegative(a))) { l.appliedBy = a.getAccountId(); l.status = SubmitRecord.Label.Status.REJECT; return l; } if ((t.isMaxPositive(a)) || (!(requiresMaxValue))) { l.appliedBy = a.getAccountId(); l.status = SubmitRecord.Label.Status.MAY; if (isMandatory) { l.status = SubmitRecord.Label.Status.OK; } } } return l; }<END_MOD>
<START_MOD>public boolean isMandatory() { return isMandatory; }<END_MOD>
<START_MOD>private void checkMaxValidatesTheLabel(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_1, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_2, com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_M1); com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.OK); assertThat(myLabel.appliedBy).isEqualTo(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_2.getAccountId()); }<END_MOD>
<START_MOD>private static java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> getApprovalsForLabel(java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals, com.google.gerrit.common.data.LabelType t) { return approvals.stream().filter(( input) -> input.getLabel().equals(t.getLabelId().get())).collect(java.util.stream.Collectors.toList()); }<END_MOD>
<START_MOD>private static void checkNothingHappens(com.google.gerrit.common.data.LabelFunction function) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Label.Status.MAY); assertThat(myLabel.appliedBy).isNull(); }<END_MOD>
@java.lang.Override public com.google.gerrit.server.restapi.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.restapi.change.Description().setLabel( Review").setTitle("Set Ready For Review == (com.google.gerrit.reviewdb.client.Change.Status.NEW)) && (rsrc.getChange().isWorkInProgress()))<START_MOD>, or(rsrc.isUserOwner(), permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))<END_MOD>); }
@java.lang.Override public com.google.gerrit.server.restapi.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.restapi.change.Description().setLabel("WIP").setTitle( Work In Progress == (com.google.gerrit.reviewdb.client.Change.Status.NEW)) && (!(rsrc.getChange().isWorkInProgress())))<START_MOD>, or(rsrc.isUserOwner(), permissionBackend.user(self).testCond(GlobalPermission.ADMINISTRATE_SERVER)))<END_MOD>); }
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (IOException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.statePermitsRead())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.<START_MOD>currentUser(<END_MOD>).project(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format( project %s not available project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (IOException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.statePermitsRead())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.<START_MOD>currentUser(<END_MOD>).project(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; }
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, <START_MOD>currentUser<END_MOD>.get().state()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (<START_MOD>(<END_MOD>!(rsrc.isUserOwner())) <START_MOD>&& (!(permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER)))) <END_MOD>{ throw new com.google.gerrit.extensions.restapi.AuthException( allowed to set work in progress } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(( is   + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException( is already work in progress } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
public java.lang.String create() { java.lang.String summaryLine = (originalGroup.isPresent()) ?   group :   group java.util.<START_MOD>List<java.lang.String> footers = new java.util.ArrayList<>(); getFooterForRename().ifPresent(footers::add); getFootersForMemberModifications().forEach(footers::add); getFootersForSubgroupModifications().forEach(footers::add); java.util.Collections.sort(footers); java.util.<END_MOD>StringJoiner footerJoiner = new java.util.StringJoiner("\n", "\n\n", ""); footerJoiner.setEmptyValue(""); <START_MOD>footers<END_MOD>.forEach(footerJoiner::add); java.lang.String footer = footerJoiner.toString(); return summaryLine + footer; }
private boolean <START_MOD>isChangeDeletable<END_MOD>(com.google.gerrit.reviewdb.client.Change.Status status) { switch (status) { case NEW : case ABANDONED : return true; case MERGED : return false; } return false; }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change.Status status = rsrc.getChange().getStatus(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions().database(db); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Delete").setTitle(( change   + (rsrc.getId()))).setVisible(and(<START_MOD>isChangeDeletable<END_MOD>(status), perm.testCond(ChangePermission.DELETE))); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { if (<START_MOD>!(isChangeDeletable<END_MOD>(rsrc.getChange().getStatus())<START_MOD>)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException( not permitted } rsrc.permissions().database(db).check(ChangePermission.DELETE); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.<END_MOD>Change.<START_MOD>Id id = rsrc.getChange().getId(); bu.setOrder(Order.DB_BEFORE_REPO); bu.addOp(id, opProvider.get()); bu.execute(); } return<END_MOD> com.google.gerrit.extensions.restapi.<START_MOD>Response.none();<END_MOD> }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(0, ((id.length()) - (Constants.DOT_GIT_EXT.length()))); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { <START_MOD>com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.statePermitsRead()) ? com.google.gerrit.server.permissions.ProjectPermission.ACCESS : com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG; <END_MOD>try { permissionBackend.user(user).project(nameKey).check(<START_MOD>permissionToCheck<END_MOD>); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.WRITE_CONFIG); } catch (com.google.gerrit.extensions.restapi.AuthException e) { state.checkStatePermitsRead(); } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
private com.google.gerrit.server.project.ProjectState checkProjectState() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(projectName); <START_MOD>com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.statePermitsRead()) ? com.google.gerrit.server.permissions.ProjectPermission.ACCESS : com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG; <END_MOD>try { permissionBackend.user(user).project(projectName).check(<START_MOD>permissionToCheck<END_MOD>); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } state.checkStatePermitsRead(); return state; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { java.lang.String projectName = params.getParameter(0); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } while (projectName.startsWith("/")) { projectName = projectName.substring(1); } java.lang.String nameWithoutSuffix = com.google.gerrit.common.ProjectUtil.stripGitSuffix(projectName); com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(nameWithoutSuffix); com.google.gerrit.server.project.ProjectState state; try { state = projectCache.checkedGet(nameKey); if (state == null) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format( %s not found nameWithoutSuffix)); } <START_MOD>com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.statePermitsRead()) ? com.google.gerrit.server.permissions.ProjectPermission.ACCESS : com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG; <END_MOD>permissionBackend.user(user).project(nameKey).check(<START_MOD>permissionToCheck<END_MOD>); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.kohsuke.args4j.CmdLineException(owner, new com.google.gerrit.server.project.NoSuchProjectException(nameKey).getMessage()); } catch (com.google.gerrit.server.permissions.PermissionBackendException | java.io.IOException e) { com.google.gerrit.server.args4j.ProjectHandler.log.warn(( load project   + nameWithoutSuffix), e); throw new org.kohsuke.args4j.CmdLineException(owner, new com.google.gerrit.server.project.NoSuchProjectException(nameKey).getMessage()); } setter.addValue(state); return 1; }
public static com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> getCacheBuilder(org.eclipse.jgit.lib.Config config, java.lang.String name) { com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> b = com.google.common.cache.CacheBuilder.newBuilder(); try { if ((config.getString("cache", name, "maximumWeight")) != null) { b.maximumWeight(config.getLong("cache", name, "maximumWeight", (20 << 20))); } if ((config.getString("cache", name, "maximumSize")) != null) { b.maximumSize(config.getLong("cache", name, "maximumSize", 16384)); } <START_MOD>java.lang.Long<END_MOD> expireAfterWrite = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterWrite", null); if (expireAfterWrite != null) { b.expireAfterWrite(expireAfterWrite, java.util.concurrent.TimeUnit.MILLISECONDS); } <START_MOD>java.lang.Long<END_MOD> expireAfterAccess = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterAccess", null); if (expireAfterAccess != null) { b.expireAfterAccess(expireAfterAccess, java.util.concurrent.TimeUnit.MILLISECONDS); } } catch (java.lang.IllegalArgumentException e) { throw new java.lang.IllegalArgumentException(( getting CacheBuilder for   + name), e); } catch (java.lang.IllegalStateException e) { throw new java.lang.IllegalStateException(( getting CacheBuilder for   + name), e); } return b; }
<START_MOD>@javax.annotation.Nullable <END_MOD>public static <START_MOD>java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Long<END_MOD> getDuration(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection, java.lang.String name, @javax.annotation.Nullable <START_MOD>java<END_MOD>.<START_MOD>lang<END_MOD>.<START_MOD>Long<END_MOD> defaultValue) { long m = config.getTimeUnit(section, subsection, name, (-1), java.util.concurrent.TimeUnit.MILLISECONDS); <START_MOD>if<END_MOD> <START_MOD>(<END_MOD>m <START_MOD>!=<END_MOD> (-1)<START_MOD>)<END_MOD> <START_MOD>{<END_MOD> <START_MOD>return<END_MOD> m; }<START_MOD> return defaultValue; }<END_MOD>
@org.junit.Test public void nullAsDefault() throws java.lang.Exception { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); <START_MOD>java.lang.Long<END_MOD> t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank",     t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); }
@org.junit.Test public void getDurationCanReturnDefault() throws java.lang.Exception { <START_MOD>java.lang.Long def = 1000L; <END_MOD>org.<START_MOD>eclipse.jgit.lib.Config config = new<END_MOD> org.eclipse.jgit.lib.Config<START_MOD>(); java.lang.Long<END_MOD> t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t).isEqualTo(1000); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t).isEqualTo(1000); config.setString("core", null, "blank",     t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t).isEqualTo(1000); }
@org.junit.Test public void getDurationReturnsDuration() throws java.lang.Exception { <START_MOD>java.lang.Long def = 2 * 1000L; <END_MOD>org.<START_MOD>eclipse.jgit.lib.Config config = new<END_MOD> org.eclipse.jgit.lib.Config<START_MOD>(); java.lang.Long<END_MOD> t; config.setString("core", "dht", "timeout",   ms t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertThat(t).isEqualTo(500); config.setString("core", "dht", "timeout",   sec try { com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); fail( IllegalArgumentException } catch (java.lang.IllegalArgumentException e) { assertThat(e).hasMessageThat().isEqualTo( time unit value: core.dht.timeout=5.2 sec } config.setString("core", "dht", "timeout",   min t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertThat(t).isEqualTo(60000); }
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> additions) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(( edit global capabilities for projects other than   + (allProjects.get()))); } } } for (com.google.gerrit.common.data.AccessSection section : additions) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (!isGlobalCapabilities) { if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException( section name } com.google.gerrit.server.project.RefPattern.validate(name); } else { <START_MOD>java.util.Set<java.lang.String> pluginCapabilities = listCapabilities.collectPluginCapabilities().keySet(); <END_MOD>for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(<START_MOD>(<END_MOD>com.google.gerrit.common.data.GlobalCapability.<START_MOD>isGlobalCapability<END_MOD>(p.getName(<START_MOD>))) || (pluginCapabilities.contains(p.getName()<END_MOD>)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException((( add non-global capability   + (p.getName())) +   to global capabilities } } } } }
<START_MOD>static java.lang.String getShortProjectName(java.lang.String projectName) { int lastIndexSlash = projectName.lastIndexOf("/"); if (lastIndexSlash == 0) { return projectName.substring(1); } return "..." + (projectName.substring((lastIndexSlash + 1))); }<END_MOD>
<START_MOD>@org.junit.Test public void editCannotBeCreatedOnAbandonedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).abandon(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("change %s is ABANDONED", change._number)); createArbitraryEditFor(changeId); }<END_MOD>
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException( required } <START_MOD>com.google.gerrit.reviewdb.client.Change change = notes.getChange(); if (!(change.getStatus().isOpen())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format( %s is %s change.getChangeId(), change.getStatus())); } <END_MOD>try { permissionBackend.currentUser().database(reviewDb).change(notes).check(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException( not permitted denied); } }
<START_MOD>@org.junit.Test public void editCannotBeCreatedOnMergedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(changeId).current().submit(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("change %s is MERGED", change._number)); createArbitraryEditFor(changeId); }<END_MOD>
@java.lang.Override public boolean deleteChangeFromIndex(final int changeId) { return new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.Request(<START_MOD> from index<END_MOD> change   changeId) { @java.lang.Override com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send() throws java.io.IOException { return httpSession.delete(buildIndexEndpoint(changeId)); } }.execute(); }
@org.junit.Test public void storedSubmitRecordsWithRequirements() { com.google.gerrit.common.data.SubmitRecord r = com.google.gerrit.server.index.change.ChangeFieldTest.record(SubmitRecord.Status.OK, com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Label.Status.MAY, "Label-1", null), com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Label.Status.OK, "Label-2", 1)); com.google.gerrit.common.data.SubmitRequirement sr = new com.google.gerrit.common.data.SubmitRequirement( <START_MOD>text<END_MOD> can be a long string with special symbols like < >   / ; : <START_MOD>"short_type", com.google.common.collect.ImmutableMap.of("custom_data",   value<END_MOD> r.requirements = java.util.Collections.singletonList(sr); com.google.gerrit.server.index.change.ChangeFieldTest.assertStoredRecordRoundTrip(r); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels) != null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord.Label(); srl.label = label.label; srl.status = label.status; srl.appliedBy = ((label.appliedBy) != null) ? new com.google.gerrit.reviewdb.client.Account.Id(label.appliedBy) : null; rec.labels.add(srl); } } if ((requirements) != null) { rec.requirements = new java.util.ArrayList(requirements.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredRequirement <START_MOD>req<END_MOD> : requirements) { <START_MOD>if ((req.fallbackText) == null) { continue; } <END_MOD>com.google.gerrit.common.data.SubmitRequirement sr = new com.google.gerrit.common.data.SubmitRequirement(<START_MOD>req.fallbackText<END_MOD>, <START_MOD>req.type<END_MOD>, <START_MOD>req.data<END_MOD>); rec.requirements.add(sr); } } return rec; }
@java.lang.Override public boolean equals(java.lang.Object o) { if ((this) == o) { return true; } if (<START_MOD>!(<END_MOD>o instanceof com.google.gerrit.common.data.SubmitRequirement)<START_MOD>)<END_MOD> {<START_MOD> return false; }<END_MOD> com.google.gerrit.common.data.SubmitRequirement that = ((com.google.gerrit.common.data.SubmitRequirement) (o)); return ((java.util.Objects.equals(<START_MOD>fallbackText<END_MOD>, that.<START_MOD>fallbackText<END_MOD>)) && (java.util.Objects.equals(<START_MOD>type<END_MOD>, that.<START_MOD>type<END_MOD>))) && (java.util.Objects.equals(<START_MOD>data<END_MOD>, that.<START_MOD>data<END_MOD>)); }
public java.util.<START_MOD>Map<END_MOD><<START_MOD>java.lang.String, <END_MOD>java.lang.String> <START_MOD>data<END_MOD>() { return <START_MOD>data<END_MOD>; }
public java.lang.String <START_MOD>fallbackText<END_MOD>() { return <START_MOD>fallbackText<END_MOD>; }
@java.lang.Override public java.lang.String toString() { return (((((((("SubmitRequirement{" + <START_MOD>"fallbackText='"<END_MOD>) + (<START_MOD>fallbackText<END_MOD>)) + '\'') +   <START_MOD>type<END_MOD>= + (<START_MOD>type<END_MOD>)) + '\'') +   <START_MOD>data<END_MOD>= + (<START_MOD>data<END_MOD>)) + '}'; }
@java.lang.Override public int hashCode() { return java.util.Objects.hash(<START_MOD>fallbackText<END_MOD>, <START_MOD>type<END_MOD>, <START_MOD>data<END_MOD>); }
public java.lang.String <START_MOD>type<END_MOD>() { return <START_MOD>type<END_MOD>; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try<START_MOD> { if (versionManager.isKnownIndex(name))<END_MOD> { if (versionManager.startReindexer(name, force)) { stdout.println( started } else { stdout.println( to reindex, index is already the latest version } } <START_MOD>else { stdout.println( reindex, index is unknown based on this name } } <END_MOD>catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(( to start reindexer:   + (e.getMessage()))); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try<START_MOD> { if (versionManager.isKnownIndex(name))<END_MOD> { if (versionManager.activateLatestIndex(name)) { stdout.println( latest index version } else { stdout.println( activating index, already using latest version<START_MOD> } } else { stdout.println( activate index, unknown based on this name<END_MOD> } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(( to activate latest index:   + (e.getMessage()))); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String userName = user.getUserName().orElseThrow(() -> new com.google.gerrit.extensions.restapi.ResourceConflictException( must be set <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.server.account.externalids.ExternalId<START_MOD>> optionalExtId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.restapi.account.SCHEME_USERNAME, userName)); if (!(optionalExtId.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId<END_MOD> extId = <START_MOD>optionalExtId<END_MOD>.get(); accountsUpdateProvider.get().update( HTTP Password via API extId.accountId(), ( u) -> u.updateExternalId(com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword))); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@org.junit.Test public void rawDocument() throws java.lang.Exception { com.google.gerrit.extensions.common.AccountInfo userInfo = gApi.accounts().id(admin.getAccountId().get()).get(); java.util.Optional<com.google.gerrit.index.query.FieldBundle> rawFields = indexes.getSearchIndex().getRaw(new com.google.gerrit.reviewdb.client.Account.Id(userInfo._accountId), com.google.gerrit.index.QueryOptions.create(com.google.gerrit.index.IndexConfig.createDefault(), 0, 1, indexes.getSearchIndex().getSchema().getStoredFields().keySet())); assertThat(rawFields).isPresent(); assertThat(rawFields.get().getValue(AccountField.ID)).isEqualTo(userInfo._accountId); if ((getSchemaVersion()) < 6) { return; } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> externalIdInfos = gApi.accounts().self().getExternalIds(); java.util.List<com.google.gerrit.server.query.account.AbstractQueryAccountsTest.ByteArrayWrapper> blobs = new java.util.ArrayList<>(); for (com.google.gerrit.extensions.common.AccountExternalIdInfo info : externalIdInfos) { <START_MOD>java.util.Optional<com.google.gerrit.server.account.externalids.ExternalId> extId = externalIds.get(ExternalId.Key.parse(info.identity)); assertThat(extId.isPresent()).isTrue(); <END_MOD>blobs.add(new com.google.gerrit.server.query.account.AbstractQueryAccountsTest.ByteArrayWrapper(<START_MOD>extId.get(<END_MOD>).toByteArray())); } assertThat(rawFields.get().getValue(AccountField.EXTERNAL_ID_STATE)).hasSize(blobs.size()); assertThat(com.google.common.collect.Streams.stream(rawFields.get().getValue(AccountField.EXTERNAL_ID_STATE)).map(( b) -> new com.google.gerrit.server.query.account.ByteArrayWrapper(b)).collect(java.util.stream.Collectors.toList())).containsExactlyElementsIn(blobs); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); <START_MOD>if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(tag)) { throw new com.google.gerrit.extensions.restapi.AuthException(( allowed to delete   + tag)); } <END_MOD>permissionBackend.currentUser().project(resource.getNameKey()).ref(tag).check(RefPermission.DELETE); resource.getProjectState().checkStatePermitsWrite(); deleteRefFactory.create(resource).ref(tag).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { <START_MOD>if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(rsrc.getBranchKey().get())) { throw new com.google.gerrit.extensions.restapi.AuthException(( allowed to delete branch   + (rsrc.getBranchKey().get()))); } <END_MOD>permissionBackend.currentUser().ref(rsrc.getBranchKey()).check(RefPermission.DELETE); rsrc.getProjectState().checkStatePermitsWrite(); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((   + (rsrc.getBranchKey())) +   has open changes } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.restapi.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
<START_MOD>public static boolean isMetaConfigRef(java.lang.String ref) { return com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG.equals(ref); }<END_MOD>
private boolean canDelete(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException {<START_MOD> if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(cmd.getRefName())) { return false; }<END_MOD> try { permissions.ref(cmd.getRefName()).check(RefPermission.DELETE); return projectState.statePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId()) != null) ? ref.getObjectId().name() : null; <START_MOD>if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(ref.getName())) { <END_MOD>info.canDelete = <START_MOD>null; } else { info.canDelete = <END_MOD>(((!(targets.contains(ref.getName()))) && (perm.testOrFalse(RefPermission.DELETE))) && (projectState.statePermitsWrite())) ? true : null;<START_MOD> }<END_MOD> com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
@org.junit.Test public void storeThenQueryNotVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock<START_MOD>.get()<END_MOD>)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
@org.junit.Test public void storeThenQueryVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock<START_MOD>.get()<END_MOD>)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doNothing().when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); java.lang.String json = new com.google.gson.Gson().toJson(mockEvent); assertThat(events).containsExactly(json); }
@java.lang.Override public java.util.List<java.lang.String> queryChangeEvents(java.lang.String query) throws com.ericsson.gerrit.plugins.eventslog.EventsLogException { if (!(online)) { throw new com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException(); } java.util.List<com.ericsson.gerrit.plugins.eventslog.sql.SQLEntry> entries = new java.util.ArrayList<>(); for (java.util.Map.Entry<java.lang.String, java.util.Collection<com.ericsson.gerrit.plugins.eventslog.sql.SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) { java.lang.String projectName = entry.getKey(); try { permissionBackend.user(userProvider<START_MOD>.get()<END_MOD>).project(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)).check(ProjectPermission.ACCESS); entries.addAll(entry.getValue()); } catch (com.google.gerrit.extensions.restapi.AuthException e) { } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.warn( check project access permission e); } } return sortedEventsFromEntries(entries); }
@org.junit.Test public void notReturnEventWithNoVisibilityInfo() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock<START_MOD>.get()<END_MOD>)).thenReturn(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
private java.lang.Object logo() { if ((logoUrl) == null) { return null; } java.lang.String url = fmt.image(logoUrl); if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return url; } else if (com.google.gitiles.doc.html.HtmlBuilder.isImageDataUri(url)) { return com.google.template.soy.shared.<START_MOD>internal<END_MOD>.Sanitizers.filterImageDataUri(url); } else { return <START_MOD>SharedUtility<END_MOD>.<START_MOD>IMAGE_URI_INNOCUOUS_OUTPUT<END_MOD>; } }
java.lang.String inline(@javax.annotation.Nullable java.lang.String markdownPath, java.lang.String imagePath) { java.lang.String data = inlineMaybe(markdownPath, imagePath); if (data != null) { return data; } return <START_MOD>SharedUtility<END_MOD>.<START_MOD>IMAGE_URI_INNOCUOUS_OUTPUT<END_MOD>; }
@com.google.common.annotations.VisibleForTesting java.lang.String href(java.lang.String target) { if (((target.startsWith("#")) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(target))) || (com.google.gitiles.doc.html.HtmlBuilder.isValidMailtoUri(target))) { return target; } else if (target.startsWith("git:")) { if (com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri(target)) { return target; } return <START_MOD>SharedUtility.NORMAL_URI_INNOCUOUS_OUTPUT<END_MOD>; } java.lang.String anchor = ""; int hash = target.indexOf('#'); if (hash >= 0) { anchor = target.substring(hash); target = target.substring(0, hash); } java.lang.String dest = com.google.gitiles.doc.PathResolver.resolve(filePath, target); if ((dest == null) || ((view) == null)) { return <START_MOD>SharedUtility.NORMAL_URI_INNOCUOUS_OUTPUT<END_MOD>; } com.google.gitiles.GitilesView.Builder b; if ((view.getType()) == (GitilesView.Type.ROOTED_DOC)) { b = com.google.gitiles.GitilesView.rootedDoc(); } else { b = com.google.gitiles.GitilesView.path(); } dest = b.copyFrom(view).setPathPart(dest).build().toUrl(); return (com.google.gitiles.doc.PathResolver.relative(requestUri, dest)) + anchor; }
java.lang.String image(java.lang.String dest) { if ((com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest)) || (com.google.gitiles.doc.html.HtmlBuilder.isImageDataUri(dest))) { return dest; } else if ((imageLoader) != null) { return imageLoader.inline(filePath, dest); } return <START_MOD>SharedUtility<END_MOD>.<START_MOD>IMAGE_URI_INNOCUOUS_OUTPUT<END_MOD>; }
@org.junit.Test <START_MOD>@com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") <END_MOD>public void voteOnBehalfOfInvalidLabel() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.RevisionApi revision = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Not-A-Label", 5); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage(   is not a configured label revision.review(in); }
<START_MOD>@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") public void strictLabelVotes() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.label("Verified", (-1)); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("label \"Verified\" is not a configured label"); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in); }<END_MOD>
<START_MOD>@org.junit.Test public void nonStrictLabelVotesPerDefault() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); java.lang.String changeId = r.getChangeId(); com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.approve(); in.label("Verified", (-1)); in.label("Code-Style", 1); in.label("Library-Compliance", (-1)); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in); assertThat(gApi.changes().id(changeId).current().reviewer(admin.email).votes().keySet()).containsExactly("Code-Review"); assertThat(gApi.changes().id(changeId).current().reviewer(admin.email).votes().values()).containsExactly(((short) (2))); assertThat(gApi.changes().id(changeId).get().submittable).isTrue(); in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.label("Code-Review", 42); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in); assertThat(gApi.changes().id(changeId).current().reviewer(admin.email).votes().values()).containsExactly(((short) (2))); }<END_MOD>
<START_MOD>@org.junit.Test public void voteOnBehalfOfInvalidLabelIgnoredWithoutStrictLabels() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.RevisionApi revision = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Code-Review", 1); in.label("Not-A-Label", 5); revision.review(in); assertThat(gApi.changes().id(r.getChangeId()).get().labels).doesNotContainKey("Not-A-Label"); }<END_MOD>
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.account.AccountResource.Capability resource) <START_MOD>throws com.google.gerrit.extensions.restapi.ResourceNotFoundException <END_MOD>{<START_MOD> permissionBackend.checkDefault();<END_MOD> return com.google.gerrit.extensions.restapi.BinaryResult.create("ok\n"); }
<START_MOD>private static java.lang.String changePermissionName(com.google.gerrit.server.permissions.ChangePermission changePermission) { return com.google.gerrit.server.permissions.DefaultPermissionMappings.changePermissionName(changePermission).orElseThrow(() -> new java.lang.IllegalStateException()); }<END_MOD>
<START_MOD>private static java.lang.String refPermissionName(com.google.gerrit.server.permissions.RefPermission refPermission) { return com.google.gerrit.server.permissions.DefaultPermissionMappings.refPermissionName(refPermission).orElseThrow(() -> new java.lang.IllegalStateException()); }<END_MOD>
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.<START_MOD>RestApiException<END_MOD>, com.google.gerrit.server.permissions.PermissionBackendException {<START_MOD> permissionBackend.checkDefault();<END_MOD> com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser(); if ((self.get()) != (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : perm.test(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.AccountLimits limits = limitsFactory.create(rsrc.getUser()); addRanges(have, limits); addPriority(have, limits); return OutputFormat.JSON.newGson().toJsonTree(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Capability parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException { <START_MOD>permissionBackend.checkDefault(); <END_MOD>com.google.gerrit.server.IdentifiedUser target = parent.getUser(); if ((self.get()) != target) { permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm = parse(id); if (permissionBackend.user(target).test(perm)) { return new com.google.gerrit.server.account.AccountResource.Capability(target, perm.permissionName()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private com.google.gerrit.extensions.api.access.GlobalOrPluginPermission parse(com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { java.lang.String name = id.get(); <START_MOD>java.util.Optional<com.google.gerrit.server.permissions.GlobalPermission><END_MOD> perm = com.google.gerrit.server.permissions.<START_MOD>DefaultPermissionMappings.globalPermission<END_MOD>(name); if (perm<START_MOD>.isPresent()<END_MOD>) { return perm<START_MOD>.get()<END_MOD>; } int dash = name.lastIndexOf('-'); if (dash < 0) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } java.lang.String pluginName = name.substring(0, dash); java.lang.String capability = name.substring((dash + 1)); if ((pluginName.isEmpty()) || (capability.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, capability); }
<START_MOD>public boolean isDefault() { return false; }<END_MOD>
<START_MOD>public void checkDefault() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if (!(isDefault())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("Gerrit permissions not used on this server"); } }<END_MOD>
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.restapi.config.ListCapabilities.CapabilityInfo> apply(com.google.gerrit.server.config.ConfigResource resource) throws <START_MOD>com.google.gerrit.extensions.restapi.ResourceNotFoundException, <END_MOD>java.lang.IllegalAccessException, java.lang.NoSuchFieldException {<START_MOD> permissionBackend.checkDefault();<END_MOD> return com.google.common.collect.ImmutableMap.<java.lang.String, com.google.gerrit.server.restapi.config.ListCapabilities.CapabilityInfo>builder().putAll(collectCoreCapabilities()).putAll(collectPluginCapabilities()).build(); }
<START_MOD>@java.lang.Override public boolean isDefault() { return true; }<END_MOD>
private java.util.Collection<com.google.gerrit.server.account.AccountSshKey> fixInvalidSequenceNumbers(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> keys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.comparing(( k) -> k.<START_MOD>id<END_MOD>().get())); java.util.List<com.google.gerrit.server.account.AccountSshKey> fixedKeys = new java.util.ArrayList(keys); com.google.gerrit.server.account.AccountSshKey minKey = o.min(keys); while ((minKey.<START_MOD>id<END_MOD>().get()) <= 0) { com.google.gerrit.server.account.AccountSshKey fixedKey = <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(<END_MOD>new com.google.gerrit.server.account.AccountSshKey.Id(minKey.<START_MOD>id<END_MOD>().getParentKey(), java.lang.Math.max(((o.max(keys).<START_MOD>id<END_MOD>().get()) + 1), 1)), minKey.<START_MOD>sshPublicKey<END_MOD>()); java.util.Collections.replaceAll(fixedKeys, minKey, fixedKey); minKey = o.min(fixedKeys); } return fixedKeys; }
private void markInvalid(com.google.gerrit.server.account.AccountSshKey k) { try { com.google.gerrit.sshd.SshKeyCacheImpl.log.info((( SSH key   + (k.<START_MOD>id<END_MOD>())) +   invalid authorizedKeys.markKeyInvalid(k.<START_MOD>account<END_MOD>(), k.<START_MOD>id<END_MOD>().get()); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.sshd.SshKeyCacheImpl.log.error((( to mark SSH key + (k.<START_MOD>id<END_MOD>())) +   invalid e); } }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) { return com.google.gerrit.server.account.AccountSshKey<START_MOD>.create<END_MOD>(id, encoded); }
private void add(java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl, com.google.gerrit.server.account.AccountSshKey k) { try { kl.add(new com.google.gerrit.sshd.SshKeyCacheEntry(k.<START_MOD>id<END_MOD>(), com.google.gerrit.sshd.SshUtil.parse(k))); } catch (java.lang.OutOfMemoryError e) { throw e; } catch (java.lang.Throwable e) { markInvalid(k); } }
private void deleteSshKey(com.google.gerrit.extensions.common.SshKeyInfo i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.account.AccountSshKey sshKey = com.google.gerrit.server.account.AccountSshKey<START_MOD>.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(user.getAccountId(), i.seq), i.sshPublicKey); deleteSshKey.apply(new com.google.gerrit.server.account.AccountResource.SshKey(user.asIdentifiedUser(), sshKey), null); }
public static com.google.gerrit.extensions.common.SshKeyInfo newSshKeyInfo(com.google.gerrit.server.account.AccountSshKey sshKey) { com.google.gerrit.extensions.common.SshKeyInfo info = new com.google.gerrit.extensions.common.SshKeyInfo(); info.seq = sshKey.<START_MOD>id<END_MOD>().get(); info.sshPublicKey = sshKey.<START_MOD>sshPublicKey<END_MOD>(); info.encodedKey = sshKey.<START_MOD>encodedKey<END_MOD>(); info.algorithm = sshKey.<START_MOD>algorithm<END_MOD>(); info.comment = com.google.common.base.Strings.emptyToNull(sshKey.<START_MOD>comment<END_MOD>()); info.valid = sshKey.<START_MOD>valid<END_MOD>(); return info; }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId user = externalIds.get(ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username)); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.server.account.AccountSshKey k : authorizedKeys.getKeys(user.accountId())) { if (k.<START_MOD>valid<END_MOD>()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); }
private boolean markKeyInvalid(int seq) { checkLoaded(); <START_MOD>java.util.Optional<<END_MOD>com.google.gerrit.server.account.AccountSshKey<START_MOD>><END_MOD> key = <START_MOD>keys.get(<END_MOD>(seq<START_MOD> - 1)<END_MOD>); if ((key<START_MOD>.isPresent()<END_MOD>) && (key.<START_MOD>get().valid<END_MOD>())) { <START_MOD>keys.add((seq - 1), java.util.Optional.of(com.google.gerrit.server.account.AccountSshKey.createInvalid(<END_MOD>key.<START_MOD>get<END_MOD>(<START_MOD>)))<END_MOD>); return true; } return false; }
public <START_MOD>abstract com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.server.account.AccountSshKey.Id<END_MOD> <START_MOD>id<END_MOD>();
<START_MOD>public abstract com.google.gerrit.server.account.AccountSshKey.Builder setId(com.google.gerrit.server.account.AccountSshKey.Id id);<END_MOD>
public <START_MOD>static com.google.gerrit.server.account.AccountSshKey createInvalid(<END_MOD>com.google.gerrit.server.account.AccountSshKey.Id <START_MOD>id, java.lang.String sshPublicKey<END_MOD>) { return <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(<END_MOD>id<START_MOD>, sshPublicKey, false)<END_MOD>; }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.create<END_MOD>(id, com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey(encoded)); com.google.gerrit.sshd.SshUtil.parse(key); return key; } catch (java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e) { throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } catch (java.security.NoSuchProviderException e) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error( parse SSH key e); throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } }
public static java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String s) { java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys = new java.util.ArrayList<>(); int seq = 1; for (java.lang.String line : s.split("\\r?\\n")) { line = line.trim(); if (line.isEmpty()) { continue; } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX)) { java.lang.String pub = line.substring(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX.length()); com.google.gerrit.server.account.AccountSshKey key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.createInvalid<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++)), pub); keys.add(java.util.Optional.of(key)); } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.DELETED_KEY_COMMENT)) { keys.add(java.util.Optional.empty()); seq++; } else if (line.startsWith("#")) { continue; } else { com.google.gerrit.server.account.AccountSshKey key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++)), line); keys.add(java.util.Optional.of(key)); } } return keys; }
@org.junit.Test public void validity() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (-1)), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.<START_MOD>valid<END_MOD>()).isFalse(); key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(<END_MOD>new com.google.gerrit.server.account.AccountSshKey<START_MOD>.Id(accountId, 0), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.valid()).isFalse(); key = com.google.gerrit.server.account.AccountSshKey.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, <START_MOD>1<END_MOD>), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.<START_MOD>valid<END_MOD>()).isTrue(); }
@org.junit.Test public void getters() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey<START_MOD>.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.<START_MOD>sshPublicKey<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.<START_MOD>algorithm<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   assertThat(key.<START_MOD>encodedKey<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   assertThat(key.<START_MOD>comment<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   }
private static void assertParse(java.lang.StringBuilder authorizedKeys, java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> expectedKeys) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parsedKeys = com.google.gerrit.server.account.AuthorizedKeys.parse(accountId, authorizedKeys.toString()); assertThat(parsedKeys).containsExactlyElementsIn(expectedKeys); int seq = 1; for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> sshKey : parsedKeys) { if (sshKey.isPresent()) { assertThat(sshKey.get().<START_MOD>account<END_MOD>()).isEqualTo(accountId); assertThat(sshKey.get().<START_MOD>id<END_MOD>().get()).isEqualTo(seq); } seq++; } }
private static java.lang.String addInvalidKey(java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = <START_MOD>com.google.gerrit.server.account.AccountSshKey.createInvalid<END_MOD>(keyId, pub); <START_MOD>keys.add(java.util.Optional.of(<END_MOD>key<START_MOD>)); return ((AuthorizedKeys.INVALID_KEY_COMMENT_PREFIX) + <END_MOD>(key<START_MOD>.sshPublicKey())<END_MOD>) + "\n"; }
@org.junit.Test public void keyWithNewLines() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey<START_MOD>.create<END_MOD>(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1_WITH_NEWLINES); assertThat(key.<START_MOD>sshPublicKey<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.<START_MOD>algorithm<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   assertThat(key.<START_MOD>encodedKey<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   assertThat(key.<START_MOD>comment<END_MOD>()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(   }
private static java.lang.String addKey(java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey<START_MOD>.create<END_MOD>(keyId, pub); keys.add(java.util.Optional.of(key)); return (key.<START_MOD>sshPublicKey<END_MOD>()) + "\n"; }
private com.google.gerrit.server.account.AccountSshKey addKey(java.lang.String pub) throws com.google.gerrit.common.errors.InvalidSshKeyException { checkLoaded(); for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key : keys) { if ((key.isPresent()) && (key.get().<START_MOD>sshPublicKey<END_MOD>().trim().equals(pub.trim()))) { return key.get(); } } int seq = (keys.size()) + 1; com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(accountId, seq); com.google.gerrit.server.account.AccountSshKey key = sshKeyCreator.create(keyId, pub); keys.add(java.util.Optional.of(key)); return key; }
public <START_MOD>static com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.server.account.AccountSshKey<END_MOD> <START_MOD>createInvalid<END_MOD>(<START_MOD>com.google.gerrit.server.account.AccountSshKey key<END_MOD>) { return <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(key.id(), key.<END_MOD>sshPublicKey<START_MOD>(), false)<END_MOD>; }
public <START_MOD>static com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey<END_MOD>.Id <START_MOD>id, java.lang.String sshPublicKey<END_MOD>) { return <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(<END_MOD>id<START_MOD>, sshPublicKey, true)<END_MOD>; }
public <START_MOD>Account.Id<END_MOD> <START_MOD>account<END_MOD>() { <START_MOD>return<END_MOD> <START_MOD>id().accountId<END_MOD>; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.SshKey rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().<START_MOD>id<END_MOD>().get()); rsrc.getUser().getUserName().ifPresent(sshKeyCache::evict); return com.google.gerrit.extensions.restapi.Response.none(); }
<START_MOD>private java.lang.String publicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = sshPublicKey(); if ((s != null) && ((s.length()) > 0)) { java.lang.String[] parts = s.split(" "); if ((parts.length) > index) { return parts[index]; } } return defaultValue; }<END_MOD>
private com.google.gerrit.server.account.AccountSshKey createSshKey(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String keyFile) throws java.io.IOException { java.nio.file.Path p = java.nio.file.Paths.get(keyFile); if (!(java.nio.file.Files.exists(p))) { throw new java.io.IOException(java.lang.String.format( add public SSH key: %s is not a file keyFile)); } java.lang.String content = new java.lang.String(java.nio.file.Files.readAllBytes(p), java.nio.charset.StandardCharsets.UTF_8); return <START_MOD>com.google.gerrit.server.account.AccountSshKey.create(<END_MOD>new com.google.gerrit.server.account.AccountSshKey.Id(id, 1), content); }
<START_MOD>public<END_MOD> <START_MOD>static com<END_MOD>.<START_MOD>google<END_MOD>.<START_MOD>gerrit.server.account.AccountSshKey<END_MOD> <START_MOD>create<END_MOD>(<START_MOD>com.google.gerrit.server.account.AccountSshKey.Id<END_MOD> <START_MOD>id<END_MOD>, java.lang.String <START_MOD>sshPublicKey,<END_MOD> <START_MOD>boolean<END_MOD> <START_MOD>valid<END_MOD>) { return <START_MOD>new com.google.gerrit.server.account.AutoValue_AccountSshKey.Builder().setId(id).setSshPublicKey(com.google.gerrit.server.account.AccountSshKey.stripOffNewLines(sshPublicKey)).setValid((valid && (id.isValid()))).build()<END_MOD>; }
public void setKeys(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> newKeys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.comparing(( k) -> k.<START_MOD>id<END_MOD>().get())); keys = new java.util.ArrayList(java.util.Collections.nCopies(o.max(newKeys).<START_MOD>id<END_MOD>().get(), java.util.Optional.empty())); for (com.google.gerrit.server.account.AccountSshKey key : newKeys) { keys.set(((key.<START_MOD>id<END_MOD>().get()) - 1), java.util.Optional.of(key)); } }
@java.lang.Override public void start() { if ((executor) == null) { return; } java.<START_MOD>lang.Thread<END_MOD> scheduler = <START_MOD>new java.lang.Thread(() -> { for (com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { executor<END_MOD>.execute(() -> <START_MOD>cache.get(<END_MOD>name<START_MOD>)<END_MOD>); } executor.shutdown(); try { executor.awaitTermination(java.lang.Long.MAX_VALUE, java.util.concurrent.TimeUnit.MILLISECONDS); com.google.gerrit.server.project.ProjectCacheWarmer.log.info( loading project cache } catch (java.lang.InterruptedException e) { com.google.gerrit.server.project.ProjectCacheWarmer.log.warn( while waiting for project cache to load } }); <START_MOD>scheduler.setName("ProjectCacheWarmer"); scheduler.setDaemon(true); com.google.gerrit.server.project.ProjectCacheWarmer.log.info( project cache scheduler.start(); }<END_MOD>
<START_MOD>java.lang.String[] sshAllows() { return sshAllows; }<END_MOD>
<START_MOD>@org.junit.Test public void assignee() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testing.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); com.google.gerrit.extensions.api.changes.AssigneeInput input = new com.google.gerrit.extensions.api.changes.AssigneeInput(); input.assignee = user.getUserName().get(); gApi.changes().id(change1.getChangeId()).setAssignee(input); assertQuery("is:assigned", change1); assertQuery("-is:assigned", change2); assertQuery("is:unassigned", change2); assertQuery("-is:unassigned", change1); assertQuery(("assignee:" + (user.getUserName())), change1); assertQuery(("-assignee:" + (user.getUserName())), change2); }<END_MOD>