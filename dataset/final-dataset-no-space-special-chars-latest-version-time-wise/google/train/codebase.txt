

static void postSignIn(final boolean success) { final com.google.gerrit.client.SignInDialog d = com.google.gerrit.client.SignInDialog.current; assert d != null; if (success) { com.google.gerrit.client.Gerrit.postSignIn(); d.hide(); if ((d.callback) != null) { d.callback.onSuccess(null); } } else { d.hide(); } }
static void postSignIn(final boolean success) { final com.google.gerrit.client.SignInDialog d = com.google.gerrit.client.SignInDialog.current; assert d != null; if (success) { com.google.gerrit.client.Gerrit.postSignIn(); d.hide(); if ((d.callback) != null) { com.google.gwt.user.client.DeferredCommand.addCommand(new com.google.gwt.user.client.Command() { public void execute() { d.callback.onSuccess(null); } }); } } else { d.hide(); } }
public void execute() { d.callback.onSuccess(null); }
private com.google.gwtorm.jdbc.Database<com.google.gerrit.client.reviewdb.ReviewDb> createDatabase() throws com.google.gwtorm.client.OrmException { final java.util.Properties p = readGerritDataSource(); return new com.google.gwtorm.jdbc.Database<com.google.gerrit.client.reviewdb.ReviewDb>(p, com.google.gerrit.client.reviewdb.ReviewDb.class); }


private void initUI() { addStyleName("gerrit-ChangeScreen"); descriptionBlock = new com.google.gerrit.client.changes.ChangeDescriptionBlock(); add(descriptionBlock); dependencies = new com.google.gerrit.client.changes.ChangeTable(); dependsOn = new com.google.gerrit.client.changes.ChangeTable.Section(Util.C.changeScreenDependsOn()); neededBy = new com.google.gerrit.client.changes.ChangeTable.Section(Util.C.changeScreenNeededBy()); dependencies.addSection(dependsOn); dependencies.addSection(neededBy); dependenciesPanel = new com.google.gwt.user.client.ui.DisclosurePanel(Util.C.changeScreenDependencies()); dependenciesPanel.setContent(dependencies); dependenciesPanel.setWidth("95%"); add(dependenciesPanel); approvals = new com.google.gerrit.client.changes.ApprovalTable(); approvalsPanel = new com.google.gwt.user.client.ui.DisclosurePanel(Util.C.changeScreenApprovals()); approvalsPanel.setContent(com.google.gerrit.client.changes.ChangeScreen.wrap(approvals)); dependenciesPanel.setWidth("95%"); add(approvalsPanel); patchSetPanels = new com.google.gwt.user.client.ui.FlowPanel(); add(patchSetPanels); messagesContent = new com.google.gwt.user.client.ui.FlowPanel(); messagesContent.setStyleName("gerrit-ChangeMessages"); messagesPanel = new com.google.gwt.user.client.ui.DisclosurePanel(Util.C.changeScreenMessages()); messagesPanel.setContent(messagesContent); add(messagesPanel); }



public void display(final java.util.Set<com.google.gerrit.client.reviewdb.ApprovalCategory.Id> need, final java.util.List<com.google.gerrit.client.data.ApprovalDetail> rows) { final int oldcnt = table.getRowCount(); table.resizeRows((1 + (rows.size()))); if (oldcnt < (1 + (rows.size()))) { for (int row = oldcnt; row < (1 + (rows.size())); row++) { applyEdgeStyles(row); applyScoreStyles(row); } } if (rows.isEmpty()) { table.setVisible(false); } else { table.setVisible(true); for (int i = 0; i < (rows.size()); i++) { displayRow((i + 1), rows.get(i)); } } missing.clear(); missing.setVisible(false); if (need != null) { for (final com.google.gerrit.client.data.ApprovalType at : types) { if (need.contains(at.getCategory().getId())) { final com.google.gwt.user.client.ui.Label l = new com.google.gwt.user.client.ui.Label(Util.M.needApproval(at.getCategory().getName())); l.setStyleName("gerrit-Change-MissingApproval"); missing.add(l); missing.setVisible(true); } } } }

public void updateContact(final java.lang.String fullName, final java.lang.String emailAddr, final com.google.gerrit.client.reviewdb.ContactInformation info, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { run(callback, new com.google.gerrit.server.Action<com.google.gwtjsonrpc.client.VoidResult>() { public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account me = db.accounts().get(com.google.gerrit.client.rpc.Common.getAccountId()); me.setFullName(fullName); me.setPreferredEmail(emailAddr); me.setContactInformation(info); db.accounts().update(java.util.Collections.singleton(me)); com.google.gerrit.client.rpc.Common.getAccountCache().invalidate(me.getId()); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } }); }
public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account me = db.accounts().get(com.google.gerrit.client.rpc.Common.getAccountId()); me.setFullName(fullName); me.setPreferredEmail(emailAddr); me.setContactInformation(info); db.accounts().update(java.util.Collections.singleton(me)); com.google.gerrit.client.rpc.Common.getAccountCache().invalidate(me.getId()); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }




public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.patch.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.PatchLineComment comment = db.patchComments().get(commentKey); if (comment == null) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } if (!(com.google.gerrit.client.rpc.Common.getAccountId().equals(comment.getAuthor()))) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } if ((comment.getStatus()) != (PatchLineComment.Status.DRAFT)) { throw new com.google.gerrit.server.patch.Failure(new java.lang.IllegalStateException("Comment published")); } db.patchComments().delete(java.util.Collections.singleton(comment)); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.patch.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult r; r = db.run(new com.google.gwtorm.client.OrmRunnable<com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult, com.google.gerrit.client.reviewdb.ReviewDb>() { public com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult run(com.google.gerrit.client.reviewdb.ReviewDb db, com.google.gwtorm.client.Transaction txn, boolean retry) throws com.google.gwtorm.client.OrmException { return doPublishComments(psid, message, approvals, db, txn); } }); try { final com.google.gerrit.server.ChangeMail cm = new com.google.gerrit.server.ChangeMail(server, r.change); cm.setFrom(com.google.gerrit.client.rpc.Common.getAccountId()); cm.setPatchSet(r.patchSet, r.info); cm.setChangeMessage(r.message); cm.setPatchLineComments(r.comments); cm.setReviewDb(db); cm.setHttpServletRequest(com.google.gerrit.server.GerritJsonServlet.getCurrentCall().getHttpServletRequest()); cm.sendComment(); } catch (MessagingException e) { log.error(("Cannot send comments by email for patch set " + psid), e); throw new com.google.gerrit.server.patch.Failure(e); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }

public void deleteDraft(final com.google.gerrit.client.reviewdb.PatchLineComment.Key commentKey, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { run(callback, new com.google.gerrit.server.patch.Action<com.google.gwtjsonrpc.client.VoidResult>() { public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.patch.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.PatchLineComment comment = db.patchComments().get(commentKey); if (comment == null) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } if (!(com.google.gerrit.client.rpc.Common.getAccountId().equals(comment.getAuthor()))) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } if ((comment.getStatus()) != (PatchLineComment.Status.DRAFT)) { throw new com.google.gerrit.server.patch.Failure(new java.lang.IllegalStateException("Comment published")); } db.patchComments().delete(java.util.Collections.singleton(comment)); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } }); }
public com.google.gerrit.client.reviewdb.PatchLineComment run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.patch.Failure, com.google.gwtorm.client.OrmException { if ((comment.getStatus()) != (PatchLineComment.Status.DRAFT)) { throw new com.google.gerrit.server.patch.Failure(new java.lang.IllegalStateException("Comment published")); } final com.google.gerrit.client.reviewdb.Patch patch = db.patches().get(comment.getKey().getParentKey()); final com.google.gerrit.client.reviewdb.Change change; if (patch == null) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } change = db.changes().get(patch.getKey().getParentKey().getParentKey()); assertCanRead(change); final com.google.gerrit.client.reviewdb.Account.Id me = com.google.gerrit.client.rpc.Common.getAccountId(); if ((comment.getKey().get()) == null) { final com.google.gerrit.client.reviewdb.PatchLineComment nc = new com.google.gerrit.client.reviewdb.PatchLineComment(new com.google.gerrit.client.reviewdb.PatchLineComment.Key(patch.getKey(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), comment.getLine(), me); nc.setSide(comment.getSide()); nc.setMessage(comment.getMessage()); db.patchComments().insert(java.util.Collections.singleton(nc)); return nc; } else { if (!(me.equals(comment.getAuthor()))) { throw new com.google.gerrit.server.patch.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } comment.updated(); db.patchComments().update(java.util.Collections.singleton(comment)); return comment; } }





public com.google.gerrit.client.data.ChangeDetail run(final com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.client.changes.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Change change = db.changes().get(id); if (change == null) { throw new com.google.gerrit.client.changes.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } assertCanRead(change); final boolean anon; if ((com.google.gerrit.client.rpc.Common.getAccountId()) == null) { anon = true; } else { anon = canRead(null, change.getDest().getParentKey()); } final com.google.gerrit.client.data.ChangeDetail d = new com.google.gerrit.client.data.ChangeDetail(); d.load(db, new com.google.gerrit.client.data.AccountInfoCacheFactory(db), change, anon); return d; }


public void onSuccess(final com.google.gerrit.client.admin.ProjectDetail result) { display(result); }
@java.lang.Override public void onLoad() { if ((members) == null) { initUI(); } enableForm(false); saveName.setEnabled(false); saveOwner.setEnabled(false); saveDesc.setEnabled(false); super.onLoad(); Util.GROUP_SVC.groupDetail(groupId, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.admin.AccountGroupDetail>() { public void onSuccess(final com.google.gerrit.client.admin.AccountGroupDetail result) { enableForm(true); saveName.setEnabled(false); saveOwner.setEnabled(false); saveDesc.setEnabled(false); display(result); } }); }
public void onSuccess(final com.google.gerrit.client.admin.AccountGroupDetail result) { enableForm(true); saveName.setEnabled(false); saveOwner.setEnabled(false); saveDesc.setEnabled(false); display(result); }
@java.lang.Override public void onLoad() { if ((tabs) == null) { initUI(); } super.onLoad(); tabs.selectTab(tabTokens.indexOf(initialTabToken)); Util.PROJECT_SVC.projectDetail(projectId, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.admin.ProjectDetail>() { public void onSuccess(final com.google.gerrit.client.admin.ProjectDetail result) { display(result); } }); }
@java.lang.Override public void onLoad() { if ((ownerId) == null) { ownerId = com.google.gerrit.client.rpc.Common.getAccountId(); } if ((table) == null) { table = new com.google.gerrit.client.changes.ChangeTable(); byOwner = new com.google.gerrit.client.changes.ChangeTable.Section(""); forReview = new com.google.gerrit.client.changes.ChangeTable.Section(""); closed = new com.google.gerrit.client.changes.ChangeTable.Section(""); table.addSection(byOwner); table.addSection(forReview); table.addSection(closed); add(table); } table.setSavePointerId(com.google.gerrit.client.Link.toAccountDashboard(ownerId)); super.onLoad(); Util.LIST_SVC.forAccount(ownerId, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.data.AccountDashboardInfo>() { public void onSuccess(final com.google.gerrit.client.data.AccountDashboardInfo r) { if (isAttached()) { display(r); } } }); }
public void onSuccess(final com.google.gerrit.client.data.AccountDashboardInfo r) { if (isAttached()) { display(r); } }

@java.lang.Override public java.lang.Object getScreenCacheToken() { return anchorPrefix; }
public void onSuccess(final com.google.gerrit.client.data.UnifiedPatchDetail r) { if (isAttached()) { display(r); } }
@java.lang.Override public void onLoad() { if ((diffTable) == null) { initUI(); } super.onLoad(); PatchUtil.DETAIL_SVC.unifiedPatchDetail(patchId, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.data.UnifiedPatchDetail>() { public void onSuccess(final com.google.gerrit.client.data.UnifiedPatchDetail r) { if (isAttached()) { display(r); } } }); }
public void onSuccess(final com.google.gerrit.client.reviewdb.Account result) { if (isAttached()) { display(result); } }
@java.lang.Override public void onLoad() { super.onLoad(); Util.LIST_SVC.myDraftChanges(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.data.SingleListChangeInfo>() { public void onSuccess(final com.google.gerrit.client.data.SingleListChangeInfo result) { display(result); } }); }
@java.lang.Override public void onLoad() { super.onLoad(); Util.LIST_SVC.myStarredChanges(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.data.SingleListChangeInfo>() { public void onSuccess(final com.google.gerrit.client.data.SingleListChangeInfo result) { display(result); } }); }
public void onSuccess(final com.google.gwtjsonrpc.client.VoidResult result) { com.google.gwt.user.client.History.newItem(Link.SETTINGS_CONTACT, true); }
public void refresh() { Util.DETAIL_SVC.changeDetail(changeId, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.data.ChangeDetail>() { public void onSuccess(final com.google.gerrit.client.data.ChangeDetail r) { if (isAttached()) { setStarred(r.isStarred()); display(r); } } }); }
public void onSuccess(final com.google.gerrit.client.data.ChangeDetail r) { if (isAttached()) { setStarred(r.isStarred()); display(r); } }


public void onSuccess(final java.util.List<com.google.gerrit.client.reviewdb.AccountGroup> result) { if (isAttached()) { groups.display(result); groups.finishDisplay(true); } }
@java.lang.Override public void onLoad() { if ((groups) == null) { initUI(); } Util.GROUP_SVC.ownedGroups(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.client.reviewdb.AccountGroup>>() { public void onSuccess(final java.util.List<com.google.gerrit.client.reviewdb.AccountGroup> result) { if (isAttached()) { groups.display(result); groups.finishDisplay(true); } } }); }
@java.lang.Override public void onLoad() { if ((sbsTable) == null) { initUI(); } super.onLoad(); PatchUtil.DETAIL_SVC.sideBySidePatchDetail(patchId, null, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.data.SideBySidePatchDetail>() { public void onSuccess(final com.google.gerrit.client.data.SideBySidePatchDetail r) { if (isAttached()) { display(r); } } }); }
@java.lang.Override public void onLoad() { if ((info) == null) { initUI(); } super.onLoad(); display(com.google.gerrit.client.Gerrit.getUserAccount()); tabs.selectTab(tabTokens.indexOf(initialTabToken)); Util.ACCOUNT_SVC.myAccount(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.reviewdb.Account>() { public void onSuccess(final com.google.gerrit.client.reviewdb.Account result) { if (isAttached()) { display(result); } } }); }
public void onSuccess(final com.google.gerrit.client.data.SideBySidePatchDetail r) { if (isAttached()) { display(r); } }
public void onClick(final com.google.gwt.user.client.ui.Widget sender) { if ((send) == sender) { onSend(); } else if ((cancel) == sender) { com.google.gerrit.client.Gerrit.uncache(this); goChange(); } }
public void onSuccess(final com.google.gerrit.client.changes.PatchSetPublishDetail result) { send.setEnabled(true); display(result); }
public void onSuccess(final java.util.List<com.google.gerrit.client.reviewdb.Project> result) { if (isAttached()) { projects.display(result); projects.finishDisplay(true); } }
@java.lang.Override public void onLoad() { if ((projects) == null) { initUI(); } Util.PROJECT_SVC.ownedProjects(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.client.reviewdb.Project>>() { public void onSuccess(final java.util.List<com.google.gerrit.client.reviewdb.Project> result) { if (isAttached()) { projects.display(result); projects.finishDisplay(true); } } }); }
@java.lang.Override public void onLoad() { super.onLoad(); Util.ACCOUNT_SEC.validateEmail(magicToken, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.client.VoidResult result) { com.google.gwt.user.client.History.newItem(Link.SETTINGS_CONTACT, true); } }); }



private void setNew(com.google.gerrit.client.reviewdb.Change c, com.google.gerrit.client.reviewdb.ChangeMessage msg) { for (int attempts = 0; attempts < 10; attempts++) { c.setStatus(Change.Status.NEW); com.google.gerrit.server.ChangeUtil.updated(c); try { final com.google.gwtorm.client.Transaction txn = schema.beginTransaction(); schema.changes().update(java.util.Collections.singleton(c), txn); if (msg != null) { schema.changeMessages().insert(java.util.Collections.singleton(msg), txn); } txn.commit(); break; } catch (com.google.gwtorm.client.OrmException e) { try { c = schema.changes().get(c.getId()); if (c.getStatus().isClosed()) { break; } } catch (com.google.gwtorm.client.OrmException e2) { } } } }




static void fireOnCallStart() { for (final com.google.gwtjsonrpc.client.RpcStatusListener l : com.google.gwtjsonrpc.client.JsonUtil.listeners) { l.onCallStart(); } }



@java.lang.SuppressWarnings("fallthrough") public boolean execute() { final boolean attachedNow = isAttached(); if ((!(attached)) && attachedNow) { attached = true; } else if ((attached) && (!attachedNow)) { return false; } start = java.lang.System.currentTimeMillis(); switch (stage) { case 0 : if ((row) == 0) { table.appendHeader(nc); } while ((row) < (list.size())) { table.appendRow(nc, list.get(row)); if ((((++(row)) % 10) == 0) && (longRunning())) { updateMeter(); return true; } } table.resetHtml(nc); nc = null; stage = 1; row = 0; case 1 : while ((row) < (list.size())) { table.initializeRow(((row) + 1), list.get(row)); if ((((++(row)) % 50) == 0) && (longRunning())) { updateMeter(); return true; } } updateMeter(); showTable(); } return false; }
@java.lang.Override protected com.google.gerrit.client.ui.Screen createScreen() { return new com.google.gerrit.client.patches.PatchScreen.Unified(key, parentPatchTable()); }
@java.lang.Override protected com.google.gerrit.client.ui.Screen createScreen() { return new com.google.gerrit.client.patches.PatchScreen.SideBySide(key, parentPatchTable()); }


@java.lang.Override protected void onInitUI() { super.onInitUI(); final com.google.gerrit.client.reviewdb.Change.Id changeId = patchKey.getParentKey().getParentKey(); final java.lang.String path = patchKey.get(); java.lang.String fileName = path; final int last = fileName.lastIndexOf('/'); if (last >= 0) { fileName = fileName.substring((last + 1)); } setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName)); setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path)); historyTable = new com.google.gerrit.client.patches.HistoryTable(this); historyPanel = new com.google.gwt.user.client.ui.DisclosurePanel(PatchUtil.C.patchHistoryTitle()); historyPanel.setContent(historyTable); historyPanel.setOpen(false); historyPanel.setVisible(false); add(historyPanel); noDifference = new com.google.gwt.user.client.ui.Label(PatchUtil.C.noDifference()); noDifference.setStyleName("gerrit-PatchNoDifference"); noDifference.setVisible(false); contentTable = createContentTable(); contentTable.fileList = fileList; fileList = null; final com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.setStyleName("gerrit-SideBySideScreen-SideBySideTable"); fp.add(noDifference); fp.add(contentTable); add(fp); }


private void doSearch() { final java.lang.String query = searchBox.getText().trim(); if (((query.length()) == 0) || (Gerrit.C.searchHint().equals(query))) { return; } searchBox.setFocus(false); if (query.matches("^[1-9][0-9]*$")) { final com.google.gerrit.client.reviewdb.Change.Id ck = Change.Id.parse(query); com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Link.toChange(ck), new com.google.gerrit.client.changes.ChangeScreen(ck)); } else { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Link.toChangeQuery(query), true); } }





@java.lang.Override protected void onInitUI() { super.onInitUI(); final com.google.gerrit.client.reviewdb.Change.Id changeId = patchKey.getParentKey().getParentKey(); final java.lang.String path = patchKey.get(); java.lang.String fileName = path; final int last = fileName.lastIndexOf('/'); if (last >= 0) { fileName = fileName.substring((last + 1)); } setWindowTitle(PatchUtil.M.patchWindowTitle(changeId.get(), fileName)); setPageTitle(PatchUtil.M.patchPageTitle(changeId.get(), path)); historyTable = new com.google.gerrit.client.patches.HistoryTable(this); historyPanel = new com.google.gwt.user.client.ui.DisclosurePanel(PatchUtil.C.patchHistoryTitle()); historyPanel.setContent(historyTable); historyPanel.setOpen(false); historyPanel.setVisible(false); add(historyPanel); initDisplayControls(); noDifference = new com.google.gwt.user.client.ui.Label(PatchUtil.C.noDifference()); noDifference.setStyleName("gerrit-PatchNoDifference"); noDifference.setVisible(false); contentTable = createContentTable(); contentTable.fileList = fileList; add(createNextPrevLinks()); contentPanel = new com.google.gwt.user.client.ui.FlowPanel(); contentPanel.setStyleName("gerrit-SideBySideScreen-SideBySideTable"); contentPanel.add(noDifference); contentPanel.add(contentTable); add(contentPanel); add(createNextPrevLinks()); }

public com.google.gerrit.client.ui.DirectScreenLink getNextPatchLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType) { if (index < ((patchList.size()) - 1)) return createLink((index + 1), patchType, null, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.nextPatchLinkIcon())); return null; }
public com.google.gerrit.client.ui.DirectScreenLink getPreviousPatchLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType) { if (0 < index) return createLink((index - 1), patchType, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.prevPatchLinkIcon()), null); return null; }
private com.google.gwt.user.client.ui.Widget createNextPrevLinks() { final com.google.gwt.user.client.ui.Grid table = new com.google.gwt.user.client.ui.Grid(1, 3); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); table.setStyleName("gerrit-SideBySideScreen-LinkTable"); fmt.setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_LEFT); fmt.setHorizontalAlignment(0, 1, HasHorizontalAlignment.ALIGN_CENTER); fmt.setHorizontalAlignment(0, 2, HasHorizontalAlignment.ALIGN_RIGHT); if ((fileList) != null) { table.setWidget(0, 0, fileList.getPreviousPatchLink(patchIndex, getPatchScreenType())); table.setWidget(0, 2, fileList.getNextPatchLink(patchIndex, getPatchScreenType())); } final com.google.gerrit.client.ui.ChangeLink up = new com.google.gerrit.client.ui.ChangeLink("", patchKey.getParentKey().getParentKey()); com.google.gwtexpui.safehtml.client.SafeHtml.set(up, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.upToChangeIconLink())); table.setWidget(0, 1, up); return table; }
private void populate(final com.google.gwt.user.client.ui.Grid lists) { final java.util.Iterator<com.google.gwtexpui.globalkey.client.KeyCommandSet> setitr = GlobalKey.active.all.getSets().iterator(); int[] end = new int[5]; int column = 0; while (setitr.hasNext()) { final com.google.gwtexpui.globalkey.client.KeyCommandSet set = setitr.next(); int row = end[column]; row = formatGroup(lists, row, column, set); end[column] = row; if (column == 0) { column = 4; } else { column = 0; } } }
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { int row = suggestRow; int[] spans = new int[column + 1]; OUTER : while (row < (table.getRowCount())) { int col = 0; for (int cell = 0; cell < (table.getCellCount(row)); cell++) { while ((col < column) && (0 < (spans[col]))) { (spans[(col++)])--; } spans[col] = table.getFlexCellFormatter().getRowSpan(row, cell); if (col == column) { if ((table.getWidget(row, cell)) instanceof com.google.gerrit.client.ui.ComplexDisclosurePanel) { row++; } else { break OUTER; } } } } if (((row < (table.getRowCount())) && (column < (table.getCellCount(row)))) && ((table.getWidget(row, column)) instanceof com.google.gerrit.client.patches.CommentEditorPanel)) { ((com.google.gerrit.client.patches.CommentEditorPanel) (table.getWidget(row, column))).setFocus(true); return; } if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(); return; } final com.google.gerrit.client.reviewdb.Patch.Key parentKey; final short side; switch (file) { case 0 : if ((idSideA) == null) { parentKey = new com.google.gerrit.client.reviewdb.Patch.Key(idSideB, patchKey.get()); side = ((short) (0)); } else { parentKey = new com.google.gerrit.client.reviewdb.Patch.Key(idSideA, patchKey.get()); side = ((short) (1)); } break; case 1 : parentKey = new com.google.gerrit.client.reviewdb.Patch.Key(idSideB, patchKey.get()); side = ((short) (1)); break; default : throw new java.lang.RuntimeException(("unexpected file id " + file)); } final com.google.gerrit.client.reviewdb.PatchLineComment newComment = new com.google.gerrit.client.reviewdb.PatchLineComment(new com.google.gerrit.client.reviewdb.PatchLineComment.Key(parentKey, null), line, com.google.gerrit.client.Gerrit.getUserAccount().getId()); newComment.setSide(side); newComment.setMessage(""); final com.google.gerrit.client.patches.CommentEditorPanel ed = new com.google.gerrit.client.patches.CommentEditorPanel(newComment); boolean needInsert = true; if (row < (table.getRowCount())) { for (int cell = 0; cell < (table.getCellCount(row)); cell++) { final com.google.gwt.user.client.ui.Widget w = table.getWidget(row, cell); if ((w instanceof com.google.gerrit.client.patches.CommentEditorPanel) || (w instanceof com.google.gerrit.client.ui.ComplexDisclosurePanel)) { needInsert = false; break; } } } if (needInsert) { table.insertRow(row); table.getCellFormatter().setStyleName(row, 0, com.google.gerrit.client.patches.S_ICON_CELL); } table.setWidget(row, column, ed); table.getFlexCellFormatter().setStyleName(row, column, "Comment"); int span = 1; for (int r = row + 1; r < (table.getRowCount()); r++) { boolean hasComment = false; for (int c = 0; c < (table.getCellCount(r)); c++) { final com.google.gwt.user.client.ui.Widget w = table.getWidget(r, c); if ((w instanceof com.google.gerrit.client.ui.ComplexDisclosurePanel) || (w instanceof com.google.gerrit.client.patches.CommentEditorPanel)) { hasComment = true; break; } } if (hasComment) { table.removeCell(r, column); span++; } else { break; } } if (span > 1) { table.getFlexCellFormatter().setRowSpan(row, column, span); } for (int r = row - 1; r > 0; r--) { if ((getRowItem(r)) instanceof com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList) { continue; } else if ((getRowItem(r)) != null) { movePointerTo(r); break; } } ed.setFocus(true); }


@java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((rpcSequence) == rpcseq) { if ((isNoDifferences(caught)) && (!isFirst)) { historyTable.enableAll(true); showPatch(false); } else { super.onFailure(caught); } } }
protected void refresh(final boolean isFirst) { final int rpcseq = ++(rpcSequence); script = null; comments = null; PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.data.PatchScript>() { public void onSuccess(final com.google.gerrit.client.data.PatchScript result) { if ((rpcSequence) == rpcseq) { script = result; onResult(); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((rpcSequence) == rpcseq) { if ((isNoDifferences(caught)) && (!isFirst)) { historyTable.enableAll(true); showPatch(false); } else { super.onFailure(caught); } } } private boolean isNoDifferences(final java.lang.Throwable caught) { if (caught instanceof com.google.gerrit.client.rpc.NoDifferencesException) { return true; } return (caught instanceof com.google.gwtjsonrpc.client.RemoteJsonException) && (caught.getMessage().equals(NoDifferencesException.MESSAGE)); } }); PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.patches.CommentDetail>() { public void onSuccess(final com.google.gerrit.client.patches.CommentDetail result) { if ((rpcSequence) == rpcseq) { comments = result; onResult(); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if ((!(isNoSuchEntity(caught))) && ((rpcSequence) == rpcseq)) { super.onFailure(caught); } } }); }


public com.google.gerrit.client.patches.CommentDetail run(final com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.client.rpc.BaseServiceImplementation.Failure, com.google.gwtorm.client.OrmException { validatePatchSetId(psa); validatePatchSetId(psb); me = com.google.gerrit.client.rpc.Common.getAccountId(); change = db.changes().get(changeId); patch = db.patches().get(patchKey); if ((((change) == null) || ((patch) == null)) || (!(canRead(change)))) { throw new com.google.gerrit.client.rpc.BaseServiceImplementation.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } final java.lang.String pn = patch.getFileName(); final com.google.gerrit.client.data.AccountInfoCacheFactory aic = new com.google.gerrit.client.data.AccountInfoCacheFactory(db); final com.google.gerrit.client.patches.CommentDetail r; r = new com.google.gerrit.client.patches.CommentDetail(psa, ((psb) != null ? psb : patchSetId)); for (com.google.gerrit.client.reviewdb.PatchLineComment p : db.patchComments().published(changeId, pn)) { if (r.include(p)) { aic.want(p.getAuthor()); } } if ((me) != null) { aic.want(me); for (com.google.gerrit.client.reviewdb.PatchLineComment p : db.patchComments().draft(changeId, pn, me)) { r.include(p); } } r.setHistory(db.patches().history(changeId, pn).toList()); r.setAccountInfoCache(aic.create()); return r; }

void appendRow(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, final com.google.gerrit.client.reviewdb.Patch p) { m.openTr(); m.openTd(); m.addStyleName(com.google.gerrit.client.changes.S_ICON_CELL); m.addStyleName("LeftMostCell"); m.nbsp(); m.closeTd(); m.openTd(); m.setStyleName("ChangeTypeCell"); m.append(p.getChangeType().getCode()); m.closeTd(); m.openTd(); m.addStyleName(com.google.gerrit.client.changes.S_DATA_CELL); m.addStyleName("FilePathCell"); m.closeTd(); m.openTd(); m.addStyleName(com.google.gerrit.client.changes.S_DATA_CELL); m.addStyleName("CommentCell"); appendCommentCount(m, p); m.closeTd(); switch (p.getPatchType()) { case UNIFIED : openlink(m, 2); m.closeTd(); break; case BINARY : { java.lang.String base = com.google.gwt.core.client.GWT.getHostPageBaseURL(); base += "cat/" + (com.google.gwtorm.client.KeyUtil.encode(p.getKey().toString())); switch (p.getChangeType()) { case DELETED : case MODIFIED : openlink(m, 1); m.openAnchor(); m.setAttribute("href", (base + "^1")); m.append(Util.C.patchTableDownloadPreImage()); closelink(m); break; default : emptycell(m, 1); break; } switch (p.getChangeType()) { case MODIFIED : case ADDED : openlink(m, 1); m.openAnchor(); m.setAttribute("href", (base + "^0")); m.append(Util.C.patchTableDownloadPostImage()); closelink(m); break; default : emptycell(m, 1); break; } break; } default : emptycell(m, 2); break; } openlink(m, 1); m.closeTd(); m.closeTr(); }


private void onResult() { if (((script) != null) && ((comments) != null)) { if ((comments.getHistory().size()) > 1) { historyTable.display(comments.getHistory()); historyPanel.setVisible(true); } else { historyPanel.setVisible(false); } contentTable.display(patchKey, idSideA, idSideB, script); contentTable.display(comments); contentTable.finishDisplay(); showPatch(true); script = null; comments = null; display(); } }



void appendHeader(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m) { m.openTr(); m.openTd(); m.addStyleName(com.google.gerrit.client.changes.S_ICON_HEADER); m.addStyleName("LeftMostCell"); m.nbsp(); m.closeTd(); m.openTd(); m.setStyleName(com.google.gerrit.client.changes.S_ICON_HEADER); m.nbsp(); m.closeTd(); m.openTd(); m.setStyleName(com.google.gerrit.client.changes.S_DATA_HEADER); m.append(Util.C.patchTableColumnName()); m.closeTd(); m.openTd(); m.setStyleName(com.google.gerrit.client.changes.S_DATA_HEADER); m.append(Util.C.patchTableColumnComments()); m.closeTd(); m.openTd(); m.setStyleName(com.google.gerrit.client.changes.S_DATA_HEADER); m.setAttribute("colspan", 3); m.append(Util.C.patchTableColumnDiff()); m.closeTd(); m.closeTr(); }
protected void refresh(final boolean isFirst) { final int rpcseq = ++(rpcSequence); script = null; comments = null; PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, scriptSettings, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.data.PatchScript>() { public void onSuccess(final com.google.gerrit.client.data.PatchScript result) { if ((rpcSequence) == rpcseq) { script = result; onResult(); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((rpcSequence) == rpcseq) { if ((isNoDifferences(caught)) && (!isFirst)) { historyTable.enableAll(true); showPatch(false); } else { super.onFailure(caught); } } } private boolean isNoDifferences(final java.lang.Throwable caught) { if (caught instanceof com.google.gerrit.client.rpc.NoDifferencesException) { return true; } return (caught instanceof com.google.gwtjsonrpc.client.RemoteJsonException) && (caught.getMessage().equals(NoDifferencesException.MESSAGE)); } }); PatchUtil.DETAIL_SVC.patchComments(patchKey, idSideA, idSideB, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.patches.CommentDetail>() { public void onSuccess(final com.google.gerrit.client.patches.CommentDetail result) { if ((rpcSequence) == rpcseq) { comments = result; onResult(); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if ((!(isNoSuchEntity(caught))) && ((rpcSequence) == rpcseq)) { super.onFailure(caught); } } }); }


private void createContext(final com.google.gwt.user.client.ui.Grid parent, final int row, final int col) { parent.resizeRows((row + 1)); final com.google.gwt.user.client.ui.CheckBox cb = new com.google.gwt.user.client.ui.CheckBox(PatchUtil.C.showFullFiles()); cb.addValueChangeHandler(new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { if (event.getValue()) { scriptSettings.setContext(com.google.gerrit.client.patches.WHOLE_FILE_CONTEXT); } else { initContextLines(); } refresh(false); } }); parent.setWidget(row, (col + 1), cb); }



private void setReviewedByCurrentUser(boolean reviewed) { PatchUtil.DETAIL_SVC.setReviewedByCurrentUser(patchKey, reviewed, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult>() { @java.lang.Override public void onFailure(java.lang.Throwable arg0) { } @java.lang.Override public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { } }); }



public void patchSetPublishDetail(final com.google.gerrit.client.reviewdb.PatchSet.Id id, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.PatchSetPublishDetail> callback) { run(callback, new com.google.gerrit.server.Action<com.google.gerrit.client.changes.PatchSetPublishDetail>() { public com.google.gerrit.client.changes.PatchSetPublishDetail run(final com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.PatchSet ps = db.patchSets().get(id); final com.google.gerrit.client.reviewdb.Change change = db.changes().get(ps.getId().getParentKey()); if ((ps == null) || (change == null)) { throw new com.google.gerrit.server.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } assertCanRead(change); final com.google.gerrit.client.changes.PatchSetPublishDetail d = new com.google.gerrit.client.changes.PatchSetPublishDetail(); d.load(db, change, id); return d; } }); }
public void registerEmail(final java.lang.String address, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> cb) { final org.spearce.jgit.lib.PersonIdent gi = server.newGerritPersonIdent(); final javax.servlet.http.HttpServletRequest req = com.google.gerrit.server.GerritJsonServlet.getCurrentCall().getHttpServletRequest(); try { final com.google.gerrit.server.mail.RegisterNewEmailSender sender; sender = new com.google.gerrit.server.mail.RegisterNewEmailSender(server, emailSender, address, req); sender.send(); cb.onSuccess(VoidResult.INSTANCE); } catch (com.google.gerrit.server.mail.EmailException e) { log.error(("Cannot send email verification message to " + address), e); cb.onFailure(e); } catch (java.lang.RuntimeException e) { log.error(("Cannot send email verification message to " + address), e); cb.onFailure(e); } }
public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.patch.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult r; r = db.run(new com.google.gwtorm.client.OrmRunnable<com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult, com.google.gerrit.client.reviewdb.ReviewDb>() { public com.google.gerrit.server.patch.PatchDetailServiceImpl.PublishResult run(com.google.gerrit.client.reviewdb.ReviewDb db, com.google.gwtorm.client.Transaction txn, boolean retry) throws com.google.gwtorm.client.OrmException { return doPublishComments(psid, message, approvals, db, txn); } }); try { final com.google.gerrit.server.mail.CommentSender cm = new com.google.gerrit.server.mail.CommentSender(server, r.change); cm.setFrom(com.google.gerrit.client.rpc.Common.getAccountId()); cm.setPatchSet(r.patchSet, r.info); cm.setChangeMessage(r.message); cm.setPatchLineComments(r.comments); cm.setReviewDb(db); cm.setHttpServletRequest(com.google.gerrit.server.GerritJsonServlet.getCurrentCall().getHttpServletRequest()); cm.send(); } catch (EmailException e) { log.error(("Cannot send comments by email for patch set " + psid), e); throw new com.google.gerrit.server.patch.Failure(e); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
protected void init() { smtpFromAddress = computeFrom(); if (((changeMessage) != null) && ((changeMessage.getWrittenOn()) != null)) { setHeader("Date", new java.util.Date(changeMessage.getWrittenOn().getTime())); } else { setHeader("Date", new java.util.Date()); } headers.put("From", new com.google.gerrit.server.mail.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.EmailHeader.AddressList()); if ((change) != null) { setChangeSubjectHeader(); } setHeader("Message-ID", ""); setHeader("MIME-Version", "1.0"); setHeader("Content-Type", "text/plain; charset=UTF-8"); setHeader("Content-Disposition", "inline"); setHeader("User-Agent", ("Gerrit/" + (com.google.gerrit.pgm.Version.getVersion()))); setHeader("X-Gerrit-MessageType", messageClass); if ((change) != null) { setHeader("X-Gerrit-ChangeId", ("" + (change.getChangeId()))); setListIdHeader(); setChangeUrlHeader(); setCommitIdHeader(); } body = new java.lang.StringBuilder(); inFooter = false; if (((change) != null) && ((db) != null)) { if ((patchSet) == null) { try { patchSet = db.patchSets().get(change.currentPatchSetId()); } catch (com.google.gwtorm.client.OrmException err) { patchSet = null; } } if (((patchSet) != null) && ((patchSetInfo) == null)) { try { patchSetInfo = db.patchSetInfo().get(patchSet.getId()); } catch (com.google.gwtorm.client.OrmException err) { patchSetInfo = null; } } } }
public com.google.gerrit.server.ssh.Command createCommand(final java.lang.String commandLine) { final int sp1 = commandLine.indexOf(' '); java.lang.String cmd; java.lang.String args; if (0 < sp1) { cmd = commandLine.substring(0, sp1); args = commandLine.substring((sp1 + 1)); } else { cmd = commandLine; args = ""; } if (("git".equals(cmd)) || ("gerrit".equals(cmd))) { cmd += "-"; final int sp2 = args.indexOf(' '); if (0 < sp2) { cmd += args.substring(0, sp2); args = args.substring((sp2 + 1)); } else { cmd += args; args = ""; } } final com.google.gerrit.server.ssh.Command c = create(cmd); if (c instanceof com.google.gerrit.server.ssh.AbstractCommand) { ((com.google.gerrit.server.ssh.AbstractCommand) (c)).setCommandLine(cmd, args); } return c; }






@java.lang.Override protected void applyDataRowStyle(final int row) { super.applyDataRowStyle(row); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_STAR, com.google.gerrit.client.changes.S_ICON_CELL); for (int i = com.google.gerrit.client.changes.ChangeTable.C_ID; i < (com.google.gerrit.client.changes.ChangeTable.COLUMNS); i++) { fmt.addStyleName(row, i, com.google.gerrit.client.changes.S_DATA_CELL); } fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_ID, com.google.gerrit.client.changes.ChangeTable.S_C_ID); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_SUBJECT, com.google.gerrit.client.changes.ChangeTable.S_C_SUBJECT); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_PROJECT, com.google.gerrit.client.changes.ChangeTable.S_C_PROJECT); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_BRANCH, com.google.gerrit.client.changes.ChangeTable.S_C_PROJECT); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable.C_LAST_UPDATE, com.google.gerrit.client.changes.ChangeTable.S_C_LAST_UPDATE); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); table = new com.google.gerrit.client.changes.ChangeTable(); byOwner = new com.google.gerrit.client.changes.ChangeTable.Section(""); forReview = new com.google.gerrit.client.changes.ChangeTable.Section(""); closed = new com.google.gerrit.client.changes.ChangeTable.Section(""); table.addSection(byOwner); table.addSection(forReview); table.addSection(closed); add(table); table.setSavePointerId(com.google.gerrit.client.Link.toAccountDashboard(ownerId)); }

public void display(final java.util.List<com.google.gerrit.client.data.ChangeInfo> changeList) { final int sz = (changeList != null) ? changeList.size() : 0; final boolean hadData = (rows) > 0; if (hadData) { while (sz < (rows)) { parent.removeRow(dataBegin); (rows)--; } } if (sz == 0) { if (hadData) { parent.insertNoneRow(dataBegin); } } else { if (!hadData) { parent.removeRow(dataBegin); } while ((rows) < sz) { parent.insertChangeRow(((dataBegin) + (rows))); (rows)++; } for (int i = 0; i < sz; i++) { parent.populateChangeRow(((dataBegin) + i), changeList.get(i)); } } }




@java.lang.Override public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.client.reviewdb.ReviewDb db) throws com.google.gerrit.server.rpc.account.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account me = db.accounts().get(getAccountId()); if (me == null) { throw new com.google.gerrit.server.rpc.account.Failure(new com.google.gerrit.client.rpc.NoSuchEntityException()); } final com.google.gerrit.client.reviewdb.Account other; if (newName != null) { other = db.accounts().bySshUserName(newName); } else { other = null; } if (other != null) { if (other.getId().equals(me.getId())) { return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } else { throw new com.google.gerrit.server.rpc.account.Failure(new com.google.gerrit.client.rpc.NameAlreadyUsedException()); } } final java.lang.String oldName = me.getSshUserName(); me.setSshUserName(newName); db.accounts().update(java.util.Collections.singleton(me)); uncacheSshKeys(oldName); uncacheSshKeys(newName); accountCache.evict(me.getId()); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
void doChangeUserName() { if (!(canEditSshUserName())) { return; } java.lang.String newName = userNameTxt.getText(); if ("".equals(newName)) { newName = null; } userNameTxt.setEnabled(false); changeUserName.setEnabled(false); final java.lang.String newSshUserName = newName; Util.ACCOUNT_SEC.changeSshUserName(newSshUserName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.client.VoidResult result) { userNameTxt.setEnabled(true); changeUserName.setEnabled(false); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.Gerrit.getUserAccount().setSshUserName(newSshUserName); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { userNameTxt.setEnabled(true); changeUserName.setEnabled(true); super.onFailure(caught); } }); }
@java.lang.Override public void onFailure(final java.lang.Throwable caught) { userNameTxt.setEnabled(true); changeUserName.setEnabled(true); super.onFailure(caught); }
public static void main(final java.lang.String[] argv) throws com.google.gwtjsonrpc.server.XsrfException, com.google.gwtorm.client.OrmException, java.net.SocketException { com.google.gerrit.server.ssh.GerritSshDaemon.startSshd(); }





public static java.lang.String toProjectOpen(final com.google.gerrit.client.reviewdb.Project.NameKey proj) { return ("project,open," + (proj.toString())) + ",n,z"; }

@java.lang.Override public java.lang.String toString() { return atts.get("dn"); }
public void display(final com.google.gerrit.client.reviewdb.Change chg, final com.google.gerrit.client.reviewdb.PatchSetInfo info, final com.google.gerrit.client.data.AccountInfoCache acc) { infoBlock.display(chg, acc); com.google.gwtexpui.safehtml.client.SafeHtml msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(info.getMessage()); msg = msg.linkify(); msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openElement("p").append(msg).closeElement("p"); msg = msg.replaceAll("\n\n", "</p><p>"); msg = msg.replaceAll("\n", "<br />"); com.google.gwtexpui.safehtml.client.SafeHtml.set(description, msg); }
protected void setMessageText(java.lang.String message) { if (message == null) { message = ""; } else { message = message.trim(); } messageSummary.setText(com.google.gerrit.client.ui.CommentPanel.summarize(message)); com.google.gwtexpui.safehtml.client.SafeHtml.set(messageText, new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(message).wikify()); }
void schedule(final com.google.gerrit.client.reviewdb.Project.NameKey project, final java.lang.String ref, final org.eclipse.jgit.transport.URIish uri) { synchronized(pending) { com.google.gerrit.git.PushOp e = pending.get(uri); if (e == null) { e = opFactory.create(project.get(), uri); pool.schedule(e, delay, java.util.concurrent.TimeUnit.SECONDS); pending.put(uri, e); } e.addRef(ref); } }




private synchronized void init() { if ((sysInjector) == null) { try { dbInjector = com.google.inject.Guice.createInjector(com.google.gerrit.httpd.PRODUCTION, new com.google.gerrit.server.config.DatabaseModule()); } catch (com.google.inject.CreationException ce) { final com.google.inject.spi.Message first = ce.getErrorMessages().iterator().next(); final java.lang.StringBuilder buf = new java.lang.StringBuilder(); buf.append(first.getMessage()); java.lang.Throwable why = first.getCause(); while (why != null) { buf.append("\n caused by "); buf.append(why.toString()); why = why.getCause(); } if ((first.getCause()) != null) { buf.append("\n"); buf.append("\nResolve above errors before continuing."); buf.append("\nComplete stack trace follows:"); } com.google.gerrit.httpd.WebAppInitializer.log.error(buf.toString(), first.getCause()); throw new com.google.inject.CreationException(java.util.Collections.singleton(first)); } cfgInjector = dbInjector.createChildInjector(new com.google.gerrit.server.config.GerritConfigModule()); sysInjector = createSysInjector(); sshInjector = createSshInjector(); webInjector = createWebInjector(); sysInjector.getInstance(com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(javax.servlet.http.HttpServletRequest.class)); } }
@java.lang.Override public int run() throws java.lang.Exception { if ((httpd) == null) { httpd = !(slave); } if ((!(httpd)) && (!(sshd))) { throw die("No services enabled, nothing to do"); } if ((slave) && (httpd)) { throw die("Cannot combine --slave and --enable-httpd"); } if ((httpd) && (!(sshd))) { throw die("--enable-httpd currently requires --enable-sshd"); } dbInjector = com.google.inject.Guice.createInjector(com.google.gerrit.pgm.PRODUCTION, new com.google.gerrit.server.config.DatabaseModule()); cfgInjector = dbInjector.createChildInjector(new com.google.gerrit.server.config.GerritConfigModule()); sysInjector = createSysInjector(); if (sshd) { initSshd(); } if (httpd) { initHttpd(); } final com.google.inject.Injector[] all = new com.google.inject.Injector[]{ dbInjector, cfgInjector, sysInjector, sshInjector, webInjector, httpdInjector }; try { com.google.gerrit.server.Lifecycle.start(all); if (httpd) { httpdInjector.getInstance(com.google.gerrit.pgm.http.jetty.JettyServer.class).join(); return 0; } else if (sshd) { return never(); } else { throw die("No services enabled"); } } finally { com.google.gerrit.server.Lifecycle.stop(all); } }



private synchronized void init() { if ((sysInjector) == null) { try { dbInjector = com.google.inject.Guice.createInjector(com.google.gerrit.httpd.PRODUCTION, new com.google.gerrit.server.config.DatabaseModule()); } catch (com.google.inject.CreationException ce) { final com.google.inject.spi.Message first = ce.getErrorMessages().iterator().next(); final java.lang.StringBuilder buf = new java.lang.StringBuilder(); buf.append(first.getMessage()); java.lang.Throwable why = first.getCause(); while (why != null) { buf.append("\n caused by "); buf.append(why.toString()); why = why.getCause(); } if ((first.getCause()) != null) { buf.append("\n"); buf.append("\nResolve above errors before continuing."); buf.append("\nComplete stack trace follows:"); } com.google.gerrit.httpd.WebAppInitializer.log.error(buf.toString(), first.getCause()); throw new com.google.inject.CreationException(java.util.Collections.singleton(first)); } sysInjector = com.google.gerrit.server.config.GerritGlobalModule.createInjector(dbInjector, new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); sshInjector = createSshInjector(); webInjector = createWebInjector(); sysInjector.getInstance(com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(javax.servlet.http.HttpServletRequest.class)); } }








@java.lang.Override public void contextDestroyed(final javax.servlet.ServletContextEvent event) { try { if ((sshInjector) != null) { sshInjector.getInstance(com.google.gerrit.sshd.SshDaemon.class).stop(); } } catch (com.google.inject.ConfigurationException e) { } catch (com.google.inject.ProvisionException e) { } try { if ((sysInjector) != null) { sysInjector.getInstance(com.google.gerrit.server.git.WorkQueue.class).shutdown(); } } catch (com.google.inject.ConfigurationException e) { } catch (com.google.inject.ProvisionException e) { } try { if ((sysInjector) != null) { sysInjector.getInstance(com.google.gerrit.server.cache.CachePool.class).stop(); } } catch (com.google.inject.ConfigurationException e) { } catch (com.google.inject.ProvisionException e) { } try { if ((dbInjector) != null) { closeDataSource(dbInjector.getInstance(DatabaseModule.DS)); } } catch (com.google.inject.ConfigurationException ce) { } catch (com.google.inject.ProvisionException ce) { } super.contextDestroyed(event); }
private com.google.inject.Injector createSshInjector() { return sysInjector.createChildInjector(new com.google.gerrit.sshd.SshModule(), new com.google.gerrit.sshd.commands.MasterCommandModule()); }

@java.lang.Override public int run() throws java.lang.Exception { com.google.inject.Injector sysInjector = com.google.gerrit.server.config.GerritGlobalModule.createInjector(); com.google.inject.Injector sshInjector = createSshInjector(sysInjector); sysInjector.getInstance(com.google.gerrit.server.cache.CachePool.class).start(); sshInjector.getInstance(com.google.gerrit.sshd.SshDaemon.class).start(); return never(); }
private com.google.inject.Injector createSshInjector(final com.google.inject.Injector sysInjector) { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.sshd.SshModule()); if (slave) { modules.add(new com.google.gerrit.sshd.commands.SlaveCommandModule()); } else { modules.add(new com.google.gerrit.sshd.commands.MasterCommandModule()); } return sysInjector.createChildInjector(modules); }
public void shutdown() { for (final com.google.gerrit.server.git.WorkQueue.Executor p : queues) { p.shutdown(); boolean isTerminated; do { try { isTerminated = p.awaitTermination(10, java.util.concurrent.TimeUnit.SECONDS); } catch (java.lang.InterruptedException ie) { isTerminated = false; } } while (!isTerminated ); } queues.clear(); }
@java.lang.Override protected void configure() { bindScope(com.google.inject.servlet.SessionScoped.class, SshScopes.SESSION); bindScope(com.google.inject.servlet.RequestScoped.class, SshScopes.REQUEST); configureSessionScope(); configureRequestScope(); configureCmdLineParser(); install(com.google.gerrit.sshd.SshKeyCacheImpl.module()); bind(com.google.gerrit.server.ssh.SshInfo.class).to(com.google.gerrit.sshd.SshDaemon.class).in(com.google.gerrit.sshd.SINGLETON); factory(DispatchCommand.Factory.class); bind(com.google.gerrit.sshd.DispatchCommandProvider.class).annotatedWith(Commands.CMD_ROOT).toInstance(new com.google.gerrit.sshd.DispatchCommandProvider(com.google.gerrit.sshd.SshModule.NAME, Commands.CMD_ROOT)); bind(com.google.gerrit.sshd.CommandFactoryProvider.class); bind(org.apache.sshd.server.CommandFactory.class).toProvider(com.google.gerrit.sshd.CommandFactoryProvider.class); bind(org.apache.sshd.server.PublickeyAuthenticator.class).to(com.google.gerrit.sshd.DatabasePubKeyAuth.class); bind(org.apache.sshd.common.KeyPairProvider.class).toProvider(com.google.gerrit.sshd.HostKeyProvider.class).in(com.google.gerrit.sshd.SINGLETON); install(new com.google.gerrit.sshd.commands.DefaultCommandModule()); }
@java.lang.Override public void contextInitialized(final javax.servlet.ServletContextEvent event) { super.contextInitialized(event); init(); try { sysInjector.getInstance(com.google.gerrit.server.cache.CachePool.class).start(); } catch (com.google.inject.ConfigurationException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to start CachePool", e); } catch (com.google.inject.ProvisionException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to start CachePool", e); } try { sysInjector.getInstance(PushAllProjectsOp.Factory.class).create(null).start(30, java.util.concurrent.TimeUnit.SECONDS); } catch (com.google.inject.ConfigurationException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to restart replication queue", e); } catch (com.google.inject.ProvisionException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to restart replication queue", e); } try { sysInjector.getInstance(ReloadSubmitQueueOp.Factory.class).create().start(15, java.util.concurrent.TimeUnit.SECONDS); } catch (com.google.inject.ConfigurationException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to restart merge queue", e); } catch (com.google.inject.ProvisionException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to restart merge queue", e); } try { sshInjector.getInstance(com.google.gerrit.sshd.SshDaemon.class).start(); } catch (com.google.inject.ConfigurationException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to start SSHD", e); } catch (com.google.inject.ProvisionException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to start SSHD", e); } catch (java.io.IOException e) { com.google.gerrit.httpd.WebAppInitializer.log.error("Unable to start SSHD", e); } }















public void update() throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.SchemaVersion version = getSchemaVersion(db); if (version == null) { creator.create(db); } else { updateSystemConfig(db); } } finally { db.close(); } }



public java.lang.String toBranch(final com.google.gerrit.reviewdb.Branch.NameKey branch) { final java.lang.StringBuilder r = new java.lang.StringBuilder(); com.google.gerrit.common.data.GitwebLink.p(r, branch.getParentKey()); com.google.gerrit.common.data.GitwebLink.h(r, branch); com.google.gerrit.common.data.GitwebLink.a(r, "shortlog"); return (baseUrl) + r; }

public java.lang.String toProject(final com.google.gerrit.reviewdb.Project.NameKey project) { final java.lang.StringBuilder r = new java.lang.StringBuilder(); com.google.gerrit.common.data.GitwebLink.p(r, project); com.google.gerrit.common.data.GitwebLink.a(r, "summary"); return (baseUrl) + r; }
public java.lang.String toRevision(final com.google.gerrit.reviewdb.Project.NameKey project, final com.google.gerrit.reviewdb.PatchSet ps) { final java.lang.StringBuilder r = new java.lang.StringBuilder(); com.google.gerrit.common.data.GitwebLink.p(r, project); com.google.gerrit.common.data.GitwebLink.a(r, "commit"); com.google.gerrit.common.data.GitwebLink.h(r, ps); return (baseUrl) + r; }
@java.lang.Override protected void setUp() throws java.lang.Exception { super.setUp(); idA = org.eclipse.jgit.lib.ObjectId.fromString("df84c2f4f7ce7e0b25cdeac84b8870bcff319885"); name = new com.google.gerrit.reviewdb.Project.NameKey("test"); realDb = createBareRepository(); mockDb = createStrictMock(org.eclipse.jgit.lib.Repository.class); pc = createStrictMock(com.google.gerrit.server.project.ProjectControl.class); pcf = createStrictMock(ProjectControl.Factory.class); grm = createStrictMock(com.google.gerrit.server.git.GitRepositoryManager.class); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(init.ui); bind(com.google.gerrit.pgm.init.InitFlags.class).toInstance(init.flags); bind(com.google.gerrit.server.git.GitRepositoryManager.class).to(com.google.gerrit.server.git.LocalDiskRepositoryManager.class); bind(com.google.gerrit.server.git.GitProjectImporter.class); }
private com.google.inject.Injector createSysInjector(final com.google.gerrit.pgm.Init.SiteInit init) { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(init.ui); bind(com.google.gerrit.pgm.init.InitFlags.class).toInstance(init.flags); bind(com.google.gerrit.server.git.GitRepositoryManager.class).to(com.google.gerrit.server.git.LocalDiskRepositoryManager.class); bind(com.google.gerrit.server.git.GitProjectImporter.class); } }); return createDbInjector(com.google.gerrit.pgm.SINGLE_USER).createChildInjector(modules); }
private void sendMergedEmail(final com.google.gerrit.sshd.commands.Receive.ReplaceResult result) { if ((result != null) && ((result.mergedIntoRef) != null)) { try { final com.google.gerrit.server.mail.MergedSender cm = mergedSenderFactory.create(result.change); cm.setFrom(currentUser.getAccountId()); cm.setReviewDb(db); cm.setPatchSet(result.patchSet, result.info); cm.setDest(new com.google.gerrit.reviewdb.Branch.NameKey(project.getNameKey(), result.mergedIntoRef)); cm.send(); } catch (com.google.gerrit.server.mail.EmailException e) { final com.google.gerrit.reviewdb.PatchSet.Id psi = result.patchSet.getId(); com.google.gerrit.sshd.commands.Receive.log.error(("Cannot send email for submitted patch set " + psi), e); } } }



private com.google.gerrit.server.account.AccountState lookup(final com.google.gerrit.reviewdb.Account.Id who) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.Account account = db.accounts().get(who); if (account == null) { return missingAccount(who); } final java.util.Collection<com.google.gerrit.reviewdb.AccountExternalId> externalIds = java.util.Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> internalGroups = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id>(); for (com.google.gerrit.reviewdb.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.AccountGroup group = groupCache.get(groupId); if ((group != null) && ((group.getType()) == (AccountGroup.Type.INTERNAL))) { internalGroups.add(groupId); } } if (internalGroups.isEmpty()) { internalGroups = registered; } else { internalGroups.addAll(registered); internalGroups = java.util.Collections.unmodifiableSet(internalGroups); } return new com.google.gerrit.server.account.AccountState(account, internalGroups, externalIds); } finally { db.close(); } }

public void evict(java.lang.String username) { self.remove(username); }


private void appendHeader(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m) { m.openTr(); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().iconCell()); m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader()); m.closeTd(); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader()); m.addStyleName(Gerrit.RESOURCES.css().lineNumber()); m.closeTd(); m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader()); m.setAttribute("width", "50%"); m.append(PatchUtil.C.patchHeaderOld()); m.closeTd(); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().fileColumnHeader()); m.addStyleName(Gerrit.RESOURCES.css().lineNumber()); m.closeTd(); m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().fileColumnHeader()); m.setAttribute("width", "50%"); m.append(PatchUtil.C.patchHeaderNew()); m.closeTd(); m.closeTr(); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { createReplyEditor(this); }
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { createCommentEditor(suggestRow, column, line, file, null); }
private java.util.Collection<com.google.gerrit.reviewdb.RefRight> getLocalRights() { return filter(projectControl.getProjectState().getLocalRights()); }
private java.util.Collection<com.google.gerrit.reviewdb.RefRight> getInheritedRights() { return filter(projectControl.getProjectState().getInheritedRights()); }
private java.util.Collection<com.google.gerrit.reviewdb.RefRight> filter(java.util.Collection<com.google.gerrit.reviewdb.RefRight> all) { java.util.List<com.google.gerrit.reviewdb.RefRight> mine = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(all.size()); for (com.google.gerrit.reviewdb.RefRight right : all) { if (com.google.gerrit.server.project.RefControl.matches(getRefName(), right.getRefPattern())) { mine.add(right); } } return mine; }

private void computeAllowed() { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> am = user.getEffectiveGroups(); final com.google.gerrit.server.project.ProjectState pe = projectCache.get(change.getProject()); computeAllowed(am, pe.getLocalRights()); computeAllowed(am, pe.getInheritedRights()); }
private boolean canPerform(com.google.gerrit.reviewdb.ApprovalCategory.Id actionId, short level) { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups(); int val = java.lang.Integer.MIN_VALUE; for (final com.google.gerrit.reviewdb.RefRight right : getLocalRights()) { if ((right.getApprovalCategoryId().equals(actionId)) && (groups.contains(right.getAccountGroupId()))) { if ((val < 0) && ((right.getMaxValue()) > 0)) { val = right.getMaxValue(); } else { val = java.lang.Math.max(right.getMaxValue(), val); } } } if ((val == (java.lang.Integer.MIN_VALUE)) && (actionId.canInheritFromWildProject())) { for (final com.google.gerrit.reviewdb.RefRight pr : getInheritedRights()) { if ((actionId.equals(pr.getApprovalCategoryId())) && (groups.contains(pr.getAccountGroupId()))) { val = java.lang.Math.max(pr.getMaxValue(), val); } } } return val >= level; }
public void applyRightFloor(final com.google.gerrit.reviewdb.PatchSetApproval a) { final com.google.gerrit.server.IdentifiedUser user = userFactory.create(a.getAccountId()); short minAllowed = 0; short maxAllowed = 0; for (final com.google.gerrit.reviewdb.RefRight r : getAllRights(a.getCategoryId())) { final com.google.gerrit.reviewdb.AccountGroup.Id grp = r.getAccountGroupId(); if (user.getEffectiveGroups().contains(grp)) { minAllowed = ((short) (java.lang.Math.min(minAllowed, r.getMinValue()))); maxAllowed = ((short) (java.lang.Math.max(maxAllowed, r.getMaxValue()))); } } if ((a.getValue()) < minAllowed) { a.setValue(minAllowed); dirty(a); } else if ((a.getValue()) > maxAllowed) { a.setValue(maxAllowed); dirty(a); } }
private com.google.gerrit.server.project.ProjectState lookup(final com.google.gerrit.reviewdb.Project.NameKey key) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.Project p = db.projects().get(key); if (p == null) { return null; } final java.util.Collection<com.google.gerrit.reviewdb.RefRight> rights = java.util.Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList()); return projectStateFactory.create(p, rights, inheritedRights); } finally { db.close(); } }
java.util.Collection<com.google.gerrit.reviewdb.RefRight> get();

public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getLocalRights() { return localRights; }
public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getAllRights(final com.google.gerrit.reviewdb.ApprovalCategory.Id id) { java.util.Collection<com.google.gerrit.reviewdb.RefRight> l = allRights.get(id); if (l == null) { l = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); l.addAll(getRefRights(id)); l.addAll(getWildcardRights(id)); l = java.util.Collections.unmodifiableCollection(l); allRights.put(id, l); } return l; }
@java.lang.Override public java.util.Collection<com.google.gerrit.reviewdb.RefRight> get() { return this.get(wildProject).getLocalRights(); }
com.google.gerrit.server.project.ProjectState create(com.google.gerrit.reviewdb.Project project, java.util.Collection<com.google.gerrit.reviewdb.RefRight> localRights, com.google.gerrit.server.project.ProjectState.InheritedRights inheritedRights);
public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getInheritedRights() { if (isSpecialWildProject()) { return java.util.Collections.emptyList(); } return inheritedRights.get(); }
public void applyRightFloor(final com.google.gerrit.reviewdb.PatchSetApproval a) { final com.google.gerrit.server.IdentifiedUser user = userFactory.create(a.getAccountId()); short minAllowed = 0; short maxAllowed = 0; for (final com.google.gerrit.reviewdb.RefRight r : getAllRights(a.getCategoryId())) { final com.google.gerrit.reviewdb.AccountGroup.Id grp = r.getAccountGroupId(); if (user.getEffectiveGroups().contains(grp)) { minAllowed = ((short) (java.lang.Math.min(minAllowed, r.getMinValue()))); maxAllowed = ((short) (java.lang.Math.max(maxAllowed, r.getMaxValue()))); } } if ((a.getValue()) < minAllowed) { a.setValue(minAllowed); dirty(a); } else if ((a.getValue()) > maxAllowed) { a.setValue(maxAllowed); dirty(a); } }

public void applyTypeFloor(final com.google.gerrit.common.data.ApprovalType at, final com.google.gerrit.reviewdb.PatchSetApproval a) { final com.google.gerrit.reviewdb.ApprovalCategoryValue atMin = at.getMin(); if ((atMin != null) && ((a.getValue()) < (atMin.getValue()))) { a.setValue(atMin.getValue()); dirty(a); } final com.google.gerrit.reviewdb.ApprovalCategoryValue atMax = at.getMax(); if ((atMax != null) && ((a.getValue()) > (atMax.getValue()))) { a.setValue(atMax.getValue()); dirty(a); } }
public void testCreateSchema_ApprovalCategory_PushTag() throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ReviewDb c = db.create().open(); try { final com.google.gerrit.reviewdb.ApprovalCategory cat; cat = c.approvalCategories().get(ApprovalCategory.PUSH_TAG); assertNotNull(cat); assertEquals(ApprovalCategory.PUSH_TAG, cat.getId()); assertEquals("Push Annotated Tag", cat.getName()); assertNull(cat.getAbbreviatedName()); assertEquals(NoOpFunction.NAME, cat.getFunctionName()); assertTrue(cat.isAction()); } finally { c.close(); } assertValueRange(ApprovalCategory.PUSH_TAG, ApprovalCategory.PUSH_TAG_SIGNED, ApprovalCategory.PUSH_TAG_ANNOTATED, ApprovalCategory.PUSH_TAG_ANY); }

private void initPushTagCategory(final com.google.gerrit.reviewdb.ReviewDb c) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ApprovalCategory cat; final java.util.ArrayList<com.google.gerrit.reviewdb.ApprovalCategoryValue> vals; cat = new com.google.gerrit.reviewdb.ApprovalCategory(com.google.gerrit.reviewdb.ApprovalCategory.PUSH_TAG, "Push Annotated Tag"); cat.setPosition(((short) (-1))); cat.setFunctionName(NoOpFunction.NAME); vals = new java.util.ArrayList<com.google.gerrit.reviewdb.ApprovalCategoryValue>(); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, ApprovalCategory.PUSH_TAG_SIGNED, "Create Signed Tag")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, ApprovalCategory.PUSH_TAG_ANNOTATED, "Create Annotated Tag")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, ApprovalCategory.PUSH_TAG_ANY, "Create Any Tag")); c.approvalCategories().insert(java.util.Collections.singleton(cat)); c.approvalCategoryValues().insert(vals); }
public void testResolve() throws java.net.UnknownHostException { assertEquals(new java.net.InetSocketAddress(1234), com.google.gerrit.server.util.SocketUtil.resolve("*:1234", 80)); assertEquals(new java.net.InetSocketAddress(80), com.google.gerrit.server.util.SocketUtil.resolve("*", 80)); assertEquals(new java.net.InetSocketAddress(1234), com.google.gerrit.server.util.SocketUtil.resolve(":1234", 80)); assertEquals(new java.net.InetSocketAddress(80), com.google.gerrit.server.util.SocketUtil.resolve("", 80)); assertEquals(new java.net.InetSocketAddress(java.net.InetAddress.getByName("1:2:3:4:5:6:7:8"), 1234), com.google.gerrit.server.util.SocketUtil.resolve("[1:2:3:4:5:6:7:8]:1234", 80)); assertEquals(new java.net.InetSocketAddress(java.net.InetAddress.getByName("1:2:3:4:5:6:7:8"), 80), com.google.gerrit.server.util.SocketUtil.resolve("[1:2:3:4:5:6:7:8]", 80)); assertEquals(new java.net.InetSocketAddress(java.net.InetAddress.getByName("localhost"), 1234), com.google.gerrit.server.util.SocketUtil.resolve("[localhost]:1234", 80)); assertEquals(new java.net.InetSocketAddress(java.net.InetAddress.getByName("localhost"), 80), com.google.gerrit.server.util.SocketUtil.resolve("[localhost]", 80)); try { com.google.gerrit.server.util.SocketUtil.resolve("invalid.name.localdomain:12", 80); fail("did not throw exception"); } catch (java.lang.IllegalArgumentException e) { assertEquals("unknown host: invalid.name.localdomain:12", e.getMessage()); } }
static void copy(final java.io.File dst, final java.io.InputStream in) throws java.io.FileNotFoundException, java.io.IOException { try { dst.getParentFile().mkdirs(); final java.io.FileOutputStream out = new java.io.FileOutputStream(dst); try { final byte[] buf = new byte[4096]; int n; while (0 < (n = in.read(buf))) { out.write(buf, 0, n); } } finally { out.close(); } } finally { in.close(); } }
private java.lang.String getFileType() { java.lang.String srcType = settings.getFilename(); if (srcType == null) { return null; } int dot = srcType.lastIndexOf('.'); if (0 < dot) { srcType = srcType.substring((dot + 1)); } return srcType; }
public com.google.gerrit.server.account.AuthRequest authenticate(final com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException { final java.lang.String username = who.getLocalUser(); try { final javax.naming.directory.DirContext ctx = open(); try { final com.google.gerrit.server.auth.ldap.LdapQuery.Result m = findAccount(ctx, username); if ((authConfig.getAuthType()) == (com.google.gerrit.reviewdb.AuthType.LDAP)) { authenticate(m.getDN(), who.getPassword()); } who.setDisplayName(com.google.gerrit.server.auth.ldap.LdapRealm.apply(accountFullName, m)); who.setUserName(com.google.gerrit.server.auth.ldap.LdapRealm.apply(accountSshUserName, m)); if ((accountEmailAddress) != null) { who.setEmailAddress(com.google.gerrit.server.auth.ldap.LdapRealm.apply(accountEmailAddress, m)); } else if (emailExpander.canExpand(username)) { who.setEmailAddress(emailExpander.expand(username)); } membershipCache.put(username, queryForGroups(ctx, username, m)); return who; } finally { try { ctx.close(); } catch (javax.naming.NamingException e) { com.google.gerrit.server.auth.ldap.LdapRealm.log.warn("Cannot close LDAP query handle", e); } } } catch (javax.naming.NamingException e) { com.google.gerrit.server.auth.ldap.LdapRealm.log.error("Cannot query LDAP to autenticate user", e); throw new com.google.gerrit.server.account.AccountException("Cannot query LDAP for account", e); } }
public com.google.gerrit.prettify.common.SparseHtmlFile getSparseHtmlFileB() { com.google.gerrit.prettify.common.PrettySettings s = new com.google.gerrit.prettify.common.PrettySettings(settings.getPrettySettings()); s.setFileName(b.getPath()); com.google.gerrit.prettify.common.PrettyFormatter f = ClientSideFormatter.FACTORY.get(); f.setPrettySettings(s); f.setEditFilter(PrettyFormatter.B); f.setEditList(getEditList()); if (((s.isSyntaxHighlighting()) && (a.isWholeFile())) && (!(b.isWholeFile()))) { f.format(b.completeWithContext(a, getEditList())); } else { f.format(b); } return f; }
public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.PatchSet patchSet) { final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(patchsetCreatedHook.getAbsolutePath()); args.add("--change"); args.add(change.getKey().get()); args.add("--project"); args.add(change.getProject().get()); args.add("--branch"); args.add(change.getDest().getShortName()); args.add("--commit"); args.add(patchSet.getRevision().get()); args.add("--patchset"); args.add(java.lang.Integer.toString(patchSet.getPatchSetId())); runHook(getRepo(change), args); }
public void doChangeAbandonedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final java.lang.String reason) { final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeAbandonedHook.getAbsolutePath()); args.add("--change"); args.add(change.getKey().get()); args.add("--project"); args.add(change.getProject().get()); args.add("--branch"); args.add(change.getDest().getShortName()); args.add("--abandoner"); args.add(getDisplayName(account)); args.add("--reason"); args.add((reason == null ? "" : reason)); runHook(getRepo(change), args); }


public void doChangeMergedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final com.google.gerrit.reviewdb.PatchSet patchSet) { final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeMergedHook.getAbsolutePath()); args.add("--change"); args.add(change.getKey().get()); args.add("--project"); args.add(change.getProject().get()); args.add("--branch"); args.add(change.getDest().getShortName()); args.add("--submitter"); args.add(getDisplayName(account)); args.add("--commit"); args.add(patchSet.getRevision().get()); runHook(getRepo(change), args); }


static java.lang.String[] split(java.lang.String commandLine) { final java.util.List<java.lang.String> list = new java.util.ArrayList<java.lang.String>(); boolean inquote = false; java.lang.StringBuilder r = new java.lang.StringBuilder(); for (int ip = 0; ip < (commandLine.length());) { final char b = commandLine.charAt((ip++)); switch (b) { case '\t' : case ' ' : if (inquote) r.append(b); else if ((r.length()) > 0) { list.add(r.toString()); r = new java.lang.StringBuilder(); } continue; case '\'' : inquote = !inquote; continue; case '\\' : if (inquote || (ip == (commandLine.length()))) r.append(b); else r.append(commandLine.charAt((ip++))); continue; default : r.append(b); continue; } } if ((r.length()) > 0) { list.add(r.toString()); } return list.toArray(new java.lang.String[list.size()]); }
@java.lang.Override public void authenticate(final java.lang.String username, final java.lang.String password, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.auth.userpass.LoginResult> callback) { com.google.gerrit.common.auth.userpass.LoginResult result = new com.google.gerrit.common.auth.userpass.LoginResult(); if ((((username == null) || ("".equals(username))) || (password == null)) || ("".equals(password))) { result.success = false; callback.onSuccess(result); return; } final com.google.gerrit.server.account.AuthRequest req = com.google.gerrit.server.account.AuthRequest.forUser(username); req.setPassword(password); final com.google.gerrit.server.account.AuthResult res; try { res = accountManager.authenticate(req); } catch (com.google.gerrit.server.account.AccountException e) { result.success = false; callback.onSuccess(result); return; } result.success = true; result.isNew = res.isNew(); webSession.get().login(res, false); callback.onSuccess(result); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException, java.sql.SQLException { com.google.gwtorm.jdbc.JdbcSchema jdbc = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); com.google.gerrit.reviewdb.SystemConfig sc = db.systemConfig().get(new com.google.gerrit.reviewdb.SystemConfig.Key()); java.sql.Statement s = jdbc.getConnection().createStatement(); try { java.sql.ResultSet r; r = s.executeQuery("SELECT name FROM projects WHERE project_id = 0"); try { if (!(r.next())) { throw new com.google.gwtorm.client.OrmException("Cannot read old wild project"); } sc.wildProjectName = new com.google.gerrit.reviewdb.Project.NameKey(r.getString(1)); } finally { r.close(); } if ((jdbc.getDialect()) instanceof com.google.gwtorm.schema.sql.DialectMySQL) { s.execute("DROP FUNCTION nextval_project_id"); } else if ((jdbc.getDialect()) instanceof com.google.gwtorm.schema.sql.DialectH2) { s.execute(("ALTER TABLE projects DROP CONSTRAINT" + " IF EXISTS CONSTRAINT_F3")); } } finally { s.close(); } db.systemConfig().update(java.util.Collections.singleton(sc)); }

private void display() throws com.google.gerrit.sshd.commands.Failure { final java.io.PrintWriter stdout = toPrintWriter(out); try { for (final com.google.gerrit.reviewdb.Project p : db.projects().all()) { if (p.getNameKey().equals(wildProject)) { continue; } final com.google.gerrit.server.project.ProjectState e = projectCache.get(p.getNameKey()); if ((e != null) && (e.controlFor(currentUser).isVisible())) { stdout.print(p.getName()); stdout.println(); } } } catch (com.google.gwtorm.client.OrmException e) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: database error", e); } finally { stdout.flush(); } }
@java.lang.Override protected void runImpl() throws java.io.IOException { final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.upload(in, out, err); }
private void parseCommands(final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { for (final org.eclipse.jgit.transport.ReceiveCommand cmd : commands) { if ((cmd.getResult()) != (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { continue; } if ((!(org.eclipse.jgit.lib.Repository.isValidRefName(cmd.getRefName()))) || (cmd.getRefName().contains("//"))) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "not valid ref"); continue; } if (cmd.getRefName().startsWith(com.google.gerrit.server.git.ReceiveCommits.NEW_CHANGE)) { parseNewChangeCommand(cmd); continue; } final java.util.regex.Matcher m = com.google.gerrit.server.git.ReceiveCommits.NEW_PATCHSET.matcher(cmd.getRefName()); if (m.matches()) { final com.google.gerrit.reviewdb.Change.Id changeId = Change.Id.parse(m.group(1)); parseReplaceCommand(cmd, changeId); continue; } switch (cmd.getType()) { case CREATE : parseCreate(cmd); continue; case UPDATE : parseUpdate(cmd); continue; case DELETE : parseDelete(cmd); continue; case UPDATE_NONFASTFORWARD : parseRewind(cmd); continue; } com.google.gerrit.server.git.ReceiveCommits.reject(cmd); } }



@java.lang.Override public void run() throws java.lang.Exception { java.io.PrintWriter p = toPrintWriter(out); ownerId = authConfig.getAdministratorsGroup(); parseCommandLine(); try { validateParameters(); org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(projectName); repo.create(true); org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(branch); repoManager.setProjectDescription(projectName, projectDescription); createProject(); rq.replicateNewProject(new com.google.gerrit.reviewdb.Project.NameKey(projectName), branch); } catch (java.lang.Exception e) { p.print((("Error when trying to create project: " + (e.getMessage())) + "\n")); p.flush(); } }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws java.lang.Exception { java.io.PrintWriter p = toPrintWriter(out); ownerId = authConfig.getAdministratorsGroup(); parseCommandLine(); try { validateParameters(); org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(projectName); repo.create(true); org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(branch); repoManager.setProjectDescription(projectName, projectDescription); createProject(); rq.replicateNewProject(new com.google.gerrit.reviewdb.Project.NameKey(projectName), branch); } catch (java.lang.Exception e) { p.print((("Error when trying to create project: " + (e.getMessage())) + "\n")); p.flush(); } } }); }



private void createProject() throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project.NameKey newProjectNameKey = new com.google.gerrit.reviewdb.Project.NameKey(projectName); final com.google.gerrit.reviewdb.RefRight.Key prk = new com.google.gerrit.reviewdb.RefRight.Key(newProjectNameKey, new com.google.gerrit.reviewdb.RefRight.RefPattern("refs/*"), com.google.gerrit.reviewdb.ApprovalCategory.OWN, ownerId); final com.google.gerrit.reviewdb.RefRight pr = new com.google.gerrit.reviewdb.RefRight(prk); pr.setMaxValue(((short) (1))); pr.setMinValue(((short) (1))); db.refRights().insert(java.util.Collections.singleton(pr)); final com.google.gerrit.reviewdb.Project newProject = new com.google.gerrit.reviewdb.Project(newProjectNameKey); newProject.setDescription(projectDescription); newProject.setSubmitType(submitType); newProject.setUseContributorAgreements(contributorAgreements); newProject.setUseSignedOffBy(signedOffBy); db.projects().insert(java.util.Collections.singleton(newProject)); }
@java.lang.Override public com.google.gwtjsonrpc.client.VoidResult call() throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchRefException, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.project.ProjectControl projectControl = projectControlFactory.controlFor(projectName); for (final com.google.gerrit.reviewdb.RefRight.Key k : toRemove) { if (!(projectName.equals(k.getProjectNameKey()))) { throw new java.lang.IllegalArgumentException("All keys must be from same project"); } if (!(controlForRef(projectControl, k.getRefPattern()).isOwner())) { throw new com.google.gerrit.server.project.NoSuchRefException(k.getRefPattern()); } } for (final com.google.gerrit.reviewdb.RefRight.Key k : toRemove) { final com.google.gerrit.reviewdb.RefRight m = db.refRights().get(k); if (m != null) { db.refRights().delete(java.util.Collections.singleton(m)); } } projectCache.evict(projectControl.getProject()); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
@java.lang.Override protected void configure() { final com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); command(gerrit, "approve").to(com.google.gerrit.sshd.commands.ApproveCommand.class); command(gerrit, "create-account").to(com.google.gerrit.sshd.commands.AdminCreateAccount.class); command(gerrit, "create-project").to(com.google.gerrit.sshd.commands.AdminCreateProject.class); command(gerrit, "gsql").to(com.google.gerrit.sshd.commands.AdminQueryShell.class); command(gerrit, "receive-pack").to(com.google.gerrit.sshd.commands.Receive.class); command(gerrit, "replicate").to(com.google.gerrit.sshd.commands.AdminReplicate.class); }
private com.google.gerrit.server.project.ProjectState lookup(final com.google.gerrit.reviewdb.Project.NameKey key) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.Project p = db.projects().get(key); if (p == null) { return null; } final java.util.Collection<com.google.gerrit.reviewdb.RefRight> rights = java.util.Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList()); return projectStateFactory.create(p, rights, inheritedRights); } finally { db.close(); } }
@java.lang.Override protected void configure() { final com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); command(gerrit, "approve").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); command(gerrit, "create-account").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); command(gerrit, "create-project").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); command(gerrit, "gsql").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); command(gerrit, "receive-pack").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); command(gerrit, "replicate").to(com.google.gerrit.sshd.commands.ErrorSlaveMode.class); }

@java.lang.Override protected <V> java.util.concurrent.RunnableScheduledFuture<V> decorateTask(final java.lang.Runnable runnable, java.util.concurrent.RunnableScheduledFuture<V> r) { r = super.decorateTask(runnable, r); for (; ;) { final int id = idGenerator.next(); final com.google.gerrit.server.git.WorkQueue.Task<V> task = new com.google.gerrit.server.git.WorkQueue.Task<V>(runnable, r, this, id); if ((all.putIfAbsent(task.getTaskId(), task)) == null) { return task; } } }
protected synchronized void startThread(final com.google.gerrit.sshd.BaseCommand.CommandRunnable thunk) { final com.google.gerrit.sshd.BaseCommand.TaskThunk tt = new com.google.gerrit.sshd.BaseCommand.TaskThunk(thunk); if (isAdminCommand()) { new java.lang.Thread(tt, tt.toString()).start(); } else { task = executor.submit(tt); } }

@java.lang.Override public WorkQueue.Executor get() { final com.google.gerrit.server.git.WorkQueue.Executor executor; executor = queues.createQueue(poolSize, "SSH-Worker"); final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory(); executor.setThreadFactory(new java.util.concurrent.ThreadFactory() { @java.lang.Override public java.lang.Thread newThread(final java.lang.Runnable task) { final java.lang.Thread t = parent.newThread(task); t.setPriority(java.lang.Thread.MIN_PRIORITY); return t; } }); return executor; }

@java.lang.Override protected <V> java.util.concurrent.RunnableScheduledFuture<V> decorateTask(final java.lang.Runnable runnable, java.util.concurrent.RunnableScheduledFuture<V> r) { r = super.decorateTask(runnable, r); for (; ;) { final int id = idGenerator.next(); com.google.gerrit.server.git.WorkQueue.Task<V> task; if (runnable instanceof com.google.gerrit.server.git.ProjectRunnable) { task = new com.google.gerrit.server.git.WorkQueue.ProjectTask<V>(((com.google.gerrit.server.git.ProjectRunnable) (runnable)), r, this, id); } else { task = new com.google.gerrit.server.git.WorkQueue.Task<V>(runnable, r, this, id); } if ((all.putIfAbsent(task.getTaskId(), task)) == null) { return task; } } }
@java.lang.Override public T atomicUpdate(final K key, final com.google.gwtorm.client.AtomicUpdate<T> update) throws com.google.gwtorm.client.OrmException { return schema.run(new com.google.gwtorm.client.OrmRunnable<T, com.google.gwtorm.jdbc.JdbcSchema>() { @java.lang.Override public T run(com.google.gwtorm.jdbc.JdbcSchema db, com.google.gwtorm.client.Transaction txn, boolean retry) throws com.google.gwtorm.client.OrmException { final T obj = get(key); if (obj == null) { return null; } final T res = update.update(obj); update(java.util.Collections.singleton(obj), txn); return res; } }); }
private void refresh() { Util.PROJECT_SVC.projectDetail(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); saveProject.setEnabled(false); display(result); } }); }
public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { addRight.setEnabled(true); nameTxt.setText(""); referenceTxt.setText(""); display(result); }
void populate(final int row, final com.google.gerrit.reviewdb.Branch k) { final com.google.gerrit.common.data.GitwebLink c = com.google.gerrit.client.Gerrit.getConfig().getGitwebLink(); table.setWidget(row, 1, new com.google.gwt.user.client.ui.CheckBox()); table.setText(row, 2, k.getShortName()); if ((k.getRevision()) != null) { table.setText(row, 3, k.getRevision().get()); } else { table.setText(row, 3, ""); } if (c != null) { table.setWidget(row, 4, new com.google.gwt.user.client.ui.Anchor("(gitweb)", false, c.toBranch(k.getNameKey()))); } final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); if (c != null) { fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell()); } setRowItem(row, k); }
void display(final java.util.Map<com.google.gerrit.reviewdb.AccountGroup.Id, com.google.gerrit.reviewdb.AccountGroup> groups, final java.util.List<com.google.gerrit.reviewdb.RefRight> refRights) { while (1 < (table.getRowCount())) table.removeRow(((table.getRowCount()) - 1)); for (final com.google.gerrit.reviewdb.RefRight r : refRights) { final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); populate(row, groups, r); } }
public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); display(result); }

private void doAddNewBranch() { java.lang.String branchName = nameTxtBox.getText(); if (("".equals(branchName)) || (Util.C.defaultBranchName().equals(branchName))) { nameTxtBox.setFocus(true); return; } java.lang.String rev = irevTxtBox.getText(); if (("".equals(rev)) || (Util.C.defaultRevisionSpec().equals(rev))) { irevTxtBox.setText("HEAD"); com.google.gwt.user.client.DeferredCommand.addCommand(new com.google.gwt.user.client.Command() { @java.lang.Override public void execute() { irevTxtBox.selectAll(); irevTxtBox.setFocus(true); } }); return; } if (!(branchName.startsWith(Branch.R_REFS))) { branchName = (com.google.gerrit.reviewdb.Branch.R_HEADS) + branchName; } addBranch.setEnabled(false); Util.PROJECT_SVC.addBranch(projectName, branchName, rev, new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.Branch>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.Branch> result) { addBranch.setEnabled(true); nameTxtBox.setText(""); irevTxtBox.setText(""); branches.display(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((caught instanceof com.google.gerrit.common.errors.InvalidNameException) || ((caught instanceof com.google.gwtjsonrpc.client.RemoteJsonException) && (caught.getMessage().equals(InvalidNameException.MESSAGE)))) { nameTxtBox.selectAll(); nameTxtBox.setFocus(true); } else if ((caught instanceof com.google.gerrit.common.errors.InvalidRevisionException) || ((caught instanceof com.google.gwtjsonrpc.client.RemoteJsonException) && (caught.getMessage().equals(InvalidRevisionException.MESSAGE)))) { irevTxtBox.selectAll(); irevTxtBox.setFocus(true); } addBranch.setEnabled(true); super.onFailure(caught); } }); }
void display(final java.util.List<com.google.gerrit.reviewdb.Branch> result) { while (1 < (table.getRowCount())) table.removeRow(((table.getRowCount()) - 1)); for (final com.google.gerrit.reviewdb.Branch k : result) { final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); populate(row, k); } }
public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.Branch> result) { addBranch.setEnabled(true); nameTxtBox.setText(""); irevTxtBox.setText(""); branches.display(result); }
@java.lang.Override protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.listBranches(projectName, new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.Branch>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.Branch> result) { enableForm(true); branches.display(result); } }); }
@java.lang.Override protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); display(result); } }); }
void display(final com.google.gerrit.common.data.ProjectDetail result) { rights.display(result.groups, result.rights); }

private void enableForm(final boolean on) { submitType.setEnabled(on); descTxt.setEnabled(on); useContributorAgreements.setEnabled(on); useSignedOffBy.setEnabled(on); }
public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); saveProject.setEnabled(false); display(result); }


public void doChangeAbandonedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final java.lang.String reason) { final com.google.gerrit.common.ChangeHookRunner.ChangeAbandonedEvent event = new com.google.gerrit.common.ChangeHookRunner.ChangeAbandonedEvent(); event.change = getChangeAttribute(change); event.abandoner = getAccountAttribute(account); event.reason = reason; fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeAbandonedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--abandoner"); args.add(getDisplayName(account)); args.add("--reason"); args.add((reason == null ? "" : reason)); runHook(getRepo(change), args); }
public void doChangeMergedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final com.google.gerrit.reviewdb.PatchSet patchSet) { final com.google.gerrit.common.ChangeHookRunner.ChangeMergedEvent event = new com.google.gerrit.common.ChangeHookRunner.ChangeMergedEvent(); event.change = getChangeAttribute(change); event.submitter = getAccountAttribute(account); event.patchSet = getPatchSetAttribute(patchSet); fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeMergedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--submitter"); args.add(getDisplayName(account)); args.add("--commit"); args.add(event.patchSet.revision); runHook(getRepo(change), args); }
public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.PatchSet patchSet) { final com.google.gerrit.common.ChangeHookRunner.PatchSetCreatedEvent event = new com.google.gerrit.common.ChangeHookRunner.PatchSetCreatedEvent(); event.change = getChangeAttribute(change); event.patchSet = getPatchSetAttribute(patchSet); fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(patchsetCreatedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--commit"); args.add(event.patchSet.revision); args.add("--patchset"); args.add(event.patchSet.number); runHook(getRepo(change), args); }
@com.google.gwtorm.client.Query("WHERE open = false AND status = ? AND dest.projectName = ? AND sortKey < ?" + " ORDER BY sortKey DESC LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> byProjectClosedNext(char status, com.google.gerrit.reviewdb.Project.NameKey p, java.lang.String sortKey, int limit) throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query("WHERE open = true AND sortKey < ? ORDER BY sortKey DESC LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> allOpenNext(java.lang.String sortKey, int limit) throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query("WHERE open = false AND status = ? AND sortKey < ? ORDER BY sortKey DESC LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> allClosedNext(char status, java.lang.String sortKey, int limit) throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query("WHERE open = true AND dest.projectName = ? AND sortKey < ?" + " ORDER BY sortKey DESC LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> byProjectOpenNext(com.google.gerrit.reviewdb.Project.NameKey p, java.lang.String sortKey, int limit) throws com.google.gwtorm.client.OrmException;

public static java.util.List<com.google.gerrit.reviewdb.RefRight> filterMostSpecific(java.util.List<com.google.gerrit.reviewdb.RefRight> actionRights) { boolean sameRefPattern = true; java.util.List<com.google.gerrit.reviewdb.RefRight> mostSpecific = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); java.lang.String currentRefPattern = null; int i = 0; while (sameRefPattern && (i < (actionRights.size()))) { if (currentRefPattern == null) { currentRefPattern = actionRights.get(i).getRefPattern(); mostSpecific.add(actionRights.get(i)); i++; } else { if (currentRefPattern.equals(actionRights.get(i).getRefPattern())) { mostSpecific.add(actionRights.get(i)); i++; } else { sameRefPattern = false; } } } return mostSpecific; }
boolean canPerform(com.google.gerrit.reviewdb.ApprovalCategory.Id actionId, short level) { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups(); int val = java.lang.Integer.MIN_VALUE; java.util.List<com.google.gerrit.reviewdb.RefRight> allRights = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); allRights.addAll(getLocalRights(actionId)); if (actionId.canInheritFromWildProject()) { allRights.addAll(getInheritedRights(actionId)); } java.util.Collections.sort(allRights, RefRight.REF_PATTERN_ORDER); for (com.google.gerrit.reviewdb.RefRight right : com.google.gerrit.server.project.RefControl.filterMostSpecific(allRights)) { if (groups.contains(right.getAccountGroupId())) { if ((val < 0) && ((right.getMaxValue()) > 0)) { val = right.getMaxValue(); } else { val = java.lang.Math.max(right.getMaxValue(), val); } } } return val >= level; }

public java.util.List<com.google.gerrit.reviewdb.RefRight> getAllRights(final com.google.gerrit.reviewdb.ApprovalCategory.Id id) { java.util.List<com.google.gerrit.reviewdb.RefRight> l = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); l.addAll(getLocalRights(id)); l.addAll(getInheritedRights(id)); java.util.Collections.sort(l, RefRight.REF_PATTERN_ORDER); return java.util.Collections.unmodifiableList(com.google.gerrit.server.project.RefControl.filterMostSpecific(l)); }
@java.lang.Override protected void configure() { final com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); command(gerrit, "approve").to(com.google.gerrit.sshd.commands.ApproveCommand.class); command(gerrit, "create-account").to(com.google.gerrit.sshd.commands.AdminCreateAccount.class); command(gerrit, "create-project").to(com.google.gerrit.sshd.commands.CreateProject.class); command(gerrit, "gsql").to(com.google.gerrit.sshd.commands.AdminQueryShell.class); command(gerrit, "receive-pack").to(com.google.gerrit.sshd.commands.Receive.class); command(gerrit, "replicate").to(com.google.gerrit.sshd.commands.AdminReplicate.class); command(gerrit, "set-project-parent").to(com.google.gerrit.sshd.commands.AdminSetParent.class); }
@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException, java.lang.IllegalStateException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); com.google.gerrit.reviewdb.Change change = db.changes().get(changeId); if (change == null) { throw new com.google.gerrit.common.errors.NoSuchEntityException(); } if (!(patchSetId.equals(change.currentPatchSetId()))) { throw new java.lang.IllegalStateException((("Patch set " + (patchSetId)) + " not current")); } if (change.getStatus().isClosed()) { throw new java.lang.IllegalStateException((("Change" + changeId) + " is closed")); } final java.util.List<com.google.gerrit.reviewdb.PatchSetApproval> allApprovals = new java.util.ArrayList<com.google.gerrit.reviewdb.PatchSetApproval>(db.patchSetApprovals().byPatchSet(patchSetId).toList()); final com.google.gerrit.reviewdb.PatchSetApproval.Key ak = new com.google.gerrit.reviewdb.PatchSetApproval.Key(patchSetId, user.getAccountId(), SUBMIT); com.google.gerrit.reviewdb.PatchSetApproval myAction = null; for (final com.google.gerrit.reviewdb.PatchSetApproval ca : allApprovals) { if (ak.equals(ca.getKey())) { myAction = ca; myAction.setValue(((short) (1))); myAction.setGranted(); break; } } if (myAction == null) { myAction = new com.google.gerrit.reviewdb.PatchSetApproval(ak, ((short) (1))); allApprovals.add(myAction); } final com.google.gerrit.common.data.ApprovalType actionType = approvalTypes.getApprovalType(myAction.getCategoryId()); if ((actionType == null) || (!(actionType.getCategory().isAction()))) { throw new java.lang.IllegalArgumentException(((actionType.getCategory().getName()) + " not an action")); } final com.google.gerrit.server.workflow.FunctionState fs = functionState.create(change, patchSetId, allApprovals); for (com.google.gerrit.common.data.ApprovalType c : approvalTypes.getApprovalTypes()) { com.google.gerrit.server.workflow.CategoryFunction.forCategory(c.getCategory()).run(c, fs); } if (!(com.google.gerrit.server.workflow.CategoryFunction.forCategory(actionType.getCategory()).isValid(user, actionType, fs))) { throw new java.lang.IllegalStateException(((actionType.getCategory().getName()) + " not permitted")); } fs.normalize(actionType, myAction); if ((myAction.getValue()) <= 0) { throw new java.lang.IllegalStateException(((actionType.getCategory().getName()) + " not permitted")); } db.patchSetApprovals().upsert(java.util.Collections.singleton(myAction)); change = db.changes().atomicUpdate(changeId, new com.google.gwtorm.client.AtomicUpdate<com.google.gerrit.reviewdb.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.Change update(com.google.gerrit.reviewdb.Change change) { if ((change.getStatus()) == (Change.Status.NEW)) { change.setStatus(Change.Status.SUBMITTED); com.google.gerrit.server.ChangeUtil.updated(change); } return change; } }); if ((change.getStatus()) == (Change.Status.SUBMITTED)) { merger.merge(change.getDest()); } return changeDetailFactory.create(changeId).call(); }
@java.lang.Override public com.google.gerrit.common.data.PatchSetPublishDetail call() throws com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl control = changeControlFactory.validateFor(changeId); change = control.getChange(); patchSetInfo = infoFactory.get(patchSetId); drafts = db.patchComments().draft(patchSetId, user.getAccountId()).toList(); allowed = new java.util.HashMap<com.google.gerrit.reviewdb.ApprovalCategory.Id, java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id>>(); given = new java.util.HashMap<com.google.gerrit.reviewdb.ApprovalCategory.Id, com.google.gerrit.reviewdb.PatchSetApproval>(); if ((change.getStatus().isOpen()) && (patchSetId.equals(change.currentPatchSetId()))) { computeAllowed(); for (final com.google.gerrit.reviewdb.PatchSetApproval a : db.patchSetApprovals().byPatchSetUser(patchSetId, user.getAccountId())) { given.put(a.getCategoryId(), a); } } aic.want(change.getOwner()); accounts = aic.create(); com.google.gerrit.common.data.PatchSetPublishDetail detail = new com.google.gerrit.common.data.PatchSetPublishDetail(); detail.setAccounts(accounts); detail.setPatchSetInfo(patchSetInfo); detail.setChange(change); detail.setDrafts(drafts); detail.setAllowed(allowed); detail.setGiven(given); return detail; }

@java.lang.Override protected void onInitUI() { super.onInitUI(); addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen()); approvalButtons = new java.util.ArrayList<com.google.gerrit.client.changes.PublishCommentScreen.ValueRadioButton>(); descBlock = new com.google.gerrit.client.changes.ChangeDescriptionBlock(); add(descBlock); final com.google.gwt.user.client.ui.FormPanel form = new com.google.gwt.user.client.ui.FormPanel(); final com.google.gwt.user.client.ui.FlowPanel body = new com.google.gwt.user.client.ui.FlowPanel(); form.setWidget(body); form.addSubmitHandler(new com.google.gwt.user.client.ui.FormPanel.SubmitHandler() { @java.lang.Override public void onSubmit(final com.google.gwt.user.client.ui.FormPanel.SubmitEvent event) { event.cancel(); } }); add(form); approvalPanel = new com.google.gwt.user.client.ui.FlowPanel(); body.add(approvalPanel); initMessage(body); draftsPanel = new com.google.gwt.user.client.ui.FlowPanel(); body.add(draftsPanel); final com.google.gwt.user.client.ui.FlowPanel buttonRow = new com.google.gwt.user.client.ui.FlowPanel(); body.add(buttonRow); send = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishCommentsSend()); send.addClickHandler(this); buttonRow.add(send); cancel = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishCommentsCancel()); cancel.addClickHandler(this); buttonRow.add(cancel); }
@java.lang.Override public void run() throws com.google.gerrit.sshd.commands.Failure { initOptionList(); parseCommandLine(); boolean ok = true; for (final com.google.gerrit.reviewdb.PatchSet.Id patchSetId : patchSetIds) { try { approveOne(patchSetId); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { ok = false; writeError((("error: " + (e.getMessage())) + "\n")); } catch (java.lang.Exception e) { ok = false; writeError((("fatal: internal server error while approving " + patchSetId) + "\n")); com.google.gerrit.sshd.commands.ReviewCommand.log.error(("internal error while approving " + patchSetId)); } } if (!ok) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("one or more approvals failed;" + " review output above")); } }
@java.lang.Override public final void start(final org.apache.sshd.server.Environment env) { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws com.google.gerrit.sshd.commands.Failure { initOptionList(); parseCommandLine(); boolean ok = true; for (final com.google.gerrit.reviewdb.PatchSet.Id patchSetId : patchSetIds) { try { approveOne(patchSetId); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { ok = false; writeError((("error: " + (e.getMessage())) + "\n")); } catch (java.lang.Exception e) { ok = false; writeError((("fatal: internal server error while approving " + patchSetId) + "\n")); com.google.gerrit.sshd.commands.ReviewCommand.log.error(("internal error while approving " + patchSetId)); } } if (!ok) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("one or more approvals failed;" + " review output above")); } } }); }
public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.PatchSet patchSet) { final com.google.gerrit.common.ChangeHookRunner.PatchSetCreatedEvent event = new com.google.gerrit.common.ChangeHookRunner.PatchSetCreatedEvent(); event.change = getChangeAttribute(change); event.patchSet = getPatchSetAttribute(patchSet); fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(patchsetCreatedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--change-url"); args.add(event.change.url); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--commit"); args.add(event.patchSet.revision); args.add("--patchset"); args.add(event.patchSet.number); runHook(getRepo(change), args); }





@java.lang.Override protected void configure() { final java.lang.String cacheName = WebSessionManager.CACHE_NAME; final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.httpd.WebSessionManager.Key, com.google.gerrit.httpd.WebSessionManager.Val>> type = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.httpd.WebSessionManager.Key, com.google.gerrit.httpd.WebSessionManager.Val>>() {}; disk(type, cacheName).memoryLimit(1024).maxAge(12, java.util.concurrent.TimeUnit.HOURS).evictionPolicy(EvictionPolicy.LRU); bind(com.google.gerrit.httpd.WebSessionManager.class); bind(com.google.gerrit.httpd.WebSession.class).in(com.google.inject.servlet.RequestScoped.class); }
void setUserAccountId(com.google.gerrit.reviewdb.Account.Id id) { key = new com.google.gerrit.httpd.WebSessionManager.Key(("id:" + id)); val = new com.google.gerrit.httpd.WebSessionManager.Val(id, 0, false, null, ""); }

static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { final java.lang.String cacheName = WebSessionManager.CACHE_NAME; final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.httpd.WebSessionManager.Key, com.google.gerrit.httpd.WebSessionManager.Val>> type = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.httpd.WebSessionManager.Key, com.google.gerrit.httpd.WebSessionManager.Val>>() {}; disk(type, cacheName).memoryLimit(1024).maxAge(12, java.util.concurrent.TimeUnit.HOURS).evictionPolicy(EvictionPolicy.LRU); bind(com.google.gerrit.httpd.WebSessionManager.class); bind(com.google.gerrit.httpd.WebSession.class).in(com.google.inject.servlet.RequestScoped.class); } }; }
public void login(final com.google.gerrit.server.account.AuthResult res, final boolean rememberMe) { final com.google.gerrit.reviewdb.Account.Id id = res.getAccountId(); final com.google.gerrit.reviewdb.AccountExternalId.Key identity = res.getExternalId(); if ((val) != null) { manager.destroy(key); key = null; val = null; } key = manager.createKey(id); val = manager.createVal(key, id, rememberMe, identity, null); saveCookie(); }

public void logout() { if ((val) != null) { manager.destroy(key); key = null; val = null; saveCookie(); } }















void addOneKey(final com.google.gerrit.reviewdb.AccountSshKey k) { final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); final com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); if (k.isValid()) { table.setText(row, 2, ""); fmt.removeStyleName(row, 2, Gerrit.RESOURCES.css().sshKeyPanelInvalid()); } else { table.setText(row, 2, Util.C.sshKeyInvalid()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().sshKeyPanelInvalid()); } table.setText(row, 3, k.getAlgorithm()); table.setText(row, 4, com.google.gerrit.client.account.SshPanel.elide(k.getEncodedKey(), 40)); table.setText(row, 5, k.getComment()); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().sshKeyPanelEncodedKey()); for (int c = 2; c <= 5; c++) { fmt.addStyleName(row, c, Gerrit.RESOURCES.css().dataCell()); } setRowItem(row, k); }









@com.google.gwt.uibinder.client.UiHandler("update") void onUpdate(com.google.gwt.event.dom.client.ClickEvent event) { update(); }

private void deactivate() { if ((activePatchSetId) != (-1)) { com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel patchSetPanel = patchSetPanels.get(activePatchSetId); patchSetPanel.setActive(false); activePatchSetId = -1; } }


public void display(final com.google.gerrit.reviewdb.Change chg, final com.google.gerrit.reviewdb.PatchSetInfo info, final com.google.gerrit.common.data.AccountInfoCache acc) { infoBlock.display(chg, acc); com.google.gwtexpui.safehtml.client.SafeHtml msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(info.getMessage()); msg = msg.linkify(); msg = com.google.gerrit.client.ui.CommentLinkProcessor.apply(msg); msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openElement("p").append(msg).closeElement("p"); msg = msg.replaceAll("\n\n", "</p><p>"); msg = msg.replaceAll("\n", "<br />"); com.google.gwtexpui.safehtml.client.SafeHtml.set(description, msg); }



@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myProjectWatch(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo>>() { public void onSuccess(final java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo> result) { watches.display(result); } }); }
public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.AccountGroup> result) { groups.display(result); }
private void refresh() { Util.PROJECT_SVC.projectDetail(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType); saveProject.setVisible((((result.canModifyAgreements) || (result.canModifyDescription)) || (result.canModifyMergeType))); saveProject.setEnabled(false); display(result); } }); }
public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType); saveProject.setVisible((((result.canModifyAgreements) || (result.canModifyDescription)) || (result.canModifyMergeType))); saveProject.setEnabled(false); display(result); }
public void onSuccess(final java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo> result) { watches.display(result); }
public void onSuccess(final com.google.gerrit.reviewdb.Account result) { display(result.getGeneralPreferences()); enable(true); }
public void onSuccess(final com.google.gerrit.common.data.AgreementInfo result) { agreements.display(result); }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myAgreements(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.AgreementInfo>() { public void onSuccess(final com.google.gerrit.common.data.AgreementInfo result) { agreements.display(result); } }); }
public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); display(result); }
@java.lang.Override protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.projectDetail(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(true); display(result); } }); }
public void onSuccess(final com.google.gerrit.common.data.ListBranchesResult result) { enableForm(true); display(result.getBranches()); addPanel.setVisible(result.getCanAdd()); }
@java.lang.Override protected void onLoad() { enableForm(false); super.onLoad(); Util.PROJECT_SVC.listBranches(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ListBranchesResult>() { public void onSuccess(final com.google.gerrit.common.data.ListBranchesResult result) { enableForm(true); display(result.getBranches()); addPanel.setVisible(result.getCanAdd()); } }); }
public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.AccountExternalId> result) { identites.display(result); }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SEC.myExternalIds(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.AccountExternalId>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.AccountExternalId> result) { identites.display(result); } }); }
private void refresh() { Util.ACCOUNT_SEC.myGroups(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.AccountGroup>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.AccountGroup> result) { groups.display(result); } }); }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myAccount(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.Account>() { public void onSuccess(final com.google.gerrit.reviewdb.Account result) { display(result.getGeneralPreferences()); enable(true); } }); }
public static boolean matches(java.lang.String refName, java.lang.String refPattern) { if (refPattern.endsWith("/*")) { java.lang.String prefix = refPattern.substring(0, ((refPattern.length()) - 1)); return refName.startsWith(prefix); } else { return refName.equals(refPattern); } }
public java.util.List<com.google.gerrit.reviewdb.RefRight> getAllRights(final com.google.gerrit.reviewdb.ApprovalCategory.Id id) { java.util.List<com.google.gerrit.reviewdb.RefRight> l = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); l.addAll(getLocalRights(id)); l.addAll(getInheritedRights(id)); java.util.Collections.sort(l, RefRight.REF_PATTERN_ORDER); return java.util.Collections.unmodifiableList(com.google.gerrit.server.project.RefControl.filterMostSpecific(l)); }
public static java.util.List<com.google.gerrit.reviewdb.RefRight> filterMostSpecific(java.util.List<com.google.gerrit.reviewdb.RefRight> actionRights) { boolean sameRefPattern = true; java.util.List<com.google.gerrit.reviewdb.RefRight> mostSpecific = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); java.lang.String currentRefPattern = null; int i = 0; while (sameRefPattern && (i < (actionRights.size()))) { if (currentRefPattern == null) { currentRefPattern = actionRights.get(i).getRefPattern(); mostSpecific.add(actionRights.get(i)); i++; } else { if (currentRefPattern.equals(actionRights.get(i).getRefPattern())) { mostSpecific.add(actionRights.get(i)); i++; } else { sameRefPattern = false; } } } return mostSpecific; }
boolean canPerform(com.google.gerrit.reviewdb.ApprovalCategory.Id actionId, short level) { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> groups = getCurrentUser().getEffectiveGroups(); int val = java.lang.Integer.MIN_VALUE; java.util.List<com.google.gerrit.reviewdb.RefRight> allRights = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); allRights.addAll(getLocalRights(actionId)); if (actionId.canInheritFromWildProject()) { allRights.addAll(getInheritedRights(actionId)); } java.util.Collections.sort(allRights, RefRight.REF_PATTERN_ORDER); for (com.google.gerrit.reviewdb.RefRight right : com.google.gerrit.server.project.RefControl.filterMostSpecific(allRights)) { if (groups.contains(right.getAccountGroupId())) { val = java.lang.Math.max(right.getMaxValue(), val); } } return val >= level; }

static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.ActiveSession.Key, com.google.gerrit.reviewdb.ActiveSession>> type = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.ActiveSession.Key, com.google.gerrit.reviewdb.ActiveSession>>() {}; core(type, com.google.gerrit.httpd.WebSession.CACHE_NAME).memoryLimit(1024).maxAge(12, java.util.concurrent.TimeUnit.HOURS).evictionPolicy(EvictionPolicy.LRU); bind(com.google.gerrit.httpd.WebSession.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.httpd.WebSession.KeyGenerator.class).in(com.google.gerrit.httpd.SINGLETON); } }; }
@java.lang.Override protected void configure() { final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.ActiveSession.Key, com.google.gerrit.reviewdb.ActiveSession>> type = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.ActiveSession.Key, com.google.gerrit.reviewdb.ActiveSession>>() {}; core(type, com.google.gerrit.httpd.WebSession.CACHE_NAME).memoryLimit(1024).maxAge(12, java.util.concurrent.TimeUnit.HOURS).evictionPolicy(EvictionPolicy.LRU); bind(com.google.gerrit.httpd.WebSession.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.httpd.WebSession.KeyGenerator.class).in(com.google.gerrit.httpd.SINGLETON); }
private java.util.List<com.google.gerrit.reviewdb.RefRight> filter(java.util.Collection<com.google.gerrit.reviewdb.RefRight> all) { java.util.List<com.google.gerrit.reviewdb.RefRight> mine = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(all.size()); for (com.google.gerrit.reviewdb.RefRight right : all) { if (com.google.gerrit.server.project.RefControl.matches(getRefName(), right.getRefPattern())) { mine.add(right); } } return mine; }
public static boolean matches(java.lang.String refName, java.lang.String refPattern) { if (refPattern.endsWith("/*")) { java.lang.String prefix = refPattern.substring(0, ((refPattern.length()) - 1)); return refName.startsWith(prefix); } else { return refName.equals(refPattern); } }


public com.google.gerrit.server.events.ChangeAttribute asChangeAttribute(final com.google.gerrit.reviewdb.Change change) { com.google.gerrit.server.events.ChangeAttribute a = new com.google.gerrit.server.events.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.id = change.getKey().get(); a.number = change.getId().toString(); a.subject = change.getSubject(); a.url = getChangeUrl(change); final com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); a.owner = asAccountAttribute(owner.getAccount()); return a; }




@java.lang.Override protected void init() { super.init(); ccAllApprovals(); bccStarredBy(); bccWatchesNotifyAllComments(); }
public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project.NameKey nameKey = new com.google.gerrit.reviewdb.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); final com.google.gerrit.reviewdb.AccountProjectWatch watch = new com.google.gerrit.reviewdb.AccountProjectWatch(new com.google.gerrit.reviewdb.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey)); db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); }
public void onSuccess(final com.google.gerrit.common.data.AccountProjectWatchInfo result) { addNew.setEnabled(true); nameTxt.setText(""); watches.insertWatch(result); }
void doAddNew() { final java.lang.String projectName = nameTxt.getText(); if (((projectName == null) || ((projectName.length()) == 0)) || (Util.C.defaultProjectName().equals(projectName))) { return; } addNew.setEnabled(false); Util.ACCOUNT_SVC.addProjectWatch(projectName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.AccountProjectWatchInfo>() { public void onSuccess(final com.google.gerrit.common.data.AccountProjectWatchInfo result) { addNew.setEnabled(true); nameTxt.setText(""); watches.insertWatch(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { addNew.setEnabled(true); super.onFailure(caught); } }); }
protected void bccWatchesNotifyAllComments() { if ((db) != null) { try { final com.google.gerrit.server.project.ProjectState ps = getProjectState(); if (ps != null) { for (final com.google.gerrit.reviewdb.AccountProjectWatch w : db.accountProjectWatches().notifyAllComments(ps.getProject().getNameKey())) { add(RecipientType.BCC, w.getAccountId()); } } } catch (com.google.gwtorm.client.OrmException err) { } } }
@java.lang.Override public com.google.gerrit.reviewdb.com.google.gwtorm<?>[] members() { return new com.google.gwtorm.client.Key<?>[]{ projectName }; }

@com.google.gerrit.common.auth.SignInRequired void addProjectWatch(java.lang.String projectName, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.data.AccountProjectWatchInfo> callback);
private void bccWatchesNotifySubmittedChanges() { if ((db) != null) { try { final com.google.gerrit.server.project.ProjectState ps = getProjectState(); if (ps != null) { for (com.google.gerrit.reviewdb.AccountProjectWatch w : db.accountProjectWatches().notifySubmittedChanges(ps.getProject().getNameKey())) { add(RecipientType.BCC, w.getAccountId()); } } } catch (com.google.gwtorm.client.OrmException err) { } } }
@java.lang.Override protected void init() { super.init(); ccAllApprovals(); bccStarredBy(); bccWatchesNotifyAllComments(); bccWatchesNotifySubmittedChanges(); }

private void bccWatchers() { if ((db) != null) { try { final com.google.gerrit.server.project.ProjectState ps = getProjectState(); if (ps != null) { final java.util.Set<com.google.gerrit.reviewdb.Account.Id> owners = new java.util.HashSet<com.google.gerrit.reviewdb.Account.Id>(); for (com.google.gerrit.reviewdb.AccountGroup.Id g : getProjectOwners()) { for (com.google.gerrit.reviewdb.AccountGroupMember m : db.accountGroupMembers().byGroup(g)) { owners.add(m.getAccountId()); } } for (com.google.gerrit.reviewdb.AccountProjectWatch w : db.accountProjectWatches().notifyNewChanges(ps.getProject().getNameKey())) { if (owners.contains(w.getAccountId())) { add(RecipientType.TO, w.getAccountId()); } else { add(RecipientType.BCC, w.getAccountId()); } } } } catch (com.google.gwtorm.client.OrmException err) { } } }

public void addProjectWatch(final java.lang.String projectName, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.data.AccountProjectWatchInfo> callback) { run(callback, new com.google.gerrit.httpd.rpc.account.Action<com.google.gerrit.common.data.AccountProjectWatchInfo>() { public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project.NameKey nameKey = new com.google.gerrit.reviewdb.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); final com.google.gerrit.reviewdb.AccountProjectWatch watch = new com.google.gerrit.reviewdb.AccountProjectWatch(new com.google.gerrit.reviewdb.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey)); db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); } }); }


@java.lang.Override protected void init() { super.init(); ccAllApprovals(); bccStarredBy(); bccWatchesNotifyAllComments(); }

public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> get(java.lang.String username) { return cache.get(username); }
@java.lang.Override protected void configure() { final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.Account.Id, com.google.gerrit.server.account.AccountState>> byIdType = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.Account.Id, com.google.gerrit.server.account.AccountState>>() {}; core(byIdType, com.google.gerrit.server.account.AccountCacheImpl.BYID_NAME).populateWith(com.google.gerrit.server.account.AccountCacheImpl.ByIdLoader.class); final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.Account.Id>> byUsernameType = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.Account.Id>>() {}; core(byUsernameType, com.google.gerrit.server.account.AccountCacheImpl.BYUSER_NAME).populateWith(com.google.gerrit.server.account.AccountCacheImpl.ByNameLoader.class); bind(com.google.gerrit.server.account.AccountCacheImpl.class); bind(com.google.gerrit.server.account.AccountCache.class).to(com.google.gerrit.server.account.AccountCacheImpl.class); }
@java.lang.Override public int compare(final org.eclipse.jgit.diff.Edit o1, final org.eclipse.jgit.diff.Edit o2) { return (o1.getBeginA()) - (o2.getBeginA()); }
private void ensureCommentsVisible(final com.google.gerrit.common.data.CommentDetail comments) { if ((comments.getCommentsA().isEmpty()) && (comments.getCommentsB().isEmpty())) { return; } final java.util.List<org.eclipse.jgit.diff.Edit> empty = new java.util.ArrayList<org.eclipse.jgit.diff.Edit>(); int lastLine; lastLine = -1; for (com.google.gerrit.reviewdb.PatchLineComment plc : comments.getCommentsA()) { final int a = plc.getLine(); if (lastLine != a) { final int b = mapA2B((a - 1)); if (0 <= b) { safeAdd(empty, new org.eclipse.jgit.diff.Edit((a - 1), b)); } lastLine = a; } } lastLine = -1; for (com.google.gerrit.reviewdb.PatchLineComment plc : comments.getCommentsB()) { final int b = plc.getLine(); if (lastLine != b) { final int a = mapB2A((b - 1)); if (0 <= a) { safeAdd(empty, new org.eclipse.jgit.diff.Edit(a, (b - 1))); } lastLine = b; } } edits.addAll(empty); java.util.Collections.sort(edits, com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder.EDIT_SORT); }
public void evictByUsername(java.lang.String username) { byName.remove(username); }
public com.google.gerrit.reviewdb.Patch.ChangeType getChangeType() { return changeType; }
private void packContent(boolean ignoredWhitespace) { com.google.gerrit.prettify.common.EditList list = new com.google.gerrit.prettify.common.EditList(edits, context, a.size(), b.size()); for (final com.google.gerrit.prettify.common.EditList.Hunk hunk : list.getHunks()) { while (hunk.next()) { if (hunk.isContextLine()) { final java.lang.String lineA = a.src.getLine(hunk.getCurA()); a.dst.addLine(hunk.getCurA(), lineA); if (ignoredWhitespace) { final java.lang.String lineB = b.src.getLine(hunk.getCurB()); if (!(lineA.equals(lineB))) { b.dst.addLine(hunk.getCurB(), lineB); } } hunk.incBoth(); continue; } if (hunk.isDeletedA()) { a.addLine(hunk.getCurA()); hunk.incA(); } if (hunk.isInsertedB()) { b.addLine(hunk.getCurB()); hunk.incB(); } } } }
private int mapB2A(final int b) { if (edits.isEmpty()) { return b; } for (int i = 0; i < (edits.size()); i++) { final org.eclipse.jgit.diff.Edit e = edits.get(i); if (b < (e.getBeginB())) { if (i == 0) { return b; } return (e.getBeginA()) - ((e.getBeginB()) - b); } if (((e.getBeginB()) <= b) && (b <= (e.getEndB()))) { return -1; } } final org.eclipse.jgit.diff.Edit last = edits.get(((edits.size()) - 1)); return (last.getBeginA()) + (b - (last.getEndB())); }
@java.lang.Override public boolean equals(final java.lang.Object o) { if (o instanceof com.google.gerrit.server.patch.PatchListKey) { final com.google.gerrit.server.patch.PatchListKey k = ((com.google.gerrit.server.patch.PatchListKey) (o)); return ((com.google.gerrit.server.patch.PatchListKey.eq(oldId, k.oldId)) && (com.google.gerrit.server.patch.PatchListKey.eq(newId, k.newId))) && ((whitespace) == (k.whitespace)); } return false; }
static com.google.gerrit.server.patch.PatchListEntry readFrom(final java.io.InputStream in) throws java.io.IOException { final com.google.gerrit.reviewdb.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.Patch.ChangeType.values()); final com.google.gerrit.reviewdb.Patch.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.Patch.PatchType.values()); final java.lang.String oldName = readString(in); final java.lang.String newName = readString(in); final byte[] hdr = readBytes(in); final int editCount = readVarInt32(in); final org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { editArray[i] = com.google.gerrit.server.patch.PatchListEntry.readEdit(in); int innerCount = readVarInt32(in); if (0 < innerCount) { org.eclipse.jgit.diff.Edit[] inner = new org.eclipse.jgit.diff.Edit[innerCount]; for (int innerIdx = 0; innerIdx < innerCount; innerIdx++) { inner[innerIdx] = com.google.gerrit.server.patch.PatchListEntry.readEdit(in); } editArray[i] = new org.eclipse.jgit.diff.ReplaceEdit(editArray[i], com.google.gerrit.server.patch.PatchListEntry.toList(inner)); } } return new com.google.gerrit.server.patch.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.gerrit.server.patch.PatchListEntry.toList(editArray)); }
private int mapA2B(final int a) { if (edits.isEmpty()) { return a; } for (int i = 0; i < (edits.size()); i++) { final org.eclipse.jgit.diff.Edit e = edits.get(i); if (a < (e.getBeginA())) { if (i == 0) { return a; } return (e.getBeginB()) - ((e.getBeginA()) - a); } if (((e.getBeginA()) <= a) && (a <= (e.getEndA()))) { return -1; } } final org.eclipse.jgit.diff.Edit last = edits.get(((edits.size()) - 1)); return (last.getBeginB()) + (a - (last.getEndA())); }
private void write(final java.io.OutputStream out, final org.eclipse.jgit.diff.Edit e) throws java.io.IOException { writeVarInt32(out, e.getBeginA()); writeVarInt32(out, e.getEndA()); writeVarInt32(out, e.getBeginB()); writeVarInt32(out, e.getEndB()); }
@java.lang.Override public com.google.gerrit.server.account.AccountState createEntry(final com.google.gerrit.reviewdb.Account.Id key) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.server.account.AccountState state = load(db, key); if ((state.getUserName()) != null) { byName.put(state.getUserName(), state.getAccount().getId()); } return state; } finally { db.close(); } }
@java.lang.Override public Account.Id createEntry(final java.lang.String username) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.AccountExternalId.Key key = new com.google.gerrit.reviewdb.AccountExternalId.Key(com.google.gerrit.reviewdb.AccountExternalId.SCHEME_USERNAME, username); final com.google.gerrit.reviewdb.AccountExternalId id = db.accountExternalIds().get(key); return id != null ? id.getAccountId() : null; } finally { db.close(); } }
void writeTo(final java.io.OutputStream out) throws java.io.IOException { writeEnum(out, changeType); writeEnum(out, patchType); writeString(out, oldName); writeString(out, newName); writeBytes(out, header); writeVarInt32(out, edits.size()); for (final org.eclipse.jgit.diff.Edit e : edits) { write(out, e); if (e instanceof org.eclipse.jgit.diff.ReplaceEdit) { org.eclipse.jgit.diff.ReplaceEdit r = ((org.eclipse.jgit.diff.ReplaceEdit) (e)); writeVarInt32(out, r.getInternalEdits().size()); for (org.eclipse.jgit.diff.Edit i : r.getInternalEdits()) { write(out, i); } } else { writeVarInt32(out, 0); } } }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.Account.Id, com.google.gerrit.server.account.AccountState>> byIdType = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<com.google.gerrit.reviewdb.Account.Id, com.google.gerrit.server.account.AccountState>>() {}; core(byIdType, com.google.gerrit.server.account.AccountCacheImpl.BYID_NAME).populateWith(com.google.gerrit.server.account.AccountCacheImpl.ByIdLoader.class); final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.Account.Id>> byUsernameType = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.Account.Id>>() {}; core(byUsernameType, com.google.gerrit.server.account.AccountCacheImpl.BYUSER_NAME).populateWith(com.google.gerrit.server.account.AccountCacheImpl.ByNameLoader.class); bind(com.google.gerrit.server.account.AccountCacheImpl.class); bind(com.google.gerrit.server.account.AccountCache.class).to(com.google.gerrit.server.account.AccountCacheImpl.class); } }; }
static com.google.gerrit.server.patch.PatchListEntry empty(final java.lang.String fileName) { return new com.google.gerrit.server.patch.PatchListEntry(com.google.gerrit.reviewdb.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.Patch.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.patch.PatchListEntry.EMPTY_HEADER, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList()); }
@java.lang.Override public com.google.gerrit.server.account.AccountState getByUsername(java.lang.String username) { com.google.gerrit.reviewdb.Account.Id id = byName.get(username); return id != null ? byId.get(id) : null; }
public java.util.List<org.eclipse.jgit.diff.Edit> getEdits() { return edits; }
public com.google.gerrit.reviewdb.Patch.PatchType getPatchType() { return patchType; }
private void safeAdd(final java.util.List<org.eclipse.jgit.diff.Edit> empty, final org.eclipse.jgit.diff.Edit toAdd) { final int a = toAdd.getBeginA(); final int b = toAdd.getBeginB(); for (final org.eclipse.jgit.diff.Edit e : edits) { if (((e.getBeginA()) <= a) && (a <= (e.getEndA()))) { return; } if (((e.getBeginB()) <= b) && (b <= (e.getEndB()))) { return; } } empty.add(toAdd); }
public com.google.gerrit.reviewdb.AccountDiffPreference.Whitespace getWhitespace() { return whitespace; }
private static org.eclipse.jgit.diff.Edit readEdit(final java.io.InputStream in) throws java.io.IOException { final int beginA = readVarInt32(in); final int endA = readVarInt32(in); final int beginB = readVarInt32(in); final int endB = readVarInt32(in); return new org.eclipse.jgit.diff.Edit(beginA, endA, beginB, endB); }
private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException { oldId = readCanBeNull(in); newId = readNotNull(in); whitespace = readEnum(in, com.google.gerrit.reviewdb.AccountDiffPreference.Whitespace.values()); }
public com.google.gwtjsonrpc.client.VoidResult run(final com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Account.Id me = getAccountId(); final java.util.Set<com.google.gerrit.reviewdb.Change.Id> existing = currentUser.get().getStarredChanges(); java.util.List<com.google.gerrit.reviewdb.StarredChange> add = new java.util.ArrayList<com.google.gerrit.reviewdb.StarredChange>(); java.util.List<com.google.gerrit.reviewdb.StarredChange.Key> remove = new java.util.ArrayList<com.google.gerrit.reviewdb.StarredChange.Key>(); if ((req.getAddSet()) != null) { for (final com.google.gerrit.reviewdb.Change.Id id : req.getAddSet()) { if (!(existing.contains(id))) { add.add(new com.google.gerrit.reviewdb.StarredChange(new com.google.gerrit.reviewdb.StarredChange.Key(me, id))); } } } if ((req.getRemoveSet()) != null) { for (final com.google.gerrit.reviewdb.Change.Id id : req.getRemoveSet()) { remove.add(new com.google.gerrit.reviewdb.StarredChange.Key(me, id)); } } db.starredChanges().insert(add); db.starredChanges().deleteKeys(remove); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
public com.google.gerrit.server.IdentifiedUser create(final com.google.gerrit.server.AccessPath accessPath, final com.google.gerrit.reviewdb.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, dbProvider, id); }
public com.google.gerrit.server.IdentifiedUser create(com.google.gerrit.server.AccessPath accessPath, com.google.inject.Provider<java.net.SocketAddress> remotePeerProvider, com.google.gerrit.reviewdb.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(accessPath, authConfig, canonicalUrl, realm, accountCache, remotePeerProvider, null, id); }




private void start() { synchronized(lock) { if ((manager) != null) { throw new java.lang.IllegalStateException("Cache pool has already been started"); } try { java.lang.System.setProperty("net.sf.ehcache.skipUpdateCheck", ("" + true)); } catch (java.lang.SecurityException e) { } manager = new net.sf.ehcache.CacheManager(new com.google.gerrit.ehcache.EhcachePoolImpl.Factory().toConfiguration()); for (com.google.gerrit.server.cache.CacheProvider<?, ?> p : caches.values()) { net.sf.ehcache.Ehcache eh = manager.getEhcache(p.getName()); com.google.gerrit.server.cache.EntryCreator<?, ?> c = p.getEntryCreator(); if (c != null) { p.bind(new com.google.gerrit.ehcache.PopulatingCache(eh, c)); } else { p.bind(new com.google.gerrit.ehcache.SimpleCache(eh)); } } } }





public void doChangeAbandonedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final java.lang.String reason) { final com.google.gerrit.server.events.ChangeAbandonedEvent event = new com.google.gerrit.server.events.ChangeAbandonedEvent(); event.change = eventFactory.asChangeAttribute(change); event.abandoner = eventFactory.asAccountAttribute(account); event.reason = reason; fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeAbandonedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--change-url"); args.add(event.change.url); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--abandoner"); args.add(getDisplayName(account)); args.add("--reason"); args.add((reason == null ? "" : reason)); runHook(getRepo(change), args); }
public void doChangeMergedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.Account account, final com.google.gerrit.reviewdb.PatchSet patchSet) { final com.google.gerrit.server.events.ChangeMergedEvent event = new com.google.gerrit.server.events.ChangeMergedEvent(); event.change = eventFactory.asChangeAttribute(change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(changeMergedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--change-url"); args.add(event.change.url); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--submitter"); args.add(getDisplayName(account)); args.add("--commit"); args.add(event.patchSet.revision); runHook(getRepo(change), args); }
public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.reviewdb.PatchSet patchSet) { final com.google.gerrit.server.events.PatchSetCreatedEvent event = new com.google.gerrit.server.events.PatchSetCreatedEvent(); final com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); args.add(patchsetCreatedHook.getAbsolutePath()); args.add("--change"); args.add(event.change.id); args.add("--change-url"); args.add(event.change.url); args.add("--project"); args.add(event.change.project); args.add("--branch"); args.add(event.change.branch); args.add("--uploader"); args.add(getDisplayName(uploader.getAccount())); args.add("--commit"); args.add(event.patchSet.revision); args.add("--patchset"); args.add(event.patchSet.number); runHook(getRepo(change), args); }

private void fireEvent(final com.google.gerrit.reviewdb.Change change, final com.google.gerrit.server.events.ChangeEvent event) { for (com.google.gerrit.common.ChangeHookRunner.ChangeListenerHolder holder : listeners.values()) { if (isVisibleTo(change, holder.user)) { holder.listener.onChangeEvent(event); } } }
private com.google.gerrit.server.events.ApprovalAttribute getApprovalAttribute(java.util.Map.Entry<com.google.gerrit.reviewdb.ApprovalCategory.Id, com.google.gerrit.reviewdb.ApprovalCategoryValue.Id> approval) { com.google.gerrit.server.events.ApprovalAttribute a = new com.google.gerrit.server.events.ApprovalAttribute(); a.type = approval.getKey().get(); final com.google.gerrit.common.data.ApprovalType at = approvalTypes.getApprovalType(approval.getKey()); a.description = at.getCategory().getName(); a.value = java.lang.Short.toString(approval.getValue().get()); return a; }

@com.google.gwtorm.client.Relation com.google.gwtorm.data.PersonAccess people();
@com.google.gwtorm.client.Relation com.google.gwtorm.data.AddressAccess addresses();
@com.google.gwtorm.client.Relation com.google.gwtorm.data.PersonAccess2 people();


@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountPatchReviewAccess accountPatchReviews();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.PatchSetApprovalAccess patchSetApprovals();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ActiveSessionAccess activeSessions();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountSshKeyAccess accountSshKeys();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ProjectAccess projects();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.PatchLineCommentAccess patchComments();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ChangeMessageAccess changeMessages();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.SchemaVersionAccess schemaVersion();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountGroupAgreementAccess accountGroupAgreements();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountExternalIdAccess accountExternalIds();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.RefRightAccess refRights();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ApprovalCategoryAccess approvalCategories();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.SystemConfigAccess systemConfig();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.PatchSetAccess patchSets();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountGroupNameAccess accountGroupNames();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountProjectWatchAccess accountProjectWatches();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.TrackingIdAccess trackingIds();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountAccess accounts();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ChangeAccess changes();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ApprovalCategoryValueAccess approvalCategoryValues();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.ContributorAgreementAccess contributorAgreements();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountAgreementAccess accountAgreements();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountGroupMemberAuditAccess accountGroupMembersAudit();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountGroupMemberAccess accountGroupMembers();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.PatchSetAncestorAccess patchSetAncestors();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.StarredChangeAccess starredChanges();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountGroupAccess accountGroups();
@com.google.gwtorm.client.Relation com.google.gerrit.reviewdb.AccountDiffPreferenceAccess accountDiffPreferences();
@com.google.gerrit.server.query.change.Rewrite("status:merged S=(sortkey_before:*) L=(limit:*)") public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> r20_byMergedNext(@com.google.inject.name.Named("S") final com.google.gerrit.server.query.change.SortKeyPredicate.Before s, @com.google.inject.name.Named("L") final com.google.gerrit.server.query.IntPredicate<com.google.gerrit.server.query.change.ChangeData> l) { return new com.google.gerrit.server.query.change.ChangeQueryRewriter.PaginatedSource(50000, s.getValue(), l.intValue()) { @java.lang.Override com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> scan(com.google.gerrit.reviewdb.ChangeAccess a, java.lang.String key, int limit) throws com.google.gwtorm.client.OrmException { return a.allClosedNext(Change.Status.MERGED.getCode(), key, limit); } @java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.client.OrmException { return ((cd.change(dbProvider).getStatus()) == (Change.Status.MERGED)) && (s.match(cd)); } }; }
@com.google.gerrit.server.query.change.Rewrite("status:merged S=(sortkey_after:*) L=(limit:*)") public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> r20_byMergedPrev(@com.google.inject.name.Named("S") final com.google.gerrit.server.query.change.SortKeyPredicate.After s, @com.google.inject.name.Named("L") final com.google.gerrit.server.query.IntPredicate<com.google.gerrit.server.query.change.ChangeData> l) { return new com.google.gerrit.server.query.change.ChangeQueryRewriter.PaginatedSource(50000, s.getValue(), l.intValue()) { @java.lang.Override com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> scan(com.google.gerrit.reviewdb.ChangeAccess a, java.lang.String key, int limit) throws com.google.gwtorm.client.OrmException { return a.allClosedPrev(Change.Status.MERGED.getCode(), key, limit); } @java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.client.OrmException { return ((cd.change(dbProvider).getStatus()) == (Change.Status.MERGED)) && (s.match(cd)); } }; }
@com.google.gerrit.server.query.change.Rewrite("status:abandoned S=(sortkey_before:*) L=(limit:*)") public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> r20_byAbandonedNext(@com.google.inject.name.Named("S") final com.google.gerrit.server.query.change.SortKeyPredicate.Before s, @com.google.inject.name.Named("L") final com.google.gerrit.server.query.IntPredicate<com.google.gerrit.server.query.change.ChangeData> l) { return new com.google.gerrit.server.query.change.ChangeQueryRewriter.PaginatedSource(50000, s.getValue(), l.intValue()) { @java.lang.Override com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> scan(com.google.gerrit.reviewdb.ChangeAccess a, java.lang.String key, int limit) throws com.google.gwtorm.client.OrmException { return a.allClosedNext(Change.Status.ABANDONED.getCode(), key, limit); } @java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.client.OrmException { return ((cd.change(dbProvider).getStatus()) == (Change.Status.ABANDONED)) && (s.match(cd)); } }; }
@com.google.gerrit.server.query.change.Rewrite("status:abandoned S=(sortkey_after:*) L=(limit:*)") public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> r20_byAbandonedPrev(@com.google.inject.name.Named("S") final com.google.gerrit.server.query.change.SortKeyPredicate.After s, @com.google.inject.name.Named("L") final com.google.gerrit.server.query.IntPredicate<com.google.gerrit.server.query.change.ChangeData> l) { return new com.google.gerrit.server.query.change.ChangeQueryRewriter.PaginatedSource(50000, s.getValue(), l.intValue()) { @java.lang.Override com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> scan(com.google.gerrit.reviewdb.ChangeAccess a, java.lang.String key, int limit) throws com.google.gwtorm.client.OrmException { return a.allClosedPrev(Change.Status.ABANDONED.getCode(), key, limit); } @java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.client.OrmException { return ((cd.change(dbProvider).getStatus()) == (Change.Status.ABANDONED)) && (s.match(cd)); } }; }
protected void initName(final java.lang.String method, final com.google.gwtorm.client.Relation rel) throws com.google.gwtorm.client.OrmException { if (rel == null) { throw new com.google.gwtorm.client.OrmException((((("Method " + method) + " is missing ") + (com.google.gwtorm.client.Relation.class.getName())) + " annotation")); } relation = rel; methodName = method; relationName = com.google.gwtorm.schema.Util.any(relation.name(), com.google.gwtorm.schema.Util.makeSqlFriendly(methodName)); }


private void send(final java.util.List<org.eclipse.jgit.transport.RemoteRefUpdate> cmds, final org.eclipse.jgit.transport.RefSpec spec) throws java.io.IOException { final java.lang.String src = spec.getSource(); final java.lang.String dst = spec.getDestination(); final boolean force = spec.isForceUpdate(); cmds.add(new org.eclipse.jgit.transport.RemoteRefUpdate(db, src, dst, force, null, null)); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.reviewdb.ReviewDb.class).toProvider(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(com.google.gerrit.server.account.AccountResolver.class); bind(com.google.gerrit.server.query.change.ChangeQueryRewriter.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(GroupControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(ChangeQueryBuilder.Factory.class); factory(ReceiveCommits.Factory.class); factory(MergeOp.Factory.class); factory(AddReviewerSender.Factory.class); factory(CreateChangeSender.Factory.class); factory(PublishComments.Factory.class); factory(ReplacePatchSetSender.Factory.class); factory(AbandonedSender.Factory.class); factory(CommentSender.Factory.class); factory(MergedSender.Factory.class); factory(MergeFailSender.Factory.class); factory(RegisterNewEmailSender.Factory.class); }
@java.lang.Override public com.google.gwtorm.client.ResultSet<com.google.gerrit.server.query.change.ChangeData> read() throws com.google.gwtorm.client.OrmException { com.google.gerrit.server.query.change.ChangeDataSource source = source(); if (source == null) { throw new com.google.gwtorm.client.OrmException(("No ChangeDataSource: " + (this))); } java.util.ArrayList<com.google.gerrit.server.query.change.ChangeData> r = new java.util.ArrayList<com.google.gerrit.server.query.change.ChangeData>(); com.google.gerrit.server.query.change.ChangeData last = null; boolean skipped = false; for (com.google.gerrit.server.query.change.ChangeData data : source.read()) { if (match(data)) { r.add(data); } else { skipped = true; } last = data; } if ((skipped && (last != null)) && (source instanceof com.google.gerrit.server.query.change.Paginated)) { com.google.gerrit.server.query.change.Paginated p = ((com.google.gerrit.server.query.change.Paginated) (source)); while (skipped && ((r.size()) < (p.limit()))) { com.google.gerrit.server.query.change.ChangeData lastBeforeRestart = last; skipped = false; last = null; for (com.google.gerrit.server.query.change.ChangeData data : p.restart(lastBeforeRestart)) { if (match(data)) { r.add(data); } else { skipped = true; } last = data; } } } return new com.google.gwtorm.client.impl.ListResultSet<com.google.gerrit.server.query.change.ChangeData>(r); }

@java.lang.Override public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> and(java.util.Collection<? extends com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> l) { return com.google.gerrit.server.query.change.ChangeQueryRewriter.hasSource(l) ? new com.google.gerrit.server.query.change.AndSource(l) : super.and(l); }

@java.lang.Override public void onRequestSuggestions(final com.google.gerrit.client.ui.Request req, final com.google.gerrit.client.ui.Callback callback) { com.google.gerrit.client.RpcStatus.hide(new java.lang.Runnable() { public void run() { SuggestUtil.SVC.suggestAccount(req.getQuery(), req.getLimit(), new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.AccountInfo>>() { public void onSuccess(final java.util.List<com.google.gerrit.common.data.AccountInfo> result) { final java.util.ArrayList<com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion> r = new java.util.ArrayList<com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion>(result.size()); for (final com.google.gerrit.common.data.AccountInfo p : result) { r.add(new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); } }); } }); }
public void run() { SuggestUtil.SVC.suggestAccount(req.getQuery(), req.getLimit(), new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.AccountInfo>>() { public void onSuccess(final java.util.List<com.google.gerrit.common.data.AccountInfo> result) { final java.util.ArrayList<com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion> r = new java.util.ArrayList<com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion>(result.size()); for (final com.google.gerrit.common.data.AccountInfo p : result) { r.add(new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); } }); }





public void run() throws java.lang.Exception { ui.header("Gerrit Code Review %s", com.google.gerrit.pgm.init.InitUtil.version()); if (site.isNew) { if (!(ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath()))) { throw com.google.gerrit.pgm.init.InitUtil.die("aborted by user"); } if ((!(site.site_path.isDirectory())) && (!(site.site_path.mkdirs()))) { throw com.google.gerrit.pgm.init.InitUtil.die(("Cannot make directory " + (site.site_path))); } flags.deleteOnFailure = true; } com.google.gerrit.pgm.init.InitUtil.mkdir(site.bin_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.etc_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.lib_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.logs_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.static_dir); for (com.google.gerrit.pgm.init.InitStep step : steps) { step.run(); } com.google.gerrit.pgm.init.InitUtil.savePublic(flags.cfg); com.google.gerrit.pgm.init.InitUtil.saveSecure(flags.sec); if (!(site.replication_config.exists())) { site.replication_config.createNewFile(); } com.google.gerrit.pgm.init.InitUtil.extract(site.gerrit_sh, com.google.gerrit.pgm.Init.class, "gerrit.sh"); com.google.gerrit.pgm.init.InitUtil.chmod(493, site.gerrit_sh); if (!(ui.isBatch())) { java.lang.System.err.println(); } }
public void run() throws java.lang.Exception { ui.header("Gerrit Code Review %s", com.google.gerrit.pgm.init.InitUtil.version()); if (site.isNew) { if (!(ui.yesno(true, "Create '%s'", site.site_path.getCanonicalPath()))) { throw com.google.gerrit.pgm.init.InitUtil.die("aborted by user"); } if ((!(site.site_path.isDirectory())) && (!(site.site_path.mkdirs()))) { throw com.google.gerrit.pgm.init.InitUtil.die(("Cannot make directory " + (site.site_path))); } flags.deleteOnFailure = true; } com.google.gerrit.pgm.init.InitUtil.mkdir(site.bin_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.etc_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.lib_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.logs_dir); com.google.gerrit.pgm.init.InitUtil.mkdir(site.static_dir); for (com.google.gerrit.pgm.init.InitStep step : steps) { step.run(); } com.google.gerrit.pgm.init.InitUtil.savePublic(flags.cfg); com.google.gerrit.pgm.init.InitUtil.saveSecure(flags.sec); if (!(site.replication_config.exists())) { site.replication_config.createNewFile(); } com.google.gerrit.pgm.init.InitUtil.extract(site.gerrit_sh, com.google.gerrit.pgm.Init.class, "gerrit.sh"); com.google.gerrit.pgm.init.InitUtil.chmod(493, site.gerrit_sh); if (!(ui.isBatch())) { java.lang.System.err.println(); } }
@java.lang.Override protected void formatChange() { appendText(("Change " + (change.getKey().abbreviate()))); if ((((patchSetInfo) != null) && ((patchSetInfo.getAuthor()) != null)) && ((patchSetInfo.getAuthor().getName()) != null)) { appendText(" by "); appendText(patchSetInfo.getAuthor().getName()); } appendText(" submitted to "); appendText(dest.getShortName()); appendText(":\n\n"); formatChangeDetail(); formatApprovals(); }
@java.lang.Override protected void formatChange() { appendText(getNameFor(fromId)); appendText(((" has abandoned change " + (change.getKey().abbreviate())) + ":\n")); appendText("\n"); formatCoverLetter(); }
@java.lang.Override protected void formatChange() { formatSalutation(); formatChangeDetail(); appendText("\n"); appendText(((" " + (getPullUrl())) + "\n")); }
@java.lang.Override protected void formatChange() { formatSalutation(); formatChangeDetail(); appendText("\n"); appendText(((" " + (getPullUrl())) + "\n")); }
protected java.lang.String getChangeMessageThreadId() { final java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append('<'); r.append("gerrit"); r.append('.'); r.append(change.getCreatedOn().getTime()); r.append('.'); r.append(change.getKey().get()); r.append('@'); r.append(getGerritHost()); r.append('>'); return r.toString(); }
protected void init() { setupVelocityContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new com.google.gerrit.server.mail.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.EmailHeader.AddressList()); setHeader("Message-ID", ""); if ((fromId) != null) { final com.google.gerrit.server.mail.Address a = toAddress(fromId); if ((a != null) && (!(smtpFromAddress.email.equals(a.email)))) { setHeader("Reply-To", a.email); } } setHeader("X-Gerrit-MessageType", messageClass); body = new java.lang.StringBuilder(); if (((fromId) != null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { final com.google.gerrit.reviewdb.Account account = args.accountCache.get(fromId).getAccount(); final java.lang.String name = account.getFullName(); final java.lang.String email = account.getPreferredEmail(); if (((name != null) && (!(name.isEmpty()))) || ((email != null) && (!(email.isEmpty())))) { body.append("From"); if ((name != null) && (!(name.isEmpty()))) { body.append(" ").append(name); } if ((email != null) && (!(email.isEmpty()))) { body.append(" <").append(email).append(">"); } body.append(":\n\n"); } } }


private void setListIdHeader() { final java.lang.StringBuilder listid = new java.lang.StringBuilder(); listid.append("gerrit-"); listid.append(projectName.replace('/', '-')); listid.append("@"); listid.append(getGerritHost()); final java.lang.String listidStr = listid.toString(); setHeader("Mailing-List", ("list " + listidStr)); setHeader("List-Id", (("<" + (listidStr.replace('@', '.'))) + ">")); if ((getSettingsUrl()) != null) { setHeader("List-Unsubscribe", (("<" + (getSettingsUrl())) + ">")); } }

@java.lang.Override public org.eclipse.jgit.transport.ReceivePack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository db) throws org.eclipse.jgit.http.server.resolver.ServiceNotAuthorizedException, org.eclipse.jgit.http.server.resolver.ServiceNotEnabledException { final com.google.gerrit.server.project.ProjectControl pc = com.google.gerrit.httpd.ProjectServlet.getProjectControl(req); if ((pc.getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (pc.getCurrentUser())); final com.google.gerrit.server.git.ReceiveCommits rc = factory.create(pc, db); final com.google.gerrit.server.git.ReceiveCommits.Capable s = rc.canUpload(); if (s != (ReceiveCommits.Capable.OK)) { final java.lang.String who = user.getUserName(); final java.lang.String why = s.getMessage(); com.google.gerrit.httpd.ProjectServlet.log.warn(((("Rejected push from " + who) + ": ") + why)); throw new org.eclipse.jgit.http.server.resolver.ServiceNotEnabledException(); } rc.getReceivePack().setRefLogIdent(user.newRefLogIdent()); return rc.getReceivePack(); } else { throw new org.eclipse.jgit.http.server.resolver.ServiceNotAuthorizedException(); } }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); if (!(projectControl.allRefsAreVisible())) { up.setRefFilter(new com.google.gerrit.server.git.VisibleRefFilter(repo, projectControl, db.get())); } up.setTimeout(config.getTimeout()); try { up.upload(in, out, err); } catch (java.io.InterruptedIOException err) { throw new com.google.gerrit.sshd.commands.Failure(128, "fatal: client IO read/write timeout", err); } }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { final com.google.gerrit.server.git.ReceiveCommits receive = factory.create(projectControl, repo); com.google.gerrit.server.git.ReceiveCommits.Capable r = receive.canUpload(); if (r != (ReceiveCommits.Capable.OK)) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("\nfatal: " + (r.getMessage()))); } verifyProjectVisible("reviewer", reviewerId); verifyProjectVisible("CC", ccId); receive.addReviewers(reviewerId); receive.addExtraCC(ccId); final org.eclipse.jgit.transport.ReceivePack rp = receive.getReceivePack(); rp.setRefLogIdent(currentUser.newRefLogIdent()); rp.setTimeout(config.getTimeout()); try { rp.receive(in, out, err); } catch (java.io.InterruptedIOException err) { throw new com.google.gerrit.sshd.commands.Failure(128, "fatal: client IO read/write timeout", err); } }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) throws org.eclipse.jgit.http.server.resolver.ServiceNotEnabledException { com.google.gerrit.server.project.ProjectControl pc = com.google.gerrit.httpd.ProjectServlet.getProjectControl(req); org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); if (!(pc.allRefsAreVisible())) { up.setRefFilter(new com.google.gerrit.server.git.VisibleRefFilter(repo, pc, db.get())); } return up; }
protected java.lang.String velocifyFile(java.lang.String name) throws com.google.gerrit.server.mail.EmailException { try { java.io.StringWriter w = new java.io.StringWriter(); org.apache.velocity.app.Velocity.mergeTemplate(name, velocityContext, w); return w.toString(); } catch (org.apache.velocity.exception.ResourceNotFoundException e) { try { java.io.StringWriter w = new java.io.StringWriter(); java.lang.String pkg = "com/google/gerrit/server/mail/"; org.apache.velocity.app.Velocity.mergeTemplate((pkg + name), velocityContext, w); return w.toString(); } catch (java.lang.Exception e2) { throw new com.google.gerrit.server.mail.EmailException((("Velocity WAR template" + name) + ".\n"), e2); } } catch (java.lang.Exception e) { throw new com.google.gerrit.server.mail.EmailException((("Velocity template " + name) + ".\n"), e); } }
public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getInheritedRights(com.google.gerrit.reviewdb.ApprovalCategory.Id action) { if (action.canInheritFromWildProject()) { return com.google.gerrit.server.project.ProjectState.filter(getInheritedRights(), action); } return java.util.Collections.emptyList(); }






@java.lang.Override public void onFocus(com.google.gwt.event.dom.client.FocusEvent event) { setFocus(true); }

public void setFocus(boolean focus) { if (focus) { bugStopping = true; super.setFocus((!focus)); bugStopping = false; } super.setFocus(focus); if (focus) { focusHint(); } else if (!(bugStopping)) { blurHint(); } isFocused = focus; }
public void setHintText(java.lang.String text) { if (text == null) { if ((hintText) == null) { return; } hintFocusHandler.removeHandler(); hintFocusHandler = null; hintBlurHandler.removeHandler(); hintBlurHandler = null; hintText = null; focusHint(); return; } if ((hintText) == null) { hintText = text; hintFocusHandler = addFocusHandler(new com.google.gwt.event.dom.client.FocusHandler() { @java.lang.Override public void onFocus(com.google.gwt.event.dom.client.FocusEvent event) { setFocus(true); } }); hintBlurHandler = addBlurHandler(new com.google.gwt.event.dom.client.BlurHandler() { @java.lang.Override public void onBlur(com.google.gwt.event.dom.client.BlurEvent event) { setFocus(false); } }); } else { focusHint(); hintText = text; } if (!(isFocused)) { blurHint(); } }
void display(final com.google.gerrit.common.data.ProjectDetail result) { project = result.project; final boolean isall = com.google.gerrit.client.Gerrit.getConfig().getWildProject().equals(project.getNameKey()); submitTypePanel.setVisible((!isall)); agreementsPanel.setVisible((!isall)); useContributorAgreements.setVisible(com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()); descTxt.setText(project.getDescription()); useContributorAgreements.setValue(project.isUseContributorAgreements()); useSignedOffBy.setValue(project.isUseSignedOffBy()); setSubmitType(project.getSubmitType()); }
private void initAgreements() { final com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean> onChangeSave = new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { saveProject.setEnabled(true); } }; agreementsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); agreementsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingAgreements())); useContributorAgreements = new com.google.gwt.user.client.ui.CheckBox(Util.C.useContributorAgreements()); useContributorAgreements.addValueChangeHandler(onChangeSave); agreementsPanel.add(useContributorAgreements); useSignedOffBy = new com.google.gwt.user.client.ui.CheckBox(Util.C.useSignedOffBy(), true); useSignedOffBy.addValueChangeHandler(onChangeSave); agreementsPanel.add(useSignedOffBy); add(agreementsPanel); }



private void doSave() { project.setDescription(descTxt.getText().trim()); project.setUseContributorAgreements(useContributorAgreements.getValue()); project.setUseSignedOffBy(useSignedOffBy.getValue()); if ((submitType.getSelectedIndex()) >= 0) { project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex()))); } enableForm(false, false, false); saveProject.setEnabled(false); Util.PROJECT_SVC.changeProjectSettings(project, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType); display(result); } }); }

private void initDescription() { final com.google.gwt.user.client.ui.VerticalPanel vp = new com.google.gwt.user.client.ui.VerticalPanel(); vp.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingDescription())); descTxt = new com.google.gwtexpui.globalkey.client.NpTextArea(); descTxt.setVisibleLines(6); descTxt.setCharacterWidth(60); vp.add(descTxt); add(vp); new com.google.gerrit.client.ui.TextSaveButtonListener(descTxt, saveProject); }
private void initSubmitType() { submitTypePanel = new com.google.gwt.user.client.ui.VerticalPanel(); submitTypePanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingSubmitType())); submitType = new com.google.gwt.user.client.ui.ListBox(); for (final com.google.gerrit.reviewdb.Project.SubmitType type : Project.SubmitType.values()) { submitType.addItem(com.google.gerrit.client.admin.Util.toLongString(type), type.name()); } submitType.addChangeHandler(new com.google.gwt.event.dom.client.ChangeHandler() { @java.lang.Override public void onChange(final com.google.gwt.event.dom.client.ChangeEvent event) { saveProject.setEnabled(true); } }); submitTypePanel.add(submitType); add(submitTypePanel); }
void display(final com.google.gerrit.common.data.ProjectDetail result) { project = result.project; final boolean isall = com.google.gerrit.client.Gerrit.getConfig().getWildProject().equals(project.getNameKey()); submitTypePanel.setVisible((!isall)); agreementsPanel.setVisible((!isall)); useContributorAgreements.setVisible(com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()); descTxt.setText(project.getDescription()); useContributorAgreements.setValue(project.isUseContributorAgreements()); useSignedOffBy.setValue(project.isUseSignedOffBy()); setSubmitType(project.getSubmitType()); }




private void update() { com.google.gerrit.reviewdb.AccountDiffPreference dp = new com.google.gerrit.reviewdb.AccountDiffPreference(value); dp.setIgnoreWhitespace(getIgnoreWhitespace()); dp.setContext(getContext()); dp.setTabSize(tabWidth.getIntValue()); dp.setLineLength(colWidth.getIntValue()); dp.setSyntaxHighlighting(syntaxHighlighting.getValue()); dp.setIntralineDifference(intralineDifference.getValue()); dp.setShowWhitespaceErrors(whitespaceErrors.getValue()); dp.setShowTabs(showTabs.getValue()); value = dp; fireEvent(new com.google.gwt.event.logical.shared.ValueChangeEvent<com.google.gerrit.reviewdb.AccountDiffPreference>(dp) {}); if (com.google.gerrit.client.Gerrit.isSignedIn()) { persistDiffPreferences(); } }
@java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { if (((fileList) == null) || (fileList.isAttached())) { final com.google.gerrit.reviewdb.PatchSet.Id psid = patchKey.getParentKey(); fileList = new com.google.gerrit.client.changes.PatchTable(); fileList.setSavePointerId(("PatchTable " + psid)); Util.DETAIL_SVC.patchSetDetail(psid, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.PatchSetDetail>() { public void onSuccess(final com.google.gerrit.common.data.PatchSetDetail result) { fileList.display(result); } }); } final com.google.gerrit.client.patches.PatchBrowserPopup p = new com.google.gerrit.client.patches.PatchBrowserPopup(patchKey, fileList); p.open(); }
private com.google.gerrit.client.ui.PatchLink createLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType, com.google.gwtexpui.safehtml.client.SafeHtml before, com.google.gwtexpui.safehtml.client.SafeHtml after) { com.google.gerrit.reviewdb.Patch patch = patchList.get(index); com.google.gerrit.reviewdb.Patch.Key thisKey = patch.getKey(); com.google.gerrit.client.ui.PatchLink link; if ((patchType == (PatchScreen.Type.SIDE_BY_SIDE)) && ((patch.getPatchType()) == (Patch.PatchType.UNIFIED))) { link = new com.google.gerrit.client.ui.PatchLink.SideBySide("", thisKey, index, detail, this); } else { link = new com.google.gerrit.client.ui.PatchLink.Unified("", thisKey, index, detail, this); } com.google.gwtexpui.safehtml.client.SafeHtmlBuilder text = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); text.append(before); text.append(com.google.gerrit.client.changes.PatchTable.getFileNameOnly(patch)); text.append(after); com.google.gwtexpui.safehtml.client.SafeHtml.set(link, text); return link; }

@java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { patchSetDetail = result; if ((fileList) == null) { fileList = new com.google.gerrit.client.changes.PatchTable(); fileList.display(result); patchIndex = fileList.indexOf(patchKey); topNav.display(patchIndex, getPatchScreenType(), fileList); bottomNav.display(patchIndex, getPatchScreenType(), fileList); } refresh(true); }
@java.lang.Override protected void onLoad() { super.onLoad(); if ((patchSetDetail) == null) { Util.DETAIL_SVC.patchSetDetail(idSideB, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.PatchSetDetail>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { patchSetDetail = result; if ((fileList) == null) { fileList = new com.google.gerrit.client.changes.PatchTable(); fileList.display(result); patchIndex = fileList.indexOf(patchKey); topNav.display(patchIndex, getPatchScreenType(), fileList); bottomNav.display(patchIndex, getPatchScreenType(), fileList); } refresh(true); } }); } else { refresh(true); } }
public com.google.gerrit.client.ui.InlineHyperlink getPreviousPatchLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType) { if (0 < index) return createLink((index - 1), patchType, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.prevPatchLinkIcon()), null); return null; }
private void computeAllowed() { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> am = user.getEffectiveGroups(); final com.google.gerrit.server.project.ProjectState pe = projectCache.get(change.getProject()); for (com.google.gerrit.reviewdb.ApprovalCategory.Id category : approvalTypes.getApprovalCategories()) { com.google.gerrit.server.project.RefControl rc = pe.controlFor(user).controlForRef(change.getDest()); java.util.List<com.google.gerrit.reviewdb.RefRight> categoryRights = rc.getApplicableRights(category); computeAllowed(am, categoryRights, category); } }


@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myProjectWatch(new com.google.gerrit.client.rpc.ScreenLoadCallback<java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo>>(this) { public void preDisplay(final java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo> result) { watches.display(result); } }); }



public void onSuccess(final com.google.gwtjsonrpc.client.VoidResult result) { for (int row = 1; row < (table.getRowCount());) { final com.google.gerrit.common.data.AccountProjectWatchInfo k = getRowItem(row); if ((k != null) && (ids.contains(k.getWatch().getKey()))) { table.removeRow(row); } else { row++; } } }
void insertWatch(final com.google.gerrit.common.data.AccountProjectWatchInfo k) { final java.lang.String newName = k.getProject().getName(); int row = 1; for (; row < (table.getRowCount()); row++) { final com.google.gerrit.common.data.AccountProjectWatchInfo i = getRowItem(row); if ((i != null) && ((i.getProject().getName().compareTo(newName)) >= 0)) { break; } } table.insertRow(row); applyDataRowStyle(row); populate(row, k); }



private void enableForm(final boolean canModifyAgreements, final boolean canModifyDescription, final boolean canModifyMergeType) { submitType.setEnabled(canModifyMergeType); descTxt.setEnabled(canModifyDescription); useContributorAgreements.setEnabled(canModifyAgreements); useSignedOffBy.setEnabled(canModifyAgreements); requireChangeID.setEnabled(canModifyMergeType); saveProject.setEnabled(((canModifyAgreements || canModifyDescription) || canModifyMergeType)); }
void display(final com.google.gerrit.common.data.ProjectDetail result) { project = result.project; final boolean isall = com.google.gerrit.client.Gerrit.getConfig().getWildProject().equals(project.getNameKey()); projectOptionsPanel.setVisible((!isall)); agreementsPanel.setVisible((!isall)); useContributorAgreements.setVisible(com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()); descTxt.setText(project.getDescription()); useContributorAgreements.setValue(project.isUseContributorAgreements()); useSignedOffBy.setValue(project.isUseSignedOffBy()); requireChangeID.setValue(project.isRequireChangeID()); setSubmitType(project.getSubmitType()); }
private void initProjectOptions() { final com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean> onChangeSave = new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { saveProject.setEnabled(true); } }; submitTypePanel = new com.google.gwt.user.client.ui.VerticalPanel(); submitTypePanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingSubmitType())); submitType = new com.google.gwt.user.client.ui.ListBox(); for (final com.google.gerrit.reviewdb.Project.SubmitType type : Project.SubmitType.values()) { submitType.addItem(com.google.gerrit.client.admin.Util.toLongString(type), type.name()); } submitType.addChangeHandler(new com.google.gwt.event.dom.client.ChangeHandler() { @java.lang.Override public void onChange(final com.google.gwt.event.dom.client.ChangeEvent event) { saveProject.setEnabled(true); } }); submitTypePanel.add(submitType); add(submitTypePanel); projectOptionsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); projectOptionsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingProjectOptions())); requireChangeID = new com.google.gwt.user.client.ui.CheckBox(Util.C.requireChangeID(), true); requireChangeID.addValueChangeHandler(onChangeSave); projectOptionsPanel.add(requireChangeID); add(projectOptionsPanel); }
private void doSave() { project.setDescription(descTxt.getText().trim()); project.setUseContributorAgreements(useContributorAgreements.getValue()); project.setUseSignedOffBy(useSignedOffBy.getValue()); project.setRequireChangeID(requireChangeID.getValue()); if ((submitType.getSelectedIndex()) >= 0) { project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex()))); } enableForm(false, false, false); saveProject.setEnabled(false); Util.PROJECT_SVC.changeProjectSettings(project, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType); display(result); } }); }
public org.eclipse.jgit.lib.PersonIdent newCommitterIdent(final java.util.Date when, final java.util.TimeZone tz) { final com.google.gerrit.reviewdb.Account ua = getAccount(); java.lang.String name = ua.getFullName(); java.lang.String email = ua.getPreferredEmail(); if ((email == null) || (email.isEmpty())) { java.lang.String user = getUserName(); if ((user == null) || (user.isEmpty())) { user = "account-" + (ua.getId().toString()); } java.lang.String host; if ((canonicalUrl.get()) != null) { try { host = new java.net.URL(canonicalUrl.get()).getHost(); } catch (java.net.MalformedURLException e) { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } } else { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } email = (user + "@") + host; } if ((name == null) || (name.isEmpty())) { final int at = email.indexOf('@'); if (0 < at) { name = email.substring(0, at); } else { name = "Anonymous Coward"; } } return new org.eclipse.jgit.lib.PersonIdent(name, email, when, tz); }

@java.lang.Override public void onPostReceive(final org.eclipse.jgit.transport.ReceivePack arg0, final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { for (final org.eclipse.jgit.transport.ReceiveCommand c : commands) { if ((c.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.OK)) { if (com.google.gerrit.server.git.ReceiveCommits.isHead(c)) { switch (c.getType()) { case CREATE : autoCloseChanges(c); break; case DELETE : break; case UPDATE : case UPDATE_NONFASTFORWARD : autoCloseChanges(c); break; } } if ((com.google.gerrit.server.git.ReceiveCommits.isHead(c)) || (com.google.gerrit.server.git.ReceiveCommits.isTag(c))) { replication.scheduleUpdate(project.getNameKey(), c.getRefName()); } } } if ((!(allNewChanges.isEmpty())) && ((canonicalWebUrl) != null)) { final java.lang.String url = canonicalWebUrl; rp.sendMessage(""); rp.sendMessage("New Changes:"); for (final com.google.gerrit.reviewdb.Change.Id c : allNewChanges) { rp.sendMessage(((" " + url) + (c.get()))); } rp.sendMessage(""); } }



@java.lang.Override protected void onInitUI() { super.onInitUI(); setPageTitle(Util.C.groupListTitle()); groups = new com.google.gerrit.client.admin.GroupTable(true, com.google.gerrit.common.PageLinks.ADMIN_GROUPS); add(groups); final com.google.gwt.user.client.ui.VerticalPanel fp = new com.google.gwt.user.client.ui.VerticalPanel(); fp.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel()); fp.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingCreateGroup())); addTxt = new com.google.gwtexpui.globalkey.client.NpTextBox(); addTxt.setVisibleLength(60); addTxt.addKeyPressHandler(new com.google.gwt.event.dom.client.KeyPressHandler() { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getCharCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doCreateGroup(); } } }); fp.add(addTxt); addNew = new com.google.gwt.user.client.ui.Button(Util.C.buttonCreateGroup()); addNew.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { doCreateGroup(); } }); fp.add(addNew); add(fp); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gwt.user.client.ui.Widget sender = ((com.google.gwt.user.client.ui.Widget) (event.getSource())); if (sender == (edit)) { edit(); } else if (sender == (save)) { onSave(com.google.gerrit.client.patches.CommentEditorPanel.NULL_CALLBACK); } else if (sender == (cancel)) { render(); } else if (sender == (discard)) { onDiscard(); } }

private void initProjectOptions() { projectOptionsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); projectOptionsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingProjectOptions())); submitType = new com.google.gwt.user.client.ui.ListBox(); for (final com.google.gerrit.reviewdb.Project.SubmitType type : Project.SubmitType.values()) { submitType.addItem(com.google.gerrit.client.admin.Util.toLongString(type), type.name()); } saveEnabler.listenTo(submitType); projectOptionsPanel.add(submitType); useContentMerge = new com.google.gwt.user.client.ui.CheckBox(Util.C.useContentMerge(), true); saveEnabler.listenTo(useContentMerge); projectOptionsPanel.add(useContentMerge); requireChangeID = new com.google.gwt.user.client.ui.CheckBox(Util.C.requireChangeID(), true); saveEnabler.listenTo(requireChangeID); projectOptionsPanel.add(requireChangeID); add(projectOptionsPanel); }

private void service() throws com.google.gerrit.sshd.Failure, java.io.IOException { project = projectControl.getProjectState().getProject(); final java.lang.String name = project.getName(); try { repo = repoManager.openRepository(name); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.Failure(1, (("fatal: '" + name) + "': not a git archive"), e); } try { runImpl(); } finally { repo.close(); } }
private void update() { com.google.gerrit.reviewdb.AccountDiffPreference dp = new com.google.gerrit.reviewdb.AccountDiffPreference(getValue()); dp.setIgnoreWhitespace(getIgnoreWhitespace()); dp.setContext(getContext()); dp.setTabSize(tabWidth.getIntValue()); dp.setLineLength(colWidth.getIntValue()); dp.setSyntaxHighlighting(syntaxHighlighting.getValue()); dp.setIntralineDifference(intralineDifference.getValue()); dp.setShowWhitespaceErrors(whitespaceErrors.getValue()); dp.setShowTabs(showTabs.getValue()); dp.setSkipDeleted(skipDeleted.getValue()); dp.setSkipUncommented(skipUncommented.getValue()); listenablePrefs.set(dp); if (com.google.gerrit.client.Gerrit.isSignedIn()) { persistDiffPreferences(); } }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.reviewdb.ReviewDb.class).toProvider(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(com.google.gerrit.server.account.AccountResolver.class); bind(com.google.gerrit.server.query.change.ChangeQueryRewriter.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(GroupControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(ChangeQueryBuilder.Factory.class); factory(ReceiveCommits.Factory.class); factory(MergeOp.Factory.class); factory(AddReviewerSender.Factory.class); factory(CreateChangeSender.Factory.class); factory(PublishComments.Factory.class); factory(ReplacePatchSetSender.Factory.class); factory(AbandonedSender.Factory.class); factory(CommentSender.Factory.class); factory(MergedSender.Factory.class); factory(MergeFailSender.Factory.class); factory(RegisterNewEmailSender.Factory.class); }
@java.lang.Override public AccountGroup.Id call() throws com.google.gerrit.common.errors.NameAlreadyUsedException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.AccountGroup.NameKey key = new com.google.gerrit.reviewdb.AccountGroup.NameKey(name); if ((db.accountGroupNames().get(key)) != null) { throw new com.google.gerrit.common.errors.NameAlreadyUsedException(); } final com.google.gerrit.reviewdb.AccountGroup.Id id = new com.google.gerrit.reviewdb.AccountGroup.Id(db.nextAccountGroupId()); final com.google.gerrit.reviewdb.Account.Id me = user.getAccountId(); final com.google.gerrit.reviewdb.AccountGroup group = new com.google.gerrit.reviewdb.AccountGroup(key, id); db.accountGroups().insert(java.util.Collections.singleton(group)); try { final com.google.gerrit.reviewdb.AccountGroupName n = new com.google.gerrit.reviewdb.AccountGroupName(group); db.accountGroupNames().insert(java.util.Collections.singleton(n)); } catch (com.google.gwtorm.client.OrmDuplicateKeyException dupeErr) { db.accountGroups().delete(java.util.Collections.singleton(group)); throw new com.google.gerrit.common.errors.NameAlreadyUsedException(); } com.google.gerrit.reviewdb.AccountGroupMember member = new com.google.gerrit.reviewdb.AccountGroupMember(new com.google.gerrit.reviewdb.AccountGroupMember.Key(me, id)); db.accountGroupMembersAudit().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.AccountGroupMemberAudit(member, me))); db.accountGroupMembers().insert(java.util.Collections.singleton(member)); accountCache.evict(me); return id; }
@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.mail.EmailException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl control = changeControlFactory.validateFor(changeId); if (!(control.canAbandon())) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } com.google.gerrit.reviewdb.Change change = control.getChange(); final com.google.gerrit.reviewdb.PatchSet patch = db.patchSets().get(patchSetId); if (patch == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } final com.google.gerrit.reviewdb.ChangeMessage cmsg = new com.google.gerrit.reviewdb.ChangeMessage(new com.google.gerrit.reviewdb.ChangeMessage.Key(changeId, com.google.gerrit.server.ChangeUtil.messageUUID(db)), currentUser.getAccountId()); final java.lang.StringBuilder msgBuf = new java.lang.StringBuilder((("Patch Set " + (patchSetId.get())) + ": Abandoned")); if (((message) != null) && ((message.length()) > 0)) { msgBuf.append("\n\n"); msgBuf.append(message); } cmsg.setMessage(msgBuf.toString()); change = db.changes().atomicUpdate(changeId, new com.google.gwtorm.client.AtomicUpdate<com.google.gerrit.reviewdb.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.Change update(com.google.gerrit.reviewdb.Change change) { if ((change.getStatus().isOpen()) && (change.currentPatchSetId().equals(patchSetId))) { change.setStatus(Change.Status.ABANDONED); com.google.gerrit.server.ChangeUtil.updated(change); return change; } else { return null; } } }); if (change != null) { db.changeMessages().insert(java.util.Collections.singleton(cmsg)); final java.util.List<com.google.gerrit.reviewdb.PatchSetApproval> approvals = db.patchSetApprovals().byChange(changeId).toList(); for (com.google.gerrit.reviewdb.PatchSetApproval a : approvals) { a.cache(change); } db.patchSetApprovals().update(approvals); final com.google.gerrit.server.mail.AbandonedSender cm = abandonedSenderFactory.create(change); cm.setFrom(currentUser.getAccountId()); cm.setChangeMessage(cmsg); cm.send(); } hooks.doChangeAbandonedHook(change, currentUser.getAccount(), message); return changeDetailFactory.create(changeId).call(); }


@java.lang.Override public void replicateNewProject(com.google.gerrit.reviewdb.Project.NameKey projectName, java.lang.String head) { if (!(isEnabled())) { return; } for (com.google.gerrit.server.git.PushReplication.ReplicationConfig config : configs) { java.util.List<org.eclipse.jgit.transport.URIish> uriList = config.getURIs(projectName, "*"); for (org.eclipse.jgit.transport.URIish uri : uriList) { replicateProject(uri, head); } } }

public java.util.List<com.google.gerrit.reviewdb.AccountGroup> run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.server.IdentifiedUser user = identifiedUser.get(); final java.util.List<com.google.gerrit.reviewdb.AccountGroup> result; if (user.isAdministrator()) { result = db.accountGroups().all().toList(); } else { final java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id> seen = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id>(); result = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup.Id myGroup : user.getEffectiveGroups()) { for (com.google.gerrit.reviewdb.AccountGroup group : db.accountGroups().ownedByGroup(myGroup)) { final com.google.gerrit.reviewdb.AccountGroup.Id id = group.getId(); if (!(seen.add(id))) { continue; } try { com.google.gerrit.server.account.GroupControl c = groupControlFactory.controlFor(id); if (c.isOwner()) { result.add(c.getAccountGroup()); } } catch (NoSuchGroupException e) { continue; } } } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.AccountGroup>() { public int compare(final com.google.gerrit.reviewdb.AccountGroup a, final com.google.gerrit.reviewdb.AccountGroup b) { return a.getName().compareTo(b.getName()); } }); return result; }






public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { com.google.gerrit.sshd.SshScope.Context old = com.google.gerrit.sshd.SshScope.set(context); java.lang.String message; try { message = messageFactory.get().getMessage(); } finally { com.google.gerrit.sshd.SshScope.set(old); } err.write(org.eclipse.jgit.lib.Constants.encodeASCII(message.toString())); err.flush(); in.close(); out.close(); err.close(); exit.onExit(127); }













@java.lang.Override public AccountGroup.Id call() throws com.google.gerrit.common.errors.NameAlreadyUsedException, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.account.PerformCreateGroup performCreateGroup = performCreateGroupFactory.create(); final com.google.gerrit.reviewdb.Account.Id me = user.getAccountId(); return performCreateGroup.createGroup(groupName, null, null, me); }






@java.lang.Override protected void onInitUI() { super.onInitUI(); initName(); initOwner(); initDescription(); initGroupType(); initMemberList(); initExternal(); }
@java.lang.Override public com.google.gerrit.common.data.GroupDetail call() throws com.google.gerrit.server.account.NoSuchGroupException, com.google.gwtorm.client.OrmException { control = groupControl.validateFor(groupId); final com.google.gerrit.reviewdb.AccountGroup group = control.getAccountGroup(); final com.google.gerrit.common.data.GroupDetail detail = new com.google.gerrit.common.data.GroupDetail(); detail.setGroup(group); detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId())); switch (group.getType()) { case INTERNAL : detail.setMembers(loadMembers()); break; } detail.setAccounts(aic.create()); return detail; }







@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getEffectiveGroups() { if ((effectiveGroups) == null) { if (authConfig.isIdentityTrustable(state().getExternalIds())) { effectiveGroups = realm.groups(state()); } else { effectiveGroups = authConfig.getRegisteredGroups(); } } return effectiveGroups; }
private void addMembers(final com.google.gerrit.reviewdb.AccountGroup.Id groupId, final com.google.gerrit.reviewdb.Account... members) throws com.google.gwtorm.client.OrmException { final java.util.List<com.google.gerrit.reviewdb.AccountGroupMember> memberships = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroupMember>(); final java.util.List<com.google.gerrit.reviewdb.AccountGroupMemberAudit> membershipsAudit = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroupMemberAudit>(); for (com.google.gerrit.reviewdb.Account.Id accountId : members) { final com.google.gerrit.reviewdb.AccountGroupMember membership = new com.google.gerrit.reviewdb.AccountGroupMember(new com.google.gerrit.reviewdb.AccountGroupMember.Key(accountId, groupId)); memberships.add(membership); final com.google.gerrit.reviewdb.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.AccountGroupMemberAudit(membership, currentUser.getAccountId()); membershipsAudit.add(audit); } db.accountGroupMembers().insert(memberships); db.accountGroupMembersAudit().insert(membershipsAudit); for (com.google.gerrit.reviewdb.Account.Id accountId : members) { accountCache.evict(accountId); } }
public AccountGroup.Id createGroup(final java.lang.String groupName, final java.lang.String groupDescription, final com.google.gerrit.reviewdb.AccountGroup.Id ownerGroupId, final com.google.gerrit.reviewdb.Account... initialMembers) throws com.google.gerrit.common.errors.NameAlreadyUsedException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.AccountGroup.Id groupId = new com.google.gerrit.reviewdb.AccountGroup.Id(db.nextAccountGroupId()); final com.google.gerrit.reviewdb.AccountGroup.NameKey nameKey = new com.google.gerrit.reviewdb.AccountGroup.NameKey(groupName); final com.google.gerrit.reviewdb.AccountGroup group = new com.google.gerrit.reviewdb.AccountGroup(nameKey, groupId); if (ownerGroupId != null) { group.setOwnerGroupId(ownerGroupId); } if (groupDescription != null) { group.setDescription(groupDescription); } final com.google.gerrit.reviewdb.AccountGroupName gn = new com.google.gerrit.reviewdb.AccountGroupName(group); try { db.accountGroupNames().insert(java.util.Collections.singleton(gn)); } catch (com.google.gwtorm.client.OrmDuplicateKeyException e) { throw new com.google.gerrit.common.errors.NameAlreadyUsedException(); } db.accountGroups().insert(java.util.Collections.singleton(group)); addMembers(groupId, initialMembers); return groupId; }


private void display(final com.google.gerrit.common.data.GroupDetail result) { final com.google.gerrit.reviewdb.AccountGroup group = result.group; setPageTitle(Util.M.group(group.getName())); groupNameTxt.setText(group.getName()); if ((result.ownerGroup) != null) { ownerTxt.setText(result.ownerGroup.getName()); } else { ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get())); } descTxt.setText(group.getDescription()); switch (group.getType()) { case INTERNAL : accounts = result.accounts; members.display(result.members); break; case LDAP : externalName.setText(((group.getExternalNameKey()) != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected())); break; } setType(group.getType()); }

private void setType(final com.google.gerrit.reviewdb.AccountGroup.Type newType) { final boolean system = newType == (AccountGroup.Type.SYSTEM); typeSystem.setVisible(system); typeSelect.setVisible((!system)); saveType.setVisible((!system)); memberPanel.setVisible((newType == (AccountGroup.Type.INTERNAL))); externalPanel.setVisible((newType == (AccountGroup.Type.LDAP))); externalNameFilter.setText(groupNameTxt.getText()); if (!system) { for (int i = 0; i < (typeSelect.getItemCount()); i++) { if (newType.name().equals(typeSelect.getValue(i))) { typeSelect.setSelectedIndex(i); break; } } } saveType.setEnabled(false); }






public com.google.gerrit.common.data.GroupDetail run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.account.Failure, com.google.gerrit.server.account.NoSuchGroupException, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.account.GroupControl control = groupControlFactory.validateFor(groupId); if ((control.getAccountGroup().getType()) != (AccountGroup.Type.INTERNAL)) { throw new com.google.gerrit.httpd.rpc.account.Failure(new com.google.gerrit.common.errors.NameAlreadyUsedException()); } final com.google.gerrit.reviewdb.Account a = findAccount(nameOrEmail); if (!(a.isActive())) { throw new com.google.gerrit.httpd.rpc.account.Failure(new com.google.gerrit.common.errors.InactiveAccountException(a.getFullName())); } if (!(control.canAdd(a.getId()))) { throw new com.google.gerrit.httpd.rpc.account.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } final com.google.gerrit.reviewdb.AccountGroupMember.Key key = new com.google.gerrit.reviewdb.AccountGroupMember.Key(a.getId(), groupId); com.google.gerrit.reviewdb.AccountGroupMember m = db.accountGroupMembers().get(key); if (m == null) { m = new com.google.gerrit.reviewdb.AccountGroupMember(key); db.accountGroupMembersAudit().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.AccountGroupMemberAudit(m, getAccountId()))); db.accountGroupMembers().insert(java.util.Collections.singleton(m)); accountCache.evict(m.getAccountId()); } return groupDetailFactory.create(groupId).call(); }


private void createGroup() throws com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.account.PerformCreateGroup performCreateGroup = performCreateGroupFactory.create(); try { performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId, initialMembers.toArray(new com.google.gerrit.reviewdb.Account.Id[initialMembers.size()])); } catch (com.google.gerrit.common.errors.NameAlreadyUsedException e) { throw die(e); } }
public boolean canSee(com.google.gerrit.reviewdb.Account.Id id) { return isOwner(); }
private void activate(final com.google.gerrit.reviewdb.PatchSet.Id patchSetId) { if (!(patchSetId.equals(activePatchSetId))) { deactivate(); com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel patchSetPanel = patchSetPanels.get(patchSetId); patchSetPanel.setOpen(true); patchSetPanel.setActive(true); activePatchSetId = patchSetId; } }


@java.lang.Override protected void onInitUI() { super.onInitUI(); initName(); initOwner(); initDescription(); initGroupType(); initMemberList(); initExternal(); }
private void display(final com.google.gerrit.common.data.GroupDetail result) { final com.google.gerrit.reviewdb.AccountGroup group = result.group; setPageTitle(Util.M.group(group.getName())); groupNameTxt.setText(group.getName()); if ((result.ownerGroup) != null) { ownerTxt.setText(result.ownerGroup.getName()); } else { ownerTxt.setText(Util.M.deletedGroup(group.getOwnerGroupId().get())); } descTxt.setText(group.getDescription()); switch (group.getType()) { case INTERNAL : accounts = result.accounts; members.display(result.members); break; case LDAP : externalName.setText(((group.getExternalNameKey()) != null ? group.getExternalNameKey().get() : Util.C.noGroupSelected())); break; } setType(group.getType()); }



@com.google.gwtorm.client.Query("WHERE dest.projectName = ? AND changeKey = ?") com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.Change> byProjectKey(com.google.gerrit.reviewdb.Project.NameKey p, com.google.gerrit.reviewdb.Change.Key key) throws com.google.gwtorm.client.OrmException;














public void display(com.google.gerrit.common.data.PatchSetDetail detail) { this.detail = detail; this.patchList = detail.getPatches(); myTable = null; final com.google.gerrit.client.changes.PatchTable.DisplayCommand cmd = new com.google.gerrit.client.changes.PatchTable.DisplayCommand(patchList); if (cmd.execute()) { cmd.initMeter(); com.google.gwt.user.client.DeferredCommand.addCommand(cmd); } else { cmd.showTable(); } }


@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getEffectiveGroups() { return authConfig.getAnonymousGroups(); }
@java.lang.Override public com.google.gerrit.server.project.ProjectState createEntry(com.google.gerrit.reviewdb.Project.NameKey key) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { org.eclipse.jgit.lib.Repository git = mgr.openRepository(key); try { final com.google.gerrit.server.git.ProjectConfig cfg = new com.google.gerrit.server.git.ProjectConfig(); cfg.load(git); final com.google.gerrit.reviewdb.Project p = cfg.getProject(); final java.util.Collection<com.google.gerrit.reviewdb.RefRight> rights = java.util.Collections.unmodifiableCollection(db.refRights().byProject(key).toList()); return projectStateFactory.create(p, rights); } finally { git.close(); } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notFound) { return null; } finally { db.close(); } }

@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getEffectiveGroups() { if ((effectiveGroups) == null) { if (authConfig.isIdentityTrustable(state().getExternalIds())) { effectiveGroups = realm.groups(state()); } else { effectiveGroups = authConfig.getRegisteredGroups(); } } return effectiveGroups; }

private com.google.gerrit.server.account.AccountState load(final com.google.gerrit.reviewdb.ReviewDb db, final com.google.gerrit.reviewdb.Account.Id who) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Account account = db.accounts().get(who); if (account == null) { return missing(who); } final java.util.Collection<com.google.gerrit.reviewdb.AccountExternalId> externalIds = java.util.Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> internalGroups = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id>(); for (com.google.gerrit.reviewdb.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.AccountGroup group = groupCache.get(groupId); if ((group != null) && ((group.getType()) == (AccountGroup.Type.INTERNAL))) { internalGroups.add(groupId); } } if (internalGroups.isEmpty()) { internalGroups = registered; } else { internalGroups.addAll(registered); internalGroups = java.util.Collections.unmodifiableSet(internalGroups); } return new com.google.gerrit.server.account.AccountState(account, internalGroups, externalIds); }
public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getRegisteredGroups() { return registeredGroups; }
public java.util.List<com.google.gerrit.reviewdb.AccountGroup> run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.server.IdentifiedUser user = identifiedUser.get(); final java.util.List<com.google.gerrit.reviewdb.AccountGroup> result; if (user.isAdministrator()) { result = db.accountGroups().all().toList(); } else { final java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id> seen = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id>(); result = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup.Id myGroup : user.getEffectiveGroups()) { for (com.google.gerrit.reviewdb.AccountGroup group : db.accountGroups().ownedByGroup(myGroup)) { final com.google.gerrit.reviewdb.AccountGroup.Id id = group.getId(); if (!(seen.add(id))) { continue; } try { com.google.gerrit.server.account.GroupControl c = groupControlFactory.controlFor(id); if (c.isOwner()) { result.add(c.getAccountGroup()); } } catch (NoSuchGroupException e) { continue; } } } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.AccountGroup>() { public int compare(final com.google.gerrit.reviewdb.AccountGroup a, final com.google.gerrit.reviewdb.AccountGroup b) { return a.getName().compareTo(b.getName()); } }); return result; }
public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getAnonymousGroups() { return anonymousGroups; }
public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> getOwners() { return owners; }
private java.util.Set<com.google.gerrit.reviewdb.RefRight> resolveOwnerGroups(final com.google.gerrit.reviewdb.RefRight refRight) { final java.util.Set<com.google.gerrit.reviewdb.RefRight> resolvedRefRights = new java.util.HashSet<com.google.gerrit.reviewdb.RefRight>(); if (refRight.getAccountGroupId().equals(systemConfig.ownerGroupId)) { for (final com.google.gerrit.reviewdb.AccountGroup.Id ownerGroup : getProjectState().getOwners()) { if (!(ownerGroup.equals(systemConfig.ownerGroupId))) { resolvedRefRights.add(new com.google.gerrit.reviewdb.RefRight(refRight, ownerGroup)); } } } else { resolvedRefRights.add(refRight); } return resolvedRefRights; }




private void initReadCategory(final com.google.gerrit.reviewdb.ReviewDb c, final com.google.gerrit.reviewdb.SystemConfig sConfig) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.ApprovalCategory cat; final java.util.ArrayList<com.google.gerrit.reviewdb.ApprovalCategoryValue> vals; cat = new com.google.gerrit.reviewdb.ApprovalCategory(com.google.gerrit.reviewdb.ApprovalCategory.READ, "Read Access"); cat.setPosition(((short) (-1))); cat.setFunctionName(NoOpFunction.NAME); vals = new java.util.ArrayList<com.google.gerrit.reviewdb.ApprovalCategoryValue>(); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 2, "Upload permission")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 1, "Read access")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, (-1), "No access")); c.approvalCategories().insert(java.util.Collections.singleton(cat)); c.approvalCategoryValues().insert(vals); final com.google.gerrit.reviewdb.RefRight.RefPattern pattern = new com.google.gerrit.reviewdb.RefRight.RefPattern(com.google.gerrit.reviewdb.RefRight.ALL); { final com.google.gerrit.reviewdb.RefRight read = new com.google.gerrit.reviewdb.RefRight(new com.google.gerrit.reviewdb.RefRight.Key(com.google.gerrit.server.schema.SchemaCreator.DEFAULT_WILD_NAME, pattern, cat.getId(), sConfig.anonymousGroupId)); read.setMaxValue(((short) (1))); read.setMinValue(((short) (1))); c.refRights().insert(java.util.Collections.singleton(read)); } { final com.google.gerrit.reviewdb.RefRight read = new com.google.gerrit.reviewdb.RefRight(new com.google.gerrit.reviewdb.RefRight.Key(com.google.gerrit.server.schema.SchemaCreator.DEFAULT_WILD_NAME, pattern, cat.getId(), sConfig.registeredGroupId)); read.setMaxValue(((short) (2))); read.setMinValue(((short) (1))); c.refRights().insert(java.util.Collections.singleton(read)); } { final com.google.gerrit.reviewdb.RefRight read = new com.google.gerrit.reviewdb.RefRight(new com.google.gerrit.reviewdb.RefRight.Key(com.google.gerrit.server.schema.SchemaCreator.DEFAULT_WILD_NAME, pattern, cat.getId(), sConfig.adminGroupId)); read.setMaxValue(((short) (1))); read.setMinValue(((short) (1))); c.refRights().insert(java.util.Collections.singleton(read)); } }
private void initApprovals(final com.google.gerrit.common.data.PatchSetPublishDetail r, final com.google.gwt.user.client.ui.Panel body) { for (final com.google.gerrit.common.data.ApprovalType ct : com.google.gerrit.client.Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) { if (r.isAllowed(ct.getCategory().getId())) { initApprovalType(r, body, ct); } } }

public boolean isValid(final com.google.gerrit.server.CurrentUser user, final com.google.gerrit.common.data.ApprovalType at, final com.google.gerrit.server.workflow.FunctionState state) { com.google.gerrit.server.project.RefControl rc = state.controlFor(user); for (final com.google.gerrit.reviewdb.RefRight pr : rc.getApplicableRights(at.getCategory().getId())) { if ((user.getEffectiveGroups().contains(pr.getAccountGroupUUID())) && (((pr.getMinValue()) < 0) || ((pr.getMaxValue()) > 0))) { return true; } } return false; }
private boolean canPushWithForce() { for (com.google.gerrit.common.data.PermissionRule rule : access(Permission.PUSH)) { if (rule.getForce()) { return true; } } return false; }



public boolean canSubmit() { return canPerform(Permission.SUBMIT); }
private com.google.gerrit.server.project.ProjectState newProjectState() { com.google.gerrit.server.project.ProjectCache projectCache = null; com.google.gerrit.reviewdb.Project.NameKey wildProject = new com.google.gerrit.reviewdb.Project.NameKey("-- All Projects --"); com.google.gerrit.server.project.ProjectControl.AssistedFactory projectControlFactory = null; com.google.gerrit.reviewdb.Project project = new com.google.gerrit.reviewdb.Project(); project.setName(parent.get()); com.google.gerrit.server.project.ProjectState ps = new com.google.gerrit.server.project.ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, project, localRights); ps.setInheritedRights(inheritedRights); return ps; }
public void testInheritRead_SingleBranchDoesNotOverrideInherited() { grant(parent, com.google.gerrit.server.project.READ, registered, "refs/*", 1, 2); grant(local, com.google.gerrit.server.project.READ, registered, "refs/heads/foobar", 1); com.google.gerrit.server.project.ProjectControl u = user(); assertTrue("can upload", u.canPushToAtLeastOneRef()); assertTrue("can upload refs/heads/master", u.controlForRef("refs/heads/master").canUpload()); assertTrue("can upload refs/heads/foobar", u.controlForRef("refs/heads/foobar").canUpload()); }


private void assignGroupUUIDs(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { groupMap = new java.util.HashMap<com.google.gerrit.reviewdb.AccountGroup.Id, com.google.gerrit.reviewdb.AccountGroup>(); java.util.List<com.google.gerrit.reviewdb.AccountGroup> groups = db.accountGroups().all().toList(); for (com.google.gerrit.reviewdb.AccountGroup g : groups) { if (g.getId().equals(systemConfig.ownerGroupId)) { g.setGroupUUID(AccountGroup.PROJECT_OWNERS); } else { g.setGroupUUID(com.google.gerrit.server.account.GroupUUID.make(g.getName(), serverUser)); } groupMap.put(g.getId(), g); } db.accountGroups().update(groups); systemConfig.adminGroupUUID = toUUID(systemConfig.adminGroupId); systemConfig.anonymousGroupUUID = toUUID(systemConfig.anonymousGroupId); systemConfig.registeredGroupUUID = toUUID(systemConfig.registeredGroupId); systemConfig.batchUsersGroupUUID = toUUID(systemConfig.batchUsersGroupId); db.systemConfig().update(java.util.Collections.singleton(systemConfig)); }

public void setInherit(boolean newInherit) { inherit = newInherit; }
public boolean getInherit() { return (inherit) || (com.google.gerrit.common.data.Permission.OWNER.equals(getName())); }
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.Project> call() throws com.google.gwtorm.client.OrmException { final java.util.List<com.google.gerrit.reviewdb.Project> result; if (user.isAdministrator()) { result = db.projects().all().toList(); } else { result = new java.util.ArrayList<com.google.gerrit.reviewdb.Project>(); for (com.google.gerrit.reviewdb.Project p : db.projects().all().toList()) { try { com.google.gerrit.server.project.ProjectControl c = projectControlFactory.controlFor(p.getNameKey()); if ((c.isVisible()) || (c.isOwner())) { result.add(p); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.Project>() { public int compare(final com.google.gerrit.reviewdb.Project a, final com.google.gerrit.reviewdb.Project b) { return a.getName().compareTo(b.getName()); } }); return result; }
private com.google.gerrit.client.ui.Screen select() { java.lang.String p; p = "admin,group,"; if (token.startsWith(p)) return new com.google.gerrit.client.admin.AccountGroupScreen(AccountGroup.Id.parse(com.google.gerrit.client.Dispatcher.skip(p, token))); p = "admin,project,"; if (token.startsWith(p)) { p = com.google.gerrit.client.Dispatcher.skip(p, token); final int c = p.indexOf(','); final com.google.gerrit.reviewdb.Project.NameKey k = Project.NameKey.parse(p.substring(0, c)); final boolean isWild = k.equals(com.google.gerrit.client.Gerrit.getConfig().getWildProject()); p = p.substring((c + 1)); if (ProjectScreen.INFO.equals(p)) { return new com.google.gerrit.client.admin.ProjectInfoScreen(k); } if ((!isWild) && (ProjectScreen.BRANCH.equals(p))) { return new com.google.gerrit.client.admin.ProjectBranchesScreen(k); } if (ProjectScreen.ACCESS.equals(p)) { return new com.google.gerrit.client.NotFoundScreen(); } return new com.google.gerrit.client.NotFoundScreen(); } if (com.google.gerrit.client.ADMIN_GROUPS.equals(token)) { return new com.google.gerrit.client.admin.GroupListScreen(); } if (com.google.gerrit.client.ADMIN_PROJECTS.equals(token)) { return new com.google.gerrit.client.admin.ProjectListScreen(); } return new com.google.gerrit.client.NotFoundScreen(); }



public short normalize(com.google.gerrit.reviewdb.ApprovalCategory.Id category, short score) { return getRefControl().normalize(category, score); }

private void applyRightFloor(final com.google.gerrit.reviewdb.PatchSetApproval a) { final com.google.gerrit.server.IdentifiedUser user = userFactory.create(a.getAccountId()); com.google.gerrit.server.project.RefControl rc = controlFor(user); short minAllowed = 0; short maxAllowed = 0; for (final com.google.gerrit.reviewdb.RefRight r : rc.getApplicableRights(a.getCategoryId())) { final com.google.gerrit.reviewdb.AccountGroup.UUID grp = r.getAccountGroupUUID(); if (user.getEffectiveGroups().contains(grp)) { minAllowed = ((short) (java.lang.Math.min(minAllowed, r.getMinValue()))); maxAllowed = ((short) (java.lang.Math.max(maxAllowed, r.getMaxValue()))); } } if ((a.getValue()) < minAllowed) { a.setValue(minAllowed); } else if ((a.getValue()) > maxAllowed) { a.setValue(maxAllowed); } }

private void createProject(org.eclipse.jgit.lib.Repository git) throws com.google.gwtorm.client.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<com.google.gerrit.reviewdb.RefRight> access = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); for (com.google.gerrit.reviewdb.AccountGroup.UUID ownerId : ownerIds) { com.google.gerrit.reviewdb.AccountGroup group = groupCache.get(ownerId); final com.google.gerrit.reviewdb.RefRight.Key prk = new com.google.gerrit.reviewdb.RefRight.Key(nameKey, new com.google.gerrit.reviewdb.RefRight.RefPattern(com.google.gerrit.reviewdb.RefRight.ALL), com.google.gerrit.reviewdb.ApprovalCategory.OWN, group.getId()); final com.google.gerrit.reviewdb.RefRight pr = new com.google.gerrit.reviewdb.RefRight(prk); pr.setMaxValue(((short) (1))); pr.setMinValue(((short) (1))); access.add(pr); } db.refRights().insert(access); com.google.gerrit.server.git.ProjectConfig config = new com.google.gerrit.server.git.ProjectConfig(); config.load(git); com.google.gerrit.reviewdb.Project newProject = config.getProject(); newProject.setName(projectName); newProject.setDescription(projectDescription); newProject.setSubmitType(submitType); newProject.setUseContributorAgreements(contributorAgreements); newProject.setUseSignedOffBy(signedOffBy); newProject.setUseContentMerge(contentMerge); newProject.setRequireChangeID(requireChangeID); if ((newParent) != null) { newProject.setParentName(newParent.getProject().getName()); } org.eclipse.jgit.lib.CommitBuilder commit = new org.eclipse.jgit.lib.CommitBuilder(); commit.setAuthor(userIdent); commit.setCommitter(serverIdent); commit.setMessage("Created project\n"); if (!(config.commit(commit, git))) { throw new java.io.IOException(("Cannot create " + (projectName))); } }
public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getInheritedRights() { if ((inheritedRights) == null) { inheritedRights = computeInheritedRights(); } return inheritedRights; }



@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.Project> call() throws com.google.gwtorm.client.OrmException { java.util.List<com.google.gerrit.reviewdb.Project> result = new java.util.ArrayList<com.google.gerrit.reviewdb.Project>(); if (user.isAdministrator()) { result = db.projects().get(mgr.all()).toList(); } else { for (com.google.gerrit.reviewdb.Project.NameKey p : mgr.all()) { try { com.google.gerrit.server.project.ProjectControl c = projectControlFactory.controlFor(p); if ((c.isVisible()) || (c.isOwner())) { result.add(c.getProject()); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.Project>() { public int compare(final com.google.gerrit.reviewdb.Project a, final com.google.gerrit.reviewdb.Project b) { return a.getName().compareTo(b.getName()); } }); return result; }
@java.lang.Override public void run() throws java.lang.Exception { java.io.PrintWriter p = toPrintWriter(out); parseCommandLine(); try { validateParameters(); if (!(permissionsOnly)) { final org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(projectName); try { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(branch); repoManager.setProjectDescription(projectName, projectDescription); final com.google.gerrit.reviewdb.Project.NameKey project = new com.google.gerrit.reviewdb.Project.NameKey(projectName); rq.replicateNewProject(project, branch); if (createEmptyCommit) { createEmptyCommit(repo, project, branch); } } finally { repo.close(); } } createProject(); } catch (java.lang.Exception e) { p.print((("Error when trying to create project: " + (e.getMessage())) + "\n")); p.flush(); } }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws java.lang.Exception { java.io.PrintWriter p = toPrintWriter(out); parseCommandLine(); try { validateParameters(); if (!(permissionsOnly)) { final org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(projectName); try { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(branch); repoManager.setProjectDescription(projectName, projectDescription); final com.google.gerrit.reviewdb.Project.NameKey project = new com.google.gerrit.reviewdb.Project.NameKey(projectName); rq.replicateNewProject(project, branch); if (createEmptyCommit) { createEmptyCommit(repo, project, branch); } } finally { repo.close(); } } createProject(); } catch (java.lang.Exception e) { p.print((("Error when trying to create project: " + (e.getMessage())) + "\n")); p.flush(); } } }); }
@java.lang.Override public com.google.gerrit.common.data.ProjectDetail call() throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project.NameKey projectName = update.getNameKey(); final com.google.gerrit.server.project.ProjectControl projectControl = projectControlFactory.ownerFor(projectName); final com.google.gerrit.reviewdb.Project proj = db.projects().get(projectName); if (proj == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } proj.copySettingsFrom(update); db.projects().update(java.util.Collections.singleton(proj)); projectCache.evict(proj); if (!(projectControl.getProjectState().isSpecialWildProject())) { repoManager.setProjectDescription(projectName.get(), update.getDescription()); } return projectDetailFactory.create(projectName).call(); }
@java.lang.Override public com.google.gerrit.server.project.ProjectState createEntry(com.google.gerrit.reviewdb.Project.NameKey key) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.Project p = db.projects().get(key); if (p == null) { return null; } final java.util.Collection<com.google.gerrit.reviewdb.RefRight> rights = java.util.Collections.unmodifiableCollection(db.refRights().byProject(p.getNameKey()).toList()); return projectStateFactory.create(p, rights); } finally { db.close(); } }







@java.lang.Override protected void configure() { install(new com.google.gerrit.server.schema.SchemaVersion.Module()); bind(new com.google.inject.TypeLiteral<com.google.gwtorm.client.SchemaFactory<com.google.gerrit.reviewdb.ReviewDb>>() {}).to(new com.google.inject.TypeLiteral<com.google.gwtorm.jdbc.Database<com.google.gerrit.reviewdb.ReviewDb>>() {}).in(com.google.gerrit.server.schema.SINGLETON); bind(new com.google.inject.TypeLiteral<com.google.gwtorm.jdbc.Database<com.google.gerrit.reviewdb.ReviewDb>>() {}).toProvider(com.google.gerrit.server.schema.ReviewDbDatabaseProvider.class).in(com.google.gerrit.server.schema.SINGLETON); }

public void testInheritRead_SingleBranchDeniesUpload() { grant(parent, com.google.gerrit.server.project.READ, registered, "refs/*", 1, 2); grant(local, com.google.gerrit.server.project.READ, registered, "-refs/heads/foobar", 1); com.google.gerrit.server.project.ProjectControl u = user(); assertTrue("can upload", u.canPushToAtLeastOneRef()); assertTrue("can upload refs/heads/master", u.controlForRef("refs/heads/master").canUpload()); assertFalse("deny refs/heads/foobar", u.controlForRef("refs/heads/foobar").canUpload()); }
private void grant(com.google.gerrit.reviewdb.Project.NameKey project, com.google.gerrit.reviewdb.ApprovalCategory.Id categoryId, com.google.gerrit.reviewdb.AccountGroup.UUID group, java.lang.String ref, int maxValue) { grant(project, categoryId, group, ref, maxValue, maxValue); }
@java.lang.Override protected void setUp() throws java.lang.Exception { super.setUp(); localRights = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); inheritedRights = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(); }
public java.util.Collection<com.google.gerrit.reviewdb.RefRight> getLocalRights() { return localRights; }
public void testCannotUploadToAnyRef() { grant(parent, com.google.gerrit.server.project.READ, registered, "refs/*", 1); grant(local, com.google.gerrit.server.project.READ, devs, "refs/heads/*", 1, 2); com.google.gerrit.server.project.ProjectControl u = user(); assertFalse("cannot upload", u.canPushToAtLeastOneRef()); assertFalse("cannot upload refs/heads/master", u.controlForRef("refs/heads/master").canUpload()); }
@java.lang.Override public void onPostReceive(final org.eclipse.jgit.transport.ReceivePack arg0, final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { for (final org.eclipse.jgit.transport.ReceiveCommand c : commands) { if ((c.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.OK)) { if (com.google.gerrit.server.git.ReceiveCommits.isHead(c)) { switch (c.getType()) { case CREATE : autoCloseChanges(c); break; case DELETE : break; case UPDATE : case UPDATE_NONFASTFORWARD : autoCloseChanges(c); break; } } if (!(c.getRefName().startsWith(com.google.gerrit.server.git.ReceiveCommits.NEW_CHANGE))) { replication.scheduleUpdate(project.getNameKey(), c.getRefName()); com.google.gerrit.reviewdb.Branch.NameKey destBranch = new com.google.gerrit.reviewdb.Branch.NameKey(project.getNameKey(), c.getRefName()); hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount()); } } } if ((!(allNewChanges.isEmpty())) && ((canonicalWebUrl) != null)) { final java.lang.String url = canonicalWebUrl; rp.sendMessage(""); rp.sendMessage("New Changes:"); for (final com.google.gerrit.reviewdb.Change.Id c : allNewChanges) { rp.sendMessage(((" " + url) + (c.get()))); } rp.sendMessage(""); } }



public com.google.gerrit.reviewdb.Project getProject() { return project; }


private java.util.Set<java.lang.String> allRefPatterns(com.google.gerrit.reviewdb.ApprovalCategory.Id actionId) { final java.util.Set<java.lang.String> all = new java.util.HashSet<java.lang.String>(); for (final com.google.gerrit.reviewdb.RefRight pr : state.getAllRights(actionId, true)) { all.add(pr.getRefPattern()); } return all; }
private boolean canPerformOnAnyRef(com.google.gerrit.reviewdb.ApprovalCategory.Id actionId, short requireValue) { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.UUID> groups = user.getEffectiveGroups(); for (final com.google.gerrit.reviewdb.RefRight pr : state.getAllRights(actionId, true)) { if ((groups.contains(pr.getAccountGroupUUID())) && ((pr.getMaxValue()) >= requireValue)) { return true; } } return false; }







public com.google.gerrit.testutil.InMemoryDatabase create() throws com.google.gwtorm.client.OrmException { if (!(created)) { created = true; final com.google.gerrit.reviewdb.ReviewDb c = open(); try { new com.google.gerrit.server.schema.SchemaCreator(new java.io.File("."), schemaVersion).create(c); } finally { c.close(); } } return this; }
public org.eclipse.jgit.lib.Repository createRepository(java.lang.String name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } try { java.io.File dir = org.eclipse.jgit.lib.RepositoryCache.FileKey.resolve(new java.io.File(basePath, name), FS.DETECTED); org.eclipse.jgit.lib.RepositoryCache.FileKey loc; if (dir != null) { loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(dir, FS.DETECTED); } else { if (!(name.endsWith(".git"))) { name = name + ".git"; } loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(new java.io.File(basePath, name), FS.DETECTED); } projects = null; return org.eclipse.jgit.lib.RepositoryCache.open(loc, false); } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot open repository " + name)); e2.initCause(e1); throw e2; } }


private void initWildCardProject(final com.google.gerrit.reviewdb.ReviewDb c) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project p; p = new com.google.gerrit.reviewdb.Project(com.google.gerrit.server.schema.SchemaCreator.DEFAULT_WILD_NAME); p.setDescription("Rights inherited by all other projects"); p.setUseContributorAgreements(false); c.projects().insert(java.util.Collections.singleton(p)); }
public void create(final com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final com.google.gwtorm.jdbc.JdbcSchema jdbc = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); final com.google.gwtorm.jdbc.JdbcExecutor e = new com.google.gwtorm.jdbc.JdbcExecutor(jdbc); try { jdbc.updateSchema(e); } finally { e.close(); } final com.google.gerrit.reviewdb.CurrentSchemaVersion sVer = com.google.gerrit.reviewdb.CurrentSchemaVersion.create(); sVer.versionNbr = versionNbr; db.schemaVersion().insert(java.util.Collections.singleton(sVer)); final com.google.gerrit.reviewdb.SystemConfig sConfig = initSystemConfig(db); initOwnerCategory(db); initReadCategory(db, sConfig); initVerifiedCategory(db); initCodeReviewCategory(db, sConfig); initSubmitCategory(db); initPushTagCategory(db); initPushUpdateBranchCategory(db); initForgeIdentityCategory(db, sConfig); initWildCardProject(db); final com.google.gwtorm.schema.sql.SqlDialect d = jdbc.getDialect(); if (d instanceof com.google.gwtorm.schema.sql.DialectH2) { index_generic.run(db); } else if (d instanceof com.google.gwtorm.schema.sql.DialectMySQL) { index_generic.run(db); mysql_nextval.run(db); } else if (d instanceof com.google.gwtorm.schema.sql.DialectPostgreSQL) { index_postgres.run(db); } else { throw new com.google.gwtorm.client.OrmException(("Unsupported database " + (d.getClass().getName()))); } }

public org.eclipse.jgit.lib.Repository createRepository(java.lang.String name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } try { java.io.File dir = org.eclipse.jgit.lib.RepositoryCache.FileKey.resolve(new java.io.File(basePath, name), FS.DETECTED); org.eclipse.jgit.lib.RepositoryCache.FileKey loc; if (dir != null) { loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(dir, FS.DETECTED); } else { if (!(name.endsWith(".git"))) { name = name + ".git"; } loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(new java.io.File(basePath, name), FS.DETECTED); } return org.eclipse.jgit.lib.RepositoryCache.open(loc, false); } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot open repository " + name)); e2.initCause(e1); throw e2; } }


public void run() { try { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { for (final com.google.gerrit.reviewdb.Project project : db.projects().all()) { if (!(project.getNameKey().equals(wildProject))) { replication.scheduleFullSync(project.getNameKey(), urlMatch); } } } finally { db.close(); } } catch (com.google.gwtorm.client.OrmException e) { com.google.gerrit.server.git.PushAllProjectsOp.log.error("Cannot enumerate known projects", e); } }
public void suggestProjectNameKey(final java.lang.String query, final int limit, final com.google.gwt.user.client.rpc.AsyncCallback<java.util.List<com.google.gerrit.reviewdb.Project.NameKey>> callback) { run(callback, new com.google.gerrit.httpd.rpc.Action<java.util.List<com.google.gerrit.reviewdb.Project.NameKey>>() { public java.util.List<com.google.gerrit.reviewdb.Project.NameKey> run(final com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gwtorm.client.OrmException { final java.lang.String a = query; final java.lang.String b = a + (com.google.gerrit.httpd.rpc.SuggestServiceImpl.MAX_SUFFIX); final int max = 10; final int n = (limit <= 0) ? max : java.lang.Math.min(limit, max); final com.google.gerrit.server.CurrentUser user = currentUser.get(); final java.util.List<com.google.gerrit.reviewdb.Project.NameKey> r = new java.util.ArrayList<com.google.gerrit.reviewdb.Project.NameKey>(); for (final com.google.gerrit.reviewdb.Project p : db.projects().suggestByName(a, b, n)) { final com.google.gerrit.server.project.ProjectState e = projectCache.get(p.getNameKey()); if ((e != null) && (e.controlFor(user).isVisible())) { r.add(p.getNameKey()); } } return r; } }); }
@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gwtorm.client.SchemaFactory<com.google.gerrit.reviewdb.ReviewDb>>() {}).toInstance(db); bind(com.google.gerrit.server.config.SitePaths.class).toInstance(paths); install(new com.google.gerrit.server.schema.SchemaVersion.Module()); }
private com.google.gerrit.server.project.ProjectState newProjectState() { com.google.gerrit.server.project.ProjectCache projectCache = null; com.google.gerrit.reviewdb.Project.NameKey wildProject = null; com.google.gerrit.server.project.ProjectControl.AssistedFactory projectControlFactory = null; com.google.gerrit.server.project.ProjectState ps = new com.google.gerrit.server.project.ProjectState(anonymousUser, projectCache, wildProject, projectControlFactory, new com.google.gerrit.reviewdb.Project(parent), localRights); ps.setInheritedRights(inheritedRights); return ps; }



public boolean canUpload() { return canPerform(com.google.gerrit.server.project.READ, ((short) (2))); }
public short normalize(com.google.gerrit.reviewdb.ApprovalCategory.Id category, short score) { short minAllowed = 0; short maxAllowed = 0; for (com.google.gerrit.reviewdb.RefRight r : getApplicableRights(category)) { if (getCurrentUser().getEffectiveGroups().contains(r.getAccountGroupUUID())) { minAllowed = ((short) (java.lang.Math.min(minAllowed, r.getMinValue()))); maxAllowed = ((short) (java.lang.Math.max(maxAllowed, r.getMaxValue()))); } } if (score < minAllowed) { score = minAllowed; } if (score > maxAllowed) { score = maxAllowed; } return score; }

public java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id> getAllowed(final com.google.gerrit.reviewdb.ApprovalCategory.Id id) { return allowed.get(id); }
private boolean allowedValueForRef(java.util.Set<com.google.gerrit.reviewdb.AccountGroup.UUID> groups, short level) { for (com.google.gerrit.reviewdb.RefRight right : rights) { if ((groups.contains(right.getAccountGroupUUID())) && ((right.getMaxValue()) >= level)) { return true; } } return false; }
private boolean matches(java.lang.String refPattern) { if (com.google.gerrit.server.project.RefControl.isTemplate(refPattern)) { com.google.gerrit.common.data.ParamertizedString template = new com.google.gerrit.common.data.ParamertizedString(refPattern); java.util.HashMap<java.lang.String, java.lang.String> p = new java.util.HashMap<java.lang.String, java.lang.String>(); if ((getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser) { p.put("username", ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())).getUserName()); } else { return false; } if (com.google.gerrit.server.project.RefControl.isRE(refPattern)) { for (java.util.Map.Entry<java.lang.String, java.lang.String> ent : p.entrySet()) { ent.setValue(com.google.gerrit.server.project.RefControl.escape(ent.getValue())); } } refPattern = template.replace(p); } if (com.google.gerrit.server.project.RefControl.isRE(refPattern)) { return java.util.regex.Pattern.matches(refPattern, getRefName()); } else if (refPattern.endsWith("/*")) { java.lang.String prefix = refPattern.substring(0, ((refPattern.length()) - 1)); return getRefName().startsWith(prefix); } else { return getRefName().equals(refPattern); } }

public java.util.Map<com.google.gerrit.reviewdb.ApprovalCategory.Id, java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id>> getAllowed() { return allowed; }
public void addRight(com.google.gerrit.reviewdb.RefRight right) { rights.add(right); if (right.isExclusive()) { containsExclusive = true; } }
private java.util.List<com.google.gerrit.reviewdb.RefRight> resolveOwnerGroups(final java.util.List<com.google.gerrit.reviewdb.RefRight> refRights) { final java.util.List<com.google.gerrit.reviewdb.RefRight> resolvedRefRights = new java.util.ArrayList<com.google.gerrit.reviewdb.RefRight>(refRights.size()); for (final com.google.gerrit.reviewdb.RefRight refRight : refRights) { resolvedRefRights.addAll(resolveOwnerGroups(refRight)); } return resolvedRefRights; }






@java.lang.Override public com.google.gerrit.common.data.PatchSetPublishDetail call() throws com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl control = changeControlFactory.validateFor(changeId); change = control.getChange(); patchSetInfo = infoFactory.get(patchSetId); drafts = db.patchComments().draft(patchSetId, user.getAccountId()).toList(); allowed = new java.util.HashMap<com.google.gerrit.reviewdb.ApprovalCategory.Id, java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id>>(); given = new java.util.HashMap<com.google.gerrit.reviewdb.ApprovalCategory.Id, com.google.gerrit.reviewdb.PatchSetApproval>(); if ((change.getStatus().isOpen()) && (patchSetId.equals(change.currentPatchSetId()))) { computeAllowed(); for (final com.google.gerrit.reviewdb.PatchSetApproval a : db.patchSetApprovals().byPatchSetUser(patchSetId, user.getAccountId())) { given.put(a.getCategoryId(), a); } } aic.want(change.getOwner()); accounts = aic.create(); com.google.gerrit.common.data.PatchSetPublishDetail detail = new com.google.gerrit.common.data.PatchSetPublishDetail(); detail.setAccounts(accounts); detail.setPatchSetInfo(patchSetInfo); detail.setChange(change); detail.setDrafts(drafts); detail.setAllowed(allowed); detail.setGiven(given); final com.google.gerrit.server.project.CanSubmitResult canSubmitResult = control.canSubmit(patchSetId); detail.setSubmitAllowed((canSubmitResult == (com.google.gerrit.server.project.CanSubmitResult.OK))); return detail; }
@java.lang.Override public com.google.gerrit.server.project.ProjectState createEntry(com.google.gerrit.reviewdb.Project.NameKey key) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open(); try { org.eclipse.jgit.lib.Repository git = mgr.openRepository(key); try { final com.google.gerrit.server.git.ProjectConfig cfg = new com.google.gerrit.server.git.ProjectConfig(); cfg.load(git); final com.google.gerrit.reviewdb.Project p = cfg.getProject(); java.util.Collection<com.google.gerrit.reviewdb.RefRight> rights = db.refRights().byProject(key).toList(); java.util.Set<com.google.gerrit.reviewdb.AccountGroup.Id> groupIds = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.Id>(); for (com.google.gerrit.reviewdb.RefRight r : rights) { groupIds.add(r.getAccountGroupId()); } java.util.Map<com.google.gerrit.reviewdb.AccountGroup.Id, com.google.gerrit.reviewdb.AccountGroup> groupsById = db.accountGroups().toMap(db.accountGroups().get(groupIds)); for (com.google.gerrit.reviewdb.RefRight r : rights) { com.google.gerrit.reviewdb.AccountGroup group = groupsById.get(r.getAccountGroupId()); if (group != null) { r.setAccountGroupUUID(group.getGroupUUID()); } else { r.setAccountGroupUUID(new com.google.gerrit.reviewdb.AccountGroup.UUID(("DELETED_GROUP_" + (r.getAccountGroupId().get())))); } } rights = java.util.Collections.unmodifiableCollection(rights); return projectStateFactory.create(p, rights); } finally { git.close(); } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notFound) { return null; } finally { db.close(); } }
public boolean canPushToAtLeastOneRef() { return ((canPerformOnAnyRef(ApprovalCategory.READ, ((short) (2)))) || (canPerformOnAnyRef(ApprovalCategory.PUSH_HEAD, ((short) (1))))) || (canPerformOnAnyRef(ApprovalCategory.PUSH_TAG, ((short) (1)))); }
public void setAllowed(java.util.Map<com.google.gerrit.reviewdb.ApprovalCategory.Id, java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id>> allowed) { this.allowed = allowed; }


private org.eclipse.jgit.lib.ObjectId createNoteContent(com.google.gerrit.server.git.CodeReviewCommit commit) throws com.google.gerrit.server.git.CodeReviewNoteCreationException, java.io.IOException { try { com.google.gerrit.server.git.ReviewNoteHeaderFormatter formatter = new com.google.gerrit.server.git.ReviewNoteHeaderFormatter(author.getTimeZone()); final java.util.List<java.lang.String> idList = commit.getFooterLines(com.google.gerrit.server.git.CreateCodeReviewNotes.CHANGE_ID); if (idList.isEmpty()) formatter.appendChangeId(commit.change.getKey()); com.google.gwtorm.client.ResultSet<com.google.gerrit.reviewdb.PatchSetApproval> approvals = schema.patchSetApprovals().byPatchSet(commit.patchsetId); com.google.gerrit.reviewdb.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.PatchSetApproval a : approvals) { if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) { submit = a; } else { formatter.appendApproval(approvalTypes.getApprovalType(a.getCategoryId()).getCategory(), a.getValue(), accountCache.get(a.getAccountId()).getAccount()); } } formatter.appendSubmittedBy(accountCache.get(submit.getAccountId()).getAccount()); formatter.appendSubmittedAt(submit.getGranted()); formatter.appendReviewedOn(canonicalWebUrl, commit.change.getId()); formatter.appendProject(commit.change.getProject().get()); formatter.appendBranch(commit.change.getDest()); return inserter.insert(Constants.OBJ_BLOB, formatter.toString().getBytes("UTF-8")); } catch (com.google.gwtorm.client.OrmException e) { throw new com.google.gerrit.server.git.CodeReviewNoteCreationException(commit, e); } }
public com.google.gerrit.server.project.ProjectState get(final com.google.gerrit.reviewdb.Project.NameKey projectName) { return byName.get(projectName); }

public boolean isOwnerOf(com.google.gerrit.common.data.AccessSection section) { return getOwnerOf().contains(section.getRefPattern()); }
private org.eclipse.jgit.lib.Ref getBranchRef(com.google.gerrit.reviewdb.Project.NameKey projectName) { try { final org.eclipse.jgit.lib.Repository r = repoManager.openRepository(projectName); try { return r.getRef(showBranch); } finally { r.close(); } } catch (java.io.IOException ioe) { return null; } }











private void appendLineNumber(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, final int idx) { m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().lineNumber()); m.append((idx + 1)); m.closeTd(); }

private void appendLineText(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, final int lineNumberMinusOne, final com.google.gerrit.client.patches.PatchLine.Type type, final com.google.gwtexpui.safehtml.client.SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) { m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().lineNumber()); m.append((lineNumberMinusOne + 1)); m.closeTd(); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().fileLine()); switch (type) { case Type.CONTEXT : m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT()); break; case Type.DELETE : m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE()); if (trailingEdit || fullBlock) { m.addStyleName("wdd"); } break; case Type.INSERT : m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT()); if (trailingEdit || fullBlock) { m.addStyleName("wdi"); } break; } m.append(lineHtml); m.closeTd(); }









@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final com.google.gerrit.reviewdb.Account.Id accountId; try { final com.google.gerrit.reviewdb.Account a = accountResolver.find(token); if (a != null) { accountId = a.getId(); } else { accountId = createAccountIfUserCanBeAuthenticated(token); } } catch (com.google.gwtorm.client.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "database is down"); } setter.addValue(accountId); return 1; }
private Account.Id createAccountIfUserCanBeAuthenticated(final java.lang.String username) throws org.kohsuke.args4j.CmdLineException { try { final com.google.gerrit.server.account.AuthRequest areq = com.google.gerrit.server.account.AuthRequest.forUser(username); final com.google.gerrit.server.account.AuthResult arsp = accountManager.authenticate(areq); return arsp.getAccountId(); } catch (com.google.gerrit.server.account.AccountException e) { throw new org.kohsuke.args4j.CmdLineException(owner, (("Unable to authenticate user \"" + username) + "\""), e); } }
private void appendLineText(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, final int lineNumberMinusOne, final com.google.gerrit.client.patches.PatchLine.Type type, final com.google.gwtexpui.safehtml.client.SafeHtml lineHtml, final boolean trailingEdit, final boolean fullBlock) { m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().lineNumber()); m.append((lineNumberMinusOne + 1)); m.closeTd(); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().fileLine()); switch (type) { case Type.CONTEXT : m.addStyleName(Gerrit.RESOURCES.css().fileLineCONTEXT()); break; case Type.DELETE : m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE()); if (trailingEdit || fullBlock) { m.addStyleName("wdd"); } break; case Type.INSERT : m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT()); if (trailingEdit || fullBlock) { m.addStyleName("wdi"); } break; } m.append(lineHtml); m.closeTd(); }
private void appendLineNumber(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, final int idx) { m.openTd(); m.setStyleName(Gerrit.RESOURCES.css().lineNumber()); m.append((idx + 1)); m.closeTd(); }


private java.util.Map<java.lang.String, java.util.List<com.google.gerrit.common.data.PermissionRule>> permissions() { if ((permissions) == null) { permissions = new java.util.HashMap<java.lang.String, java.util.List<com.google.gerrit.common.data.PermissionRule>>(); com.google.gerrit.common.data.AccessSection section = state.getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES); for (com.google.gerrit.common.data.Permission permission : section.getPermissions()) { for (com.google.gerrit.common.data.PermissionRule rule : permission.getRules()) { if (matchGroup(rule.getGroup().getUUID())) { if (!(rule.getDeny())) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = permissions.get(permission.getName()); if (r == null) { r = new java.util.ArrayList<com.google.gerrit.common.data.PermissionRule>(2); permissions.put(permission.getName(), r); } r.add(rule); } } } } } return permissions; }
public com.google.gerrit.rules.PrologEnvironment newPrologEnvironment() throws com.googlecode.prolog_cafe.compiler.CompileException { com.google.gerrit.rules.PrologEnvironment env = envFactory.create(getClass().getClassLoader()); java.lang.String rules = getConfig().getPrologRules(); if (rules != null) { java.io.PushbackReader in = new java.io.PushbackReader(new java.io.StringReader(rules), com.googlecode.prolog_cafe.lang.Prolog.PUSHBACK_SIZE); com.googlecode.prolog_cafe.lang.JavaObjectTerm streamObject = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(in); if (!(env.execute(Prolog.BUILTIN, "consult_stream", com.googlecode.prolog_cafe.lang.SymbolTerm.intern("rules.pl"), streamObject))) { throw new com.googlecode.prolog_cafe.compiler.CompileException(((("Cannot consult rules.pl " + (getProject().getName())) + " ") + (getConfig().getRevision()))); } } return env; }

private com.google.gerrit.server.project.ProjectControl user(com.google.gerrit.reviewdb.AccountGroup... memberOf) { com.google.gerrit.reviewdb.ReviewDb db = null; com.google.gerrit.server.account.GroupCache groupCache = null; java.lang.String canonicalWebUrl = "http://localhost"; com.google.gerrit.server.project.RefControl.Factory refControlFactory = new com.google.gerrit.server.project.RefControl.Factory() { @java.lang.Override public com.google.gerrit.server.project.RefControl create(final com.google.gerrit.server.project.ProjectControl projectControl, final java.lang.String ref) { return new com.google.gerrit.server.project.RefControl(projectControl, ref); } }; return new com.google.gerrit.server.project.ProjectControl(java.util.Collections.<com.google.gerrit.reviewdb.AccountGroup.UUID>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.AccountGroup.UUID>emptySet(), db, groupCache, canonicalWebUrl, refControlFactory, new com.google.gerrit.server.project.RefControlTest.MockUser(memberOf), newProjectState()); }

private java.io.File local(final javax.servlet.http.HttpServletRequest req) { final java.lang.String name = req.getPathInfo(); if (((name.length()) < 2) || (!(name.startsWith("/")))) { return null; } if (((name.indexOf('/', 1)) > 0) || ((name.indexOf('\\', 1)) > 0)) { return null; } final java.io.File p = new java.io.File(staticBase, name.substring(1)); return p.isFile() ? p : null; }


@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { if (!(projectControl.canRunUploadPack())) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); if (!(projectControl.allRefsAreVisible())) { up.setRefFilter(new com.google.gerrit.server.git.VisibleRefFilter(repo, projectControl, db.get(), true)); } up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); try { up.upload(in, out, err); } catch (java.io.InterruptedIOException err) { throw new com.google.gerrit.sshd.commands.Failure(128, "fatal: client IO read/write timeout", err); } }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd); } }
private void parseRewind(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevCommit newObject; try { newObject = rp.getRevWalk().parseCommit(cmd.getNewId()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException notCommit) { newObject = null; } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " forced update"), err); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid object"); return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (newObject != null) { validateNewCommits(ctl, cmd); if ((cmd.getResult()) != (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { return; } } if (ctl.canForceUpdate()) { } else { cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD); } }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) throws org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException, org.eclipse.jgit.transport.resolver.ServiceNotEnabledException { com.google.gerrit.server.project.ProjectControl pc = com.google.gerrit.httpd.ProjectServlet.getProjectControl(req); if (!(pc.canRunUploadPack())) { throw new org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException(); } org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(packConfig); if (!(pc.allRefsAreVisible())) { up.setRefFilter(new com.google.gerrit.server.git.VisibleRefFilter(repo, pc, db.get(), true)); } return up; }
private int distance(java.lang.String pattern) { java.lang.String example; if (com.google.gerrit.server.project.RefControl.isRE(pattern)) { example = com.google.gerrit.server.project.RefControl.shortestExample(pattern); } else if (pattern.endsWith("/*")) { example = (pattern.substring(0, ((pattern.length()) - 1))) + '1'; } else if (pattern.equals(getRefName())) { return 0; } else { return java.lang.Math.max(pattern.length(), getRefName().length()); } return org.apache.commons.lang.StringUtils.getLevenshteinDistance(example, getRefName()); }
private com.google.gerrit.server.project.ProjectControl user(com.google.gerrit.reviewdb.AccountGroup... memberOf) { com.google.gerrit.server.project.RefControl.Factory refControlFactory = new com.google.gerrit.server.project.RefControl.Factory() { @java.lang.Override public com.google.gerrit.server.project.RefControl create(final com.google.gerrit.server.project.ProjectControl projectControl, final java.lang.String ref) { return new com.google.gerrit.server.project.RefControl(systemConfig, projectControl, ref); } }; return new com.google.gerrit.server.project.ProjectControl(java.util.Collections.<com.google.gerrit.reviewdb.AccountGroup.Id>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.AccountGroup.Id>emptySet(), refControlFactory, new com.google.gerrit.server.project.RefControlTest.MockUser(memberOf), newProjectState()); }
@java.lang.Override public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> filter(java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { final java.util.Set<com.google.gerrit.reviewdb.Change.Id> visibleChanges = visibleChanges(); final java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = new java.util.HashMap<java.lang.String, org.eclipse.jgit.lib.Ref>(); final java.util.List<org.eclipse.jgit.lib.Ref> deferredTags = new java.util.ArrayList<org.eclipse.jgit.lib.Ref>(); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { if (com.google.gerrit.reviewdb.PatchSet.isRef(ref.getName())) { if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) { result.put(ref.getName(), ref); } } else if (com.google.gerrit.server.git.VisibleRefFilter.isTag(ref)) { deferredTags.add(ref); } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) { result.put(ref.getName(), ref); } } if ((!(deferredTags.isEmpty())) && (!(result.isEmpty()))) { addVisibleTags(result, deferredTags); } return result; }
public static java.lang.String shortestExample(java.lang.String pattern) { if (com.google.gerrit.server.project.RefControl.isRE(pattern)) { return com.google.gerrit.server.project.RefControl.toRegExp(pattern).toAutomaton().getShortestExample(true); } else if (pattern.endsWith("/*")) { return (pattern.substring(0, ((pattern.length()) - 1))) + '1'; } else { return pattern; } }
private void parseCreate(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid object"); return; } if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canCreate(rp.getRevWalk(), obj)) { validateNewCommits(ctl, cmd); } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd); } }
@java.lang.Override public com.google.gerrit.server.project.RefControl create(final com.google.gerrit.server.project.ProjectControl projectControl, final java.lang.String ref) { return new com.google.gerrit.server.project.RefControl(systemConfig, projectControl, ref); }

java.util.Collection<com.google.gerrit.common.data.AccessSection> access() { if ((access) == null) { access = state.getAllAccessSections(); } return access; }



public static java.lang.String toAccountGroup(final com.google.gerrit.reviewdb.AccountGroup.Id id) { return "admin,group," + (id.toString()); }
public static java.lang.String toChangeQuery(final java.lang.String query) { return (("q," + (com.google.gwtorm.client.KeyUtil.encode(query))) + ",") + (com.google.gerrit.common.PageLinks.TOP); }



private static void publish(java.lang.String token) { new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, select()); } private com.google.gerrit.client.ui.Screen select() { java.lang.String p = "change,publish,"; if (token.startsWith(p)) return new com.google.gerrit.client.changes.PublishCommentScreen(PatchSet.Id.parse(com.google.gerrit.client.Dispatcher.skip(p, token))); return new com.google.gerrit.client.NotFoundScreen(); } }.onSuccess(); }
private com.google.gerrit.client.ui.Screen select() { java.lang.String p; p = "admin,group,uuid-"; if (token.startsWith(p)) return new com.google.gerrit.client.admin.AccountGroupScreen(AccountGroup.UUID.parse(com.google.gerrit.client.Dispatcher.skip(p, token))); p = "admin,group,"; if (token.startsWith(p)) return new com.google.gerrit.client.admin.AccountGroupScreen(AccountGroup.Id.parse(com.google.gerrit.client.Dispatcher.skip(p, token))); p = "admin,project,"; if (token.startsWith(p)) { p = com.google.gerrit.client.Dispatcher.skip(p, token); final int c = p.indexOf(','); final com.google.gerrit.reviewdb.Project.NameKey k = Project.NameKey.parse(p.substring(0, c)); final boolean isWild = k.equals(com.google.gerrit.client.Gerrit.getConfig().getWildProject()); p = p.substring((c + 1)); if (ProjectScreen.INFO.equals(p)) { return new com.google.gerrit.client.admin.ProjectInfoScreen(k); } if ((!isWild) && (ProjectScreen.BRANCH.equals(p))) { return new com.google.gerrit.client.admin.ProjectBranchesScreen(k); } if (ProjectScreen.ACCESS.equals(p)) { return new com.google.gerrit.client.admin.ProjectAccessScreen(k); } return new com.google.gerrit.client.NotFoundScreen(); } if (com.google.gerrit.client.ADMIN_GROUPS.equals(token)) { return new com.google.gerrit.client.admin.GroupListScreen(); } if (com.google.gerrit.client.ADMIN_PROJECTS.equals(token)) { return new com.google.gerrit.client.admin.ProjectListScreen(); } return new com.google.gerrit.client.NotFoundScreen(); }

private static com.google.gerrit.client.ui.Screen mine(final java.lang.String token) { if (com.google.gerrit.client.MINE.equals(token)) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { return new com.google.gerrit.client.changes.AccountDashboardScreen(com.google.gerrit.client.Gerrit.getUserAccount().getId()); } else { final com.google.gerrit.client.ui.Screen r = new com.google.gerrit.client.changes.AccountDashboardScreen(null); r.setRequiresSignIn(true); return r; } } else if ("mine,starred".equals(token)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("is:starred"); } else if ("mine,drafts".equals(token)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("has:draft"); } else { java.lang.String p = "mine,watched,"; if (token.startsWith(p)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("is:watched status:open", com.google.gerrit.client.Dispatcher.skip(p, token)); } return new com.google.gerrit.client.NotFoundScreen(); } }
public static void patch(java.lang.String token, final com.google.gerrit.reviewdb.Patch.Key id, final int patchIndex, final com.google.gerrit.common.data.PatchSetDetail patchSetDetail, final com.google.gerrit.client.changes.PatchTable patchTable) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, select()); } private com.google.gerrit.client.ui.Screen select() { java.lang.String p; p = "patch,sidebyside,"; if (token.startsWith(p)) { return new com.google.gerrit.client.patches.PatchScreen.SideBySide((id != null ? id : Patch.Key.parse(com.google.gerrit.client.Dispatcher.skip(p, token))), patchIndex, patchSetDetail, patchTable); } p = "patch,unified,"; if (token.startsWith(p)) { return new com.google.gerrit.client.patches.PatchScreen.Unified((id != null ? id : Patch.Key.parse(com.google.gerrit.client.Dispatcher.skip(p, token))), patchIndex, patchSetDetail, patchTable); } return new com.google.gerrit.client.NotFoundScreen(); } }); }
public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, select()); }
private static com.google.gerrit.client.ui.Screen all(final java.lang.String token) { java.lang.String p; p = "all,abandoned,"; if (token.startsWith(p)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("status:abandoned", com.google.gerrit.client.Dispatcher.skip(p, token)); } p = "all,merged,"; if (token.startsWith(p)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("status:merged", com.google.gerrit.client.Dispatcher.skip(p, token)); } p = "all,open,"; if (token.startsWith(p)) { return com.google.gerrit.client.changes.QueryScreen.forQuery("status:open", com.google.gerrit.client.Dispatcher.skip(p, token)); } return new com.google.gerrit.client.NotFoundScreen(); }

public static java.lang.String toGroup(final com.google.gerrit.reviewdb.AccountGroup.UUID uuid) { return "admin,group,uuid-" + (uuid.toString()); }



public static java.lang.String toProjectAcceess(final com.google.gerrit.reviewdb.Project.NameKey p) { return ("admin,project," + (p.get())) + ",access"; }
private void onLogin() { hideError(); final java.lang.String user = username.getText(); if ((user == null) || (user.equals(""))) { showError(Util.C.usernameRequired()); username.setFocus(true); return; } final java.lang.String pass = password.getText(); if ((pass == null) || (pass.equals(""))) { showError(Util.C.passwordRequired()); password.setFocus(true); return; } enable(false); Util.SVC.authenticate(user, pass, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.auth.userpass.LoginResult>() { public void onSuccess(final com.google.gerrit.common.auth.userpass.LoginResult result) { if (result.success) { java.lang.String to = token; if ((result.isNew) && (!(to.startsWith(((com.google.gerrit.common.PageLinks.REGISTER) + ","))))) { to = ((com.google.gerrit.common.PageLinks.REGISTER) + ",") + to; } com.google.gwt.user.client.Window.Location.replace((((com.google.gwt.user.client.Window.Location.getPath()) + "login/") + to)); } else { showError(Util.C.invalidLogin()); enable(true); password.selectAll(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { password.setFocus(true); } }); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { super.onFailure(caught); enable(true); } }); }
public void onSuccess(final com.google.gerrit.common.auth.userpass.LoginResult result) { if (result.success) { java.lang.String to = token; if ((result.isNew) && (!(to.startsWith(((com.google.gerrit.common.PageLinks.REGISTER) + ","))))) { to = ((com.google.gerrit.common.PageLinks.REGISTER) + ",") + to; } com.google.gwt.user.client.Window.Location.replace((((com.google.gwt.user.client.Window.Location.getPath()) + "login/") + to)); } else { showError(Util.C.invalidLogin()); enable(true); password.selectAll(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { password.setFocus(true); } }); } }
private static java.lang.String skip(final java.lang.String prefix, final java.lang.String in) { return in.substring(prefix.length()); }
private static com.google.gerrit.client.ui.Screen project(final java.lang.String token) { java.lang.String p; p = "project,open,"; if (token.startsWith(p)) { final java.lang.String s = com.google.gerrit.client.Dispatcher.skip(p, token); final int c = s.indexOf(','); com.google.gerrit.reviewdb.Project.NameKey proj = Project.NameKey.parse(s.substring(0, c)); return com.google.gerrit.client.changes.QueryScreen.forQuery(("status:open " + (op("project", proj.get()))), s.substring((c + 1))); } p = "project,merged,"; if (token.startsWith(p)) { final java.lang.String s = com.google.gerrit.client.Dispatcher.skip(p, token); final int c = s.indexOf(','); com.google.gerrit.reviewdb.Project.NameKey proj = Project.NameKey.parse(s.substring(0, c)); return com.google.gerrit.client.changes.QueryScreen.forQuery(("status:merged " + (op("project", proj.get()))), s.substring((c + 1))); } p = "project,abandoned,"; if (token.startsWith(p)) { final java.lang.String s = com.google.gerrit.client.Dispatcher.skip(p, token); final int c = s.indexOf(','); com.google.gerrit.reviewdb.Project.NameKey proj = Project.NameKey.parse(s.substring(0, c)); return com.google.gerrit.client.changes.QueryScreen.forQuery(("status:abandoned " + (op("project", proj.get()))), s.substring((c + 1))); } return new com.google.gerrit.client.NotFoundScreen(); }


@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.project.ProjectAdminServiceImpl.class); }
@java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); }
private void doAddReviewer() { final java.lang.String nameEmail = addMemberBox.getText(); if ((nameEmail.length()) == 0) { return; } addMemberBox.setEnabled(false); final java.util.List<java.lang.String> reviewers = new java.util.ArrayList<java.lang.String>(); reviewers.add(nameEmail); PatchUtil.DETAIL_SVC.addReviewers(changeId, reviewers, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ReviewerResult>() { public void onSuccess(final com.google.gerrit.common.data.ReviewerResult result) { addMemberBox.setEnabled(true); addMemberBox.setText(""); if (!(result.getErrors().isEmpty())) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder r = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); for (final com.google.gerrit.common.data.ReviewerResult.Error e : result.getErrors()) { switch (e.getType()) { case ACCOUNT_NOT_FOUND : r.append(Util.M.accountNotFound(e.getName())); break; case ACCOUNT_INACTIVE : r.append(Util.M.accountInactive(e.getName())); break; case CHANGE_NOT_VISIBLE : r.append(Util.M.changeNotVisibleTo(e.getName())); break; default : r.append(e.getName()); r.append(" - "); r.append(e.getType()); r.br(); break; } } new com.google.gerrit.client.ErrorDialog(r).center(); } final com.google.gerrit.common.data.ChangeDetail r = result.getChange(); if (r != null) { setAccountInfoCache(r.getAccounts()); display(r.getChange(), r.getMissingApprovals(), r.getApprovals()); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { addMemberBox.setEnabled(true); super.onFailure(caught); } }); }

public void addReviewers(final com.google.gerrit.reviewdb.Change.Id id, final java.util.List<java.lang.String> reviewers, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.data.ReviewerResult> callback) { addReviewerFactory.create(id, reviewers).to(callback); }
java.lang.String accountNotFound(java.lang.String who);
void display(final java.util.List<com.google.gerrit.reviewdb.Patch> result) { all.clear(); final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder nc = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); appendHeader(nc); appendRow(nc, null); for (final com.google.gerrit.reviewdb.Patch k : result) { appendRow(nc, k); } resetHtml(nc); int row = 1; { final com.google.gerrit.reviewdb.Patch k = new com.google.gerrit.reviewdb.Patch(new com.google.gerrit.reviewdb.Patch.Key(null, "")); setRowItem(row, k); installRadio(row, k, 0, screen.idSideA); row++; } for (final com.google.gerrit.reviewdb.Patch k : result) { setRowItem(row, k); installRadio(row, k, 0, screen.idSideA); installRadio(row, k, 1, screen.idSideB); row++; } }


public <T> void set(com.google.gerrit.rules.StoredValue<T> sv, T obj) { sv.set(engine, obj); }


private void update() { if ((colWidth.getIntValue()) <= 0) { new com.google.gerrit.client.ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center(); return; } com.google.gerrit.reviewdb.AccountDiffPreference dp = new com.google.gerrit.reviewdb.AccountDiffPreference(getValue()); dp.setIgnoreWhitespace(getIgnoreWhitespace()); dp.setContext(getContext()); dp.setTabSize(tabWidth.getIntValue()); dp.setLineLength(colWidth.getIntValue()); dp.setSyntaxHighlighting(syntaxHighlighting.getValue()); dp.setIntralineDifference(intralineDifference.getValue()); dp.setShowWhitespaceErrors(whitespaceErrors.getValue()); dp.setShowTabs(showTabs.getValue()); dp.setSkipDeleted(skipDeleted.getValue()); dp.setSkipUncommented(skipUncommented.getValue()); dp.setExpandAllComments(expandAllComments.getValue()); listenablePrefs.set(dp); if (com.google.gerrit.client.Gerrit.isSignedIn()) { persistDiffPreferences(); } }

void populate(final int row, final com.google.gerrit.reviewdb.Branch k) { final com.google.gerrit.common.data.GitwebLink c = com.google.gerrit.client.Gerrit.getConfig().getGitwebLink(); if (k.getCanDelete()) { table.setWidget(row, 1, new com.google.gwt.user.client.ui.CheckBox()); canDelete = true; } else { table.setText(row, 1, ""); } table.setText(row, 2, k.getShortName()); if ((k.getRevision()) != null) { table.setText(row, 3, k.getRevision().get()); } else { table.setText(row, 3, ""); } if (c != null) { table.setWidget(row, 4, new com.google.gwt.user.client.ui.Anchor("(gitweb)", false, c.toBranch(k.getNameKey()))); } final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); if (c != null) { fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell()); } setRowItem(row, k); }
public T get(com.googlecode.prolog_cafe.lang.Prolog engine) { T r = getOrNull(engine); if (r == null) { java.lang.String msg; if ((key.isJavaObject()) && ((key.toJava()) instanceof java.lang.Class<?>)) { msg = ("No " + (((java.lang.Class<?>) (key.toJava())).getName())) + " avaliable"; } else { msg = key.toString(); } throw new com.googlecode.prolog_cafe.lang.SystemException(msg); } return r; }


public void copyStoredValues(com.google.gerrit.rules.PrologEnvironment child) { storedValues.putAll(child.storedValues); }


public java.lang.String toProject(final com.google.gerrit.reviewdb.Project.NameKey project) { com.google.gerrit.common.data.ParamertizedString pattern = new com.google.gerrit.common.data.ParamertizedString(type.getProject()); final java.util.Map<java.lang.String, java.lang.String> p = new java.util.HashMap<java.lang.String, java.lang.String>(); p.put("project", com.google.gwt.http.client.URL.encodeQueryString(project.get())); return (baseUrl) + (pattern.replace(p)); }
public java.lang.String toRevision(final com.google.gerrit.reviewdb.Project.NameKey project, final com.google.gerrit.reviewdb.PatchSet ps) { com.google.gerrit.common.data.ParamertizedString pattern = new com.google.gerrit.common.data.ParamertizedString(type.getRevision()); final java.util.Map<java.lang.String, java.lang.String> p = new java.util.HashMap<java.lang.String, java.lang.String>(); p.put("project", com.google.gwt.http.client.URL.encodeQueryString(project.get())); p.put("commit", com.google.gwt.http.client.URL.encodeQueryString(ps.getRevision().get())); return (baseUrl) + (pattern.replace(p)); }
public java.lang.String toBranch(final com.google.gerrit.reviewdb.Branch.NameKey branch) { com.google.gerrit.common.data.ParamertizedString pattern = new com.google.gerrit.common.data.ParamertizedString(type.getBranch()); final java.util.Map<java.lang.String, java.lang.String> p = new java.util.HashMap<java.lang.String, java.lang.String>(); p.put("project", com.google.gwt.http.client.URL.encodeQueryString(branch.getParentKey().get())); p.put("branch", com.google.gwt.http.client.URL.encodeQueryString(branch.get())); return (baseUrl) + (pattern.replace(p)); }
public void testReplaceToLowerCase() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("${a.toLowerCase}"); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("a")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("a", "foo"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("foo", p.bind(a)[0]); assertEquals("foo", p.replace(a)); a.put("a", "FOO"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("foo", p.bind(a)[0]); assertEquals("foo", p.replace(a)); }
public void testReplace3() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("a${bar}"); assertEquals("a${bar}", p.getPattern()); assertEquals("a{0}", p.getRawPattern()); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("bar")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("bar", "frobinator"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("frobinator", p.bind(a)[0]); assertEquals("afrobinator", p.replace(a)); }
public void testReplaceLocalName() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("${a.localPart}"); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("a")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("a", "foo@example.com"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("foo", p.bind(a)[0]); assertEquals("foo", p.replace(a)); a.put("a", "foo"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("foo", p.bind(a)[0]); assertEquals("foo", p.replace(a)); }
public com.google.gerrit.common.data.ParamertizedString.Builder replace(final java.lang.String name, final java.lang.String value) { params.put(name, value); return this; }
public com.google.gerrit.common.data.ParamertizedString.Builder replace(final java.lang.String name, final java.lang.String value) { return new com.google.gerrit.common.data.ParamertizedString.Builder().replace(name, value); }
private static java.util.Map<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function> initFunctions() { final java.util.HashMap<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function> m = new java.util.HashMap<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function>(); m.put("toLowerCase", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { return a.toLowerCase(); } }); m.put("toUpperCase", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { return a.toUpperCase(); } }); m.put("localPart", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { int at = a.indexOf('@'); return at < 0 ? a : a.substring(0, at); } }); return java.util.Collections.unmodifiableMap(m); }
public void testAsis1() { final com.google.gerrit.common.data.ParamertizedString p = com.google.gerrit.common.data.ParamertizedString.asis("${bar}c"); assertEquals("${bar}c", p.getPattern()); assertEquals("${bar}c", p.getRawPattern()); assertTrue(p.getParameterNames().isEmpty()); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("bar", "frobinator"); assertNotNull(p.bind(a)); assertEquals(0, p.bind(a).length); assertEquals("${bar}c", p.replace(a)); }
public void testUndefinedFunctionName() { com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("${a.anUndefinedMethod}"); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("a.anUndefinedMethod")); }
static com.google.gerrit.common.data.ParamertizedString paramString(org.eclipse.jgit.lib.Config c, java.lang.String n, java.lang.String d) { java.lang.String expression = com.google.gerrit.server.auth.ldap.LdapRealm.optdef(c, n, d); if (expression == null) { return null; } else if (expression.contains("${")) { return new com.google.gerrit.common.data.ParamertizedString(expression); } else { return new com.google.gerrit.common.data.ParamertizedString((("${" + expression) + "}")); } }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.AccountGroup.ExternalNameKey> lookupGroups(java.lang.String name) { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.ExternalNameKey> out; final java.util.Map<java.lang.String, java.lang.String> params = java.util.Collections.<java.lang.String, java.lang.String>emptyMap(); out = new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.ExternalNameKey>(); try { final javax.naming.directory.DirContext ctx = helper.open(); try { final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema = helper.getSchema(ctx); final com.google.gerrit.common.data.ParamertizedString filter = com.google.gerrit.common.data.ParamertizedString.asis(schema.groupPattern.replace(com.google.gerrit.server.auth.ldap.LdapRealm.GROUPNAME, name).toString()); for (java.lang.String groupBase : schema.groupBases) { final com.google.gerrit.server.auth.ldap.LdapQuery query = new com.google.gerrit.server.auth.ldap.LdapQuery(groupBase, schema.groupScope, filter, java.util.Collections.<java.lang.String>emptySet()); for (com.google.gerrit.server.auth.ldap.LdapQuery.Result res : query.query(ctx, params)) { out.add(new com.google.gerrit.reviewdb.AccountGroup.ExternalNameKey(res.getDN())); } } } finally { try { ctx.close(); } catch (javax.naming.NamingException e) { com.google.gerrit.server.auth.ldap.LdapRealm.log.warn("Cannot close LDAP query handle", e); } } } catch (javax.naming.NamingException e) { com.google.gerrit.server.auth.ldap.LdapRealm.log.warn("Cannot query LDAP for groups matching requested name", e); } return out; }
public void testEmptyString() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString(""); assertEquals("", p.getPattern()); assertEquals("", p.getRawPattern()); assertTrue(p.getParameterNames().isEmpty()); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); assertNotNull(p.bind(a)); assertEquals(0, p.bind(a).length); assertEquals("", p.replace(a)); }
public void testReplace4() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("a${bar}c"); assertEquals("a${bar}c", p.getPattern()); assertEquals("a{0}c", p.getRawPattern()); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("bar")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("", p.bind(a)[0]); assertEquals("ac", p.replace(a)); }
public void testReplace1() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("${bar}c"); assertEquals("${bar}c", p.getPattern()); assertEquals("{0}c", p.getRawPattern()); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("bar")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("bar", "frobinator"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("frobinator", p.bind(a)[0]); assertEquals("frobinatorc", p.replace(a)); }
public void testReplace2() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("a${bar}c"); assertEquals("a${bar}c", p.getPattern()); assertEquals("a{0}c", p.getRawPattern()); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("bar")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("bar", "frobinator"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("frobinator", p.bind(a)[0]); assertEquals("afrobinatorc", p.replace(a)); }
private static java.lang.String apply(com.google.gerrit.common.data.ParamertizedString p, com.google.gerrit.server.auth.ldap.LdapQuery.Result m) throws javax.naming.NamingException { if (p == null) { return null; } final java.util.Map<java.lang.String, java.lang.String> values = new java.util.HashMap<java.lang.String, java.lang.String>(); for (final java.lang.String name : m.attributes()) { values.put(name, m.get(name)); } java.lang.String r = p.replace(values); return r.isEmpty() ? null : r; }
public java.lang.String replace(final java.util.Map<java.lang.String, java.lang.String> params) { final java.lang.StringBuilder r = new java.lang.StringBuilder(); for (final com.google.gerrit.common.data.ParamertizedString.Format f : patternOps) { f.format(r, params); } return r.toString(); }
public java.util.List<java.lang.String> getParameterNames() { final java.util.ArrayList<java.lang.String> r = new java.util.ArrayList<java.lang.String>(parameters.size()); for (com.google.gerrit.common.data.ParamertizedString.Parameter p : parameters) { r.add(p.name); } return java.util.Collections.unmodifiableList(r); }
public void testReplaceToUpperCase() { final com.google.gerrit.common.data.ParamertizedString p = new com.google.gerrit.common.data.ParamertizedString("${a.toUpperCase}"); assertEquals(1, p.getParameterNames().size()); assertTrue(p.getParameterNames().contains("a")); final java.util.Map<java.lang.String, java.lang.String> a = new java.util.HashMap<java.lang.String, java.lang.String>(); a.put("a", "foo"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("FOO", p.bind(a)[0]); assertEquals("FOO", p.replace(a)); a.put("a", "FOO"); assertNotNull(p.bind(a)); assertEquals(1, p.bind(a).length); assertEquals("FOO", p.bind(a)[0]); assertEquals("FOO", p.replace(a)); }
public static com.google.gerrit.common.data.ParamertizedString asis(final java.lang.String constant) { return new com.google.gerrit.common.data.ParamertizedString(new com.google.gerrit.common.data.ParamertizedString.Constant(constant)); }



public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { box.hide(); }
@java.lang.Override public void onSubmit(final com.google.gwt.user.client.ui.FormPanel.SubmitEvent event) { event.cancel(); final java.lang.String addr = inEmail.getText().trim(); if (!(addr.contains("@"))) { return; } inEmail.setEnabled(false); register.setEnabled(false); Util.ACCOUNT_SEC.registerEmail(addr, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { box.hide(); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { inEmail.setEnabled(true); register.setEnabled(true); super.onFailure(caught); } }); }
static void upgradeUI(java.lang.String token) { com.google.gwt.user.client.History.newItem(((Dispatcher.RELOAD_UI) + token), false); Window.Location.reload(); }
public void registerEmail(final java.lang.String address, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> cb) { try { final com.google.gerrit.server.mail.RegisterNewEmailSender sender; sender = registerNewEmailFactory.create(address); sender.send(); cb.onSuccess(VoidResult.INSTANCE); } catch (com.google.gerrit.server.mail.EmailException e) { log.error(("Cannot send email verification message to " + address), e); cb.onFailure(e); } catch (java.lang.RuntimeException e) { log.error(("Cannot send email verification message to " + address), e); cb.onFailure(e); } }
public void validateEmail(final java.lang.String token, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { try { final com.google.gwtjsonrpc.server.ValidToken t = authConfig.getEmailRegistrationToken().checkToken(token, null); if (((t == null) || ((t.getData()) == null)) || ("".equals(t.getData()))) { callback.onFailure(new java.lang.IllegalStateException("Invalid token")); return; } final java.lang.String newEmail = new java.lang.String(org.eclipse.jgit.util.Base64.decode(t.getData()), "UTF-8"); if (!(newEmail.contains("@"))) { callback.onFailure(new java.lang.IllegalStateException("Invalid token")); return; } accountManager.link(user.get().getAccountId(), com.google.gerrit.server.account.AuthRequest.forEmail(newEmail)); callback.onSuccess(VoidResult.INSTANCE); } catch (com.google.gwtjsonrpc.server.XsrfException e) { callback.onFailure(e); } catch (java.io.UnsupportedEncodingException e) { callback.onFailure(e); } catch (com.google.gerrit.server.account.AccountException e) { callback.onFailure(e); } }
private static java.util.Map<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function> initFunctions() { final java.util.HashMap<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function> m = new java.util.HashMap<java.lang.String, com.google.gerrit.common.data.ParamertizedString.Function>(); m.put("toLowerCase", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { return a.toLowerCase(); } }); m.put("toUpperCase", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { return a.toUpperCase(); } }); m.put("localPart", new com.google.gerrit.common.data.ParamertizedString.Function() { @java.lang.Override java.lang.String apply(java.lang.String a) { int at = a.indexOf('@'); return at < 0 ? a : a.substring(0, at); } }); return java.util.Collections.unmodifiableMap(m); }


@java.lang.Override protected void onInitUI() { super.onInitUI(); addStyleName(Gerrit.RESOURCES.css().publishCommentsScreen()); approvalButtons = new java.util.ArrayList<com.google.gerrit.client.changes.PublishCommentScreen.ValueRadioButton>(); descBlock = new com.google.gerrit.client.changes.ChangeDescriptionBlock(); add(descBlock); final com.google.gwt.user.client.ui.FormPanel form = new com.google.gwt.user.client.ui.FormPanel(); final com.google.gwt.user.client.ui.FlowPanel body = new com.google.gwt.user.client.ui.FlowPanel(); form.setWidget(body); form.addSubmitHandler(new com.google.gwt.user.client.ui.FormPanel.SubmitHandler() { @java.lang.Override public void onSubmit(final com.google.gwt.user.client.ui.FormPanel.SubmitEvent event) { event.cancel(); } }); add(form); approvalPanel = new com.google.gwt.user.client.ui.FlowPanel(); body.add(approvalPanel); initMessage(body); draftsPanel = new com.google.gwt.user.client.ui.FlowPanel(); body.add(draftsPanel); final com.google.gwt.user.client.ui.FlowPanel buttonRow = new com.google.gwt.user.client.ui.FlowPanel(); buttonRow.setStyleName(Gerrit.RESOURCES.css().patchSetActions()); body.add(buttonRow); send = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishCommentsSend()); send.addClickHandler(this); buttonRow.add(send); submit = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishSubmitSend()); submit.addClickHandler(this); buttonRow.add(submit); cancel = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishCommentsCancel()); cancel.addClickHandler(this); buttonRow.add(cancel); }




private void listPendingSubmits() throws com.google.gerrit.server.git.MergeException { try { submitted = schema.changes().submitted(destBranch).toList(); } catch (com.google.gwtorm.client.OrmException e) { throw new com.google.gerrit.server.git.MergeException("Cannot query the database", e); } }
private void mergeImpl() throws com.google.gerrit.server.git.MergeException { openRepository(); openBranch(); listPendingSubmits(); validateChangeList(); mergeTip = branchTip; switch (destProject.getSubmitType()) { case CHERRY_PICK : cherryPickChanges(); break; case FAST_FORWARD_ONLY : case MERGE_ALWAYS : case MERGE_IF_NECESSARY : default : reduceToMinimalMerge(); mergeTopics(); markCleanMerges(); break; } updateBranch(); updateChangeStatus(); updateSubscriptions(); }

@java.lang.Override public void myGroups(final com.google.gwt.user.client.rpc.AsyncCallback<java.util.List<com.google.gerrit.reviewdb.AccountGroup>> callback) { myGroupsFactory.create().to(callback); }






public void run() { synchronized(cleanup) { for (final java.util.Iterator<java.lang.Runnable> i = cleanup.iterator(); i.hasNext();) { try { i.next().run(); } catch (java.lang.Throwable err) { com.google.gerrit.server.RequestCleanup.log.error("Failed to execute per-request cleanup", err); } i.remove(); } } }
public void add(final java.lang.Runnable task) { synchronized(cleanup) { cleanup.add(task); } }
public static com.google.gerrit.common.data.GitWebType fromName(final java.lang.String name) { final com.google.gerrit.common.data.GitWebType type; if (((name == null) || (name.isEmpty())) || (name.equalsIgnoreCase("gitweb"))) { type = new com.google.gerrit.common.data.GitWebType(); type.setProject("?p=${project}.git;a=summary"); type.setRevision("?p=${project}.git;a=commit;h=${commit}"); type.setBranch("?p=${project}.git;a=shortlog;h=${branch}"); } else if (name.equalsIgnoreCase("cgit")) { type = new com.google.gerrit.common.data.GitWebType(); type.setProject("${project}/summary"); type.setRevision("${project}/commit/?id=${commit}"); type.setBranch("${project}/log/?h=${branch}"); } else if (name.equalsIgnoreCase("custom")) { type = new com.google.gerrit.common.data.GitWebType(); } else { type = null; } return type; }

@java.lang.Override public void setValue(com.google.gerrit.common.data.ProjectAccess value) { if (((editing) && (value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES))) && ((value.getLocal(AccessSection.GLOBAL_CAPABILITIES)) == null)) { value.getLocal().add(0, new com.google.gerrit.common.data.AccessSection(com.google.gerrit.common.data.AccessSection.GLOBAL_CAPABILITIES)); } this.value = value; com.google.gerrit.reviewdb.Project.NameKey parent = value.getInheritsFrom(); if (parent != null) { inheritsFrom.getStyle().setDisplay(Display.BLOCK); parentProject.setText(parent.get()); parentProject.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS)); } else { inheritsFrom.getStyle().setDisplay(Display.NONE); } addSection.setVisible((((value != null) && (editing)) && (!(value.getOwnerOf().isEmpty())))); }
@java.lang.Override public com.google.gerrit.common.data.ProjectDetail call() throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Project.NameKey projectName = update.getNameKey(); projectControlFactory.ownerFor(projectName); final com.google.gerrit.server.git.MetaDataUpdate md; try { md = metaDataUpdateFactory.create(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notFound) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } try { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.getProject().copySettingsFrom(update); md.setMessage("Modified project settings\n"); if (config.commit(md)) { mgr.setProjectDescription(projectName, update.getDescription()); projectCache.evict(config.getProject()); } else { throw new com.google.gwtorm.client.OrmConcurrencyException(("Cannot update " + projectName)); } } catch (org.eclipse.jgit.errors.ConfigInvalidException err) { throw new com.google.gwtorm.client.OrmException(("Cannot read project " + projectName), err); } catch (java.io.IOException err) { throw new com.google.gwtorm.client.OrmException(("Cannot update project " + projectName), err); } finally { md.close(); } return projectDetailFactory.create(projectName).call(); }






@java.lang.Override public com.google.gerrit.common.data.GroupList call() throws java.lang.Exception { final com.google.gerrit.server.IdentifiedUser user = identifiedUser.get(); final java.util.List<com.google.gerrit.reviewdb.AccountGroup> list; if (user.getCapabilities().canAdministrateServer()) { list = new java.util.LinkedList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup group : groupCache.all()) { list.add(group); } } else { list = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup group : groupCache.all()) { final com.google.gerrit.server.account.GroupControl c = groupControlFactory.controlFor(group); if (c.isVisible()) { list.add(c.getAccountGroup()); } } } java.util.List<com.google.gerrit.common.data.GroupDetail> l = new java.util.ArrayList<com.google.gerrit.common.data.GroupDetail>(); for (com.google.gerrit.reviewdb.AccountGroup group : list) { l.add(groupDetailFactory.create(group.getId()).call()); } com.google.gerrit.common.data.GroupList res = new com.google.gerrit.common.data.GroupList(); res.setGroups(l); res.setCanCreateGroup(user.getCapabilities().canCreateGroup()); return res; }

private void display() throws com.google.gerrit.sshd.commands.Failure { final java.io.PrintWriter stdout = toPrintWriter(out); try { final com.google.gerrit.common.data.GroupList visibleGroups = performVisibleGroupsFactory.create().getVisibleGroups(); for (final GroupDetail groupDetail : visibleGroups.getGroups()) { stdout.print(((groupDetail.group.getName()) + "\n")); } } catch (com.google.gwtorm.client.OrmException e) { throw die(e); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw die(e); } finally { stdout.flush(); } }

public com.google.gerrit.common.data.GroupList getVisibleGroups() throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.client.OrmException { final com.google.gerrit.server.IdentifiedUser user = identifiedUser.get(); final java.util.List<com.google.gerrit.reviewdb.AccountGroup> list; if (user.getCapabilities().canAdministrateServer()) { list = new java.util.LinkedList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup group : groupCache.all()) { list.add(group); } } else { list = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroup>(); for (final com.google.gerrit.reviewdb.AccountGroup group : groupCache.all()) { final com.google.gerrit.server.account.GroupControl c = groupControlFactory.controlFor(group); if (c.isVisible()) { list.add(c.getAccountGroup()); } } } java.util.List<com.google.gerrit.common.data.GroupDetail> l = new java.util.ArrayList<com.google.gerrit.common.data.GroupDetail>(); for (com.google.gerrit.reviewdb.AccountGroup group : list) { l.add(groupDetailFactory.create(group.getId()).call()); } com.google.gerrit.common.data.GroupList res = new com.google.gerrit.common.data.GroupList(); res.setGroups(l); res.setCanCreateGroup(user.getCapabilities().canCreateGroup()); return res; }

private void display() throws com.google.gerrit.sshd.commands.Failure { final java.io.PrintWriter stdout = toPrintWriter(out); try { final com.google.gerrit.server.account.PerformVisibleGroups performVisibleGroups = performVisibleGroupsFactory.create(); performVisibleGroups.setProjects(projects); final com.google.gerrit.common.data.GroupList visibleGroups = performVisibleGroups.getVisibleGroups(); for (final GroupDetail groupDetail : visibleGroups.getGroups()) { stdout.print(((groupDetail.group.getName()) + "\n")); } } catch (com.google.gwtorm.client.OrmException e) { throw die(e); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw die(e); } finally { stdout.flush(); } }
private void display() throws com.google.gerrit.sshd.commands.Failure { final java.io.PrintWriter stdout = toPrintWriter(out); try { final com.google.gerrit.server.account.PerformVisibleGroups performVisibleGroups = performVisibleGroupsFactory.create(); performVisibleGroups.setProjects(projects); performVisibleGroups.setOnlyVisibleToAll(visibleToAll); final com.google.gerrit.common.data.GroupList visibleGroups = performVisibleGroups.getVisibleGroups(); for (final GroupDetail groupDetail : visibleGroups.getGroups()) { stdout.print(((groupDetail.group.getName()) + "\n")); } } catch (com.google.gwtorm.client.OrmException e) { throw die(e); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw die(e); } finally { stdout.flush(); } }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.Account> call() throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.client.OrmException { return listAccounts(groupUUID, new java.util.HashSet<com.google.gerrit.reviewdb.AccountGroup.UUID>()); }
private boolean suggestGroupAsReviewer(final com.google.gerrit.reviewdb.Project.NameKey project, final com.google.gerrit.common.data.GroupReference group) throws com.google.gwtorm.client.OrmException { if (!(com.google.gerrit.server.patch.AddReviewer.isLegalReviewerGroup(group.getUUID()))) { return false; } try { final java.util.Set<com.google.gerrit.reviewdb.Account> members = groupMembersFactory.create(project, group.getUUID()).call(); if (members.isEmpty()) { return false; } final int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", AddReviewer.DEFAULT_MAX_REVIEWERS); if ((maxAllowed > 0) && ((members.size()) > maxAllowed)) { return false; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { return false; } catch (com.google.gerrit.server.project.NoSuchProjectException e) { return false; } return true; }
com.google.gerrit.server.account.GroupMembersFactory create(com.google.gerrit.reviewdb.Project.NameKey project, com.google.gerrit.reviewdb.AccountGroup.UUID groupUUID);
private void onLogin() { hideError(); final java.lang.String user = username.getText(); if ((user == null) || (user.equals(""))) { showError(Util.C.usernameRequired()); username.setFocus(true); return; } final java.lang.String pass = password.getText(); if ((pass == null) || (pass.equals(""))) { showError(Util.C.passwordRequired()); password.setFocus(true); return; } enable(false); Util.SVC.authenticate(user, pass, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.auth.userpass.LoginResult>() { public void onSuccess(final com.google.gerrit.common.auth.userpass.LoginResult result) { if (result.success) { java.lang.String to = token; if (!(to.startsWith("/"))) { to = "/" + to; } if ((result.isNew) && (!(token.startsWith(((com.google.gerrit.common.PageLinks.REGISTER) + "/"))))) { to = (com.google.gerrit.common.PageLinks.REGISTER) + to; } com.google.gwt.user.client.Window.Location.replace((((com.google.gwt.user.client.Window.Location.getPath()) + "login") + to)); } else { showError(Util.C.invalidLogin()); enable(true); password.selectAll(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { password.setFocus(true); } }); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { super.onFailure(caught); enable(true); } }); }
public void onSuccess(final com.google.gerrit.common.auth.userpass.LoginResult result) { if (result.success) { java.lang.String to = token; if (!(to.startsWith("/"))) { to = "/" + to; } if ((result.isNew) && (!(token.startsWith(((com.google.gerrit.common.PageLinks.REGISTER) + "/"))))) { to = (com.google.gerrit.common.PageLinks.REGISTER) + to; } com.google.gwt.user.client.Window.Location.replace((((com.google.gwt.user.client.Window.Location.getPath()) + "login") + to)); } else { showError(Util.C.invalidLogin()); enable(true); password.selectAll(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { password.setFocus(true); } }); } }
@java.lang.Override public void authenticate(java.lang.String username, final java.lang.String password, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.auth.userpass.LoginResult> callback) { com.google.gerrit.common.auth.userpass.LoginResult result = new com.google.gerrit.common.auth.userpass.LoginResult(); if ((((username == null) || ("".equals(username.trim()))) || (password == null)) || ("".equals(password))) { result.success = false; callback.onSuccess(result); return; } username = username.trim(); final com.google.gerrit.server.account.AuthRequest req = com.google.gerrit.server.account.AuthRequest.forUser(username); req.setPassword(password); final com.google.gerrit.server.account.AuthResult res; try { res = accountManager.authenticate(req); } catch (com.google.gerrit.server.account.AccountUserNameException e) { callback.onFailure(e); return; } catch (com.google.gerrit.server.account.AccountException e) { result.success = false; callback.onSuccess(result); return; } result.success = true; result.isNew = res.isNew(); webSession.get().login(res, true); callback.onSuccess(result); }
public boolean canDelete() { if (GitRepositoryManager.REF_CONFIG.equals(refName)) { return false; } switch (getCurrentUser().getAccessPath()) { case WEB_UI : return (isOwner()) || (canPushWithForce()); case GIT : return canPushWithForce(); default : return false; } }
private boolean canPushWithForce() { if ((GitRepositoryManager.REF_CONFIG.equals(refName)) && (!(projectControl.isOwner()))) { return false; } boolean result = false; for (com.google.gerrit.common.data.PermissionRule rule : access(Permission.PUSH)) { if (rule.isBlock()) { return false; } if (rule.getForce()) { result = true; } } return result; }
public boolean canUpload() { return projectControl.controlForRef(("refs/for/" + (getRefName()))).canPerform(Permission.PUSH); }

public boolean canUploadMerges() { return projectControl.controlForRef(("refs/for/" + (getRefName()))).canPerform(Permission.PUSH_MERGE); }
public boolean canCreate(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevObject object) { boolean owner; switch (getCurrentUser().getAccessPath()) { case WEB_UI : owner = isOwner(); break; default : owner = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { return owner || (canPerform(Permission.CREATE)); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if ((getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); final java.lang.String addr = tagger.getEmailAddress(); valid = user.getEmailAddresses().contains(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.PUSH_TAG)); } else { return owner || (canPerform(Permission.PUSH_TAG)); } } else { return false; } }
public boolean isVisible() { return (visibleForReplication()) || (canPerformOnAnyRef(Permission.READ)); }
public boolean canSubmit() { if (GitRepositoryManager.REF_CONFIG.equals(refName)) { return projectControl.isOwner(); } return canPerform(Permission.SUBMIT); }
public boolean canForceUpdate() { return (canPushWithForce()) || (canDelete()); }


public boolean canUpdate() { if ((GitRepositoryManager.REF_CONFIG.equals(refName)) && (!(projectControl.isOwner()))) { return false; } return canPerform(Permission.PUSH); }
public boolean isVisible() { return (projectControl.visibleForReplication()) || (canPerform(Permission.READ)); }




public java.lang.String toProject(final com.google.gerrit.reviewdb.Project.NameKey project) { com.google.gerrit.common.data.ParameterizedString pattern = new com.google.gerrit.common.data.ParameterizedString(type.getProject()); final java.util.Map<java.lang.String, java.lang.String> p = new java.util.HashMap<java.lang.String, java.lang.String>(); p.put("project", com.google.gwt.http.client.URL.encodeQueryString(project.get())); return (baseUrl) + (pattern.replace(p)); }
private void display() throws com.google.gerrit.sshd.commands.Failure { final java.io.PrintWriter stdout = toPrintWriter(out); try { final com.google.gerrit.server.account.VisibleGroups visibleGroups = visibleGroupsFactory.create(); visibleGroups.setProjects(projects); visibleGroups.setOnlyVisibleToAll(visibleToAll); visibleGroups.setGroupType(groupType); final com.google.gerrit.common.data.GroupList groupList = visibleGroups.get(); for (final GroupDetail groupDetail : groupList.getGroups()) { stdout.print(((groupDetail.group.getName()) + "\n")); } } catch (com.google.gwtorm.client.OrmException e) { throw die(e); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw die(e); } finally { stdout.flush(); } }

public com.google.gerrit.common.data.GroupList get() throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.client.OrmException { final java.lang.Iterable<com.google.gerrit.reviewdb.AccountGroup> groups; if (((projects) != null) && (!(projects.isEmpty()))) { groups = getGroupsForProjects(); } else { groups = groupCache.all(); } return createGroupList(filterGroups(groups)); }
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.AccountGroup> call() { final java.util.Set<com.google.gerrit.reviewdb.AccountGroup.UUID> effective = user.getEffectiveGroups(); final int cnt = effective.size(); final java.util.List<com.google.gerrit.reviewdb.AccountGroup> groupList = new java.util.ArrayList<com.google.gerrit.reviewdb.AccountGroup>(cnt); for (final com.google.gerrit.reviewdb.AccountGroup.UUID groupId : effective) { groupList.add(groupCache.get(groupId)); } java.util.Collections.sort(groupList, new java.util.Comparator<com.google.gerrit.reviewdb.AccountGroup>() { @java.lang.Override public int compare(com.google.gerrit.reviewdb.AccountGroup a, com.google.gerrit.reviewdb.AccountGroup b) { return a.getName().compareTo(b.getName()); } }); return groupList; }
@java.lang.Override public com.google.gwtjsonrpc.client.VoidResult call() throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.validateFor(changeId); change = ctl.getChange(); patchSet = db.patchSets().get(patchSetId); if ((patchSet) == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } drafts = drafts(); publishDrafts(); final boolean isCurrent = patchSetId.equals(change.currentPatchSetId()); if (isCurrent && (change.getStatus().isOpen())) { publishApprovals(ctl); } else if (!(approvals.isEmpty())) { throw new com.google.gerrit.server.project.InvalidChangeOperationException("Change is closed"); } else { publishMessageOnly(); } touchChange(); email(); fireHook(); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
com.google.gerrit.server.patch.PublishComments create(com.google.gerrit.reviewdb.PatchSet.Id patchSetId, java.lang.String messageText, java.util.Set<com.google.gerrit.reviewdb.ApprovalCategoryValue.Id> approvals);

@java.lang.Override public void start(final org.apache.sshd.server.Environment env) { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws java.lang.Exception { if (!(currentUser.getCapabilities().canCreateProject())) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName()); throw new com.google.gerrit.sshd.commands.UnloggedFailure(com.google.gerrit.sshd.BaseCommand.STATUS_NOT_ADMIN, msg); } parseCommandLine(); validateParameters(); try { nameKey = new com.google.gerrit.reviewdb.Project.NameKey(projectName); java.lang.String head = (permissionsOnly) ? com.google.gerrit.server.git.GitRepositoryManager.REF_CONFIG : branch; final org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(nameKey); try { rq.replicateNewProject(nameKey, head); org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(head); createProjectConfig(); if ((!(permissionsOnly)) && (createEmptyCommit)) { createEmptyCommit(repo, nameKey, branch); } } finally { repo.close(); } } catch (java.lang.IllegalStateException err) { handleRepositoryExistsException(nameKey); } catch (com.google.gerrit.server.git.RepositoryCaseMismatchException err) { handleRepositoryExistsException(err.getNameOfExistingProject()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException badName) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("fatal: " + (badName.getMessage()))); } catch (java.lang.Exception err) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: Cannot create " + (projectName)), err); } } }); }
@java.lang.Override public void replicateNewProject(com.google.gerrit.reviewdb.Project.NameKey projectName, java.lang.String head) { if (!(isEnabled())) { return; } for (com.google.gerrit.server.git.PushReplication.ReplicationConfig config : configs) { java.util.List<org.eclipse.jgit.transport.URIish> uriList = config.getURIs(projectName, "*"); java.lang.String[] adminUrls = config.getAdminUrls(); boolean adminURLUsed = false; for (java.lang.String url : adminUrls) { org.eclipse.jgit.transport.URIish adminURI = null; try { if ((url != null) && (!(url.isEmpty()))) { adminURI = new org.eclipse.jgit.transport.URIish(url); } } catch (java.net.URISyntaxException e) { com.google.gerrit.server.git.PushReplication.log.error((("The URL '" + url) + "' is invalid")); } if (adminURI != null) { final java.lang.String replacedPath = com.google.gerrit.server.git.PushReplication.replace(adminURI.getPath(), "name", projectName.get()); if (replacedPath != null) { adminURI = adminURI.setPath(replacedPath); if (usingSSH(adminURI)) { replicateProject(adminURI, head); adminURLUsed = true; } else { com.google.gerrit.server.git.PushReplication.log.error((("The adminURL '" + url) + "' is non-SSH which is not allowed")); } } } } if (!adminURLUsed) { for (org.eclipse.jgit.transport.URIish uri : uriList) { replicateProject(uri, head); } } } }
@java.lang.Override public void run() throws java.lang.Exception { if (!(currentUser.getCapabilities().canCreateProject())) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName()); throw new com.google.gerrit.sshd.commands.UnloggedFailure(com.google.gerrit.sshd.BaseCommand.STATUS_NOT_ADMIN, msg); } parseCommandLine(); validateParameters(); try { nameKey = new com.google.gerrit.reviewdb.Project.NameKey(projectName); java.lang.String head = (permissionsOnly) ? com.google.gerrit.server.git.GitRepositoryManager.REF_CONFIG : branch; final org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(nameKey); try { rq.replicateNewProject(nameKey, head); org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(head); createProjectConfig(); if ((!(permissionsOnly)) && (createEmptyCommit)) { createEmptyCommit(repo, nameKey, branch); } } finally { repo.close(); } } catch (java.lang.IllegalStateException err) { handleRepositoryExistsException(nameKey); } catch (com.google.gerrit.server.git.RepositoryCaseMismatchException err) { handleRepositoryExistsException(err.getNameOfExistingProject()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException badName) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("fatal: " + (badName.getMessage()))); } catch (java.lang.Exception err) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: Cannot create " + (projectName)), err); } }
private void replicateProject(final org.eclipse.jgit.transport.URIish replicateURI, final java.lang.String head) { org.eclipse.jgit.transport.SshSessionFactory sshFactory = org.eclipse.jgit.transport.SshSessionFactory.getInstance(); org.eclipse.jgit.transport.RemoteSession sshSession; java.lang.String projectPath = QuotedString.BOURNE.quote(replicateURI.getPath()); if (!(usingSSH(replicateURI))) { com.google.gerrit.server.git.PushReplication.log.warn((("Cannot create new project on remote site since the connection " + "method is not SSH: ") + (replicateURI.toString()))); return; } java.io.OutputStream errStream = createErrStream(); java.lang.String cmd = ((((("mkdir -p " + projectPath) + "&& cd ") + projectPath) + "&& git init --bare") + "&& git symbolic-ref HEAD ") + (QuotedString.BOURNE.quote(head)); try { sshSession = sshFactory.getSession(replicateURI, null, FS.DETECTED, 0); java.lang.Process proc = sshSession.exec(cmd, 0); proc.getOutputStream().close(); org.eclipse.jgit.util.io.StreamCopyThread out = new org.eclipse.jgit.util.io.StreamCopyThread(proc.getInputStream(), errStream); org.eclipse.jgit.util.io.StreamCopyThread err = new org.eclipse.jgit.util.io.StreamCopyThread(proc.getErrorStream(), errStream); out.start(); err.start(); try { proc.waitFor(); out.halt(); err.halt(); } catch (java.lang.InterruptedException interrupted) { } sshSession.disconnect(); } catch (java.io.IOException e) { com.google.gerrit.server.git.PushReplication.log.error(((((((("Communication error when trying to replicate to: " + (replicateURI.toString())) + "\n") + "Error reported: ") + (e.getMessage())) + "\n") + "Error in communication: ") + (errStream.toString()))); } }
private void parseRewind(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevCommit newObject; try { newObject = rp.getRevWalk().parseCommit(cmd.getNewId()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException notCommit) { newObject = null; } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " forced update"), err); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid object"); return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (newObject != null) { validateNewCommits(ctl, cmd); if ((cmd.getResult()) != (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { return; } } if (ctl.canForceUpdate()) { } else { cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD); } }
@java.lang.Override public com.google.gerrit.reviewdb.Change update(com.google.gerrit.reviewdb.Change change) { if (change.getStatus().isOpen()) { if ((destTopicName) != null) { change.setTopic(destTopicName); } change.setStatus(Change.Status.NEW); change.setCurrentPatchSet(result.info); com.google.gerrit.server.ChangeUtil.updated(change); return change; } else { return null; } }



public void deleteDraft(final com.google.gerrit.reviewdb.PatchLineComment.Key commentKey, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { run(callback, new com.google.gerrit.httpd.rpc.patch.Action<com.google.gwtjsonrpc.client.VoidResult>() { public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.patch.Failure, com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.PatchLineComment comment = db.patchComments().get(commentKey); if (comment == null) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } if (!(getAccountId().equals(comment.getAuthor()))) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } if ((comment.getStatus()) != (PatchLineComment.Status.DRAFT)) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new java.lang.IllegalStateException("Comment published")); } db.patchComments().delete(java.util.Collections.singleton(comment)); return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } }); }



private void onDiscard() { expandTimer.cancel(); if (isNew()) { text.setFocus(false); removeUI(); return; } text.setFocus(false); text.setReadOnly(true); save.setEnabled(false); cancel.setEnabled(false); discard.setEnabled(false); PatchUtil.DETAIL_SVC.deleteDraft(comment.getKey(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.client.VoidResult result) { notifyDraftDelta((-1)); removeUI(); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { text.setReadOnly(false); text.setFocus(true); save.setEnabled(true); cancel.setEnabled(true); discard.setEnabled(true); super.onFailure(caught); } }); }
@com.google.gerrit.common.auth.SignInRequired void deleteDraft(com.google.gerrit.reviewdb.PatchLineComment.Key key, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback);


public static java.lang.String toLongString(final com.google.gerrit.reviewdb.Change.Status status) { if (status == null) { return ""; } switch (status) { case NEW : return com.google.gerrit.client.changes.Util.C.statusLongNew(); case SUBMITTED : return com.google.gerrit.client.changes.Util.C.statusLongSubmitted(); case MERGED : return com.google.gerrit.client.changes.Util.C.statusLongMerged(); case ABANDONED : return com.google.gerrit.client.changes.Util.C.statusLongAbandoned(); default : return status.name(); } }




private void loadMessages() throws com.google.gwtorm.client.OrmException { detail.setMessages(db.changeMessages().byChange(changeId).toList()); for (final com.google.gerrit.reviewdb.ChangeMessage m : detail.getMessages()) { aic.want(m.getAuthor()); } }
private void loadPatchSets() throws com.google.gwtorm.client.OrmException { detail.setPatchSets(db.patchSets().byChange(changeId).toList()); }
public boolean isVisible() { return getRefControl().isVisible(); }
private void matchChange(java.util.Set<com.google.gerrit.reviewdb.Change.Id> matched, com.google.gerrit.reviewdb.Change change) { try { if (((change != null) && (inProject(change))) && (changeControlFactory.controlFor(change).isVisible())) { matched.add(change.getId()); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { } }


public com.google.gerrit.common.data.Capable canUpload() { com.google.gerrit.common.data.Capable result = projectControl.canPushToAtLeastOneRef(); if (result != (com.google.gerrit.common.data.Capable.OK)) { return result; } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> blockingFors; try { blockingFors = repo.getRefDatabase().getRefs("refs/for/"); } catch (java.io.IOException err) { java.lang.String projName = project.getName(); com.google.gerrit.server.git.ReceiveCommits.log.warn((("Cannot scan refs in '" + projName) + "'"), err); return new com.google.gerrit.common.data.Capable((("Server process cannot read '" + projName) + "'")); } if (!(blockingFors.isEmpty())) { java.lang.String projName = project.getName(); com.google.gerrit.server.git.ReceiveCommits.log.error(((("Repository '" + projName) + "' needs the following refs removed to receive changes: ") + (blockingFors.keySet()))); return new com.google.gerrit.common.data.Capable("One or more refs/for/ names blocks change upload"); } return com.google.gerrit.common.data.Capable.OK; }
private com.google.gerrit.reviewdb.ChangeMessage message(final com.google.gerrit.reviewdb.Change c, final java.lang.String body) { final java.lang.String uuid; try { uuid = com.google.gerrit.server.ChangeUtil.messageUUID(schema); } catch (com.google.gwtorm.client.OrmException e) { return null; } final com.google.gerrit.reviewdb.ChangeMessage m = new com.google.gerrit.reviewdb.ChangeMessage(new com.google.gerrit.reviewdb.ChangeMessage.Key(c.getId(), uuid), null); m.setMessage(body); return m; }

public org.apache.velocity.runtime.RuntimeInstance get() { java.lang.String rl = "resource.loader"; java.lang.String pkg = "org.apache.velocity.runtime.resource.loader"; java.util.Properties p = new java.util.Properties(); p.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS, com.google.gerrit.server.mail.VelocityRuntimeProvider.Slf4jLogChute.class.getName()); p.setProperty("runtime.log.logsystem.log4j.category", "velocity"); if (site.mail_dir.isDirectory()) { p.setProperty(rl, "file, class"); p.setProperty((("file." + rl) + ".class"), (pkg + ".FileResourceLoader")); p.setProperty((("file." + rl) + ".path"), site.mail_dir.getAbsolutePath()); p.setProperty((("class." + rl) + ".class"), (pkg + ".ClasspathResourceLoader")); } else { p.setProperty(rl, "class"); p.setProperty((("class." + rl) + ".class"), (pkg + ".ClasspathResourceLoader")); } org.apache.velocity.runtime.RuntimeInstance ri = new org.apache.velocity.runtime.RuntimeInstance(); try { ri.init(p); } catch (java.lang.Exception err) { throw new com.google.inject.ProvisionException("Cannot configure Velocity templates", err); } return ri; }
private com.google.inject.Injector createWebInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(sshInjector.getInstance(com.google.gerrit.httpd.WebModule.class)); modules.add(sysInjector.getInstance(com.google.gerrit.httpd.GitOverHttpModule.class)); modules.add(sshInjector.getInstance(com.google.gerrit.httpd.WebSshGlueModule.class)); modules.add(com.google.gerrit.httpd.CacheBasedWebSession.module()); modules.add(com.google.gerrit.server.contact.HttpContactStoreConnection.module()); if (sshd) { modules.add(sshInjector.getInstance(com.google.inject.Module.class)); } return sysInjector.createChildInjector(modules); }




@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.Project> call() { java.util.List<com.google.gerrit.reviewdb.Project> result = new java.util.ArrayList<com.google.gerrit.reviewdb.Project>(); for (com.google.gerrit.reviewdb.Project.NameKey p : projectCache.all()) { try { com.google.gerrit.server.project.ProjectControl c = projectControlFactory.controlFor(p); if ((c.isVisible()) || (c.isOwner())) { result.add(c.getProject()); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.Project>() { public int compare(final com.google.gerrit.reviewdb.Project a, final com.google.gerrit.reviewdb.Project b) { return a.getName().compareTo(b.getName()); } }); return result; }


@java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); }

void visibleProjects(com.google.gwt.user.client.rpc.AsyncCallback<java.util.List<com.google.gerrit.reviewdb.Project>> callback);
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.Project> call() throws com.google.gwtorm.client.OrmException { final java.util.List<com.google.gerrit.reviewdb.Project> result; if (user.isAdministrator()) { result = db.projects().all().toList(); } else { result = new java.util.ArrayList<com.google.gerrit.reviewdb.Project>(); for (com.google.gerrit.reviewdb.Project p : db.projects().all().toList()) { try { com.google.gerrit.server.project.ProjectControl c = projectControlFactory.controlFor(p.getNameKey()); if ((c.isVisible()) || (c.isOwner())) { result.add(p); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } } } java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.Project>() { public int compare(final com.google.gerrit.reviewdb.Project a, final com.google.gerrit.reviewdb.Project b) { return a.getName().compareTo(b.getName()); } }); return result; }
@java.lang.Override public void visibleProjects(final com.google.gwt.user.client.rpc.AsyncCallback<java.util.List<com.google.gerrit.reviewdb.Project>> callback) { visibleProjectsFactory.create().to(callback); }

@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.project.ProjectAdminServiceImpl.class); }



protected void onInitUI() { final com.google.gwt.user.client.ui.FlowPanel me = ((com.google.gwt.user.client.ui.FlowPanel) (getWidget())); me.add((header = new com.google.gwt.user.client.ui.FlowPanel())); me.add((body = new com.google.gwt.user.client.ui.FlowPanel())); header.setStyleName(Gerrit.RESOURCES.css().screenHeader()); header.add((headerText = new com.google.gwt.user.client.ui.InlineLabel())); }
protected void insertTitleWidget(final com.google.gwt.user.client.ui.Widget w) { header.insert(w, 0); }
protected abstract void runImpl() throws com.google.gerrit.sshd.Failure, java.io.IOException;
private com.google.gerrit.server.patch.PatchList compute(final com.google.gerrit.server.patch.PatchListKey key) throws java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(key.projectKey.get()); try { return readPatchList(key, repo); } finally { repo.close(); } }

private void mergeImpl() throws com.google.gerrit.server.git.MergeException { openRepository(); openBranch(); listPendingSubmits(); validateChangeList(); mergeTip = branchTip; switch (destProject.getSubmitType()) { case CHERRY_PICK : cherryPickChanges(); break; case FAST_FORWARD_ONLY : case MERGE_ALWAYS : case MERGE_IF_NECESSARY : default : reduceToMinimalMerge(); mergeTopics(); markCleanMerges(); break; } updateBranch(); updateChangeStatus(); }





private void service() throws com.google.gerrit.sshd.Failure, java.io.IOException { project = projectControl.getProjectState().getProject(); final java.lang.String name = project.getName(); try { repo = repoManager.openRepository(name); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.Failure(1, (("fatal: '" + name) + "': not a git archive"), e); } try { runImpl(); } finally { repo.close(); } }

private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(com.google.gerrit.server.schema.SchemaVersionCheck.module()); modules.add(new com.google.gerrit.pgm.util.LogFileCompressor.Module()); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.cache.EhcachePoolImpl.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); if (httpd) { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); } else { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.server.config.CanonicalWebUrlProvider.class; } }); } if (!(slave)) { modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); } return cfgInjector.createChildInjector(modules); }
private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.cache.EhcachePoolImpl.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); return cfgInjector.createChildInjector(modules); }
private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); return cfgInjector.createChildInjector(modules); }
private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(com.google.gerrit.server.schema.SchemaVersionCheck.module()); modules.add(new com.google.gerrit.pgm.util.LogFileCompressor.Module()); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); if (httpd) { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); } else { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.server.config.CanonicalWebUrlProvider.class; } }); } if (!(slave)) { modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); } return cfgInjector.createChildInjector(modules); }
@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException, java.lang.IllegalStateException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.validateFor(changeId); java.util.List<com.google.gerrit.common.data.SubmitRecord> result = changeControl.canSubmit(db, patchSetId); if (result.isEmpty()) { throw new java.lang.IllegalStateException("Cannot submit"); } switch (result.get(0).status) { case OK : com.google.gerrit.server.ChangeUtil.submit(patchSetId, user, db, opFactory, merger); return changeDetailFactory.create(changeId).call(); case NOT_READY : { for (com.google.gerrit.common.data.SubmitRecord.Label lbl : result.get(0).labels) { switch (lbl.status) { case OK : break; case REJECT : throw new java.lang.IllegalStateException(("Blocked by " + (lbl.label))); case NEED : throw new java.lang.IllegalStateException(("Needs " + (lbl.label))); case IMPOSSIBLE : throw new java.lang.IllegalStateException("Cannnot submit, check project access"); default : throw new java.lang.IllegalArgumentException(("Unknown status " + (lbl.status))); } } throw new java.lang.IllegalStateException("Cannot submit"); } case CLOSED : throw new java.lang.IllegalStateException("Change is closed"); case RULE_ERROR : if ((result.get(0).errorMessage) != null) { throw new java.lang.IllegalStateException(result.get(0).errorMessage); } else { throw new java.lang.IllegalStateException("Internal rule error"); } default : throw new java.lang.IllegalStateException(("Uknown status " + (result.get(0).status))); } }


@java.lang.Override public void run() throws java.lang.Exception { if (!(currentUser.getCapabilities().canCreateProject())) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName()); throw new com.google.gerrit.sshd.commands.UnloggedFailure(com.google.gerrit.sshd.BaseCommand.STATUS_NOT_ADMIN, msg); } parseCommandLine(); try { final com.google.gerrit.server.project.CreateProjectArgs args = new com.google.gerrit.server.project.CreateProjectArgs(); args.setProjectName(projectName); args.setOwnerIds(ownerIds); args.setNewParent(newParent); args.setPermissionsOnly(permissionsOnly); args.setProjectDescription(projectDescription); args.setSubmitType(submitType); args.setContributorAgreements(contributorAgreements); args.setSignedOffBy(signedOffBy); args.setContentMerge(contentMerge); args.setChangeIdRequired(requireChangeID); args.setBranch(branch); args.setCreateEmptyCommit(createEmptyCommit); final com.google.gerrit.server.project.CreateProject createProject = CreateProjectFactory.create(args); createProject.createProject(); } catch (com.google.gerrit.common.errors.ProjectCreationFailedException err) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("fatal: " + (err.getMessage())), err); } }
private void markChangeMergedByPush(final com.google.gerrit.reviewdb.ReviewDb db, final com.google.gerrit.server.git.ReceiveCommits.ReplaceResult result) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.Change change = result.change; final java.lang.String mergedIntoRef = result.mergedIntoRef; change.setCurrentPatchSet(result.info); change.setStatus(Change.Status.MERGED); com.google.gerrit.server.ChangeUtil.updated(change); final java.util.List<com.google.gerrit.reviewdb.PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList(); for (com.google.gerrit.reviewdb.PatchSetApproval a : approvals) { a.cache(change); } db.patchSetApprovals().update(approvals); final java.lang.StringBuilder msgBuf = new java.lang.StringBuilder(); msgBuf.append("Change has been successfully pushed"); if (!(mergedIntoRef.equals(change.getDest().get()))) { msgBuf.append(" into "); if (mergedIntoRef.startsWith(Constants.R_HEADS)) { msgBuf.append("branch "); msgBuf.append(org.eclipse.jgit.lib.Repository.shortenRefName(mergedIntoRef)); } else { msgBuf.append(mergedIntoRef); } } msgBuf.append("."); final com.google.gerrit.reviewdb.ChangeMessage msg = new com.google.gerrit.reviewdb.ChangeMessage(new com.google.gerrit.reviewdb.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey()); msg.setMessage(msgBuf.toString()); db.changeMessages().insert(java.util.Collections.singleton(msg)); db.changes().atomicUpdate(change.getId(), new com.google.gwtorm.client.AtomicUpdate<com.google.gerrit.reviewdb.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.Change update(com.google.gerrit.reviewdb.Change change) { if (change.getStatus().isOpen()) { change.setCurrentPatchSet(result.info); change.setStatus(Change.Status.MERGED); com.google.gerrit.server.ChangeUtil.updated(change); } return change; } }); }
@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.client.OrmException, java.lang.IllegalStateException { final com.google.gerrit.reviewdb.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.validateFor(changeId); if ((!(changeControl.isOwner())) && (!(changeControl.isVisible(db)))) { throw new java.lang.IllegalStateException("Cannot publish patchset"); } com.google.gerrit.server.ChangeUtil.publishDraftPatchSet(db, patchSetId); return changeDetailFactory.create(changeId).call(); }
private void handleReviewResultErrors(final com.google.gerrit.common.data.ReviewResult result) { for (com.google.gerrit.common.data.ReviewResult.Error resultError : result.getErrors()) { java.lang.String errMsg = "error: "; switch (resultError.getType()) { case ABANDON_NOT_PERMITTED : errMsg += "not permitted to abandon change"; break; case RESTORE_NOT_PERMITTED : errMsg += "not permitted to restore change"; break; case SUBMIT_NOT_PERMITTED : errMsg += "not permitted to submit change"; break; case SUBMIT_NOT_READY : errMsg += "approvals or dependencies lacking"; break; case CHANGE_IS_CLOSED : errMsg += "change is closed"; break; case RULE_ERROR : errMsg += "rule error"; break; default : errMsg += "failure in review"; } if ((resultError.getMessage()) != null) { errMsg += ": " + (resultError.getMessage()); } writeError(errMsg); } }

private void handleReviewResultErrors(final com.google.gerrit.common.data.ReviewResult result) { for (com.google.gerrit.common.data.ReviewResult.Error resultError : result.getErrors()) { java.lang.String errMsg = "error: "; switch (resultError.getType()) { case ABANDON_NOT_PERMITTED : errMsg += "not permitted to abandon change"; break; case RESTORE_NOT_PERMITTED : errMsg += "not permitted to restore change"; break; case SUBMIT_NOT_PERMITTED : errMsg += "not permitted to submit change"; break; case SUBMIT_NOT_READY : errMsg += "approvals or dependencies lacking"; break; case CHANGE_IS_CLOSED : errMsg += "change is closed"; break; case CHANGE_NOT_VISIBLE : errMsg += "not permitted to review change"; break; case RULE_ERROR : errMsg += "rule error"; break; default : errMsg += "failure in review"; } if ((resultError.getMessage()) != null) { errMsg += ": " + (resultError.getMessage()); } writeError(errMsg); } }

public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.patch.Failure, com.google.gwtorm.client.OrmException { try { final com.google.gerrit.server.project.ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey()); if (!(cc.isOwner())) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } com.google.gerrit.server.ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db); } catch (NoSuchChangeException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new NoSuchChangeException(psid.getParentKey())); } catch (PatchSetInfoNotAvailableException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(e); } catch (IOException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(e); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
public void deleteDraftPatchSet(final com.google.gerrit.reviewdb.PatchSet.Id psid, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { run(callback, new com.google.gerrit.httpd.rpc.patch.Action<com.google.gwtjsonrpc.client.VoidResult>() { public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.patch.Failure, com.google.gwtorm.client.OrmException { try { final com.google.gerrit.server.project.ChangeControl cc = changeControlFactory.validateFor(psid.getParentKey()); if (!(cc.isOwner())) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } com.google.gerrit.server.ChangeUtil.deleteDraftPatchSet(psid, gitManager, replication, patchSetInfoFactory, db); } catch (NoSuchChangeException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new NoSuchChangeException(psid.getParentKey())); } catch (PatchSetInfoNotAvailableException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(e); } catch (IOException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(e); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } }); }
public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.patch.Failure, com.google.gwtorm.client.OrmException { com.google.gerrit.common.data.ReviewResult result = null; try { result = deleteDraftPatchSetFactory.create(psid).call(); } catch (NoSuchChangeException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new NoSuchChangeException(result.getChangeId())); } if ((result.getErrors().size()) > 0) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; }
public void deleteDraftPatchSet(final com.google.gerrit.reviewdb.PatchSet.Id psid, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwtjsonrpc.client.VoidResult> callback) { run(callback, new com.google.gerrit.httpd.rpc.patch.Action<com.google.gwtjsonrpc.client.VoidResult>() { public com.google.gwtjsonrpc.client.VoidResult run(com.google.gerrit.reviewdb.ReviewDb db) throws com.google.gerrit.httpd.rpc.patch.Failure, com.google.gwtorm.client.OrmException { com.google.gerrit.common.data.ReviewResult result = null; try { result = deleteDraftPatchSetFactory.create(psid).call(); } catch (NoSuchChangeException e) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new NoSuchChangeException(result.getChangeId())); } if ((result.getErrors().size()) > 0) { throw new com.google.gerrit.httpd.rpc.patch.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } return com.google.gwtjsonrpc.client.VoidResult.INSTANCE; } }); }
public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(PageLinks.MINE); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(PageLinks.MINE); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); super.onFailure(caught); } }); }
private void populateDeleteDraftPatchSetAction() { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button(Util.C.buttonDeleteDraftPatchSet()); b.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); PatchUtil.DETAIL_SVC.deleteDraftPatchSet(patchSet.getId(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.client.VoidResult>() { public void onSuccess(com.google.gwtjsonrpc.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(PageLinks.MINE); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); super.onFailure(caught); } }); } }); actionsPanel.add(b); }
private void addGrid(final com.google.gwt.user.client.ui.VerticalPanel fp) { final com.google.gwt.user.client.ui.Grid grid = new com.google.gwt.user.client.ui.Grid(2, 2); grid.setStyleName(Gerrit.RESOURCES.css().infoBlock()); grid.setText(0, 0, ((Util.C.columnProjectName()) + ":")); grid.setWidget(0, 1, project); grid.setText(1, 0, ((Util.C.headingParentProjectName()) + ":")); grid.setWidget(1, 1, sugestParent); fp.add(grid); }

@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(ChangeProjectAccess.Factory.class); factory(CreateProjectHandler.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectAccessFactory.Factory.class); factory(ProjectDetailFactory.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.project.ProjectAdminServiceImpl.class); }
private void addCreateProjectPanel() { final com.google.gwt.user.client.ui.VerticalPanel fp = new com.google.gwt.user.client.ui.VerticalPanel(); fp.setStyleName(Gerrit.RESOURCES.css().createProjectPanel()); initCreateTxt(); initCreateButton(); initParentBox(); addGrid(fp); emptyCommit = new com.google.gwt.user.client.ui.CheckBox(Util.C.checkBoxEmptyCommit()); permissionsOnly = new com.google.gwt.user.client.ui.CheckBox(Util.C.checkBoxPermissionsOnly()); fp.add(emptyCommit); fp.add(permissionsOnly); fp.add(create); add(fp); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); setPageTitle(Util.C.createProjectTitle()); addCreateProjectPanel(); }
protected void closePopup() { popup.hide(); if ((regWindowResize) != null) { regWindowResize.removeHandler(); regWindowResize = null; } }
protected void displayPopup() { popingUp = true; if (firstPopupLoad) { populateProjects(); } else { popup.setPopupPositionAndShow(popupPosition); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(popup); com.google.gwtexpui.globalkey.client.GlobalKey.addApplication(popup, new com.google.gwtexpui.globalkey.client.HidePopupPanelCommand(0, com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE, popup)); projectsTab.setRegisterKeys(true); projectsTab.finishDisplay(); if ((regWindowResize) == null) { regWindowResize = com.google.gwt.user.client.Window.addResizeHandler(this); } popingUp = false; } }
@java.lang.Override public void onResize(final com.google.gwt.event.logical.shared.ResizeEvent event) { sp.setSize("100%", "100%"); popup.setHeight("100%"); popupPosition.setPosition(preferredPopupWidth, popup.getOffsetHeight()); }
@java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(ChangeProjectAccess.Factory.class); factory(CreateProjectHandler.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectAccessFactory.Factory.class); factory(ProjectDetailFactory.Factory.class); }



private void update(com.google.gerrit.reviewdb.AccountDiffPreference dp) { if (((lastScript) != null) && (canReuse(dp, lastScript))) { lastScript.setDiffPrefs(dp); RpcStatus.INSTANCE.onRpcStart(null); settingsPanel.setEnabled(false); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { try { onResult(lastScript, false); } finally { RpcStatus.INSTANCE.onRpcComplete(null); } } }); } else { refresh(false); } }
private void populateDiffAllActions(final com.google.gerrit.common.data.PatchSetDetail detail) { final com.google.gwt.user.client.ui.Button diffAllSideBySide = new com.google.gwt.user.client.ui.Button(Util.C.buttonDiffAllSideBySide()); diffAllSideBySide.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { for (com.google.gerrit.reviewdb.Patch p : detail.getPatches()) { com.google.gwt.user.client.Window.open((((Window.Location.getPath()) + "#") + (com.google.gerrit.client.Dispatcher.toPatchSideBySide(p.getKey()))), "_blank", null); } } }); actionsPanel.add(diffAllSideBySide); final com.google.gwt.user.client.ui.Button diffAllUnified = new com.google.gwt.user.client.ui.Button(Util.C.buttonDiffAllUnified()); diffAllUnified.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { for (com.google.gerrit.reviewdb.Patch p : detail.getPatches()) { com.google.gwt.user.client.Window.open((((Window.Location.getPath()) + "#") + (com.google.gerrit.client.Dispatcher.toPatchUnified(p.getKey()))), "_blank", null); } } }); actionsPanel.add(diffAllUnified); }
@java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { if (patchSet.getId().equals(diffBaseId)) { patchTable.setVisible(false); actionsPanel.setVisible(false); } else { if ((patchTable) != null) { patchTable.removeFromParent(); } patchTable = new com.google.gerrit.client.changes.PatchTable(); patchTable.setPatchSetIdToCompareWith(diffBaseId); patchTable.display(result); body.add(patchTable); for (com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler) { patchTable.addClickHandler(clickHandler); } } }
public static void patch(java.lang.String token, final com.google.gerrit.reviewdb.Patch.Key id, final int patchIndex, final com.google.gerrit.common.data.PatchSetDetail patchSetDetail, final com.google.gerrit.client.changes.PatchTable patchTable, final com.google.gerrit.client.patches.PatchScreen.TopView topView, final java.lang.String panelType) { final com.google.gerrit.client.patches.PatchScreen.TopView top = (topView == null) ? com.google.gerrit.client.Gerrit.getPatchScreenTopView() : topView; com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, select()); } private com.google.gerrit.client.ui.Screen select() { if (id != null) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = (0 <= c) ? token.substring((c + 1)) : ""; } if ("".equals(panel)) { return new com.google.gerrit.client.patches.PatchScreen.SideBySide(id, patchIndex, patchSetDetail, patchTable, top); } else if ("unified".equals(panel)) { return new com.google.gerrit.client.patches.PatchScreen.Unified(id, patchIndex, patchSetDetail, patchTable, top); } } return new com.google.gerrit.client.NotFoundScreen(); } }); }
private com.google.gerrit.client.ui.Screen select() { if (id != null) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = (0 <= c) ? token.substring((c + 1)) : ""; } if ("".equals(panel)) { return new com.google.gerrit.client.patches.PatchScreen.SideBySide(id, patchIndex, patchSetDetail, patchTable, top); } else if ("unified".equals(panel)) { return new com.google.gerrit.client.patches.PatchScreen.Unified(id, patchIndex, patchSetDetail, patchTable, top); } } return new com.google.gerrit.client.NotFoundScreen(); }
private static java.lang.String skip(java.lang.String token) { return token.substring(com.google.gerrit.client.Dispatcher.prefixlen); }
public void refresh() { com.google.gerrit.reviewdb.AccountDiffPreference diffPrefs; if ((patchTable) == null) { diffPrefs = new com.google.gerrit.client.ui.ListenableAccountDiffPreference().get(); } else { diffPrefs = patchTable.getPreferences().get(); } Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.PatchSetDetail>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { if (patchSet.getId().equals(diffBaseId)) { patchTable.setVisible(false); actionsPanel.setVisible(false); } else { if ((patchTable) != null) { patchTable.removeFromParent(); } patchTable = new com.google.gerrit.client.changes.PatchTable(); patchTable.setPatchSetIdToCompareWith(diffBaseId); patchTable.display(result); body.add(patchTable); for (com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler) { patchTable.addClickHandler(clickHandler); } } } }); }

@java.lang.Override protected void configure() { bind(org.eclipse.jgit.lib.Config.class).annotatedWith(com.google.gerrit.server.config.GerritServerConfig.class).toInstance(new org.eclipse.jgit.lib.Config()); bind(CapabilityControl.Factory.class).toProvider(com.google.inject.assistedinject.FactoryProvider.newFactory(CapabilityControl.Factory.class, com.google.gerrit.server.account.CapabilityControl.class)); bind(com.google.gerrit.server.project.ProjectCache.class).toInstance(projectCache); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.git.PushReplication.ReplicationConfig.class).toInstance(this); bind(org.eclipse.jgit.transport.RemoteConfig.class).toInstance(remote); bind(PushOp.Factory.class).toProvider(com.google.inject.assistedinject.FactoryProvider.newFactory(PushOp.Factory.class, com.google.gerrit.server.git.PushOp.class)); }
public void testListTables() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { assertTrue(dialect.listTables(db).isEmpty()); execute("CREATE SEQUENCE cnt"); execute("CREATE TABLE foo (cnt INT)"); java.util.Set<java.lang.String> s = dialect.listTables(db); assertEquals(1, s.size()); assertFalse(s.contains("cnt")); assertTrue(s.contains("foo")); }
@java.lang.Override public void tearDown() throws java.lang.Exception { if ((openSchemas) != null) { for (com.google.gwtorm.data.PhoneBookDb schema : openSchemas) { schema.close(); } openSchemas = null; } super.tearDown(); }
public void testInsertManyPeopleByTransaction() throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = openAndCreate(); final com.google.gwtorm.client.Transaction txn = schema.beginTransaction(); final java.util.ArrayList<com.google.gwtorm.data.TestPerson> all = new java.util.ArrayList<com.google.gwtorm.data.TestPerson>(); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Bob"), 18)); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Mary"), 22)); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Zak"), 33)); schema.people().insert(all, txn); final java.sql.Statement st = statement(schema); java.sql.ResultSet rs; rs = st.executeQuery("SELECT name,age FROM people ORDER BY name"); assertFalse(rs.next()); rs.close(); txn.commit(); rs = st.executeQuery("SELECT name,age FROM people ORDER BY name"); for (int rowIdx = 0; rowIdx < (all.size()); rowIdx++) { assertTrue(rs.next()); assertEquals(all.get(rowIdx).name(), rs.getString(1)); assertEquals(all.get(rowIdx).age(), rs.getInt(2)); } assertFalse(rs.next()); rs.close(); st.close(); }
public void testGetPeopleAccess() throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = open(); assertNotNull(schema.people()); }
@com.google.gwtorm.client.Query("ORDER BY age LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> youngestN(int n) throws com.google.gwtorm.client.OrmException;
public void testUpdateNoPerson() throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = openAndCreate(); final com.google.gwtorm.data.TestPerson bob = new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Bob"), 18); try { schema.people().update(java.util.Collections.singleton(bob)); fail("Update of missing person succeeded"); } catch (com.google.gwtorm.client.OrmConcurrencyException e) { assertEquals("Concurrent modification detected", e.getMessage()); } }
@com.google.gwtorm.client.Query("WHERE age > ? ORDER BY age") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> olderThan(int age) throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> all() throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query("WHERE name = 'bob' LIMIT ?") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> firstNBob(int n) throws com.google.gwtorm.client.OrmException;
public void testFetchNotPerson() throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = openAndCreate(); final java.util.ArrayList<com.google.gwtorm.data.TestPerson> all = new java.util.ArrayList<com.google.gwtorm.data.TestPerson>(); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Bob"), 18)); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Mary"), 22)); all.add(new com.google.gwtorm.data.TestPerson(new com.google.gwtorm.data.TestPerson.Key("Zak"), 33)); schema.people().insert(all); final java.util.List<com.google.gwtorm.data.TestPerson> r = schema.people().notPerson(new com.google.gwtorm.data.TestPerson.Key("Mary"), 10).toList(); assertEquals(2, r.size()); assertEquals(all.get(2).name(), r.get(0).name()); assertEquals(all.get(0).name(), r.get(1).name()); }
@com.google.gwtorm.client.Query("WHERE name != ? AND age > ? ORDER BY name DESC") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> notPerson(com.google.gwtorm.data.TestPerson.Key key, int age) throws com.google.gwtorm.client.OrmException;
@java.lang.SuppressWarnings("cast") public void testPerson() throws java.io.UnsupportedEncodingException { final com.google.gwtorm.protobuf.ProtobufCodec<com.google.gwtorm.data.TestPerson> e = com.google.gwtorm.protobuf.CodecFactory.encoder(com.google.gwtorm.data.TestPerson.class); final byte[] bin = new byte[]{ 10, 9, 10, 7, 116, 101, 115, 116, 105, 110, 103, 16, ((byte) (150)), 1, 24, 1 }; com.google.gwtorm.data.TestPerson p = e.decode(bin); assertNotNull(p); assertTrue((p instanceof com.google.gwtorm.data.TestPerson)); assertEquals("testing", p.name()); assertEquals(75, p.age()); assertTrue(p.isRegistered()); final byte[] out = e.encode(p).toByteArray(); assertEquals(new java.lang.String(bin, "ISO-8859-1"), new java.lang.String(out, "ISO-8859-1")); assertEquals(bin.length, e.sizeof(p)); }
public void testAddress() { final com.google.gwtorm.protobuf.ProtobufCodec<com.google.gwtorm.data.TestAddress> e = com.google.gwtorm.protobuf.CodecFactory.encoder(com.google.gwtorm.data.TestAddress.class); com.google.gwtorm.data.TestAddress a = e.decode(new byte[0]); assertNotNull(a); assertNull(a.location()); com.google.gwtorm.data.TestPerson.Key k = new com.google.gwtorm.data.TestPerson.Key("bob"); com.google.gwtorm.data.TestPerson p = new com.google.gwtorm.data.TestPerson(k, 42); com.google.gwtorm.data.TestAddress b = new com.google.gwtorm.data.TestAddress(new com.google.gwtorm.data.TestAddress.Key(k, "ny"), "ny"); byte[] act = e.encode(b).toByteArray(); com.google.gwtorm.data.TestAddress c = e.decode(act); assertEquals(c.location(), b.location()); assertEquals(c.city(), b.city()); assertEquals(c.key(), b.key()); }
public void testListSequences() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { assertTrue(dialect.listSequences(db).isEmpty()); execute("CREATE SEQUENCE cnt"); execute("CREATE TABLE foo (cnt INT)"); java.util.Set<java.lang.String> s = dialect.listSequences(db); assertEquals(1, s.size()); assertTrue(s.contains("cnt")); assertFalse(s.contains("foo")); }
@com.google.gwtorm.client.Query("WHERE registered = false ORDER BY name") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> notRegistered() throws com.google.gwtorm.client.OrmException;
@com.google.gwtorm.client.Query("ORDER BY age LIMIT 1") com.google.gwtorm.client.ResultSet<com.google.gwtorm.data.TestPerson> youngest() throws com.google.gwtorm.client.OrmException;
public void testGetAddressAccess() throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = open(); assertNotNull(schema.addresses()); }
@com.google.gwtorm.client.PrimaryKey("name") com.google.gwtorm.data.TestPerson get(com.google.gwtorm.data.TestPerson.Key key) throws com.google.gwtorm.client.OrmException;
@java.lang.Override protected void tearDown() { if ((executor) != null) { executor.close(); } executor = null; if ((db) != null) { try { db.close(); } catch (java.sql.SQLException e) { throw new java.lang.RuntimeException("Cannot close database", e); } } db = null; }
@java.lang.Override protected void setUp() throws java.lang.Exception { super.setUp(); org.h2.Driver.load(); db = java.sql.DriverManager.getConnection("jdbc:h2:mem:DialectH2Test"); executor = new com.google.gwtorm.jdbc.JdbcExecutor(db); dialect = new com.google.gwtorm.schema.sql.DialectH2().refine(db); final java.util.Properties p = new java.util.Properties(); p.setProperty("driver", org.h2.Driver.class.getName()); p.setProperty("url", db.getMetaData().getURL()); phoneBook = new com.google.gwtorm.jdbc.Database<com.google.gwtorm.data.PhoneBookDb>(new com.google.gwtorm.jdbc.SimpleDataSource(p), com.google.gwtorm.data.PhoneBookDb.class); phoneBook2 = new com.google.gwtorm.jdbc.Database<com.google.gwtorm.data.PhoneBookDb2>(new com.google.gwtorm.jdbc.SimpleDataSource(p), com.google.gwtorm.data.PhoneBookDb2.class); }
public void testUpgradeSchema() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { final com.google.gwtorm.data.PhoneBookDb p = phoneBook.open(); try { p.updateSchema(executor); execute("CREATE SEQUENCE cnt"); execute("CREATE TABLE foo (cnt INT)"); execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)"); execute("ALTER TABLE people DROP COLUMN registered"); execute("DROP TABLE addresses"); execute("DROP SEQUENCE address_id"); java.util.Set<java.lang.String> sequences; java.util.Set<java.lang.String> tables; p.updateSchema(executor); sequences = dialect.listSequences(db); tables = dialect.listTables(db); assertTrue(sequences.contains("cnt")); assertTrue(tables.contains("foo")); assertTrue(sequences.contains("address_id")); assertTrue(tables.contains("addresses")); p.pruneSchema(executor); sequences = dialect.listSequences(db); tables = dialect.listTables(db); assertFalse(sequences.contains("cnt")); assertFalse(tables.contains("foo")); final com.google.gwtorm.data.TestPerson.Key pk = new com.google.gwtorm.data.TestPerson.Key("Bob"); final com.google.gwtorm.data.TestPerson bob = new com.google.gwtorm.data.TestPerson(pk, p.nextAddressId()); p.people().insert(java.util.Collections.singleton(bob)); final com.google.gwtorm.data.TestAddress addr = new com.google.gwtorm.data.TestAddress(new com.google.gwtorm.data.TestAddress.Key(pk, "home"), "some place"); p.addresses().insert(java.util.Collections.singleton(addr)); } finally { p.close(); } final com.google.gwtorm.data.PhoneBookDb2 p2 = phoneBook2.open(); try { ((com.google.gwtorm.jdbc.JdbcSchema) (p2)).renameField(executor, "people", "registered", "isRegistered"); } finally { p2.close(); } }

@org.junit.Test public void testUpsertNothing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.NO_DATA); }
@org.junit.Test public void testUpdateOne() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 1); createClassUnderTest().update(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); }
@org.junit.Test public void testInsertNothing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { setup(); createClassUnderTest().insert(com.google.gwtorm.jdbc.TestJdbcAccess.NO_DATA); }
@org.junit.Test public void testUpsertTwoSecondExistsing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 0, 1); java.sql.PreparedStatement insert = stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS); verifyIds(insert, 1); }
@org.junit.Test public void testUpsertOneNotExisting() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE); java.sql.PreparedStatement insert = stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); verifyIds(insert, 1); }
@java.lang.Override protected void doUpsert(final java.lang.Iterable<T> instances, final com.google.gwtorm.jdbc.JdbcTransaction txn) throws com.google.gwtorm.client.OrmException { java.util.Collection<T> inserts = null; try { java.sql.PreparedStatement ps = null; try { int cnt = 0; for (final T o : instances) { if (ps == null) { ps = schema.getConnection().prepareStatement(getUpdateOneSql()); } bindOneUpdate(ps, o); ps.addBatch(); cnt++; } if (0 < cnt) { final int[] states = ps.executeBatch(); if (states == null) { inserts = new java.util.ArrayList<T>(cnt); for (T o : instances) { inserts.add(o); } } else { int i = 0; for (T o : instances) { if (((states.length) <= i) || ((states[i]) != 1)) { if (inserts == null) { inserts = new java.util.ArrayList<T>((cnt - i)); } inserts.add(o); } i++; } } } } finally { if (ps != null) { ps.close(); } } } catch (java.sql.SQLException e) { throw convertError("update", e); } if (inserts != null) { doInsert(inserts, txn); } }
@org.junit.Test public void testDeleteOneNotExisting() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.DELETE, 0); try { createClassUnderTest().delete(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); fail("missing OrmConcurrencyException"); } catch (com.google.gwtorm.client.OrmConcurrencyException e) { } }
@org.junit.Test public void testUpdateOneModified() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 0); com.google.gwtorm.jdbc.JdbcAccess<com.google.gwtorm.jdbc.TestJdbcAccess.Data, com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey> classUnderTest = createClassUnderTest(); try { classUnderTest.update(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); fail("missing OrmConcurrencyException"); } catch (com.google.gwtorm.client.OrmConcurrencyException e) { } }
@org.junit.Test public void testUpsertOneExisting() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); }
@org.junit.Test public void testUpdateNothing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { createClassUnderTest().update(com.google.gwtorm.jdbc.TestJdbcAccess.NO_DATA); }

@org.junit.Test public void testInsertOneException() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchException(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, new java.sql.BatchUpdateException()); try { createClassUnderTest().insert(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); fail("missingException"); } catch (com.google.gwtorm.client.OrmException e) { } }
@org.junit.Test public void testDeleteOneExisting() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.DELETE, 1); createClassUnderTest().delete(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); }
@org.junit.Test public void testUpsertTwoBothExistsing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 1, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS); }
@org.junit.Test public void testUpsertOneException() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchException(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, new java.sql.BatchUpdateException()); try { createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); fail("missingException"); } catch (com.google.gwtorm.client.OrmException e) { } }
@org.junit.Test public void testUpsertTwoNotExistsing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE); java.sql.PreparedStatement insert = stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, 1, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS); verifyIds(insert, 1, 2); }
@org.junit.Test public void testInsertOne() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, 1); createClassUnderTest().insert(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); }
@org.junit.Test public void testUpsertTwoFirstExistsing() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, 1, 0); java.sql.PreparedStatement insert = stubExecuteBatchOK(com.google.gwtorm.jdbc.TestJdbcAccess.INSERT, 1); createClassUnderTest().upsert(com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS); verifyIds(insert, 2); }
@org.junit.Test public void testUpdateOneException() throws com.google.gwtorm.client.OrmException, java.sql.SQLException { stubExecuteBatchException(com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE, new java.sql.BatchUpdateException()); try { createClassUnderTest().update(com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW); fail("missingException"); } catch (com.google.gwtorm.client.OrmException e) { } }

private void execute(final java.sql.PreparedStatement ps, final int cnt) throws com.google.gwtorm.client.OrmConcurrencyException, java.sql.SQLException { if (cnt > 0) { final int[] updateCounts = ps.executeBatch(); if (updateCounts == null) { throw new java.sql.SQLException("No rows affected"); } int totalUpdateCount = 0; for (int i = 0; i < (updateCounts.length); i++) { int updateCount = updateCounts[i]; if (updateCount > 0) { totalUpdateCount += updateCount; } } if (totalUpdateCount != cnt) { throw new com.google.gwtorm.client.OrmConcurrencyException(); } } }




@java.lang.Override protected void doUpsert(final java.lang.Iterable<T> instances, final com.google.gwtorm.jdbc.JdbcTransaction txn) throws com.google.gwtorm.client.OrmException { if (!(instances.iterator().hasNext())) { return; } final java.lang.Iterable<T> inserts; try { java.sql.PreparedStatement ps = schema.getConnection().prepareStatement(getUpdateOneSql()); try { inserts = attemptUpdatesAsBatch(ps, instances); } finally { ps.close(); } } catch (java.sql.SQLException e) { throw convertError("update", e); } doInsert(inserts, txn); }
@java.lang.Override protected void doUpdate(final java.lang.Iterable<T> instances, final com.google.gwtorm.jdbc.JdbcTransaction txn) throws com.google.gwtorm.client.OrmException { if (!(instances.iterator().hasNext())) { return; } try { java.sql.PreparedStatement ps = schema.getConnection().prepareStatement(getUpdateOneSql()); try { int cnt = 0; for (final T o : instances) { bindOneUpdate(ps, o); ps.addBatch(); cnt++; } execute(ps, cnt); } finally { ps.close(); } } catch (java.sql.SQLException e) { throw convertError("update", e); } }
@java.lang.Override protected void doDelete(final java.lang.Iterable<T> instances, final com.google.gwtorm.jdbc.JdbcTransaction txn) throws com.google.gwtorm.client.OrmException { if (!(instances.iterator().hasNext())) { return; } try { java.sql.PreparedStatement ps = schema.getConnection().prepareStatement(getDeleteOneSql()); try { int cnt = 0; for (final T o : instances) { bindOneDelete(ps, o); ps.addBatch(); cnt++; } execute(ps, cnt); } finally { ps.close(); } } catch (java.sql.SQLException e) { throw convertError("delete", e); } }

private void execute(final java.sql.PreparedStatement ps, final int cnt) throws com.google.gwtorm.client.OrmConcurrencyException, java.sql.SQLException { if (cnt == 0) { return; } final int[] states = ps.executeBatch(); if (states == null) { throw new java.sql.SQLException((("No rows affected; expected " + cnt) + " rows")); } for (int i = 0; i < cnt; i++) { if (((states.length) <= i) || ((states[i]) != 1)) { throw new com.google.gwtorm.client.OrmConcurrencyException(); } } }
@java.lang.Override protected void doInsert(final java.lang.Iterable<T> instances, final com.google.gwtorm.jdbc.JdbcTransaction txn) throws com.google.gwtorm.client.OrmException { try { if (schema.getDialect().canDetermineIndividualBatchUpdateCounts()) { insertAsBatch(instances); } else { insertIndividually(instances); } } catch (java.sql.SQLException e) { throw convertError("insert", e); } }
private void email() { try { if ((message) != null) { final com.google.gerrit.server.mail.CommentSender cm = commentSenderFactory.create(change); cm.setFrom(user.getAccountId()); cm.setPatchSet(patchSet, patchSetInfoFactory.get(db, patchSetId)); cm.setChangeMessage(message); cm.setPatchLineComments(drafts); cm.send(); } } catch (com.google.gerrit.server.mail.EmailException e) { com.google.gerrit.server.patch.PublishComments.log.error(("Cannot send comments by email for patch set " + (patchSetId)), e); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e) { com.google.gerrit.server.patch.PublishComments.log.error(("Failed to obtain PatchSetInfo for patch set " + (patchSetId)), e); } }






@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.ReceiveSession rs) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { base.advertiseRefs(rs); java.util.HashMap<java.lang.String, org.eclipse.jgit.lib.Ref> r = new java.util.HashMap<java.lang.String, org.eclipse.jgit.lib.Ref>(); for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : rs.getAdvertisedRefs().entrySet()) { if (!(e.getKey().startsWith("refs/changes/"))) { r.put(e.getKey(), e.getValue()); } } rs.setAdvertisedRefs(r, rs.getAdvertisedObjects()); }
private void parseRewind(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevCommit newObject; try { newObject = rs.getRevWalk().parseCommit(cmd.getNewId()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException notCommit) { newObject = null; } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " forced update"), err); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid object"); return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (newObject != null) { validateNewCommits(ctl, cmd); if ((cmd.getResult()) != (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { return; } } if (ctl.canForceUpdate()) { } else { cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, ((" need '" + (com.google.gerrit.common.data.PermissionRule.FORCE_PUSH)) + "' privilege.")); } }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "can not delete references"); } }
private void parseCreate(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rs.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid object"); return; } if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canCreate(rs.getRevWalk(), obj)) { validateNewCommits(ctl, cmd); } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "can not create new references"); } }
private void parseUpdate(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canUpdate()) { if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } validateNewCommits(ctl, cmd); } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "can not update the reference as a fast forward"); } }
@java.lang.Override public org.eclipse.jgit.transport.ReceivePack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository db) throws org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException { final com.google.gerrit.server.project.ProjectControl pc = ((com.google.gerrit.server.project.ProjectControl) (req.getAttribute(com.google.gerrit.httpd.GitOverHttpServlet.ATT_CONTROL))); if (!((pc.getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser)) { throw new org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException(); } final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (pc.getCurrentUser())); final com.google.gerrit.server.git.ReceiveCommits rc = factory.create(pc, db); rc.getReceivePack().setRefLogIdent(user.newRefLogIdent()); req.setAttribute(com.google.gerrit.httpd.GitOverHttpServlet.ATT_RC, rc); session.get().setAccessPath(AccessPath.GIT); return rc.getReceivePack(); }
@java.lang.Override public void onPreReceive(final org.eclipse.jgit.transport.ReceivePack arg0, final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { parseCommands(commands); if (((newChange) != null) && ((newChange.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED))) { createNewChanges(); } doReplaces(); }
private void sendInvalidEmailError(org.eclipse.jgit.revwalk.RevCommit c, java.lang.String type, org.eclipse.jgit.lib.PersonIdent who) { java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("\n"); sb.append((("ERROR: In commit " + (c.name())) + "\n")); sb.append((((("ERROR: " + type) + " email address ") + (who.getEmailAddress())) + "\n")); sb.append("ERROR: does not match your user account.\n"); sb.append("ERROR:\n"); if (currentUser.getEmailAddresses().isEmpty()) { sb.append("ERROR: You have not registered any email addresses.\n"); } else { sb.append("ERROR: The following addresses are currently registered:\n"); for (java.lang.String address : currentUser.getEmailAddresses()) { sb.append((("ERROR: " + address) + "\n")); } } sb.append("ERROR:\n"); if ((canonicalWebUrl) != null) { sb.append("ERROR: To register an email address, please visit:\n"); sb.append((((("ERROR: " + (canonicalWebUrl)) + "#") + (com.google.gerrit.common.PageLinks.SETTINGS_CONTACT)) + "\n")); } sb.append("\n"); getReceivePack().sendMessage(sb.toString()); }
public org.eclipse.jgit.transport.ReceivePack getReceivePack() { return rp; }

private static void reject(final org.eclipse.jgit.transport.ReceiveCommand cmd, final java.lang.String why) { cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why); }

private boolean requestReplace(final org.eclipse.jgit.transport.ReceiveCommand cmd, final boolean checkMergedInto, final com.google.gerrit.reviewdb.Change change, final org.eclipse.jgit.revwalk.RevCommit newCommit) { if (change.getStatus().isClosed()) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, (("change " + (change.getId())) + " closed")); return false; } final com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest req = new com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); if (replaceByChange.containsKey(req.ontoChange)) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "duplicate request"); return false; } if (replaceByCommit.containsKey(req.newCommit)) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "duplicate request"); return false; } replaceByChange.put(req.ontoChange, req); replaceByCommit.put(req.newCommit, req); return true; }
private void doReplaces() { for (final com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest request : replaceByChange.values()) { try { doReplace(request); } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error(((("Error computing replacement patch for change " + (request.ontoChange)) + ", commit ") + (request.newCommit.name())), err); com.google.gerrit.server.git.ReceiveCommits.reject(request.cmd, "diff error"); } catch (com.google.gwtorm.client.OrmException err) { com.google.gerrit.server.git.ReceiveCommits.log.error(((("Error storing replacement patch for change " + (request.ontoChange)) + ", commit ") + (request.newCommit.name())), err); com.google.gerrit.server.git.ReceiveCommits.reject(request.cmd, "database error"); } if ((request.cmd.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { com.google.gerrit.server.git.ReceiveCommits.log.error(((((("Replacement patch for change " + (request.ontoChange)) + ", commit ") + (request.newCommit.name())) + " wasn't attempted.") + " This is a bug in the receive process implementation.")); com.google.gerrit.server.git.ReceiveCommits.reject(request.cmd, "internal error"); } } }

private void parseReplaceCommand(final org.eclipse.jgit.transport.ReceiveCommand cmd, final com.google.gerrit.reviewdb.Change.Id changeId) { if ((cmd.getType()) != (ReceiveCommand.Type.CREATE)) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid usage"); return; } final org.eclipse.jgit.revwalk.RevCommit newCommit; try { newCommit = rp.getRevWalk().parseCommit(cmd.getNewId()); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.error((("Cannot parse " + (cmd.getNewId().name())) + " as commit"), e); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "invalid commit"); return; } final com.google.gerrit.reviewdb.Change changeEnt; try { changeEnt = db.changes().get(changeId); } catch (com.google.gwtorm.client.OrmException e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot lookup existing change " + changeId), e); com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "database error"); return; } if (changeEnt == null) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, (("change " + changeId) + " not found")); return; } if (!(project.getNameKey().equals(changeEnt.getProject()))) { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, ((("change " + changeId) + " does not belong to project ") + (project.getName()))); return; } requestReplace(cmd, true, changeEnt, newCommit); }





@java.lang.Override public void onPreReceive(final org.eclipse.jgit.transport.ReceivePack arg0, final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { java.util.concurrent.Future<?> workerFuture = executor.submit(new java.lang.Runnable() { @java.lang.Override public void run() { processCommands(commands); } }, scopePropagator); java.lang.Exception err = null; try { workerFuture.get(); } catch (java.util.concurrent.ExecutionException e) { err = e; } catch (java.lang.InterruptedException e) { err = e; } if (err != null) { com.google.gerrit.server.git.ReceiveCommits.log.warn("Error in ReceiveCommits", err); messageSender.sendError("internal error while processing changes"); for (final org.eclipse.jgit.transport.ReceiveCommand c : commands) { if ((c.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED)) { com.google.gerrit.server.git.ReceiveCommits.reject(c, "internal error"); } } } }
@java.lang.Override public void onPreReceive(final org.eclipse.jgit.transport.ReceivePack arg0, final java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { parseCommands(commands); if (((newChange) != null) && ((newChange.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED))) { createNewChanges(); } doReplaces(); for (final org.eclipse.jgit.transport.ReceiveCommand c : commands) { if ((c.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.OK)) { switch (c.getType()) { case CREATE : if (com.google.gerrit.server.git.ReceiveCommits.isHead(c)) { autoCloseChanges(c); } break; case UPDATE : tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId()); if (com.google.gerrit.server.git.ReceiveCommits.isHead(c)) { autoCloseChanges(c); } break; case UPDATE_NONFASTFORWARD : if (com.google.gerrit.server.git.ReceiveCommits.isHead(c)) { autoCloseChanges(c); } break; } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(c)) { projectCache.evict(project); com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); repoManager.setProjectDescription(project.getNameKey(), ps.getProject().getDescription()); } if (!(com.google.gerrit.server.util.MagicBranch.isMagicBranch(c.getRefName()))) { replication.scheduleUpdate(project.getNameKey(), c.getRefName()); com.google.gerrit.reviewdb.Branch.NameKey destBranch = new com.google.gerrit.reviewdb.Branch.NameKey(project.getNameKey(), c.getRefName()); hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount()); } } } if ((!(allNewChanges.isEmpty())) && ((canonicalWebUrl) != null)) { final java.lang.String url = canonicalWebUrl; messageSender.sendMessage(""); messageSender.sendMessage("New Changes:"); for (final com.google.gerrit.reviewdb.Change c : allNewChanges) { if ((c.getStatus()) == (Change.Status.DRAFT)) { messageSender.sendMessage((((" " + url) + (c.getChangeId())) + " [DRAFT]")); } else { messageSender.sendMessage(((" " + url) + (c.getChangeId()))); } } messageSender.sendMessage(""); } }
public void begin(java.util.concurrent.Future<?> workerFuture) throws java.util.concurrent.ExecutionException { synchronized(this) { long left = maxIntervalNanos; while (!(done)) { long start = java.lang.System.nanoTime(); try { java.util.concurrent.TimeUnit.NANOSECONDS.timedWait(this, left); } catch (java.lang.InterruptedException e) { throw new java.util.concurrent.ExecutionException(e); } left -= (java.lang.System.nanoTime()) - start; if (left <= 0) { moveSpinner(); left = maxIntervalNanos; } sendUpdate(); if ((!(done)) && (workerFuture.isDone())) { com.google.gerrit.server.git.MultiProgressMonitor.log.warn(("MultiProgressMonitor worker did not call end()" + " before returning")); end(); } } } try { workerFuture.get(maxIntervalNanos, java.util.concurrent.TimeUnit.NANOSECONDS); } catch (java.lang.InterruptedException e) { throw new java.util.concurrent.ExecutionException(e); } catch (java.util.concurrent.CancellationException e) { throw new java.util.concurrent.ExecutionException(e); } catch (java.util.concurrent.TimeoutException e) { workerFuture.cancel(true); throw new java.util.concurrent.ExecutionException(e); } sendDone(); }







public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.changes.CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage(), Util.C.buttonRestoreChangeSend(), Util.C.buttonRestoreChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) { public void onSend() { Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback()); } }.center(); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.changes.CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, false), Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage(), Util.C.buttonAbandonChangeSend(), Util.C.buttonAbandonChangeCancel(), Gerrit.RESOURCES.css().abandonChangeDialog(), Gerrit.RESOURCES.css().abandonMessage()) { public void onSend() { Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback()); } }.center(); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.changes.CommentedChangeActionDialog(patchSet.getId(), createCommentedCallback(b, true), Util.C.revertChangeTitle(), Util.C.headingRevertMessage(), Util.C.buttonRevertChangeSend(), Util.C.buttonRevertChangeCancel(), Gerrit.RESOURCES.css().revertChangeDialog(), Gerrit.RESOURCES.css().revertMessage(), Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get())) { public void onSend() { Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback()); } }.center(); }
public void onSend() { Util.MANAGE_SVC.revertChange(getPatchSetId(), getMessageText(), createCallback()); }
public void onSend() { Util.MANAGE_SVC.abandonChange(getPatchSetId(), getMessageText(), createCallback()); }

public void onSend() { Util.MANAGE_SVC.restoreChange(getPatchSetId(), getMessageText(), createCallback()); }

private com.google.gerrit.server.project.ProjectState newProjectState() { com.google.gerrit.rules.PrologEnvironment.Factory envFactory = null; com.google.gerrit.server.git.GitRepositoryManager mgr = null; com.google.gerrit.server.project.ProjectControl.AssistedFactory projectControlFactory = null; com.google.gerrit.rules.RulesCache rulesCache = null; all.put(local.getProject().getNameKey(), new com.google.gerrit.server.project.ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, local)); all.put(parent.getProject().getNameKey(), new com.google.gerrit.server.project.ProjectState(projectCache, allProjectsName, projectControlFactory, envFactory, mgr, rulesCache, parent)); return all.get(local.getProject().getNameKey()); }
public com.google.gerrit.server.project.ProjectState getParentState() { if (isAllProjects) { return null; } com.google.gerrit.reviewdb.Project.NameKey parentName = getProject().getParent(); if (parentName == null) { parentName = allProjectsName; } return projectCache.get(parentName); }
private java.util.Set<com.google.gerrit.reviewdb.Project.NameKey> getAllParents(final com.google.gerrit.reviewdb.Project.NameKey projectName) { final java.util.Set<com.google.gerrit.reviewdb.Project.NameKey> parents = new java.util.HashSet<com.google.gerrit.reviewdb.Project.NameKey>(); com.google.gerrit.reviewdb.Project.NameKey p = projectName; while ((p != null) && (parents.add(p))) { final com.google.gerrit.server.project.ProjectState e = projectCache.get(p); if (e == null) { break; } p = getParentName(e.getProject()); } return parents; }
private java.util.List<com.google.gerrit.reviewdb.Project> getChildren(final com.google.gerrit.reviewdb.Project.NameKey parentName) { final java.util.List<com.google.gerrit.reviewdb.Project> childProjects = new java.util.ArrayList<com.google.gerrit.reviewdb.Project>(); for (final com.google.gerrit.reviewdb.Project.NameKey projectName : projectCache.all()) { final com.google.gerrit.server.project.ProjectState e = projectCache.get(projectName); if (e == null) { continue; } if (parentName.equals(getParentName(e.getProject()))) { childProjects.add(e.getProject()); } } return childProjects; }
public Project.NameKey getParentName() { if ((project.getParent()) != null) { return project.getParent(); } if (project.getNameKey().equals(allProjectsName)) { return null; } return allProjectsName; }

@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getEffectiveGroups() { return groups; }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groups(final com.google.gerrit.server.account.AccountState who) { final java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> r = new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>(); r.addAll(membershipCache.get(com.google.gerrit.server.auth.ldap.LdapRealm.findId(who.getExternalIds()))); r.addAll(who.getInternalGroups()); return r; }












static com.google.gerrit.server.project.SectionMatcher wrap(com.google.gerrit.common.data.AccessSection section) { java.lang.String ref = section.getName(); if (com.google.gerrit.common.data.AccessSection.isAccessSection(ref)) { return com.google.gerrit.server.project.SectionMatcher.wrap(ref, section); } else { return null; } }


@com.google.gwt.uibinder.client.UiHandler("deleteSection") void onDeleteSection(com.google.gwt.event.dom.client.ClickEvent event) { isDeleted = true; if ((name.isVisible()) && (com.google.gerrit.common.data.AccessSection.isAccessSection(name.getValue()))) { deletedName.setInnerText(Util.M.deletedReference(name.getValue())); } else { java.lang.String name = Util.C.sectionNames().get(value.getName()); if (name == null) { name = value.getName(); } deletedName.setInnerText(Util.M.deletedSection(name)); } normal.getStyle().setDisplay(Display.NONE); deleted.getStyle().setDisplay(Display.BLOCK); }
private void rebuildPermissionSelector() { java.util.List<java.lang.String> perms = new java.util.ArrayList<java.lang.String>(); if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) { for (java.lang.String varName : Util.C.capabilityNames().keySet()) { if ((value.getPermission(varName)) == null) { perms.add(varName); } } } else if (com.google.gerrit.common.data.AccessSection.isAccessSection(value.getName())) { for (com.google.gerrit.common.data.ApprovalType t : com.google.gerrit.client.Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) { java.lang.String varName = (com.google.gerrit.common.data.Permission.LABEL) + (t.getCategory().getLabelName()); if ((value.getPermission(varName)) == null) { perms.add(varName); } } for (java.lang.String varName : Util.C.permissionNames().keySet()) { if ((value.getPermission(varName)) == null) { perms.add(varName); } } } if (perms.isEmpty()) { addContainer.getStyle().setDisplay(Display.NONE); } else { addContainer.getStyle().setDisplay(Display.BLOCK); perms.add(0, Util.C.addPermission()); permissionSelector.setValue(Util.C.addPermission()); permissionSelector.setAcceptableValues(perms); } }
@java.lang.Override public void setValue(com.google.gerrit.common.data.AccessSection value) { java.util.Collections.sort(value.getPermissions()); this.value = value; this.readOnly = (!(editing)) || (!(projectAccess.isOwnerOf(value))); name.setEnabled((!(readOnly))); deleteSection.setVisible((!(readOnly))); if (com.google.gerrit.common.data.AccessSection.isAccessSection(value.getName())) { name.setVisible(true); name.setIgnoreEditorValue(false); sectionType.setInnerText(Util.C.sectionTypeReference()); } else { name.setVisible(false); name.setIgnoreEditorValue(true); java.lang.String name = Util.C.sectionNames().get(value.getName()); if (name != null) { sectionType.setInnerText(name); sectionName.getStyle().setDisplay(Display.NONE); } else { sectionType.setInnerText(Util.C.sectionTypeSection()); sectionName.setInnerText(value.getName()); sectionName.getStyle().clearDisplay(); } } if (readOnly) { addContainer.getStyle().setDisplay(Display.NONE); } else { enableEditing(); } }



public com.google.gwt.user.client.ui.Image createStar() { final com.google.gwt.user.client.ui.Image star = new com.google.gwt.user.client.ui.Image(getResource()); star.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); star.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { com.google.gerrit.client.changes.StarCache.this.toggleStar(); } }); com.google.gwt.event.logical.shared.ValueChangeHandler starUpdater = new com.google.gwt.event.logical.shared.ValueChangeHandler() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent event) { star.setResource(com.google.gerrit.client.changes.StarCache.this.getResource()); } }; cache.getChangeDetailCache().addValueChangeHandler(starUpdater); cache.getChangeInfoCache().addValueChangeHandler(starUpdater); this.addValueChangeHandler(starUpdater); return star; }
private void createSkipLine(int row, com.google.gerrit.client.patches.SkippedLine line) { com.google.gwt.user.client.ui.FlowPanel p = new com.google.gwt.user.client.ui.FlowPanel(); com.google.gwt.user.client.ui.Label l1 = new com.google.gwt.user.client.ui.Label(((" " + (PatchUtil.C.patchSkipRegionStart())) + " ")); com.google.gwt.user.client.ui.Anchor all = new com.google.gwt.user.client.ui.Anchor(java.lang.String.valueOf(line.getSize())); com.google.gwt.user.client.ui.Label l2 = new com.google.gwt.user.client.ui.Label(((" " + (PatchUtil.C.patchSkipRegionEnd())) + " ")); all.addClickHandler(expandAllListener); if ((line.getSize()) > 30) { com.google.gwt.user.client.ui.Anchor before = new com.google.gwt.user.client.ui.Anchor(PatchUtil.M.expandBefore(com.google.gerrit.client.patches.SideBySideTable.NUM_ROWS_TO_EXPAND)); before.addClickHandler(expandBeforeListener); com.google.gwt.user.client.ui.Anchor after = new com.google.gwt.user.client.ui.Anchor(PatchUtil.M.expandAfter(com.google.gerrit.client.patches.SideBySideTable.NUM_ROWS_TO_EXPAND)); after.addClickHandler(expandAfterListener); p.add(before); p.add(l1); p.add(all); p.add(l2); p.add(after); } else { p.add(l1); p.add(all); p.add(l2); } setWidget(row, 1, p); }
public com.google.gerrit.server.events.PatchSetAttribute asPatchSetAttribute(final com.google.gerrit.reviewdb.client.PatchSet patchSet) { com.google.gerrit.server.events.PatchSetAttribute p = new com.google.gerrit.server.events.PatchSetAttribute(); p.revision = patchSet.getRevision().get(); p.number = java.lang.Integer.toString(patchSet.getPatchSetId()); p.ref = patchSet.getRefName(); p.uploader = asAccountAttribute(patchSet.getUploader()); p.createdOn = (patchSet.getCreatedOn().getTime()) / 1000L; return p; }
public void run() { SuggestUtil.SVC.suggestProjectNameKey(req.getQuery(), req.getLimit(), new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> result) { final java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion> r = new java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion>(result.size()); for (final com.google.gerrit.reviewdb.client.Project.NameKey p : result) { r.add(new com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); } }); }


@java.lang.Override public void onRequestSuggestions(final com.google.gerrit.client.ui.Request req, final com.google.gerrit.client.ui.Callback callback) { com.google.gerrit.client.RpcStatus.hide(new java.lang.Runnable() { public void run() { SuggestUtil.SVC.suggestProjectNameKey(req.getQuery(), req.getLimit(), new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey>>() { public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> result) { final java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion> r = new java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion>(result.size()); for (final com.google.gerrit.reviewdb.client.Project.NameKey p : result) { r.add(new com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); } }); } }); }
public void onSuccess(final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> result) { final java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion> r = new java.util.ArrayList<com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion>(result.size()); for (final com.google.gerrit.reviewdb.client.Project.NameKey p : result) { r.add(new com.google.gerrit.client.ui.ProjectNameSuggestOracle.ProjectNameSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); }








public void display(final java.util.List<com.google.gerrit.reviewdb.client.Project> projects) { while (1 < (table.getRowCount())) table.removeRow(((table.getRowCount()) - 1)); for (final com.google.gerrit.reviewdb.client.Project k : projects) insert(table.getRowCount(), k); finishDisplay(); }

@java.lang.Override protected void onLoad() { super.onLoad(); Util.PROJECT_SVC.visibleProjects(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.ProjectList>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.ProjectList result) { createProjectLinkPanel.setVisible(result.canCreateProject()); projects.display(result.getProjects()); projects.finishDisplay(); } }); }
@java.lang.Override protected void populate(final int row, final com.google.gerrit.reviewdb.client.Project k) { table.setWidget(row, 1, new com.google.gerrit.client.ui.Hyperlink(k.getName(), link(k))); table.setText(row, 2, k.getDescription()); setRowItem(row, k); }
@java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.ProjectList result) { createProjectLinkPanel.setVisible(result.canCreateProject()); projects.display(result.getProjects()); projects.finishDisplay(); }
private java.lang.String link(final com.google.gerrit.reviewdb.client.Project item) { return com.google.gerrit.client.Dispatcher.toProjectAdmin(item.getNameKey(), ProjectScreen.INFO); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); setPageTitle(Util.C.projectListTitle()); createProjectLinkPanel = new com.google.gwt.user.client.ui.VerticalPanel(); createProjectLinkPanel.setStyleName(Gerrit.RESOURCES.css().createProjectLink()); createProjectLinkPanel.add(new com.google.gerrit.client.ui.Hyperlink(Util.C.headingCreateProject(), com.google.gerrit.common.PageLinks.ADMIN_CREATE_PROJECT)); add(createProjectLinkPanel); projects = new com.google.gerrit.client.ui.ProjectsTable() { @java.lang.Override protected void onOpenRow(final int row) { com.google.gwt.user.client.History.newItem(link(getRowItem(row))); } private java.lang.String link(final com.google.gerrit.reviewdb.client.Project item) { return com.google.gerrit.client.Dispatcher.toProjectAdmin(item.getNameKey(), ProjectScreen.INFO); } @java.lang.Override protected void populate(final int row, final com.google.gerrit.reviewdb.client.Project k) { table.setWidget(row, 1, new com.google.gerrit.client.ui.Hyperlink(k.getName(), link(k))); table.setText(row, 2, k.getDescription()); setRowItem(row, k); } }; projects.setSavePointerId(PageLinks.ADMIN_PROJECTS); add(projects); }
@java.lang.Override protected java.lang.Object getRowItemKey(final com.google.gerrit.reviewdb.client.Project item) { return item.getNameKey(); }

protected void populate(final int row, final com.google.gerrit.reviewdb.client.Project k) { table.setText(row, 1, k.getName()); table.setText(row, 2, k.getDescription()); setRowItem(row, k); }
protected void populateProjects() { Util.PROJECT_SVC.visibleProjects(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectList>() { @java.lang.Override public void onSuccess(final com.google.gerrit.common.data.ProjectList result) { projectsTab.display(result.getProjects()); if (firstPopupLoad) { firstPopupLoad = false; displayPopup(); } } }); }
@java.lang.Override public void onSuccess(final com.google.gerrit.common.data.ProjectList result) { projectsTab.display(result.getProjects()); if (firstPopupLoad) { firstPopupLoad = false; displayPopup(); } }

@java.lang.Override public void onSuccess(java.util.List<com.google.gerrit.reviewdb.client.Project> result) { if ((result != null) && (!(result.isEmpty()))) { suggestedParentsTab.setVisible(true); suggestedParentsTab.display(result); suggestedParentsTab.finishDisplay(); } }
private void initSuggestedParents() { suggestedParentsTab = new com.google.gerrit.client.ui.ProjectsTable() { { table.setText(0, 1, Util.C.parentSuggestions()); } @java.lang.Override protected void populate(final int row, final com.google.gerrit.reviewdb.client.Project k) { final com.google.gwt.user.client.ui.Anchor projectLink = new com.google.gwt.user.client.ui.Anchor(k.getName()); projectLink.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { sugestParent.setText(getRowItem(row).getName()); } }); table.setWidget(row, 1, projectLink); table.setText(row, 2, k.getDescription()); setRowItem(row, k); } }; suggestedParentsTab.setVisible(false); Util.PROJECT_SVC.suggestParentCandidates(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.reviewdb.client.Project>>() { @java.lang.Override public void onSuccess(java.util.List<com.google.gerrit.reviewdb.client.Project> result) { if ((result != null) && (!(result.isEmpty()))) { suggestedParentsTab.setVisible(true); suggestedParentsTab.display(result); suggestedParentsTab.finishDisplay(); } } }); }
@java.lang.Override protected void populate(final int row, final com.google.gerrit.reviewdb.client.Project k) { final com.google.gwt.user.client.ui.Anchor projectLink = new com.google.gwt.user.client.ui.Anchor(k.getName()); projectLink.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { sugestParent.setText(getRowItem(row).getName()); } }); table.setWidget(row, 1, projectLink); table.setText(row, 2, k.getDescription()); setRowItem(row, k); }










@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT"); res.setHeader("Pragma", "no-cache"); res.setHeader("Cache-Control", "no-cache, must-revalidate"); res.setContentType("text/plain"); res.setCharacterEncoding("UTF-8"); com.google.gerrit.server.project.ListProjects impl = factory.get(); com.google.gerrit.util.cli.CmdLineParser clp = parser.create(impl); try { @java.lang.SuppressWarnings("unchecked") java.util.Map<java.lang.String, java.lang.String[]> parameterMap = req.getParameterMap(); clp.parseOptionMap(parameterMap); } catch (org.kohsuke.args4j.CmdLineException e) { if (!(clp.wasHelpRequestedByOption())) { res.setStatus(HttpServletResponse.SC_BAD_REQUEST); send(res, e.getMessage().getBytes("UTF-8")); return; } } byte[] data; if (clp.wasHelpRequestedByOption()) { java.io.StringWriter msg = new java.io.StringWriter(); clp.printDetailedUsage(req.getRequestURI(), msg); data = msg.toString().getBytes("UTF-8"); } else { java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); impl.display(buf); data = buf.toByteArray(); } if (com.google.gwt.user.server.rpc.RPCServletUtils.acceptsGzipEncoding(req)) { res.setHeader("Content-Encoding", "gzip"); data = com.google.gerrit.httpd.HtmlDomUtil.compress(data); } send(res, data); }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> watchedby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account account = args.accountResolver.find(who); if (account == null) { throw error((("User " + who) + " not found")); } return new com.google.gerrit.server.query.change.IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, account.getId())); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> reviewer(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); if (m.isEmpty()) { throw error((("User " + who) + " not found")); } else if ((m.size()) == 1) { com.google.gerrit.reviewdb.client.Account.Id id = m.iterator().next(); return new com.google.gerrit.server.query.change.ReviewerPredicate(args.dbProvider, id); } else { java.util.List<com.google.gerrit.server.query.change.ReviewerPredicate> p = new java.util.ArrayList<com.google.gerrit.server.query.change.ReviewerPredicate>(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { p.add(new com.google.gerrit.server.query.change.ReviewerPredicate(args.dbProvider, id)); } return com.google.gerrit.server.query.Predicate.or(p); } }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> owner(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); if (m.isEmpty()) { throw error((("User " + who) + " not found")); } else if ((m.size()) == 1) { com.google.gerrit.reviewdb.client.Account.Id id = m.iterator().next(); return new com.google.gerrit.server.query.change.OwnerPredicate(args.dbProvider, id); } else { java.util.List<com.google.gerrit.server.query.change.OwnerPredicate> p = new java.util.ArrayList<com.google.gerrit.server.query.change.OwnerPredicate>(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { p.add(new com.google.gerrit.server.query.change.OwnerPredicate(args.dbProvider, id)); } return com.google.gerrit.server.query.Predicate.or(p); } }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> starredby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account account = args.accountResolver.find(who); if (account == null) { throw error((("User " + who) + " not found")); } return new com.google.gerrit.server.query.change.IsStarredByPredicate(args.dbProvider, args.userFactory.create(args.dbProvider, account.getId())); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> draftby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account account = args.accountResolver.find(who); if (account == null) { throw error((("User " + who) + " not found")); } return new com.google.gerrit.server.query.change.HasDraftByPredicate(args.dbProvider, account.getId()); }

void print(java.io.PrintWriter out) { seen.clear(); collisions.clear(); for (com.google.gwtorm.schema.RelationModel r : rels) { for (com.google.gwtorm.schema.ColumnModel c : r.getColumns()) { if (c.isNested()) { java.lang.String type = com.google.gwtorm.schema.java.ProtoFileGenerator.getShortClassName(c); if (seen.contains(type)) { collisions.add(type); } else { seen.add(type); } } } } seen.clear(); for (com.google.gwtorm.schema.RelationModel r : rels) { generateMessage(r.getPrimaryKey().getField(), out, true); } for (com.google.gwtorm.schema.RelationModel r : rels) { generateMessage(r, out); } out.print((("message Any" + (schemaName)) + " {\n")); for (com.google.gwtorm.schema.RelationModel r : com.google.gwtorm.schema.java.ProtoFileGenerator.sortRelations(rels)) { out.print((((((("\toptional " + (com.google.gwtorm.schema.java.ProtoFileGenerator.getMessageName(r))) + " ") + (r.getRelationName().toLowerCase())) + " = ") + (r.getRelationID())) + ";\n")); } out.print("}\n"); }
private static void dashboard(final java.lang.String token) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(Account.Id.parse(com.google.gerrit.client.Dispatcher.skip(token)))); }

@java.lang.Override protected void onLoad() { super.onLoad(); Util.LIST_SVC.forAccount(ownerId, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.AccountDashboardInfo>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.AccountDashboardInfo r) { display(r); } }); }




protected com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.data.SingleListChangeInfo> loadCallback() { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.SingleListChangeInfo>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.SingleListChangeInfo result) { display(result); } }; }
protected void display(final com.google.gerrit.common.data.SingleListChangeInfo result) { changes = result.getChanges(); if (!(changes.isEmpty())) { final com.google.gerrit.common.data.ChangeInfo f = changes.get(0); final com.google.gerrit.common.data.ChangeInfo l = changes.get(((changes.size()) - 1)); prev.setTargetHistoryToken((((anchorPrefix) + ",p,") + (f.getSortKey()))); next.setTargetHistoryToken((((anchorPrefix) + ",n,") + (l.getSortKey()))); if (useLoadPrev) { prev.setVisible((!(result.isAtEnd()))); next.setVisible((!(com.google.gerrit.client.changes.PagedSingleListScreen.MIN_SORTKEY.equals(pos)))); } else { prev.setVisible((!(com.google.gerrit.client.changes.PagedSingleListScreen.MAX_SORTKEY.equals(pos)))); next.setVisible((!(result.isAtEnd()))); } } table.setAccountInfoCache(result.getAccounts()); section.display(result.getChanges()); table.finishDisplay(); }

@java.lang.Override protected void loadPrev() { Util.LIST_SVC.allQueryPrev(query, pos, pageSize, loadCallback()); }

@java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.SingleListChangeInfo result) { display(result); }


@java.lang.Override protected void onInitUI() { super.onInitUI(); prev = new com.google.gerrit.client.ui.Hyperlink(Util.C.pagedChangeListPrev(), true, ""); prev.setVisible(false); next = new com.google.gerrit.client.ui.Hyperlink(Util.C.pagedChangeListNext(), true, ""); next.setVisible(false); table = new com.google.gerrit.client.changes.ChangeTable(true) { { keysNavigation.add(new com.google.gerrit.client.changes.PagedSingleListScreen.DoLinkCommand(0, 'p', Util.C.changeTablePagePrev(), prev)); keysNavigation.add(new com.google.gerrit.client.changes.PagedSingleListScreen.DoLinkCommand(0, 'n', Util.C.changeTablePageNext(), next)); } }; section = new com.google.gerrit.client.changes.ChangeTable.Section(null, com.google.gerrit.client.changes.ChangeTable.ApprovalViewType.STRONGEST, null); table.addSection(section); table.setSavePointerId(anchorPrefix); add(table); final com.google.gwt.user.client.ui.HorizontalPanel buttons = new com.google.gwt.user.client.ui.HorizontalPanel(); buttons.setStyleName(Gerrit.RESOURCES.css().changeTablePrevNextLinks()); buttons.add(prev); buttons.add(next); add(buttons); }
@java.lang.Override protected com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.common.data.SingleListChangeInfo> loadCallback() { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.SingleListChangeInfo>() { public final void onSuccess(final com.google.gerrit.common.data.SingleListChangeInfo result) { if (isAttached()) { if (((result.getChanges().size()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { final com.google.gerrit.common.data.ChangeInfo c = result.getChanges().get(0); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(c), new com.google.gerrit.client.changes.ChangeScreen(c)); } else { com.google.gerrit.client.Gerrit.setQueryString(query); display(result); com.google.gerrit.client.changes.QueryScreen.this.display(); } } } }; }
public final void onSuccess(final com.google.gerrit.common.data.SingleListChangeInfo result) { if (isAttached()) { if (((result.getChanges().size()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { final com.google.gerrit.common.data.ChangeInfo c = result.getChanges().get(0); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(c), new com.google.gerrit.client.changes.ChangeScreen(c)); } else { com.google.gerrit.client.Gerrit.setQueryString(query); display(result); this.display(); } } }
@java.lang.Override protected void loadNext() { Util.LIST_SVC.allQueryNext(query, pos, pageSize, loadCallback()); }


@java.lang.Override public void preDisplay(final com.google.gerrit.common.data.ListBranchesResult result) { if (result.getNoRepository()) { branches.setVisible(false); addPanel.setVisible(false); delBranch.setVisible(false); com.google.gwt.user.client.ui.Label no = new com.google.gwt.user.client.ui.Label(Util.C.errorNoGitRepository()); no.setStyleName(Gerrit.RESOURCES.css().smallHeading()); add(no); } else { enableForm(true); display(result.getBranches()); addPanel.setVisible(result.getCanAdd()); } }
private void enableForm(final boolean on) { delBranch.setEnabled(on); addBranch.setEnabled(on); nameTxtBox.setEnabled(on); irevTxtBox.setEnabled(on); }
@com.google.gerrit.common.auth.SignInRequired void deleteBranch(com.google.gerrit.reviewdb.Project.NameKey projectName, java.util.Set<com.google.gerrit.reviewdb.Branch.NameKey> ids, com.google.gwt.user.client.rpc.AsyncCallback<java.util.Set<com.google.gerrit.reviewdb.Branch.NameKey>> callback);
@java.lang.Override public void deleteBranch(final com.google.gerrit.reviewdb.Project.NameKey projectName, final java.util.Set<com.google.gerrit.reviewdb.Branch.NameKey> toRemove, final com.google.gwt.user.client.rpc.AsyncCallback<java.util.Set<com.google.gerrit.reviewdb.Branch.NameKey>> callback) { deleteBranchesFactory.create(projectName, toRemove).to(callback); }
private void display(final java.util.List<com.google.gerrit.reviewdb.Branch> listBranches) { branches.display(listBranches); delBranch.setVisible(branches.hasBranchCanDelete()); }
com.google.gerrit.httpd.rpc.project.DeleteBranches create(@com.google.inject.assistedinject.Assisted com.google.gerrit.reviewdb.Project.NameKey name, @com.google.inject.assistedinject.Assisted java.util.Set<com.google.gerrit.reviewdb.Branch.NameKey> toRemove);


@java.lang.Override protected void onLoad() { super.onLoad(); Util.PROJECT_SVC.listBranches(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.ListBranchesResult>(this) { @java.lang.Override public void preDisplay(final com.google.gerrit.common.data.ListBranchesResult result) { if (result.getNoRepository()) { branches.setVisible(false); addPanel.setVisible(false); delBranch.setVisible(false); com.google.gwt.user.client.ui.Label no = new com.google.gwt.user.client.ui.Label(Util.C.errorNoGitRepository()); no.setStyleName(Gerrit.RESOURCES.css().smallHeading()); add(no); } else { enableForm(true); display(result.getBranches()); addPanel.setVisible(result.getCanAdd()); } } }); }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "can not delete references"); } }
private void parseUpdate(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canUpdate()) { if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } validateNewCommits(ctl, cmd); } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd, "can not update the reference as a fast forward"); } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { com.google.gerrit.reviewdb.client.Change c = change(db); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else if ((approvals) != null) { currentApprovals = approvalsMap(db).get(c.currentPatchSetId()); } else { currentApprovals = db.get().patchSetApprovals().byPatchSet(c.currentPatchSetId()).toList(); } } return currentApprovals; }
private void verifyCommandLine() throws com.google.gerrit.sshd.commands.UnloggedFailure { if ((processor.getIncludeFiles()) && (!((processor.getIncludePatchSets()) || (processor.getIncludeCurrentPatchSet())))) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, "--files option needs --patch-sets or --current-patch-set"); } }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) { startThread(new com.google.gerrit.plugins.CommandRunnable() { @java.lang.Override public void run() throws com.google.gerrit.plugins.Failure { parseCommandLine(); final java.io.PrintWriter stdout = toPrintWriter(out); stdout.println("Hello world!"); stdout.flush(); } }); }

private com.google.inject.Injector createSshInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); if (sshd) { modules.add(new com.google.gerrit.sshd.SshModule()); if (slave) { modules.add(new com.google.gerrit.sshd.commands.SlaveCommandModule()); } else { modules.add(new com.google.gerrit.sshd.commands.MasterCommandModule()); } } else { modules.add(new com.google.gerrit.server.ssh.NoSshModule()); } return sysInjector.createChildInjector(modules); }
public void copyVetosToLatestPatchSet(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet.Id source; if ((change.getNumberOfPatchSets()) > 1) { source = new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), ((change.getNumberOfPatchSets()) - 1)); } else { throw new java.io.IOException("Previous patch set could not be found"); } com.google.gerrit.reviewdb.client.PatchSet.Id dest = change.currPatchSetId(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : db.patchSetApprovals().byPatchSet(source)) { if (!(ApprovalCategory.SUBMIT.equals(a.getCategoryId()))) { final com.google.gerrit.common.data.ApprovalType type = approvalTypes.byId(a.getCategoryId()); if ((type.getCategory().isCopyMinScore()) && (type.isMaxNegative(a))) { db.patchSetApprovals().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.PatchSetApproval(dest, a))); } } } }







public boolean canRestore() { return canAbandon(); }

private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(new com.google.gerrit.common.ChangeHookRunner.Module()); modules.add(new com.google.gerrit.server.git.ReceiveCommitsExecutorModule()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.ehcache.EhcachePoolImpl.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.mail.SignedTokenEmailTokenVerifier.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); return cfgInjector.createChildInjector(modules); }
private void initSshd() { sshInjector = createSshInjector(); manager.add(sshInjector); }
private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(com.google.gerrit.server.schema.SchemaVersionCheck.module()); modules.add(new com.google.gerrit.pgm.util.LogFileCompressor.Module()); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(new com.google.gerrit.common.ChangeHookRunner.Module()); modules.add(new com.google.gerrit.server.git.ReceiveCommitsExecutorModule()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.ehcache.EhcachePoolImpl.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.mail.SignedTokenEmailTokenVerifier.Module()); modules.add(new com.google.gerrit.server.git.PushReplication.Module()); if (httpd) { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); } else { modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.server.config.CanonicalWebUrlProvider.class; } }); } if (!(slave)) { modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); } return cfgInjector.createChildInjector(modules); }


private synchronized void init() { if ((manager) == null) { final java.lang.String path = java.lang.System.getProperty("gerrit.site_path"); if (path != null) { sitePath = new java.io.File(path); } try { dbInjector = createDbInjector(); } catch (com.google.inject.CreationException ce) { final com.google.inject.spi.Message first = ce.getErrorMessages().iterator().next(); final java.lang.StringBuilder buf = new java.lang.StringBuilder(); buf.append(first.getMessage()); java.lang.Throwable why = first.getCause(); while (why != null) { buf.append("\n caused by "); buf.append(why.toString()); why = why.getCause(); } if ((first.getCause()) != null) { buf.append("\n"); buf.append("\nResolve above errors before continuing."); buf.append("\nComplete stack trace follows:"); } com.google.gerrit.httpd.WebAppInitializer.log.error(buf.toString(), first.getCause()); throw new com.google.inject.CreationException(java.util.Collections.singleton(first)); } cfgInjector = createCfgInjector(); sysInjector = createSysInjector(); sshInjector = createSshInjector(); webInjector = createWebInjector(); sysInjector.getInstance(com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(javax.servlet.http.HttpServletRequest.class)); manager = new com.google.gerrit.lifecycle.LifecycleManager(); manager.add(dbInjector); manager.add(cfgInjector); manager.add(sysInjector); manager.add(sshInjector); manager.add(webInjector); } }


public void setSshInjector(com.google.inject.Injector injector) { sshModule = com.google.gerrit.server.plugins.PluginGuiceEnvironment.copy(injector); sshGen = injector.getProvider(com.google.gerrit.server.plugins.ModuleGenerator.class); onStart.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.StartPluginListener.class)); onReload.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.ReloadPluginListener.class)); }








private void export(com.google.gerrit.server.plugins.AutoRegisterModules.ClassData def) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.Class<?> clazz; try { clazz = java.lang.Class.forName(def.className, false, classLoader); } catch (java.lang.ClassNotFoundException err) { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Cannot load %s with @Export(\"%s\")", def.className, def.exportedAsName), err); } com.google.gerrit.extensions.Export export = clazz.getAnnotation(com.google.gerrit.extensions.Export.class); if (export == null) { PluginLoader.log.warn(java.lang.String.format("In plugin %s asm incorrectly parsed %s with @Export(\"%s\")", pluginName, clazz.getName(), def.exportedAsName)); return; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("org.apache.sshd.server.Command", clazz)) { if ((sshGen) != null) { sshGen.export(export, clazz); } } else if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpServlet", clazz)) { if ((httpGen) != null) { httpGen.export(export, clazz); } } else { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Class %s with @Export(\"%s\") not supported", clazz.getName(), export.value())); } }


private void scan() throws com.google.gerrit.server.plugins.InvalidPluginException { java.util.Enumeration<java.util.jar.JarEntry> e = jarFile.entries(); while (e.hasMoreElements()) { java.util.jar.JarEntry entry = e.nextElement(); if (com.google.gerrit.server.plugins.AutoRegisterModules.skip(entry)) { continue; } com.google.gerrit.server.plugins.AutoRegisterModules.ClassData def = new com.google.gerrit.server.plugins.AutoRegisterModules.ClassData(); try { new org.objectweb.asm.ClassReader(read(entry)).accept(def, com.google.gerrit.server.plugins.AutoRegisterModules.SKIP_ALL); } catch (java.io.IOException err) { throw new com.google.gerrit.server.plugins.InvalidPluginException("Cannot auto-register", err); } catch (java.lang.RuntimeException err) { PluginLoader.log.warn(java.lang.String.format("Plugin %s has invaild class file %s inside of %s", pluginName, entry.getName(), jarFile.getName()), err); continue; } if ((def.exportedAsName) != null) { if (def.isConcrete()) { export(def); } else { PluginLoader.log.warn(java.lang.String.format("Plugin %s tries to export abstract class %s", pluginName, def.className)); } } } }
public void remove();

public void setHttpInjector(com.google.inject.Injector injector) { httpModule = com.google.gerrit.server.plugins.PluginGuiceEnvironment.copy(injector); httpGen = injector.getProvider(com.google.gerrit.server.plugins.ModuleGenerator.class); onStart.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.StartPluginListener.class)); onReload.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.ReloadPluginListener.class)); }

private static <T> java.util.List<T> listeners(com.google.inject.Injector src, java.lang.Class<T> type) { java.util.List<com.google.inject.Binding<T>> bindings = src.findBindingsByType(com.google.inject.TypeLiteral.get(type)); java.util.List<T> found = com.google.common.collect.Lists.newArrayListWithCapacity(bindings.size()); for (com.google.inject.Binding<T> b : bindings) { found.add(b.getProvider().get()); } return found; }



void onReloadPlugin(com.google.gerrit.server.plugins.Plugin oldPlugin, com.google.gerrit.server.plugins.Plugin newPlugin) { for (com.google.gerrit.server.plugins.ReloadPluginListener l : onReload) { l.onReloadPlugin(oldPlugin, newPlugin); } }


void onStartPlugin(com.google.gerrit.server.plugins.Plugin plugin) { for (com.google.gerrit.server.plugins.StartPluginListener l : onStart) { l.onStartPlugin(plugin); } }
public void start(com.google.gerrit.server.plugins.PluginGuiceEnvironment env) throws java.lang.Exception { com.google.inject.Injector root = newRootInjector(env); manager = new com.google.gerrit.lifecycle.LifecycleManager(); if ((sysModule) != null) { sysInjector = root.createChildInjector(root.getInstance(sysModule)); manager.add(sysInjector); } else { sysInjector = root; } if (((sshModule) != null) && (env.hasSshModule())) { sshInjector = sysInjector.createChildInjector(env.getSshModule(), sysInjector.getInstance(sshModule)); manager.add(sshInjector); } if (((httpModule) != null) && (env.hasHttpModule())) { httpInjector = sysInjector.createChildInjector(env.getHttpModule(), sysInjector.getInstance(httpModule)); manager.add(httpInjector); } manager.start(); }




@java.lang.Override public void destroy() { synchronized(this) { if ((cmd) != null) { final com.google.gerrit.sshd.SshScope.Context old = com.google.gerrit.sshd.SshScope.set(ctx); try { cmd.destroy(); log(BaseCommand.STATUS_CANCEL); } finally { ctx = null; cmd = null; com.google.gerrit.sshd.SshScope.set(old); } } } }




@java.lang.Override protected void init() throws com.google.gerrit.server.mail.EmailException { super.init(); bccWatchers(); }
protected final java.util.List<com.google.gerrit.reviewdb.client.AccountProjectWatch> getWatches() throws com.google.gwtorm.server.OrmException { if ((changeData) == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.reviewdb.client.AccountProjectWatch> matching = new java.util.ArrayList<com.google.gerrit.reviewdb.client.AccountProjectWatch>(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> projectWatchers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) { projectWatchers.add(w.getAccountId()); add(matching, w); } for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) { if (!(projectWatchers.contains(w.getAccountId()))) { add(matching, w); } } return java.util.Collections.unmodifiableList(matching); }
protected void bccWatchesNotifyAllComments() { try { for (final com.google.gerrit.reviewdb.client.AccountProjectWatch w : getWatches()) { if (w.isNotify(NotifyType.ALL_COMMENTS)) { add(RecipientType.BCC, w.getAccountId()); } } } catch (com.google.gwtorm.server.OrmException err) { } }
@java.lang.Override public boolean isVisible(com.google.gerrit.reviewdb.client.Account account) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId()); return changeControl.forUser(who).isVisible(reviewDbProvider.get()); }
void cleanup() { try { jarFile.close(); } catch (java.io.IOException err) { } if ((!(tmpFile.delete())) && (tmpFile.exists())) { PluginLoader.log.warn(("Cannot delete " + (tmpFile.getAbsolutePath()))); } }
private com.google.inject.Injector newRootInjector(com.google.gerrit.server.plugins.Plugin.ApiType type, com.google.gerrit.server.plugins.PluginGuiceEnvironment env) { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newLinkedList(); if (type == (com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN)) { modules.add(env.getSysModule()); } modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(name); bind(java.io.File.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginData.class).toProvider(new com.google.inject.Provider<java.io.File>() { private volatile boolean ready; @java.lang.Override public java.io.File get() { if (!(ready)) { synchronized(dataDir) { if ((!(dataDir.exists())) && (!(dataDir.mkdirs()))) { throw new com.google.inject.ProvisionException(java.lang.String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), name)); } ready = true; } } return dataDir; } }); } }); return com.google.inject.Guice.createInjector(modules); }
public void add(final com.google.inject.Injector injector) { if (started) { throw new java.lang.IllegalStateException("Already started"); } for (final com.google.inject.Binding<com.google.gerrit.lifecycle.LifecycleListener> binding : com.google.gerrit.lifecycle.LifecycleManager.get(injector)) { add(binding.getProvider().get()); } }
public void start() { if (!(started)) { started = true; for (com.google.gerrit.lifecycle.LifecycleListener obj : listeners.keySet()) { obj.start(); } } }
public void add(final com.google.gerrit.extensions.registration.RegistrationHandle handle) { if (handle instanceof com.google.gerrit.extensions.registration.ReloadableRegistrationHandle) { if ((reloadableHandles) == null) { reloadableHandles = com.google.common.collect.Lists.newArrayList(); } reloadableHandles.add(((com.google.gerrit.extensions.registration.ReloadableRegistrationHandle<?>) (handle))); } add(new com.google.gerrit.lifecycle.LifecycleListener() { @java.lang.Override public void start() { } @java.lang.Override public void stop() { handle.remove(); } }); }
public void add(final com.google.gerrit.lifecycle.LifecycleListener listener) { listeners.put(listener, true); }
public void stop() { if (started) { final java.util.List<com.google.gerrit.lifecycle.LifecycleListener> t = new java.util.ArrayList<com.google.gerrit.lifecycle.LifecycleListener>(listeners.keySet()); for (int i = (t.size()) - 1; 0 <= i; i--) { final com.google.gerrit.lifecycle.LifecycleListener obj = t.get(i); try { obj.stop(); } catch (java.lang.Throwable err) { org.slf4j.LoggerFactory.getLogger(obj.getClass()).warn("Failed to stop", err); } } started = false; } }


private void sendResource(java.util.jar.JarFile jar, java.util.jar.JarEntry entry, javax.servlet.http.HttpServletResponse res, java.lang.String pluginName) throws java.io.IOException { sendResource(jar, entry, res, pluginName, false); }

private com.google.inject.Injector newRootInjector(com.google.gerrit.server.plugins.PluginGuiceEnvironment env) { return com.google.inject.Guice.createInjector(env.getSysModule(), new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(name); } }); }
public boolean isOwner() { if ((isOwner) == null) { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(group.getOwnerGroupId()); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerUUID = (g != null) ? g.getGroupUUID() : null; isOwner = (getCurrentUser().getEffectiveGroups().contains(ownerUUID)) || (getCurrentUser().getCapabilities().canAdministrateServer()); } return isOwner; }
private static <T> java.util.List<java.util.concurrent.atomic.AtomicReference<T>> find(com.google.inject.Injector src, com.google.inject.TypeLiteral<T> type) { java.util.List<com.google.inject.Binding<T>> bindings = src.findBindingsByType(type); int cnt = (bindings != null) ? bindings.size() : 0; if (cnt == 0) { return java.util.Collections.emptyList(); } java.util.List<java.util.concurrent.atomic.AtomicReference<T>> r = new java.util.ArrayList<java.util.concurrent.atomic.AtomicReference<T>>(cnt); for (com.google.inject.Binding<T> b : bindings) { r.add(new java.util.concurrent.atomic.AtomicReference<T>(b.getProvider().get())); } return r; }

com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.reviewdb.client.Account.Id who, final boolean remember, final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin, java.lang.String xsrfToken) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long refreshCookieAt = (com.google.gerrit.httpd.WebSessionManager.now()) + refresh; if (xsrfToken == null) { final int nonceLen = 20; final byte[] rnd = new byte[nonceLen]; prng.nextBytes(rnd); xsrfToken = com.google.gerrit.httpd.CookieBase64.encode(rnd); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, xsrfToken); self.put(key, val); return val; }
com.google.gerrit.httpd.WebSessionManager.Val get(final com.google.gerrit.httpd.WebSessionManager.Key key) { return self.getIfPresent(key.token); }
public final SubmitRecord.Label.Status status() { if ((approved()) != null) { return SubmitRecord.Label.Status.OK; } else if ((rejected()) != null) { return SubmitRecord.Label.Status.REJECT; } else { return SubmitRecord.Label.Status.NEED; } }
@java.lang.Override protected void migrateData(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.server.schema.UpdateUI ui) throws java.sql.SQLException { final java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement(); try { stmt.execute(("CREATE INDEX submodule_subscription_access_bySubscription" + " ON submodule_subscriptions (submodule_project_name, submodule_branch_name)")); } finally { stmt.close(); } }
private int search(final java.lang.String fileName) { int high = patches.length; int low = 0; while (low < high) { final int mid = (low + high) >>> 1; final int cmp = patches[mid].getNewName().compareTo(fileName); if (cmp < 0) low = mid + 1; else if (cmp == 0) return mid; else high = mid; } return -(low + 1); }
@java.lang.Override public com.google.gwtjsonrpc.common.VoidResult call() throws com.google.gerrit.common.errors.ProjectCreationFailedException { final com.google.gerrit.server.project.CreateProjectArgs args = new com.google.gerrit.server.project.CreateProjectArgs(); args.setProjectName(projectName); if (!(parentName.equals(""))) { final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parentName); try { args.newParent = projectControlFactory.validateFor(nameKey); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.common.errors.ProjectCreationFailedException((("Parent project \"" + (parentName)) + "\" does not exist."), e); } } args.projectDescription = ""; args.submitType = com.google.gerrit.reviewdb.client.Project.SubmitType.MERGE_IF_NECESSARY; args.branch = org.eclipse.jgit.lib.Constants.MASTER; args.createEmptyCommit = emptyCommit; args.permissionsOnly = permissionsOnly; final com.google.gerrit.server.project.CreateProject createProject = createProjectFactory.create(args); createProject.createProject(); return com.google.gwtjsonrpc.common.VoidResult.INSTANCE; }
private void createEmptyCommit(final org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String ref) throws java.io.IOException { org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter(); try { org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[]{ })); cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent()); cb.setCommitter(serverIdent); cb.setMessage("Initial empty repository\n"); org.eclipse.jgit.lib.ObjectId id = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(Constants.HEAD); ru.setNewObjectId(id); final org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : replication.scheduleUpdate(project, ref); break; default : { throw new java.io.IOException(result.name()); } } } catch (java.io.IOException e) { com.google.gerrit.server.project.CreateProject.log.error(("Cannot create empty commit for " + (createProjectArgs.getProjectName())), e); throw e; } finally { oi.release(); } }
private void validateParameters() throws com.google.gerrit.common.errors.ProjectCreationFailedException { if (((createProjectArgs.getProjectName()) == null) || (createProjectArgs.getProjectName().isEmpty())) { throw new com.google.gerrit.common.errors.ProjectCreationFailedException("Project name is required"); } if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) { createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, ((createProjectArgs.getProjectName().length()) - (Constants.DOT_GIT_EXT.length())))); } if (!(currentUser.getCapabilities().canCreateProject())) { throw new com.google.gerrit.common.errors.ProjectCreationFailedException(java.lang.String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName())); } if (((createProjectArgs.ownerIds) == null) || (createProjectArgs.ownerIds.isEmpty())) { createProjectArgs.ownerIds = new java.util.ArrayList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>(projectOwnerGroups); } while (createProjectArgs.branch.startsWith("/")) { createProjectArgs.branch = createProjectArgs.branch.substring(1); } if (!(createProjectArgs.branch.startsWith(Constants.R_HEADS))) { createProjectArgs.branch = (org.eclipse.jgit.lib.Constants.R_HEADS) + (createProjectArgs.branch); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(createProjectArgs.branch))) { throw new com.google.gerrit.common.errors.ProjectCreationFailedException(java.lang.String.format("Branch \"%s\" is not a valid name.", createProjectArgs.branch)); } }
@java.lang.Override public com.google.gerrit.server.account.GroupMembership getEffectiveGroups() { if ((effectiveGroups) == null) { if (authConfig.isIdentityTrustable(state().getExternalIds())) { effectiveGroups = realm.groups(state()); } else { effectiveGroups = groupMembershipFactory.create(com.google.gerrit.server.IdentifiedUser.registeredGroups); } } return effectiveGroups; }
@java.lang.Override public com.google.gerrit.common.data.GroupDetail call() throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { control = groupControl.validateFor(groupId); final com.google.gerrit.reviewdb.client.AccountGroup group = control.getAccountGroup(); final com.google.gerrit.common.data.GroupDetail detail = new com.google.gerrit.common.data.GroupDetail(); detail.setGroup(group); detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId())); switch (group.getType()) { case INTERNAL : detail.setMembers(loadMembers()); detail.setIncludes(loadIncludes()); break; } detail.setAccounts(aic.create()); detail.setCanModify(control.isOwner()); detail.setGroups(gic.create()); return detail; }

@java.lang.Override protected void configure() { final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>> groups = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>>() {}; core(groups, com.google.gerrit.server.auth.ldap.LdapModule.GROUP_CACHE).maxAge(1, java.util.concurrent.TimeUnit.HOURS).populateWith(LdapRealm.MemberLoader.class); final com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id>> usernames = new com.google.inject.TypeLiteral<com.google.gerrit.server.cache.Cache<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id>>() {}; core(usernames, com.google.gerrit.server.auth.ldap.LdapModule.USERNAME_CACHE).populateWith(LdapRealm.UserLoader.class); bind(com.google.gerrit.server.account.Realm.class).to(com.google.gerrit.server.auth.ldap.LdapRealm.class).in(Scopes.SINGLETON); bind(com.google.gerrit.server.auth.ldap.Helper.class); }
public boolean isOwner() { if ((isOwner) == null) { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(group.getOwnerGroupId()); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerUUID = (g != null) ? g.getGroupUUID() : null; isOwner = (getCurrentUser().getEffectiveGroups().contains(ownerUUID)) || (getCurrentUser().getCapabilities().canAdministrateServer()); } return isOwner; }






private java.util.List<com.google.gerrit.common.data.GroupReference> suggestAccountGroup(final com.google.gerrit.reviewdb.server.ReviewDb db, final java.lang.String query, final int limit) throws com.google.gwtorm.server.OrmException { final java.lang.String a = query; final java.lang.String b = a + (com.google.gerrit.httpd.rpc.SuggestServiceImpl.MAX_SUFFIX); final int max = 10; final int n = (limit <= 0) ? max : java.lang.Math.min(limit, max); java.util.List<com.google.gerrit.common.data.GroupReference> r = new java.util.ArrayList<com.google.gerrit.common.data.GroupReference>(n); for (com.google.gerrit.reviewdb.client.AccountGroupName group : db.accountGroupNames().suggestByName(a, b, n)) { try { if (groupControlFactory.controlFor(group.getId()).isVisible()) { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(group.getId()); if ((g != null) && ((g.getGroupUUID()) != null)) { r.add(com.google.gerrit.common.data.GroupReference.forGroup(g)); } } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { continue; } } return r; }









public com.google.gerrit.server.account.GroupControl controlFor(final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if (group == null) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupId); } return new com.google.gerrit.server.account.GroupControl(groupCache, user.get(), group); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> ownerin(java.lang.String group) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.reviewdb.client.AccountGroup g = args.groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(group)); if (g == null) { throw error((("Group " + group) + " not found")); } return new com.google.gerrit.server.query.change.OwnerinPredicate(args.dbProvider, args.userFactory, g.getGroupUUID()); }


@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> reviewerin(java.lang.String group) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.reviewdb.client.AccountGroup g = args.groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(group)); if (g == null) { throw error((("Group " + group) + " not found")); } return new com.google.gerrit.server.query.change.ReviewerinPredicate(args.dbProvider, args.userFactory, g.getGroupUUID()); }


public boolean updateGroupNames(com.google.gerrit.server.account.GroupCache groupCache) { boolean dirty = false; for (com.google.gerrit.common.data.GroupReference ref : groupsByUUID.values()) { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(ref.getUUID()); if ((g != null) && (!(g.getName().equals(ref.getName())))) { dirty = true; ref.setName(g.getName()); } } return dirty; }
private void createProjectConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { final com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject()); try { final com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.load(md); com.google.gerrit.reviewdb.client.Project newProject = config.getProject(); newProject.setDescription(createProjectArgs.projectDescription); newProject.setSubmitType(createProjectArgs.submitType); newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements); newProject.setUseSignedOffBy(createProjectArgs.signedOffBy); newProject.setUseContentMerge(createProjectArgs.contentMerge); newProject.setRequireChangeID(createProjectArgs.changeIdRequired); if ((createProjectArgs.newParent) != null) { newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey()); } if (!(createProjectArgs.ownerIds.isEmpty())) { final com.google.gerrit.common.data.AccessSection all = config.getAccessSection(AccessSection.ALL, true); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerId : createProjectArgs.ownerIds) { com.google.gerrit.reviewdb.client.AccountGroup accountGroup = groupCache.get(ownerId); if (accountGroup != null) { com.google.gerrit.common.data.GroupReference group = config.resolve(accountGroup); all.getPermission(Permission.OWNER, true).add(new com.google.gerrit.common.data.PermissionRule(group)); } } } md.setMessage("Created project\n"); if (!(config.commit(md))) { throw new java.io.IOException(("Cannot create " + (createProjectArgs.getProjectName()))); } } finally { md.close(); } projectCache.onCreateProject(createProjectArgs.getProject()); repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription); replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG); }



public void evictAfterRename(final com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName, final com.google.gerrit.reviewdb.client.AccountGroup.NameKey newName) { byName.remove(oldName); updateGroupList(oldName, newName); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroup createEntry(final com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws java.lang.Exception { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> r = db.accountGroups().byUUID(uuid).toList(); if ((r.size()) == 1) { return r.get(0); } else { return null; } } finally { db.close(); } }
public com.google.gerrit.reviewdb.client.AccountGroup get(final com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return byUUID.get(uuid); }
public void evict(final com.google.gerrit.reviewdb.client.AccountGroup group) { byId.remove(group.getId()); byName.remove(group.getNameKey()); byUUID.remove(group.getGroupUUID()); byExternalName.remove(group.getExternalNameKey()); }
public com.google.gerrit.reviewdb.client.AccountGroup get(final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { return byId.get(groupId); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup> all() { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> groups = new java.util.ArrayList<com.google.gerrit.reviewdb.client.AccountGroup>(); for (final com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName : list.get(com.google.gerrit.server.account.GroupCacheImpl.ListKey.ALL)) { final com.google.gerrit.reviewdb.client.AccountGroup group = get(groupName); if (group != null) { groups.add(group); } } return java.util.Collections.unmodifiableList(groups); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroup createEntry(final com.google.gerrit.reviewdb.client.AccountGroup.NameKey key) throws java.lang.Exception { final com.google.gerrit.reviewdb.client.AccountGroupName r; final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { r = db.accountGroupNames().get(key); if (r != null) { return db.accountGroups().get(r.getId()); } else { return null; } } finally { db.close(); } }
@java.lang.Override public java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup> createEntry(final com.google.gerrit.reviewdb.client.AccountGroup.ExternalNameKey key) throws java.lang.Exception { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { return db.accountGroups().byExternalName(key).toList(); } finally { db.close(); } }
public com.google.gerrit.reviewdb.client.AccountGroup get(final com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { return byName.get(name); }
public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> filter(java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { final java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> visibleChanges = visibleChanges(); final java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = new java.util.HashMap<java.lang.String, org.eclipse.jgit.lib.Ref>(); final java.util.List<org.eclipse.jgit.lib.Ref> deferredTags = new java.util.ArrayList<org.eclipse.jgit.lib.Ref>(); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { if (com.google.gerrit.reviewdb.client.PatchSet.isRef(ref.getName())) { if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) { result.put(ref.getName(), ref); } } else if (com.google.gerrit.server.git.VisibleRefFilter.isTag(ref)) { if ((ref.getObjectId()) != null) { deferredTags.add(ref); } } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) { result.put(ref.getName(), ref); } } if ((!(deferredTags.isEmpty())) && (!(result.isEmpty()))) { com.google.gerrit.server.git.TagMatcher tags = tagCache.get(projectName).matcher(db, result.values()); for (org.eclipse.jgit.lib.Ref tag : deferredTags) { if (tags.isReachable(tag)) { result.put(tag.getName(), tag); } } } return result; }
@java.lang.Override public void setValue(com.google.gerrit.common.data.PermissionRule value) { com.google.gerrit.common.data.GroupReference ref = value.getGroup(); if ((ref.getUUID()) != null) { groupNameLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toGroup(ref.getUUID())); } groupNameLink.setText(ref.getName()); groupNameSpan.setInnerText(ref.getName()); deletedGroupName.setInnerText(ref.getName()); groupNameLink.setVisible(((ref.getUUID()) != null)); com.google.gwt.user.client.ui.UIObject.setVisible(groupNameSpan, ((ref.getUUID()) == null)); }




@java.lang.Override protected void service(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.httpd.RestApiServlet.noCache(res); try { super.service(req, res); } catch (java.lang.Error err) { com.google.gerrit.httpd.RestApiServlet.handleError(err, req, res); } catch (java.lang.RuntimeException err) { com.google.gerrit.httpd.RestApiServlet.handleError(err, req, res); } }







public void display(final java.lang.String commitMessage) { com.google.gwtexpui.safehtml.client.SafeHtml msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitMessage); msg = msg.linkify(); msg = com.google.gerrit.client.ui.CommentLinkProcessor.apply(msg); msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openElement("p").append(msg).closeElement("p"); msg = msg.replaceAll("\n\n", "</p><p>"); msg = msg.replaceAll("\n", "<br />"); com.google.gwtexpui.safehtml.client.SafeHtml.set(description, msg); }


@java.lang.Override protected void onInitUI() { super.onInitUI(); table = new com.google.gerrit.client.changes.ChangeTable2(); table.addStyleName(Gerrit.RESOURCES.css().accountDashboard()); outgoing = new com.google.gerrit.client.changes.ChangeTable2.Section(); incoming = new com.google.gerrit.client.changes.ChangeTable2.Section(); closed = new com.google.gerrit.client.changes.ChangeTable2.Section(); outgoing.setTitleText(Util.C.outgoingReviews()); incoming.setTitleText(Util.C.incomingReviews()); closed.setTitleText(Util.C.recentlyClosed()); table.addSection(outgoing); table.addSection(incoming); table.addSection(closed); add(table); table.setSavePointerId(("owner:" + (ownerId))); }
public void display(com.google.gerrit.client.changes.ChangeList changeList) { final int sz = (changeList != null) ? changeList.size() : 0; final boolean hadData = (rows) > 0; if (hadData) { while (sz < (rows)) { parent.removeRow(dataBegin); (rows)--; } } else { parent.removeRow(dataBegin); } if (sz == 0) { parent.insertNoneRow(dataBegin); return; } while ((rows) < sz) { parent.insertChangeRow(((dataBegin) + (rows))); (rows)++; } for (int i = 0; i < sz; i++) { parent.populateChangeRow(((dataBegin) + i), changeList.get(i)); } }
private com.google.gerrit.server.query.change.ListChanges.ChangeInfo toChangeInfo(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ListChanges.ChangeInfo out = new com.google.gerrit.server.query.change.ListChanges.ChangeInfo(); com.google.gerrit.reviewdb.client.Change in = cd.change(db); out.project = in.getProject().get(); out.branch = in.getDest().getShortName(); out.topic = in.getTopic(); out.id = in.getKey().get(); out.subject = in.getSubject(); out.status = in.getStatus(); out.owner = asAccountAttribute(in.getOwner()); out.created = in.getCreatedOn(); out.updated = in.getLastUpdatedOn(); out._number = in.getId().get(); out._sortkey = in.getSortKey(); out.starred = (user.getStarredChanges().contains(in.getId())) ? true : null; out.labels = labelsFor(cd); return out; }

private void rebuildPermissionSelector() { java.util.List<java.lang.String> perms = new java.util.ArrayList<java.lang.String>(); if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) { for (java.lang.String varName : Util.C.capabilityNames().keySet()) { if ((value.getPermission(varName)) == null) { perms.add(varName); } } } else if (com.google.gerrit.common.data.AccessSection.isAccessSection(value.getName())) { for (com.google.gerrit.common.data.ApprovalType t : com.google.gerrit.client.Gerrit.getConfig().getApprovalTypes().getApprovalTypes()) { java.lang.String varName = (com.google.gerrit.common.data.Permission.LABEL) + (t.getCategory().getLabelName()); if ((value.getPermission(varName)) == null) { perms.add(varName); } } for (java.lang.String varName : Util.C.permissionNames().keySet()) { if ((value.getPermission(varName)) == null) { perms.add(varName); } } } if (perms.isEmpty()) { addContainer.getStyle().setDisplay(Display.NONE); } else { addContainer.getStyle().setDisplay(Display.BLOCK); perms.add(0, Util.C.addPermission()); permissionSelector.setValue(Util.C.addPermission()); permissionSelector.setAcceptableValues(perms); } }


private java.util.List<com.google.gerrit.server.project.SectionMatcher> getLocalAccessSections() { java.util.List<com.google.gerrit.server.project.SectionMatcher> sm = localAccessSections; if (sm == null) { java.util.Collection<com.google.gerrit.common.data.AccessSection> fromConfig = config.getAccessSections(); sm = new java.util.ArrayList<com.google.gerrit.server.project.SectionMatcher>(fromConfig.size()); for (com.google.gerrit.common.data.AccessSection section : fromConfig) { com.google.gerrit.server.project.SectionMatcher matcher = com.google.gerrit.server.project.SectionMatcher.wrap(section); if (matcher != null) { sm.add(matcher); } } localAccessSections = sm; } return sm; }
protected void setPageTitle(final java.lang.String text) { final java.lang.String old = headerText.getText(); if (text.isEmpty()) { header.setVisible(false); } else { headerText.setText(text); header.setVisible(true); } if (((windowTitle) == null) || ((windowTitle) == old)) { setWindowTitle(text); } }
private void displayTitle(final com.google.gerrit.reviewdb.client.Change.Key changeId, final java.lang.String subject) { final java.lang.StringBuilder titleBuf = new java.lang.StringBuilder(); if (com.google.gwt.i18n.client.LocaleInfo.getCurrentLocale().isRTL()) { if (subject != null) { titleBuf.append(subject); titleBuf.append(" :"); } titleBuf.append(Util.M.changeScreenTitleId(changeId.abbreviate())); } else { titleBuf.append(Util.M.changeScreenTitleId(changeId.abbreviate())); if (subject != null) { titleBuf.append(": "); titleBuf.append(subject); } } setPageTitle(titleBuf.toString()); }

public void display(final java.lang.String commitMessage) { java.lang.String commitSummary = ""; java.lang.String commitBody = ""; java.lang.String[] splitCommitMessage = commitMessage.split("\n", 2); commitSummary = splitCommitMessage[0]; if ((splitCommitMessage.length) > 1) commitBody = splitCommitMessage[1]; if (commitBody.trim().isEmpty()) { commitBodyPre.getStyle().setDisplay(Display.NONE); } com.google.gwtexpui.safehtml.client.SafeHtml commitSummaryLinkified = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitSummary); commitSummaryLinkified = commitSummaryLinkified.linkify(); commitSummaryLinkified = com.google.gerrit.client.ui.CommentLinkProcessor.apply(commitSummaryLinkified); com.google.gwtexpui.safehtml.client.SafeHtml commitBodyLinkified = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitBody); commitBodyLinkified = commitBodyLinkified.linkify(); commitBodyLinkified = com.google.gerrit.client.ui.CommentLinkProcessor.apply(commitBodyLinkified); commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString()); commitBodyPre.setInnerHTML(commitBodyLinkified.asString()); }
public void display(final com.google.gerrit.reviewdb.client.Change chg, final com.google.gerrit.reviewdb.client.PatchSetInfo info, final com.google.gerrit.common.data.AccountInfoCache acc) { infoBlock.display(chg, acc); messageBlock.display(info.getMessage()); }

public void display(final java.lang.String commitMessage) { com.google.gwtexpui.safehtml.client.SafeHtml msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitMessage); msg = msg.linkify(); msg = com.google.gerrit.client.ui.CommentLinkProcessor.apply(msg); msg = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openElement("p").append(msg).closeElement("p"); msg = msg.replaceAll("\n\n", "</p><p>"); msg = msg.replaceAll("\n", "<br />"); com.google.gwtexpui.safehtml.client.SafeHtml.set(description, msg); }
private void embedMovie() { if ((com.google.gwtexpui.clippy.client.CopyableLabel.flashEnabled) && (com.google.gwtexpui.user.client.UserAgent.hasFlash)) { final java.lang.String flashVars = "text=" + (com.google.gwt.http.client.URL.encodeQueryString(getText())); final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder h = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); h.openElement("span"); h.setStyleName(ClippyResources.I.css().control()); h.openElement("object"); h.setWidth(com.google.gwtexpui.clippy.client.CopyableLabel.SWF_WIDTH); h.setHeight(com.google.gwtexpui.clippy.client.CopyableLabel.SWF_HEIGHT); h.setAttribute("classid", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"); h.paramElement("movie", com.google.gwtexpui.clippy.client.CopyableLabel.swfUrl()); h.paramElement("FlashVars", flashVars); h.openElement("embed"); h.setWidth(com.google.gwtexpui.clippy.client.CopyableLabel.SWF_WIDTH); h.setHeight(com.google.gwtexpui.clippy.client.CopyableLabel.SWF_HEIGHT); h.setAttribute("wmode", "transparent"); h.setAttribute("type", "application/x-shockwave-flash"); h.setAttribute("src", com.google.gwtexpui.clippy.client.CopyableLabel.swfUrl()); h.setAttribute("FlashVars", flashVars); h.closeSelf(); h.closeElement("object"); h.closeElement("span"); if ((swf) != null) { com.google.gwt.user.client.DOM.removeChild(getElement(), swf); } com.google.gwt.user.client.DOM.appendChild(getElement(), (swf = com.google.gwtexpui.safehtml.client.SafeHtml.parse(h))); } }
public void display(com.google.gerrit.reviewdb.client.Change.Id changeId, java.lang.Boolean starred, java.lang.String commitMessage) { if (((changeId != null) && (starred != null)) && (com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.changes.StarredChanges.Icon star = com.google.gerrit.client.changes.StarredChanges.createIcon(changeId, starred); star.setStyleName(Gerrit.RESOURCES.css().changeScreenStarIcon()); starPanel.add(star); if ((keysAction) != null) { keysAction.add(com.google.gerrit.client.changes.StarredChanges.newKeyCommand(star)); } } java.lang.String[] splitCommitMessage = commitMessage.split("\n", 2); java.lang.String commitSummary = splitCommitMessage[0]; java.lang.String commitBody = ""; if ((splitCommitMessage.length) > 1) { commitBody = splitCommitMessage[1]; } com.google.gwtexpui.safehtml.client.SafeHtml commitSummaryLinkified = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitSummary); commitSummaryLinkified = commitSummaryLinkified.linkify(); commitSummaryLinkified = com.google.gerrit.client.ui.CommentLinkProcessor.apply(commitSummaryLinkified); commitSummaryPre.setInnerHTML(commitSummaryLinkified.asString()); if (commitBody.trim().isEmpty()) { commitBodyPre.getStyle().setDisplay(Display.NONE); } else { com.google.gwtexpui.safehtml.client.SafeHtml commitBodyLinkified = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commitBody); commitBodyLinkified = commitBodyLinkified.linkify(); commitBodyLinkified = com.google.gerrit.client.ui.CommentLinkProcessor.apply(commitBodyLinkified); commitBodyPre.setInnerHTML(commitBodyLinkified.asString()); } }
public com.google.gerrit.reviewdb.client.Account find(final java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); return (r.size()) == 1 ? byId.get(r.iterator().next()).getAccount() : null; }
void populate(final int row, final com.google.gerrit.client.plugins.PluginInfo plugin) { table.setText(row, 1, plugin.name()); table.setText(row, 2, plugin.version()); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); setRowItem(row, plugin); }

private void enable(boolean enabled) { commitMessage.setEnabled(enabled); commit.setEnabled(enabled); cancel1.setEnabled(enabled); cancel2.setEnabled(enabled); }
private void rename(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { boolean success = false; for (int attempts = 0; (!success) && (attempts < (com.google.gerrit.server.git.RenameGroupOp.MAX_TRIES)); attempts++) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { projectCache.evict(config.getProject()); return; } ref.setName(newName); md.getCommitBuilder().setAuthor(author); md.setMessage((((("Rename group " + (oldName)) + " to ") + (newName)) + "\n")); if (config.commit(md)) { projectCache.evict(config.getProject()); success = true; } else { try { java.lang.Thread.sleep(25); } catch (java.lang.InterruptedException wakeUp) { continue; } } } if (!success) { if (tryingAgain) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((("Could not rename group " + (oldName)) + " to ") + (newName)) + " in ") + (md.getProjectName().get()))); } else { retryOn.add(md.getProjectName()); } } }


@java.lang.Override protected java.lang.String getRefName() { return GitRepositoryManager.REF_CONFIG; }


@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.mail.EmailException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { final com.google.gerrit.common.data.ReviewResult result = abandonChangeFactory.create(patchSetId.getParentKey(), message).call(); if ((result.getErrors().size()) > 0) { throw new com.google.gerrit.server.project.NoSuchChangeException(result.getChangeId()); } return changeDetailFactory.create(result.getChangeId()).call(); }
public void verifyMergeability(com.google.gerrit.reviewdb.client.Change change) { try { setDestProject(); openRepository(); final org.eclipse.jgit.lib.Ref destBranchRef = repo.getRef(destBranch.get()); submitted = new java.util.ArrayList<com.google.gerrit.reviewdb.client.Change>(); submitted.add(change); if ((((destBranchRef == null) && ((change.getLastSha1MergeTested()) == null)) || ((change.getLastSha1MergeTested()) == null)) || ((destBranchRef != null) && (!(destBranchRef.getObjectId().getName().equals(change.getLastSha1MergeTested().get()))))) { openSchema(); preMerge(); if (destBranchRef != null) { change.setLastSha1MergeTested(new com.google.gerrit.reviewdb.client.RevId(destBranchRef.getObjectId().getName())); } else { change.setLastSha1MergeTested(new com.google.gerrit.reviewdb.client.RevId("")); } change.setMergeable(isMergeable(change)); db.changes().update(java.util.Collections.singleton(change)); } } catch (com.google.gerrit.server.git.MergeException e) { com.google.gerrit.server.git.MergeOp.log.error((("Test merge attempt for change: " + (change.getId())) + " failed"), e); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.MergeOp.log.error((("Test merge attempt for change: " + (change.getId())) + " failed: Not able to query the database"), e); } catch (java.io.IOException e) { com.google.gerrit.server.git.MergeOp.log.error((("Test merge attempt for change: " + (change.getId())) + " failed"), e); } finally { if ((db) != null) { db.close(); } db = null; } }


@java.lang.Override public int run() throws java.lang.Exception { if ((threads) <= 0) { threads = 1; } dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); gitInjector = dbInjector.createChildInjector(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { install(com.google.gerrit.server.schema.SchemaVersionCheck.module()); bind(com.google.gerrit.common.data.ApprovalTypes.class).toProvider(com.google.gerrit.server.config.ApprovalTypesProvider.class).in(Scopes.SINGLETON); bind(java.lang.String.class).annotatedWith(com.google.gerrit.server.config.CanonicalWebUrl.class).toProvider(com.google.gerrit.server.config.CanonicalWebUrlProvider.class).in(Scopes.SINGLETON); bind(com.google.gerrit.server.cache.CachePool.class); install(com.google.gerrit.server.account.AccountCacheImpl.module()); install(com.google.gerrit.server.account.GroupCacheImpl.module()); install(new com.google.gerrit.ehcache.EhcachePoolImpl.Module()); install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(CreateCodeReviewNotes.Factory.class); } }); install(new com.google.gerrit.lifecycle.LifecycleModule() { @java.lang.Override protected void configure() { listener().to(LocalDiskRepositoryManager.Lifecycle.class); } }); } }); manager.add(dbInjector, gitInjector); manager.start(); gitInjector.injectMembers(this); java.util.List<com.google.gerrit.reviewdb.client.Change> allChangeList = allChanges(); monitor.beginTask("Scanning changes", allChangeList.size()); changes = cluster(allChangeList); allChangeList = null; monitor.startWorkers(threads); for (int tid = 0; tid < (threads); tid++) { new com.google.gerrit.pgm.ExportReviewNotes.Worker().start(); } monitor.waitForCompletion(); monitor.endTask(); manager.stop(); return 0; }
private org.eclipse.jgit.revwalk.RevCommit createCommit(org.eclipse.jgit.notes.NoteMap map, org.eclipse.jgit.lib.PersonIdent author, java.lang.String message, org.eclipse.jgit.revwalk.RevCommit... parents) throws java.io.IOException { org.eclipse.jgit.lib.CommitBuilder b = new org.eclipse.jgit.lib.CommitBuilder(); b.setTreeId(map.writeTree(inserter)); b.setAuthor((author != null ? author : gerritIdent)); b.setCommitter(gerritIdent); if ((parents.length) > 0) { b.setParentIds(parents); } b.setMessage(message); org.eclipse.jgit.lib.ObjectId commitId = inserter.insert(b); inserter.flush(); return revWalk.parseCommit(commitId); }


public void create(java.util.List<com.google.gerrit.server.git.CodeReviewCommit> commits, org.eclipse.jgit.lib.PersonIdent author) throws com.google.gerrit.server.git.CodeReviewNoteCreationException { try { this.commits = commits; this.author = author; loadBase(); applyNotes(); updateRef(); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.CodeReviewNoteCreationException(e); } catch (java.lang.InterruptedException e) { throw new com.google.gerrit.server.git.CodeReviewNoteCreationException(e); } finally { release(); } }
@java.lang.Override protected void configure() { install(com.google.gerrit.server.schema.SchemaVersionCheck.module()); bind(com.google.gerrit.common.data.ApprovalTypes.class).toProvider(com.google.gerrit.server.config.ApprovalTypesProvider.class).in(Scopes.SINGLETON); bind(java.lang.String.class).annotatedWith(com.google.gerrit.server.config.CanonicalWebUrl.class).toProvider(com.google.gerrit.server.config.CanonicalWebUrlProvider.class).in(Scopes.SINGLETON); bind(com.google.gerrit.server.cache.CachePool.class); install(com.google.gerrit.server.account.AccountCacheImpl.module()); install(com.google.gerrit.server.account.GroupCacheImpl.module()); install(new com.google.gerrit.ehcache.EhcachePoolImpl.Module()); install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(CreateCodeReviewNotes.Factory.class); } }); install(new com.google.gerrit.lifecycle.LifecycleModule() { @java.lang.Override protected void configure() { listener().to(LocalDiskRepositoryManager.Lifecycle.class); } }); }



@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "patch to review") void addPatchSetId(final java.lang.String token) { try { patchSetIds.addAll(parsePatchSetId(token)); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { throw new java.lang.IllegalArgumentException(e.getMessage(), e); } catch (com.google.gwtorm.server.OrmException e) { throw new java.lang.IllegalArgumentException("database error", e); } }
private void displayParents(final java.util.List<com.google.gerrit.reviewdb.client.PatchSetInfo.ParentInfo> parents) { if ((parents.size()) == 0) { infoTable.setWidget(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_PARENTS, 1, new com.google.gwt.user.client.ui.InlineLabel(Util.C.initialCommit())); return; } final com.google.gwt.user.client.ui.Grid parentsTable = new com.google.gwt.user.client.ui.Grid(parents.size(), 2); parentsTable.setStyleName(Gerrit.RESOURCES.css().parentsTable()); parentsTable.addStyleName(Gerrit.RESOURCES.css().noborder()); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter ptfmt = parentsTable.getCellFormatter(); int row = 0; for (com.google.gerrit.reviewdb.client.PatchSetInfo.ParentInfo parent : parents) { parentsTable.setWidget(row, 0, new com.google.gwt.user.client.ui.InlineLabel(parent.id.get())); ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().noborder()); ptfmt.addStyleName(row, 0, Gerrit.RESOURCES.css().monospace()); parentsTable.setWidget(row, 1, new com.google.gwt.user.client.ui.InlineLabel(parent.shortMessage)); ptfmt.addStyleName(row, 1, Gerrit.RESOURCES.css().noborder()); row++; } infoTable.setWidget(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_PARENTS, 1, parentsTable); }

public static void doSignIn(java.lang.String token) { switch (com.google.gerrit.client.Gerrit.myConfig.getAuthType()) { case HTTP : case HTTP_LDAP : case CLIENT_SSL_CERT_LDAP : case CUSTOM_EXTENSION : com.google.gwt.user.client.Window.Location.assign(com.google.gerrit.client.Gerrit.loginRedirect(token)); break; case DEVELOPMENT_BECOME_ANY_ACCOUNT : com.google.gwt.user.client.Window.Location.assign(com.google.gerrit.client.Gerrit.selfRedirect("/become")); break; case OPENID : new com.google.gerrit.client.auth.openid.OpenIdSignInDialog(com.google.gerrit.common.auth.SignInMode.SIGN_IN, token, null).center(); break; case LDAP : case LDAP_BIND : new com.google.gerrit.client.auth.userpass.UserPassSignInDialog(token, null).center(); break; } }
@java.lang.Override protected void onInitUI() { super.onInitUI(); if (com.google.gerrit.client.Gerrit.isSignedIn()) { setTitleFarEast(reviewed); } keysNavigation = new com.google.gwtexpui.globalkey.client.KeyCommandSet(Gerrit.C.sectionNavigation()); keysNavigation.add(new com.google.gerrit.client.patches.UpToChangeCommand(patchKey.getParentKey(), 0, 'u')); keysNavigation.add(new com.google.gerrit.client.patches.PatchScreen.FileListCmd(0, 'f', PatchUtil.C.fileList())); historyTable = new com.google.gerrit.client.patches.HistoryTable(this); commitMessageBlock = new com.google.gerrit.client.changes.CommitMessageBlock(); topPanel = new com.google.gwt.user.client.ui.FlowPanel(); add(topPanel); noDifference = new com.google.gwt.user.client.ui.Label(PatchUtil.C.noDifference()); noDifference.setStyleName(Gerrit.RESOURCES.css().patchNoDifference()); noDifference.setVisible(false); contentTable = createContentTable(); contentTable.fileList = fileList; topNav = new com.google.gerrit.client.patches.NavLinks(keysNavigation, patchKey.getParentKey()); bottomNav = new com.google.gerrit.client.patches.NavLinks(null, patchKey.getParentKey()); add(topNav); contentPanel = new com.google.gwt.user.client.ui.FlowPanel(); contentPanel.setStyleName(Gerrit.RESOURCES.css().sideBySideScreenSideBySideTable()); contentPanel.add(noDifference); contentPanel.add(contentTable); add(contentPanel); add(bottomNav); if ((fileList) != null) { topNav.display(patchIndex, getPatchScreenType(), fileList); bottomNav.display(patchIndex, getPatchScreenType(), fileList); } }





@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { displayPopup(); }





@java.lang.Override protected void onUnload() { super.onUnload(); closePopup(); }


public void setPosition(int offsetWidth, int offsetHeight) { if ((preferredPopupWidth) == (-1)) { preferredPopupWidth = offsetWidth; } int top = (grid.getAbsoluteTop()) - 50; int left = 5 + (java.lang.Math.max(((grid.getAbsoluteLeft()) + (grid.getOffsetWidth())), ((watchesTab.getAbsoluteLeft()) + (watchesTab.getOffsetWidth())))); if ((top + offsetHeight) > (com.google.gwt.user.client.Window.getClientHeight())) { top = (com.google.gwt.user.client.Window.getClientHeight()) - offsetHeight; } if ((left + offsetWidth) > (com.google.gwt.user.client.Window.getClientWidth())) { left = (com.google.gwt.user.client.Window.getClientWidth()) - offsetWidth; } if (top < 0) { sp.setHeight((((sp.getOffsetHeight()) + top) + "px")); top = 0; } if (left < 0) { sp.setWidth((((sp.getOffsetWidth()) + left) + "px")); left = 0; } popup.setPopupPosition(left, top); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); createWidgets(); final com.google.gwt.user.client.ui.Grid grid = new com.google.gwt.user.client.ui.Grid(2, 2); grid.setStyleName(Gerrit.RESOURCES.css().infoBlock()); grid.setText(0, 0, Util.C.watchedProjectName()); grid.setWidget(0, 1, nameTxt); grid.setText(1, 0, Util.C.watchedProjectFilter()); grid.setWidget(1, 1, filterTxt); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = grid.getCellFormatter(); fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost()); fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost()); fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().header()); fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().header()); fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader()); final com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.setStyleName(Gerrit.RESOURCES.css().addWatchPanel()); fp.add(grid); fp.add(addNew); fp.add(browse); add(fp); add(watchesTab); add(delSel); final com.google.gwt.user.client.ui.FlowPanel pfp = new com.google.gwt.user.client.ui.FlowPanel(); sp = new com.google.gwt.user.client.ui.ScrollPanel(projectsTab); pfp.add(sp); pfp.add(close); popup.setWidget(pfp); popupPosition = new com.google.gwt.user.client.ui.PopupPanel.PositionCallback() { public void setPosition(int offsetWidth, int offsetHeight) { if ((preferredPopupWidth) == (-1)) { preferredPopupWidth = offsetWidth; } int top = (grid.getAbsoluteTop()) - 50; int left = 5 + (java.lang.Math.max(((grid.getAbsoluteLeft()) + (grid.getOffsetWidth())), ((watchesTab.getAbsoluteLeft()) + (watchesTab.getOffsetWidth())))); if ((top + offsetHeight) > (com.google.gwt.user.client.Window.getClientHeight())) { top = (com.google.gwt.user.client.Window.getClientHeight()) - offsetHeight; } if ((left + offsetWidth) > (com.google.gwt.user.client.Window.getClientWidth())) { left = (com.google.gwt.user.client.Window.getClientWidth()) - offsetWidth; } if (top < 0) { sp.setHeight((((sp.getOffsetHeight()) + top) + "px")); top = 0; } if (left < 0) { sp.setWidth((((sp.getOffsetWidth()) + left) + "px")); left = 0; } popup.setPopupPosition(left, top); } }; }







@java.lang.Override protected void onInitUI() { super.onInitUI(); setPageTitle(Util.C.createProjectTitle()); vp = new com.google.gwt.user.client.ui.VerticalPanel(); addCreateProjectPanel(); }








private void initSuggestedParents() { suggestedParentsTab = new com.google.gerrit.client.ui.ProjectsTable() { { table.setText(0, 1, Util.C.parentSuggestions()); } @java.lang.Override protected void populate(final int row, final com.google.gerrit.client.projects.ProjectInfo k) { final com.google.gwt.user.client.ui.Anchor projectLink = new com.google.gwt.user.client.ui.Anchor(k.name()); projectLink.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { sugestParent.setText(getRowItem(row).name()); } }); table.setWidget(row, 1, projectLink); table.setText(row, 2, k.description()); setRowItem(row, k); } }; suggestedParentsTab.setVisible(false); com.google.gerrit.client.projects.ProjectMap.permissions(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.ProjectMap>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ProjectMap list) { if (!(list.isEmpty())) { suggestedParentsTab.setVisible(true); suggestedParentsTab.display(list); suggestedParentsTab.finishDisplay(); } } }); }

private com.google.gerrit.client.ui.PatchLink createLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType, com.google.gwtexpui.safehtml.client.SafeHtml before, com.google.gwtexpui.safehtml.client.SafeHtml after) { com.google.gerrit.reviewdb.client.Patch patch = patchList.get(index); if (((listenablePrefs.get().isSkipDeleted()) && (patch.getChangeType().equals(ChangeType.DELETED))) || ((listenablePrefs.get().isSkipUncommented()) && ((patch.getCommentCount()) == 0))) { return null; } com.google.gerrit.reviewdb.client.Patch.Key thisKey = patch.getKey(); com.google.gerrit.client.ui.PatchLink link; if ((patchType == (PatchScreen.Type.SIDE_BY_SIDE)) && ((patch.getPatchType()) == (com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED))) { link = new com.google.gerrit.client.ui.PatchLink.SideBySide("", base, thisKey, index, detail, this); } else { link = new com.google.gerrit.client.ui.PatchLink.Unified("", base, thisKey, index, detail, this); } com.google.gwtexpui.safehtml.client.SafeHtmlBuilder text = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); text.append(before); text.append(com.google.gerrit.client.changes.PatchTable.getFileNameOnly(patch)); text.append(after); com.google.gwtexpui.safehtml.client.SafeHtml.set(link, text); return link; }
public com.google.gerrit.client.ui.InlineHyperlink getPreviousPatchLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType) { for (index--; index > (-1); index--) { com.google.gerrit.client.ui.InlineHyperlink link = createLink(index, patchType, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.prevPatchLinkIcon()), null); if (link != null) { return link; } } return null; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType) { for (index++; index < (patchList.size()); index++) { com.google.gerrit.client.ui.InlineHyperlink link = createLink(index, patchType, null, com.google.gwtexpui.safehtml.client.SafeHtml.asis(Util.C.nextPatchLinkIcon())); if (link != null) { return link; } } return null; }
private void runPlugin(java.lang.String name, java.io.File jar, com.google.gerrit.server.plugins.Plugin oldPlugin) throws com.google.gerrit.server.plugins.PluginInstallException { org.eclipse.jgit.storage.file.FileSnapshot snapshot = org.eclipse.jgit.storage.file.FileSnapshot.save(jar); try { com.google.gerrit.server.plugins.Plugin newPlugin = loadPlugin(name, jar, snapshot); boolean reload = ((oldPlugin != null) && (oldPlugin.canReload())) && (newPlugin.canReload()); if ((!reload) && (oldPlugin != null)) { oldPlugin.stop(); running.remove(name); } newPlugin.start(env); if (reload) { env.onReloadPlugin(oldPlugin, newPlugin); oldPlugin.stop(); } else { env.onStartPlugin(newPlugin); } running.put(name, newPlugin); broken.remove(name); } catch (java.lang.Throwable err) { broken.put(name, snapshot); throw new com.google.gerrit.server.plugins.PluginInstallException(err); } }
@java.lang.Override public boolean accept(java.io.File pathname) { return (pathname.getName().endsWith(".jar")) && (pathname.isFile()); }
private java.util.List<java.io.File> scanJarsInPluginsDirectory() { if (((pluginsDir) == null) || (!(pluginsDir.exists()))) { return java.util.Collections.emptyList(); } java.io.File[] matches = pluginsDir.listFiles(new java.io.FileFilter() { @java.lang.Override public boolean accept(java.io.File pathname) { return (pathname.getName().endsWith(".jar")) && (pathname.isFile()); } }); if (matches == null) { com.google.gerrit.server.plugins.PluginLoader.log.error(("Cannot list " + (pluginsDir.getAbsolutePath()))); return java.util.Collections.emptyList(); } return java.util.Arrays.asList(matches); }
private void createReviewedPanel() { reviewedPanel = new com.google.gwt.user.client.ui.FlowPanel(); reviewedCheckBox = new com.google.gwt.user.client.ui.CheckBox(((PatchUtil.C.reviewedAnd()) + " ")); reviewedCheckBox.addValueChangeHandler(new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { setReviewedByCurrentUser(event.getValue()); } }); reviewedPanel.add(reviewedCheckBox); reviewedPanel.add(getReviewedAnchor()); }
void populate(final int row, final com.google.gerrit.client.plugins.PluginInfo plugin) { com.google.gwt.user.client.ui.CheckBox checkBox = new com.google.gwt.user.client.ui.CheckBox(); table.setWidget(row, 1, checkBox); table.setWidget(row, 2, new com.google.gwt.user.client.ui.Anchor(plugin.name(), com.google.gerrit.client.Gerrit.selfRedirect((("/plugins/" + (plugin.name())) + "/")))); table.setText(row, 3, plugin.version()); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); setRowItem(row, plugin); }
public <T> boolean parse(T param, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gerrit.util.cli.CmdLineParser clp = parserFactory.create(param); try { @java.lang.SuppressWarnings("unchecked") java.util.Map<java.lang.String, java.lang.String[]> parameterMap = req.getParameterMap(); clp.parseOptionMap(parameterMap); } catch (org.kohsuke.args4j.CmdLineException e) { if (!(clp.wasHelpRequestedByOption())) { res.setStatus(HttpServletResponse.SC_BAD_REQUEST); com.google.gerrit.httpd.RestApiServlet.sendText(req, res, e.getMessage()); return false; } } if (clp.wasHelpRequestedByOption()) { java.io.StringWriter msg = new java.io.StringWriter(); clp.printQueryStringUsage(req.getRequestURI(), msg); msg.write('\n'); msg.write('\n'); clp.printUsage(msg, null); msg.write('\n'); com.google.gerrit.httpd.RestApiServlet.sendText(req, res, msg.toString()); return false; } return true; }


public void parseOptionMap(java.util.Map<java.lang.String, java.lang.String[]> parameters) throws org.kohsuke.args4j.CmdLineException { java.util.ArrayList<java.lang.String> tmp = new java.util.ArrayList<java.lang.String>(); for (java.util.Map.Entry<java.lang.String, java.lang.String[]> ent : parameters.entrySet()) { java.lang.String name = ent.getKey(); if (!(name.startsWith("-"))) { if ((name.length()) == 1) { name = "-" + name; } else { name = "--" + name; } } if ((findHandler(name)) instanceof org.kohsuke.args4j.spi.BooleanOptionHandler) { boolean on = false; for (java.lang.String value : ent.getValue()) { on = toBoolean(ent.getKey(), value); } if (on) { tmp.add(name); } } else { for (java.lang.String value : ent.getValue()) { tmp.add(name); tmp.add(value); } } } parser.parseArgument(tmp.toArray(new java.lang.String[tmp.size()])); }





public void refresh() { com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs; if ((patchTable) == null) { diffPrefs = new com.google.gerrit.client.ui.ListenableAccountDiffPreference().get(); } else { diffPrefs = patchTable.getPreferences().get(); } Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.PatchSetDetail>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { if (patchSet.getId().equals(diffBaseId)) { patchTable.setVisible(false); actionsPanel.setVisible(false); } else { if ((patchTable) != null) { patchTable.removeFromParent(); } patchTable = new com.google.gerrit.client.changes.PatchTable(); patchTable.display(diffBaseId, result); body.add(patchTable); for (com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler) { patchTable.addClickHandler(clickHandler); } } } }); }


@java.lang.Override public void onSuccess(com.google.gerrit.common.data.PatchSetDetail result) { if (patchSet.getId().equals(diffBaseId)) { patchTable.setVisible(false); actionsPanel.setVisible(false); } else { if ((patchTable) != null) { patchTable.removeFromParent(); } patchTable = new com.google.gerrit.client.changes.PatchTable(); patchTable.display(diffBaseId, result); body.add(patchTable); for (com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler) { patchTable.addClickHandler(clickHandler); } } }
@java.lang.Override public void onOpen(final com.google.gwt.event.logical.shared.OpenEvent<com.google.gwt.user.client.ui.DisclosurePanel> event) { if ((infoTable) == null) { com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs; if ((diffBaseId) == null) { diffPrefs = null; } else { diffPrefs = new com.google.gerrit.client.ui.ListenableAccountDiffPreference().get(); } Util.DETAIL_SVC.patchSetDetail2(diffBaseId, patchSet.getId(), diffPrefs, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.PatchSetDetail>() { public void onSuccess(final com.google.gerrit.common.data.PatchSetDetail result) { ensureLoaded(result); patchTable.setRegisterKeys(true); } }); } }
public void onSuccess(final com.google.gerrit.common.data.PatchSetDetail result) { ensureLoaded(result); patchTable.setRegisterKeys(true); }
public void ensureLoaded(final com.google.gerrit.common.data.PatchSetDetail detail) { infoTable = new com.google.gwt.user.client.ui.Grid(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_CNT, 2); infoTable.setStyleName(Gerrit.RESOURCES.css().infoBlock()); infoTable.addStyleName(Gerrit.RESOURCES.css().patchSetInfoBlock()); initRow(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_AUTHOR, Util.C.patchSetInfoAuthor()); initRow(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_COMMITTER, Util.C.patchSetInfoCommitter()); initRow(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_PARENTS, Util.C.patchSetInfoParents()); initRow(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_DOWNLOAD, Util.C.patchSetInfoDownload()); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter itfmt = infoTable.getCellFormatter(); itfmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost()); itfmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost()); itfmt.addStyleName(((com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_CNT) - 1), 0, Gerrit.RESOURCES.css().bottomheader()); itfmt.addStyleName(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_AUTHOR, 1, Gerrit.RESOURCES.css().useridentity()); itfmt.addStyleName(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_COMMITTER, 1, Gerrit.RESOURCES.css().useridentity()); itfmt.addStyleName(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_DOWNLOAD, 1, Gerrit.RESOURCES.css().downloadLinkListCell()); final com.google.gerrit.reviewdb.client.PatchSetInfo info = detail.getInfo(); displayUserIdentity(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_AUTHOR, info.getAuthor()); displayUserIdentity(com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.R_COMMITTER, info.getCommitter()); displayParents(info.getParents()); displayDownload(); body.add(infoTable); if (!(patchSet.getId().equals(diffBaseId))) { patchTable = new com.google.gerrit.client.changes.PatchTable(); patchTable.setSavePointerId(("PatchTable " + (patchSet.getId()))); patchTable.display(diffBaseId, detail); actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions()); body.add(actionsPanel); if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (changeDetail.canEdit()) { populateReviewAction(); if (changeDetail.isCurrentPatchSet(detail)) { populateActions(detail); } } if (detail.getPatchSet().isDraft()) { if (changeDetail.canPublish()) { populatePublishAction(); } if ((changeDetail.canDeleteDraft()) && ((changeDetail.getPatchSets().size()) > 1)) { populateDeleteDraftPatchSetAction(); } } } populateDiffAllActions(detail); body.add(patchTable); for (com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler) { patchTable.addClickHandler(clickHandler); } } }



protected void display() { final com.google.gerrit.reviewdb.client.AccountDiffPreference dp = getValue(); setIgnoreWhitespace(dp.getIgnoreWhitespace()); if (enableSmallFileFeatures) { syntaxHighlighting.setValue(dp.isSyntaxHighlighting()); } else { syntaxHighlighting.setValue(false); } setContext(dp.getContext()); tabWidth.setIntValue(dp.getTabSize()); colWidth.setIntValue(dp.getLineLength()); intralineDifference.setValue(dp.isIntralineDifference()); whitespaceErrors.setValue(dp.isShowWhitespaceErrors()); showTabs.setValue(dp.isShowTabs()); skipDeleted.setValue(dp.isSkipDeleted()); skipUncommented.setValue(dp.isSkipUncommented()); expandAllComments.setValue(dp.isExpandAllComments()); retainHeader.setValue(dp.isRetainHeader()); manualReview.setValue(dp.isManualReview()); }
private void update() { if ((colWidth.getIntValue()) <= 0) { new com.google.gerrit.client.ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center(); return; } com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(getValue()); dp.setIgnoreWhitespace(getIgnoreWhitespace()); dp.setContext(getContext()); dp.setTabSize(tabWidth.getIntValue()); dp.setLineLength(colWidth.getIntValue()); dp.setSyntaxHighlighting(syntaxHighlighting.getValue()); dp.setIntralineDifference(intralineDifference.getValue()); dp.setShowWhitespaceErrors(whitespaceErrors.getValue()); dp.setShowTabs(showTabs.getValue()); dp.setSkipDeleted(skipDeleted.getValue()); dp.setSkipUncommented(skipUncommented.getValue()); dp.setExpandAllComments(expandAllComments.getValue()); dp.setRetainHeader(retainHeader.getValue()); dp.setManualReview(manualReview.getValue()); listenablePrefs.set(dp); }



public static com.google.gerrit.reviewdb.client.AccountDiffPreference createDefault(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = new com.google.gerrit.reviewdb.client.AccountDiffPreference(accountId); p.setIgnoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE); p.setTabSize(8); p.setLineLength(100); p.setSyntaxHighlighting(true); p.setShowWhitespaceErrors(true); p.setIntralineDifference(true); p.setShowTabs(true); p.setContext(com.google.gerrit.reviewdb.client.AccountDiffPreference.DEFAULT_CONTEXT); p.setManualReview(false); return p; }

private java.lang.String toHTML(com.google.gerrit.prettify.common.SparseFileContent src) { com.google.gwtexpui.safehtml.client.SafeHtml html; if (diffPrefs.isIntralineDifference()) { html = colorLineEdits(src); } else { com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); for (int index = src.first(); index < (src.size()); index = src.next(index)) { b.append(src.get(index)); b.append('\n'); } html = b; final java.lang.String r = ((("<span class=\"wse\"" + " title=\"") + (PrettifyConstants.C.wseBareCR())) + "\"") + ">&nbsp;</span>$1"; html = html.replaceAll("\r([^\n])", r); } if (diffPrefs.isShowWhitespaceErrors()) { html = showTabAfterSpace(html); html = showTrailingWhitespace(html); } if (diffPrefs.isShowTabs()) { java.lang.String t = (1 < (diffPrefs.getTabSize())) ? "\t" : ""; html = html.replaceAll("\t", ("<span class=\"vt\">\u00bb</span>" + t)); } return html.asString(); }
private void appendShowBareCR(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder buf, java.lang.String src, boolean end) { while (!(src.isEmpty())) { int cr = src.indexOf('\r'); if (cr < 0) { buf.append(src); return; } else if (end) { if (cr == ((src.length()) - 1)) { buf.append(src.substring(0, cr)); return; } } else if ((cr == ((src.length()) - 2)) && ((src.charAt((cr + 1))) == '\n')) { buf.append(src.substring(0, cr)); buf.append('\n'); return; } buf.append(src.substring(0, cr)); buf.openSpan(); buf.setStyleName("wse"); buf.setAttribute("title", PrettifyConstants.C.wseBareCR()); buf.nbsp(); buf.closeSpan(); src = src.substring((cr + 1)); } }
protected com.google.gerrit.prettify.common.SparseHtmlFile getSparseHtmlFileA(com.google.gerrit.common.data.PatchScript s) { com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(s.getDiffPrefs()); dp.setShowWhitespaceErrors(false); com.google.gerrit.prettify.common.PrettyFormatter f = ClientSideFormatter.FACTORY.get(); f.setDiffPrefs(dp); f.setFileName(s.getA().getPath()); f.setEditFilter(PrettyFormatter.A); f.setEditList(s.getEdits()); f.format(s.getA()); return f; }





void onExecute(int exitValue) { final com.google.gerrit.sshd.SshScope.Context ctx = context.get(); ctx.finished = java.lang.System.currentTimeMillis(); final java.lang.String commandLine = ctx.getCommandLine(); java.lang.String cmd = QuotedString.BOURNE.quote(commandLine); if (cmd == commandLine) { cmd = ("'" + commandLine) + "'"; } final org.apache.log4j.spi.LoggingEvent event = log(cmd); event.setProperty(com.google.gerrit.sshd.SshLog.P_WAIT, (((ctx.started) - (ctx.created)) + "ms")); event.setProperty(com.google.gerrit.sshd.SshLog.P_EXEC, (((ctx.finished) - (ctx.started)) + "ms")); final java.lang.String status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status = "killed"; break; case BaseCommand.STATUS_NOT_FOUND : status = "not-found"; break; case BaseCommand.STATUS_NOT_ADMIN : status = "not-admin"; break; default : status = java.lang.String.valueOf(exitValue); break; } event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, status); async.append(event); }

void onLogout() { async.append(log("LOGOUT")); }












@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { webSession.get().logout(); if ((logoutUrl) != null) { rsp.sendRedirect(logoutUrl); } else { java.lang.String url = urlProvider.get(); if (com.google.common.base.Strings.isNullOrEmpty(url)) { url = req.getContextPath(); } if (com.google.common.base.Strings.isNullOrEmpty(url)) { url = "/"; } if (!(url.endsWith("/"))) { url += "/"; } rsp.sendRedirect(url); } }
void onLogin() { async.append(log(("LOGIN FROM " + (session.get().getRemoteAddressAsString())))); }

void onAuthFail(final com.google.gerrit.sshd.SshSession sd) { final org.apache.log4j.spi.LoggingEvent event = new org.apache.log4j.spi.LoggingEvent(org.apache.log4j.Logger.class.getName(), null, java.lang.System.currentTimeMillis(), org.apache.log4j.Level.INFO, ("AUTH FAILURE FROM " + (sd.getRemoteAddressAsString())), "SSHD", null, null, null, null); event.setProperty(com.google.gerrit.sshd.SshLog.P_SESSION, com.google.gerrit.sshd.SshLog.id(sd.getSessionId())); event.setProperty(com.google.gerrit.sshd.SshLog.P_USER_NAME, sd.getUsername()); final java.lang.String error = sd.getAuthenticationError(); if (error != null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, error); } async.append(event); }
private void validateNewCommits(com.google.gerrit.server.project.RefControl ctl, org.eclipse.jgit.transport.ReceiveCommand cmd) { final org.eclipse.jgit.revwalk.RevWalk walk = rp.getRevWalk(); walk.reset(); walk.sort(RevSort.NONE); try { walk.markStart(walk.parseCommit(cmd.getNewId())); for (org.eclipse.jgit.lib.ObjectId id : existingObjects()) { try { walk.markUninteresting(walk.parseCommit(id)); } catch (java.io.IOException e) { continue; } } org.eclipse.jgit.revwalk.RevCommit c; while ((c = walk.next()) != null) { if (!(validCommit(ctl, cmd, c))) { break; } } } catch (java.io.IOException err) { cmd.setResult(com.google.gerrit.server.git.REJECTED_MISSING_OBJECT); com.google.gerrit.server.git.ReceiveCommits.log.error("Invalid pack upload; one or more objects weren't sent", err); } }
@java.lang.SuppressWarnings("unchecked") <K, V> com.google.common.cache.CacheBuilder<K, V> create(com.google.gerrit.server.cache.CacheBinding<K, V> def, boolean unwrapValueHolder) { com.google.common.cache.CacheBuilder<K, V> builder = com.google.gerrit.server.cache.h2.DefaultCacheFactory.newCacheBuilder(); builder.recordStats(); builder.maximumWeight(cfg.getLong("cache", def.name(), "memoryLimit", def.maximumWeight())); com.google.common.cache.Weigher<K, V> weigher = def.weigher(); if ((weigher != null) && unwrapValueHolder) { final com.google.common.cache.Weigher<K, V> impl = weigher; weigher = ((com.google.common.cache.Weigher<K, V>) (new com.google.common.cache.Weigher<K, com.google.gerrit.server.cache.h2.H2CacheImpl.ValueHolder<V>>() { @java.lang.Override public int weigh(K key, com.google.gerrit.server.cache.h2.H2CacheImpl.ValueHolder<V> value) { return impl.weigh(key, value.value); } })); } else if (weigher == null) { weigher = com.google.gerrit.server.cache.h2.DefaultCacheFactory.unitWeight(); } builder.weigher(weigher); java.lang.Long age = def.expireAfterWrite(java.util.concurrent.TimeUnit.SECONDS); if (has(def.name(), "maxAge")) { builder.expireAfterWrite(com.google.gerrit.server.config.ConfigUtil.getTimeUnit(cfg, "cache", def.name(), "maxAge", (age != null ? age : 0), java.util.concurrent.TimeUnit.SECONDS), java.util.concurrent.TimeUnit.SECONDS); } else if (age != null) { builder.expireAfterWrite(age, java.util.concurrent.TimeUnit.SECONDS); } return builder; }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.cache.h2.DefaultCacheFactory.class); bind(com.google.gerrit.server.cache.MemoryCacheFactory.class).to(com.google.gerrit.server.cache.h2.DefaultCacheFactory.class); bind(com.google.gerrit.server.cache.PersistentCacheFactory.class).to(com.google.gerrit.server.cache.h2.H2CacheFactory.class); listener().to(com.google.gerrit.server.cache.h2.H2CacheFactory.class); }



private com.google.gerrit.server.query.change.ListChanges.ChangeInfo toChangeInfo(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ListChanges.ChangeInfo out = new com.google.gerrit.server.query.change.ListChanges.ChangeInfo(); com.google.gerrit.reviewdb.client.Change in = cd.change(db); out.project = in.getProject().get(); out.branch = in.getDest().getShortName(); out.topic = in.getTopic(); out.id = in.getKey().get(); out.subject = in.getSubject(); out.status = in.getStatus(); out.owner = asAccountAttribute(in.getOwner()); out.updated = in.getLastUpdatedOn(); out._number = in.getId().get(); out._sortkey = in.getSortKey(); out.starred = (user.getStarredChanges().contains(in.getId())) ? true : null; out.labels = (true) ? labelsFor(cd) : null; return out; }
public static void next(java.lang.String query, int limit, java.lang.String sortkey, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList> callback) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeList.newQuery(query); if (limit > 0) { call.addParameter("n", limit); } if (!(PagedSingleListScreen.MAX_SORTKEY.equals(sortkey))) { call.addParameter("N", sortkey); } call.send(callback); }
public static void prev(java.lang.String query, int limit, java.lang.String sortkey, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList> callback) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeList.newQuery(query); if (limit > 0) { call.addParameter("n", limit); } if (!(PagedSingleListScreen.MIN_SORTKEY.equals(sortkey))) { call.addParameter("P", sortkey); } call.send(callback); }

@java.lang.SuppressWarnings("unchecked") public static void query(com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeList<com.google.gerrit.client.changes.ChangeList>> callback, java.lang.String... queries) { assert (queries.length) >= 2; com.google.gerrit.client.rpc.RestApi call = new com.google.gerrit.client.rpc.RestApi(com.google.gerrit.client.changes.ChangeList.URI); for (java.lang.String q : queries) { call.addParameterRaw("q", com.google.gwtorm.client.KeyUtil.encode(q)); } call.send(callback); }
@java.lang.Override protected void configureServlets() { bind(com.google.gerrit.httpd.plugins.HttpPluginServlet.class); serve("/plugins/*").with(com.google.gerrit.httpd.plugins.HttpPluginServlet.class); bind(com.google.gerrit.server.plugins.StartPluginListener.class).annotatedWith(com.google.inject.internal.UniqueAnnotations.create()).to(com.google.gerrit.httpd.plugins.HttpPluginServlet.class); bind(com.google.gerrit.server.plugins.ReloadPluginListener.class).annotatedWith(com.google.inject.internal.UniqueAnnotations.create()).to(com.google.gerrit.httpd.plugins.HttpPluginServlet.class); bind(com.google.gerrit.server.plugins.ModuleGenerator.class).to(com.google.gerrit.httpd.plugins.HttpAutoRegisterModuleGenerator.class); install(new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.httpd.plugins.HttpPluginModule.PLUGIN_RESOURCES, com.google.gerrit.httpd.plugins.ResourceKey.class, com.google.gerrit.httpd.plugins.Resource.class).maximumWeight((2 << 20)).weigher(com.google.gerrit.httpd.plugins.ResourceWeigher.class); } }); }
@java.lang.Override public T call() throws java.lang.Exception { if ((threadLocal.get()) != null) { throw new java.lang.IllegalStateException(("Cannot continue request, " + ("thread already has request in progress. A new thread must " + "be used to propagate the request scope context."))); } threadLocal.set(ctx); try { return callable.call(); } finally { threadLocal.remove(); } }
@java.lang.Override protected final <T> java.util.concurrent.Callable<T> wrapImpl(final java.util.concurrent.Callable<T> callable) { final C ctx = continuingContext(requireContext()); return new java.util.concurrent.Callable<T>() { @java.lang.Override public T call() throws java.lang.Exception { if ((threadLocal.get()) != null) { throw new java.lang.IllegalStateException(("Cannot continue request, " + ("thread already has request in progress. A new thread must " + "be used to propagate the request scope context."))); } threadLocal.set(ctx); try { return callable.call(); } finally { threadLocal.remove(); } } }; }
private com.google.gwt.user.client.ui.Anchor getDownloadLink() { boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName()); if ((isCommitMessage || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) && (0 >= (script.getA().size())))) || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.B)) && (0 >= (script.getB().size())))) { return null; } com.google.gerrit.reviewdb.client.Patch.Key key = ((idSideA) == null) ? patchKey : new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); java.lang.String sideURL = ((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) ? "1" : "0"; final java.lang.String base = (com.google.gwt.core.client.GWT.getHostPageBaseURL()) + "cat/"; final com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(PatchUtil.C.download()); anchor.setHref((((base + (com.google.gwtorm.client.KeyUtil.encode(key.toString()))) + "^") + sideURL)); return anchor; }
private void addLink(java.lang.String label, final com.google.gerrit.reviewdb.client.PatchSet.Id id) { final com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(label); anchor.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { if ((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) { idSideA = id; } else { idSideB = id; } com.google.gerrit.reviewdb.client.Patch.Key keySideB = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); switch (screenType) { case SIDE_BY_SIDE : com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toPatchSideBySide(idSideA, keySideB)); break; case UNIFIED : com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toPatchUnified(idSideA, keySideB)); break; } } }); links.add(anchor); linkPanel.add(anchor); }

private void populateReviewedPanel() { reviewedPanel.clear(); reviewedCheckBox = new com.google.gwt.user.client.ui.CheckBox(((PatchUtil.C.reviewedAnd()) + " ")); reviewedCheckBox.addValueChangeHandler(new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { setReviewedByCurrentUser(event.getValue()); } }); reviewedPanel.add(reviewedCheckBox); reviewedPanel.add(getReviewedAnchor()); }

public void parseOptionMap(java.util.Map<java.lang.String, java.lang.String[]> parameters, java.util.Set<java.lang.String> argNames) throws org.kohsuke.args4j.CmdLineException { java.util.ArrayList<java.lang.String> tmp = new java.util.ArrayList<java.lang.String>(); for (java.util.Map.Entry<java.lang.String, java.lang.String[]> ent : parameters.entrySet()) { java.lang.String name = ent.getKey(); if (!(name.startsWith("-"))) { if ((name.length()) == 1) { name = "-" + name; } else { name = "--" + name; } } if ((findHandler(name)) instanceof org.kohsuke.args4j.spi.BooleanOptionHandler) { boolean on = false; for (java.lang.String value : ent.getValue()) { on = toBoolean(ent.getKey(), value); } if (on) { tmp.add(name); } } else { for (java.lang.String value : ent.getValue()) { if (!(argNames.contains(ent.getKey()))) { tmp.add(name); } tmp.add(value); } } } parser.parseArgument(tmp.toArray(new java.lang.String[tmp.size()])); }
public <T extends com.google.gwt.core.client.JavaScriptObject> void send(final com.google.gwtjsonrpc.common.AsyncCallback<T> cb) { com.google.gwt.http.client.RequestBuilder req = new com.google.gwt.http.client.RequestBuilder(com.google.gwt.http.client.RequestBuilder.GET, url.toString()); req.setHeader("Accept", JsonConstants.JSON_TYPE); req.setCallback(new com.google.gwt.http.client.RequestCallback() { @java.lang.Override public void onResponseReceived(com.google.gwt.http.client.Request req, com.google.gwt.http.client.Response res) { RpcStatus.INSTANCE.onRpcComplete(); int status = res.getStatusCode(); if (status != 200) { if (((400 <= status) && (status < 500)) && (com.google.gerrit.client.rpc.RestApi.isTextBody(res))) { cb.onFailure(new com.google.gwtjsonrpc.client.RemoteJsonException(res.getText(), status, null)); } else { cb.onFailure(new com.google.gwt.user.client.rpc.StatusCodeException(status, res.getStatusText())); } return; } if (!(com.google.gerrit.client.rpc.RestApi.isJsonBody(res))) { cb.onFailure(new com.google.gwtjsonrpc.client.RemoteJsonException("Invalid JSON")); return; } java.lang.String json = res.getText(); if (!(json.startsWith(com.google.gerrit.client.rpc.RestApi.JSON_MAGIC))) { cb.onFailure(new com.google.gwtjsonrpc.client.RemoteJsonException("Invalid JSON")); return; } T data; try { data = com.google.gerrit.client.rpc.Natives.<T>parseJSON(json.substring(com.google.gerrit.client.rpc.RestApi.JSON_MAGIC.length())); } catch (java.lang.RuntimeException e) { cb.onFailure(new com.google.gwtjsonrpc.client.RemoteJsonException("Invalid JSON")); return; } cb.onSuccess(data); } @java.lang.Override public void onError(com.google.gwt.http.client.Request req, java.lang.Throwable err) { RpcStatus.INSTANCE.onRpcComplete(); if (err.getMessage().contains("XmlHttpRequest.status")) { cb.onFailure(new com.google.gwtjsonrpc.client.ServerUnavailableException()); } else { cb.onFailure(err); } } }); try { RpcStatus.INSTANCE.onRpcStart(); req.send(); } catch (com.google.gwt.http.client.RequestException e) { RpcStatus.INSTANCE.onRpcComplete(); cb.onFailure(e); } }








private static void handleError(java.lang.Throwable err, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.lang.String uri = req.getRequestURI(); if (!(com.google.common.base.Strings.isNullOrEmpty(req.getQueryString()))) { uri += "?" + (req.getQueryString()); } com.google.gerrit.httpd.RestApiServlet.log.error(java.lang.String.format("Error in %s %s", req.getMethod(), uri), err); if (!(res.isCommitted())) { res.reset(); res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); com.google.gerrit.httpd.RestApiServlet.noCache(res); com.google.gerrit.httpd.RestApiServlet.sendText(req, res, "Internal Server Error"); } }

@java.lang.Override protected void onInitUI() { super.onInitUI(); setPageTitle(Util.C.projectListTitle()); projects = new com.google.gerrit.client.ui.ProjectsTable() { @java.lang.Override protected void onOpenRow(final int row) { com.google.gwt.user.client.History.newItem(link(getRowItem(row))); } private java.lang.String link(final com.google.gerrit.client.projects.ProjectInfo item) { return com.google.gerrit.client.Dispatcher.toProjectAdmin(item.name_key(), ProjectScreen.INFO); } @java.lang.Override protected void populate(final int row, final com.google.gerrit.client.projects.ProjectInfo k) { table.setWidget(row, 1, new com.google.gerrit.client.ui.Hyperlink(k.name(), link(k))); table.setText(row, 2, k.description()); setRowItem(row, k); } }; projects.setSavePointerId(PageLinks.ADMIN_PROJECTS); add(projects); }

private void setAccount() throws com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException { final com.google.gerrit.reviewdb.client.Account account = db.accounts().get(id); boolean accountUpdated = false; boolean sshKeysUpdated = false; for (java.lang.String email : addEmails) { link(id, email); } for (java.lang.String email : deleteEmails) { deleteMail(id, email); } if ((fullName) != null) { if (realm.allowsEdit(FieldName.FULL_NAME)) { account.setFullName(fullName); } else { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, "The realm doesn't allow editing names"); } } if (active) { accountUpdated = true; account.setActive(true); } else if (inactive) { accountUpdated = true; account.setActive(false); } addSshKeys = readSshKey(addSshKeys); if (!(addSshKeys.isEmpty())) { sshKeysUpdated = true; addSshKeys(addSshKeys, account); } deleteSshKeys = readSshKey(deleteSshKeys); if (!(deleteSshKeys.isEmpty())) { sshKeysUpdated = true; deleteSshKeys(deleteSshKeys, account); } if (accountUpdated) { db.accounts().update(java.util.Collections.singleton(account)); byIdCache.evict(id); } if (sshKeysUpdated) { sshKeyCache.evict(account.getUserName()); } db.close(); }
public void doDraftPublishedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.DraftPublishedEvent event = new com.google.gerrit.server.events.DraftPublishedEvent(); final com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), draftPublishedHook, args); }
public void doChangeAbandonedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final java.lang.String reason, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeAbandonedEvent event = new com.google.gerrit.server.events.ChangeAbandonedEvent(); event.change = eventFactory.asChangeAttribute(change); event.abandoner = eventFactory.asAccountAttribute(account); event.reason = reason; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--abandoner", getDisplayName(account)); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeAbandonedHook, args); }
public void doChangeRestoredHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final java.lang.String reason, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeRestoredEvent event = new com.google.gerrit.server.events.ChangeRestoredEvent(); event.change = eventFactory.asChangeAttribute(change); event.restorer = eventFactory.asAccountAttribute(account); event.reason = reason; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--restorer", getDisplayName(account)); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeRestoredHook, args); }
public void doChangeMergedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeMergedEvent event = new com.google.gerrit.server.events.ChangeMergedEvent(); event.change = eventFactory.asChangeAttribute(change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); runHook(change.getProject(), changeMergedHook, args); }
public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.PatchSetCreatedEvent event = new com.google.gerrit.server.events.PatchSetCreatedEvent(); final com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), patchsetCreatedHook, args); }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { batch.addCommand(cmd); } else { if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) { reject(cmd, "cannot delete project configuration"); } else { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.DELETE, ctl.getRefName()); reject(cmd, "can not delete references"); } } }
public org.eclipse.jgit.lib.Repository openRepository(com.google.gerrit.reviewdb.client.Project.NameKey name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } if (!(names.contains(name))) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(gitDirOf(name)); } final org.eclipse.jgit.lib.RepositoryCache.FileKey loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.lenient(gitDirOf(name), FS.DETECTED); try { return org.eclipse.jgit.lib.RepositoryCache.open(loc); } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot open repository " + name)); e2.initCause(e1); throw e2; } }

private com.google.gerrit.pgm.Init.SiteInit createSiteInit() { final com.google.gerrit.pgm.util.ConsoleUI ui = com.google.gerrit.pgm.util.ConsoleUI.getInstance(batchMode); final java.io.File sitePath = getSitePath(); final java.util.List<java.lang.Module> m = new java.util.ArrayList<java.lang.Module>(); m.add(new com.google.gerrit.pgm.init.InitModule()); m.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); bind(com.google.gerrit.pgm.init.ReloadSiteLibrary.class).toInstance(new com.google.gerrit.pgm.init.ReloadSiteLibrary() { @java.lang.Override public void reload() { com.google.gerrit.pgm.Init.super.loadSiteLib(); } }); } }); try { return com.google.inject.Guice.createInjector(com.google.gerrit.pgm.PRODUCTION, m).getInstance(com.google.gerrit.pgm.Init.SiteInit.class); } catch (com.google.inject.CreationException ce) { final com.google.inject.spi.Message first = ce.getErrorMessages().iterator().next(); java.lang.Throwable why = first.getCause(); if (why instanceof com.google.gerrit.pgm.util.Die) { throw ((com.google.gerrit.pgm.util.Die) (why)); } final java.lang.StringBuilder buf = new java.lang.StringBuilder(); while (why != null) { buf.append(why.getMessage()); why = why.getCause(); if (why != null) { buf.append("\n caused by "); } } throw die(buf.toString(), new java.lang.RuntimeException("InitInjector failed", ce)); } }
@java.lang.Override public int hashCode() { int h = 0; h = (h * 31) + (aId.hashCode()); h = (h * 31) + (bId.hashCode()); return h; }
@java.lang.Override public boolean equals(final java.lang.Object o) { if (o instanceof com.google.gerrit.server.patch.IntraLineDiffKey) { final com.google.gerrit.server.patch.IntraLineDiffKey k = ((com.google.gerrit.server.patch.IntraLineDiffKey) (o)); return (aId.equals(k.aId)) && (bId.equals(k.bId)); } return false; }







java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> sort(final java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> incoming) throws java.io.IOException { final java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> heads = new java.util.HashSet<com.google.gerrit.server.git.CodeReviewCommit>(); final java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> sort = new java.util.HashSet<com.google.gerrit.server.git.CodeReviewCommit>(incoming); while (!(sort.isEmpty())) { final com.google.gerrit.server.git.CodeReviewCommit n = com.google.gerrit.server.git.MergeSorter.removeOne(sort); rw.resetRetain(CAN_MERGE); rw.markStart(n); for (org.eclipse.jgit.revwalk.RevCommit c : accepted) { rw.markUninteresting(c); } org.eclipse.jgit.revwalk.RevCommit c; final org.eclipse.jgit.revwalk.RevCommitList<org.eclipse.jgit.revwalk.RevCommit> contents = new org.eclipse.jgit.revwalk.RevCommitList<org.eclipse.jgit.revwalk.RevCommit>(); while ((c = rw.next()) != null) { if (!(c.has(CAN_MERGE))) { if ((n.missing) == null) { n.statusCode = CommitMergeStatus.MISSING_DEPENDENCY; n.missing = new java.util.ArrayList<com.google.gerrit.server.git.CodeReviewCommit>(); } n.missing.add(((com.google.gerrit.server.git.CodeReviewCommit) (c))); } else { contents.add(c); } } if ((n.statusCode) == (CommitMergeStatus.MISSING_DEPENDENCY)) { continue; } sort.removeAll(contents); heads.removeAll(contents); heads.add(n); } return heads; }
private void preMerge() throws com.google.gerrit.server.git.MergeException { final com.google.gerrit.server.git.SubmitStrategy strategy = createStrategy(); mergeTip = strategy.run(branchTip, toMerge); refLogIdent = strategy.getRefLogIdent(); commits.putAll(strategy.getNewCommits()); }
public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gerrit.client.Gerrit.myConfig = result.config; com.google.gerrit.client.Gerrit.myTheme = result.theme; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.xsrfToken = result.xsrfToken; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } onModuleLoad2(); }
@com.google.gwtjsonrpc.common.HostPageCache(name = "gerrit_hostpagedata", once = true) void load(com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.HostPageData> callback);
private void recursivelyExpandGroups(final java.util.Set<java.lang.String> groupDNs, final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema, final javax.naming.directory.DirContext ctx, final java.lang.String groupDN) { if ((groupDNs.add(groupDN)) && ((schema.accountMemberField) != null)) { try { final javax.naming.Name compositeGroupName = new javax.naming.CompositeName().add(groupDN); final javax.naming.directory.Attribute in = ctx.getAttributes(compositeGroupName).get(schema.accountMemberField); if (in != null) { final javax.naming.NamingEnumeration<?> groups = in.getAll(); try { while (groups.hasMore()) { final java.lang.String nextDN = ((java.lang.String) (groups.next())); recursivelyExpandGroups(groupDNs, schema, ctx, nextDN); } } catch (javax.naming.PartialResultException e) { } } } catch (javax.naming.NamingException e) { LdapRealm.log.warn(("Could not find group " + groupDN), e); } } }
@java.lang.Override protected void configure() { cache(com.google.gerrit.server.auth.ldap.LdapModule.GROUP_CACHE, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).expireAfterWrite(1, java.util.concurrent.TimeUnit.HOURS).loader(LdapRealm.MemberLoader.class); cache(com.google.gerrit.server.auth.ldap.LdapModule.USERNAME_CACHE, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.base.Optional<com.google.gerrit.reviewdb.client.Account.Id>>() {}).loader(LdapRealm.UserLoader.class); cache(com.google.gerrit.server.auth.ldap.LdapModule.GROUP_EXIST_CACHE, java.lang.String.class, new com.google.inject.TypeLiteral<java.lang.Boolean>() {}).expireAfterWrite(1, java.util.concurrent.TimeUnit.HOURS).loader(LdapRealm.ExistenceLoader.class); bind(com.google.gerrit.server.account.Realm.class).to(com.google.gerrit.server.auth.ldap.LdapRealm.class).in(Scopes.SINGLETON); bind(com.google.gerrit.server.auth.ldap.Helper.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.auth.ldap.LdapGroupBackend.class); }








private java.lang.String getFixedCommitMsgWithChangeId(java.lang.String errMsg, org.eclipse.jgit.revwalk.RevCommit c) { final java.lang.String changeId = "Change-Id:"; java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("ERROR: ").append(errMsg); sb.append("\n"); sb.append("Suggestion for commit message:\n"); if ((c.getFullMessage().indexOf(changeId)) == (-1)) { sb.append(c.getFullMessage()); sb.append("\n"); sb.append(changeId).append(" I").append(c.name()); } else { java.lang.String[] lines = c.getFullMessage().trim().split("\n"); java.lang.String lastLine = ((lines.length) > 0) ? lines[((lines.length) - 1)] : ""; if ((lastLine.indexOf(changeId)) == 0) { for (int i = 0; i < ((lines.length) - 1); i++) { sb.append(lines[i]); sb.append("\n"); } sb.append("\n"); sb.append(lastLine); } else { sb.append(c.getFullMessage()); sb.append("\n"); sb.append(changeId).append(" I").append(c.name()); sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message."); } } return sb.toString(); }









public void create(final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { final com.google.gwtorm.jdbc.JdbcSchema jdbc = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); final com.google.gwtorm.jdbc.JdbcExecutor e = new com.google.gwtorm.jdbc.JdbcExecutor(jdbc); try { jdbc.updateSchema(e); } finally { e.close(); } final com.google.gerrit.reviewdb.client.CurrentSchemaVersion sVer = com.google.gerrit.reviewdb.client.CurrentSchemaVersion.create(); sVer.versionNbr = versionNbr; db.schemaVersion().insert(java.util.Collections.singleton(sVer)); final com.google.gerrit.reviewdb.client.SystemConfig sConfig = initSystemConfig(db); initVerifiedCategory(db); initCodeReviewCategory(db, sConfig); if ((mgr) != null) { initWildCardProject(); } final com.google.gwtorm.schema.sql.SqlDialect d = jdbc.getDialect(); if (d instanceof com.google.gwtorm.schema.sql.DialectH2) { index_generic.run(db); } else if (d instanceof com.google.gwtorm.schema.sql.DialectMySQL) { index_generic.run(db); mysql_nextval.run(db); } else if (d instanceof com.google.gwtorm.schema.sql.DialectPostgreSQL) { index_postgres.run(db); } else { throw new com.google.gwtorm.server.OrmException(("Unsupported database " + (d.getClass().getName()))); } }



@java.lang.Override protected void configure() { bind(com.google.gerrit.server.plugins.ServerInformationImpl.class); bind(com.google.gerrit.extensions.systemstatus.ServerInformation.class).to(com.google.gerrit.server.plugins.ServerInformationImpl.class); bind(com.google.gerrit.server.plugins.PluginCleanerTask.class); bind(com.google.gerrit.server.plugins.PluginGuiceEnvironment.class); bind(com.google.gerrit.server.plugins.PluginLoader.class); bind(com.google.gerrit.server.plugins.CopyConfigModule.class); listener().to(com.google.gerrit.server.plugins.PluginLoader.class); }


private com.google.gerrit.server.plugins.Plugin runPlugin(java.lang.String name, java.io.File jar, com.google.gerrit.server.plugins.Plugin oldPlugin) throws com.google.gerrit.server.plugins.PluginInstallException { org.eclipse.jgit.storage.file.FileSnapshot snapshot = org.eclipse.jgit.storage.file.FileSnapshot.save(jar); try { com.google.gerrit.server.plugins.Plugin newPlugin = loadPlugin(name, jar, snapshot); boolean reload = ((oldPlugin != null) && (oldPlugin.canReload())) && (newPlugin.canReload()); if ((!reload) && (oldPlugin != null)) { oldPlugin.stop(); running.remove(name); } if (!(newPlugin.isDisabled())) { newPlugin.start(env); } if (reload) { env.onReloadPlugin(oldPlugin, newPlugin); oldPlugin.stop(); } else if (!(newPlugin.isDisabled())) { env.onStartPlugin(newPlugin); } if (!(newPlugin.isDisabled())) { running.put(name, newPlugin); } else { disabled.put(name, newPlugin); } broken.remove(name); return newPlugin; } catch (java.lang.Throwable err) { broken.put(name, snapshot); throw new com.google.gerrit.server.plugins.PluginInstallException(err); } }
public void stop() { if ((manager) != null) { manager.stop(); manager = null; sysInjector = null; sshInjector = null; httpInjector = null; } }
private static void addDiffLink(final com.google.gerrit.client.ui.LinkMenuBar m, final java.lang.String text, final com.google.gerrit.client.patches.PatchScreen.Type type) { m.addItem(new com.google.gerrit.client.ui.LinkMenuItem(text, "") { @java.lang.Override public void go() { if ((com.google.gerrit.client.Gerrit.patchScreen) != null) { com.google.gerrit.client.Gerrit.patchScreen.setTopView(PatchScreen.TopView.MAIN); if (type == (com.google.gerrit.client.Gerrit.patchScreen.getPatchScreenType())) { com.google.gwt.dom.client.AnchorElement.as(getElement()).blur(); } else { new com.google.gerrit.client.ui.PatchLink("", type, com.google.gerrit.client.Gerrit.patchScreen).go(); } } } }); }
private static void addDiffLink(final com.google.gerrit.client.ui.LinkMenuBar m, final java.lang.String text, final com.google.gerrit.client.patches.PatchScreen.TopView tv) { m.addItem(new com.google.gerrit.client.ui.LinkMenuItem(text, "") { @java.lang.Override public void go() { if ((com.google.gerrit.client.Gerrit.patchScreen) != null) { com.google.gerrit.client.Gerrit.patchScreen.setTopView(tv); } com.google.gwt.dom.client.AnchorElement.as(getElement()).blur(); } }); }

public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gerrit.client.Gerrit.myConfig = result.config; com.google.gerrit.client.Gerrit.myTheme = result.theme; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.xsrfToken = result.xsrfToken; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } onModuleLoad2(); }


private static com.googlecode.prolog_cafe.lang.BufferingPrologControl newEmptyMachine(java.lang.ClassLoader cl) { com.googlecode.prolog_cafe.lang.BufferingPrologControl ctl = new com.googlecode.prolog_cafe.lang.BufferingPrologControl(); ctl.setMaxArity(PrologEnvironment.MAX_ARITY); ctl.setMaxDatabaseSize(com.google.gerrit.rules.RulesCache.DB_MAX); ctl.setPrologClassLoader(new com.googlecode.prolog_cafe.lang.PrologClassLoader(cl)); ctl.setEnabled(java.util.EnumSet.allOf(Prolog.Feature.class), false); ctl.initialize(com.google.gerrit.rules.RulesCache.PACKAGE_LIST); return ctl; }




private void appendLineText(final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m, boolean syntaxHighlighting, final com.google.gerrit.client.patches.PatchLine.Type type, final com.google.gerrit.prettify.common.SparseHtmlFile src, final int i) { final com.google.gwtexpui.safehtml.client.SafeHtml text = src.getSafeHtmlLine(i); m.openTd(); m.addStyleName(Gerrit.RESOURCES.css().diffText()); switch (type) { case Type.CONTEXT : m.addStyleName(Gerrit.RESOURCES.css().diffTextCONTEXT()); m.nbsp(); m.append(text); break; case Type.DELETE : m.addStyleName(Gerrit.RESOURCES.css().diffTextDELETE()); if (syntaxHighlighting) { m.addStyleName(Gerrit.RESOURCES.css().fileLineDELETE()); } m.append("-"); m.append(text); break; case Type.INSERT : m.addStyleName(Gerrit.RESOURCES.css().diffTextINSERT()); if (syntaxHighlighting) { m.addStyleName(Gerrit.RESOURCES.css().fileLineINSERT()); } m.append("+"); m.append(text); break; } m.closeTd(); }

void display(final com.google.gerrit.common.data.ProjectDetail result) { project = result.project; final boolean isall = com.google.gerrit.client.Gerrit.getConfig().getWildProject().equals(project.getNameKey()); projectOptionsPanel.setVisible((!isall)); agreementsPanel.setVisible((!isall)); useContributorAgreements.setVisible(com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()); descTxt.setText(project.getDescription()); useContributorAgreements.setValue(project.isUseContributorAgreements()); useSignedOffBy.setValue(project.isUseSignedOffBy()); useContentMerge.setValue(project.isUseContentMerge()); requireChangeID.setValue(project.isRequireChangeID()); setSubmitType(project.getSubmitType()); setState(project.getState()); saveProject.setEnabled(false); }
private void initAgreements() { agreementsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); agreementsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingAgreements())); useContributorAgreements = new com.google.gwt.user.client.ui.CheckBox(Util.C.useContributorAgreements()); saveEnabler.listenTo(useContributorAgreements); agreementsPanel.add(useContributorAgreements); useSignedOffBy = new com.google.gwt.user.client.ui.CheckBox(Util.C.useSignedOffBy(), true); saveEnabler.listenTo(useSignedOffBy); agreementsPanel.add(useSignedOffBy); add(agreementsPanel); }




protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (1 <= line) { final com.google.gerrit.reviewdb.client.Patch.Key parentKey; final short side; switch (file) { case 0 : if ((idSideA) == null) { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (0)); } else { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); side = ((short) (1)); } break; case 1 : parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (1)); break; default : throw new java.lang.RuntimeException(("unexpected file id " + file)); } final com.google.gerrit.reviewdb.client.PatchLineComment newComment = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(parentKey, null), line, com.google.gerrit.client.Gerrit.getUserAccount().getId(), null); newComment.setSide(side); newComment.setMessage(""); createCommentEditor(suggestRow, column, newComment).setFocus(true); } } else { com.google.gerrit.client.Gerrit.doSignIn(com.google.gwt.user.client.History.getToken()); } }
public void onSuccess(final com.google.gerrit.reviewdb.client.PatchLineComment result) { enableButtons(true); notifyDraftDelta(1); createEditor(result).setOpen(false); }
private com.google.gerrit.client.patches.CommentEditorPanel createEditor(final com.google.gerrit.reviewdb.client.PatchLineComment newComment) { int row = rowOf(getElement()); int column = columnOf(getElement()); return createCommentEditor((row + 1), column, newComment); }
private void cannedReply(java.lang.String message) { final com.google.gerrit.reviewdb.client.PatchLineComment newComment = newComment(); newComment.setMessage(message); com.google.gerrit.client.patches.CommentEditorPanel p = createEditor(newComment); if (p == null) { enableButtons(false); PatchUtil.DETAIL_SVC.saveDraft(newComment, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.PatchLineComment>() { public void onSuccess(final com.google.gerrit.reviewdb.client.PatchLineComment result) { enableButtons(true); notifyDraftDelta(1); createEditor(result).setOpen(false); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } else { if (!(p.isOpen())) { p.setOpen(true); } p.setFocus(true); } }
private void createReplyEditor() { final com.google.gerrit.reviewdb.client.PatchLineComment newComment = newComment(); newComment.setMessage(""); createEditor(newComment).setFocus(true); }

protected void bccWatches(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) { try { com.google.gerrit.server.mail.ChangeEmail.Watchers matching = getWatches(type); for (com.google.gerrit.reviewdb.client.Account.Id user : matching.accounts) { add(RecipientType.BCC, user); } for (com.google.gerrit.server.mail.Address addr : matching.emails) { add(RecipientType.BCC, addr); } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn(("Cannot BCC watchers for " + type), err); } }




private void addMessage(java.lang.String message) { messages.add(new com.google.gerrit.server.git.ReceiveCommits.Message(message, false)); }
void addError(java.lang.String error) { messages.add(new com.google.gerrit.server.git.ReceiveCommits.Message(error, true)); }
@java.lang.Override public void configure() { install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(com.google.gerrit.server.git.AsyncReceiveCommits.Factory.class)); expose(com.google.gerrit.server.git.AsyncReceiveCommits.Factory.class); install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(ReceiveCommits.Factory.class)); }
private void reject(final org.eclipse.jgit.transport.ReceiveCommand cmd, final java.lang.String why) { cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why); commandProgress.update(1); }





private java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> loadDashboards(final com.google.gerrit.reviewdb.client.Project.NameKey projectName, final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.revwalk.RevWalk revWalk, final org.eclipse.jgit.lib.Ref ref) throws java.io.IOException { final java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> output = com.google.common.collect.Maps.newTreeMap(); final org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit(ref.getObjectId()); final org.eclipse.jgit.revwalk.RevTree tree = commit.getTree(); org.eclipse.jgit.treewalk.TreeWalk treeWalk = new org.eclipse.jgit.treewalk.TreeWalk(repo); try { treeWalk.addTree(tree); treeWalk.setRecursive(true); while (treeWalk.next()) { com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo info = new com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo(); info.name = treeWalk.getPathString(); info.refName = ref.getName(); info.projectName = projectName.get(); info.id = com.google.gerrit.server.dashboard.ListDashboards.createId(info.refName, info.name); final org.eclipse.jgit.lib.ObjectLoader loader = repo.open(treeWalk.getObjectId(0)); java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); loader.copyTo(out); org.eclipse.jgit.lib.Config dashboardConfig = new org.eclipse.jgit.lib.Config(); try { dashboardConfig.fromText(new java.lang.String(out.toByteArray(), "UTF-8")); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.dashboard.ListDashboards.log.warn("Failed to load dashboards", e); } info.description = dashboardConfig.getString("main", null, "description"); final java.lang.StringBuilder query = new java.lang.StringBuilder(); query.append("title="); query.append(info.name.replaceAll(" ", "+")); final java.util.Set<java.lang.String> sections = dashboardConfig.getSubsections("section"); for (final java.lang.String section : sections) { query.append("&"); query.append(section.replaceAll(" ", "+")); query.append("="); query.append(dashboardConfig.getString("section", section, "query")); } info.parameters = query.toString(); output.put(info.id, info); } } finally { treeWalk.release(); } return output; }
private java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> projectDashboards(final com.google.gerrit.reviewdb.client.Project.NameKey projectName) { final java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> output = com.google.common.collect.Maps.newTreeMap(); final com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); final com.google.gerrit.server.project.ProjectControl projectControl = projectState.controlFor(currentUser); if ((projectState == null) || (!(projectControl.isVisible()))) { return output; } org.eclipse.jgit.lib.Repository repo = null; org.eclipse.jgit.revwalk.RevWalk revWalk = null; try { repo = repoManager.openRepository(projectName); final java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.dashboard.ListDashboards.REFS_DASHBOARDS); for (final org.eclipse.jgit.lib.Ref ref : refs.values()) { if (projectControl.controlForRef(ref.getName()).canRead()) { revWalk = new org.eclipse.jgit.revwalk.RevWalk(repo); output.putAll(loadDashboards(projectName, repo, revWalk, ref)); } } } catch (java.io.IOException e) { com.google.gerrit.server.dashboard.ListDashboards.log.warn("Failed to load dashboards", e); } finally { if (revWalk != null) { revWalk.release(); } if (repo != null) { repo.close(); } } return output; }
public void display(java.io.OutputStream out) { final java.io.PrintWriter stdout; try { stdout = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.OutputStreamWriter(out, "UTF-8"))); } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.RuntimeException("JVM lacks UTF-8 encoding", e); } try { final java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> output; if ((level) != null) { switch (level) { case PROJECT : output = projectDashboards(new com.google.gerrit.reviewdb.client.Project.NameKey(entityName)); break; default : throw new java.lang.IllegalStateException(("unsupported dashboard level: " + (level))); } } else { output = com.google.common.collect.Maps.newTreeMap(); } format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo>>() {}.getType(), stdout); stdout.print('\n'); } finally { stdout.flush(); } }


private com.google.gerrit.client.ui.Screen selectProject() { if (com.google.gerrit.client.Dispatcher.matchPrefix("/admin/projects/", token)) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); int c = rest.lastIndexOf(','); if (c < 0) { return new com.google.gerrit.client.admin.ProjectInfoScreen(Project.NameKey.parse(rest)); } else if (c == 0) { return new com.google.gerrit.client.NotFoundScreen(); } com.google.gerrit.reviewdb.client.Project.NameKey k = Project.NameKey.parse(rest.substring(0, c)); java.lang.String panel = rest.substring((c + 1)); if (ProjectScreen.INFO.equals(panel)) { return new com.google.gerrit.client.admin.ProjectInfoScreen(k); } if (ProjectScreen.BRANCH.equals(panel)) { return new com.google.gerrit.client.admin.ProjectBranchesScreen(k); } if (ProjectScreen.ACCESS.equals(panel)) { return new com.google.gerrit.client.admin.ProjectAccessScreen(k); } } return new com.google.gerrit.client.NotFoundScreen(); }
protected void initColumnHeaders() { table.setText(0, 1, Util.C.dashboardName()); table.setText(0, 2, Util.C.dashboardDescription()); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().dataHeader()); fmt.addStyleName(0, 2, Gerrit.RESOURCES.css().dataHeader()); }
protected void populate(final int row, final com.google.gerrit.client.dashboards.DashboardInfo k) { table.setWidget(row, 1, new com.google.gwt.user.client.ui.Anchor(k.name(), ("#" + (link(k))))); table.setText(row, 2, k.description()); setRowItem(row, k); }


public <T extends com.google.gwt.core.client.JavaScriptObject> void send(final com.google.gwtjsonrpc.common.AsyncCallback<T> cb) { com.google.gwt.http.client.RequestBuilder req = new com.google.gwt.http.client.RequestBuilder(com.google.gwt.http.client.RequestBuilder.GET, url.toString()); req.setHeader("Accept", JsonConstants.JSON_TYPE); if ((com.google.gerrit.client.Gerrit.getAccessToken()) != null) { req.setHeader("Authorization", ("OAuth " + (com.google.gerrit.client.Gerrit.getAccessToken()))); } req.setCallback(new com.google.gerrit.client.rpc.RestApi.MyRequestCallback<T>(cb)); try { RpcStatus.INSTANCE.onRpcStart(); req.send(); } catch (com.google.gwt.http.client.RequestException e) { RpcStatus.INSTANCE.onRpcComplete(); cb.onFailure(e); } }





public void display(java.io.OutputStream out) { final java.io.PrintWriter stdout; try { stdout = new java.io.PrintWriter(new java.io.BufferedWriter(new java.io.OutputStreamWriter(out, "UTF-8"))); } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.RuntimeException("JVM lacks UTF-8 encoding", e); } try { final java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> output; if ((level) != null) { switch (level) { case PROJECT : output = projectDashboards(new com.google.gerrit.reviewdb.client.Project.NameKey(entityName)); break; default : throw new java.lang.IllegalStateException(("unsupported dashboard level: " + (level))); } } else { output = com.google.common.collect.Maps.newTreeMap(); } format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo>>() {}.getType(), stdout); stdout.print('\n'); } finally { stdout.flush(); } }
private java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> projectDashboards(final com.google.gerrit.reviewdb.client.Project.NameKey projectName) { final java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> output = com.google.common.collect.Maps.newTreeMap(); final com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); final com.google.gerrit.server.project.ProjectControl projectControl = projectState.controlFor(currentUser); if ((projectState == null) || (!(projectControl.isVisible()))) { return output; } org.eclipse.jgit.lib.Repository repo = null; org.eclipse.jgit.revwalk.RevWalk revWalk = null; try { repo = repoManager.openRepository(projectName); final java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.dashboard.ListDashboards.REFS_DASHBOARDS); for (final org.eclipse.jgit.lib.Ref ref : refs.values()) { if (projectControl.controlForRef(ref.getName()).canRead()) { revWalk = new org.eclipse.jgit.revwalk.RevWalk(repo); output.putAll(loadDashboards(repo, revWalk, ref)); } } } catch (java.io.IOException e) { com.google.gerrit.server.dashboard.ListDashboards.log.warn("Failed to load dashboards", e); } finally { if (revWalk != null) { revWalk.release(); } if (repo != null) { repo.close(); } } return output; }
private java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> allDashboardsFor(final com.google.gerrit.reviewdb.client.Project.NameKey projectName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); com.google.gerrit.reviewdb.client.Project.NameKey parent; java.util.Map<java.lang.String, com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo> dashboards = com.google.common.collect.Maps.newTreeMap(); java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> seen = new java.util.HashSet<com.google.gerrit.reviewdb.client.Project.NameKey>(); seen.add(projectName); do { dashboards = addProjectDashboards(projectState, dashboards); parent = projectState.getProject().getParent(); if ((parent == null) || (!(seen.add(parent)))) { break; } projectState = projectCache.get(parent); } while (projectState != null ); projectState = projectCache.getAllProjects(); parent = projectState.getProject().getNameKey(); if (seen.add(parent)) { dashboards = addProjectDashboards(projectState, dashboards); } return dashboards; }
protected void populate(final int row, final com.google.gerrit.client.dashboards.DashboardInfo k) { if (k.isDefault()) { table.setWidget(row, 1, new com.google.gwt.user.client.ui.Image(Gerrit.RESOURCES.greenCheck())); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.getElement(row, 1).setTitle(Util.C.dashboardDefaultToolTip()); } table.setWidget(row, 2, new com.google.gwt.user.client.ui.Anchor(k.name(), ("#" + (link(k))))); table.setText(row, 3, k.description()); setRowItem(row, k); }
public <T> boolean parse(T param, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { return parse(param, req, res, java.util.Collections.<java.lang.String>emptySet()); }
public <T> boolean parse(T param, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, java.util.Set<java.lang.String> argNames) throws java.io.IOException { com.google.gerrit.util.cli.CmdLineParser clp = parserFactory.create(param); try { @java.lang.SuppressWarnings("unchecked") java.util.Map<java.lang.String, java.lang.String[]> parameterMap = req.getParameterMap(); clp.parseOptionMap(parameterMap, argNames); } catch (org.kohsuke.args4j.CmdLineException e) { if (!(clp.wasHelpRequestedByOption())) { res.setStatus(HttpServletResponse.SC_BAD_REQUEST); com.google.gerrit.httpd.RestApiServlet.sendText(req, res, e.getMessage()); return false; } } if (clp.wasHelpRequestedByOption()) { java.io.StringWriter msg = new java.io.StringWriter(); clp.printQueryStringUsage(req.getRequestURI(), msg); msg.write('\n'); msg.write('\n'); clp.printUsage(msg, null); msg.write('\n'); com.google.gerrit.httpd.RestApiServlet.sendText(req, res, msg.toString()); return false; } return true; }
public void login(final com.google.gerrit.server.account.AuthResult res, final boolean rememberMe) { final com.google.gerrit.reviewdb.client.Account.Id id = res.getAccountId(); final com.google.gerrit.reviewdb.client.AccountExternalId.Key identity = res.getExternalId(); if ((val) != null) { manager.destroy(key); } key = manager.createKey(id); val = manager.createVal(key, id, rememberMe, identity); saveCookie(); }

public void setUserAccountId(com.google.gerrit.reviewdb.client.Account.Id id) { key = new com.google.gerrit.httpd.WebSessionManager.Key(("id:" + id)); val = new com.google.gerrit.httpd.WebSessionManager.Val(id, 0, false, null, 0); }

@java.lang.Override public void run() { c.close(); }
@java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb get() { final com.google.gerrit.reviewdb.server.ReviewDb c; try { c = schema.open(); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.inject.ProvisionException("Cannot open ReviewDb", e); } try { cleanup.get().add(new java.lang.Runnable() { @java.lang.Override public void run() { c.close(); } }); return c; } catch (java.lang.Error e) { c.close(); throw e; } catch (java.lang.RuntimeException e) { c.close(); throw e; } }
com.google.gerrit.sshd.SshScope.Context set(com.google.gerrit.sshd.SshScope.Context ctx) { com.google.gerrit.sshd.SshScope.Context old = com.google.gerrit.sshd.SshScope.current.get(); com.google.gerrit.sshd.SshScope.current.set(ctx); local.setContext(ctx); return old; }
@java.lang.Override public T call() throws java.lang.Exception { com.google.gerrit.server.util.RequestContext old = local.setContext(context); try { return callable.call(); } finally { local.setContext(old); } }
public static java.lang.Module module() { return new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.server.util.ThreadLocalRequestContext.class); bind(com.google.gerrit.server.util.RequestContext.class).annotatedWith(com.google.inject.name.Names.named(com.google.gerrit.server.util.ThreadLocalRequestContext.FALLBACK)).to(com.google.gerrit.server.util.FallbackRequestContext.class); } @com.google.inject.Provides com.google.gerrit.server.util.RequestContext provideRequestContext(@com.google.inject.name.Named(com.google.gerrit.server.util.ThreadLocalRequestContext.FALLBACK) com.google.gerrit.server.util.RequestContext fallback) { return com.google.common.base.Objects.firstNonNull(com.google.gerrit.server.util.ThreadLocalRequestContext.local.get(), fallback); } @com.google.inject.Provides com.google.gerrit.server.CurrentUser provideCurrentUser(com.google.gerrit.server.util.RequestContext ctx) { return ctx.getCurrentUser(); } @com.google.inject.Provides com.google.gerrit.server.IdentifiedUser provideCurrentUser(com.google.gerrit.server.CurrentUser user) { if (user instanceof com.google.gerrit.server.IdentifiedUser) { return ((com.google.gerrit.server.IdentifiedUser) (user)); } throw new com.google.inject.ProvisionException(com.google.gerrit.common.errors.NotSignedInException.MESSAGE, new com.google.gerrit.common.errors.NotSignedInException()); } }; }
protected <T> java.util.concurrent.Callable<T> context(final com.google.gerrit.server.util.RequestContext context, final java.util.concurrent.Callable<T> callable) { return new java.util.concurrent.Callable<T>() { @java.lang.Override public T call() throws java.lang.Exception { com.google.gerrit.server.util.RequestContext old = local.setContext(context); try { return callable.call(); } finally { local.setContext(old); } } }; }
private void openSchema() throws com.google.gwtorm.server.OrmException { if ((db) == null) { db = schemaFactory.open(); } }
@java.lang.Override public void doFilter(final javax.servlet.ServletRequest request, final javax.servlet.ServletResponse response, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.util.RequestContext old = local.setContext(requestContext.get()); try { try { chain.doFilter(request, response); } finally { cleanup.get().run(); } } finally { local.setContext(old); } }



public void query(java.io.Writer out) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException, java.io.IOException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } java.util.List<java.util.List<com.google.gerrit.server.query.change.ListChanges.ChangeInfo>> res = com.google.common.collect.Lists.newArrayListWithCapacity(queries.size()); for (java.lang.String query : queries) { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = imp.queryChanges(query); boolean moreChanges = ((imp.getLimit()) > 0) && ((changes.size()) > (imp.getLimit())); if (moreChanges) { if (reverse) { changes = changes.subList(1, changes.size()); } else { changes = changes.subList(0, imp.getLimit()); } } com.google.gerrit.server.query.change.ChangeData.ensureChangeLoaded(db, changes); com.google.gerrit.server.query.change.ChangeData.ensureCurrentPatchSetLoaded(db, changes); com.google.gerrit.server.query.change.ChangeData.ensureCurrentApprovalsLoaded(db, changes); java.util.List<com.google.gerrit.server.query.change.ListChanges.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { info.add(toChangeInfo(cd)); } if (moreChanges && (!(info.isEmpty()))) { if (reverse) { info.get(0)._moreChanges = true; } else { info.get(((info.size()) - 1))._moreChanges = true; } } res.add(info); } if (!(accounts.isEmpty())) { for (com.google.gerrit.reviewdb.client.Account account : db.get().accounts().get(accounts.keySet())) { com.google.gerrit.server.events.AccountAttribute a = accounts.get(account.getId()); a.name = com.google.common.base.Strings.emptyToNull(account.getFullName()); } } if (format.isJson()) { format.newGson().toJson(((res.size()) == 1 ? res.get(0) : res), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.server.query.change.ListChanges.ChangeInfo>>() {}.getType(), out); out.write('\n'); } else { boolean firstQuery = true; for (java.util.List<com.google.gerrit.server.query.change.ListChanges.ChangeInfo> info : res) { if (firstQuery) { firstQuery = false; } else { out.write('\n'); } for (com.google.gerrit.server.query.change.ListChanges.ChangeInfo c : info) { java.lang.String id = new com.google.gerrit.reviewdb.client.Change.Key(c.changeId).abbreviate(); java.lang.String subject = c.subject; if (((subject.length()) + (id.length())) > 80) { subject = subject.substring(0, (80 - (id.length()))); } out.write(id); out.write(' '); out.write(subject.replace('\n', ' ')); out.write('\n'); } } } }




private com.google.gwt.user.client.ui.Anchor createDownloadLink() { boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName()); if ((isCommitMessage || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) && (0 >= (script.getA().size())))) || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.B)) && (0 >= (script.getB().size())))) { return null; } com.google.gerrit.reviewdb.client.Patch.Key key = ((idSideA) == null) ? patchKey : new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); java.lang.String sideURL = ((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) ? "1" : "0"; final java.lang.String base = (com.google.gwt.core.client.GWT.getHostPageBaseURL()) + "cat/"; com.google.gwt.user.client.ui.Image image = new com.google.gwt.user.client.ui.Image(Gerrit.RESOURCES.downloadIcon()); final com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(); anchor.setHref((((base + (com.google.gwtorm.client.KeyUtil.encode(key.toString()))) + "^") + sideURL)); anchor.setTitle(PatchUtil.C.download()); anchor.setStyleName(style.downloadLink()); com.google.gwt.user.client.DOM.insertBefore(anchor.getElement(), image.getElement(), com.google.gwt.user.client.DOM.getFirstChild(anchor.getElement())); return anchor; }




protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (1 <= line) { final com.google.gerrit.reviewdb.client.Patch.Key parentKey; final short side; switch (file) { case 0 : if ((idSideA) == null) { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (0)); } else { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); side = ((short) (1)); } break; case 1 : parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (1)); break; default : throw new java.lang.RuntimeException(("unexpected file id " + file)); } final com.google.gerrit.reviewdb.client.PatchLineComment newComment = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(parentKey, null), line, com.google.gerrit.client.Gerrit.getUserAccount().getId(), null); newComment.setSide(side); newComment.setMessage(""); createCommentEditor(suggestRow, column, newComment).setFocus(true); } } else { com.google.gerrit.client.Gerrit.doSignIn(com.google.gwt.user.client.History.getToken()); } }







private void populateTableHeader(final com.google.gerrit.common.data.PatchScript script, final com.google.gerrit.common.data.PatchSetDetail detail) { prepareHeaderWidgets(script, detail); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.SideBySideTable.A, psListOfHeaderA); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.SideBySideTable.B, psListOfHeaderB); }
protected void prepareHeaderWidgets(com.google.gerrit.common.data.PatchScript script, com.google.gerrit.common.data.PatchSetDetail detail) { initPatchSetListForTableHeader(); psListOfHeaderA.display(detail, script, patchKey, idSideA, idSideB); psListOfHeaderB.display(detail, script, patchKey, idSideA, idSideB); }
@java.lang.Override void createFileCommentEitorOnSideB() { }
private void populateTableHeader(final com.google.gerrit.common.data.PatchScript script, final com.google.gerrit.common.data.PatchSetDetail detail) { prepareHeaderWidgets(script, detail); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.UnifiedDiffTable.PC, psListOfHeaderA); table.setWidget(rowOfTableHeaderB, com.google.gerrit.client.patches.UnifiedDiffTable.PC, psListOfHeaderB); table.getFlexCellFormatter().addStyleName(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.UnifiedDiffTable.PC, Gerrit.RESOURCES.css().unifiedTableHeader()); table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, com.google.gerrit.client.patches.UnifiedDiffTable.PC, Gerrit.RESOURCES.css().unifiedTableHeader()); }
@java.lang.Override void createFileCommentEitorOnSideA() { }



private com.google.gwt.user.client.ui.Widget createSearchLink(java.lang.String projectName) { com.google.gwt.user.client.ui.Image image = new com.google.gwt.user.client.ui.Image(Gerrit.RESOURCES.queryProjectLink()); com.google.gerrit.client.ui.InlineHyperlink h = new com.google.gerrit.client.ui.InlineHyperlink(" ", com.google.gerrit.common.PageLinks.toChangeQuery(("project:" + projectName))); h.setTitle(Util.C.projectListQueryLink()); com.google.gwt.user.client.DOM.insertBefore(h.getElement(), image.getElement(), com.google.gwt.user.client.DOM.getFirstChild(h.getElement())); return h; }




private void destroyEditor(final int row, final int col) { table.clearCell(row, col); final int span = table.getFlexCellFormatter().getRowSpan(row, col); boolean removeRow = true; final int nCells = table.getCellCount(row); for (int cell = 0; cell < nCells; cell++) { if ((table.getWidget(row, cell)) != null) { removeRow = false; break; } } if (removeRow) { for (int r = row - 1; 0 <= r; r--) { boolean data = false; for (int c = 0; c < (table.getCellCount(r)); c++) { data |= (table.getWidget(r, c)) != null; final int s = (table.getFlexCellFormatter().getRowSpan(r, c)) - 1; if ((r + s) == row) { table.getFlexCellFormatter().setRowSpan(r, c, s); } } if (!data) { break; } } table.removeRow(row); } else { table.getFlexCellFormatter().setStyleName(row, col, Gerrit.RESOURCES.css().diffText()); if (span != 1) { table.getFlexCellFormatter().setRowSpan(row, col, 1); for (int r = row + 1; r < (row + span); r++) { table.insertCell(r, col); table.getFlexCellFormatter().setStyleName(r, col, Gerrit.RESOURCES.css().diffText()); } } } }

protected void bindComment(final int row, final int col, final com.google.gerrit.reviewdb.client.PatchLineComment line, final boolean isLast, boolean expandComment) { if ((line.getStatus()) == (PatchLineComment.Status.DRAFT)) { final com.google.gerrit.client.patches.CommentEditorPanel plc = new com.google.gerrit.client.patches.CommentEditorPanel(line); plc.addFocusHandler(this); plc.addBlurHandler(this); table.setWidget(row, col, plc); styleLastCommentCell(row, col); } else { final com.google.gerrit.common.data.AccountInfo author = accountCache.get(line.getAuthor()); final com.google.gerrit.client.patches.AbstractPatchContentTable.PublishedCommentPanel panel = new com.google.gerrit.client.patches.AbstractPatchContentTable.PublishedCommentPanel(author, line); panel.setOpen(expandComment); panel.addFocusHandler(this); panel.addBlurHandler(this); table.setWidget(row, col, panel); styleLastCommentCell(row, col); com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList l = ((com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList) (getRowItem(row))); if (l == null) { l = new com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList(); setRowItem(row, l); } l.comments.add(line); l.panels.add(panel); } styleCommentRow(row); }
@java.lang.Override protected void onCellDoubleClick(final int row, int column) { if ((column > 0) && ((getRowItem(row)) instanceof com.google.gerrit.client.patches.PatchLine)) { final com.google.gerrit.client.patches.PatchLine line = ((com.google.gerrit.client.patches.PatchLine) (getRowItem(row))); if ((column == 1) || (column == (com.google.gerrit.client.patches.SideBySideTable.A))) { createCommentEditor((row + 1), com.google.gerrit.client.patches.SideBySideTable.A, line.getLineA(), ((short) (0))); } else if ((column == (com.google.gerrit.client.patches.SideBySideTable.B)) || (column == 4)) { createCommentEditor((row + 1), com.google.gerrit.client.patches.SideBySideTable.B, line.getLineB(), ((short) (1))); } } }

private void styleLastCommentCell(final int row, final int col) { final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); fmt.removeStyleName((row - 1), col, Gerrit.RESOURCES.css().commentPanelLast()); fmt.setStyleName(row, col, Gerrit.RESOURCES.css().commentHolder()); fmt.addStyleName(row, col, Gerrit.RESOURCES.css().commentPanelLast()); }
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (1 <= line) { final com.google.gerrit.reviewdb.client.Patch.Key parentKey; final short side; switch (file) { case 0 : if ((idSideA) == null) { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (0)); } else { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); side = ((short) (1)); } break; case 1 : parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (1)); break; default : throw new java.lang.RuntimeException(("unexpected file id " + file)); } final com.google.gerrit.reviewdb.client.PatchLineComment newComment = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(parentKey, null), line, com.google.gerrit.client.Gerrit.getUserAccount().getId(), null); newComment.setSide(side); newComment.setMessage(""); createCommentEditor(suggestRow, column, newComment).setFocus(true); } } else { com.google.gerrit.client.Gerrit.doSignIn(com.google.gwt.user.client.History.getToken()); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { setOpen((!(isOpen()))); }





@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.change.ChangeResource.CHANGE_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.change.ReviewerResource.REVIEWER_KIND); get(com.google.gerrit.server.change.ChangeResource.CHANGE_KIND).to(com.google.gerrit.server.change.GetChange.class); post(com.google.gerrit.server.change.ChangeResource.CHANGE_KIND, "abandon").to(com.google.gerrit.server.change.Abandon.class); child(com.google.gerrit.server.change.ChangeResource.CHANGE_KIND, "reviewers").to(com.google.gerrit.server.change.Reviewers.class); get(com.google.gerrit.server.change.ReviewerResource.REVIEWER_KIND).to(com.google.gerrit.server.change.GetReviewer.class); }






@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.server.change.PostReview.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { if ((input.labels) != null) { checkLabels(revision, input.strictLabels, input.labels); } if ((input.comments) != null) { checkComments(input.comments); } db.changes().beginTransaction(revision.getChange().getId()); try { change = db.changes().get(revision.getChange().getId()); com.google.gerrit.server.ChangeUtil.updated(change); timestamp = change.getLastUpdatedOn(); if ((input.comments) != null) { insertComments(revision, input.comments, input.drafts); } if ((change.getStatus().isOpen()) && ((input.labels) != null)) { updateLabels(revision, input.labels); } insertMessage(revision, input.message); db.changes().update(java.util.Collections.singleton(change)); db.commit(); } finally { db.rollback(); } email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync(); fireCommentAddedHook(revision); return input; }

public void display(final java.lang.String commitMessage) { display(null, null, commitMessage); }


@java.lang.Override protected void configure() { factory(AbandonChangeHandler.Factory.class); factory(AlterTopicHandler.Factory.class); factory(RestoreChangeHandler.Factory.class); factory(RevertChange.Factory.class); factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); factory(SubmitAction.Factory.class); factory(PublishAction.Factory.class); factory(DeleteDraftChange.Factory.class); }
@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AbandonChangeHandler.Factory.class); factory(AlterTopicHandler.Factory.class); factory(RestoreChangeHandler.Factory.class); factory(RevertChange.Factory.class); factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); factory(SubmitAction.Factory.class); factory(PublishAction.Factory.class); factory(DeleteDraftChange.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeDetailServiceImpl.class); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeManageServiceImpl.class); }

public void display(com.google.gerrit.reviewdb.client.Change chg, java.lang.Boolean starred, com.google.gerrit.reviewdb.client.PatchSetInfo info, final com.google.gerrit.common.data.AccountInfoCache acc, com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord) { infoBlock.display(chg, acc, submitTypeRecord); messageBlock.display(chg.getId(), starred, info.getMessage()); }
@java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { if (!(suggestionDisplay.isSuggestionSelected)) { doSearch(); } } }

static com.google.gerrit.server.project.DashboardsCollection.DashboardInfo parse(com.google.gerrit.reviewdb.client.Project project, java.lang.String refName, java.lang.String path, org.eclipse.jgit.lib.Config config) throws java.io.UnsupportedEncodingException { com.google.gerrit.server.project.DashboardsCollection.DashboardInfo info = new com.google.gerrit.server.project.DashboardsCollection.DashboardInfo(refName, path); info.title = config.getString("dashboard", null, "title"); info.description = config.getString("dashboard", null, "description"); info.isDefault = (info.id.equals(com.google.gerrit.server.project.DashboardsCollection.defaultOf(project))) ? true : null; com.google.gerrit.server.UrlEncoded u = new com.google.gerrit.server.UrlEncoded("/dashboard/"); u.put("title", com.google.common.base.Objects.firstNonNull(info.title, info.path)); for (java.lang.String name : config.getSubsections("section")) { com.google.gerrit.server.project.DashboardsCollection.Section s = new com.google.gerrit.server.project.DashboardsCollection.Section(); s.name = name; s.query = config.getString("section", name, "query"); u.put(s.name, com.google.gerrit.server.project.DashboardsCollection.replace(project.getName(), s.query)); info.sections.add(s); } info.url = u.toString().replace("%3A", ":"); return info; }

@java.lang.Override public com.google.gerrit.server.change.ReviewerResource parse(com.google.gerrit.server.change.ChangeResource change, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.Exception { if (id.matches("^[0-9]+$")) { return new com.google.gerrit.server.change.ReviewerResource(change, Account.Id.parse(id)); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }

private void onSend2(final boolean submit) { final java.util.Map<com.google.gerrit.reviewdb.client.ApprovalCategory.Id, com.google.gerrit.reviewdb.client.ApprovalCategoryValue.Id> values = new java.util.HashMap<com.google.gerrit.reviewdb.client.ApprovalCategory.Id, com.google.gerrit.reviewdb.client.ApprovalCategoryValue.Id>(); for (final com.google.gerrit.client.changes.PublishCommentScreen.ValueRadioButton b : approvalButtons) { if (b.getValue()) { values.put(b.value.getCategoryId(), b.value.getId()); } } enableForm(false); PatchUtil.DETAIL_SVC.publishComments(patchSetId, message.getText().trim(), new java.util.HashSet<com.google.gerrit.reviewdb.client.ApprovalCategoryValue.Id>(values.values()), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { if (submit) { submit(); } else { saveStateOnUnload = false; goChange(); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { super.onFailure(caught); enableForm(true); } }); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) { { sendButton.setText(Util.C.buttonRestoreChangeSend()); } @java.lang.Override public void onSend() { Util.MANAGE_SVC.restoreChange(patchSet.getId(), getMessageText(), createCallback()); } }.center(); }
@java.lang.Override protected void configure() { factory(AbandonedSender.Factory.class); }

@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AlterTopicHandler.Factory.class); factory(RestoreChangeHandler.Factory.class); factory(RevertChange.Factory.class); factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); factory(SubmitAction.Factory.class); factory(PublishAction.Factory.class); factory(DeleteDraftChange.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeDetailServiceImpl.class); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeManageServiceImpl.class); }
@java.lang.Override protected void configure() { factory(AlterTopicHandler.Factory.class); factory(RestoreChangeHandler.Factory.class); factory(RevertChange.Factory.class); factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); factory(SubmitAction.Factory.class); factory(PublishAction.Factory.class); factory(DeleteDraftChange.Factory.class); }
@java.lang.Override public void onSend() { Util.MANAGE_SVC.restoreChange(patchSet.getId(), getMessageText(), createCallback()); }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.DraftResource rsrc, com.google.gerrit.server.change.PutDraft.Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { if (((in == null) || ((in.message) == null)) || (in.message.trim().isEmpty())) { return delete.get().apply(rsrc, null); } else if (((in.kind) != null) && (!("gerritcodereview#comment".equals(in.kind)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("expected kind gerritcodereview#comment"); } else if (((in.line) != null) && ((in.line) < 0)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must be >= 0"); } com.google.gerrit.reviewdb.client.PatchLineComment c = rsrc.getComment(); if (((in.path) != null) && (!(in.path.equals(c.getKey().getParentKey().getFileName())))) { db.get().patchComments().delete(java.util.Collections.singleton(c)); c = update(new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(new com.google.gerrit.reviewdb.client.Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid()), in); db.get().patchComments().insert(java.util.Collections.singleton(c)); } else { db.get().patchComments().update(java.util.Collections.singleton(update(c, in))); } return new com.google.gerrit.server.change.GetDraft.Comment(c); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.server.change.PostReview.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if ((input.labels) != null) { checkLabels(revision, input.strictLabels, input.labels); } if ((input.comments) != null) { checkComments(input.comments); } db.changes().beginTransaction(revision.getChange().getId()); try { change = db.changes().get(revision.getChange().getId()); com.google.gerrit.server.ChangeUtil.updated(change); timestamp = change.getLastUpdatedOn(); if ((input.comments) != null) { insertComments(revision, input.comments, input.drafts); } if ((change.getStatus().isOpen()) && ((input.labels) != null)) { updateLabels(revision, input.labels); } insertMessage(revision, input.message); db.changes().update(java.util.Collections.singleton(change)); db.commit(); } finally { db.rollback(); } email.create(change, revision.getPatchSet(), revision.getAuthorId(), message, comments).sendAsync(); fireCommentAddedHook(revision); com.google.gerrit.server.change.PostReview.Output output = new com.google.gerrit.server.change.PostReview.Output(); output.labels = input.labels; return output; }
private com.google.gerrit.reviewdb.client.PatchLineComment update(com.google.gerrit.reviewdb.client.PatchLineComment e, com.google.gerrit.server.change.PutDraft.Input in) { if ((in.side) != null) { e.setSide(((in.side) == (com.google.gerrit.server.change.GetDraft.Side.PARENT) ? ((short) (0)) : ((short) (1)))); } if ((in.line) != null) { e.setLine(in.line); } e.setMessage(in.message.trim()); e.updated(); return e; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.RevisionResource rsrc, Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { if (com.google.common.base.Strings.isNullOrEmpty(in.path)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("path must be non-empty"); } else if (((in.message) == null) || (in.message.trim().isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("message must be non-empty"); } else if (((in.line) != null) && ((in.line) <= 0)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must be > 0"); } com.google.gerrit.reviewdb.client.PatchLineComment c = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(new com.google.gerrit.reviewdb.client.Patch.Key(rsrc.getPatchSet().getId(), in.path), com.google.gerrit.server.ChangeUtil.messageUUID(db.get())), ((in.line) != null ? in.line : 0), rsrc.getAuthorId(), null); c.setStatus(Status.DRAFT); c.setSide(((in.side) == (GetDraft.Side.PARENT) ? ((short) (0)) : ((short) (1)))); c.setMessage(in.message.trim()); db.get().patchComments().insert(java.util.Collections.singleton(c)); return new com.google.gerrit.server.change.GetDraft.Comment(c); }
public static java.lang.String messageUUID(final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final byte[] raw = new byte[8]; com.google.gerrit.server.ChangeUtil.fill(raw, db); return org.eclipse.jgit.util.Base64.encodeBytes(raw); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { new com.google.gerrit.client.ui.CommentedActionDialog<com.google.gerrit.common.data.ChangeDetail>(Util.C.titleEditCommitMessage(), Util.C.headingEditCommitMessage(), new com.google.gerrit.client.changes.ChangeDetailCache.IgnoreErrorCallback() {}) { { message.setCharacterWidth(80); message.setVisibleLines(20); message.setText(commitMessage); } @java.lang.Override public void onSend() { Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback()); } }.center(); }
@java.lang.Override public void onSend() { Util.MANAGE_SVC.createNewPatchSet(patchSetId, getMessageText(), createCallback()); }

private static <T extends com.google.gwt.core.client.JavaScriptObject> T parseJson(com.google.gwt.http.client.Response res) throws com.google.gwt.json.client.JSONException { java.lang.String json = res.getText(); if (json.startsWith(com.google.gerrit.client.rpc.RestApi.JSON_MAGIC)) { json = json.substring(com.google.gerrit.client.rpc.RestApi.JSON_MAGIC.length()); } if (json.isEmpty()) { throw new com.google.gwt.json.client.JSONException("response was empty"); } return com.google.gerrit.client.rpc.RestApi.cast(com.google.gwt.json.client.JSONParser.parseStrict(json)); }
public void onSuccess(com.google.gerrit.common.data.ChangeDetail result) { onSubmitResult(result); }

private void submit() { Util.MANAGE_SVC.submit(patchSetId, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ChangeDetail>() { public void onSuccess(com.google.gerrit.common.data.ChangeDetail result) { saveStateOnUnload = false; goChange(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { goChange(); super.onFailure(caught); } }); }


@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); Util.MANAGE_SVC.submit(patchSet.getId(), new com.google.gerrit.client.changes.ChangeDetailCache.GerritWidgetCallback(b) { public void onSuccess(com.google.gerrit.common.data.ChangeDetail result) { onSubmitResult(result); } }); }




public java.lang.String getUnifiedDiff() { com.google.gerrit.server.patch.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return ""; } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(args.settings.maximumDiffSize); org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf); org.eclipse.jgit.lib.Repository git; try { git = args.server.openRepository(change.getProject()); } catch (java.io.IOException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot open repository to format patch", e); return ""; } try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } finally { fmt.release(); git.close(); } }
void display(java.lang.String token) { assert token != null; try { try { if (com.google.gerrit.client.Dispatcher.matchPrefix(com.google.gerrit.client.Dispatcher.RELOAD_UI, token)) { com.google.gerrit.client.Dispatcher.wasStartedByReloadUI = true; token = com.google.gerrit.client.Dispatcher.skip(token); } com.google.gerrit.client.Dispatcher.select(token); } finally { com.google.gerrit.client.Dispatcher.wasStartedByReloadUI = false; } } catch (java.lang.RuntimeException err) { com.google.gwt.core.client.GWT.log(("Error parsing history token: " + token), err); com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } }
@java.lang.Override protected void insertRow(final int row) { super.insertRow(row); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); fmt.addStyleName(row, ((com.google.gerrit.client.patches.SideBySideTable.A) - 1), Gerrit.RESOURCES.css().lineNumber()); fmt.addStyleName(row, com.google.gerrit.client.patches.SideBySideTable.A, Gerrit.RESOURCES.css().diffText()); fmt.addStyleName(row, com.google.gerrit.client.patches.SideBySideTable.B, Gerrit.RESOURCES.css().diffText()); fmt.addStyleName(row, ((com.google.gerrit.client.patches.SideBySideTable.B) + 1), Gerrit.RESOURCES.css().lineNumber()); }

com.google.common.util.concurrent.CheckedFuture<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gwtorm.server.OrmException> insertPatchSet() throws java.io.IOException { rp.getRevWalk().parseBody(newCommit); warnMalformedMessage(newCommit); final java.lang.Thread caller = java.lang.Thread.currentThread(); com.google.common.util.concurrent.ListenableFuture<com.google.gerrit.reviewdb.client.PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new java.util.concurrent.Callable<com.google.gerrit.reviewdb.client.PatchSet.Id>() { @java.lang.Override public PatchSet.Id call() throws com.google.gwtorm.server.OrmException { try { if (caller == (java.lang.Thread.currentThread())) { return insertPatchSet(db); } else { com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { return insertPatchSet(db); } finally { db.close(); } } } finally { synchronized(replaceProgress) { replaceProgress.update(1); } } } })); return com.google.common.util.concurrent.Futures.makeChecked(future, com.google.gerrit.server.git.ReceiveCommits.ORM_EXCEPTION); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.git.ChangeUpdateExecutor public com.google.common.util.concurrent.ListeningExecutorService createChangeUpdateExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config) { int poolSize = config.getInt("receive", null, "changeUpdateThreads", 1); if (poolSize <= 1) { return com.google.common.util.concurrent.MoreExecutors.sameThreadExecutor(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(com.google.common.util.concurrent.MoreExecutors.getExitingExecutorService(new java.util.concurrent.ThreadPoolExecutor(1, poolSize, 10, java.util.concurrent.TimeUnit.MINUTES, new java.util.concurrent.ArrayBlockingQueue<java.lang.Runnable>(poolSize), new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("ChangeUpdate-%d").setDaemon(true).build(), new java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy()))); }
public void setFullName(final java.lang.String name) { fullName = name; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing(final java.io.File pub) { try { java.io.InputStream in = new java.io.FileInputStream(pub); try { in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream(in); return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection(in); } finally { in.close(); } } catch (java.io.IOException e) { throw new com.google.inject.ProvisionException(("Cannot read " + pub), e); } catch (org.bouncycastle.openpgp.PGPException e) { throw new com.google.inject.ProvisionException(("Cannot read " + pub), e); } }


private java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> scan() { if (recent) { return recentProjectsCache.getProjects(userProvider.get().getAccountId()); } else if ((matchPrefix) != null) { return projectCache.byName(matchPrefix); } else { return projectCache.all(); } }



@java.lang.Override protected void populate(final int row, final com.google.gerrit.client.projects.ProjectInfo k) { com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(createSearchLink(k)); fp.add(new com.google.gerrit.client.ui.InlineHyperlink(k.name(), link(k))); table.setWidget(row, 1, fp); table.setText(row, 2, k.description()); com.google.gerrit.client.GitwebLink l = com.google.gerrit.client.Gerrit.getGitwebLink(); if (l != null) { table.setWidget(row, 3, new com.google.gwt.user.client.ui.Anchor(l.getLinkName(), false, l.toProject(k.name_key()))); } setRowItem(row, k); }
@org.junit.Test public void testEmptyCommit() throws java.lang.Exception { expect(schemaFactory.open()).andReturn(schema); final org.eclipse.jgit.lib.Repository realDb = createWorkRepository(); final org.eclipse.jgit.api.Git git = new org.eclipse.jgit.api.Git(realDb); final org.eclipse.jgit.revwalk.RevCommit mergeTip = git.commit().setMessage("test").call(); final com.google.gerrit.reviewdb.client.Branch.NameKey branchNameKey = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("test-project"), "test-branch"); expect(urlProvider.get()).andReturn("http://localhost:8080"); expect(schema.submoduleSubscriptions()).andReturn(subscriptions); final com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.SubmoduleSubscription> emptySubscriptions = new com.google.gwtorm.server.ListResultSet<com.google.gerrit.reviewdb.client.SubmoduleSubscription>(new java.util.ArrayList<com.google.gerrit.reviewdb.client.SubmoduleSubscription>()); expect(subscriptions.bySubmodule(branchNameKey)).andReturn(emptySubscriptions); schema.close(); doReplay(); final com.google.gerrit.server.git.SubmoduleOp submoduleOp = new com.google.gerrit.server.git.SubmoduleOp(branchNameKey, mergeTip, new org.eclipse.jgit.revwalk.RevWalk(realDb), urlProvider, schemaFactory, realDb, null, new java.util.ArrayList<com.google.gerrit.reviewdb.client.Change>(), null, null, null, null); submoduleOp.update(); doVerify(); }
private static void whoAmI() { final java.lang.String name = com.google.gerrit.client.FormatUtil.nameEmail(com.google.gerrit.client.Gerrit.getUserAccount()); final com.google.gwt.user.client.ui.InlineLabel l = new com.google.gwt.user.client.ui.InlineLabel(name); l.setStyleName(com.google.gerrit.client.Gerrit.RESOURCES.css().menuBarUserName()); com.google.gerrit.client.Gerrit.menuRight.add(l); }
static com.google.gerrit.server.project.DashboardsCollection.DashboardInfo parse(com.google.gerrit.reviewdb.client.Project definingProject, java.lang.String refName, java.lang.String path, org.eclipse.jgit.lib.Config config, java.lang.String project, boolean setDefault) throws java.io.UnsupportedEncodingException { com.google.gerrit.server.project.DashboardsCollection.DashboardInfo info = new com.google.gerrit.server.project.DashboardsCollection.DashboardInfo(refName, path); info.project = definingProject.getName(); info.title = config.getString("dashboard", null, "title"); info.description = config.getString("dashboard", null, "description"); info.foreach = config.getString("dashboard", null, "foreach"); if (setDefault) { java.lang.String id = (refName + ":") + path; info.isDefault = (id.equals(com.google.gerrit.server.project.DashboardsCollection.defaultOf(definingProject))) ? true : null; } com.google.gerrit.server.UrlEncoded u = new com.google.gerrit.server.UrlEncoded("/dashboard/"); u.put("title", com.google.common.base.Objects.firstNonNull(info.title, info.path)); if ((info.foreach) != null) { u.put("foreach", com.google.gerrit.server.project.DashboardsCollection.replace(project, info.foreach)); } for (java.lang.String name : config.getSubsections("section")) { com.google.gerrit.server.project.DashboardsCollection.Section s = new com.google.gerrit.server.project.DashboardsCollection.Section(); s.name = name; s.query = config.getString("section", name, "query"); u.put(s.name, com.google.gerrit.server.project.DashboardsCollection.replace(project, s.query)); info.sections.add(s); } info.url = u.toString().replace("%3A", ":"); return info; }
public boolean canCreate(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevObject object) { if (!(canWrite())) { return false; } boolean owner; switch (getCurrentUser().getAccessPath()) { case REST_API : case JSON_RPC : owner = isOwner(); break; default : owner = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { return owner || (canPerform(Permission.CREATE)); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if ((getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); final java.lang.String addr = tagger.getEmailAddress(); valid = user.getEmailAddresses().contains(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.PUSH_TAG)); } else { return owner || (canPerform(Permission.PUSH_TAG)); } } else { return false; } }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { batch.addCommand(cmd); } else { if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) { reject(cmd, "cannot delete project configuration"); } else { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.DELETE, ctl.getRefName()); reject(cmd, "cannot delete references"); } } }
@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); java.lang.String projectName = token; while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } if (projectName.endsWith(".git")) { projectName = projectName.substring(0, ((projectName.length()) - 4)); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } } while (projectName.startsWith("/")) { projectName = projectName.substring(1); } final com.google.gerrit.server.project.ProjectControl control; try { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); control = projectControlFactory.validateFor(nameKey, ((com.google.gerrit.server.project.ProjectControl.OWNER) | (com.google.gerrit.server.project.ProjectControl.VISIBLE))); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new org.kohsuke.args4j.CmdLineException(owner, (("'" + token) + "': not a Gerrit project")); } setter.addValue(control); return 1; }


private void validateNewCommits(com.google.gerrit.server.project.RefControl ctl, org.eclipse.jgit.transport.ReceiveCommand cmd) { if ((((((((ctl.canForgeAuthor()) && (ctl.canForgeCommitter())) && (ctl.canForgeGerritServerIdentity())) && (ctl.canUploadMerges())) && (!(project.isUseSignedOffBy()))) && (com.google.common.collect.Iterables.isEmpty(rejectCommits))) && (!(GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())))) && (!((com.google.gerrit.server.util.MagicBranch.isMagicBranch(cmd.getRefName())) || (com.google.gerrit.server.git.ReceiveCommits.NEW_PATCHSET.matcher(cmd.getRefName()).matches())))) { return; } final org.eclipse.jgit.revwalk.RevWalk walk = rp.getRevWalk(); walk.reset(); walk.sort(RevSort.NONE); try { walk.markStart(walk.parseCommit(cmd.getNewId())); for (org.eclipse.jgit.lib.ObjectId id : existingObjects()) { try { walk.markUninteresting(walk.parseCommit(id)); } catch (java.io.IOException e) { continue; } } org.eclipse.jgit.revwalk.RevCommit c; while ((c = walk.next()) != null) { if (!(validCommit(ctl, cmd, c))) { break; } } } catch (java.io.IOException err) { cmd.setResult(com.google.gerrit.server.git.REJECTED_MISSING_OBJECT); com.google.gerrit.server.git.ReceiveCommits.log.error("Invalid pack upload; one or more objects weren't sent", err); } }
java.util.List<org.eclipse.jgit.transport.URIish> getURIs(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String urlMatch) { java.util.List<org.eclipse.jgit.transport.URIish> r = com.google.common.collect.Lists.newArrayListWithCapacity(remote.getURIs().size()); for (org.eclipse.jgit.transport.URIish uri : remote.getURIs()) { if (com.googlesource.gerrit.plugins.replication.Destination.matches(uri, urlMatch)) { java.lang.String name = project.get(); if (com.googlesource.gerrit.plugins.replication.Destination.needsUrlEncoding(uri)) { name = com.googlesource.gerrit.plugins.replication.Destination.encode(name); } java.lang.String replacedPath = com.googlesource.gerrit.plugins.replication.ReplicationQueue.replaceName(uri.getPath(), name); if (replacedPath != null) { uri = uri.setPath(replacedPath); r.add(uri); } } } return r; }

@com.google.common.annotations.VisibleForTesting java.util.Map<java.lang.String, ?> buildData(javax.servlet.http.HttpServletRequest req) throws java.io.IOException { com.google.gitiles.RepositoryDescription desc = accessFactory.forRequest(req).getRepositoryDescription(); return com.google.common.collect.ImmutableMap.of("cloneUrl", desc.cloneUrl, "description", com.google.common.base.Strings.nullToEmpty(desc.description), "branches", getRefs(req, Constants.R_HEADS), "tags", getRefs(req, Constants.R_TAGS)); }
private java.util.List<java.util.Map<java.lang.String, java.lang.String>> getRefs(javax.servlet.http.HttpServletRequest req, java.lang.String prefix) throws java.io.IOException { org.eclipse.jgit.lib.RefDatabase refdb = org.eclipse.jgit.http.server.ServletUtils.getRepository(req).getRefDatabase(); java.util.Collection<org.eclipse.jgit.lib.Ref> refs = org.eclipse.jgit.lib.RefComparator.sort(refdb.getRefs(prefix).values()); java.util.List<java.util.Map<java.lang.String, java.lang.String>> result = com.google.common.collect.Lists.newArrayListWithCapacity(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { java.lang.String name = ref.getName().substring(prefix.length()); boolean needPrefix = !(ref.getName().equals(refdb.getRef(name).getName())); result.add(com.google.common.collect.ImmutableMap.of("url", com.google.gitiles.GitilesView.log().copyFrom(req).setRevision(com.google.gitiles.Revision.unpeeled((needPrefix ? ref.getName() : name), ref.getObjectId())).toUrl(), "name", name)); } return result; }


private java.lang.String getFixedCommitMsgWithChangeId(java.lang.String errMsg, org.eclipse.jgit.revwalk.RevCommit c) { final java.lang.String changeId = "Change-Id:"; java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("ERROR: ").append(errMsg); sb.append("\n"); sb.append("Suggestion for commit message:\n"); if ((c.getFullMessage().indexOf(changeId)) == (-1)) { sb.append(c.getFullMessage()); sb.append("\n"); sb.append(changeId).append(" I").append(c.name()); } else { java.lang.String[] lines = c.getFullMessage().trim().split("\n"); java.lang.String lastLine = ((lines.length) > 0) ? lines[((lines.length) - 1)] : ""; if ((lastLine.indexOf(changeId)) == 0) { for (int i = 0; i < ((lines.length) - 1); i++) { sb.append(lines[i]); sb.append("\n"); } sb.append("\n"); sb.append(lastLine); } else { sb.append(c.getFullMessage()); sb.append("\n"); sb.append(changeId).append(" I").append(c.name()); sb.append("\nHint: A potential Change-Id was found, but it was not in the footer of the commit message."); } } sb.append("\n"); sb.append("Hint: To automatically add a Change-Id to commit messages, install the commit-msg hook:\n"); sb.append(getCommitMessageHookInstallationHint()); return sb.toString(); }
private void showGitlink(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.treewalk.TreeWalk tw, org.eclipse.jgit.revwalk.RevTree root) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.submodule.SubmoduleWalk sw = org.eclipse.jgit.submodule.SubmoduleWalk.forPath(org.eclipse.jgit.http.server.ServletUtils.getRepository(req), root, view.getTreePath()); java.lang.String remoteUrl; try { remoteUrl = sw.getRemoteUrl(); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } finally { sw.release(); } java.util.Map<java.lang.String, java.lang.Object> data = com.google.common.collect.Maps.newHashMap(); data.put("sha", org.eclipse.jgit.lib.ObjectId.toString(tw.getObjectId(0))); data.put("remoteUrl", remoteUrl); java.lang.String httpUrl = com.google.gitiles.PathServlet.resolveHttpUrl(remoteUrl); if (httpUrl != null) { data.put("httpUrl", httpUrl); } render(req, res, "gitiles.pathDetail", com.google.common.collect.ImmutableMap.of("title", view.getTreePath(), "type", com.google.gitiles.PathServlet.FileType.GITLINK.toString(), "data", data)); }
private void showTree(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.treewalk.TreeWalk tw, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); render(req, res, "gitiles.pathDetail", com.google.common.collect.ImmutableMap.of("title", (!(view.getTreePath().isEmpty()) ? view.getTreePath() : "/"), "type", com.google.gitiles.PathServlet.FileType.TREE.toString(), "data", new com.google.gitiles.TreeSoyData(rw, view).toSoyData(id, tw))); }





@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.mail.EmailException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { final com.google.gerrit.reviewdb.client.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.server.project.ChangeControl control = changeControlFactory.validateFor(changeId); if (!(control.canAddPatchSet())) { throw new com.google.gerrit.server.project.InvalidChangeOperationException(("Not allowed to add new Patch Sets to: " + (changeId.toString()))); } com.google.gerrit.server.ChangeUtil.editCommitMessage(patchSetId, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent); return changeDetailFactory.create(changeId).call(); }


public org.eclipse.jgit.lib.Repository createRepository(final com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.git.RepositoryCaseMismatchException, org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } java.io.File dir = org.eclipse.jgit.lib.RepositoryCache.FileKey.resolve(gitDirOf(name), FS.DETECTED); org.eclipse.jgit.lib.RepositoryCache.FileKey loc; if (dir != null) { loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(dir, FS.DETECTED); if (!(names.contains(name))) { throw new com.google.gerrit.server.git.RepositoryCaseMismatchException(name); } } else { java.lang.String n = name.get(); if (!(n.endsWith(Constants.DOT_GIT_EXT))) { n = n + (org.eclipse.jgit.lib.Constants.DOT_GIT_EXT); } loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.exact(new java.io.File(basePath, n), FS.DETECTED); } try { org.eclipse.jgit.lib.Repository db = org.eclipse.jgit.lib.RepositoryCache.open(loc, false); db.create(true); org.eclipse.jgit.lib.StoredConfig config = db.getConfig(); config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true); config.save(); onCreateProject(name); return db; } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot create repository " + name)); e2.initCause(e1); throw e2; } }


@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.reviewdb.ReviewDb.class).toProvider(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(MetaDataUpdate.User.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.server.account.AccountResolver.class); bind(com.google.gerrit.server.query.change.ChangeQueryRewriter.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(GroupControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(ChangeQueryBuilder.Factory.class); factory(ReceiveCommits.Factory.class); factory(MergeOp.Factory.class); factory(CreateCodeReviewNotes.Factory.class); factory(AddReviewerSender.Factory.class); factory(CreateChangeSender.Factory.class); factory(PublishComments.Factory.class); factory(ReplacePatchSetSender.Factory.class); factory(AbandonedSender.Factory.class); factory(RevertedSender.Factory.class); factory(CommentSender.Factory.class); factory(MergedSender.Factory.class); factory(MergeFailSender.Factory.class); factory(RegisterNewEmailSender.Factory.class); factory(PerformCreateGroup.Factory.class); }
private void parseDelete(final org.eclipse.jgit.transport.ReceiveCommand cmd) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canDelete()) { } else { com.google.gerrit.server.git.ReceiveCommits.reject(cmd); } }
@java.lang.Override protected void init() throws com.google.gerrit.server.mail.EmailException { super.init(); ccAllApprovals(); bccStarredBy(); includeWatchers(NotifyType.ALL_COMMENTS); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(MetaDataUpdate.User.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.server.ApprovalsUtil.class); bind(com.google.gerrit.server.project.PerRequestProjectControlCache.class).in(com.google.inject.servlet.RequestScoped.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(AccountControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(SubmoduleOp.Factory.class); factory(MergeOp.Factory.class); factory(CreateCodeReviewNotes.Factory.class); install(new com.google.gerrit.server.git.AsyncReceiveCommits.Module()); factory(AddReviewer.Factory.class); factory(AddReviewerSender.Factory.class); factory(CommitMessageEditedSender.Factory.class); factory(CreateChangeSender.Factory.class); factory(DeleteDraftPatchSet.Factory.class); factory(PublishDraft.Factory.class); factory(ReplacePatchSetSender.Factory.class); factory(RebasedPatchSetSender.Factory.class); factory(RemoveReviewer.Factory.class); factory(MergedSender.Factory.class); factory(MergeFailSender.Factory.class); factory(PerformCreateGroup.Factory.class); factory(PerformRenameGroup.Factory.class); factory(VisibleGroups.Factory.class); factory(GroupDetailFactory.Factory.class); factory(GroupMembers.Factory.class); factory(CreateProject.Factory.class); factory(SuggestParentCandidates.Factory.class); factory(BanCommit.Factory.class); factory(CommitValidators.Factory.class); }
@org.kohsuke.args4j.Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group") void addGroup(final com.google.gerrit.reviewdb.client.AccountGroup.Id id) { initialGroups.add(id); }
private void addGroups(final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, final java.util.Collection<? extends com.google.gerrit.reviewdb.client.AccountGroup.Id> groups) throws com.google.gwtorm.server.OrmException { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupInclude> includeList = new java.util.ArrayList<com.google.gerrit.reviewdb.client.AccountGroupInclude>(); final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupIncludeAudit> includesAudit = new java.util.ArrayList<com.google.gerrit.reviewdb.client.AccountGroupIncludeAudit>(); for (com.google.gerrit.reviewdb.client.AccountGroup.Id includeId : groups) { final com.google.gerrit.reviewdb.client.AccountGroupInclude groupInclude = new com.google.gerrit.reviewdb.client.AccountGroupInclude(new com.google.gerrit.reviewdb.client.AccountGroupInclude.Key(groupId, includeId)); includeList.add(groupInclude); final com.google.gerrit.reviewdb.client.AccountGroupIncludeAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupIncludeAudit(groupInclude, currentUser.getAccountId()); includesAudit.add(audit); } db.accountGroupIncludes().insert(includeList); db.accountGroupIncludesAudit().insert(includesAudit); for (com.google.gerrit.reviewdb.client.AccountGroup group : db.accountGroups().get(new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.Id>(groups))) { groupIncludeCache.evictInclude(group.getGroupUUID()); } }

public com.google.gerrit.common.data.GroupDetail run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gerrit.httpd.rpc.account.Failure, com.google.gwtorm.server.OrmException { final com.google.gerrit.server.account.GroupControl control = groupControlFactory.validateFor(groupId); if ((groupCache.get(groupId).getType()) != (AccountGroup.Type.INTERNAL)) { throw new com.google.gerrit.httpd.rpc.account.Failure(new com.google.gerrit.common.errors.NameAlreadyUsedException()); } final com.google.gerrit.reviewdb.client.AccountGroup a = findGroup(groupName); if (!(control.canAddGroup(a.getId()))) { throw new com.google.gerrit.httpd.rpc.account.Failure(new com.google.gerrit.common.errors.NoSuchEntityException()); } final com.google.gerrit.reviewdb.client.AccountGroupInclude.Key key = new com.google.gerrit.reviewdb.client.AccountGroupInclude.Key(groupId, a.getId()); com.google.gerrit.reviewdb.client.AccountGroupInclude m = db.accountGroupIncludes().get(key); if (m == null) { m = new com.google.gerrit.reviewdb.client.AccountGroupInclude(key); db.accountGroupIncludesAudit().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.AccountGroupIncludeAudit(m, getAccountId()))); db.accountGroupIncludes().insert(java.util.Collections.singleton(m)); groupIncludeCache.evictInclude(a.getGroupUUID()); } return groupDetailFactory.create(groupId).call(); }

@java.lang.Override protected void configure() { bind(com.google.gerrit.server.group.GroupsCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.GroupResource.GROUP_KIND); get(com.google.gerrit.server.group.GroupResource.GROUP_KIND).to(com.google.gerrit.server.group.GetGroup.class); }

private void onDiscovery(final DiscoveryResult result) { switch (result.status) { case VALID : redirectForm.setMethod(FormPanel.METHOD_POST); redirectForm.setAction(result.providerUrl); redirectBody.clear(); for (final java.util.Map.Entry<java.lang.String, java.lang.String> e : result.providerArgs.entrySet()) { redirectBody.add(new com.google.gwt.user.client.ui.Hidden(e.getKey(), e.getValue())); } com.google.gwt.dom.client.FormElement.as(redirectForm.getElement()).setTarget("_top"); redirectForm.submit(); break; case ERROR : case NO_PROVIDER : case NOT_ALLOWED : break; } }













public com.google.gerrit.server.project.ProjectState getParentState() { if (isAllProjects) { return null; } return projectCache.get(getProject().getParent(allProjectsName)); }
@java.lang.Override public int compare(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> a, com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> b) { int ai = (a instanceof com.google.gerrit.server.query.change.ChangeDataSource) ? 0 : 1; int bi = (b instanceof com.google.gerrit.server.query.change.ChangeDataSource) ? 0 : 1; int cmp = ai - bi; if (((cmp == 0) && (a instanceof com.google.gerrit.server.query.change.ChangeDataSource)) && (b instanceof com.google.gerrit.server.query.change.ChangeDataSource)) { ai = (((com.google.gerrit.server.query.change.ChangeDataSource) (a)).hasChange()) ? 0 : 1; bi = (((com.google.gerrit.server.query.change.ChangeDataSource) (b)).hasChange()) ? 0 : 1; cmp = ai - bi; } if (cmp == 0) { cmp = (a.getCost()) - (b.getCost()); } if (((cmp == 0) && (a instanceof com.google.gerrit.server.query.change.ChangeDataSource)) && (b instanceof com.google.gerrit.server.query.change.ChangeDataSource)) { com.google.gerrit.server.query.change.ChangeDataSource as = ((com.google.gerrit.server.query.change.ChangeDataSource) (a)); com.google.gerrit.server.query.change.ChangeDataSource bs = ((com.google.gerrit.server.query.change.ChangeDataSource) (b)); cmp = (as.getCardinality()) - (bs.getCardinality()); } return cmp; }


@java.lang.Override public java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> apply(final com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { final java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> members = com.google.common.collect.Lists.newArrayList(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(resource.getGroupUUID()); final com.google.gerrit.common.data.GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call(); if ((groupDetail.members) != null) { for (final com.google.gerrit.reviewdb.client.AccountGroupMember member : groupDetail.members) { final com.google.gerrit.reviewdb.client.Account account = accountCache.get(member.getAccountId()).getAccount(); members.add(com.google.gerrit.server.group.MembersCollection.parse(account)); } } return members; }

@java.lang.Override public java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> apply(final com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { return com.google.common.collect.Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>()).values()); }


@java.lang.Override protected void configure() { bind(com.google.gerrit.server.group.GroupsCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.GroupResource.GROUP_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.MemberResource.MEMBER_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.IncludedGroupResource.INCLUDED_GROUP_KIND); get(com.google.gerrit.server.group.GroupResource.GROUP_KIND).to(com.google.gerrit.server.group.GetGroup.class); child(com.google.gerrit.server.group.GroupResource.GROUP_KIND, "members").to(com.google.gerrit.server.group.MembersCollection.class); get(com.google.gerrit.server.group.MemberResource.MEMBER_KIND).to(com.google.gerrit.server.group.GetMember.class); child(com.google.gerrit.server.group.GroupResource.GROUP_KIND, "groups").to(com.google.gerrit.server.group.IncludedGroupsCollection.class); get(com.google.gerrit.server.group.IncludedGroupResource.INCLUDED_GROUP_KIND).to(com.google.gerrit.server.group.GetIncludedGroup.class); }


@java.lang.Override protected void configure() { bind(com.google.gerrit.server.group.GroupsCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.GroupResource.GROUP_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.MemberResource.MEMBER_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.group.IncludedGroupResource.INCLUDED_GROUP_KIND); get(com.google.gerrit.server.group.GroupResource.GROUP_KIND).to(com.google.gerrit.server.group.GetGroup.class); child(com.google.gerrit.server.group.GroupResource.GROUP_KIND, "members").to(com.google.gerrit.server.group.MembersCollection.class); get(com.google.gerrit.server.group.MemberResource.MEMBER_KIND).to(com.google.gerrit.server.group.GetMember.class); put(com.google.gerrit.server.group.GroupResource.GROUP_KIND, "members").to(com.google.gerrit.server.group.PutMember.class); child(com.google.gerrit.server.group.GroupResource.GROUP_KIND, "groups").to(com.google.gerrit.server.group.IncludedGroupsCollection.class); get(com.google.gerrit.server.group.IncludedGroupResource.INCLUDED_GROUP_KIND).to(com.google.gerrit.server.group.GetIncludedGroup.class); }




@java.lang.Override public com.google.gerrit.server.group.MemberResource parse(final com.google.gerrit.server.group.GroupResource parent, final java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.Exception { final com.google.gerrit.reviewdb.client.Account a = accountResolver.find(com.google.gerrit.server.util.Url.decode(id)); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(parent.getControl().getGroup().getGroupUUID()); final com.google.gerrit.common.data.GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call(); if ((groupDetail.members) != null) { for (final com.google.gerrit.reviewdb.client.AccountGroupMember member : groupDetail.members) { if (member.getAccountId().equals(a.getId())) { return new com.google.gerrit.server.group.MemberResource(parent, userGenericFactory.create(a.getId())); } } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }

private boolean findIncludedGroup(java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> query) { boolean found = false; while ((!found) && (!(groupQueue.isEmpty()))) { com.google.gerrit.reviewdb.client.AccountGroup.UUID id = groupQueue.remove(); for (final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId : groupIncludeCache.getByInclude(id)) { if (includes.add(groupId)) { groupQueue.add(groupId); found |= query.contains(groupId); } } } return found; }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getKnownGroups() { findIncludedGroup(java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet()); return com.google.common.collect.Sets.newHashSet(includes); }
@java.lang.Override public boolean containsAnyOf(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.UUID> ids) { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> query = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId : ids) { if (includes.contains(groupId)) { return true; } query.add(groupId); } return findIncludedGroup(query); }
@java.lang.Override public boolean contains(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { if (id == null) { return false; } if (includes.contains(id)) { return true; } return findIncludedGroup(java.util.Collections.singleton(id)); }
private com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> computeKnownGroups() { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> direct = user.state().getInternalGroups(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> r = com.google.common.collect.Sets.newHashSet(direct); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = com.google.common.collect.Lists.newArrayList(r); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID id = q.remove(((q.size()) - 1)); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID g : includeCache.memberIn(id)) { if (r.add(g)) { q.add(g); memberOf.put(g, true); } } } return com.google.common.collect.ImmutableSet.copyOf(r); }
public static void addMembers(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.Set<java.lang.String> members, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeList<com.google.gerrit.client.groups.MemberInfo>> cb) { com.google.gerrit.client.rpc.RestApi call = new com.google.gerrit.client.rpc.RestApi(com.google.gerrit.client.groups.GroupApi.membersBase(groupUUID)); com.google.gerrit.client.groups.GroupApi.MemberInput input = com.google.gerrit.client.groups.GroupApi.MemberInput.create(); for (java.lang.String member : members) { input.add_member(member); } call.data(input).put(cb); }

void display(final java.io.PrintWriter out) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(out, '\t'); for (final com.google.gerrit.server.group.GroupInfo info : get()) { formatter.addColumn(info.name); if (verboseOutput) { com.google.gerrit.reviewdb.client.AccountGroup o = ((info.ownerId) != null) ? groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.server.util.Url.decode(info.ownerId))) : null; formatter.addColumn(com.google.gerrit.server.util.Url.decode(info.id)); formatter.addColumn(com.google.common.base.Strings.nullToEmpty(info.description)); formatter.addColumn((o != null ? o.getName() : "n/a")); formatter.addColumn((o != null ? o.getGroupUUID().get() : "")); formatter.addColumn(java.lang.Boolean.toString(com.google.common.base.Objects.firstNonNull(info.visibleToAll, java.lang.Boolean.FALSE))); } formatter.nextLine(); } formatter.finish(); }
@java.lang.Override public void sendError(int sc, java.lang.String msg) { status = sc; }
@java.lang.Override public void sendRedirect(java.lang.String msg) { status = SC_FOUND; }

@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(org.eclipse.jgit.http.server.ServletUtils.getRepository(req)); java.util.List<java.util.Map<java.lang.String, java.lang.Object>> tags; try { tags = com.google.gitiles.RefServlet.getTags(req, timeCache, walk, 0); } finally { walk.release(); } renderHtml(req, res, "gitiles.refsDetail", com.google.common.collect.ImmutableMap.of("branches", com.google.gitiles.RefServlet.getBranches(req, 0), "tags", tags)); }
protected final com.google.gerrit.server.mail.ChangeEmail.Watchers getWatches(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.mail.ChangeEmail.Watchers matching = new com.google.gerrit.server.mail.ChangeEmail.Watchers(); if ((changeData) == null) { return matching; } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> projectWatchers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) { projectWatchers.add(w.getAccountId()); if (w.isNotify(type)) { add(matching, w); } } for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) { if ((!(projectWatchers.contains(w.getAccountId()))) && (w.isNotify(type))) { add(matching, w); } } com.google.gerrit.server.project.ProjectState state = projectState; while (state != null) { for (com.google.gerrit.server.git.NotifyConfig nc : state.getConfig().getNotifyConfigs()) { if (nc.isNotify(type)) { try { add(matching, nc, state.getProject().getNameKey()); } catch (com.google.gerrit.server.query.QueryParseException e) { com.google.gerrit.server.mail.ChangeEmail.log.warn(java.lang.String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage())); } } } state = state.getParentState(); } return matching; }



@java.lang.Override protected void init() throws com.google.gerrit.server.mail.EmailException { super.init(); try { com.google.gerrit.server.mail.Watchers matching = getWatches(NotifyType.NEW_CHANGES); for (com.google.gerrit.reviewdb.client.Account.Id user : com.google.common.collect.Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) { if (isOwnerOfProjectOrBranch(user)) { add(RecipientType.TO, user); } } add(RecipientType.TO, matching.to); add(RecipientType.CC, matching.cc); add(RecipientType.BCC, matching.bcc); } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.CreateChangeSender.log.warn("Cannot notify watchers for new change", err); } }



protected final com.google.gerrit.server.mail.ProjectWatch.Watchers getWatches(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.mail.ProjectWatch watch = new com.google.gerrit.server.mail.ProjectWatch(args, project, projectState, changeData); return watch.getWatches(type); }

@java.lang.SuppressWarnings("unchecked") private void add(com.google.gerrit.server.mail.ProjectWatch.Watchers matching, com.google.gerrit.server.git.NotifyConfig nc, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { for (com.google.gerrit.common.data.GroupReference ref : nc.getGroups()) { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(args.groupBackend.get(ref.getUUID())); if (group == null) { com.google.gerrit.server.mail.ProjectWatch.log.warn(java.lang.String.format("Project %s has invalid group %s in notify section %s", project.get(), ref.getName(), nc.getName())); continue; } if ((group.getType()) != (AccountGroup.Type.INTERNAL)) { com.google.gerrit.server.mail.ProjectWatch.log.warn(java.lang.String.format("Project %s cannot use group %s of type %s in notify section %s", project.get(), ref.getName(), group.getType(), nc.getName())); continue; } com.google.gerrit.server.query.change.ChangeQueryBuilder qb = args.queryBuilder.create(new com.google.gerrit.server.query.change.SingleGroupUser(args.capabilityControlFactory, ref.getUUID())); qb.setAllowFile(true); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p = qb.is_visible(); if ((nc.getFilter()) != null) { p = com.google.gerrit.server.query.Predicate.and(qb.parse(nc.getFilter()), p); p = args.queryRewriter.get().rewrite(p); } if (p.match(changeData)) { recursivelyAddAllAccounts(matching.list(nc.getHeader()), group); } } if (!(nc.getAddresses().isEmpty())) { if ((nc.getFilter()) != null) { com.google.gerrit.server.query.change.ChangeQueryBuilder qb = args.queryBuilder.create(args.anonymousUser); qb.setAllowFile(true); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p = qb.parse(nc.getFilter()); p = args.queryRewriter.get().rewrite(p); if (p.match(changeData)) { matching.list(nc.getHeader()).emails.addAll(nc.getAddresses()); } } else { matching.list(nc.getHeader()).emails.addAll(nc.getAddresses()); } } }


public static void addMembers(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.Set<java.lang.String> members, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeList<com.google.gerrit.client.groups.MemberInfo>> cb) { if ((members.size()) == 1) { com.google.gerrit.client.groups.GroupApi.addMember(groupUUID, members.iterator().next(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.groups.MemberInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.groups.MemberInfo result) { cb.onSuccess(com.google.gerrit.client.rpc.NativeList.of(result)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { cb.onFailure(caught); } }); } else { com.google.gerrit.client.rpc.RestApi call = new com.google.gerrit.client.rpc.RestApi(com.google.gerrit.client.groups.GroupApi.membersBase(groupUUID)); com.google.gerrit.client.groups.GroupApi.MemberInput input = com.google.gerrit.client.groups.GroupApi.MemberInput.create(); for (java.lang.String member : members) { input.add_member(member); } call.data(input).put(cb); } }




public static void createGroup(java.lang.String groupName, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.groups.GroupInfo> cb) { com.google.gerrit.client.groups.GroupApi.GroupInput in = com.google.gerrit.client.groups.GroupApi.GroupInput.create(); in.name(groupName); new com.google.gerrit.client.rpc.RestApi("/groups/").data(in).post(cb); }
@java.lang.Override public com.google.gerrit.server.group.GroupInfo apply(com.google.gerrit.extensions.restapi.TopLevelResource resource, com.google.gerrit.server.group.CreateGroup.Input input) throws com.google.gerrit.common.errors.NameAlreadyUsedException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { final com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (self.get())); if (!(me.getCapabilities().canCreateGroup())) { throw new com.google.gerrit.extensions.restapi.AuthException("Cannot create group"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("group name missing"); } com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(input.name)); if (group != null) { return new com.google.gerrit.server.group.GroupInfo(com.google.gerrit.common.data.GroupDescriptions.forAccountGroup(group)); } try { group = performCreateGroupFactory.create().createGroup(input.name, null, visibleToAll, null, java.util.Collections.singleton(me.getAccountId()), null); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } return new com.google.gerrit.server.group.GroupInfo(com.google.gerrit.common.data.GroupDescriptions.forAccountGroup(group)); }




public static void removeMembers(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> ids, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { if ((ids.size()) == 1) { com.google.gerrit.reviewdb.client.Account.Id u = ids.iterator().next(); new com.google.gerrit.client.rpc.RestApi((((com.google.gerrit.client.groups.GroupApi.membersBase(groupUUID)) + "/") + u)).delete(cb); } else { com.google.gerrit.client.groups.GroupApi.MemberInput in = com.google.gerrit.client.groups.GroupApi.MemberInput.create(); for (com.google.gerrit.reviewdb.client.Account.Id u : ids) { in.add_member(u.toString()); } new com.google.gerrit.client.rpc.RestApi(((com.google.gerrit.client.groups.GroupApi.membersBase(groupUUID)) + ".delete")).data(in).post(cb); } }
private static java.lang.String includedGroupsBase(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { return (com.google.gerrit.client.groups.GroupApi.base(groupUUID)) + "groups"; }

private static java.lang.String membersBase(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { return (com.google.gerrit.client.groups.GroupApi.base(groupUUID)) + "members"; }
private static java.lang.String base(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { java.lang.String id = com.google.gwt.http.client.URL.encodePathSegment(groupUUID.get()); return ("/groups/" + id) + "/"; }

@java.lang.Override public java.lang.String select(javax.servlet.http.HttpServletRequest req) { java.lang.String ua = req.getHeader("User-Agent"); if (ua == null) { return null; } ua = ua.toLowerCase(); if ((ua.indexOf("opera")) != (-1)) { return "opera"; } else if ((ua.indexOf("webkit")) != (-1)) { return "safari"; } else if ((ua.indexOf("msie")) != (-1)) { java.util.regex.Matcher m = com.google.gwtexpui.linker.server.UserAgentRule.msie.matcher(ua); if ((m.matches()) && ((m.groupCount()) == 2)) { int v = makeVersion(m); if (v >= 8000) { return "ie8"; } if (v >= 6000) { return "ie6"; } } return null; } else if ((ua.indexOf("gecko")) != (-1)) { java.util.regex.Matcher m = com.google.gwtexpui.linker.server.UserAgentRule.gecko.matcher(ua); if ((m.matches()) && ((m.groupCount()) == 2)) { if ((makeVersion(m)) >= 1008) { return "gecko1_8"; } } return "gecko"; } return null; }




public void setReviewedByCurrentUser(boolean reviewed) { if ((fileList) != null) { fileList.updateReviewedStatus(patchKey, reviewed); } PatchUtil.DETAIL_SVC.setReviewedByCurrentUser(patchKey, reviewed, new com.google.gwtjsonrpc.common.AsyncCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onFailure(java.lang.Throwable arg0) { } @java.lang.Override public void onSuccess(com.google.gwtjsonrpc.common.VoidResult result) { } }); }


private java.lang.String getCommand(java.lang.String commandLine) { commandLine = commandLine.trim(); int spacePos = commandLine.indexOf(' '); return spacePos > 0 ? commandLine.substring(0, spacePos) : commandLine; }
void audit(com.google.gerrit.sshd.SshScope.Context ctx, java.lang.Object result, java.lang.String commandName, java.lang.String[] args) { final java.lang.String sid = extractSessionId(ctx); final long created = extractCreated(ctx); final java.lang.String what = extractWhat(commandName, args); auditService.dispatch(new com.google.gerrit.audit.AuditEvent(sid, extractCurrentUser(ctx), ("ssh:" + what), created, java.util.Arrays.asList(args), result)); }
private java.lang.String extractWhat(java.lang.String commandName, java.lang.String[] args) { java.lang.String result = commandName; if ("gerrit".equals(commandName)) { if ((args.length) > 1) result = ("gerrit" + ".") + (args[1]); } return result; }
@java.lang.Override public java.lang.String toString() { java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append(uuid.toString()); sb.append("|"); sb.append(sessionId); sb.append('|'); sb.append(who); sb.append('|'); sb.append(when); sb.append('|'); sb.append(what); sb.append('|'); sb.append(elapsed); sb.append('|'); if ((params) != null) { sb.append('['); for (int i = 0; i < (params.size()); i++) { if (i > 0) sb.append(','); java.lang.Object param = params.get(i); if (param == null) { sb.append("null"); } else { sb.append(param); } } sb.append(']'); } sb.append('|'); if ((result) != null) { sb.append(result); } return sb.toString(); }
private void audit() { try { com.google.gerrit.httpd.rpc.GerritJsonServlet.GerritCall call = com.google.gerrit.httpd.rpc.GerritJsonServlet.currentCall.get(); com.google.gwtjsonrpc.server.MethodHandle method = call.getMethod(); if (method == null) { return; } com.google.gerrit.common.audit.Audit note = ((com.google.gerrit.common.audit.Audit) (method.getAnnotation(com.google.gerrit.common.audit.Audit.class))); if (note != null) { final java.lang.String sid = call.getWebSession().getSessionId(); final com.google.gerrit.server.CurrentUser username = call.getWebSession().getCurrentUser(); final java.util.List<java.lang.Object> args = extractParams(note, call); final java.lang.String what = extractWhat(note, method.getName()); final java.lang.Object result = call.getResult(); audit.dispatch(new com.google.gerrit.audit.AuditEvent(sid, username, what, call.getWhen(), args, result)); } } catch (java.lang.Throwable all) { com.google.gerrit.httpd.rpc.GerritJsonServlet.log.error("Unable to log the call", all); } }
private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(new com.google.gerrit.common.ChangeHookRunner.Module()); modules.add(new com.google.gerrit.server.git.ReceiveCommitsExecutorModule()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.mail.SignedTokenEmailTokenVerifier.Module()); modules.add(new com.google.gerrit.server.plugins.PluginModule()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(com.google.gerrit.sshd.SshKeyCacheImpl.module()); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); return cfgInjector.createChildInjector(modules); }





@java.lang.Override protected void onLoad() { super.onLoad(); Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchSetPublishDetail>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.PatchSetPublishDetail result) { send.setEnabled(true); display(result); } @java.lang.Override protected void postDisplay() { message.setFocus(true); } }); }




@java.lang.Override public com.google.gerrit.server.group.IncludedGroupResource parse(com.google.gerrit.server.group.GroupResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (!(parent.isInternal())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.common.data.GroupDescription.Internal p = ((com.google.gerrit.common.data.GroupDescription.Internal) (parent.getGroup())); com.google.gerrit.server.group.GroupResource included = groupsCollection.get().parse(id.get()); com.google.gerrit.reviewdb.client.AccountGroupIncludeByUuid in = dbProvider.get().accountGroupIncludesByUuid().get(new com.google.gerrit.reviewdb.client.AccountGroupIncludeByUuid.Key(p.getAccountGroup().getId(), included.getGroupUUID())); if (in != null) { return new com.google.gerrit.server.group.IncludedGroupResource(included.getControl()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public static void deleteOnlyDraftPatchSet(final com.google.gerrit.reviewdb.client.PatchSet patch, final com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.git.GitRepositoryManager gitManager, final com.google.gerrit.server.extensions.events.GitReferenceUpdated replication, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { final com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = patch.getId(); if ((patch == null) || (!(patch.isDraft()))) { throw new com.google.gerrit.server.project.NoSuchChangeException(patchSetId.getParentKey()); } org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject()); try { org.eclipse.jgit.lib.RefUpdate update = repo.updateRef(patch.getRefName()); update.setForceUpdate(true); update.disableRefLog(); switch (update.delete()) { case NEW : case FAST_FORWARD : case FORCED : case NO_CHANGE : break; default : throw new java.io.IOException(((((("Failed to delete ref " + (patch.getRefName())) + " in ") + (repo.getDirectory())) + ": ") + (update.getResult()))); } replication.fire(change.getProject(), update.getName()); } finally { repo.close(); } db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(patchSetId)); db.changeMessages().delete(db.changeMessages().byPatchSet(patchSetId)); db.patchComments().delete(db.patchComments().byPatchSet(patchSetId)); db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(patchSetId)); db.patchSetAncestors().delete(db.patchSetAncestors().byPatchSet(patchSetId)); db.patchSets().delete(java.util.Collections.singleton(patch)); }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit commitAt(org.eclipse.jgit.lib.ObjectId expected) throws java.io.IOException { if (com.google.common.base.Objects.equal(src, expected)) { return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(getRefName()); if (expected != null) { ru.setExpectedOldObjectId(expected); } else { ru.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); } ru.setNewObjectId(src); ru.disableRefLog(); inserter.flush(); switch (ru.update(rw)) { case NEW : case FAST_FORWARD : revision = rw.parseCommit(ru.getNewObjectId()); update.replicate(ru.getName()); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }
public void fire(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref) { com.google.gerrit.server.extensions.events.GitReferenceUpdated.Event event = new com.google.gerrit.server.extensions.events.GitReferenceUpdated.Event(project, ref); for (com.google.gerrit.extensions.events.GitReferenceUpdatedListener l : listeners) { l.onGitReferenceUpdated(event); } }
void replicate(java.lang.String ref) { replication.fire(projectName, ref); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Update> getUpdates() { com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Update update = new com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Update() { public java.lang.String getRefName() { return ref; } }; return com.google.common.collect.ImmutableList.of(update); }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit createRef(java.lang.String refName) throws java.io.IOException { if (com.google.common.base.Objects.equal(src, revision)) { return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(refName); ru.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); ru.setNewObjectId(src); ru.disableRefLog(); inserter.flush(); org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : revision = rw.parseCommit(ru.getNewObjectId()); update.replicate(ru.getName()); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }
private void createEmptyCommits(final org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.util.List<java.lang.String> refs) throws java.io.IOException { org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter(); try { org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[]{ })); cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent()); cb.setCommitter(serverIdent); cb.setMessage("Initial empty repository\n"); org.eclipse.jgit.lib.ObjectId id = oi.insert(cb); oi.flush(); for (java.lang.String ref : refs) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(ref); ru.setNewObjectId(id); final org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : referenceUpdated.fire(project, ref); break; default : { throw new java.io.IOException(java.lang.String.format("Failed to create ref \"%s\": %s", ref, result.name())); } } } } catch (java.io.IOException e) { com.google.gerrit.server.project.CreateProject.log.error(("Cannot create empty commit for " + (createProjectArgs.getProjectName())), e); throw e; } finally { oi.release(); } }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit createRef(java.lang.String refName) throws java.io.IOException { if (com.google.common.base.Objects.equal(src, revision)) { return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(refName); ru.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); ru.setNewObjectId(src); ru.disableRefLog(); inserter.flush(); org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : revision = rw.parseCommit(ru.getNewObjectId()); update.replicate(ru); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit commitAt(org.eclipse.jgit.lib.ObjectId expected) throws java.io.IOException { if (com.google.common.base.Objects.equal(src, expected)) { return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(getRefName()); if (expected != null) { ru.setExpectedOldObjectId(expected); } else { ru.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); } ru.setNewObjectId(src); ru.disableRefLog(); inserter.flush(); switch (ru.update(rw)) { case NEW : case FAST_FORWARD : revision = rw.parseCommit(ru.getNewObjectId()); update.replicate(ru); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }
void replicate(org.eclipse.jgit.lib.RefUpdate ru) { replication.fire(projectName, ru); }
public boolean isFile() { boolean isCommitMessage = Patch.COMMIT_MSG.equals(script.getNewName()); return !((isCommitMessage || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.A)) && (0 >= (script.getA().size())))) || (((side) == (com.google.gerrit.client.patches.PatchSetSelectBox.Side.B)) && (0 >= (script.getB().size())))); }
@java.lang.Override public void onDoubleClick(com.google.gwt.event.dom.client.DoubleClickEvent event) { if (headerSideB.isFile()) { createFileCommentEditorOnSideB(); } }
private void populateTableHeader(final com.google.gerrit.common.data.PatchScript script, final com.google.gerrit.common.data.PatchSetDetail detail) { initHeaders(script, detail); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.SideBySideTable.A, headerSideA); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.SideBySideTable.B, headerSideB); if (headerSideA.isFile()) { table.setWidget(com.google.gerrit.client.patches.R_HEAD, ((com.google.gerrit.client.patches.SideBySideTable.A) - 1), iconA); } if (headerSideB.isFile()) { table.setWidget(com.google.gerrit.client.patches.R_HEAD, ((com.google.gerrit.client.patches.SideBySideTable.B) + 1), iconB); } }
@java.lang.Override public void onDoubleClick(com.google.gwt.event.dom.client.DoubleClickEvent event) { if (headerSideA.isFile()) { createFileCommentEditorOnSideA(); } }
private void populateTableHeader(final com.google.gerrit.common.data.PatchScript script, final com.google.gerrit.common.data.PatchSetDetail detail) { initHeaders(script, detail); table.setWidget(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.UnifiedDiffTable.PC, headerSideA); table.setWidget(rowOfTableHeaderB, com.google.gerrit.client.patches.UnifiedDiffTable.PC, headerSideB); table.getFlexCellFormatter().addStyleName(com.google.gerrit.client.patches.R_HEAD, com.google.gerrit.client.patches.UnifiedDiffTable.PC, Gerrit.RESOURCES.css().unifiedTableHeader()); table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, com.google.gerrit.client.patches.UnifiedDiffTable.PC, Gerrit.RESOURCES.css().unifiedTableHeader()); if (headerSideA.isFile()) { table.setWidget(com.google.gerrit.client.patches.R_HEAD, 1, iconA); } if (headerSideB.isFile()) { table.setWidget(rowOfTableHeaderB, 2, iconB); } }
void insert(com.google.gerrit.client.groups.GroupInfo info) { java.util.Comparator<com.google.gerrit.client.groups.GroupInfo> c = new java.util.Comparator<com.google.gerrit.client.groups.GroupInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.groups.GroupInfo a, com.google.gerrit.client.groups.GroupInfo b) { int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name())); if (cmp != 0) { return cmp; } return a.getGroupUUID().compareTo(b.getGroupUUID()); } public java.lang.String nullToEmpty(java.lang.String str) { return str == null ? "" : str; } }; for (int row = 1; row < (table.getRowCount()); row++) { final com.google.gerrit.client.groups.GroupInfo i = getRowItem(row); if (i != null) { if ((c.compare(info, i)) == 0) { return; } if ((c.compare(info, i)) < 0) { table.insertRow(row); applyDataRowStyle(row); populate(row, info); return; } } } final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); populate(row, info); }
void insert(com.google.gerrit.client.groups.GroupInfo info) { java.util.Comparator<com.google.gerrit.client.groups.GroupInfo> c = new java.util.Comparator<com.google.gerrit.client.groups.GroupInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.groups.GroupInfo a, com.google.gerrit.client.groups.GroupInfo b) { int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name())); if (cmp != 0) { return cmp; } return a.getGroupUUID().compareTo(b.getGroupUUID()); } public java.lang.String nullToEmpty(java.lang.String str) { return str == null ? "" : str; } }; int insertPosition = table.getRowCount(); for (int row = 1; row < (table.getRowCount()); row++) { final com.google.gerrit.client.groups.GroupInfo i = getRowItem(row); if (i != null) { if ((c.compare(info, i)) == 0) { return; } if ((c.compare(info, i)) < 0) { insertPosition = row; break; } } } table.insertRow(insertPosition); applyDataRowStyle(insertPosition); populate(insertPosition, info); }
@java.lang.Override public int compare(com.google.gerrit.client.groups.GroupInfo a, com.google.gerrit.client.groups.GroupInfo b) { int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name())); if (cmp != 0) { return cmp; } return a.getGroupUUID().compareTo(b.getGroupUUID()); }
void insert(com.google.gerrit.client.groups.GroupInfo info) { java.util.Comparator<com.google.gerrit.client.groups.GroupInfo> c = new java.util.Comparator<com.google.gerrit.client.groups.GroupInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.groups.GroupInfo a, com.google.gerrit.client.groups.GroupInfo b) { int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name())); if (cmp != 0) { return cmp; } return a.getGroupUUID().compareTo(b.getGroupUUID()); } public java.lang.String nullToEmpty(java.lang.String str) { return str == null ? "" : str; } }; int insertPosition = table.getRowCount(); int left = 1; int right = (table.getRowCount()) - 1; while (left <= right) { int middle = (left + right) / 2; com.google.gerrit.client.groups.GroupInfo i = getRowItem(middle); int cmp = c.compare(i, info); if (cmp < 0) { left = middle + 1; } else if (cmp > 0) { right = middle - 1; } else { return; } } insertPosition = left; table.insertRow(insertPosition); applyDataRowStyle(insertPosition); populate(insertPosition, info); }
public java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> formatList2(java.util.List<java.util.List<com.google.gerrit.server.query.change.ChangeData>> in) throws com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> res = com.google.common.collect.Lists.newArrayListWithCapacity(in.size()); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> changes : in) { com.google.gerrit.server.query.change.ChangeData.ensureChangeLoaded(db, changes); com.google.gerrit.server.query.change.ChangeData.ensureCurrentPatchSetLoaded(db, changes); com.google.gerrit.server.query.change.ChangeData.ensureCurrentApprovalsLoaded(db, changes); res.add(toChangeInfo(changes)); } if (!(accounts.isEmpty())) { for (com.google.gerrit.reviewdb.client.Account account : db.get().accounts().get(accounts.keySet())) { com.google.gerrit.server.events.AccountAttribute a = accounts.get(account.getId()); a.name = com.google.common.base.Strings.emptyToNull(account.getFullName()); } } return res; }

private com.google.gerrit.server.change.ChangeJson.ChangeInfo toChangeInfo(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.change.ChangeJson.ChangeInfo out = new com.google.gerrit.server.change.ChangeJson.ChangeInfo(); com.google.gerrit.reviewdb.client.Change in = cd.change(db); out.project = in.getProject().get(); out.branch = in.getDest().getShortName(); out.topic = in.getTopic(); out.changeId = in.getKey().get(); out.subject = in.getSubject(); out.status = in.getStatus(); out.owner = asAccountAttribute(in.getOwner()); out.created = in.getCreatedOn(); out.updated = in.getLastUpdatedOn(); out._number = in.getId().get(); out._sortkey = in.getSortKey(); out.starred = (user.getStarredChanges().contains(in.getId())) ? true : null; out.reviewed = ((in.getStatus().isOpen()) && (isChangeReviewed(cd))) ? true : null; out.labels = (options.contains(com.google.gerrit.server.change.LABELS)) ? labelsFor(cd) : null; out.finish(); if ((options.contains(com.google.gerrit.server.change.ALL_REVISIONS)) || (options.contains(com.google.gerrit.server.change.CURRENT_REVISION))) { out.revisions = revisions(cd); for (java.lang.String commit : out.revisions.keySet()) { if (out.revisions.get(commit).isCurrent) { out.current_revision = commit; break; } } } return out; }


private com.google.gerrit.server.change.ChangeJson.ChangeInfo toChangeInfo(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.change.ChangeJson.ChangeInfo out = new com.google.gerrit.server.change.ChangeJson.ChangeInfo(); com.google.gerrit.reviewdb.client.Change in = cd.change(db); out.project = in.getProject().get(); out.branch = in.getDest().getShortName(); out.topic = in.getTopic(); out.changeId = in.getKey().get(); out.subject = in.getSubject(); out.status = in.getStatus(); out.owner = asAccountAttribute(in.getOwner()); out.created = in.getCreatedOn(); out.updated = in.getLastUpdatedOn(); out._number = in.getId().get(); out._sortkey = in.getSortKey(); out.starred = (user.getStarredChanges().contains(in.getId())) ? true : null; out.reviewed = ((in.getStatus().isOpen()) && (isChangeReviewed(cd))) ? true : null; out.labels = (options.contains(com.google.gerrit.server.change.LABELS)) ? labelsFor(cd) : null; out.finish(); if ((options.contains(com.google.gerrit.server.change.ALL_REVISIONS)) || (options.contains(com.google.gerrit.server.change.CURRENT_REVISION))) { out.revisions = revisions(cd); for (java.lang.String commit : out.revisions.keySet()) { if (out.revisions.get(commit).isCurrent) { out.current_revision = commit; break; } } } return out; }

public static void ensureCurrentPatchSetLoaded(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.server.query.change.ChangeData> missing = com.google.common.collect.Maps.newHashMap(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentPatchSet) == null) && ((cd.patches) == null)) { missing.put(cd.change(db).currentPatchSetId(), cd); } } if (!(missing.isEmpty())) { for (com.google.gerrit.reviewdb.client.PatchSet ps : db.get().patchSets().get(missing.keySet())) { com.google.gerrit.server.query.change.ChangeData cd = missing.get(ps.getId()); cd.currentPatchSet = ps; cd.patches = com.google.common.collect.Lists.newArrayList(ps); } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> patches(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((patches) == null) { patches = db.get().patchSets().byChange(legacyId).toList(); } return patches; }

private com.google.gerrit.server.change.ChangeJson.ChangeInfo toChangeInfo(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.change.ChangeJson.ChangeInfo out = new com.google.gerrit.server.change.ChangeJson.ChangeInfo(); com.google.gerrit.reviewdb.client.Change in = cd.change(db); out.project = in.getProject().get(); out.branch = in.getDest().getShortName(); out.topic = in.getTopic(); out.changeId = in.getKey().get(); out.subject = in.getSubject(); out.status = in.getStatus(); out.owner = asAccountAttribute(in.getOwner()); out.created = in.getCreatedOn(); out.updated = in.getLastUpdatedOn(); out._number = in.getId().get(); out._sortkey = in.getSortKey(); out.starred = (user.getStarredChanges().contains(in.getId())) ? true : null; out.reviewed = ((in.getStatus().isOpen()) && (isChangeReviewed(cd))) ? true : null; if ((options.contains(com.google.gerrit.server.change.LABELS)) || (options.contains(com.google.gerrit.server.change.DETAILED_LABELS))) { out.labels = labelsFor(cd, options.contains(com.google.gerrit.server.change.DETAILED_LABELS)); } out.finish(); if ((options.contains(com.google.gerrit.server.change.ALL_REVISIONS)) || (options.contains(com.google.gerrit.server.change.CURRENT_REVISION))) { out.revisions = revisions(cd); for (java.lang.String commit : out.revisions.keySet()) { if (out.revisions.get(commit).isCurrent) { out.current_revision = commit; break; } } } return out; }


public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { com.google.gerrit.reviewdb.client.Change c = change(db); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else if ((approvals) != null) { java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval>> map = approvalsMap(db); currentApprovals = map.get(c.currentPatchSetId()); if ((currentApprovals) == null) { currentApprovals = java.util.Collections.emptyList(); map.put(c.currentPatchSetId(), currentApprovals); } } else { currentApprovals = db.get().patchSetApprovals().byPatchSet(c.currentPatchSetId()).toList(); } } return currentApprovals; }
public java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval>> approvalsMap(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((approvalsMap) == null) { java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> all = approvals(db); approvalsMap = new java.util.HashMap<com.google.gerrit.reviewdb.client.PatchSet.Id, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval>>(all.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : all) { java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> c = approvalsMap.get(psa.getPatchSetId()); if (c == null) { c = new java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchSetApproval>(); approvalsMap.put(psa.getPatchSetId(), c); } c.add(psa); } } return approvalsMap; }
private java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return java.util.Collections.emptyMap(); } java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> src; if (options.contains(com.google.gerrit.server.change.ALL_REVISIONS)) { src = cd.patches(db); } else { src = java.util.Collections.singletonList(cd.currentPatchSet(db)); } java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> res = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.reviewdb.client.PatchSet in : src) { if (ctl.isPatchVisible(in, db.get())) { res.put(in.getRevision().get(), toRevisionInfo(cd, in)); } } return res; }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((approvals) == null) { approvals = db.get().patchSetApprovals().byChange(legacyId).toList(); } return approvals; }
@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.rpc.CallbackGroup cbs = new com.google.gerrit.client.rpc.CallbackGroup(); Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchSetPublishDetail>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.PatchSetPublishDetail result) { send.setEnabled(true); display(result); } @java.lang.Override protected void postDisplay() { message.setFocus(true); } })); }
private void onSend2(final boolean submit) { com.google.gerrit.client.changes.PublishCommentScreen.ReviewInput data = com.google.gerrit.client.changes.PublishCommentScreen.ReviewInput.create(); data.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(message.getText().trim())); data.init(); for (final com.google.gerrit.client.changes.PublishCommentScreen.ValueRadioButton b : approvalButtons) { if (b.getValue()) { data.label(b.category.getLabelName(), b.value.getValue()); } } enableForm(false); new com.google.gerrit.client.rpc.RestApi("/changes/").id(java.lang.String.valueOf(patchSetId.getParentKey().get())).view("revisions").id(revision).view("review").post(data, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.PublishCommentScreen.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.PublishCommentScreen.ReviewInput result) { if (submit) { submit(); } else { saveStateOnUnload = false; goChange(); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { super.onFailure(caught); enableForm(true); } }); }










public static void my(com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.groups.GroupList> callback) { new com.google.gerrit.client.rpc.RestApi("/accounts/self/groups").get(callback); }

@java.lang.Override public java.util.List<com.google.gerrit.server.group.GroupInfo> apply(com.google.gerrit.server.account.AccountResource resource) { com.google.gerrit.server.IdentifiedUser user = resource.getUser(); com.google.gerrit.reviewdb.client.Account.Id userId = user.getAccountId(); java.util.List<com.google.gerrit.server.group.GroupInfo> groups = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) { com.google.gerrit.server.account.GroupControl ctl; try { ctl = groupControlFactory.controlFor(uuid); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { continue; } if ((ctl.isVisible()) && (ctl.canSeeMember(userId))) { groups.add(new com.google.gerrit.server.group.GroupInfo(ctl.getGroup())); } } return groups; }

@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.Exception { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } else if (!(user instanceof com.google.gerrit.server.IdentifiedUser)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return parse(id.get()); }
public java.io.Reader get(java.lang.String endPoint) throws java.io.IOException { org.apache.http.client.methods.HttpGet get = new org.apache.http.client.methods.HttpGet(("http://localhost:8080/a" + endPoint)); org.apache.http.HttpResponse response = getClient().execute(get); java.io.Reader reader = new java.io.InputStreamReader(response.getEntity().getContent()); reader.skip(4); return reader; }


@java.lang.Override public void changeUserName(final java.lang.String newName, final com.google.gwtjsonrpc.common.AsyncCallback<com.google.gwtjsonrpc.common.VoidResult> callback) { if (realm.allowsEdit(Account.FieldName.USER_NAME)) { com.google.gerrit.httpd.rpc.Handler.wrap(changeUserNameFactory.create(newName)).to(callback); } else { callback.onFailure(new com.google.gerrit.common.errors.NameAlreadyUsedException()); } }

@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); final com.google.inject.Provider<org.apache.sshd.server.Command> p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": ") + (commandName)) + ": not found"; throw new com.google.gerrit.sshd.UnloggedFailure(1, msg); } final org.apache.sshd.server.Command cmd = p.get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) bc.setName(commandName); else bc.setName((((getName()) + " ") + (commandName))); bc.setArguments(args.toArray(new java.lang.String[args.size()])); } else if (!(args.isEmpty())) { throw new com.google.gerrit.sshd.UnloggedFailure(1, ((commandName) + " does not take arguments")); } provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes(com.google.gerrit.sshd.ENC)); err.flush(); onExit(e.exitCode); } }
private void checkRequiresCapability(org.apache.sshd.server.Command cmd) throws com.google.gerrit.sshd.UnloggedFailure { com.google.gerrit.extensions.annotations.RequiresCapability rc = cmd.getClass().getAnnotation(com.google.gerrit.extensions.annotations.RequiresCapability.class); if (rc != null) { com.google.gerrit.server.CurrentUser user = currentUser.get(); com.google.gerrit.server.account.CapabilityControl ctl = user.getCapabilities(); if ((!(ctl.canPerform(rc.value()))) && (!(ctl.canAdministrateServer()))) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value()); throw new com.google.gerrit.sshd.UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg); } } }
@java.lang.Override protected java.lang.String usage() { final java.lang.StringBuilder usage = new java.lang.StringBuilder(); usage.append("Available commands"); if (!(getName().isEmpty())) { usage.append(" of "); usage.append(getName()); } usage.append(" are:\n"); usage.append("\n"); for (java.lang.String name : com.google.common.collect.Sets.newTreeSet(commands.keySet())) { usage.append(" "); usage.append(name); usage.append("\n"); } usage.append("\n"); usage.append("See '"); if ((getName().indexOf(' ')) < 0) { usage.append(getName()); usage.append(' '); } usage.append("COMMAND --help\' for more information.\n"); usage.append("\n"); return usage.toString(); }
private java.lang.String getComment(com.google.gerrit.server.events.ChangeAttribute change, com.google.gerrit.server.events.ChangeEvent hook, com.google.gerrit.server.events.AccountAttribute who, java.lang.String what) { return (((((getCommentPrefix(change)) + "change ") + what) + " [by ") + who) + "]"; }

@java.lang.Override public java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> apply(final com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { try { final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.group.MembersCollection.MemberInfo> members = getMembers(resource.getGroupUUID(), new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>()); final java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> memberInfos = com.google.common.collect.Lists.newArrayList(members.values()); java.util.Collections.sort(memberInfos, new java.util.Comparator<com.google.gerrit.server.group.MembersCollection.MemberInfo>() { @java.lang.Override public int compare(com.google.gerrit.server.group.MembersCollection.MemberInfo a, com.google.gerrit.server.group.MembersCollection.MemberInfo b) { return com.google.common.collect.ComparisonChain.start().compare(a.fullName, b.fullName, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.preferredEmail, b.preferredEmail, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.id, b.id, com.google.common.collect.Ordering.natural().nullsFirst()).result(); } }); return memberInfos; } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(resource.getGroupUUID().get()); } }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { com.google.gerrit.reviewdb.client.Change c = change(db); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else if (((approvals) != null) && (((limitedIds) == null) || (limitedIds.contains(c.currentPatchSetId())))) { return approvals.get(c.currentPatchSetId()); } else { currentApprovals = com.google.gerrit.server.query.change.ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSet(c.currentPatchSetId())); } } return currentApprovals; }
private java.util.Collection<com.google.gerrit.server.change.AccountInfo> removableReviewers(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return com.google.common.collect.ImmutableList.of(); } com.google.gerrit.reviewdb.client.Change change = ctl.getChange(); if ((!(change.getStatus().isOpen())) || (!((ctl.getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser))) { return com.google.common.collect.ImmutableList.of(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> fixed = com.google.common.collect.Sets.newHashSet(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> removable = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.PatchSetApproval app : cd.currentApprovals(db)) { if (ctl.canRemoveReviewer(app)) { removable.add(app.getAccountId()); } else { fixed.add(app.getAccountId()); } } removable.removeAll(fixed); java.util.List<com.google.gerrit.server.change.AccountInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(removable.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : removable) { result.add(accountLoader.get(id)); } return result; }
@org.junit.Test public void testCreateGroupWhenGroupAlreadyExists_PreconditionFailed() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.put("/groups/Administrators"); assertEquals(HttpStatus.SC_PRECONDITION_FAILED, r.getStatusCode()); }

public static boolean isMagicBranch(java.lang.String refName) { if (((refName.startsWith(com.google.gerrit.server.util.MagicBranch.NEW_DRAFT_CHANGE)) || (refName.startsWith(com.google.gerrit.server.util.MagicBranch.NEW_PUBLISH_CHANGE))) || (refName.startsWith(com.google.gerrit.server.util.MagicBranch.NEW_CHANGE))) { return true; } return false; }



@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final com.google.gerrit.reviewdb.client.Account.Id accountId; try { final com.google.gerrit.reviewdb.client.Account a = accountResolver.find(token); if (a != null) { accountId = a.getId(); } else { switch (authType) { case HTTP_LDAP : case CLIENT_SSL_CERT_LDAP : case LDAP : accountId = createAccountByLdap(token); break; default : throw new org.kohsuke.args4j.CmdLineException(owner, (("user \"" + token) + "\" not found")); } } } catch (com.google.gwtorm.server.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "database is down"); } setter.addValue(accountId); return 1; }













@java.lang.Override public com.google.gerrit.server.change.RevisionResource parse(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.PatchSet> match = com.google.common.collect.Lists.newArrayListWithExpectedSize(2); for (com.google.gerrit.reviewdb.client.PatchSet ps : find(change, id.get())) { com.google.gerrit.reviewdb.client.Change.Id changeId = ps.getId().getParentKey(); if ((changeId.equals(change.getChange().getId())) && (change.getControl().isPatchVisible(ps, dbProvider.get()))) { match.add(ps); } } if ((match.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.change.RevisionResource(change, match.get(0)); }

@java.lang.Override public com.google.gerrit.server.group.GroupJson.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) { return json.addOption(com.google.gerrit.server.group.OWNER).format(resource.getGroup()); }
@java.lang.Override public com.google.gerrit.server.group.GroupJson.GroupInfo apply(com.google.gerrit.extensions.restapi.TopLevelResource resource, com.google.gerrit.server.group.CreateGroup.Input input) throws com.google.gerrit.common.errors.NameAlreadyUsedException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.group.CreateGroup.Input(); } if (((input.name) != null) && (!(name.equals(input.name)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("name must match URL"); } com.google.gerrit.reviewdb.client.AccountGroup.Id ownerId = owner(input); com.google.gerrit.reviewdb.client.AccountGroup group; try { group = op.create().createGroup(name, com.google.common.base.Strings.emptyToNull(input.description), com.google.common.base.Objects.firstNonNull(input.visibleToAll, defaultVisibleToAll), ownerId, (ownerId == null ? java.util.Collections.singleton(self.get().getAccountId()) : java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()), null); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } return json.addOption(com.google.gerrit.server.group.OWNER).format(com.google.gerrit.common.data.GroupDescriptions.forAccountGroup(group)); }
@java.lang.Override public com.google.gerrit.server.group.GroupJson.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.reviewdb.client.AccountGroup group = resource.toAccountGroup(); if (group == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try { com.google.gerrit.server.account.GroupControl c = controlFactory.validateFor(group.getOwnerGroupUUID()); return json.addOption(com.google.gerrit.server.group.OWNER).format(c.getGroup()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> apply(final com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.group.MembersCollection.MemberInfo> members = getMembers(resource.getGroupUUID(), new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>()); final java.util.List<com.google.gerrit.server.group.MembersCollection.MemberInfo> memberInfos = com.google.common.collect.Lists.newArrayList(members.values()); java.util.Collections.sort(memberInfos, new java.util.Comparator<com.google.gerrit.server.group.MembersCollection.MemberInfo>() { @java.lang.Override public int compare(com.google.gerrit.server.group.MembersCollection.MemberInfo a, com.google.gerrit.server.group.MembersCollection.MemberInfo b) { return com.google.common.collect.ComparisonChain.start().compare(a.fullName, b.fullName, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.preferredEmail, b.preferredEmail, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.id, b.id, com.google.common.collect.Ordering.natural().nullsFirst()).result(); } }); return memberInfos; }

@java.lang.Override public com.google.gerrit.server.group.GroupJson.GroupInfo apply(com.google.gerrit.server.group.IncludedGroupResource rsrc) { return json.addOption(com.google.gerrit.server.group.OWNER).format(rsrc.getMemberDescription()); }
@java.lang.Override public com.google.gerrit.server.change.ReviewerJson.PostResult apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.PostReviewers.Input input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account.Id accountId = parser.parse(rsrc, input.reviewer); try { if (accountId != null) { return putAccount(reviewerFactory.create(rsrc, accountId)); } else { return putGroup(rsrc, input); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } }
private void initProjectOptions() { projectOptionsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); projectOptionsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingProjectOptions())); submitType = new com.google.gwt.user.client.ui.ListBox(); for (final com.google.gerrit.reviewdb.client.Project.SubmitType type : Project.SubmitType.values()) { submitType.addItem(com.google.gerrit.client.admin.Util.toLongString(type), type.name()); } submitType.addChangeHandler(new com.google.gwt.event.dom.client.ChangeHandler() { @java.lang.Override public void onChange(com.google.gwt.event.dom.client.ChangeEvent event) { setEnabledForUseContentMerge(); } }); saveEnabler.listenTo(submitType); projectOptionsPanel.add(submitType); state = new com.google.gwt.user.client.ui.ListBox(); for (final com.google.gerrit.reviewdb.client.Project.State stateValue : Project.State.values()) { state.addItem(com.google.gerrit.client.admin.Util.toLongString(stateValue), stateValue.name()); } saveEnabler.listenTo(state); projectOptionsPanel.add(state); contentMerge = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(contentMerge); fp.add(new com.google.gwt.user.client.ui.InlineLabel(Util.C.useContentMerge())); saveEnabler.listenTo(contentMerge); projectOptionsPanel.add(fp); requireChangeID = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(requireChangeID); fp.add(new com.google.gwt.user.client.ui.InlineHTML(Util.C.requireChangeID())); saveEnabler.listenTo(requireChangeID); projectOptionsPanel.add(fp); add(projectOptionsPanel); }

private void initAgreements() { agreementsPanel = new com.google.gwt.user.client.ui.VerticalPanel(); agreementsPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingAgreements())); contributorAgreements = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); if (com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()) { com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(contributorAgreements); fp.add(new com.google.gwt.user.client.ui.InlineLabel(Util.C.useContributorAgreements())); saveEnabler.listenTo(contributorAgreements); agreementsPanel.add(fp); } signedOffBy = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(signedOffBy); fp.add(new com.google.gwt.user.client.ui.InlineHTML(Util.C.useSignedOffBy())); saveEnabler.listenTo(signedOffBy); agreementsPanel.add(fp); add(agreementsPanel); }
private void loadPermissionRules(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String varName, java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName, com.google.gerrit.common.data.Permission perm, boolean useRange) { for (java.lang.String ruleString : rc.getStringList(section, subsection, varName)) { com.google.gerrit.common.data.PermissionRule rule; try { rule = com.google.gerrit.common.data.PermissionRule.fromString(ruleString, useRange); } catch (java.lang.IllegalArgumentException notRule) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((((("Invalid rule in " + section) + (subsection != null ? "." + subsection : "")) + ".") + varName) + ": ") + (notRule.getMessage())))); continue; } com.google.gerrit.common.data.GroupReference ref = groupsByName.get(rule.getGroup().getName()); if (ref == null) { ref = rule.getGroup(); groupsByName.put(ref.getName(), ref); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("group \"" + (ref.getName())) + "\" not in ") + (com.google.gerrit.server.git.ProjectConfig.GROUP_LIST)))); } rule.setGroup(ref); perm.add(rule); } }
@org.junit.Test public void testEditConfigMissingGroupTableEntry() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = util.commit(util.tree(util.file("groups", util.blob(com.google.gerrit.server.git.ProjectConfigTest.group(developers))), util.file("project.config", util.blob(("" + (((("[access \"refs/heads/*\"]\n" + " exclusiveGroupPermissions = read submit\n") + " submit = group People Who Can Submit\n") + " upload = group Developers\n") + " read = group Developers\n")))))); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.common.data.AccessSection section = cfg.getAccessSection("refs/heads/*"); com.google.gerrit.common.data.Permission submit = section.getPermission(Permission.SUBMIT); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))); rev = commit(cfg); assertEquals(("" + ((((((("[access \"refs/heads/*\"]\n" + " exclusiveGroupPermissions = read submit\n") + " submit = group People Who Can Submit\n") + "\tsubmit = group Staff\n") + " upload = group Developers\n") + " read = group Developers\n") + "[project]\n") + "\tstate = active\n")), text(rev, "project.config")); }
private static void configureDefaults(java.util.Map<java.lang.String, java.util.List<com.google.gerrit.common.data.PermissionRule>> out, com.google.gerrit.common.data.AccessSection section) { com.google.gerrit.server.account.CapabilityCollection.configureDefault(out, section, GlobalCapability.QUERY_LIMIT, com.google.gerrit.server.account.CapabilityCollection.anonymous); }
private static void configureDefault(java.util.Map<java.lang.String, java.util.List<com.google.gerrit.common.data.PermissionRule>> out, com.google.gerrit.common.data.AccessSection section, java.lang.String capName, com.google.gerrit.common.data.GroupReference group) { if (com.google.gerrit.server.account.CapabilityCollection.doesNotDeclare(section, capName)) { com.google.gerrit.common.data.PermissionRange.WithDefaults range = com.google.gerrit.common.data.GlobalCapability.getRange(capName); if (range != null) { com.google.gerrit.common.data.PermissionRule rule = new com.google.gerrit.common.data.PermissionRule(group); rule.setRange(range.getDefaultMin(), range.getDefaultMax()); out.put(capName, java.util.Collections.singletonList(rule)); } } }
void mergeFrom(com.google.gerrit.common.data.Permission src) { for (com.google.gerrit.common.data.PermissionRule srcRule : src.getRules()) { com.google.gerrit.common.data.PermissionRule dstRule = getRule(srcRule.getGroup()); if (dstRule != null) { dstRule.mergeFrom(srcRule); } else { add(srcRule); } } }
private static com.google.gerrit.common.data.PermissionRule rule(com.google.gerrit.common.data.GroupReference group) { return new com.google.gerrit.common.data.PermissionRule(group); }
private void addGroup(com.google.gerrit.common.data.GroupReference ref) { if ((ref.getUUID()) != null) { if ((value.getRule(ref)) == null) { com.google.gerrit.common.data.PermissionRule newRule = value.getRule(ref, true); if ((validRange) != null) { int min = validRange.getDefaultMin(); int max = validRange.getDefaultMax(); newRule.setRange(min, max); } else if (GlobalCapability.PRIORITY.equals(value.getName())) { newRule.setAction(PermissionRule.Action.BATCH); } rules.getList().add(newRule); } groupToAdd.setValue(null); groupToAdd.setFocus(true); } else { addRule.setEnabled(false); SuggestUtil.SVC.suggestAccountGroupForProject(projectName, ref.getName(), 1, new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.GroupReference>>() { @java.lang.Override public void onSuccess(java.util.List<com.google.gerrit.common.data.GroupReference> result) { addRule.setEnabled(true); if ((result.size()) == 1) { addGroup(result.get(0)); } else { groupToAdd.setFocus(true); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { addRule.setEnabled(true); super.onFailure(caught); } }); } }
public com.google.gerrit.common.data.PermissionRule getRule(com.google.gerrit.common.data.GroupReference group, boolean create) { initRules(); for (com.google.gerrit.common.data.PermissionRule r : rules) { if (com.google.gerrit.common.data.Permission.sameGroup(r, group)) { return r; } } if (create) { com.google.gerrit.common.data.PermissionRule r = new com.google.gerrit.common.data.PermissionRule(group); rules.add(r); return r; } else { return null; } }
public com.google.gerrit.common.data.PermissionRule getRule(com.google.gerrit.common.data.GroupReference group) { return getRule(group, false); }
private void createProjectConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { final com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject()); try { final com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.load(md); com.google.gerrit.reviewdb.client.Project newProject = config.getProject(); newProject.setDescription(createProjectArgs.projectDescription); newProject.setSubmitType(createProjectArgs.submitType); newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements); newProject.setUseSignedOffBy(createProjectArgs.signedOffBy); newProject.setUseContentMerge(createProjectArgs.contentMerge); newProject.setRequireChangeID(createProjectArgs.changeIdRequired); if ((createProjectArgs.newParent) != null) { newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey()); } if (!(createProjectArgs.ownerIds.isEmpty())) { final com.google.gerrit.common.data.AccessSection all = config.getAccessSection(AccessSection.ALL, true); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerId : createProjectArgs.ownerIds) { com.google.gerrit.common.data.GroupDescription.Basic g = groupBackend.get(ownerId); if (g != null) { com.google.gerrit.common.data.GroupReference group = config.resolve(com.google.gerrit.common.data.GroupReference.forGroup(g)); all.getPermission(Permission.OWNER, true).add(new com.google.gerrit.common.data.PermissionRule(group)); } } } md.setMessage("Created project\n"); config.commit(md); } finally { md.close(); } projectCache.onCreateProject(createProjectArgs.getProject()); repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription); }
private com.google.gerrit.common.data.PermissionRule rule(com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.reviewdb.client.AccountGroup group) { return new com.google.gerrit.common.data.PermissionRule(config.resolve(group)); }
private com.google.gerrit.common.data.PermissionRule newRule(com.google.gerrit.server.git.ProjectConfig project, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { com.google.gerrit.common.data.GroupReference group = new com.google.gerrit.common.data.GroupReference(groupUUID, groupUUID.get()); group = project.resolve(group); return new com.google.gerrit.common.data.PermissionRule(group); }
private static com.google.gerrit.common.data.PermissionRule deny(com.google.gerrit.common.data.GroupReference group) { com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.schema.Schema_53.rule(group); rule.setDeny(); return rule; }
boolean canPerform(java.lang.String permissionName) { java.util.List<com.google.gerrit.common.data.PermissionRule> access = access(permissionName); for (com.google.gerrit.common.data.PermissionRule rule : access) { if ((rule.isBlock()) && (!(rule.getForce()))) { return false; } } return !(access.isEmpty()); }



public boolean isVisibleByRegisteredUsers() { java.util.List<com.google.gerrit.common.data.PermissionRule> access = relevant.getPermission(Permission.READ); for (com.google.gerrit.common.data.PermissionRule rule : access) { if (rule.isBlock()) { return false; } } for (com.google.gerrit.common.data.PermissionRule rule : access) { if ((rule.getGroup().getUUID().equals(AccountGroup.ANONYMOUS_USERS)) || (rule.getGroup().getUUID().equals(AccountGroup.REGISTERED_USERS))) { return true; } } return false; }

private static com.google.gerrit.common.data.PermissionRange toRange(java.lang.String permissionName, java.util.List<com.google.gerrit.common.data.PermissionRule> ruleList) { int min = 0; int max = 0; int blockMin = java.lang.Integer.MIN_VALUE; int blockMax = java.lang.Integer.MAX_VALUE; for (com.google.gerrit.common.data.PermissionRule rule : ruleList) { if (rule.isBlock()) { blockMin = java.lang.Math.max(blockMin, rule.getMin()); blockMax = java.lang.Math.min(blockMax, rule.getMax()); } else { min = java.lang.Math.min(min, rule.getMin()); max = java.lang.Math.max(max, rule.getMax()); } } if (blockMin > (java.lang.Integer.MIN_VALUE)) { min = java.lang.Math.max(min, (blockMin + 1)); } if (blockMax < (java.lang.Integer.MAX_VALUE)) { max = java.lang.Math.min(max, (blockMax - 1)); } return new com.google.gerrit.common.data.PermissionRange(permissionName, min, max); }

private java.util.Map<java.lang.String, java.util.Collection<java.lang.String>> permittedLabels(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> permitted = com.google.common.collect.LinkedListMultimap.create(); for (com.google.gerrit.common.data.SubmitRecord rec : submitRecords(cd)) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label r : rec.labels) { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(r.label); if (type == null) { continue; } com.google.gerrit.common.data.PermissionRange range = ctl.getRange(com.google.gerrit.common.data.Permission.forLabel(r.label)); for (com.google.gerrit.common.data.LabelValue v : type.getValues()) { if (range.contains(v.getValue())) { permitted.put(r.label, v.formatValue()); } } } } java.util.List<java.lang.String> toClear = com.google.common.collect.Lists.newArrayListWithCapacity(permitted.keySet().size()); for (java.util.Map.Entry<java.lang.String, java.util.Collection<java.lang.String>> e : permitted.asMap().entrySet()) { if (com.google.gerrit.server.change.ChangeJson.isOnlyZero(e.getValue())) { toClear.add(e.getKey()); } } for (java.lang.String label : toClear) { permitted.removeAll(label); } return permitted.asMap(); }
private java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.LabelInfo> labelsFor(com.google.gerrit.server.query.change.ChangeData cd, boolean standard, boolean detailed) throws com.google.gwtorm.server.OrmException { if ((!standard) && (!detailed)) { return null; } com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(db); if (ps == null) { return java.util.Collections.emptyMap(); } if (cd.getChange().getStatus().isOpen()) { return labelsForOpenChange(cd, standard, detailed); } else { return labelsForClosedChange(cd, standard, detailed); } }
private java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return java.util.Collections.emptyMap(); } java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> src; if (((cd.getLimitedPatchSets()) != null) || (options.contains(com.google.gerrit.server.change.ALL_REVISIONS))) { src = cd.patches(db); } else { src = java.util.Collections.singletonList(cd.currentPatchSet(db)); } java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> res = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.reviewdb.client.PatchSet in : src) { if (ctl.isPatchVisible(in, db.get())) { res.put(in.getRevision().get(), toRevisionInfo(cd, in)); } } return res; }
private java.util.Collection<com.google.gerrit.server.account.AccountInfo> removableReviewers(com.google.gerrit.server.query.change.ChangeData cd, java.util.Collection<com.google.gerrit.server.change.ChangeJson.LabelInfo> labels) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return com.google.common.collect.ImmutableList.of(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> fixed = com.google.common.collect.Sets.newHashSetWithExpectedSize(labels.size()); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> removable = com.google.common.collect.Sets.newHashSetWithExpectedSize(labels.size()); for (com.google.gerrit.server.change.ChangeJson.LabelInfo label : labels) { if ((label.all) == null) { continue; } for (com.google.gerrit.server.change.ChangeJson.ApprovalInfo ai : label.all) { if (ctl.canRemoveReviewer(ai._id, ai.value)) { removable.add(ai._id); } else { fixed.add(ai._id); } } } removable.removeAll(fixed); java.util.List<com.google.gerrit.server.account.AccountInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(removable.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : removable) { result.add(accountLoader.get(id)); } return result; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.server.project.ProjectControl ctl; try { ctl = controlFactory.controlFor(new com.google.gerrit.reviewdb.client.Project.NameKey(id), user.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } if ((!(ctl.isVisible())) && (!(ctl.isOwner()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.project.ProjectResource(ctl); }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { return parse(id.get()); }
@java.lang.Override public com.google.gerrit.server.group.IncludedGroupResource parse(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup parent = resource.toAccountGroup(); if (parent == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.common.data.GroupDescription.Basic member = groupsCollection.get().parse(id.get()); if ((isMember(parent, member)) && (resource.getControl().canSeeGroup(member.getGroupUUID()))) { return new com.google.gerrit.server.group.IncludedGroupResource(resource, member); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public GroupDescription.Basic parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(id); if (groupBackend.handles(uuid)) { com.google.gerrit.common.data.GroupDescription.Basic d = groupBackend.get(uuid); if (d != null) { return d; } } if (id.matches("^[1-9][0-9]*$")) { try { com.google.gerrit.reviewdb.client.AccountGroup.Id legacyId = AccountGroup.Id.parse(id); return groupControlFactory.controlFor(legacyId).getGroup(); } catch (java.lang.IllegalArgumentException invalidId) { } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { } } com.google.gerrit.common.data.GroupReference ref = com.google.gerrit.server.account.GroupBackends.findExactSuggestion(groupBackend, id); if (ref != null) { com.google.gerrit.common.data.GroupDescription.Basic d = groupBackend.get(ref.getUUID()); if (d != null) { return d; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.Exception { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } else if (!(user instanceof com.google.gerrit.server.IdentifiedUser)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(parse(id.get())); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.group.GroupResource(ctl); }
private AccountGroup.Id owner(com.google.gerrit.server.group.CreateGroup.Input input) throws com.google.gerrit.extensions.restapi.BadRequestException { if ((input.ownerId) != null) { try { com.google.gerrit.common.data.GroupDescription.Basic d = groups.parse(com.google.gerrit.extensions.restapi.Url.decode(input.ownerId)); com.google.gerrit.reviewdb.client.AccountGroup owner = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(d); if (owner == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("ownerId must be internal group"); } return owner.getId(); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException("ownerId cannot be resolved"); } } return null; }
private com.google.gwt.http.client.RequestBuilder request(com.google.gwt.http.client.RequestBuilder.Method method) { com.google.gwt.http.client.RequestBuilder req = new com.google.gwt.http.client.RequestBuilder(method, url()); if ((ifNoneMatch) != null) { req.setHeader("If-None-Match", ifNoneMatch); } req.setHeader("Accept", com.google.gerrit.client.rpc.RestApi.JSON_TYPE); if ((com.google.gerrit.client.Gerrit.getAuthorization()) != null) { req.setHeader("Authorization", com.google.gerrit.client.Gerrit.getAuthorization()); } return req; }
private void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.ChangeUtil.insertAncestors(db, ps.getId(), commit); db.patchSets().insert(java.util.Collections.singleton(ps)); db.changes().insert(java.util.Collections.singleton(change)); com.google.gerrit.server.ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines); approvalsUtil.addReviewers(db, change, ps, info, recipients.getReviewers(), java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); db.commit(); } finally { db.rollback(); } created = true; gitRefUpdated.fire(project.getNameKey(), ps.getRefName(), org.eclipse.jgit.lib.ObjectId.zeroId(), commit); hooks.doPatchsetCreatedHook(change, ps, db); workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change); cm.setFrom(me); cm.setPatchSet(ps, info); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot send email for new change " + (change.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newchange"; } })); }


@java.lang.Override public void doFilter(final javax.servlet.ServletRequest request, final javax.servlet.ServletResponse response, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if (!(webSession.get().isSignedIn())) { final javax.servlet.http.HttpServletRequest req = ((javax.servlet.http.HttpServletRequest) (request)); final javax.servlet.http.HttpServletResponse rsp = ((javax.servlet.http.HttpServletResponse) (response)); final byte[] tosend; if (com.google.gwtjsonrpc.server.RPCServletUtils.acceptsGzipEncoding(req)) { rsp.setHeader("Content-Encoding", "gzip"); tosend = signInGzip; } else { tosend = signInRaw; } com.google.gwtexpui.server.CacheHeaders.setNotCacheable(rsp); rsp.setContentType("text/html"); rsp.setCharacterEncoding(HtmlDomUtil.ENC); rsp.setContentLength(tosend.length); final java.io.OutputStream out = rsp.getOutputStream(); try { out.write(tosend); } finally { out.close(); } } else { chain.doFilter(request, response); } }

public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail); if (m.matches()) { return java.util.Collections.singleton(Account.Id.parse(m.group(1))); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { return java.util.Collections.singleton(Account.Id.parse(nameOrEmail)); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.AccountState who = byId.getByUsername(nameOrEmail); if (who != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(nameOrEmail); }
public com.google.gerrit.server.git.SubmitStrategy create(final com.google.gerrit.reviewdb.client.Project.SubmitType submitType, final com.google.gerrit.reviewdb.server.ReviewDb db, final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.lib.ObjectInserter inserter, final org.eclipse.jgit.revwalk.RevFlag canMergeFlag, final java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted, final com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, final boolean useContentMerge) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { final com.google.gerrit.server.git.SubmitStrategy.Arguments args = new com.google.gerrit.server.git.SubmitStrategy.Arguments(identifiedUserFactory, myIdent, db, repo, rw, inserter, canMergeFlag, alreadyAccepted, destBranch, useContentMerge); switch (submitType) { case CHERRY_PICK : return new com.google.gerrit.server.git.CherryPick(args, patchSetInfoFactory, urlProvider, getLabelTypes(destBranch), gitRefUpdated); case FAST_FORWARD_ONLY : return new com.google.gerrit.server.git.FastForwardOnly(args); case MERGE_ALWAYS : return new com.google.gerrit.server.git.MergeAlways(args); case MERGE_IF_NECESSARY : return new com.google.gerrit.server.git.MergeIfNecessary(args); case REBASE_IF_NECESSARY : return new com.google.gerrit.server.git.RebaseIfNecessary(args, rebaseChange); default : final java.lang.String errorMsg = "No submit strategy for: " + submitType; com.google.gerrit.server.git.SubmitStrategyFactory.log.error(errorMsg); throw new com.google.gerrit.server.git.MergeException(errorMsg); } }

private java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.LabelInfo> labelsFor(com.google.gerrit.server.query.change.ChangeData cd, boolean standard, boolean detailed) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(db); if (ps == null) { return java.util.Collections.emptyMap(); } com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getLabelTypes(); java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.LabelInfo> labels = com.google.common.collect.Maps.newTreeMap(com.google.gerrit.server.change.LabelOrdering.create(labelTypes)); initLabels(cd, labels, standard); java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = null; if (detailed) { approvals = cd.currentApprovals(db); setAllApprovals(cd, labels, approvals); } for (java.util.Map.Entry<java.lang.String, com.google.gerrit.server.change.ChangeJson.LabelInfo> e : labels.entrySet()) { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(e.getKey()); if (type == null) { continue; } if (standard) { approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue()); } if (detailed) { setLabelValues(type, e.getValue()); } } return labels; }

private static com.google.gerrit.common.data.LabelType category(int pos, java.lang.String id, java.lang.String name, com.google.gerrit.common.data.LabelValue... values) { com.google.gerrit.common.data.LabelType type = new com.google.gerrit.common.data.LabelType(name, java.util.Arrays.asList(values)); type.setId(id); type.setPosition(((short) (pos))); return type; }
@java.lang.Deprecated public ApprovalCategory.Id getApprovalCategoryId() { return new com.google.gerrit.reviewdb.client.ApprovalCategory.Id(getId()); }
public com.google.gerrit.common.data.LabelTypes getLabelTypes() { if ((labelTypes) == null) { synchronized(this) { if ((labelTypes) != null) { return labelTypes; } java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> types = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.common.data.LabelType type : dbLabelTypes.getLabelTypes()) { putLabelType(types, type); } java.util.List<com.google.gerrit.server.project.ProjectState> projects = com.google.common.collect.Lists.newArrayList(tree()); java.util.Collections.reverse(projects); for (com.google.gerrit.server.project.ProjectState s : projects) { for (com.google.gerrit.common.data.LabelType type : s.getConfig().getLabelSections()) { putLabelType(types, type); } } java.util.List<com.google.gerrit.common.data.LabelType> all = com.google.common.collect.Lists.newArrayListWithCapacity(types.size()); for (com.google.gerrit.common.data.LabelType type : types.values()) { if (!(type.getValues().isEmpty())) { all.add(type); } } labelTypes = new com.google.gerrit.common.data.LabelTypes(java.util.Collections.unmodifiableList(all)); } } return labelTypes; }
private com.google.gerrit.reviewdb.client.PatchSetApproval dummyApproval(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.reviewdb.client.Account.Id reviewerId) { com.google.gerrit.reviewdb.client.ApprovalCategory.Id id = new com.google.gerrit.reviewdb.client.ApprovalCategory.Id(com.google.common.collect.Iterables.getLast(ctl.getLabelTypes().getLabelTypes()).getId()); com.google.gerrit.reviewdb.client.PatchSetApproval dummyApproval = new com.google.gerrit.reviewdb.client.PatchSetApproval(new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(patchSetId, reviewerId, id), ((short) (0))); dummyApproval.cache(ctl.getChange()); return dummyApproval; }
private java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> setRecommendedAndDisliked(com.google.gerrit.server.query.change.ChangeData cd, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals, com.google.gerrit.common.data.LabelType type, com.google.gerrit.server.change.ChangeJson.LabelInfo label) throws com.google.gwtorm.server.OrmException { if (((label.approved) != null) || ((label.rejected) != null)) { return approvals; } if (((type.getMin()) == null) || ((type.getMax()) == null)) { return approvals; } short min = type.getMin().getValue(); short max = type.getMax().getValue(); if (((-1) <= min) && (max <= 1)) { return approvals; } if (approvals == null) { approvals = cd.currentApprovals(db); } for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { short val = psa.getValue(); if ((((val != 0) && (min < val)) && (val < max)) && (psa.getCategoryId().get().equals(type.getId()))) { if (0 < val) { label.recommended = accountLoader.get(psa.getAccountId()); label.value = (val != 1) ? val : null; } else { label.disliked = accountLoader.get(psa.getAccountId()); label.value = (val != (-1)) ? val : null; } } } return approvals; }
public void testCreateSchema_ApprovalCategory_CodeReview() throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.server.ReviewDb c = db.create().open(); try { final com.google.gerrit.reviewdb.client.ApprovalCategory cat; cat = c.approvalCategories().get(codeReview); assertNotNull(cat); assertEquals(codeReview, cat.getId()); assertEquals("Code Review", cat.getName()); assertEquals("R", cat.getAbbreviatedName()); assertEquals("MaxWithBlock", cat.getFunctionName()); assertTrue(cat.isCopyMinScore()); assertTrue((0 <= (cat.getPosition()))); } finally { c.close(); } assertValueRange(codeReview, (-2), (-1), 0, 1, 2); }

public java.lang.String getApprovals() { try { com.google.common.collect.Table<com.google.gerrit.reviewdb.client.Account.Id, java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> pos = com.google.common.collect.HashBasedTable.create(); com.google.common.collect.Table<com.google.gerrit.reviewdb.client.Account.Id, java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> neg = com.google.common.collect.HashBasedTable.create(); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : args.db.get().patchSetApprovals().byPatchSet(patchSet.getId())) { com.google.gerrit.common.data.LabelType lt = labelTypes.byId(ca.getCategoryId().get()); if (lt == null) { continue; } if ((ca.getValue()) > 0) { pos.put(ca.getAccountId(), lt.getName(), ca); } else if ((ca.getValue()) < 0) { neg.put(ca.getAccountId(), lt.getName(), ca); } } return (format("Approvals", pos)) + (format("Objections", neg)); } catch (com.google.gwtorm.server.OrmException err) { } return ""; }
private void initCodeReviewCategory(final com.google.gerrit.reviewdb.server.ReviewDb c, final com.google.gerrit.reviewdb.client.SystemConfig sConfig) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.ApprovalCategory cat; final java.util.ArrayList<com.google.gerrit.reviewdb.client.ApprovalCategoryValue> vals; cat = new com.google.gerrit.reviewdb.client.ApprovalCategory(new com.google.gerrit.reviewdb.client.ApprovalCategory.Id("CRVW"), "Code Review"); cat.setPosition(((short) (1))); cat.setAbbreviatedName("R"); cat.setCopyMinScore(true); vals = new java.util.ArrayList<com.google.gerrit.reviewdb.client.ApprovalCategoryValue>(); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 2, "Looks good to me, approved")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 1, "Looks good to me, but someone else must approve")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 0, "No score")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, (-1), "I would prefer that you didn't submit this")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, (-2), "Do not submit")); c.approvalCategories().insert(java.util.Collections.singleton(cat)); c.approvalCategoryValues().insert(vals); }
public com.google.gerrit.common.data.LabelType byId(java.lang.String id) { return byId().get(id); }
private java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> scanLabels(com.google.gerrit.server.change.RevisionResource rsrc, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> del) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = rsrc.getControl().getLabelTypes(); java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> current = com.google.common.collect.Maps.newHashMap(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : db.patchSetApprovals().byPatchSetUser(rsrc.getPatchSet().getId(), rsrc.getAccountId())) { if (ApprovalCategory.SUBMIT_ID.equals(a.getCategoryId().get())) { continue; } com.google.gerrit.common.data.LabelType lt = labelTypes.byId(a.getCategoryId().get()); if (lt != null) { current.put(lt.getName(), a); } else { del.add(a); } } return current; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> copyVetosToPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.common.data.LabelTypes labelTypes, com.google.gerrit.reviewdb.client.PatchSet.Id dest) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id source; if ((dest.get()) > 1) { source = new com.google.gerrit.reviewdb.client.PatchSet.Id(dest.getParentKey(), ((dest.get()) - 1)); } else { throw new com.google.gwtorm.server.OrmException("Previous patch set could not be found"); } java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> patchSetApprovals = db.patchSetApprovals().byChange(dest.getParentKey()).toList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : patchSetApprovals) { com.google.gerrit.common.data.LabelType type = labelTypes.byId(a.getCategoryId().get()); if ((((type != null) && (a.getPatchSetId().equals(source))) && (type.isCopyMinScore())) && (type.isMaxNegative(a))) { db.patchSetApprovals().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.PatchSetApproval(dest, a))); } } return patchSetApprovals; }
private static com.google.gerrit.common.data.LabelType type(com.google.gerrit.common.data.LabelTypes types, java.lang.String toFind) { if ((types.byLabel(toFind)) != null) { return types.byLabel(toFind); } if ((types.byId(toFind)) != null) { return types.byId(toFind); } for (com.google.gerrit.common.data.LabelType lt : types.getLabelTypes()) { if (toFind.equalsIgnoreCase(lt.getName())) { return lt; } } for (com.google.gerrit.common.data.LabelType lt : types.getLabelTypes()) { if (toFind.equalsIgnoreCase(lt.getAbbreviatedName())) { return lt; } } return com.google.gerrit.common.data.LabelType.withDefaultValues(toFind); }
private void initVerifiedCategory(final com.google.gerrit.reviewdb.server.ReviewDb c) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.ApprovalCategory cat; final java.util.ArrayList<com.google.gerrit.reviewdb.client.ApprovalCategoryValue> vals; cat = new com.google.gerrit.reviewdb.client.ApprovalCategory(new com.google.gerrit.reviewdb.client.ApprovalCategory.Id("VRIF"), "Verified"); cat.setPosition(((short) (0))); cat.setAbbreviatedName("V"); vals = new java.util.ArrayList<com.google.gerrit.reviewdb.client.ApprovalCategoryValue>(); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 1, "Verified")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, 0, "No score")); vals.add(com.google.gerrit.server.schema.SchemaCreator.value(cat, (-1), "Fails")); c.approvalCategories().insert(java.util.Collections.singleton(cat)); c.approvalCategoryValues().insert(vals); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Change c = object.getChange(); final com.google.gerrit.server.project.ProjectState project = projectCache.get(c.getDest().getParentKey()); if (project == null) { return false; } final com.google.gerrit.common.data.LabelType labelType = com.google.gerrit.server.query.change.LabelPredicate.type(project.getLabelTypes(), type); final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> allApprovers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatVotedInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : object.currentApprovals(dbProvider)) { allApprovers.add(p.getAccountId()); if (p.getCategoryId().get().equals(labelType.getId())) { approversThatVotedInCategory.add(p.getAccountId()); if (match(c, p.getValue(), p.getAccountId(), labelType)) { return true; } } } final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatDidNotVoteInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(allApprovers); approversThatDidNotVoteInCategory.removeAll(approversThatVotedInCategory); for (com.google.gerrit.reviewdb.client.Account.Id a : approversThatDidNotVoteInCategory) { if (match(c, 0, a, labelType)) { return true; } } return false; }
public com.google.gerrit.server.events.ApprovalAttribute asApprovalAttribute(com.google.gerrit.reviewdb.client.PatchSetApproval approval, com.google.gerrit.common.data.LabelTypes labelTypes) { com.google.gerrit.server.events.ApprovalAttribute a = new com.google.gerrit.server.events.ApprovalAttribute(); a.type = approval.getCategoryId().get(); a.value = java.lang.Short.toString(approval.getValue()); a.by = asAccountAttribute(approval.getAccountId()); a.grantedOn = (approval.getGranted().getTime()) / 1000L; com.google.gerrit.common.data.LabelType lt = labelTypes.byId(approval.getCategoryId().get()); if (lt != null) { a.description = lt.getName(); } return a; }

@java.lang.Override public void run() throws com.google.gerrit.plugins.Failure, com.google.gerrit.plugins.UnloggedFailure, java.lang.Exception { java.sql.Connection conn = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); conn.setAutoCommit(false); try { doDelete(conn); conn.commit(); } catch (java.lang.Exception e) { conn.rollback(); throw e; } finally { conn.setAutoCommit(true); } }









private void migratePatchSetApprovals(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.common.data.LabelTypes labelTypes) throws java.sql.SQLException { java.sql.PreparedStatement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().prepareStatement("UPDATE patch_set_approvals SET category_id = ? WHERE category_id = ?"); try { for (com.google.gerrit.common.data.LabelType type : labelTypes.getLabelTypes()) { stmt.setString(1, type.getName()); stmt.setString(2, type.getId()); stmt.addBatch(); } stmt.executeBatch(); } finally { stmt.close(); } }
private void migrateLabelsToAllProjects(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.common.data.LabelTypes labelTypes) throws java.io.IOException, java.sql.SQLException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository git = mgr.openRepository(allProjects); try { com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allProjects, git); md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> configTypes = config.getLabelSections(); java.util.List<com.google.gerrit.common.data.LabelType> newTypes = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.common.data.LabelType type : labelTypes.getLabelTypes()) { type.setId(null); if (!(configTypes.containsKey(type.getName()))) { newTypes.add(type); } } newTypes.addAll(configTypes.values()); configTypes.clear(); for (com.google.gerrit.common.data.LabelType type : newTypes) { configTypes.put(type.getName(), type); } md.setMessage("Upgrade to Gerrit Code Review schema 77\n"); config.commit(md); } finally { git.close(); } }
private void setMerged(final com.google.gerrit.reviewdb.client.Change c, final com.google.gerrit.reviewdb.client.ChangeMessage msg) { com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change.currentPatchSetId(); setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = saveApprovals(c, merged); addMergedMessage(submitter, msg); sendMergedEmail(c, submitter); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db); } catch (com.google.gwtorm.server.OrmException ex) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } }





public static com.google.gerrit.reviewdb.client.Change.Id parse(final java.lang.String str) { final com.google.gerrit.reviewdb.client.Change.Id r = new com.google.gerrit.reviewdb.client.Change.Id(); r.fromString(str); return r; }
@java.lang.Override public void start() { org.eclipse.jgit.transport.SshSessionFactory.setInstance(new org.eclipse.jgit.transport.JschConfigSessionFactory() { @java.lang.Override protected void configure(org.eclipse.jgit.transport.OpenSshConfig.Host hc, com.jcraft.jsch.Session session) { } }); new org.eclipse.jgit.storage.file.WindowCacheConfig().fromConfig(cfg).install(); }
public final native short value();



public static com.google.gerrit.reviewdb.client.AccountDiffPreference createDefault(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = new com.google.gerrit.reviewdb.client.AccountDiffPreference(accountId); p.setIgnoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE); p.setTabSize(8); p.setLineLength(100); p.setSyntaxHighlighting(true); p.setShowWhitespaceErrors(true); p.setShowLineEndings(true); p.setIntralineDifference(true); p.setShowTabs(true); p.setContext(com.google.gerrit.reviewdb.client.AccountDiffPreference.DEFAULT_CONTEXT); p.setManualReview(false); return p; }




public void execute() { final java.lang.String to = com.google.gwt.user.client.History.getToken(); new com.google.gerrit.client.auth.openid.OpenIdSignInDialog(com.google.gerrit.common.auth.SignInMode.REGISTER, to, null).center(); }





@java.lang.SuppressWarnings("unchecked") private void initUserAuth(final org.apache.sshd.server.PublickeyAuthenticator pubkey) { setUserAuthFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.server.UserAuth>>asList(new org.apache.sshd.server.auth.UserAuthPublicKey.Factory())); setPublickeyAuthenticator(pubkey); }


private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); copySelfOnEmails.setEnabled(on); reversePatchSetOrder.setEnabled(on); showUsernameInReviewCategory.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); }


private void display(final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p) { showSiteHeader.setValue(p.isShowSiteHeader()); useFlashClipboard.setValue(p.isUseFlashClipboard()); copySelfOnEmails.setValue(p.isCopySelfOnEmails()); reversePatchSetOrder.setValue(p.isReversePatchSetOrder()); showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.getMaximumPageSize()); setListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, p.getDateFormat()); setListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat()); relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable()); }
private void doSave() { final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p = new com.google.gerrit.reviewdb.client.AccountGeneralPreferences(); p.setShowSiteHeader(showSiteHeader.getValue()); p.setUseFlashClipboard(useFlashClipboard.getValue()); p.setCopySelfOnEmails(copySelfOnEmails.getValue()); p.setReversePatchSetOrder(reversePatchSetOrder.getValue()); p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue()); p.setMaximumPageSize(getListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE)); p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values())); p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values())); p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue()); enable(false); save.setEnabled(false); Util.ACCOUNT_SVC.changePreferences(p, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.getUserAccount().setGeneralPreferences(p); com.google.gerrit.client.Gerrit.applyUserPreferences(); enable(true); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enable(true); save.setEnabled(true); super.onFailure(caught); } }); }
protected boolean hasDifferences(final com.google.gerrit.common.data.PatchScript script) { boolean hasEdits = !(script.getEdits().isEmpty()); boolean hasMeta = !(script.getPatchHeader().isEmpty()); return hasEdits || hasMeta; }

public void testReplaceTwoLinks() { final com.google.gwtexpui.safehtml.client.RawFindReplace[] repl = new com.google.gwtexpui.safehtml.client.RawFindReplace[]{ new com.google.gwtexpui.safehtml.client.RawFindReplace("(issue\\s(\\d+))", "<a href=\"?$2\">$1</a>") }; final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_ReplaceTest.html("A\nissue 42\nissue 9918\nB"); final com.google.gwtexpui.safehtml.client.SafeHtml n = o.replaceAll(java.util.Arrays.asList(repl)); assertNotSame(o, n); assertEquals(("A\n" + (("<a href=\"?42\">issue 42</a>\n" + "<a href=\"?9918\">issue 9918</a>\n") + "B")), n.asString()); }
public void testReplaceInOrder1() { final com.google.gwtexpui.safehtml.client.RawFindReplace[] repl = new com.google.gwtexpui.safehtml.client.RawFindReplace[]{ new com.google.gwtexpui.safehtml.client.RawFindReplace("(GWTEXPUI-(\\d+))", "<a href=\"gwtexpui-bug?$2\">$1</a>"), new com.google.gwtexpui.safehtml.client.RawFindReplace("(issue\\s+(\\d+))", "<a href=\"generic-bug?$2\">$1</a>") }; final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_ReplaceTest.html("A\nissue 42\nReally GWTEXPUI-9918 is better\nB"); final com.google.gwtexpui.safehtml.client.SafeHtml n = o.replaceAll(java.util.Arrays.asList(repl)); assertNotSame(o, n); assertEquals(("A\n" + (("<a href=\"generic-bug?42\">issue 42</a>\n" + "Really <a href=\"gwtexpui-bug?9918\">GWTEXPUI-9918</a> is better\n") + "B")), n.asString()); }





public com.google.gwtexpui.safehtml.client.SafeHtml replaceAll(java.util.List<? extends com.google.gwtexpui.safehtml.client.FindReplace> findReplaceList) { if (findReplaceList == null) { return this; } java.lang.String html = this.asString(); for (com.google.gwtexpui.safehtml.client.FindReplace findReplace : findReplaceList) { html = html.replaceAll(findReplace.find(), findReplace.replace()); } return new com.google.gwtexpui.safehtml.client.SafeHtmlString(html); }





public com.google.gwtexpui.safehtml.client.SafeHtml replaceAll(final java.util.List<com.google.gwtexpui.safehtml.client.RegexFindReplace> findReplaceList) { if (findReplaceList == null) { return this; } java.lang.String html = this.asString(); for (com.google.gwtexpui.safehtml.client.RegexFindReplace findReplace : findReplaceList) { html = html.replaceAll(findReplace.find(), findReplace.replace()); } return new com.google.gwtexpui.safehtml.client.SafeHtmlString(html); }
public void testCreate() { final java.lang.String find = "find"; final java.lang.String replace = "replace"; final com.google.gwtexpui.safehtml.client.RegexFindReplace a = new com.google.gwtexpui.safehtml.client.RegexFindReplace(find, replace); assertSame(find, a.find()); assertSame(replace, a.replace()); assertEquals(((("find = " + find) + ", replace = ") + replace), a.toString()); }
public java.lang.String replace() { return replace; }


public void testReplaceInOrder1() { final com.google.gwtexpui.safehtml.client.RegexFindReplace[] repl = new com.google.gwtexpui.safehtml.client.RegexFindReplace[]{ new com.google.gwtexpui.safehtml.client.RegexFindReplace("(GWTEXPUI-(\\d+))", "<a href=\"gwtexpui-bug?$2\">$1</a>"), new com.google.gwtexpui.safehtml.client.RegexFindReplace("(issue\\s+(\\d+))", "<a href=\"generic-bug?$2\">$1</a>") }; final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_ReplaceTest.html("A\nissue 42\nReally GWTEXPUI-9918 is better\nB"); final com.google.gwtexpui.safehtml.client.SafeHtml n = o.replaceAll(java.util.Arrays.asList(repl)); assertNotSame(o, n); assertEquals(("A\n" + (("<a href=\"generic-bug?42\">issue 42</a>\n" + "Really <a href=\"gwtexpui-bug?9918\">GWTEXPUI-9918</a> is better\n") + "B")), n.asString()); }
public void testReplaceTwoLinks() { final com.google.gwtexpui.safehtml.client.RegexFindReplace[] repl = new com.google.gwtexpui.safehtml.client.RegexFindReplace[]{ new com.google.gwtexpui.safehtml.client.RegexFindReplace("(issue\\s(\\d+))", "<a href=\"?$2\">$1</a>") }; final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_ReplaceTest.html("A\nissue 42\nissue 9918\nB"); final com.google.gwtexpui.safehtml.client.SafeHtml n = o.replaceAll(java.util.Arrays.asList(repl)); assertNotSame(o, n); assertEquals(("A\n" + (("<a href=\"?42\">issue 42</a>\n" + "<a href=\"?9918\">issue 9918</a>\n") + "B")), n.asString()); }


@java.lang.Override public void onValueChange(final com.google.gwt.event.logical.shared.ValueChangeEvent<com.google.gerrit.common.data.ChangeDetail> event) { if (isAttached()) { com.google.gerrit.client.changes.ChangeApi.detail(event.getValue().getChange().getId().get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.com.google.gerrit.client.changes.ChangeInfo result) { changeInfo = result; display(event.getValue()); } }); } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource resource) { com.google.gerrit.server.project.GetConfig.ConfigInfo result = new com.google.gerrit.server.project.GetConfig.ConfigInfo(); com.google.gerrit.server.project.RefControl refConfig = resource.getControl().controlForRef(GitRepositoryManager.REF_CONFIG); if (refConfig.isVisible()) { com.google.gerrit.server.project.ProjectState project = resource.getControl().getProjectState(); if (want("usecontributoragreements")) { result.useContributorAgreements = project.isUseContributorAgreements(); } if (want("usecontentmerge")) { result.useContentMerge = project.isUseContentMerge(); } if (want("usesignedoffby")) { result.useSignedOffBy = project.isUseSignedOffBy(); } if (want("requirechangeid")) { result.requireChangeID = project.isRequireChangeID(); } } return result; }
@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.rpc.CallbackGroup cbs = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.changes.ChangeApi.revision(patchSetId).view("review").get(cbs.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { result.init(); change = result; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchSetPublishDetail>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.PatchSetPublishDetail result) { send.setEnabled(true); display(result); } @java.lang.Override protected void postDisplay() { message.setFocus(true); } })); }
protected void refresh(final boolean isFirst) { final int rpcseq = ++(rpcSequence); lastScript = null; settingsPanel.setEnabled(false); reviewedPanels.populate(patchKey, fileList, patchIndex, getPatchScreenType()); if (isFirst && ((fileList) != null)) { fileList.movePointerTo(patchKey); } PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, settingsPanel.getValue(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchScript>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.PatchScript result) { if ((rpcSequence) == rpcseq) { onResult(result, isFirst); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((rpcSequence) == rpcseq) { settingsPanel.setEnabled(true); super.onFailure(caught); } } }); }
private void preDisplay(final com.google.gerrit.common.data.PatchSetPublishDetail pubDetail, final com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchSetPublishDetail> origCb) { com.google.gerrit.client.projects.ProjectApi.config(pubDetail.getChange().getProject()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); display(pubDetail); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { origCb.onFailure(caught); } }); }
public final java.util.List<com.google.gwtexpui.safehtml.client.FindReplace> commentlinks() { com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.ConfigInfo.CommentLinkInfo> cls = commentlinks0().values(); java.util.List<com.google.gwtexpui.safehtml.client.FindReplace> commentLinks = new java.util.ArrayList<com.google.gwtexpui.safehtml.client.FindReplace>(cls.length()); for (int i = 0; i < (cls.length()); i++) { com.google.gerrit.client.projects.ConfigInfo.CommentLinkInfo cl = cls.get(i); if (!(cl.enabled())) { continue; } if ((cl.link()) != null) { commentLinks.add(new com.google.gwtexpui.safehtml.client.LinkFindReplace(cl.match(), cl.link())); } else { commentLinks.add(new com.google.gwtexpui.safehtml.client.RawFindReplace(cl.match(), cl.html())); } } return commentLinks; }

@java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); }
protected void refresh(final boolean isFirst) { final int rpcseq = ++(rpcSequence); lastScript = null; settingsPanel.setEnabled(false); reviewedPanels.populate(patchKey, fileList, patchIndex, getPatchScreenType()); if (isFirst && ((fileList) != null)) { fileList.movePointerTo(patchKey); } com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.PatchScript> pscb = new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.PatchScript>(this) { @java.lang.Override protected void preDisplay(final com.google.gerrit.common.data.PatchScript result) { if ((rpcSequence) == rpcseq) { onResult(result, isFirst); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { if ((rpcSequence) == rpcseq) { settingsPanel.setEnabled(true); super.onFailure(caught); } } }; if ((commentLinkProcessor) == null) { com.google.gerrit.client.rpc.CallbackGroup cb = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.projects.ProjectApi.config(patchSetDetail.getProject()).addParameter("q", "commentlinks").get(cb.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); contentTable.setCommentLinkProcessor(commentLinkProcessor); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); pscb = cb.addGwtjsonrpc(pscb); } PatchUtil.DETAIL_SVC.patchScript(patchKey, idSideA, idSideB, settingsPanel.getValue(), pscb); }

@java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); contentTable.setCommentLinkProcessor(commentLinkProcessor); }

@java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); display(pubDetail); }

@java.lang.Override public void onValueChange(final com.google.gwt.event.logical.shared.ValueChangeEvent<com.google.gerrit.common.data.ChangeDetail> event) { if (isAttached()) { com.google.gerrit.client.rpc.CallbackGroup cbs = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.projects.ProjectApi.config(event.getValue().getChange().getProject()).get(cbs.add(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { commentLinkProcessor = new com.google.gerrit.client.ui.CommentLinkProcessor(result.commentlinks()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); com.google.gerrit.client.changes.ChangeApi.detail(event.getValue().getChange().getId().get(), cbs.add(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.com.google.gerrit.client.changes.ChangeInfo result) { changeInfo = result; display(event.getValue()); } })); } }


@java.lang.Override public java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> listRepositories(java.util.Set<java.lang.String> branches) throws java.io.IOException, org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException, org.eclipse.jgit.transport.resolver.ServiceNotEnabledException { com.google.gerrit.server.project.ListProjects lp = listProjects.get(); lp.setAll(true); for (java.lang.String branch : branches) { lp.addShowBranch(branch); } java.util.Map<java.lang.String, com.google.gerrit.server.project.ProjectJson.ProjectInfo> projects = lp.apply(); java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> result = com.google.common.collect.Maps.newLinkedHashMap(); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.server.project.ProjectJson.ProjectInfo> e : projects.entrySet()) { result.put(e.getKey(), toDescription(e.getKey(), e.getValue())); } return java.util.Collections.unmodifiableMap(result); }

void doSave(final com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.reviewdb.client.Account> onSave) { java.lang.String newName = (canEditFullName()) ? nameTxt.getText() : null; if ("".equals(newName)) { newName = null; } final java.lang.String newEmail; if ((emailPick.isEnabled()) && ((emailPick.getSelectedIndex()) >= 0)) { final java.lang.String v = emailPick.getValue(emailPick.getSelectedIndex()); if (Util.C.buttonOpenRegisterNewEmail().equals(v)) { newEmail = currentEmail; } else { newEmail = v; } } else { newEmail = currentEmail; } final com.google.gerrit.reviewdb.client.ContactInformation info = toContactInformation(); save.setEnabled(false); registerNewEmail.setEnabled(false); Util.ACCOUNT_SEC.updateContact(newName, newEmail, info, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.Account>() { public void onSuccess(final com.google.gerrit.reviewdb.client.Account result) { registerNewEmail.setEnabled(true); onSaveSuccess(result); if (onSave != null) { onSave.onSuccess(result); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { save.setEnabled(true); registerNewEmail.setEnabled(true); super.onFailure(caught); } }); }
protected com.google.gerrit.prettify.common.SparseHtmlFile getSparseHtmlFileB(com.google.gerrit.common.data.PatchScript s) { com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(s.getDiffPrefs()); com.google.gerrit.prettify.common.PrettyFormatter f = ClientSideFormatter.FACTORY.get(); f.setDiffPrefs(dp); f.setFileName(s.getB().getPath()); f.setEditFilter(PrettyFormatter.B); f.setEditList(s.getEdits()); if (((dp.isSyntaxHighlighting()) && (s.getA().isWholeFile())) && (!(s.getB().isWholeFile()))) { f.format(s.getB().apply(s.getA(), s.getEdits())); } else { f.format(s.getB()); } return f; }
private void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers()); created = true; workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change); cm.setFrom(me); cm.setPatchSet(ps, info); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot send email for new change " + (change.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newchange"; } })); }
public void setAuthorNameText(final java.lang.String nameText) { header.setText(0, 0, nameText); }



public void setFullName(final java.lang.String name) { fullName = (name != null) ? name.trim() : null; }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.PatchSet patchSet = object.currentPatchSet(db); if (patchSet == null) { return false; } final com.google.gerrit.reviewdb.client.RevId revision = patchSet.getRevision(); if (revision == null) { return false; } final org.eclipse.jgit.lib.AnyObjectId objectId = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); if (objectId == null) { return false; } final com.google.gerrit.reviewdb.client.Change change = object.change(db); if (change == null) { return false; } final com.google.gerrit.reviewdb.client.Project.NameKey projectName = change.getProject(); if (projectName == null) { return false; } try { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectName); try { final org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { return rFilter.include(rw, rw.parseCommit(objectId)); } finally { rw.release(); } } finally { repo.close(); } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error((("Repository \"" + (projectName.get())) + "\" unknown."), e); } catch (org.eclipse.jgit.errors.MissingObjectException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error(((projectName.get()) + "\" commit does not exist."), e); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error(((projectName.get()) + "\" revision is not a commit."), e); } catch (java.io.IOException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error((("Could not search for commit message in \"" + (projectName.get())) + "\" repository."), e); } return false; }

private void doGet() { if ((!(lib_dir.exists())) && (!(lib_dir.mkdirs()))) { throw new com.google.gerrit.pgm.util.Die(("Cannot create " + (lib_dir))); } try { removeStaleVersions(); doGetByHttp(); verifyFileChecksum(); } catch (java.io.IOException err) { dst.delete(); if (ui.isBatch()) { throw new com.google.gerrit.pgm.util.Die(("error: Cannot get " + (jarUrl)), err); } java.lang.System.err.println(); java.lang.System.err.println(); java.lang.System.err.println(("error: " + (err.getMessage()))); java.lang.System.err.println("Please download:"); java.lang.System.err.println(); java.lang.System.err.println((" " + (jarUrl))); java.lang.System.err.println(); java.lang.System.err.println("and save as:"); java.lang.System.err.println(); java.lang.System.err.println((" " + (dst.getAbsolutePath()))); java.lang.System.err.println(); java.lang.System.err.flush(); ui.waitForUser(); if (dst.exists()) { verifyFileChecksum(); } else if (!(ui.yesno((!(required)), "Continue without this library"))) { throw new com.google.gerrit.pgm.util.Die("aborted by user"); } } reload.reload(); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) { allRefs = rp.getAdvertisedRefs(); if ((allRefs) == null) { allRefs = rp.getRepository().getAllRefs(); } rp.setAdvertisedRefs(allRefs, rp.getAdvertisedObjects()); }
@java.lang.Override public com.google.gerrit.common.data.ChangeDetail call() throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.common.errors.NoSuchEntityException, com.google.gerrit.server.patch.PatchSetInfoNotAvailableException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { rebaseChange.rebase(patchSetId, currentUser.getAccountId()); return changeDetailFactory.create(patchSetId.getParentKey()).call(); }
protected java.io.File getHook(final java.lang.String name) { final java.lang.String scproot = "com/google/gerrit/server/tools/root"; final java.lang.String path = (scproot + "/hooks/") + name; final java.net.URL url = cl().getResource(path); if (url == null) { fail((("Cannot locate " + path) + " in CLASSPATH")); } java.io.File hook; try { hook = new java.io.File(url.toURI()); } catch (java.net.URISyntaxException e) { hook = new java.io.File(url.getPath()); } if (!(hook.isFile())) { fail((("Cannot locate " + path) + " in CLASSPATH")); } final long time = hook.lastModified(); hook.setExecutable(true); hook.setLastModified(time); return hook; }
@java.lang.Override public java.util.Collection<com.google.gerrit.common.data.GroupReference> suggest(java.lang.String name) { java.util.Set<com.google.gerrit.common.data.GroupReference> groups = com.google.common.collect.Sets.newTreeSet(com.google.gerrit.server.account.GroupBackends.GROUP_REF_NAME_COMPARATOR); for (com.google.gerrit.server.account.GroupBackend g : backends) { groups.addAll(g.suggest(name)); } return groups; }
private java.util.List<com.google.gerrit.common.data.GroupReference> suggestAccountGroup(@javax.annotation.Nullable final com.google.gerrit.server.project.ProjectControl projectControl, final java.lang.String query, final int limit) { final int n = (limit <= 0) ? 10 : java.lang.Math.min(limit, 10); return com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(query), n)); }
@java.lang.Override public java.util.Collection<com.google.gerrit.common.data.GroupReference> suggest(java.lang.String name) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(name); if (com.google.gerrit.server.auth.ldap.LdapGroupBackend.isLdapUUID(uuid)) { com.google.gerrit.common.data.GroupDescription.Basic g = get(uuid); if (g == null) { return java.util.Collections.emptySet(); } return java.util.Collections.singleton(com.google.gerrit.common.data.GroupReference.forGroup(g)); } else if (name.startsWith(com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME)) { return suggestLdap(name.substring(com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME.length())); } return java.util.Collections.emptySet(); }
@java.lang.Override public java.util.Collection<com.google.gerrit.common.data.GroupReference> suggest(final java.lang.String name) { java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup> filtered = com.google.common.collect.Iterables.filter(groupCache.all(), new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.AccountGroup>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.AccountGroup group) { return (group.getName().regionMatches(true, 0, name, 0, name.length())) && (groupControlFactory.controlFor(group).isVisible()); } }); return com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.transform(filtered, com.google.gerrit.server.account.InternalGroupBackend.ACT_GROUP_TO_GROUP_REF)); }


java.util.Collection<com.google.gerrit.common.data.GroupReference> suggest(java.lang.String name);





@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel.CherryPickDialog(b) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get())); } @java.lang.Override public void onSend() { Util.MANAGE_SVC.cherryPickChange(patchSet.getId(), getMessageText(), getDestinationBranch(), createCallback()); } }.center(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.RevisionResource> list() throws com.google.gerrit.extensions.restapi.AuthException { throw new java.lang.UnsupportedOperationException(); }

private com.google.inject.servlet.GuiceFilter load(com.google.gerrit.server.plugins.Plugin plugin) { if ((plugin.getHttpInjector()) != null) { final java.lang.String name = plugin.getName(); final com.google.inject.servlet.GuiceFilter filter; try { filter = plugin.getHttpInjector().getInstance(com.google.inject.servlet.GuiceFilter.class); } catch (java.lang.RuntimeException e) { com.google.gerrit.httpd.plugins.HttpPluginServlet.log.warn(java.lang.String.format("Plugin %s cannot load GuiceFilter", name), e); return null; } try { com.google.gerrit.httpd.plugins.WrappedContext ctx = new com.google.gerrit.httpd.plugins.WrappedContext(plugin, ((base) + name)); filter.init(new com.google.gerrit.httpd.plugins.WrappedFilterConfig(ctx)); } catch (javax.servlet.ServletException e) { com.google.gerrit.httpd.plugins.HttpPluginServlet.log.warn(java.lang.String.format("Plugin %s failed to initialize HTTP", name), e); return null; } plugin.add(new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { filter.destroy(); } }); return filter; } return null; }
@java.lang.Override public void log(java.lang.Exception reason, java.lang.String msg) { log(msg, reason); }

@java.lang.Override public void init(javax.servlet.FilterConfig filterConfig) throws javax.servlet.ServletException { showGitBlitBanner(); try { java.io.InputStream resin = getClass().getResourceAsStream(com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.GITBLIT_REFERENCE_PROPERTIES); java.util.Properties properties = null; try { properties = new java.util.Properties(); properties.load(resin); properties.put("git.repositoriesFolder", repoManager.getBasePath().toString()); } finally { resin.close(); } com.gitblit.IStoredSettings settings = new com.googlesource.gerrit.plugins.gitblit.app.GitBlitSettings(properties); com.gitblit.GitBlit.self().configureContext(settings, false); com.gitblit.GitBlit.self().contextInitialized(new javax.servlet.ServletContextEvent(filterConfig.getServletContext()), getClass().getResourceAsStream(com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.GITBLIT_REFERENCE_PROPERTIES)); super.init(new com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.CustomFilterConfig(filterConfig)); } catch (java.lang.Exception e) { throw new javax.servlet.ServletException(e); } }
private static java.lang.String initSite() throws java.lang.Exception { java.text.DateFormat df = new java.text.SimpleDateFormat("yyyyMMddHHmmss"); java.lang.String path = "target/test_site_" + (df.format(new java.util.Date())); com.google.gerrit.pgm.Init init = new com.google.gerrit.pgm.Init(); int rc = init.main(new java.lang.String[]{ "-d", path, "--batch", "--no-auto-start" }); if (rc != 0) { throw new java.lang.RuntimeException("Couldn't initialize site"); } return path; }
private static java.lang.String getCommitMessageHookInstallationHint(final com.google.gerrit.server.IdentifiedUser currentUser, java.lang.String canonicalWebUrl, final com.google.gerrit.server.ssh.SshInfo sshInfo) { final java.util.List<com.jcraft.jsch.HostKey> hostKeys = sshInfo.getHostKeys(); if (hostKeys.isEmpty()) { java.lang.String p = ".git/hooks/commit-msg"; return java.lang.String.format(" curl -Lo %s %s/tools/hooks/commit-msg ; chmod +x %s", p, com.google.gerrit.server.git.validators.CommitValidators.getGerritUrl(canonicalWebUrl), p); } java.lang.String sshHost; int sshPort; java.lang.String host = hostKeys.get(0).getHost(); int c = host.lastIndexOf(':'); if (0 <= c) { if (host.startsWith("*:")) { sshHost = com.google.gerrit.server.git.validators.CommitValidators.getGerritHost(canonicalWebUrl); } else { sshHost = host.substring(0, c); } sshPort = java.lang.Integer.parseInt(host.substring((c + 1))); } else { sshHost = host; sshPort = 22; } return java.lang.String.format(" scp -p -P %d %s@%s:hooks/commit-msg .git/hooks/", sshPort, currentUser.getUserName(), sshHost); }
@java.lang.Override public Project.NameKey next() { if (!(hasNext())) { throw new java.util.NoSuchElementException(); } com.google.gerrit.reviewdb.client.Project.NameKey r = next; next = null; return r; }
public com.google.gerrit.server.project.ProjectState get(final com.google.gerrit.reviewdb.client.Project.NameKey projectName) { if (projectName == null) { return null; } try { com.google.gerrit.server.project.ProjectState state = byName.get(projectName.get()); if ((state != null) && (state.needsRefresh(clock.read()))) { byName.invalidate(projectName.get()); state = byName.get(projectName.get()); } return state; } catch (java.util.concurrent.ExecutionException e) { if (!((e.getCause()) instanceof org.eclipse.jgit.errors.RepositoryNotFoundException)) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn(java.lang.String.format("Cannot read project %s", projectName.get()), e); } return null; } }

@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> byName(final java.lang.String pfx) { final java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> src; try { src = list.get(com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL).tailSet(new com.google.gerrit.reviewdb.client.Project.NameKey(pfx)); } catch (java.util.concurrent.ExecutionException e) { return java.util.Collections.emptyList(); } return new java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey>() { @java.lang.Override public java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey> iterator() { return new java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey>() { private java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey> itr = src.iterator(); private Project.NameKey next; @java.lang.Override public boolean hasNext() { if ((next) != null) { return true; } if (!(itr.hasNext())) { return false; } com.google.gerrit.reviewdb.client.Project.NameKey r = itr.next(); if (r.get().startsWith(pfx)) { next = r; return true; } else { itr = java.util.Collections.<com.google.gerrit.reviewdb.client.Project.NameKey>emptyList().iterator(); return false; } } @java.lang.Override public Project.NameKey next() { if (!(hasNext())) { throw new java.util.NoSuchElementException(); } com.google.gerrit.reviewdb.client.Project.NameKey r = next; next = null; return r; } @java.lang.Override public void remove() { throw new java.lang.UnsupportedOperationException(); } }; } }; }
@java.lang.Override public java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey> iterator() { return new java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey>() { private java.util.Iterator<com.google.gerrit.reviewdb.client.Project.NameKey> itr = src.iterator(); private Project.NameKey next; @java.lang.Override public boolean hasNext() { if ((next) != null) { return true; } if (!(itr.hasNext())) { return false; } com.google.gerrit.reviewdb.client.Project.NameKey r = itr.next(); if (r.get().startsWith(pfx)) { next = r; return true; } else { itr = java.util.Collections.<com.google.gerrit.reviewdb.client.Project.NameKey>emptyList().iterator(); return false; } } @java.lang.Override public Project.NameKey next() { if (!(hasNext())) { throw new java.util.NoSuchElementException(); } com.google.gerrit.reviewdb.client.Project.NameKey r = next; next = null; return r; } @java.lang.Override public void remove() { throw new java.lang.UnsupportedOperationException(); } }; }

public com.google.gerrit.server.project.ProjectControl controlFor(com.google.gerrit.reviewdb.client.Project.NameKey nameKey, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.NoSuchProjectException { final com.google.gerrit.server.project.ProjectState p = projectCache.get(nameKey); if (p == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(nameKey); } return p.controlFor(user); }
@java.lang.Override public com.google.gerrit.extensions.restapi.StreamingResponse apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getRevision().getControl().getProject().getNameKey(); org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get())); org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(rw.getObjectReader(), rsrc.getPatchKey().get(), commit.getTree().getId()); if (tw == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try { final org.eclipse.jgit.lib.ObjectLoader loader = repo.open(tw.getObjectId(0)); return new com.google.gerrit.extensions.restapi.StreamingResponse() { @java.lang.Override public java.lang.String getContentType() { return "text/plain;charset=UTF-8"; } @java.lang.Override public void stream(java.io.OutputStream out) throws java.io.IOException { java.io.OutputStream b64Out = com.google.common.io.BaseEncoding.base64().encodingStream(new java.io.OutputStreamWriter(out, com.google.common.base.Charsets.UTF_8)); loader.copyTo(b64Out); b64Out.close(); } }; } finally { tw.release(); } } finally { rw.release(); } } finally { repo.close(); } }

public void loadActionPanel(final com.google.gerrit.common.data.PatchSetDetail detail) { if (!(patchSet.getId().equals(diffBaseId))) { actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions()); actionsPanel.setVisible(true); if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (changeDetail.canEdit()) { populateReviewAction(); if (changeDetail.isCurrentPatchSet(detail)) { populateActions(detail); } } if (detail.getPatchSet().isDraft()) { if (changeDetail.canPublish()) { populatePublishAction(); } if ((changeDetail.canDeleteDraft()) && ((changeDetail.getPatchSets().size()) > 1)) { populateDeleteDraftPatchSetAction(); } } } body.add(actionsPanel); } }

@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(EditCommitMessageHandler.Factory.class); factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); factory(PublishAction.Factory.class); factory(DeleteDraftChange.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeDetailServiceImpl.class); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeManageServiceImpl.class); }


@java.lang.Override public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gwt.dom.client.Document.get().getElementById("gerrit_hostpagedata").removeFromParent(); com.google.gerrit.client.Gerrit.myConfig = result.config; com.google.gerrit.client.Gerrit.myTheme = result.theme; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.authorization = result.authorization; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } onModuleLoad2(result); }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.get().parse(TopLevelResource.INSTANCE, id); com.google.gerrit.server.project.ProjectState pp = com.google.common.collect.Iterables.getFirst(p.getControl().getProjectState().parents(), null); if ((pp != null) && (parent.getNameKey().equals(pp.getProject().getNameKey()))) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getControl()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private static void build(java.io.File root, java.lang.String cmd, java.lang.String target) throws java.io.IOException { long start = java.lang.System.currentTimeMillis(); com.google.gerrit.pgm.http.jetty.JettyServer.log.info(("buck build " + target)); java.lang.Process rebuild = new java.lang.ProcessBuilder(cmd, target).directory(root).redirectErrorStream(true).start(); byte[] out; java.io.InputStream in = rebuild.getInputStream(); try { out = com.google.common.io.ByteStreams.toByteArray(in); } finally { rebuild.getOutputStream().close(); in.close(); } int status; try { status = rebuild.waitFor(); } catch (java.lang.InterruptedException e) { throw new java.io.InterruptedIOException(("interrupted waiting for " + cmd)); } if (status != 0) { java.lang.System.err.write(out); java.lang.System.err.println(); java.lang.System.exit(status); } long time = (java.lang.System.currentTimeMillis()) - start; com.google.gerrit.pgm.http.jetty.JettyServer.log.info(java.lang.String.format("UPDATED %s in %.3fs", target, (time / 1000.0))); }


private void loadPatchSets() throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> source = db.patchSets().byChange(changeId); java.util.List<com.google.gerrit.reviewdb.client.PatchSet> patches = new java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchSet>(); for (com.google.gerrit.reviewdb.client.PatchSet ps : source) { final com.google.gerrit.server.CurrentUser user = control.getCurrentUser(); if (user instanceof com.google.gerrit.server.IdentifiedUser) { final com.google.gerrit.reviewdb.client.Account.Id me = ((com.google.gerrit.server.IdentifiedUser) (user)).getAccountId(); ps.setHasDraftComments(db.patchComments().draftByPatchSetAuthor(ps.getId(), me).iterator().hasNext()); } if (control.isPatchVisible(ps, db)) { patches.add(ps); } patchsetsById.put(ps.getId(), ps); } detail.setPatchSets(patches); }
public void display(final com.google.gerrit.common.data.ChangeDetail detail, final com.google.gerrit.reviewdb.client.PatchSet.Id diffBaseId) { clear(); final com.google.gerrit.reviewdb.client.PatchSet currps = detail.getCurrentPatchSet(); currentPatchSetId = currps.getId(); patchSets = detail.getPatchSets(); if (com.google.gerrit.client.Gerrit.isSignedIn()) { final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p = com.google.gerrit.client.Gerrit.getUserAccount().getGeneralPreferences(); if (p.isReversePatchSetOrder()) { java.util.Collections.reverse(patchSets); } } patchSetPanelsList = new java.util.ArrayList<com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel>(); for (final com.google.gerrit.reviewdb.client.PatchSet ps : patchSets) { final com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel p = new com.google.gerrit.client.changes.PatchSetComplexDisclosurePanel(ps, (ps == currps)); if (diffBaseId != null) { p.setDiffBaseId(diffBaseId); if (ps == currps) { p.refresh(); } } add(p); patchSetPanelsList.add(p); } }
@java.lang.Override public com.google.gerrit.common.data.ListBranchesResult call() throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { final com.google.gerrit.server.project.ProjectControl pctl = projectControlFactory.validateFor(projectName, ((com.google.gerrit.server.project.ProjectControl.OWNER) | (com.google.gerrit.server.project.ProjectControl.VISIBLE))); final java.util.List<com.google.gerrit.reviewdb.client.Branch> branches = new java.util.ArrayList<com.google.gerrit.reviewdb.client.Branch>(); com.google.gerrit.reviewdb.client.Branch headBranch = null; com.google.gerrit.reviewdb.client.Branch configBranch = null; final java.util.Set<java.lang.String> targets = new java.util.HashSet<java.lang.String>(); final org.eclipse.jgit.lib.Repository db; try { db = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noGitRepository) { return new com.google.gerrit.common.data.ListBranchesResult(branches, false, true); } try { final java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = db.getAllRefs(); if (!(all.containsKey(Constants.HEAD))) { try { org.eclipse.jgit.lib.Ref head = db.getRef(Constants.HEAD); if (head != null) { all.put(Constants.HEAD, head); } } catch (java.io.IOException e) { } } for (final org.eclipse.jgit.lib.Ref ref : all.values()) { if (ref.isSymbolic()) { targets.add(ref.getTarget().getName()); } } for (final org.eclipse.jgit.lib.Ref ref : all.values()) { if (ref.isSymbolic()) { java.lang.String target = ref.getTarget().getName(); com.google.gerrit.server.project.RefControl targetRefControl = pctl.controlForRef(target); if (!(targetRefControl.isVisible())) { continue; } if (target.startsWith(Constants.R_HEADS)) { target = target.substring(Constants.R_HEADS.length()); } com.google.gerrit.reviewdb.client.Branch b = createBranch(ref.getName()); b.setRevision(new com.google.gerrit.reviewdb.client.RevId(target)); if (Constants.HEAD.equals(ref.getName())) { b.setCanDelete(false); headBranch = b; } else { b.setCanDelete(targetRefControl.canDelete()); branches.add(b); } continue; } final com.google.gerrit.server.project.RefControl refControl = pctl.controlForRef(ref.getName()); if (refControl.isVisible()) { if (ref.getName().startsWith(Constants.R_HEADS)) { branches.add(createBranch(ref, refControl, targets)); } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) { configBranch = createBranch(ref, refControl, targets); } } } } finally { db.close(); } java.util.Collections.sort(branches, new java.util.Comparator<com.google.gerrit.reviewdb.client.Branch>() { @java.lang.Override public int compare(final com.google.gerrit.reviewdb.client.Branch a, final com.google.gerrit.reviewdb.client.Branch b) { return a.getName().compareTo(b.getName()); } }); if (configBranch != null) { branches.add(0, configBranch); } if (headBranch != null) { branches.add(0, headBranch); } return new com.google.gerrit.common.data.ListBranchesResult(branches, pctl.canAddRefs(), false); }


private void populateCommands(final com.google.gerrit.common.data.PatchSetDetail detail) { for (final com.google.gerrit.common.data.UiCommandDetail cmd : detail.getCommands()) { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button(cmd.label); b.setEnabled(cmd.enabled); b.setTitle(cmd.title); b.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString> cb = new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); new com.google.gerrit.client.ErrorDialog(caught).center(); } @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { b.setEnabled(true); if (msg != null) { com.google.gwt.user.client.Window.alert(msg.asString()); } } }; com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(patchSet.getId()).view(cmd.id); if ("PUT".equalsIgnoreCase(cmd.method)) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(cmd.method)) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } } }); actionsPanel.add(b); } }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString> cb = new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); new com.google.gerrit.client.ErrorDialog(caught).center(); } @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { b.setEnabled(true); if (msg != null) { com.google.gwt.user.client.Window.alert(msg.asString()); } } }; com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(patchSet.getId()).view(cmd.id); if ("PUT".equalsIgnoreCase(cmd.method)) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(cmd.method)) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { b.setEnabled(true); if (msg != null) { com.google.gwt.user.client.Window.alert(msg.asString()); } }

private static synchronized void fill(byte[] raw, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if ((com.google.gerrit.server.ChangeUtil.uuidSeq) == 0) { com.google.gerrit.server.ChangeUtil.uuidPrefix = db.nextChangeMessageId(); com.google.gerrit.server.ChangeUtil.uuidSeq = java.lang.Integer.MAX_VALUE; } org.eclipse.jgit.util.NB.encodeInt32(raw, 0, com.google.gerrit.server.ChangeUtil.uuidPrefix); org.eclipse.jgit.util.NB.encodeInt32(raw, 4, ((com.google.gerrit.server.ChangeUtil.uuidSeq)--)); }




private void display(com.google.gerrit.client.diff.DiffInfo diff) { net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("value", diff.text_b()); if (((diff.meta_b()) != null) && ((diff.meta_b().content_type()) != null)) { cfg.set("mode", diff.meta_b().content_type()); } cm = net.codemirror.lib.CodeMirror.create(editorContainer.getElement(), cfg); cm.setWidth("100%"); cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { cm.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cm.refresh(); } }); }
private void display(com.google.gerrit.client.diff.DiffInfo diff) { net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", com.google.gerrit.client.diff.CodeMirrorDemo.getContentType(diff.meta_b())).set("value", diff.text_b()); cm = net.codemirror.lib.CodeMirror.create(editorContainer.getElement(), cfg); cm.setWidth("100%"); cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { cm.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cm.refresh(); } }); }

@java.lang.Override protected void onUnload() { super.onUnload(); if ((resizeHandler) != null) { resizeHandler.removeHandler(); resizeHandler = null; } if ((cm) != null) { cm.getWrapperElement().removeFromParent(); cm = null; } }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Email parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Email parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { for (com.google.gerrit.reviewdb.client.Account.Id a : byEmailCache.get(id.get())) { if (parent.getUser().getAccountId().equals(a)) { return new com.google.gerrit.server.account.AccountResource.Email(parent.getUser(), id.get()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }




private Change.Id insertPatchSet(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, org.eclipse.jgit.revwalk.RevCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet.Id id = com.google.gerrit.server.ChangeUtil.nextPatchSetId(git, change.currentPatchSetId()); com.google.gerrit.reviewdb.client.PatchSet newPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(id); newPatchSet.setCreatedOn(new java.sql.Timestamp(java.lang.System.currentTimeMillis())); newPatchSet.setUploader(change.getOwner()); newPatchSet.setRevision(new com.google.gerrit.reviewdb.client.RevId(cherryPickCommit.name())); patchSetInserterFactory.create(git, revWalk, change, cherryPickCommit).setPatchSet(newPatchSet).setRefControl(refControl).setMessage(buildChangeMessage(patchSetId, change)).insert(); return change.getId(); }

private net.codemirror.lib.CodeMirror displaySide(com.google.gerrit.client.diff.DiffInfo.FileMeta meta, java.lang.String contents) { if (meta == null) { return null; } net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", com.google.gerrit.client.diff.CodeMirrorDemo.getContentType(meta)).set("value", contents); com.google.gwt.dom.client.Element child = com.google.gwt.user.client.DOM.createDiv(); editorContainer.getElement().appendChild(child); final net.codemirror.lib.CodeMirror cm = net.codemirror.lib.CodeMirror.create(child, cfg); cm.setWidth("100%"); cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); return cm; }


private void display(com.google.gerrit.client.diff.DiffInfo diff) { cmA = displaySide(diff.meta_a(), diff.text_a()); cmB = displaySide(diff.meta_b(), diff.text_b()); resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { if ((cmA) != null) { cmA.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cmA.refresh(); } if ((cmB) != null) { cmB.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cmB.refresh(); } } }); }
public java.lang.String[] currentFilePaths(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db, com.google.gerrit.server.patch.PatchListCache cache) throws com.google.gwtorm.server.OrmException { if ((currentFiles) == null) { com.google.gerrit.reviewdb.client.Change c = change(db); if (c == null) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(db); if (ps == null) { return null; } com.google.gerrit.server.patch.PatchList p; try { p = cache.get(c, ps); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { currentFiles = new java.lang.String[0]; return currentFiles; } java.util.List<java.lang.String> r = new java.util.ArrayList<java.lang.String>(p.getPatches().size()); for (com.google.gerrit.server.patch.PatchListEntry e : p.getPatches()) { if (Patch.COMMIT_MSG.equals(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; case REWRITE : break; } } currentFiles = r.toArray(new java.lang.String[r.size()]); java.util.Arrays.sort(currentFiles); } return currentFiles; }













private void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers()); created = true; workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change); cm.setFrom(me); cm.setPatchSet(ps, info); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot send email for new change " + (change.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newchange"; } })); if (((magicBranch) != null) && (magicBranch.isSubmit())) { submit(projectControl.controlFor(change), ps); } }



private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(new com.google.gerrit.common.ChangeHookRunner.Module()); modules.add(new com.google.gerrit.server.git.ReceiveCommitsExecutorModule()); modules.add(new com.google.gerrit.server.patch.IntraLineWorkerPool.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.mail.SignedTokenEmailTokenVerifier.Module()); modules.add(new com.google.gerrit.server.plugins.PluginModule()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(com.google.gerrit.sshd.SshKeyCacheImpl.module()); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.httpd.GerritUiOptions.class).toInstance(new com.google.gerrit.httpd.GerritUiOptions(false)); } }); return cfgInjector.createChildInjector(modules); }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> file(java.lang.String file) throws com.google.gerrit.server.query.QueryParseException { if (!(allowsFile)) { throw error(("operator not permitted here: file:" + file)); } if (file.startsWith("^")) { return new com.google.gerrit.server.query.change.RegexFilePredicate(args.dbProvider, args.patchListCache, file); } throw new java.lang.IllegalArgumentException(); }

public void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.ChangeMessage changeMessage, com.google.gerrit.reviewdb.client.PatchSet ps, org.eclipse.jgit.revwalk.RevCommit commit, com.google.gerrit.common.data.LabelTypes labelTypes, com.google.gerrit.reviewdb.client.PatchSetInfo info, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers) throws com.google.gwtorm.server.OrmException { db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.ChangeUtil.insertAncestors(db, ps.getId(), commit); db.patchSets().insert(java.util.Collections.singleton(ps)); db.changes().insert(java.util.Collections.singleton(change)); com.google.gerrit.server.ChangeUtil.updateTrackingIds(db, change, trackingFooters, commit.getFooterLines()); approvalsUtil.addReviewers(db, labelTypes, change, ps, info, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); db.commit(); } finally { db.rollback(); } if (changeMessage != null) { db.changeMessages().insert(java.util.Collections.singleton(changeMessage)); } gitRefUpdated.fire(change.getProject(), ps.getRefName(), org.eclipse.jgit.lib.ObjectId.zeroId(), commit); hooks.doPatchsetCreatedHook(change, ps, db); }





private com.google.inject.Injector createSysInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.gerrit.server.git.WorkQueue.Module()); modules.add(new com.google.gerrit.common.ChangeHookRunner.Module()); modules.add(new com.google.gerrit.server.git.ReceiveCommitsExecutorModule()); modules.add(new com.google.gerrit.server.patch.IntraLineWorkerPool.Module()); modules.add(cfgInjector.getInstance(com.google.gerrit.server.config.GerritGlobalModule.class)); modules.add(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); modules.add(new com.google.gerrit.server.mail.SmtpEmailSender.Module()); modules.add(new com.google.gerrit.server.mail.SignedTokenEmailTokenVerifier.Module()); modules.add(new com.google.gerrit.server.plugins.PluginModule()); modules.add(new com.google.gerrit.server.index.Module()); modules.add(com.google.gerrit.lucene.LuceneChangeIndex.module()); modules.add(new com.google.gerrit.server.config.CanonicalWebUrlModule() { @java.lang.Override protected java.lang.Class<? extends com.google.inject.Provider<java.lang.String>> provider() { return com.google.gerrit.httpd.HttpCanonicalWebUrlProvider.class; } }); modules.add(com.google.gerrit.sshd.SshKeyCacheImpl.module()); modules.add(new com.google.gerrit.server.config.MasterNodeStartup()); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.httpd.GerritUiOptions.class).toInstance(new com.google.gerrit.httpd.GerritUiOptions(false)); } }); return cfgInjector.createChildInjector(modules); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.ChangeIndex.class).to(com.google.gerrit.lucene.LuceneChangeIndex.class); listener().to(com.google.gerrit.lucene.LuceneChangeIndex.class); }
private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); modules.add(com.google.gerrit.server.patch.PatchListCacheImpl.module()); modules.add(com.google.gerrit.lucene.LuceneChangeIndex.module()); modules.add(new com.google.inject.AbstractModule() { @java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(com.google.gerrit.reviewdb.server.ReviewDb.class).toProvider(new com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb>() { @java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb get() { return dbRef.get(); } }); bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); } }); return dbInjector.createChildInjector(modules); }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.SINGLE_USER); sysInjector = createSysInjector(); manager.add(dbInjector); manager.add(sysInjector); manager.start(); com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb> schema = dbInjector.getInstance(com.google.inject.Key.get(new com.google.inject.TypeLiteral<com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb>>() {})); com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); dbRef.set(db); com.google.gerrit.lucene.LuceneChangeIndex index = sysInjector.getInstance(com.google.gerrit.lucene.LuceneChangeIndex.class); index.getWriter().deleteAll(); int i = 0; for (com.google.gerrit.reviewdb.client.Change change : db.changes().all()) { index.insert(new com.google.gerrit.server.query.change.ChangeData(change)); i++; } index.getWriter().commit(); java.lang.System.out.println((("Reindexed " + i) + " changes")); manager.stop(); return 0; }
















private void render(com.google.gerrit.client.diff.DiffInfo diff) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Region> regions = diff.content(); net.codemirror.lib.Configuration insertOpt = net.codemirror.lib.Configuration.create().set("className", diffTable.style.insert()).set("readOnly", true); net.codemirror.lib.Configuration deleteOpt = net.codemirror.lib.Configuration.create().set("className", diffTable.style.delete()).set("readOnly", true); int lineA = 0; int lineB = 0; for (int i = 0; i < (regions.length()); i++) { com.google.gerrit.client.diff.DiffInfo.Region current = regions.get(i); if ((current.ab()) != null) { lineA += current.ab().length(); lineB += current.ab().length(); } else if (((current.a()) == null) && ((current.b()) != null)) { int delta = current.b().length(); for (int j = 0; j < delta; j++) { addPadding(cmA, (lineA - 1)); } for (int j = 0; j < delta; j++) { cmB.addLineClass(lineB, LineClassWhere.WRAP, diffTable.style.insert()); net.codemirror.lib.LineCharacter from = net.codemirror.lib.LineCharacter.create(lineB, 0); cmB.markText(from, from, insertOpt); lineB++; } } else if (((current.a()) != null) && ((current.b()) == null)) { int delta = current.a().length(); for (int j = 0; j < delta; j++) { addPadding(cmB, (lineB - 1)); } for (int j = 0; j < delta; j++) { cmA.addLineClass(lineA, LineClassWhere.WRAP, diffTable.style.delete()); net.codemirror.lib.LineCharacter from = net.codemirror.lib.LineCharacter.create(lineA, 0); cmA.markText(from, from, deleteOpt); lineA++; } } else { lineA += current.a().length(); lineB += current.a().length(); } } }
@java.lang.Override public void init(javax.servlet.FilterConfig filterConfig) throws javax.servlet.ServletException { showGitBlitBanner(); try { java.io.InputStream resin = getClass().getResourceAsStream(com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.GITBLIT_GERRIT_PROPERTIES); java.util.Properties properties = null; try { properties = new java.util.Properties(); properties.load(resin); properties.put("git.repositoriesFolder", repoManager.getBasePath().getAbsolutePath()); properties.put("realm.userService", com.googlesource.gerrit.plugins.gitblit.auth.GerritToGitBlitUserService.class.getName()); properties.put("web.otherUrls", (((config.getGitHttpUrl()) + " ") + (config.getGitSshUrl())).trim()); } finally { resin.close(); } com.gitblit.IStoredSettings settings = new com.googlesource.gerrit.plugins.gitblit.app.GitBlitSettings(properties); com.gitblit.GitBlit.self().configureContext(settings, repoManager.getBasePath(), false); com.gitblit.GitBlit.self().contextInitialized(new javax.servlet.ServletContextEvent(filterConfig.getServletContext())); super.init(new com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.CustomFilterConfig(filterConfig)); } catch (java.lang.Exception e) { throw new javax.servlet.ServletException(e); } }
@java.lang.Override public java.util.concurrent.Future<?> index(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.util.RequestScopePropagator prop) { java.lang.Runnable task = new com.google.gerrit.server.index.ChangeIndexerImpl.Task(change); if (prop != null) { task = prop.wrap(task); } return workQueue.getDefaultQueue().submit(task); }
private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); modules.add(com.google.gerrit.server.patch.PatchListCacheImpl.module()); modules.add(new com.google.gerrit.lucene.LuceneIndexModule(false)); modules.add(new com.google.inject.AbstractModule() { @java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(com.google.gerrit.reviewdb.server.ReviewDb.class).toProvider(new com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb>() { @java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb get() { return dbRef.get(); } }); bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); } }); return dbInjector.createChildInjector(modules); }

@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.SINGLE_USER); if (!(com.google.gerrit.lucene.LuceneIndexModule.isEnabled(dbInjector))) { throw die("Secondary index not enabled"); } sitePaths = dbInjector.getInstance(com.google.gerrit.server.config.SitePaths.class); deleteAll(); sysInjector = createSysInjector(); manager.add(dbInjector); manager.add(sysInjector); manager.start(); com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb> schema = dbInjector.getInstance(com.google.inject.Key.get(new com.google.inject.TypeLiteral<com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb>>() {})); com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); dbRef.set(db); com.google.gerrit.server.index.ChangeIndexer indexer = sysInjector.getInstance(com.google.gerrit.server.index.ChangeIndexer.class); com.google.common.base.Stopwatch sw = new com.google.common.base.Stopwatch().start(); int i = 0; for (com.google.gerrit.reviewdb.client.Change change : db.changes().all()) { indexer.index(change).get(); i++; } double elapsed = (sw.elapsed(java.util.concurrent.TimeUnit.MILLISECONDS)) / 1000.0; java.lang.System.out.format("Reindexed %d changes in %.02fms", i, elapsed); writeVersion(); manager.stop(); return 0; }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> file(java.lang.String file) throws com.google.gerrit.server.query.QueryParseException { if (allowFileRegex) { if (file.startsWith("^")) { return new com.google.gerrit.server.query.change.RegexFilePredicate(args.dbProvider, args.patchListCache, file); } else { throw new java.lang.IllegalArgumentException(); } } else { if ((!(file.startsWith("^"))) && ((args.indexManager) != (ChangeIndex.Manager.DISABLED))) { return new com.google.gerrit.server.query.change.EqualsFilePredicate(args.dbProvider, args.patchListCache, file); } else { throw error(("regular expression not permitted here: file:" + file)); } } }
private void displayHeader(java.util.Collection<java.lang.String> labels) { table.resizeColumns((2 + (labels.size()))); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); int col = 0; table.setText(0, col, Util.C.approvalTableReviewer()); fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header()); col++; table.clearCell(0, col); fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header()); col++; for (java.lang.String name : labels) { table.setText(0, col, name); fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header()); col++; } fmt.addStyleName(0, (col - 1), Gerrit.RESOURCES.css().rightmost()); }
private void doClearPassword() { if ((id) != null) { enableUI(false); Util.ACCOUNT_SEC.clearPassword(id.getKey(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.AccountExternalId>() { public void onSuccess(final com.google.gerrit.reviewdb.client.AccountExternalId result) { display(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enableUI(true); } }); } }

private void doGeneratePassword() { if ((id) != null) { enableUI(false); Util.ACCOUNT_SEC.generatePassword(id.getKey(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.AccountExternalId>() { public void onSuccess(final com.google.gerrit.reviewdb.client.AccountExternalId result) { display(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enableUI(true); } }); } }

void deleteChecked() { final java.util.HashSet<com.google.gerrit.reviewdb.client.AccountSshKey.Id> ids = new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountSshKey.Id>(); for (int row = 1; row < (table.getRowCount()); row++) { final com.google.gerrit.reviewdb.client.AccountSshKey k = getRowItem(row); if ((k != null) && (((com.google.gwt.user.client.ui.CheckBox) (table.getWidget(row, 1))).getValue())) { ids.add(k.getKey()); } } if (ids.isEmpty()) { updateDeleteButton(); } else { Util.ACCOUNT_SEC.deleteSshKeys(ids, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { for (int row = 1; row < (table.getRowCount());) { final com.google.gerrit.reviewdb.client.AccountSshKey k = getRowItem(row); if ((k != null) && (ids.contains(k.getKey()))) { table.removeRow(row); } else { row++; } } if ((table.getRowCount()) == 1) { display(java.util.Collections.<com.google.gerrit.reviewdb.client.AccountSshKey>emptyList()); } else { updateDeleteButton(); } } }); } }
public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { for (int row = 1; row < (table.getRowCount());) { final com.google.gerrit.reviewdb.client.AccountSshKey k = getRowItem(row); if ((k != null) && (ids.contains(k.getKey()))) { table.removeRow(row); } else { row++; } } if ((table.getRowCount()) == 1) { display(java.util.Collections.<com.google.gerrit.reviewdb.client.AccountSshKey>emptyList()); } else { updateDeleteButton(); } }



@java.lang.Override public AccountResource.SshKey parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }

void deleteChecked() { final java.util.HashSet<com.google.gerrit.reviewdb.client.AccountSshKey.Id> ids = new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountSshKey.Id>(); for (int row = 1; row < (table.getRowCount()); row++) { final com.google.gerrit.client.account.SshKeyInfo k = getRowItem(row); if ((k != null) && (((com.google.gwt.user.client.ui.CheckBox) (table.getWidget(row, 1))).getValue())) { ids.add(new com.google.gerrit.reviewdb.client.AccountSshKey.Id(com.google.gerrit.client.Gerrit.getUserAccount().getId(), k.seq())); } } if (ids.isEmpty()) { updateDeleteButton(); } else { Util.ACCOUNT_SEC.deleteSshKeys(ids, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { for (int row = 1; row < (table.getRowCount());) { final com.google.gerrit.client.account.SshKeyInfo k = getRowItem(row); if ((k != null) && (ids.contains(new com.google.gerrit.reviewdb.client.AccountSshKey.Id(com.google.gerrit.client.Gerrit.getUserAccount().getId(), k.seq())))) { table.removeRow(row); } else { row++; } } if ((table.getRowCount()) == 1) { display(java.util.Collections.<com.google.gerrit.client.account.SshKeyInfo>emptyList()); } else { updateDeleteButton(); } } }); } }


private void render(com.google.gerrit.client.diff.DiffInfo diff) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Region> regions = diff.content(); int lineA = 0; int lineB = 0; for (int i = 0; i < (regions.length()); i++) { com.google.gerrit.client.diff.DiffInfo.Region current = regions.get(i); if ((current.ab()) != null) { lineA += current.ab().length(); lineB += current.ab().length(); } else if (((current.a()) == null) && ((current.b()) != null)) { int delta = current.b().length(); insertEmptyLines(cmA, lineA, delta); lineB = colorLines(cmB, lineB, delta); } else if (((current.a()) != null) && ((current.b()) == null)) { int delta = current.a().length(); insertEmptyLines(cmB, lineB, delta); lineA = colorLines(cmA, lineA, delta); } else { int aLength = current.a().length(); int bLength = current.b().length(); lineA = colorLines(cmA, lineA, aLength); lineB = colorLines(cmB, lineB, bLength); if (aLength < bLength) { insertEmptyLines(cmA, lineA, (bLength - aLength)); } else if (aLength > bLength) { insertEmptyLines(cmB, lineB, (aLength - bLength)); } } } }


private net.codemirror.lib.CodeMirror displaySide(com.google.gerrit.client.diff.DiffInfo.FileMeta meta, java.lang.String contents, com.google.gwt.dom.client.Element ele) { if (meta == null) { contents = ""; } net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", com.google.gerrit.client.diff.CodeMirrorDemo.getContentType(meta)).set("value", contents).setInfinity("viewportMargin"); final net.codemirror.lib.CodeMirror cm = net.codemirror.lib.CodeMirror.create(ele, cfg); cm.setWidth("100%"); cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); return cm; }







void addDiff(int endA, int endB, java.util.List<org.eclipse.jgit.diff.Edit> internalEdit) { int lenA = endA - (nextA); int lenB = endB - (nextB); checkState(((lenA > 0) || (lenB > 0))); com.google.gerrit.server.change.GetDiff.ContentEntry e = entry(); if (lenA > 0) { e.a = com.google.common.collect.Lists.newArrayListWithCapacity(lenA); for (; (nextA) < endA; (nextA)++) { e.a.add(fileA.get(nextA)); } } if (lenB > 0) { e.b = com.google.common.collect.Lists.newArrayListWithCapacity(lenB); for (; (nextB) < endB; (nextB)++) { e.b.add(fileB.get(nextB)); } } if ((internalEdit != null) && (!(internalEdit.isEmpty()))) { e.editA = com.google.common.collect.Lists.newArrayListWithCapacity(((internalEdit.size()) * 2)); e.editB = com.google.common.collect.Lists.newArrayListWithCapacity(((internalEdit.size()) * 2)); for (org.eclipse.jgit.diff.Edit edit : internalEdit) { if ((edit.getBeginA()) != (edit.getEndA())) { e.editA.add(com.google.common.collect.ImmutableList.of(edit.getBeginA(), ((edit.getEndA()) - (edit.getBeginA())))); } if ((edit.getBeginB()) != (edit.getEndB())) { e.editB.add(com.google.common.collect.ImmutableList.of(edit.getBeginB(), ((edit.getEndB()) - (edit.getBeginB())))); } } } }
@java.lang.Override protected void onUnload() { if ((regNavigation) != null) { regNavigation.removeHandler(); regNavigation = null; } if ((regAction) != null) { regAction.removeHandler(); regAction = null; } super.onUnload(); }


static void replyText(@javax.annotation.Nullable javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, java.lang.String text) throws java.io.IOException { if (((req == null) || ("GET".equals(req.getMethod()))) && (com.google.gerrit.httpd.restapi.RestApiServlet.isMaybeHTML(text))) { com.google.gerrit.httpd.restapi.RestApiServlet.replyJson(req, res, com.google.common.collect.ImmutableMultimap.of("pp", "0"), new com.google.gson.JsonPrimitive(text)); } else { if (!(text.endsWith("\n"))) { text += "\n"; } com.google.gerrit.httpd.restapi.RestApiServlet.replyBinaryResult(req, res, com.google.gerrit.extensions.restapi.BinaryResult.create(text).setContentType("text/plain")); } }
private void setupDefaultOperations() { new org.eclipse.example.calc.internal.operations.Equals(); new org.eclipse.example.calc.internal.operations.Minus(); new org.eclipse.example.calc.internal.operations.Plus(); new org.eclipse.example.calc.internal.operations.Square(); new org.eclipse.example.calc.internal.Divide(); new org.eclipse.example.calc.internal.Multiply(); }
private net.codemirror.lib.LineCharacter advance(int numOfChar) { while ((currLineIndex) < (lines.length())) { java.lang.String line = lines.get(currLineIndex).substring(currLineOffset); int lengthWithNewline = (line.length()) + 1; if (numOfChar < lengthWithNewline) { net.codemirror.lib.LineCharacter at = net.codemirror.lib.LineCharacter.create(((startLine) + (currLineIndex)), (numOfChar + (currLineOffset))); currLineOffset += numOfChar; if ((currLineOffset) == (line.length())) { advanceLine(); } return at; } numOfChar -= lengthWithNewline; advanceLine(); } throw new java.lang.IllegalStateException("LineIterator index out of bound"); }

@java.lang.Override public void start(org.apache.sshd.server.Environment env) throws java.io.IOException { try { if ((caller.get()) instanceof com.google.gerrit.server.PeerDaemonUser) { parseCommandLine(); final com.google.gerrit.sshd.SshScope.Context ctx = callingContext.subContext(newSession(), com.google.gerrit.sshd.SuExec.join(args)); final com.google.gerrit.sshd.SshScope.Context old = sshScope.set(ctx); try { final com.google.gerrit.sshd.BaseCommand cmd = dispatcher.get(); cmd.setArguments(args.toArray(new java.lang.String[args.size()])); provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); } finally { sshScope.set(old); } } else { throw new com.google.gerrit.sshd.UnloggedFailure(1, "fatal: Not a peer daemon"); } } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes("UTF-8")); err.flush(); onExit(1); } }
@java.lang.Override public java.lang.String render(java.lang.String varName) { if (com.google.gerrit.common.data.Permission.isLabel(varName)) { return Util.M.label(new com.google.gerrit.common.data.Permission(varName).getLabel()); } java.lang.String desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get(varName); if (desc == null) { desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get(varName.toLowerCase()); } return desc != null ? desc : varName; }






@java.lang.Override protected void onLoad() { super.onLoad(); Util.PROJECT_SVC.projectAccess(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.ProjectAccess>(this) { @java.lang.Override public void preDisplay(com.google.gerrit.common.data.ProjectAccess access) { displayReadOnly(access); } }); savedPanel = ACCESS; }
private void displayReadOnly(com.google.gerrit.common.data.ProjectAccess access) { this.access = access; accessEditor.setEditing(false); com.google.gwt.user.client.ui.UIObject.setVisible(editTools, ((!(access.getOwnerOf().isEmpty())) || (access.canUpload()))); edit.setEnabled(((!(access.getOwnerOf().isEmpty())) || (access.canUpload()))); cancel1.setVisible(false); com.google.gwt.user.client.ui.UIObject.setVisible(commitTools, false); driver.edit(access); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(final com.google.gerrit.reviewdb.client.Account.Id fromId) { if (fromId != null) { final com.google.gerrit.reviewdb.client.Account a = accountCache.get(fromId).getAccount(); if ((a.getPreferredEmail()) != null) { return new com.google.gerrit.server.mail.Address(a.getFullName(), a.getPreferredEmail()); } } return srvAddr; }

void doAddNewInclude() { final java.lang.String groupName = addIncludeBox.getText(); if ((groupName.length()) == 0) { return; } addIncludeBox.setEnabled(false); com.google.gerrit.client.groups.GroupApi.addIncludedGroup(getGroupUUID(), groupName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.groups.GroupInfo>() { public void onSuccess(final com.google.gerrit.client.groups.GroupInfo result) { addIncludeBox.setEnabled(true); addIncludeBox.setText(""); includes.insert(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { addIncludeBox.setEnabled(true); super.onFailure(caught); } }); }
public boolean isVisible() { com.google.gerrit.reviewdb.client.AccountGroup accountGroup = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); return ((((accountGroup != null) && (accountGroup.isVisibleToAll())) || ((user) instanceof com.google.gerrit.server.InternalUser)) || (user.getEffectiveGroups().contains(group.getGroupUUID()))) || (isOwner()); }










@java.lang.Override public void stop() { openIndex.close(); closedIndex.close(); }

@java.lang.Override public void run() { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(change); try { index.replace(cd); } catch (java.io.IOException e) { com.google.gerrit.server.index.ChangeIndexerImpl.log.error("Error indexing change", e); } }




com.google.gwt.dom.client.DivElement getCmB() { return cmB; }
com.google.gwt.dom.client.DivElement getCmA() { return cmA; }









public java.lang.Runnable doScroll(final net.codemirror.lib.CodeMirror cm) { final net.codemirror.lib.CodeMirror other = (cm == (cmA)) ? cmB : cmA; return new java.lang.Runnable() { public void run() { cm.scrollToY(other.getScrollInfo().getTop()); } }; }
private void insertEmptyLines(net.codemirror.lib.CodeMirror cm, int line, int cnt) { com.google.gwt.dom.client.Element div = com.google.gwt.user.client.DOM.createDiv(); div.setClassName(diffTable.style.padding()); div.getStyle().setHeight(cnt, Unit.EM); net.codemirror.lib.Configuration config = net.codemirror.lib.Configuration.create().set("coverGutter", true).set("above", (line == 0)); cm.addLineWidget((line == 0 ? 0 : line - 1), div, config); }



public <T> com.google.gwtjsonrpc.common.AsyncCallback<T> addGwtjsonrpc(final com.google.gwtjsonrpc.common.AsyncCallback<T> cb) { callbacks.add(cb); return new com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.client.rpc.T>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.T result) { results.put(cb, result); com.google.gerrit.client.rpc.CallbackGroup.this.onSuccess(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { com.google.gerrit.client.rpc.CallbackGroup.this.onFailure(caught); } }; }
private void onSuccess() { if ((results.size()) < (callbacks.size())) { return; } for (java.lang.Object o : callbacks) { java.lang.Object result = results.get(o); if (o instanceof com.google.gwt.user.client.rpc.AsyncCallback) { @java.lang.SuppressWarnings("unchecked") com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Object> cb = ((com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Object>) (o)); cb.onSuccess(result); } else { @java.lang.SuppressWarnings("unchecked") com.google.gwtjsonrpc.common.AsyncCallback<java.lang.Object> cb = ((com.google.gwtjsonrpc.common.AsyncCallback<java.lang.Object>) (o)); cb.onSuccess(result); } } }
static void initLibrary(com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void> cb) { if (net.codemirror.lib.Loader.isLibLoaded()) { cb.onSuccess(null); } else { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); net.codemirror.lib.Loader.injectCss(Lib.I.css()); net.codemirror.lib.Loader.injectScript(Lib.I.js().getSafeUri(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void>() { public void onFailure(java.lang.Throwable caught) { } public void onSuccess(java.lang.Void result) { } })); net.codemirror.lib.Loader.injectScript(Addons.I.mark_selection().getSafeUri(), group.add(cb)); } }
public void run() { if (running.compareAndSet(false, true)) { try { task.run(); } finally { if (isPeriodic()) { running.set(false); } else { executor.remove(this); } } } }
public void end() { if (((total) == (com.google.gerrit.server.git.MultiProgressMonitor.UNKNOWN)) && ((count) > 0)) { wakeUp(); } }



private org.apache.lucene.search.Query fieldQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if ((p.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { return intQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { return exactQuery(p); } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(p.getType()); } }

public void addProjectWatch(final java.lang.String projectName, final java.lang.String filter, final com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.AccountProjectWatchInfo> callback) { run(callback, new com.google.gerrit.httpd.rpc.account.Action<com.google.gerrit.common.data.AccountProjectWatchInfo>() { public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.common.errors.InvalidQueryException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); if (filter != null) { try { com.google.gerrit.server.query.change.ChangeQueryBuilder builder = queryBuilder.create(currentUser.get()); builder.setAllowFileRegex(true); builder.parse(filter); } catch (QueryParseException badFilter) { throw new com.google.gerrit.common.errors.InvalidQueryException(badFilter.getMessage(), filter); } } com.google.gerrit.reviewdb.client.AccountProjectWatch watch = new com.google.gerrit.reviewdb.client.AccountProjectWatch(new com.google.gerrit.reviewdb.client.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey, filter)); try { db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); } catch (OrmDuplicateKeyException alreadyHave) { watch = db.accountProjectWatches().get(watch.getKey()); } return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); } }); }
@java.lang.SuppressWarnings("unchecked") private boolean filterMatch(com.google.gerrit.server.CurrentUser user, java.lang.String filter) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeQueryBuilder qb; com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p = null; if (user == null) { qb = args.queryBuilder.create(args.anonymousUser); } else { qb = args.queryBuilder.create(user); p = qb.is_visible(); } if (filter != null) { qb.setAllowFileRegex(true); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> filterPredicate = qb.parse(filter); if (p == null) { p = filterPredicate; } else { p = com.google.gerrit.server.query.Predicate.and(filterPredicate, p); } p = args.queryRewriter.get().rewrite(p); } return p == null ? true : p.match(changeData); }
public void setAllowFileRegex(boolean on) { allowFileRegex = on; }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> file(java.lang.String file) throws com.google.gerrit.server.query.QueryParseException { if (allowFileRegex) { if (file.startsWith("^")) { return new com.google.gerrit.server.query.change.RegexFilePredicate(args.dbProvider, args.patchListCache, file); } else { throw new java.lang.IllegalArgumentException(); } } else { if (file.startsWith("^")) { throw error(("regular expression not permitted here: file:" + file)); } if ((args.index) == (com.google.gerrit.server.index.ChangeIndex.DISABLED)) { throw error(("secondary index must be enabled for file:" + file)); } return new com.google.gerrit.server.query.change.EqualsFilePredicate(args.dbProvider, args.patchListCache, file); } }
private org.apache.lucene.search.Query fieldQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if ((p.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { return intQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { return exactQuery(p); } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(p.getType()); } }
public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.common.errors.InvalidQueryException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); if (filter != null) { try { com.google.gerrit.server.query.change.ChangeQueryBuilder builder = queryBuilder.create(currentUser.get()); builder.setAllowFileRegex(true); builder.parse(filter); } catch (QueryParseException badFilter) { throw new com.google.gerrit.common.errors.InvalidQueryException(badFilter.getMessage(), filter); } } com.google.gerrit.reviewdb.client.AccountProjectWatch watch = new com.google.gerrit.reviewdb.client.AccountProjectWatch(new com.google.gerrit.reviewdb.client.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey, filter)); try { db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); } catch (OrmDuplicateKeyException alreadyHave) { watch = db.accountProjectWatches().get(watch.getKey()); } return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); }

private org.apache.lucene.search.Query fieldQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if ((p.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { return intQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.TIMESTAMP)) { return com.google.gerrit.lucene.LuceneChangeIndex.timestampQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { return exactQuery(p); } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(p.getType()); } }
private void add(org.apache.lucene.document.Document doc, com.google.gerrit.server.index.FieldDef<com.google.gerrit.server.query.change.ChangeData, ?> f, java.lang.Iterable<?> values) throws com.google.gwtorm.server.OrmException { java.lang.String name = f.getName(); org.apache.lucene.document.Field.Store store = com.google.gerrit.lucene.LuceneChangeIndex.store(f); if ((f.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { for (java.lang.Object value : values) { doc.add(new org.apache.lucene.document.IntField(name, ((java.lang.Integer) (value)), store)); } } else if ((f.getType()) == (com.google.gerrit.server.index.FieldType.TIMESTAMP)) { for (java.lang.Object v : values) { doc.add(new org.apache.lucene.document.IntField(name, com.google.gerrit.lucene.LuceneChangeIndex.toIndexTime(((java.sql.Timestamp) (v))), store)); } } else if ((f.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { for (java.lang.Object value : values) { doc.add(new org.apache.lucene.document.StringField(name, ((java.lang.String) (value)), store)); } } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(f.getType()); } }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.server.query.change.ChangeData> read() throws com.google.gwtorm.server.OrmException { java.util.ArrayList<com.google.gerrit.server.query.change.ChangeData> r = new java.util.ArrayList<com.google.gerrit.server.query.change.ChangeData>(); java.util.HashSet<com.google.gerrit.reviewdb.client.Change.Id> have = new java.util.HashSet<com.google.gerrit.reviewdb.client.Change.Id>(); for (com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p : getChildren()) { if (p instanceof com.google.gerrit.server.query.change.ChangeDataSource) { for (com.google.gerrit.server.query.change.ChangeData cd : ((com.google.gerrit.server.query.change.ChangeDataSource) (p)).read()) { if (have.add(cd.getId())) { r.add(cd); } } } else { throw new com.google.gwtorm.server.OrmException(("No ChangeDataSource: " + p)); } } return new com.google.gwtorm.server.ListResultSet<com.google.gerrit.server.query.change.ChangeData>(r); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(dbProvider); return (change != null) && (status.equals(change.getStatus())); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(dbProvider); if (change == null) { return false; } com.google.gerrit.reviewdb.client.Project.NameKey p = change.getDest().getParentKey(); return p.equals(getValueKey()); }

@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { java.util.List<java.lang.String> files = object.currentFilePaths(db, cache); if (files != null) { return (java.util.Collections.binarySearch(files, value)) >= 0; } else { return true; } }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(dbProvider); if (change == null) { return false; } return getValue().equals(change.getDest().get()); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(dbProvider); return (change != null) && ((change.getLastUpdatedOn().getTime()) <= (cut)); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) { return id.equals(object.getId()); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(dbProvider); if (change == null) { return false; } return getValue().equals(change.getTopic()); }

@java.lang.Override public com.google.gerrit.server.query.change.ChangeDataSource getSource(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { java.util.Set<com.google.gerrit.reviewdb.client.Change.Status> statuses = com.google.gerrit.server.query.change.IndexRewriteImpl.getPossibleStatus(p); java.util.List<com.google.gerrit.lucene.SubIndex> indexes = com.google.common.collect.Lists.newArrayListWithCapacity(2); if (!(com.google.common.collect.Sets.intersection(statuses, com.google.gerrit.lucene.OPEN_STATUSES).isEmpty())) { indexes.add(openIndex); } if (!(com.google.common.collect.Sets.intersection(statuses, com.google.gerrit.lucene.CLOSED_STATUSES).isEmpty())) { indexes.add(closedIndex); } return new com.google.gerrit.lucene.LuceneChangeIndex.QuerySource(indexes, toQuery(p)); }

@java.lang.Override public void run() { try { sem.acquire(queueLen); } catch (java.lang.InterruptedException e) { e.printStackTrace(); } pm.end(); }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { try { final com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { context.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } @java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser() { throw new com.google.inject.OutOfScopeException("No user during ChangeIndexer"); } }); index.replace(new com.google.gerrit.server.query.change.ChangeData(change)); return null; } finally { context.setContext(null); db.close(); } } catch (java.lang.Exception e) { com.google.gerrit.server.index.ChangeIndexerImpl.log.error(java.lang.String.format("Failed to index change %d in %s", change.getChangeId(), change.getProject().get()), e); throw e; } }
@java.lang.Override public void run() { try { future.get(); done.update(1); } catch (java.lang.InterruptedException e) { fail(change, e); } catch (java.util.concurrent.ExecutionException e) { fail(change, e); } catch (java.lang.RuntimeException e) { failAndThrow(change, e); } catch (java.lang.Error e) { failAndThrow(change, e); } finally { sem.release(); } }


@java.lang.Override public java.lang.String toString() { return com.google.common.base.Objects.toStringHelper(this).omitNullValues().add("revision", revision).add("oldRevision", oldRevision).add("pathStart", pathStart).toString(); }

public com.google.gitiles.GitilesView build() { switch (type) { case HOST_INDEX : checkHostIndex(); break; case REPOSITORY_INDEX : checkRepositoryIndex(); break; case REFS : checkRefs(); break; case DESCRIBE : checkDescribe(); break; case REVISION : checkRevision(); break; case PATH : checkPath(); break; case DIFF : checkDiff(); break; case LOG : checkLog(); break; } return new com.google.gitiles.GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, params, anchor); }

public synchronized com.google.gitiles.BaseServlet getDefaultHandler(com.google.gitiles.GitilesView.Type view) { checkNotInitialized(); switch (view) { case HOST_INDEX : return new com.google.gitiles.HostIndexServlet(renderer, urls, accessFactory); case REPOSITORY_INDEX : return new com.google.gitiles.RepositoryIndexServlet(renderer, accessFactory, timeCache); case REFS : return new com.google.gitiles.RefServlet(renderer, timeCache); case REVISION : return new com.google.gitiles.RevisionServlet(renderer, linkifier()); case PATH : return new com.google.gitiles.PathServlet(renderer, urls); case DIFF : return new com.google.gitiles.DiffServlet(renderer, linkifier()); case LOG : return new com.google.gitiles.LogServlet(renderer, linkifier()); case DESCRIBE : return new com.google.gitiles.DescribeServlet(); default : throw new java.lang.IllegalArgumentException(("Invalid view type: " + view)); } }




public com.google.gitiles.GitilesView.Builder setOldRevision(com.google.gitiles.Revision revision) { switch (type) { case DIFF : case LOG : this.oldRevision = checkNotNull(revision); return this; default : throw new java.lang.IllegalStateException(java.lang.String.format("cannot set old revision on %s view", type)); } }
public com.google.gitiles.GitilesView.Builder setPathPart(java.lang.String path) { switch (type) { case PATH : case DIFF : this.path = com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash(checkNotNull(path)); return this; case DESCRIBE : case REFS : case LOG : this.path = (path != null) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash(path) : null; return this; default : throw new java.lang.IllegalStateException(java.lang.String.format("cannot set path on %s view", type)); } }

@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Change c = object.change(dbProvider); if (c == null) { return false; } final com.google.gerrit.server.project.ProjectState project = projectCache.get(c.getDest().getParentKey()); if (project == null) { return false; } final com.google.gerrit.common.data.LabelType labelType = com.google.gerrit.server.query.change.LabelPredicate.type(project.getLabelTypes(), type); final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> allApprovers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatVotedInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : object.currentApprovals(dbProvider)) { allApprovers.add(p.getAccountId()); if (labelType.matches(p)) { approversThatVotedInCategory.add(p.getAccountId()); if (match(c, p.getValue(), p.getAccountId(), labelType)) { return true; } } } final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatDidNotVoteInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(allApprovers); approversThatDidNotVoteInCategory.removeAll(approversThatVotedInCategory); for (com.google.gerrit.reviewdb.client.Account.Id a : approversThatDidNotVoteInCategory) { if (match(c, 0, a, labelType)) { return true; } } return false; }


private org.apache.lucene.search.Query fieldQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if ((p.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { return intQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.TIMESTAMP)) { return com.google.gerrit.lucene.LuceneChangeIndex.timestampQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { return exactQuery(p); } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(p.getType()); } }
private void add(org.apache.lucene.document.Document doc, com.google.gerrit.server.index.FieldDef<com.google.gerrit.server.query.change.ChangeData, ?> f, java.lang.Iterable<?> values) throws com.google.gwtorm.server.OrmException { java.lang.String name = f.getName(); org.apache.lucene.document.Field.Store store = com.google.gerrit.lucene.LuceneChangeIndex.store(f); if ((f.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { for (java.lang.Object value : values) { doc.add(new org.apache.lucene.document.IntField(name, ((java.lang.Integer) (value)), store)); } } else if ((f.getType()) == (com.google.gerrit.server.index.FieldType.TIMESTAMP)) { for (java.lang.Object v : values) { doc.add(new org.apache.lucene.document.IntField(name, com.google.gerrit.lucene.LuceneChangeIndex.toIndexTime(((java.sql.Timestamp) (v))), store)); } } else if ((f.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { for (java.lang.Object value : values) { doc.add(new org.apache.lucene.document.StringField(name, ((java.lang.String) (value)), store)); } } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(f.getType()); } }
private org.apache.lucene.search.Query exactQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) { return new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(p.getOperator(), p.getValue())); }





void replace(org.apache.lucene.index.Term term, org.apache.lucene.document.Document doc) throws java.io.IOException { writer.updateDocument(term, doc); }

void delete(org.apache.lucene.index.Term term) throws java.io.IOException { writer.deleteDocuments(term); }
void insert(org.apache.lucene.document.Document doc) throws java.io.IOException { writer.addDocument(doc); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> allApprovers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatVotedInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : object.currentApprovals(dbProvider)) { allApprovers.add(p.getAccountId()); if (p.getCategoryId().equals(category.getId())) { approversThatVotedInCategory.add(p.getAccountId()); if (match(object.change(dbProvider), p.getValue(), p.getAccountId())) { return true; } } } final java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> approversThatDidNotVoteInCategory = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(allApprovers); approversThatDidNotVoteInCategory.removeAll(approversThatVotedInCategory); for (final com.google.gerrit.reviewdb.client.Account.Id a : approversThatDidNotVoteInCategory) { if (match(object.change(dbProvider), 0, a)) { return true; } } return false; }
public com.google.gitiles.GitilesView.Builder setPathPart(java.lang.String path) { switch (type) { case PATH : case DIFF : this.path = com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash(checkNotNull(path)); break; case DESCRIBE : case REFS : case LOG : this.path = (path != null) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash(path) : null; break; default : checkState((path == null), "cannot set path on %s view", type); this.path = path; break; } return this; }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.PROJECT_SVC.listBranches(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.ListBranchesResult>(this) { @java.lang.Override public void preDisplay(final com.google.gerrit.common.data.ListBranchesResult result) { if (result.getNoRepository()) { branches.setVisible(false); addPanel.setVisible(false); delBranch.setVisible(false); com.google.gwt.user.client.ui.Label no = new com.google.gwt.user.client.ui.Label(Util.C.errorNoGitRepository()); no.setStyleName(Gerrit.RESOURCES.css().smallHeading()); add(no); } else { enableForm(true); display(result.getBranches()); addPanel.setVisible(result.getCanAdd()); } } }); savedPanel = BRANCH; }


private void refreshBranches() { com.google.gerrit.client.projects.ProjectApi.getBranches(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo>>(this) { @java.lang.Override public void preDisplay(final com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo> result) { enableForm(true); display(com.google.gerrit.client.rpc.Natives.asList(result)); } }); }
private void enableForm(final boolean on) { delBranch.setEnabled(on); addBranch.setEnabled(on); nameTxtBox.setEnabled(on); irevTxtBox.setEnabled(on); }
@java.lang.Override public void preDisplay(final com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo> result) { enableForm(true); display(com.google.gerrit.client.rpc.Natives.asList(result)); }

@java.lang.Override public void preDisplay(final com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo> result) { display(com.google.gerrit.client.rpc.Natives.asList(result)); enableForm(); }

private void refreshBranches() { com.google.gerrit.client.projects.ProjectApi.getBranches(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo>>(this) { @java.lang.Override public void preDisplay(final com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo> result) { display(com.google.gerrit.client.rpc.Natives.asList(result)); enableForm(); } }); }

private org.apache.lucene.search.Query fieldQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if ((p.getType()) == (com.google.gerrit.server.index.FieldType.INTEGER)) { return intQuery(p); } else if ((p.getType()) == (com.google.gerrit.server.index.FieldType.EXACT)) { return exactQuery(p); } else { throw com.google.gerrit.lucene.LuceneChangeIndex.badFieldType(p.getType()); } }

@java.lang.Override public boolean match(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.query.change.Arguments args) { try { return rFilter.include(rw, rw.parseCommit(args.objectId)); } catch (org.eclipse.jgit.errors.MissingObjectException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error(((args.projectName.get()) + "\" commit does not exist."), e); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error(((args.projectName.get()) + "\" revision is not a commit."), e); } catch (java.io.IOException e) { com.google.gerrit.server.query.change.MessagePredicate.log.error((("Could not search for commit message in \"" + (args.projectName.get())) + "\" repository."), e); } return false; }

@java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.gerrit.reviewdb.server.ReviewDb db = sysInjector.getInstance(com.google.gerrit.reviewdb.server.ReviewDb.class); com.google.gerrit.server.git.GitRepositoryManager mgr = sysInjector.getInstance(com.google.gerrit.server.git.GitRepositoryManager.class); repo = mgr.openRepository(project); try { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getAllRefs(); for (com.google.gerrit.reviewdb.client.Change c : db.changes().byProject(project)) { org.eclipse.jgit.lib.Ref r = refs.get(c.currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), new com.google.gerrit.server.query.change.ChangeData(c)); } } walk(); } finally { repo.close(); org.eclipse.jgit.lib.RepositoryCache.close(repo); } return null; }
@java.lang.Override public void start() { java.io.File file = com.google.gerrit.lucene.IndexVersionCheck.gerritIndexConfig(sitePaths); try { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(file, org.eclipse.jgit.util.FS.detect()); cfg.load(); for (java.util.Map.Entry<java.lang.String, java.lang.Integer> e : com.google.gerrit.lucene.IndexVersionCheck.SCHEMA_VERSIONS.entrySet()) { int schemaVersion = cfg.getInt("index", e.getKey(), "schemaVersion", 0); if (schemaVersion != (e.getValue())) { throw new com.google.inject.ProvisionException(java.lang.String.format("wrong index schema version for \"%s\": expected %d, found %d%s", e.getKey(), e.getValue(), schemaVersion, upgrade())); } } @java.lang.SuppressWarnings("deprecation") org.apache.lucene.util.Version luceneVersion = cfg.getEnum("lucene", null, "version", com.google.gerrit.lucene.LUCENE_CURRENT); if (luceneVersion != (com.google.gerrit.lucene.LuceneChangeIndex.LUCENE_VERSION)) { throw new com.google.inject.ProvisionException(java.lang.String.format("wrong Lucene version: expected %d, found %d%s", luceneVersion, com.google.gerrit.lucene.LuceneChangeIndex.LUCENE_VERSION, upgrade())); } } catch (java.io.IOException e) { throw new com.google.inject.ProvisionException(("unable to read " + file)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.inject.ProvisionException(("invalid config file " + file)); } }

private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); modules.add(com.google.gerrit.server.patch.PatchListCacheImpl.module()); modules.add(new com.google.gerrit.lucene.LuceneIndexModule(false, threads, dryRun)); modules.add(new com.google.gerrit.pgm.Reindex.ReviewDbModule()); modules.add(new com.google.inject.AbstractModule() { @java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); } }); return dbInjector.createChildInjector(modules); }
private void writeVersion() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (dryRun) { return; } org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(gerritIndexConfig(sitePaths), org.eclipse.jgit.util.FS.detect()); cfg.load(); for (java.util.Map.Entry<java.lang.String, java.lang.Integer> e : com.google.gerrit.pgm.SCHEMA_VERSIONS.entrySet()) { cfg.setInt("index", e.getKey(), "schemaVersion", e.getValue()); } cfg.setEnum("lucene", null, "version", com.google.gerrit.pgm.LUCENE_VERSION); cfg.save(); }

@java.lang.Override public void start() { java.io.File file = com.google.gerrit.lucene.IndexVersionCheck.gerritIndexConfig(sitePaths); try { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(file, org.eclipse.jgit.util.FS.detect()); cfg.load(); for (java.util.Map.Entry<java.lang.String, java.lang.Integer> e : com.google.gerrit.lucene.IndexVersionCheck.SCHEMA_VERSIONS.entrySet()) { int schemaVersion = cfg.getInt("index", e.getKey(), "schemaVersion", 0); if (schemaVersion != (e.getValue())) { throw new com.google.inject.ProvisionException(java.lang.String.format("wrong index schema version for \"%s\": expected %d, found %d%s", e.getKey(), e.getValue(), schemaVersion, upgrade())); } } @java.lang.SuppressWarnings("deprecation") org.apache.lucene.util.Version luceneVersion = cfg.getEnum("lucene", null, "version", com.google.gerrit.lucene.LUCENE_CURRENT); if (luceneVersion != (com.google.gerrit.lucene.LuceneChangeIndex.LUCENE_VERSION)) { throw new com.google.inject.ProvisionException(java.lang.String.format("wrong Lucene version: expected %d, found %d%s", luceneVersion, com.google.gerrit.lucene.LuceneChangeIndex.LUCENE_VERSION, upgrade())); } } catch (java.io.IOException e) { throw new com.google.inject.ProvisionException(("unable to read " + file)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.inject.ProvisionException(("invalid config file " + file)); } }
public static java.io.File gerritIndexConfig(com.google.gerrit.server.config.SitePaths sitePaths) { return new java.io.File(sitePaths.index_dir, "gerrit_index.config"); }

@java.lang.Override protected void configure() { install(new com.google.gerrit.server.index.IndexModule(threads)); bind(com.google.gerrit.server.index.ChangeIndex.class).to(com.google.gerrit.lucene.LuceneChangeIndex.class); listener().to(com.google.gerrit.lucene.LuceneChangeIndex.class); if (checkVersion) { listener().to(com.google.gerrit.lucene.IndexVersionCheck.class); } }







public static java.io.File gerritIndexConfig(com.google.gerrit.server.config.SitePaths sitePaths) { return new java.io.File(sitePaths.index_dir, "gerrit_index.config"); }


@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp(); index = new com.google.gerrit.server.query.change.IndexRewriteTest.DummyIndex(); queryBuilder = new com.google.gerrit.server.query.change.IndexRewriteTest.QueryBuilder(); rewrite = new com.google.gerrit.server.query.change.IndexRewriteImpl(index); }
@java.lang.Override public com.google.gerrit.server.query.change.ChangeDataSource getSource(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { return new com.google.gerrit.server.query.change.IndexRewriteTest.Source(); }
public static java.util.EnumSet<com.google.gerrit.reviewdb.client.Change.Status> getPossibleStatus(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in) { if (in instanceof com.google.gerrit.server.query.change.ChangeStatusPredicate) { return java.util.EnumSet.of(((com.google.gerrit.server.query.change.ChangeStatusPredicate) (in)).getStatus()); } else if ((in.getClass()) == (com.google.gerrit.server.query.NotPredicate.class)) { return java.util.EnumSet.complementOf(com.google.gerrit.server.query.change.IndexRewriteImpl.getPossibleStatus(in.getChild(0))); } else if ((in.getClass()) == (com.google.gerrit.server.query.OrPredicate.class)) { java.util.EnumSet<com.google.gerrit.reviewdb.client.Change.Status> s = java.util.EnumSet.noneOf(Change.Status.class); for (int i = 0; i < (in.getChildCount()); i++) { s.addAll(com.google.gerrit.server.query.change.IndexRewriteImpl.getPossibleStatus(in.getChild(i))); } return s; } else if ((in.getClass()) == (com.google.gerrit.server.query.AndPredicate.class)) { java.util.EnumSet<com.google.gerrit.reviewdb.client.Change.Status> s = java.util.EnumSet.allOf(Change.Status.class); for (int i = 0; i < (in.getChildCount()); i++) { s.retainAll(com.google.gerrit.server.query.change.IndexRewriteImpl.getPossibleStatus(in.getChild(i))); } return s; } else if ((in.getChildCount()) == 0) { return java.util.EnumSet.allOf(Change.Status.class); } else { throw new java.lang.IllegalStateException(("Invalid predicate type in change index query: " + (in.getClass()))); } }
private com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> partitionChildren(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in, java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> newChildren, java.util.BitSet toWrap) { if ((toWrap.cardinality()) == 1) { int i = toWrap.nextSetBit(0); newChildren.set(i, wrap(newChildren.get(i))); return in.copy(newChildren); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> wrapped = com.google.common.collect.Lists.newArrayListWithCapacity(toWrap.cardinality()); java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> all = com.google.common.collect.Lists.newArrayListWithCapacity((((newChildren.size()) - (toWrap.cardinality())) + 1)); for (int i = 0; i < (newChildren.size()); i++) { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> child = newChildren.get(i); if (toWrap.get(i)) { wrapped.add(child); if (com.google.gerrit.server.query.change.IndexRewriteImpl.allNonIndexOnly(child)) { all.add(child); } } else { all.add(child); } } all.add(wrap(in.copy(wrapped))); return in.copy(all); }
private com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> rewriteImpl(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in) { if (in instanceof com.google.gerrit.server.index.IndexPredicate) { return in; } if (!(com.google.gerrit.server.query.change.IndexRewriteImpl.isRewritePossible(in))) { return null; } int n = in.getChildCount(); java.util.BitSet toKeep = new java.util.BitSet(n); java.util.BitSet toWrap = new java.util.BitSet(n); java.util.BitSet rewritten = new java.util.BitSet(n); java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> newChildren = com.google.common.collect.Lists.newArrayListWithCapacity(n); for (int i = 0; i < n; i++) { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> c = in.getChild(i); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> nc = rewriteImpl(c); if (nc == null) { toKeep.set(i); newChildren.add(c); } else if (nc == c) { toWrap.set(i); newChildren.add(nc); } else { rewritten.set(i); newChildren.add(nc); } } if ((toKeep.cardinality()) == n) { return null; } if ((rewritten.cardinality()) == n) { return in.copy(newChildren); } if ((toWrap.cardinality()) == n) { return in; } return partitionChildren(in, newChildren, toWrap); }
@java.lang.Override public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> rewrite(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in) { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> out = rewriteImpl(in); if (out == null) { return in; } else if (out == in) { return wrap(out); } else { return out; } }
private com.google.gerrit.server.index.PredicateWrapper wrap(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) { try { return new com.google.gerrit.server.index.PredicateWrapper(index, p); } catch (com.google.gerrit.server.query.QueryParseException e) { throw new java.lang.IllegalStateException((("Failed to convert " + p) + " to index predicate"), e); } }
private com.google.gerrit.server.index.PredicateWrapper wrap(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { return new com.google.gerrit.server.index.PredicateWrapper(index, p); }

public com.google.gerrit.server.account.GroupControl controlFor(com.google.gerrit.common.data.GroupDescription.Basic group) { return new com.google.gerrit.server.account.GroupControl(user.get(), group); }
public final void setOwnerUUID(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { owner_id(com.google.gwt.http.client.URL.encodePathSegment(uuid.get())); }
public final AccountGroup.UUID getOwnerUUID() { java.lang.String owner = owner_id(); if (owner != null) { return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gwt.http.client.URL.decodePathSegment(owner)); } return null; }
public com.google.gerrit.server.account.GroupControl controlFor(final com.google.gerrit.server.CurrentUser who, final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.common.data.GroupDescription.Basic group = groupBackend.get(groupId); if (group == null) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupId); } return new com.google.gerrit.server.account.GroupControl(who, group); }
public boolean isVisible() { com.google.gerrit.reviewdb.client.AccountGroup accountGroup = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); return ((((accountGroup != null) && (accountGroup.isVisibleToAll())) || ((user) instanceof com.google.gerrit.server.InternalUser)) || (user.getEffectiveGroups().contains(group.getGroupUUID()))) || (isOwner()); }
public final AccountGroup.UUID getGroupUUID() { return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gwt.http.client.URL.decodePathSegment(id())); }
private void renderComments(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> comments, boolean isDraft) { for (int i = 0; (comments != null) && (i < (comments.length())); i++) { com.google.gerrit.client.changes.CommentInfo info = comments.get(i); com.google.gerrit.common.changes.Side mySide = info.side(); net.codemirror.lib.CodeMirror cm = (mySide == (com.google.gerrit.common.changes.Side.PARENT)) ? cmA : cmB; net.codemirror.lib.CodeMirror other = (cm.equals(cmA)) ? cmB : cmA; final com.google.gerrit.client.diff.CommentBox box = new com.google.gerrit.client.diff.CommentBox(info.author(), info.updated(), info.message(), isDraft); int line = (info.line()) - 1; net.codemirror.lib.Configuration config = net.codemirror.lib.Configuration.create().set("coverGutter", true); diffTable.add(box); cm.addLineWidget(line, box.getElement(), config); int lineToPad = gapProcessor.lineOnOther(mySide, line); final com.google.gwt.dom.client.Element paddingOtherside = addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX); java.lang.Runnable callback = new java.lang.Runnable() { @java.lang.Override public void run() { paddingOtherside.getStyle().setHeight(box.getOffsetHeight(), Unit.PX); } }; resizeCallbacks.add(callback); box.addClickHandler(callback); } }
private void setMessageText(java.lang.String message) { if (message == null) { message = ""; } else { message = message.trim(); } summary.setInnerText(com.google.gerrit.client.diff.CommentBox.summarize(message)); contentPanelMessage.setInnerText(message); }
@java.lang.Override protected void onOpenRow(final int row) { com.google.gwt.user.client.History.newItem(com.google.gerrit.client.Dispatcher.toGroup(getRowItem(row).getGroupId())); }

private void setAuthorNameText(com.google.gerrit.client.account.AccountInfo author) { avatar = new com.google.gerrit.client.AvatarImage(author, 26); name.setInnerText(com.google.gerrit.client.FormatUtil.name(author)); }


private void setDoubleClickHandler() { if ((messageClick) == null) { messageClick = contentPanelMessage.addDomHandler(new com.google.gwt.event.dom.client.DoubleClickHandler() { @java.lang.Override public void onDoubleClick(com.google.gwt.event.dom.client.DoubleClickEvent arg0) { editArea.setText(contentPanelMessage.getText()); setEdit((!(isEdit()))); runClickCallback(); } }, com.google.gwt.event.dom.client.DoubleClickEvent.getType()); } }

@java.lang.Override public void onUnload() { super.onUnload(); if ((messageClick) != null) { messageClick.removeHandler(); messageClick = null; } }

private void display(com.google.gerrit.client.diff.DiffInfo diffInfo) { cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA()); cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB()); render(diffInfo); initialBoxes = new java.util.ArrayList<com.google.gerrit.client.diff.CommentBox>(); publishedMap = new java.util.HashMap<java.lang.String, com.google.gerrit.client.diff.PublishedBox>(published.length()); renderPublished(); renderDrafts(); published = null; drafts = null; resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { if ((cmA) != null) { cmA.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cmA.refresh(); } if ((cmB) != null) { cmB.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.CodeMirrorDemo.HEADER_FOOTER))); cmB.refresh(); } } }); cmA.on("scroll", doScroll(cmB)); cmB.on("scroll", doScroll(cmA)); }


java.util.List<org.eclipse.jgit.transport.URIish> getURIs(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String urlMatch) { java.util.List<org.eclipse.jgit.transport.URIish> r = com.google.common.collect.Lists.newArrayListWithCapacity(remote.getURIs().size()); for (org.eclipse.jgit.transport.URIish uri : remote.getURIs()) { if (com.googlesource.gerrit.plugins.replication.Destination.matches(uri, urlMatch)) { java.lang.String name = project.get(); if (com.googlesource.gerrit.plugins.replication.Destination.needsUrlEncoding(uri)) { name = com.googlesource.gerrit.plugins.replication.Destination.encode(name); } if (remoteNameStyle.equals("dash")) { name = name.replace("/", "-"); } else if (remoteNameStyle.equals("underscore")) { name = name.replace("/", "_"); } else if (!(remoteNameStyle.equals("slash"))) { ReplicationQueue.log.debug(java.lang.String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle)); } java.lang.String replacedPath = com.googlesource.gerrit.plugins.replication.ReplicationQueue.replaceName(uri.getPath(), name); if (replacedPath != null) { uri = uri.setPath(replacedPath); r.add(uri); } } } return r; }

@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { final java.lang.String newOwner = ownerTxt.getText().trim(); if ((newOwner.length()) > 0) { com.google.gerrit.client.groups.GroupApi.setGroupOwner(getGroupUUID(), newOwner, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.groups.GroupInfo>() { public void onSuccess(final com.google.gerrit.client.groups.GroupInfo result) { updateOwnerGroup(result); saveOwner.setEnabled(false); } }); } }
private void scheduleShow() { if ((hideTimer) != null) { hideTimer.cancel(); hideTimer = null; } if (((popup.isShowing()) && (popup.isVisible())) || ((showTimer) != null)) { return; } showTimer = new com.google.gwt.user.client.Timer() { @java.lang.Override public void run() { if ((!(popup.isShowing())) || (!(popup.isVisible()))) { popup.showRelativeTo(target); } } }; showTimer.schedule(600); }
private static <T> com.google.inject.Provider<T> find(com.google.inject.Injector src, com.google.inject.TypeLiteral<T> type) { java.util.List<com.google.inject.Binding<T>> bindings = src.findBindingsByType(type); if ((bindings != null) && ((bindings.size()) == 1)) { return bindings.get(0).getProvider(); } else if ((bindings != null) && ((bindings.size()) > 1)) { throw new com.google.inject.ProvisionException(java.lang.String.format(("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration."), type)); } else { return null; } }


@java.lang.Override public com.google.gerrit.server.query.change.ChangeDataSource getSource(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { return new com.google.gerrit.server.query.change.IndexRewriteTest.Source(); }
@java.lang.Override protected void configure() { install(new com.google.gerrit.server.index.IndexModule(threads)); listener().to(com.google.gerrit.lucene.LuceneChangeIndex.class); if (checkVersion) { listener().to(com.google.gerrit.lucene.IndexVersionCheck.class); } }

private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); modules.add(com.google.gerrit.server.patch.PatchListCacheImpl.module()); modules.add(new com.google.gerrit.lucene.LuceneIndexModule(false, threads)); modules.add(new com.google.gerrit.pgm.Reindex.ReviewDbModule()); modules.add(new com.google.inject.AbstractModule() { @java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); } }); return dbInjector.createChildInjector(modules); }

@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); if (!(com.google.gerrit.server.index.IndexModule.isEnabled(dbInjector))) { throw die("Secondary index not enabled"); } com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sitePaths = dbInjector.getInstance(com.google.gerrit.server.config.SitePaths.class); deleteAll(); sysInjector = createSysInjector(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); int result = indexAll(); writeVersion(); sysManager.stop(); dbManager.stop(); return result; }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.ChangeIndexer.class).to(com.google.gerrit.server.index.ChangeIndexerImpl.class); bind(com.google.gerrit.server.query.change.IndexRewrite.class).to(com.google.gerrit.server.query.change.IndexRewriteImpl.class); bind(new com.google.inject.TypeLiteral<com.google.gerrit.server.index.Schema<com.google.gerrit.server.query.change.ChangeData>>() {}).toInstance(com.google.gerrit.server.index.ChangeSchemas.getLatestRelease()); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.server.index.ChangeIndex.class); com.google.gerrit.extensions.registration.DynamicItem.itemOf(binder(), com.google.gerrit.server.index.ChangeIndex.class); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.ChangeIndexer.class).to(com.google.gerrit.server.index.ChangeIndexerImpl.class); bind(com.google.gerrit.server.query.change.IndexRewrite.class).to(com.google.gerrit.server.query.change.IndexRewriteImpl.class); bind(com.google.gerrit.server.index.IndexCollection.class); listener().to(com.google.gerrit.server.index.IndexCollection.class); }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); if ((com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) == (com.google.gerrit.server.index.IndexModule.IndexType.SQL)) { throw die("index.type must be configured (or not SQL)"); } if ((version) == null) { version = com.google.gerrit.server.index.ChangeSchemas.getLatest().getVersion(); } com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); deleteIndex(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); int result = indexAll(); getIndex(sysInjector).markReady(); sysManager.stop(); dbManager.stop(); return result; }
private int indexAll() throws java.lang.Exception { com.google.gerrit.reviewdb.server.ReviewDb db = sysInjector.getInstance(com.google.gerrit.reviewdb.server.ReviewDb.class); com.google.common.util.concurrent.ListeningScheduledExecutorService executor = sysInjector.getInstance(com.google.inject.Key.get(com.google.common.util.concurrent.ListeningScheduledExecutorService.class, com.google.gerrit.server.index.IndexExecutor.class)); org.eclipse.jgit.lib.ProgressMonitor pm = new org.eclipse.jgit.lib.TextProgressMonitor(); pm.start(1); pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN); java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> projects = com.google.common.collect.Sets.newTreeSet(); int changeCount = 0; try { for (com.google.gerrit.reviewdb.client.Change change : db.changes().all()) { changeCount++; if (projects.add(change.getProject())) { pm.update(1); } } } finally { db.close(); } pm.endTask(); final com.google.gerrit.server.git.MultiProgressMonitor mpm = new com.google.gerrit.server.git.MultiProgressMonitor(java.lang.System.err, "Reindexing changes"); final com.google.gerrit.server.git.MultiProgressMonitor.Task projTask = mpm.beginSubTask("projects", projects.size()); final com.google.gerrit.server.git.MultiProgressMonitor.Task doneTask = mpm.beginSubTask(null, changeCount); final com.google.gerrit.server.git.MultiProgressMonitor.Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN); com.google.common.base.Stopwatch sw = new com.google.common.base.Stopwatch().start(); final java.util.List<com.google.common.util.concurrent.ListenableFuture<?>> futures = com.google.common.collect.Lists.newArrayListWithCapacity(projects.size()); final java.util.concurrent.atomic.AtomicBoolean ok = new java.util.concurrent.atomic.AtomicBoolean(true); for (final com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { final com.google.common.util.concurrent.ListenableFuture<?> future = executor.submit(new com.google.gerrit.pgm.Reindex.ReindexProject(project, doneTask, failedTask)); futures.add(future); future.addListener(new java.lang.Runnable() { @java.lang.Override public void run() { try { future.get(); } catch (java.lang.InterruptedException e) { fail(project, e); } catch (java.util.concurrent.ExecutionException e) { ok.set(false); } catch (java.lang.RuntimeException e) { failAndThrow(project, e); } catch (java.lang.Error e) { failAndThrow(project, e); } finally { projTask.update(1); } } private void fail(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.Throwable t) { com.google.gerrit.pgm.Reindex.log.error(("Failed to index project " + project), t); ok.set(false); } private void failAndThrow(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.RuntimeException e) { fail(project, e); throw e; } private void failAndThrow(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.Error e) { fail(project, e); throw e; } }, com.google.common.util.concurrent.MoreExecutors.sameThreadExecutor()); } mpm.waitFor(com.google.common.util.concurrent.Futures.transform(com.google.common.util.concurrent.Futures.successfulAsList(futures), new com.google.common.util.concurrent.AsyncFunction<java.util.List<?>, java.lang.Void>() { @java.lang.Override public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> apply(java.util.List<?> input) throws java.lang.Exception { mpm.end(); return com.google.common.util.concurrent.Futures.immediateFuture(null); } })); double elapsed = (sw.elapsed(java.util.concurrent.TimeUnit.MILLISECONDS)) / 1000.0; int n = (doneTask.getCount()) + (failedTask.getCount()); java.lang.System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, (n / elapsed)); return ok.get() ? 0 : 1; }


@java.lang.Override protected void configure() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override public void configure() { factory(LuceneChangeIndex.Factory.class); } }); install(new com.google.gerrit.server.index.IndexModule(threads)); if ((singleVersion) == null) { listener().to(com.google.gerrit.lucene.LuceneVersionManager.class).in(com.google.gerrit.lucene.SINGLETON); } else { install(new com.google.gerrit.lucene.LuceneIndexModule.SingleVersionModule()); } }
@java.lang.Override public void start() { org.eclipse.jgit.storage.file.FileBasedConfig cfg; try { cfg = com.google.gerrit.lucene.LuceneVersionManager.loadGerritIndexConfig(sitePaths); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw fail(e); } catch (java.io.IOException e) { throw fail(e); } java.util.TreeMap<java.lang.Integer, com.google.gerrit.lucene.LuceneVersionManager.Version> versions = scanVersions(cfg); com.google.gerrit.lucene.LuceneVersionManager.Version search = null; java.util.List<com.google.gerrit.lucene.LuceneVersionManager.Version> write = com.google.common.collect.Lists.newArrayListWithCapacity(2); for (com.google.gerrit.lucene.LuceneVersionManager.Version v : versions.descendingMap().values()) { if ((v.schema) == null) { continue; } if (write.isEmpty()) { write.add(v); } if (v.ready) { search = v; if (!(write.contains(v))) { write.add(v); } } } if (search == null) { throw new com.google.inject.ProvisionException("No index versions ready; run Reindex"); } markNotReady(cfg, versions.values(), write); com.google.gerrit.lucene.LuceneChangeIndex searchIndex = indexFactory.create(search.schema, readOnly); indexes.setSearchIndex(searchIndex); for (com.google.gerrit.lucene.LuceneVersionManager.Version v : versions.values()) { if ((v.schema) != null) { if ((v.version) != (search.version)) { indexes.addWriteIndex(indexFactory.create(v.schema, readOnly)); } else { indexes.addWriteIndex(searchIndex); } } } }
protected void onCellSingleClick(int row, int column) { movePointerTo(row); }

@java.lang.Override public void onKeyUp(final com.google.gwt.event.dom.client.KeyUpEvent event) { if ((event.getNativeKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE)) { hide(); } }
void setPadding(net.codemirror.lib.LineWidget widget, com.google.gwt.dom.client.Element element) { paddingWidget = widget; paddingWidgetEle = element; }
protected void setOpen(boolean open) { if (open) { removeStyleName(res.style().close()); addStyleName(res.style().open()); } else { removeStyleName(res.style().open()); addStyleName(res.style().close()); } resizePaddingWidget(); }
private void renderPublished() { for (int i = 0; ((published) != null) && (i < (published.length())); i++) { com.google.gerrit.client.changes.CommentInfo info = published.get(i); final com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, revision, info, commentLinkProcessor); box.setOpen(false); addCommentBox(info, box); initialBoxes.add(box); publishedMap.put(info.id(), box); getLineBoxMapFromSide(info.side()).put(((info.line()) - 1), box); } }
@java.lang.Override public void onShowView() { super.onShowView(); if ((cmA) != null) { cmA.refresh(); } if ((cmB) != null) { cmB.refresh(); } com.google.gwt.user.client.Window.enableScrolling(false); for (com.google.gerrit.client.diff.CommentBox box : initialBoxes) { box.resizePaddingWidget(); } }
private com.google.gerrit.client.diff.CodeMirrorDemo.LineWidgetElementPair addPaddingWidget(net.codemirror.lib.CodeMirror cm, java.lang.String style, int line, int height, com.google.gwt.dom.client.Style.Unit unit) { com.google.gwt.dom.client.Element div = com.google.gwt.user.client.DOM.createDiv(); div.setClassName(style); div.getStyle().setHeight(height, unit); net.codemirror.lib.Configuration config = net.codemirror.lib.Configuration.create().set("coverGutter", true).set("above", (line == (-1))); net.codemirror.lib.LineWidget widget = cm.addLineWidget((line == (-1) ? 0 : line), div, config); return new com.google.gerrit.client.diff.CodeMirrorDemo.LineWidgetElementPair(widget, div); }
public void run() { java.util.Map<java.lang.Integer, com.google.gerrit.client.diff.CommentBox> lineBoxMap = (cm == (cmA)) ? lineBoxMapA : lineBoxMapB; int line = cm.getActiveLine(); com.google.gerrit.client.diff.CommentBox box = lineBoxMap.get(line); if (box == null) { lineBoxMap.put(line, addNewDraft(cm, line)); } else if (box.isDraft()) { ((com.google.gerrit.client.diff.DraftBox) (lineBoxMap.get(line))).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).onReply(null); } }
void setEdit(boolean edit) { if (edit) { setOpen(true); removeStyleName(draftStyle.view()); addStyleName(draftStyle.edit()); editArea.setText(contentPanelMessage.getText()); editArea.setFocus(true); } else { removeStyleName(draftStyle.edit()); addStyleName(draftStyle.view()); } resizePaddingWidget(); }
void resizePaddingWidget() { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { paddingWidgetEle.getStyle().setHeight(getOffsetHeight(), Unit.PX); paddingWidget.changed(); selfWidget.changed(); } }); }
private com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.changes.CommentInfo info, boolean doSave) { com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(this, revision, info, commentLinkProcessor, true, doSave); addCommentBox(info, box); if (!doSave) { box.setEdit(true); } getLineBoxMapFromSide(info.side()).put(((info.line()) - 1), box); return box; }
private java.lang.Runnable insertNewDraft(final net.codemirror.lib.CodeMirror cm) { return new java.lang.Runnable() { public void run() { java.util.Map<java.lang.Integer, com.google.gerrit.client.diff.CommentBox> lineBoxMap = (cm == (cmA)) ? lineBoxMapA : lineBoxMapB; int line = cm.getActiveLine(); com.google.gerrit.client.diff.CommentBox box = lineBoxMap.get(line); if (box == null) { lineBoxMap.put(line, addNewDraft(cm, line)); } else if (box.isDraft()) { ((com.google.gerrit.client.diff.DraftBox) (lineBoxMap.get(line))).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).onReply(null); } } }; }
private void removeUI() { if ((replyToBox) != null) { replyToBox.unregisterReplyBox(); } com.google.gerrit.client.changes.CommentInfo info = getOriginal(); getDiffView().removeCommentBox(info.side(), ((info.line()) - 1)); removeFromParent(); getSelfWidget().clear(); getPaddingWidget().clear(); }
com.google.gerrit.client.diff.DraftBox addReply(com.google.gerrit.client.changes.CommentInfo replyTo, java.lang.String initMessage, boolean doSave) { com.google.gerrit.common.changes.Side side = replyTo.side(); int line = replyTo.line(); com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.create(path, side, line, replyTo.id(), initMessage); return addDraftBox(info, doSave); }
private com.google.gerrit.client.diff.DraftBox addNewDraft(net.codemirror.lib.CodeMirror cm, int line) { com.google.gerrit.common.changes.Side side = (cm == (cmA)) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION; com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.create(path, side, (line + 1), null, null); return addDraftBox(info, false); }
private void renderDrafts() { for (int i = 0; ((drafts) != null) && (i < (drafts.length())); i++) { com.google.gerrit.client.changes.CommentInfo info = drafts.get(i); final com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(this, revision, info, commentLinkProcessor, false, false); box.setOpen(false); box.setEdit(false); addCommentBox(info, box); initialBoxes.add(box); com.google.gerrit.client.diff.PublishedBox replyToBox = publishedMap.get(info.in_reply_to()); if (replyToBox != null) { replyToBox.registerReplyBox(box); } getLineBoxMapFromSide(info.side()).put(((info.line()) - 1), box); } }
protected net.codemirror.lib.LineWidget getSelfWidget() { return selfWidget; }
private void doSave() { project.setDescription(descTxt.getText().trim()); project.setUseContributorAgreements(com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contributorAgreements)); project.setUseSignedOffBy(com.google.gerrit.client.admin.ProjectInfoScreen.getBool(signedOffBy)); project.setUseContentMerge(com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contentMerge)); project.setRequireChangeID(com.google.gerrit.client.admin.ProjectInfoScreen.getBool(requireChangeID)); if ((submitType.getSelectedIndex()) >= 0) { project.setSubmitType(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex()))); } if ((state.getSelectedIndex()) >= 0) { project.setState(Project.State.valueOf(state.getValue(state.getSelectedIndex()))); } enableForm(false, false, false, false); Util.PROJECT_SVC.changeProjectSettings(project, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.ProjectDetail>() { public void onSuccess(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType, result.canModifyState); display(result); } }); }

net.codemirror.lib.LineCharacter advance(int numOfChar) { while ((currLineIndex) < (lines.length())) { int lengthWithNewline = ((lines.get(currLineIndex).length()) - (currLineOffset)) + 1; if (numOfChar < lengthWithNewline) { net.codemirror.lib.LineCharacter at = net.codemirror.lib.LineCharacter.create(((startLine) + (currLineIndex)), (numOfChar + (currLineOffset))); currLineOffset += numOfChar; return at; } numOfChar -= lengthWithNewline; advanceLine(); } throw new java.lang.IllegalStateException("EditIterator index out of bound"); }



@org.junit.Test public void testEndsBeforeNewline() { com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator iter = new com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator(lines, 0); assertLineChsEqual(net.codemirror.lib.LineCharacter.create(0, 3), iter.advance(3)); }





@org.junit.Test public void testSimpleAdvance() { com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator iter = new com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator(lines, 0); assertLineChsEqual(net.codemirror.lib.LineCharacter.create(0, 1), iter.advance(1)); }
private void markEdit(net.codemirror.lib.CodeMirror cm, com.google.gwt.core.client.JsArrayString lines, com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Span> edits, int startLine) { if (edits == null) { return; } com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator iter = new com.google.gerrit.client.diff.CodeMirrorDemo.EditIterator(lines, startLine); net.codemirror.lib.Configuration diffOpt = net.codemirror.lib.Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true); net.codemirror.lib.Configuration editOpt = net.codemirror.lib.Configuration.create().set("className", diffTable.style.intraline()).set("readOnly", true); net.codemirror.lib.LineCharacter last = net.codemirror.lib.LineCharacter.create(0, 0); for (int i = 0; i < (edits.length()); i++) { com.google.gerrit.client.diff.DiffInfo.Span span = edits.get(i); net.codemirror.lib.LineCharacter from = iter.advance(span.skip()); net.codemirror.lib.LineCharacter to = iter.advance(span.mark()); int fromLine = from.getLine(); if ((last.getLine()) == fromLine) { cm.markText(last, from, diffOpt); } else { cm.markText(net.codemirror.lib.LineCharacter.create(fromLine, 0), from, diffOpt); } cm.markText(from, to, editOpt); last = to; for (int line = fromLine; line < (to.getLine()); line++) { cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.intraline()); } } }
public void run() { if (cm.hasActiveLine()) { cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } if (other.hasActiveLine()) { other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } int line = cm.getCursor("head").getLine(); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther((cm == (cmA) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), line); int oLine = info.getLine(); cm.setActiveLine(line); cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine()); cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); if (info.isAligned()) { other.setActiveLine(oLine); other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine()); other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } }
private java.lang.Runnable updateActiveLine(final net.codemirror.lib.CodeMirror cm) { final net.codemirror.lib.CodeMirror other = otherCM(cm); return new java.lang.Runnable() { public void run() { if (cm.hasActiveLine()) { cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } if (other.hasActiveLine()) { other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } int line = cm.getCursor("head").getLine(); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther((cm == (cmA) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), line); int oLine = info.getLine(); cm.setActiveLine(line); cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine()); cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); if (info.isAligned()) { other.setActiveLine(oLine); other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine()); other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } } }; }
static void initLibrary(com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void> cb) { if (net.codemirror.lib.Loader.isLibLoaded()) { cb.onSuccess(null); } else { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); net.codemirror.lib.Loader.injectCss(Lib.I.css()); net.codemirror.lib.Loader.injectScript(Lib.I.js().getSafeUri(), group.add(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback())); net.codemirror.lib.Loader.injectScript(Addons.I.mark_selection().getSafeUri(), group.add(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback())); net.codemirror.lib.Loader.injectScript(Addons.I.foldcode().getSafeUri(), group.addFinal(cb)); } }
private void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.PatchSet ps = ins.getPatchSet(); final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); ins.setReviewers(recipients.getReviewers()).insert(); created = true; workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change); cm.setFrom(me); cm.setPatchSet(ps, ins.getPatchSetInfo()); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot send email for new change " + (change.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newchange"; } })); if (((magicBranch) != null) && (magicBranch.isSubmit())) { submit(projectControl.controlFor(change), ps); } }
public void insert() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.ChangeUtil.insertAncestors(db, patchSet.getId(), commit); db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); com.google.gerrit.server.ChangeUtil.updateTrackingIds(db, change, trackingFooters, commit.getFooterLines()); com.google.gerrit.common.data.LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); db.commit(); } finally { db.rollback(); } if ((changeMessage) != null) { db.changeMessages().insert(java.util.Collections.singleton(changeMessage)); } indexer.index(change); gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), org.eclipse.jgit.lib.ObjectId.zeroId(), commit); if (runHooks) { hooks.doPatchsetCreatedHook(change, patchSet, db); } }
private void showTextBox() { if ((textBox) == null) { textBox = new com.google.gwt.user.client.ui.TextBox(); textBox.setText(getText()); textBox.setVisibleLength(visibleLen); textBox.addKeyPressHandler(new com.google.gwt.event.dom.client.KeyPressHandler() { @java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.isControlKeyDown()) || (event.isMetaKeyDown())) { switch (event.getCharCode()) { case 'c' : case 'x' : com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.user.client.Command() { public void execute() { hideTextBox(); } }); break; } } } }); textBox.addBlurHandler(new com.google.gwt.event.dom.client.BlurHandler() { @java.lang.Override public void onBlur(final com.google.gwt.event.dom.client.BlurEvent event) { hideTextBox(); } }); content.insert(textBox, 1); } textLabel.setVisible(false); textBox.setVisible(true); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.user.client.Command() { @java.lang.Override public void execute() { textBox.selectAll(); textBox.setFocus(true); } }); }


public void run() { if (cm.hasActiveLine()) { cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } if (other.hasActiveLine()) { other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } int line = cm.getCursor("head").getLine(); net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); if (hiddenSkipMap.containsKey(handle)) { line -= hiddenSkipMap.get(handle); handle = cm.getLineHandle(line); } cm.setActiveLine(handle); if (cm.somethingSelected()) { return; } cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine()); cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther((cm == (cmA) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), line); int oLine = info.getLine(); if (info.isAligned()) { other.setActiveLine(other.getLineHandle(oLine)); other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine()); other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } }





private java.lang.Runnable updateActiveLine(final net.codemirror.lib.CodeMirror cm) { final net.codemirror.lib.CodeMirror other = otherCM(cm); return new java.lang.Runnable() { public void run() { if (cm.hasActiveLine()) { cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } if (other.hasActiveLine()) { other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine()); other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } int line = cm.getCursor("head").getLine(); net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); if (hiddenSkipMap.containsKey(handle)) { line -= hiddenSkipMap.get(handle); handle = cm.getLineHandle(line); } cm.setActiveLine(handle); if (cm.somethingSelected()) { return; } cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine()); cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther((cm == (cmA) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), line); int oLine = info.getLine(); if (info.isAligned()) { other.setActiveLine(other.getLineHandle(oLine)); other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine()); other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg()); } } }; }
@java.lang.Override protected void onLoad() { super.onLoad(); res.style().ensureInjected(); }

void setEdit(boolean edit) { if (edit) { setOpen(true); removeStyleName(draftStyle.view()); addStyleName(draftStyle.edit()); editArea.setText(contentPanelMessage.getText()); editArea.setFocus(true); } else { removeStyleName(draftStyle.edit()); addStyleName(draftStyle.view()); } resizePaddingWidget(); }
@java.lang.Override protected void onUnload() { super.onUnload(); removeKeyHandlerRegs(); if ((resizeHandler) != null) { resizeHandler.removeHandler(); resizeHandler = null; } if ((cmA) != null) { cmA.getWrapperElement().removeFromParent(); cmA = null; } if ((cmB) != null) { cmB.getWrapperElement().removeFromParent(); cmB = null; } com.google.gwt.user.client.Window.enableScrolling(true); }
private void renderPublished() { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(published); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { final com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, revision, info, commentLinkProcessor); box.setOpen(false); initialBoxes.add(box); publishedMap.put(info.id(), box); int line = (info.line()) - 1; net.codemirror.lib.CodeMirror.LineHandle handle = getCmFromSide(info.side()).getLineHandle(line); lineLastPublishedBoxMap.put(handle, box); lineActiveBoxMap.put(handle, box); addCommentBox(info, box); } }

private void postProcessCommand(final com.google.gerrit.common.data.UiCommandDetail cmd, final com.google.gwt.user.client.ui.Button b) { b.setEnabled(false); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString> cb = new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); new com.google.gerrit.client.ErrorDialog(caught).center(); } @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { b.setEnabled(true); if ((msg != null) && (!(msg.asString().isEmpty()))) { com.google.gwt.user.client.Window.alert(msg.asString()); } } }; com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(patchSet.getId()).view(cmd.id); if ("PUT".equalsIgnoreCase(cmd.method)) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(cmd.method)) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } }
private void populateCommands(final com.google.gerrit.common.data.PatchSetDetail detail) { for (final UiCommandDetail cmd : detail.getCommands()) { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button(); b.setText(cmd.label); b.setEnabled(cmd.enabled); b.setTitle(cmd.title); b.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { if (((cmd.confirmationMessage) != null) && (!(cmd.confirmationMessage.isEmpty()))) { com.google.gerrit.client.ConfirmationDialog confirmationDialog = new com.google.gerrit.client.ConfirmationDialog(cmd.title, new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(cmd.confirmationMessage), new com.google.gerrit.client.ConfirmationCallback() { @java.lang.Override public void onOk() { postProcessCommand(cmd, b); } }); confirmationDialog.center(); } else { postProcessCommand(cmd, b); } } private void postProcessCommand(final UiCommandDetail cmd, final com.google.gwt.user.client.ui.Button b) { b.setEnabled(false); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString> cb = new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); new com.google.gerrit.client.ErrorDialog(caught).center(); } @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { b.setEnabled(true); if ((msg != null) && (!(msg.asString().isEmpty()))) { com.google.gwt.user.client.Window.alert(msg.asString()); } } }; com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(patchSet.getId()).view(cmd.id); if ("PUT".equalsIgnoreCase(cmd.method)) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(cmd.method)) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } } }); actionsPanel.add(b); } }





void setEdit(boolean edit) { if (edit) { setOpen(true); removeStyleName(draftStyle.view()); addStyleName(draftStyle.edit()); editArea.setText(getOriginal().message()); expandText(); editArea.setFocus(true); disableClickFocusHandler(); } else { expandTimer.cancel(); removeStyleName(draftStyle.edit()); addStyleName(draftStyle.view()); enableClickFocusHandler(); } resizePaddingWidget(); }

@com.google.gwt.uibinder.client.UiHandler("save") void onSave(com.google.gwt.event.dom.client.ClickEvent e) { final java.lang.String message = editArea.getText(); if (message.equals("")) { return; } com.google.gerrit.client.changes.CommentInfo original = getOriginal(); com.google.gerrit.client.changes.CommentInput input = com.google.gerrit.client.changes.CommentInput.create(original); input.setMessage(message); com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo> cb = new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { updateOriginal(result); setMessageText(message); setDate(result.updated()); setEdit(false); if (isNew) { removeStyleName(draftStyle.newDraft()); isNew = false; } } }; if (isNew) { com.google.gerrit.client.changes.CommentApi.createDraft(getPatchSetId(), input, cb); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb); } getCm().focus(); }
void setReviewed(boolean reviewed) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(patchId).view("files").id(fileId).view("reviewed"); if (reviewed) { api.put(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } else { api.delete(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } toggleReviewedBox(reviewed); }
private void loadDiff(final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { com.google.gerrit.client.diff.DiffApi.list(changeId.get(), rev.name(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo> m) { files.setRevisions(null, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number())); files.setValue(m); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); }





@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { setEnabled(false); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString> cb = new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { setEnabled(true); new com.google.gerrit.client.ErrorDialog(caught).center(); } @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString msg) { setEnabled(true); if ((msg != null) && (!(msg.asString().isEmpty()))) { com.google.gwt.user.client.Window.alert(msg.asString()); } com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(changeId)); } }; com.google.gerrit.client.rpc.RestApi api = ((revision) != null) ? com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision) : com.google.gerrit.client.changes.ChangeApi.change(changeId.get()); api.view(action.id()); if ("PUT".equalsIgnoreCase(action.method())) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(action.method())) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } }






private void setTable(com.google.gerrit.client.change.FileTable.MyTable table) { clear(); add(table); this.table = table; if (register) { table.setRegisterKeys(true); } }
private void loadSubmitAction(final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev) { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), rev.name()).view("submit_type").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString result) { java.lang.String action = result.asString(); try { com.google.gerrit.reviewdb.client.Project.SubmitType type = Project.SubmitType.valueOf(action); submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type)); } catch (java.lang.IllegalArgumentException e) { submitActionText.setInnerText(action); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }); }
@java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { if ((cmA) != null) { cmA.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER))); cmA.refresh(); } if ((cmB) != null) { cmB.setHeight(((event.getHeight()) - (com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER))); cmB.refresh(); } }


private void setPaddingHeight(int height) { padding.element.getStyle().setHeight(height, Unit.PX); padding.widget.changed(); }
private com.google.gerrit.client.diff.PaddingManager.LineWidgetElementPair addPaddingWidget(net.codemirror.lib.CodeMirror cm, java.lang.String style, int line, double height, com.google.gwt.dom.client.Style.Unit unit, java.lang.Integer index) { com.google.gwt.dom.client.Element div = com.google.gwt.user.client.DOM.createDiv(); div.setClassName(style); div.getStyle().setHeight(height, unit); net.codemirror.lib.Configuration config = net.codemirror.lib.Configuration.create().set("coverGutter", true).set("above", (line == (-1))); if (index != null) { config = config.set("insertAt", index); } net.codemirror.lib.LineWidget widget = cm.addLineWidget((line == (-1) ? 0 : line), div, config); return new com.google.gerrit.client.diff.PaddingManager.LineWidgetElementPair(widget, div); }


@java.lang.Override public void onShowView() { super.onShowView(); if ((cmA) != null) { cmA.refresh(); } if ((cmB) != null) { cmB.refresh(); } com.google.gwt.user.client.Window.enableScrolling(false); for (com.google.gerrit.client.diff.CommentBox box : initialBoxes) { box.resizePaddingWidget(); } com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { if ((cmA) != null) { cmA.setOption("viewportMargin", 10); } if ((cmB) != null) { cmB.setOption("viewportMargin", 10); } } }); ((cmB) != null ? cmB : cmA).focus(); }




private void installPlugins() throws java.io.IOException { final java.io.File myWar; try { myWar = com.google.gerrit.launcher.GerritLauncher.getDistributionArchive(); } catch (java.io.FileNotFoundException e) { java.lang.System.err.println("warn: Cannot find gerrit.war"); return; } boolean foundPlugin = false; try { final java.util.zip.ZipFile zf = new java.util.zip.ZipFile(myWar); try { final java.util.Enumeration<? extends java.util.zip.ZipEntry> e = zf.entries(); while (e.hasMoreElements()) { final java.util.zip.ZipEntry ze = e.nextElement(); if (ze.isDirectory()) { continue; } if ((ze.getName().startsWith(com.google.gerrit.pgm.init.InitPlugins.PLUGIN_DIR)) && (ze.getName().endsWith(com.google.gerrit.pgm.init.InitPlugins.JAR))) { if (!foundPlugin) { if (!(ui.yesno(false, "Prompt to install core plugins"))) { return; } foundPlugin = true; } final java.lang.String pluginJarName = new java.io.File(ze.getName()).getName(); final java.lang.String pluginName = pluginJarName.substring(0, ((pluginJarName.length()) - (com.google.gerrit.pgm.init.InitPlugins.JAR.length()))); final java.io.InputStream in = zf.getInputStream(ze); try { final java.io.File tmpPlugin = com.google.gerrit.server.plugins.PluginLoader.storeInTemp(pluginName, in, site); final java.lang.String pluginVersion = com.google.gerrit.pgm.init.InitPlugins.getVersion(tmpPlugin); if (!(ui.yesno(false, "Install plugin %s version %s", pluginName, pluginVersion))) { tmpPlugin.delete(); continue; } final java.io.File plugin = new java.io.File(site.plugins_dir, pluginJarName); if (plugin.exists()) { final java.lang.String installedPluginVersion = com.google.gerrit.pgm.init.InitPlugins.getVersion(plugin); if (!(ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion))) { tmpPlugin.delete(); continue; } if (!(plugin.delete())) { throw new java.io.IOException(((("Failed to delete plugin " + pluginName) + ": ") + (plugin.getAbsolutePath()))); } } if (!(tmpPlugin.renameTo(plugin))) { throw new java.io.IOException(((((("Failed to install plugin " + pluginName) + ": ") + (tmpPlugin.getAbsolutePath())) + " -> ") + (plugin.getAbsolutePath()))); } } finally { in.close(); } } } } finally { zf.close(); } } catch (java.io.IOException e) { throw new java.io.IOException("Failure during plugin installation", e); } if (!foundPlugin) { ui.message("No plugins found."); } }
@java.lang.Override public int run() throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); final com.google.gerrit.pgm.Init.SiteInit init = createSiteInit(); init.flags.autoStart = (!(noAutoStart)) && (init.site.isNew); final com.google.gerrit.pgm.Init.SiteRun run; try { init.initializer.run(); init.flags.deleteOnFailure = false; run = createSiteRun(init); run.upgradeSchema(); } catch (java.lang.Exception failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.Init.recursiveDelete(getSitePath()); } throw failure; } catch (java.lang.Error failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.Init.recursiveDelete(getSitePath()); } throw failure; } java.lang.System.err.println(("Initialized " + (getSitePath().getCanonicalPath()))); run.start(); return 0; }

private void getImpl(final com.google.gerrit.reviewdb.client.Project.NameKey name, final com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> cb) { com.google.gerrit.client.projects.ConfigInfoCache.Entry e = cache.get(name.get()); if (e != null) { cb.onSuccess(e); return; } com.google.gerrit.client.projects.ProjectApi.config(name).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { com.google.gerrit.client.projects.ConfigInfoCache.Entry e = new com.google.gerrit.client.projects.ConfigInfoCache.Entry(result); cache.put(name.get(), e); cb.onSuccess(e); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { cb.onFailure(caught); } }); }
private void installPlugins() throws java.io.IOException { java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPlugins(); for (com.google.gerrit.pgm.init.InitPlugins.PluginData plugin : plugins) { java.lang.String pluginName = plugin.name; java.lang.String pluginJarName = plugin.jarName; java.io.InputStream in = new java.io.ByteArrayInputStream(plugin.content.toByteArray()); try { final java.io.File tmpPlugin = com.google.gerrit.server.plugins.PluginLoader.storeInTemp(pluginName, in, site); final java.lang.String pluginVersion = com.google.gerrit.pgm.init.InitPlugins.getVersion(tmpPlugin); if (!(ui.yesno(false, "Install plugin %s version %s", pluginName, pluginVersion))) { tmpPlugin.delete(); continue; } final java.io.File p = new java.io.File(site.plugins_dir, pluginJarName); if (p.exists()) { final java.lang.String installedPluginVersion = com.google.gerrit.pgm.init.InitPlugins.getVersion(p); if (!(ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion))) { tmpPlugin.delete(); continue; } if (!(p.delete())) { throw new java.io.IOException(((("Failed to delete plugin " + pluginName) + ": ") + (p.getAbsolutePath()))); } } if (!(tmpPlugin.renameTo(p))) { throw new java.io.IOException(((((("Failed to install plugin " + pluginName) + ": ") + (tmpPlugin.getAbsolutePath())) + " -> ") + (p.getAbsolutePath()))); } } finally { in.close(); } } if (plugins.isEmpty()) { ui.message("No plugins found."); } }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); }
@java.lang.Override public int run() throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); if (listPlugins) { com.google.gerrit.pgm.util.ConsoleUI ui = com.google.gerrit.pgm.util.ConsoleUI.getInstance(); java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPlugins(); ui.message("Available plugins are:\n"); for (com.google.gerrit.pgm.init.InitPlugins.PluginData plugin : plugins) { ui.message(" * %s\n", plugin.name); } if (plugins.isEmpty()) { ui.message("No plugins found.\n"); } return 0; } final com.google.gerrit.pgm.Init.SiteInit init = createSiteInit(); init.flags.autoStart = (!(noAutoStart)) && (init.site.isNew); final com.google.gerrit.pgm.Init.SiteRun run; try { init.initializer.run(); init.flags.deleteOnFailure = false; run = createSiteRun(init); run.upgradeSchema(); } catch (java.lang.Exception failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.Init.recursiveDelete(getSitePath()); } throw failure; } catch (java.lang.Error failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.Init.recursiveDelete(getSitePath()); } throw failure; } java.lang.System.err.println(("Initialized " + (getSitePath().getCanonicalPath()))); run.start(); return 0; }


@com.google.gwt.uibinder.client.UiHandler("replyDone") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { if ((replyBox) == null) { com.google.gerrit.client.diff.DraftBox box = getDiffView().addReply(getOriginal(), "Done", true); registerReplyBox(box); } else { openReplyBox(); } }
@com.google.gwt.uibinder.client.UiHandler("reply") void onReply(com.google.gwt.event.dom.client.ClickEvent e) { if ((replyBox) == null) { com.google.gerrit.client.diff.DraftBox box = getDiffView().addReply(getOriginal(), "", false); registerReplyBox(box); } else { openReplyBox(); } }

@java.lang.Override protected void onUnload() { for (com.google.gwt.event.shared.HandlerRegistration h : keys) { h.removeHandler(); } keys.clear(); super.onUnload(); }


@java.lang.Override public void onShowView() { super.onShowView(); java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView(); if ((prior != null) && (prior.startsWith("/c/"))) { scrollToPath(prior.substring(3)); } }
private void renderChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { statusText.setInnerText(com.google.gerrit.client.changes.Util.toLongString(info.status())); boolean current = (info.status().isOpen()) && (revision.equals(info.current_revision())); boolean canSubmit = labels.set(info, current); renderOwner(info); renderReviewers(info); renderActionTextDate(info); renderRevisions(info); renderHistory(info); actions.display(info, revision); star.setValue(info.starred()); permalink.setHref(com.google.gerrit.client.ui.ChangeLink.permalink(changeId)); changeIdText.setInnerText(java.lang.String.valueOf(info.legacy_id())); projectText.setInnerText(info.project()); branchText.setInnerText(info.branch()); idText.setText(("Change-Id: " + (info.change_id()))); idText.setPreviewText(info.change_id()); reload.set(info); topic.set(info); commit.set(commentLinkProcessor, info, revision); quickApprove.set(info, revision); if (com.google.gerrit.client.Gerrit.isSignedIn()) { replyAction = new com.google.gerrit.client.change.ReplyAction(info, revision, style, reply); if (topic.canEdit()) { keysAction.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 't', Util.C.keyEditTopic()) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { topic.onEdit(); } }); } } if (current) { loadMergeable(canSubmit); } reply.setVisible(((replyAction) != null)); java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append(Util.M.changeScreenTitleId(info.id_abbreviated())); if ((info.subject()) != null) { sb.append(": "); sb.append(info.subject()); } setWindowTitle(sb.toString()); }



@java.lang.Override public void onShowView() { super.onShowView(); java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView(); if ((prior != null) && (prior.startsWith("/c/"))) { scrollToPath(prior.substring(3)); } }

@com.google.gwt.uibinder.client.UiHandler("editArea") void onKeyDown(com.google.gwt.event.dom.client.KeyDownEvent e) { if ((((e.isControlKeyDown()) || (e.isMetaKeyDown())) && (!(e.isAltKeyDown()))) && (!(e.isShiftKeyDown()))) { switch (e.getNativeKeyCode()) { case 's' : case 'S' : e.preventDefault(); onSave(); return; } } else if ((((e.getNativeKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE)) && ((comment.id()) == null)) && ((editArea.getValue().length()) == 0)) { removeUI(); return; } expandTimer.schedule(250); }
void setEdit(boolean edit) { com.google.gwt.user.client.ui.UIObject.setVisible(summary, false); com.google.gwt.user.client.ui.UIObject.setVisible(p_view, (!edit)); com.google.gwt.user.client.ui.UIObject.setVisible(p_edit, edit); if (edit) { final java.lang.String msg = ((comment.message()) != null) ? comment.message().trim() : ""; editArea.setValue(msg); editArea.setFocus(true); expandText(); if ((msg.length()) > 0) { com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { editArea.setCursorPos(msg.length()); return false; } }, 0); } } else { expandTimer.cancel(); } resizePaddingWidget(); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.ReviewerResource rsrc, com.google.gerrit.server.change.DeleteReviewer.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = rsrc.getControl(); com.google.gerrit.reviewdb.client.Change.Id changeId = rsrc.getChange().getId(); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); db.changes().beginTransaction(changeId); try { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> del = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvals(db, rsrc)) { if (control.canRemoveReviewer(a)) { del.add(a); } else { throw new com.google.gerrit.extensions.restapi.AuthException("delete not permitted"); } } if (del.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } db.patchSetApprovals().delete(del); db.commit(); } finally { db.rollback(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public void execute() { assert (selfWidget) != null; assert (widgetManager) != null; selfWidget.changed(); widgetManager.resizePaddingWidget(); }
void resizePaddingWidget() { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { public void execute() { assert (selfWidget) != null; assert (widgetManager) != null; selfWidget.changed(); widgetManager.resizePaddingWidget(); } }); }
private void removeUI() { if ((replyToBox) != null) { replyToBox.unregisterReplyBox(); } parent.removeDraft(this, comment.side(), ((comment.line()) - 1)); removeFromParent(); getSelfWidget().clear(); com.google.gerrit.client.diff.PaddingManager manager = getPaddingManager(); manager.remove(this); manager.resizePaddingWidget(); cm.focus(); }
@java.lang.Override public void start() { queue.start(); if (((srvInfo.getState()) == (ServerInformation.State.STARTUP)) && (queue.replicateAllOnPluginStart)) { pushAllFuture.set(pushAll.create(null).schedule(30, java.util.concurrent.TimeUnit.SECONDS)); } }
void scheduleFullSync(final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String urlMatch) { if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn("Replication plugin did not finish startup before event"); return; } for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { for (org.eclipse.jgit.transport.URIish uri : cfg.getURIs(project, urlMatch)) { cfg.schedule(project, PushOne.ALL_REFS, uri); } } }



@java.lang.Override public void run() { try { for (com.google.gerrit.reviewdb.client.Project.NameKey nameKey : projectCache.all()) { replication.scheduleFullSync(nameKey, urlMatch); } } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.replication.PushAll.log.error("Cannot enumerate known projects", e); } }

@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.replication.Failure { if ((all) && ((projectNames.size()) > 0)) { throw new com.googlesource.gerrit.plugins.replication.UnloggedFailure(1, "error: cannot combine --all and PROJECT"); } if (all) { pushAllFactory.create(urlMatch).schedule(0, java.util.concurrent.TimeUnit.SECONDS); } else { for (java.lang.String name : projectNames) { com.google.gerrit.reviewdb.client.Project.NameKey key = new com.google.gerrit.reviewdb.client.Project.NameKey(name); if ((projectCache.get(key)) != null) { replication.scheduleFullSync(key, urlMatch); } else { throw new com.googlesource.gerrit.plugins.replication.UnloggedFailure(1, (("error: '" + name) + "': not a Gerrit project")); } } } }
@java.lang.Override public void onGitReferenceUpdated(com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Event event) { if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn("Replication plugin did not finish startup before event"); return; } com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); for (com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Update u : event.getUpdates()) { for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { if (cfg.wouldPushRef(u.getRefName())) { for (org.eclipse.jgit.transport.URIish uri : cfg.getURIs(project, null)) { cfg.schedule(project, u.getRefName(), uri); } } } } }











public void stop() { if ((manager) != null) { manager.stop(); manager = null; sysInjector = null; sshInjector = null; httpInjector = null; } }


static com.google.gerrit.server.plugins.Plugin.ApiType getApiType(java.util.jar.Manifest manifest) throws com.google.gerrit.server.plugins.InvalidPluginException { java.util.jar.Attributes main = manifest.getMainAttributes(); java.lang.String v = main.getValue("Gerrit-ApiType"); if ((com.google.common.base.Strings.isNullOrEmpty(v)) || (com.google.gerrit.server.plugins.Plugin.ApiType.EXTENSION.name().equalsIgnoreCase(v))) { return com.google.gerrit.server.plugins.Plugin.ApiType.EXTENSION; } else if (com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN.name().equalsIgnoreCase(v)) { return com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN; } else if (com.google.gerrit.server.plugins.Plugin.ApiType.JS.name().equalsIgnoreCase(v)) { return com.google.gerrit.server.plugins.Plugin.ApiType.JS; } else { throw new com.google.gerrit.server.plugins.InvalidPluginException(("Invalid Gerrit-ApiType: " + v)); } }
@java.lang.Override public java.io.File get() { if (!(ready)) { synchronized(dataDir) { if ((!(dataDir.exists())) && (!(dataDir.mkdirs()))) { throw new com.google.inject.ProvisionException(java.lang.String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), name)); } ready = true; } } return dataDir; }
public void start(com.google.gerrit.server.plugins.PluginGuiceEnvironment env) throws java.lang.Exception { com.google.inject.Injector root = newRootInjector(env); manager = new com.google.gerrit.lifecycle.LifecycleManager(); com.google.gerrit.server.plugins.AutoRegisterModules auto = null; if ((((sysModule) == null) && ((sshModule) == null)) && ((httpModule) == null)) { auto = new com.google.gerrit.server.plugins.AutoRegisterModules(name, env, jarFile, classLoader); auto.discover(); } if ((sysModule) != null) { sysInjector = root.createChildInjector(root.getInstance(sysModule)); manager.add(sysInjector); } else if ((auto != null) && ((auto.sysModule) != null)) { sysInjector = root.createChildInjector(auto.sysModule); manager.add(sysInjector); } else { sysInjector = root; } if (env.hasSshModule()) { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newLinkedList(); if ((apiType) == (com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN)) { modules.add(env.getSshModule()); } if ((sshModule) != null) { modules.add(sysInjector.getInstance(sshModule)); sshInjector = sysInjector.createChildInjector(modules); manager.add(sshInjector); } else if ((auto != null) && ((auto.sshModule) != null)) { modules.add(auto.sshModule); sshInjector = sysInjector.createChildInjector(modules); manager.add(sshInjector); } } if (env.hasHttpModule()) { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newLinkedList(); if ((apiType) == (com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN)) { modules.add(env.getHttpModule()); } if ((httpModule) != null) { modules.add(sysInjector.getInstance(httpModule)); httpInjector = sysInjector.createChildInjector(modules); manager.add(httpInjector); } else if ((auto != null) && ((auto.httpModule) != null)) { modules.add(auto.httpModule); httpInjector = sysInjector.createChildInjector(modules); manager.add(httpInjector); } } manager.start(); }
private static java.io.File initSite() throws java.lang.Exception { java.io.File tmp = com.google.gerrit.acceptance.TempFileUtil.createTempDirectory(); com.google.gerrit.pgm.Init init = new com.google.gerrit.pgm.Init(); int rc = init.main(new java.lang.String[]{ "-d", tmp.getPath(), "--batch", "--no-auto-start" }); if (rc != 0) { throw new java.lang.RuntimeException("Couldn't initialize site"); } return tmp; }
private Change.Id insertPatchSet(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, org.eclipse.jgit.revwalk.RevCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit).setMessage(buildChangeMessage(patchSetId, change)).insert(); return change.getId(); }
com.google.gerrit.server.change.PatchSetInserter create(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.revwalk.RevCommit commit);
void setEdit(boolean edit) { com.google.gwt.user.client.ui.UIObject.setVisible(summary, false); com.google.gwt.user.client.ui.UIObject.setVisible(p_view, (!edit)); com.google.gwt.user.client.ui.UIObject.setVisible(p_edit, edit); if (edit) { final java.lang.String msg = ((comment.message()) != null) ? comment.message().trim() : ""; editArea.setValue(msg); editArea.setFocus(true); expandText(); if ((msg.length()) > 0) { com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { editArea.setCursorPos(msg.length()); return false; } }, 0); } } else { expandTimer.cancel(); } resizePaddingWidget(); }
private void registerCmEvents(final net.codemirror.lib.CodeMirror cm) { cm.on("cursorActivity", updateActiveLine(cm)); cm.on("scroll", doScroll(cm)); scrollTimerA = new com.google.gwt.user.client.Timer() { @java.lang.Override public void run() { fixScroll(cmA); } }; scrollTimerB = new com.google.gwt.user.client.Timer() { @java.lang.Override public void run() { fixScroll(cmB); } }; cm.on("viewportChange", adjustGutters(cm)); cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, (-1))).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm))); }
public java.lang.String getHttpUrl(com.google.gerrit.acceptance.GerritServer server) { java.lang.StringBuilder b = new java.lang.StringBuilder(); b.append("http://"); b.append(username); b.append(":"); b.append(httpPassword); b.append(("@localhost:" + (server.getHttpPort()))); return b.toString(); }
private com.jcraft.jsch.Session getSession() throws com.jcraft.jsch.JSchException { if ((session) == null) { com.jcraft.jsch.JSch jsch = new com.jcraft.jsch.JSch(); jsch.addIdentity("KeyPair", account.privateKey(), account.sshKey.getPublicKeyBlob(), null); session = jsch.getSession(account.username, "localhost", port); session.setConfig("StrictHostKeyChecking", "no"); session.connect(); } return session; }
public java.lang.String getGitSshUrl() { if ((sshdListenAddressString) == null) { return ""; } java.lang.String[] urlParts = sshdListenAddressString.split(":"); if ((urlParts.length) < 2) { com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.log.error(("Invalid SSHD listenUrl: " + (sshdListenAddressString))); return ""; } try { java.lang.String hostname = getHost(urlParts[0]); int port = getPort(urlParts[1]); return (((((("ssh://" + (com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.GITBLIT_USER)) + "@") + hostname) + (port == (com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.SSH_DEF_PORT) ? "" : ":" + port)) + "/") + (com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.GITBLIT_REPO)) + ""; } catch (java.net.UnknownHostException e) { com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.log.error("Cannot detect localhostname"); return ""; } }
public java.lang.String getGitHttpUrl() throws java.net.UnknownHostException { java.lang.String httpListenUrl = getHttpListenUrl(); if (httpListenUrl == null) { return ""; } java.lang.String httpUrl = com.google.common.base.Objects.firstNonNull(canonicalWebUrlString, httpListenUrl); httpUrl = httpUrl.replace("://", (("://" + (com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.GITBLIT_USER)) + "@")); httpUrl += (httpUrl.endsWith("/") ? "" : "/") + (com.googlesource.gerrit.plugins.gitblit.GitBlitUrlsConfig.GITBLIT_REPO); return httpUrl; }
private void renderPublished() { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(published); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { net.codemirror.lib.CodeMirror cm = getCmFromSide(info.side()); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, commentLinkProcessor, revision, info); allBoxes.add(box); publishedMap.put(info.id(), box); int line = (info.line()) - 1; net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); lineLastPublishedBoxMap.put(handle, box); lineActiveBoxMap.put(handle, box); addCommentBox(info, box); } }

public static com.google.gerrit.client.changes.CommentInfo create(java.lang.String path, com.google.gerrit.common.changes.Side side, int line, java.lang.String in_reply_to, java.lang.String message) { com.google.gerrit.client.changes.CommentInfo info = createObject().cast(); info.setPath(path); info.setSide(side); info.setLine(line); info.setInReplyTo(in_reply_to); info.setMessage(message); return info; }


private java.lang.Runnable insertNewDraft(final net.codemirror.lib.CodeMirror cm) { return new java.lang.Runnable() { public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getActiveLine(); int line = cm.getLineNumber(handle); com.google.gerrit.client.diff.CommentBox box = lineActiveBoxMap.get(handle); if (box == null) { lineActiveBoxMap.put(handle, addNewDraft(cm, line)); } else if (box.isDraft()) { ((com.google.gerrit.client.diff.DraftBox) (lineActiveBoxMap.get(handle))).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).onReply(null); } } }; }
public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getActiveLine(); int line = cm.getLineNumber(handle); com.google.gerrit.client.diff.CommentBox box = lineActiveBoxMap.get(handle); if (box == null) { lineActiveBoxMap.put(handle, addNewDraft(cm, line)); } else if (box.isDraft()) { ((com.google.gerrit.client.diff.DraftBox) (lineActiveBoxMap.get(handle))).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).onReply(null); } }
private void renderPublished() { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(published); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { net.codemirror.lib.CodeMirror cm = getCmFromSide(info.side()); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, cm, revision, info, commentLinkProcessor); box.setOpen(false); allBoxes.add(box); publishedMap.put(info.id(), box); int line = (info.line()) - 1; net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); lineLastPublishedBoxMap.put(handle, box); lineActiveBoxMap.put(handle, box); addCommentBox(info, box); } }
private void renderDrafts() { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(drafts); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(this, getCmFromSide(info.side()), revision, info, commentLinkProcessor, false, false); box.setOpen(false); box.setEdit(false); allBoxes.add(box); if ((published) != null) { com.google.gerrit.client.diff.PublishedBox replyToBox = publishedMap.get(info.in_reply_to()); if (replyToBox != null) { replyToBox.registerReplyBox(box); } } lineActiveBoxMap.put(getCmFromSide(info.side()).getLineHandle(((info.line()) - 1)), box); addCommentBox(info, box); } }
private com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.changes.CommentInfo info, boolean doSave) { net.codemirror.lib.CodeMirror cm = getCmFromSide(info.side()); com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave); addCommentBox(info, box); if (!doSave) { box.setEdit(true); } net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(((info.line()) - 1)); lineActiveBoxMap.put(handle, box); return box; }
com.google.gerrit.client.diff.DraftBox addReply(com.google.gerrit.client.changes.CommentInfo replyTo, java.lang.String initMessage, boolean doSave) { com.google.gerrit.common.changes.Side side = replyTo.side(); int line = replyTo.line(); com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.create(path, side, line, replyTo.id(), initMessage); return addDraftBox(info, doSave); }
private void removeUI() { setEdit(false); expandTimer.cancel(); if ((replyToBox) != null) { replyToBox.unregisterReplyBox(); } com.google.gerrit.client.changes.CommentInfo info = getOriginal(); getDiffView().removeDraft(this, info.side(), ((info.line()) - 1)); removeFromParent(); getSelfWidget().clear(); com.google.gerrit.client.diff.PaddingManager manager = getPaddingManager(); manager.remove(this); manager.resizePaddingWidget(); getCm().focus(); }



@com.google.gwt.uibinder.client.UiHandler("reply") void onReply(com.google.gwt.event.dom.client.ClickEvent e) { if ((replyBox) == null) { com.google.gerrit.client.diff.DraftBox box = getDiffView().addReply(getOriginal(), "", false); registerReplyBox(box); } else { openReplyBox(); } }
@com.google.gwt.uibinder.client.UiHandler("replyDone") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { if ((replyBox) == null) { com.google.gerrit.client.diff.DraftBox box = getDiffView().addReply(getOriginal(), "Done", true); registerReplyBox(box); } else { openReplyBox(); } }


void resizePaddingWidget() { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { public void execute() { if (((selfWidget) == null) || ((widgetManager) == null)) { throw new java.lang.IllegalStateException("resizePaddingWidget() called before setting up widgets"); } selfWidget.changed(); widgetManager.resizePaddingWidget(); } }); }
private void registerCmEvents(final net.codemirror.lib.CodeMirror cm) { cm.on("cursorActivity", updateActiveLine(cm)); cm.on("gutterClick", onGutterClick(cm)); cm.on("scroll", doScroll(cm)); scrollTimerA = new com.google.gwt.user.client.Timer() { @java.lang.Override public void run() { fixScroll(cmA); } }; scrollTimerB = new com.google.gwt.user.client.Timer() { @java.lang.Override public void run() { fixScroll(cmB); } }; cm.on("viewportChange", adjustGutters(cm)); cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, (-1))).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm))); }
@java.lang.Override public void onShowView() { super.onShowView(); handlers.add(com.google.gwtexpui.user.client.UserAgent.addDialogVisibleHandler(new com.google.gwtexpui.user.client.DialogVisibleHandler() { @java.lang.Override public void onDialogVisible(com.google.gwtexpui.user.client.DialogVisibleEvent event) { diffTable.getElement().getStyle().setVisibility((event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE)); } })); if ((cmA) != null) { cmA.refresh(); } if ((cmB) != null) { cmB.refresh(); } com.google.gwt.user.client.Window.enableScrolling(false); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { if ((cmA) != null) { cmA.setOption("viewportMargin", 10); } if ((cmB) != null) { cmB.setOption("viewportMargin", 10); } resizeCodeMirror(); } }); ((cmB) != null ? cmB : cmA).focus(); }
void resizeCodeMirror() { int h = (((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + (reviewed.getOffsetHeight())) + (diffTable.getHeaderHeight())) + 5; if ((cmA) != null) { cmA.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - h)); cmA.refresh(); } if ((cmB) != null) { cmB.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - h)); cmB.refresh(); } diffTable.sidePanel.adjustGutters(cmB); }



private void registerCmEvents(net.codemirror.lib.CodeMirror cm) { cm.on("cursorActivity", updateActiveLine(cm)); cm.on("scroll", doScroll(cm)); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'j'", moveCursorDown(cm, 1))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'k'", moveCursorDown(cm, (-1)))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'u'", upToChange())); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'o'", toggleOpenBox(cm))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("Enter", toggleOpenBox(cm))); net.codemirror.lib.CodeMirror.defineVimEx("up", "u", upToChange()); net.codemirror.lib.CodeMirror.defineVimEx("mark", "m", toggleReviewed()); if (com.google.gerrit.client.Gerrit.isSignedIn()) { cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("'c'", insertNewDraft(cm))); } for (java.lang.String s : new java.lang.String[]{ "C", "J", "K", "O", "R", "U", "Ctrl-C", "Ctrl-F", "Enter" }) { net.codemirror.lib.CodeMirror.disableUnwantedKey("vim", s); } }

private void removeUI() { setEdit(false); expandTimer.cancel(); if ((replyToBox) != null) { replyToBox.unregisterReplyBox(); } com.google.gerrit.client.changes.CommentInfo info = getOriginal(); getDiffView().removeDraft(info.side(), ((info.line()) - 1)); removeFromParent(); getSelfWidget().clear(); com.google.gerrit.client.diff.PaddingManager manager = getPaddingManager(); manager.remove(this); manager.resizePaddingWidget(); getCm().focus(); }

private void isValid(java.lang.String sessionToken, java.lang.String[] clearTextParts) throws com.googlesource.gerrit.plugins.github.oauth.OAuthTokenException { int hashCode = java.lang.Integer.parseInt(clearTextParts[3]); if (hashCode != ((((((clearTextParts[0]) + "/") + (clearTextParts[1])) + "/") + (clearTextParts[2])).hashCode())) { throw new com.googlesource.gerrit.plugins.github.oauth.OAuthTokenException(("Invalid or forged token " + sessionToken)); } long ts = java.lang.Long.parseLong(clearTextParts[1]); if (((java.lang.System.currentTimeMillis()) - ts) > (com.googlesource.gerrit.plugins.github.oauth.OAuthCookieProvider.COOKIE_TIMEOUT)) { throw new com.googlesource.gerrit.plugins.github.oauth.OAuthTokenException((("Session token " + sessionToken) + " has expired")); } }
public com.google.gerrit.server.data.ChangeAttribute asChangeAttribute(final com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.data.ChangeAttribute a = new com.google.gerrit.server.data.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.topic = change.getTopic(); a.id = change.getKey().get(); a.number = change.getId().toString(); a.subject = change.getSubject(); a.url = getChangeUrl(change); a.owner = asAccountAttribute(change.getOwner()); a.status = change.getStatus(); return a; }
void resizeCodeMirror() { int h = (((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + (reviewed.getOffsetHeight())) + (diffTable.getHeaderHeight())) + 5; if ((cmA) != null) { cmA.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - h)); cmA.refresh(); } if ((cmB) != null) { cmB.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - h)); cmB.refresh(); } }








com.google.gerrit.server.git.validators.MergeValidators create();
public void validatePreMerge(com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch) throws com.google.gerrit.server.git.validators.MergeValidationException { java.util.List<com.google.gerrit.server.git.validators.MergeValidationListener> validators = com.google.common.collect.Lists.newLinkedList(); validators.add(new com.google.gerrit.server.git.validators.MergeValidators.PluginMergeValidationListener(mergeValidationListeners)); for (com.google.gerrit.server.git.validators.MergeValidationListener validator : validators) { validator.onPreMerge(commit, destProject, destBranch); } }
private boolean isUnreasonableName(final com.google.gerrit.reviewdb.client.Project.NameKey nameKey) { final java.lang.String name = nameKey.get(); if ((name.length()) == 0) return true; if ((name.charAt(((name.length()) - 1))) == '/') return true; if ((name.indexOf('\\')) >= 0) return true; if ((name.charAt(0)) == '/') return true; if (new java.io.File(name).isAbsolute()) return true; if (name.startsWith("../")) return true; if (name.contains("/../")) return true; if (name.contains("/./")) return true; if (name.contains("//")) return true; if (name.contains("?")) return true; if (name.contains("%")) return true; if (name.contains("*")) return true; if (name.contains(":")) return true; if (name.contains("<")) return true; if (name.contains(">")) return true; if (name.contains("|")) return true; if (name.contains("$")) return true; if (name.contains("\r")) return true; return false; }
private Project.NameKey getProjectName(final java.lang.String prefix, final java.lang.String fileName) { final java.lang.String projectName; if (fileName.equals(Constants.DOT_GIT)) { projectName = prefix.substring(0, ((prefix.length()) - 1)); } else if (fileName.endsWith(Constants.DOT_GIT_EXT)) { int newLen = (fileName.length()) - (Constants.DOT_GIT_EXT.length()); projectName = prefix + (fileName.substring(0, newLen)); } else { projectName = prefix + fileName; } return new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); }



public static com.google.gerrit.client.changes.CommentInfo createLine(java.lang.String path, com.google.gerrit.common.changes.Side side, int line, java.lang.String in_reply_to, java.lang.String message) { com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.createFile(path, side, in_reply_to, message); info.setLine(line); return info; }


private com.google.gerrit.reviewdb.client.PatchLineComment update(com.google.gerrit.reviewdb.client.PatchLineComment e, com.google.gerrit.server.change.PutDraft.Input in) { if ((in.side) != null) { e.setSide(((in.side) == (com.google.gerrit.common.changes.Side.PARENT) ? ((short) (0)) : ((short) (1)))); } if ((in.line) != null) { e.setLine(in.line); } if ((in.inReplyTo) != null) { e.setParentUuid(com.google.gerrit.extensions.restapi.Url.decode(in.inReplyTo)); } e.setMessage(in.message.trim()); e.updated(); return e; }





public static com.google.gwt.user.client.Element set(final com.google.gwt.user.client.Element e, final com.google.gwtexpui.safehtml.client.SafeHtml str) { com.google.gwt.user.client.DOM.setInnerHTML(e, str.asString()); return e; }
public static com.google.gwt.user.client.Element parse(final com.google.gwtexpui.safehtml.client.SafeHtml str) { return com.google.gwt.user.client.DOM.getFirstChild(com.google.gwtexpui.safehtml.client.SafeHtml.set(com.google.gwt.user.client.DOM.createDiv(), str)); }
java.util.List<org.eclipse.jgit.transport.URIish> getURIs(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String urlMatch) { java.util.List<org.eclipse.jgit.transport.URIish> r = com.google.common.collect.Lists.newArrayListWithCapacity(remote.getURIs().size()); for (org.eclipse.jgit.transport.URIish uri : remote.getURIs()) { if (com.googlesource.gerrit.plugins.replication.Destination.matches(uri, urlMatch)) { java.lang.String name = project.get(); if (com.googlesource.gerrit.plugins.replication.Destination.needsUrlEncoding(uri)) { name = com.googlesource.gerrit.plugins.replication.Destination.encode(name); } if (remoteNameStyle.equals("dash")) { name = name.replace("/", "-"); } else if (remoteNameStyle.equals("underscore")) { name = name.replace("/", "_"); } else if (!(remoteNameStyle.equals("slash"))) { ReplicationQueue.log.debug(java.lang.String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle)); } java.lang.String replacedPath = com.googlesource.gerrit.plugins.replication.ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch()); if (replacedPath != null) { uri = uri.setPath(replacedPath); r.add(uri); } } } return r; }
private void checkRequiresCapability(org.apache.sshd.server.Command cmd) throws com.google.gerrit.sshd.UnloggedFailure { com.google.gerrit.extensions.annotations.RequiresCapability rc = cmd.getClass().getAnnotation(com.google.gerrit.extensions.annotations.RequiresCapability.class); if (rc != null) { com.google.gerrit.server.CurrentUser user = currentUser.get(); com.google.gerrit.server.account.CapabilityControl ctl = user.getCapabilities(); if ((!(ctl.canPerform(rc.value()))) && (!(ctl.canAdministrateServer()))) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value()); throw new com.google.gerrit.sshd.UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg); } } }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw new com.google.gerrit.sshd.UnloggedFailure(1, msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": ") + (commandName)) + ": not found"; throw new com.google.gerrit.sshd.UnloggedFailure(1, msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) bc.setName(commandName); else bc.setName((((getName()) + " ") + (commandName))); bc.setArguments(args.toArray(new java.lang.String[args.size()])); } else if (!(args.isEmpty())) { throw new com.google.gerrit.sshd.UnloggedFailure(1, ((commandName) + " does not take arguments")); } provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes(com.google.gerrit.sshd.ENC)); err.flush(); onExit(e.exitCode); } }

@org.junit.Test public void testList() throws java.lang.Exception { java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> m = new com.google.gerrit.server.config.ListCapabilities().apply(new com.google.gerrit.server.config.ConfigResource()); for (java.lang.String id : com.google.gerrit.common.data.GlobalCapability.getAllNames()) { assertTrue(("contains " + id), m.containsKey(id)); assertEquals(id, m.get(id).id); assertNotNull((id + " has name"), m.get(id).name); } }

@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.ConfigResource.CONFIG_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.CapabilityResource.CAPABILITY_KIND); child(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "capabilities").to(com.google.gerrit.server.config.CapabilitiesCollection.class); }


@java.lang.Override protected void configure() { bind(com.googlesource.gerrit.plugins.replication.ReplicationQueue.class).in(Scopes.SINGLETON); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class).to(com.googlesource.gerrit.plugins.replication.ReplicationQueue.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.NewProjectCreatedListener.class).to(com.googlesource.gerrit.plugins.replication.ReplicationQueue.class); bind(com.googlesource.gerrit.plugins.replication.OnStartStop.class).in(Scopes.SINGLETON); bind(com.google.gerrit.extensions.events.LifecycleListener.class).annotatedWith(com.google.inject.internal.UniqueAnnotations.create()).to(com.googlesource.gerrit.plugins.replication.OnStartStop.class); bind(com.googlesource.gerrit.plugins.replication.SecureCredentialsFactory.class).in(Scopes.SINGLETON); install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(PushAll.Factory.class)); install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(RemoteSiteUser.Factory.class)); }
@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.EXTERNAL_CAPABILITY_KIND); bind(com.google.gerrit.server.config.EXTERNAL_CAPABILITY_KIND).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("startreplication")).toInstance(new com.google.gerrit.extensions.config.CapabilityDefinition() { @java.lang.Override public java.lang.String getName() { return "startReplication"; } @java.lang.Override public java.lang.String getDescription() { return "Start Replication"; } }); }
@org.junit.Test public void testList() throws java.lang.Exception { com.google.gerrit.server.config.ListCapabilities list = injector.getInstance(com.google.gerrit.server.config.ListCapabilities.class); java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> m = list.apply(new com.google.gerrit.server.config.ConfigResource()); for (java.lang.String id : com.google.gerrit.common.data.GlobalCapability.getAllNames()) { assertTrue(("contains " + id), m.containsKey(id)); assertEquals(id, m.get(id).id); assertNotNull((id + " has name"), m.get(id).name); } java.lang.String pluginCapability = "gerrit-startReplication"; assertTrue(("contains " + pluginCapability), m.containsKey(pluginCapability)); }
@org.junit.Before public void setUp() throws java.lang.Exception { com.google.inject.AbstractModule mod = new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.EXTERNAL_CAPABILITY_KIND); bind(com.google.gerrit.server.config.EXTERNAL_CAPABILITY_KIND).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("startreplication")).toInstance(new com.google.gerrit.extensions.config.CapabilityDefinition() { @java.lang.Override public java.lang.String getName() { return "startReplication"; } @java.lang.Override public java.lang.String getDescription() { return "Start Replication"; } }); } }; injector = com.google.inject.Guice.createInjector(mod); }
@java.lang.Override protected void configure() { factory(ReviewerResource.Factory.class); factory(AccountInfo.Loader.Factory.class); factory(EmailReviewComments.Factory.class); factory(ChangeInserter.Factory.class); factory(PatchSetInserter.Factory.class); }




void run(final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { try { final java.sql.Connection c = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); final java.sql.Statement stmt = c.createStatement(); try { for (java.lang.String sql : commands) { try { stmt.execute(sql); } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(((("Error in " + (name)) + ":\n") + sql), e); } } } finally { stmt.close(); } } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(("Cannot run statements for " + (name)), e); } }

private void renderPublished() { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(published); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { com.google.gerrit.common.changes.Side side = info.side(); net.codemirror.lib.CodeMirror cm = getCmFromSide(side); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, commentLinkProcessor, getPatchSetIdFromSide(side), info); publishedMap.put(info.id(), box); if (!(info.has_line())) { diffTable.addFileCommentBox(box, side); continue; } int line = (info.line()) - 1; net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); lineLastPublishedBoxMap.put(handle, box); lineActiveBoxMap.put(handle, box); addCommentBox(info, box); } }


public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getActiveLine(); int line = cm.getLineNumber(handle); com.google.gerrit.client.diff.CommentBox box = lineActiveBoxMap.get(handle); if (box == null) { lineActiveBoxMap.put(handle, addNewDraft(cm, line)); } else if (box instanceof com.google.gerrit.client.diff.DraftBox) { ((com.google.gerrit.client.diff.DraftBox) (box)).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).doReply(); } }
private java.lang.Runnable insertNewDraft(final net.codemirror.lib.CodeMirror cm) { if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { return new java.lang.Runnable() { @java.lang.Override public void run() { com.google.gerrit.client.Gerrit.doSignIn(getToken()); } }; } return new java.lang.Runnable() { public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getActiveLine(); int line = cm.getLineNumber(handle); com.google.gerrit.client.diff.CommentBox box = lineActiveBoxMap.get(handle); if (box == null) { lineActiveBoxMap.put(handle, addNewDraft(cm, line)); } else if (box instanceof com.google.gerrit.client.diff.DraftBox) { ((com.google.gerrit.client.diff.DraftBox) (box)).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (box)).doReply(); } } }; }
com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.changes.CommentInfo info) { com.google.gerrit.common.changes.Side side = info.side(); net.codemirror.lib.CodeMirror cm = getCmFromSide(side); final com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info); if ((info.id()) == null) { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { box.setOpen(true); box.setEdit(true); } }); } if (!(info.has_line())) { return box; } addCommentBox(info, box); net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(((info.line()) - 1)); lineActiveBoxMap.put(handle, box); return box; }

private void removeUI() { if ((replyToBox) != null) { replyToBox.unregisterReplyBox(); } com.google.gerrit.common.changes.Side side = comment.side(); removeFromParent(); if (!(getCommentInfo().has_line())) { parent.removeFileCommentBox(this, side); return; } com.google.gerrit.client.diff.PaddingManager manager = getPaddingManager(); manager.remove(this); parent.removeDraft(this, side, ((comment.line()) - 1)); cm.focus(); getSelfWidgetWrapper().getWidget().clear(); getGutterWrapper().remove(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { resizePaddingWidget(); } }); }

private com.google.gerrit.server.git.SubmitStrategy createStrategy(final com.google.gerrit.reviewdb.client.Project.SubmitType submitType) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch); }

public com.google.gerrit.acceptance.git.PushOneCommit.Result to(org.eclipse.jgit.api.Git git, java.lang.String ref) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.GitUtil.add(git, fileName, content); if ((changeId) != null) { com.google.gerrit.acceptance.git.GitUtil.amendCommit(git, i, subject, changeId); } else { changeId = com.google.gerrit.acceptance.git.GitUtil.createCommit(git, i, subject); } return new com.google.gerrit.acceptance.git.PushOneCommit.Result(db, ref, com.google.gerrit.acceptance.git.GitUtil.pushHead(git, ref), changeId, subject); }

public static org.eclipse.jgit.transport.PushResult pushHead(org.eclipse.jgit.api.Git git, java.lang.String ref) throws org.eclipse.jgit.api.errors.GitAPIException { org.eclipse.jgit.api.PushCommand pushCmd = git.push(); pushCmd.setRefSpecs(new org.eclipse.jgit.transport.RefSpec(("HEAD:" + ref))); java.lang.Iterable<org.eclipse.jgit.transport.PushResult> r = pushCmd.call(); return com.google.common.collect.Iterables.getOnlyElement(r); }
private java.util.Set<org.eclipse.jgit.revwalk.RevCommit> getAlreadyAccepted(final com.google.gerrit.server.git.CodeReviewCommit branchTip) throws com.google.gerrit.server.git.MergeException { final java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted = new java.util.HashSet<org.eclipse.jgit.revwalk.RevCommit>(); if (branchTip != null) { alreadyAccepted.add(branchTip); } try { for (final org.eclipse.jgit.lib.Ref r : repo.getAllRefs().values()) { if ((r.getName().startsWith(Constants.R_HEADS)) || (r.getName().startsWith(Constants.R_TAGS))) { try { alreadyAccepted.add(rw.parseCommit(r.getObjectId())); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException iote) { } } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Failed to determine already accepted commits.", e); } return alreadyAccepted; }

private int showResultSet(final java.sql.ResultSet rs, boolean alreadyOnRow, com.google.gerrit.sshd.commands.QueryShell.Function... show) throws java.sql.SQLException { switch (outputFormat) { case JSON : return showResultSetJson(rs, alreadyOnRow, show); case PRETTY : default : return showResultSetPretty(rs, alreadyOnRow, show); } }
private void executeStatement(final java.lang.String sql) { final long start = java.lang.System.currentTimeMillis(); final boolean hasResultSet; try { hasResultSet = statement.execute(sql); } catch (java.sql.SQLException e) { error(e); return; } try { if (hasResultSet) { final java.sql.ResultSet rs = statement.getResultSet(); try { final int rowCount = showResultSet(rs, false); final long ms = (java.lang.System.currentTimeMillis()) - start; switch (outputFormat) { case JSON : { final com.google.gson.JsonObject tail = new com.google.gson.JsonObject(); tail.addProperty("type", "query-stats"); tail.addProperty("rowCount", rowCount); tail.addProperty("runTimeMilliseconds", ms); println(tail.toString()); break; } case PRETTY : default : println(((((("(" + rowCount) + (rowCount == 1 ? " row" : " rows")) + "; ") + ms) + " ms)")); break; } } finally { rs.close(); } } else { final int updateCount = statement.getUpdateCount(); final long ms = (java.lang.System.currentTimeMillis()) - start; switch (outputFormat) { case JSON : { final com.google.gson.JsonObject tail = new com.google.gson.JsonObject(); tail.addProperty("type", "update-stats"); tail.addProperty("rowCount", updateCount); tail.addProperty("runTimeMilliseconds", ms); println(tail.toString()); break; } case PRETTY : default : println((((("UPDATE " + updateCount) + "; ") + ms) + " ms")); break; } } } catch (java.sql.SQLException e) { error(e); } }
@java.lang.Override public void run() { header.prev.go(); }
private void setupNav(com.google.gerrit.client.ui.InlineHyperlink link, int key, java.lang.String help, com.google.gerrit.client.diff.FileInfo info) { if (info != null) { final java.lang.String url = url(info); link.setTargetHistoryToken(url); link.setTitle(com.google.gerrit.client.diff.Header.getFileName(info.path())); keys.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, key, help) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(url); } }); } else { link.getElement().getStyle().setVisibility(Visibility.HIDDEN); keys.add(new com.google.gerrit.client.diff.UpToChangeCommand2(patchSetId, 0, key)); } }
@java.lang.Override public void run() { header.next.go(); }
private java.lang.Runnable doScroll(final net.codemirror.lib.CodeMirror cm) { final net.codemirror.lib.CodeMirror other = otherCm(cm); return new java.lang.Runnable() { public void run() { if (((cm.getScrollSetAt()) + 50) > (java.lang.System.currentTimeMillis())) { return; } net.codemirror.lib.ScrollInfo si = cm.getScrollInfo(); if (((si.getTop()) == 0) && (!(com.google.gerrit.client.Gerrit.isHeaderVisible()))) { com.google.gerrit.client.Gerrit.setHeaderVisible(true); diffTable.updateFileCommentVisibility(false); resizeCodeMirror(); } else if (((si.getTop()) > (0.5 * (si.getClientHeight()))) && (com.google.gerrit.client.Gerrit.isHeaderVisible())) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); diffTable.updateFileCommentVisibility(true); resizeCodeMirror(); } other.scrollToY(si.getTop()); other.setScrollSetAt(java.lang.System.currentTimeMillis()); (cm == (cmA) ? scrollTimerA : scrollTimerB).schedule(50); } }; }
public void run() { if (((cm.getScrollSetAt()) + 50) > (java.lang.System.currentTimeMillis())) { return; } net.codemirror.lib.ScrollInfo si = cm.getScrollInfo(); if (((si.getTop()) == 0) && (!(com.google.gerrit.client.Gerrit.isHeaderVisible()))) { com.google.gerrit.client.Gerrit.setHeaderVisible(true); diffTable.updateFileCommentVisibility(false); resizeCodeMirror(); } else if (((si.getTop()) > (0.5 * (si.getClientHeight()))) && (com.google.gerrit.client.Gerrit.isHeaderVisible())) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); diffTable.updateFileCommentVisibility(true); resizeCodeMirror(); } other.scrollToY(si.getTop()); other.setScrollSetAt(java.lang.System.currentTimeMillis()); (cm == (cmA) ? scrollTimerA : scrollTimerB).schedule(50); }
static void invoke(com.google.gerrit.client.changes.ChangeInfo change, com.google.gerrit.client.changes.ChangeInfo.ActionInfo action, com.google.gerrit.client.rpc.RestApi api) { final com.google.gerrit.reviewdb.client.Change.Id id = change.legacy_id(); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb = new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject msg) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(id)); } }; if ("PUT".equalsIgnoreCase(action.method())) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(action.method())) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject msg) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(id)); }










private void renderChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { changeInfo = info; lastDisplayedUpdate = info.updated(); statusText.setInnerText(com.google.gerrit.client.changes.Util.toLongString(info.status())); boolean current = (info.status().isOpen()) && (revision.equals(info.current_revision())); boolean canSubmit = labels.set(info, current); renderOwner(info); renderReviewers(info); renderActionTextDate(info); renderRevisions(info); renderHistory(info); actions.display(info, revision); star.setValue(info.starred()); permalink.setHref(com.google.gerrit.client.ui.ChangeLink.permalink(changeId)); changeIdText.setInnerText(java.lang.String.valueOf(info.legacy_id())); projectText.setInnerText(info.project()); branchText.setInnerText(info.branch()); idText.setText(("Change-Id: " + (info.change_id()))); idText.setPreviewText(info.change_id()); reload.set(info); topic.set(info); commit.set(commentLinkProcessor, info, revision); related.set(info, revision); quickApprove.set(info, revision); if (com.google.gerrit.client.Gerrit.isSignedIn()) { replyAction = new com.google.gerrit.client.change.ReplyAction(info, revision, style, reply); if (topic.canEdit()) { keysAction.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 't', Util.C.keyEditTopic()) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { topic.onEdit(); } }); } } if (current) { loadMergeable(info.status(), canSubmit); } java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append(Util.M.changeScreenTitleId(info.id_abbreviated())); if ((info.subject()) != null) { sb.append(": "); sb.append(info.subject()); } setWindowTitle(sb.toString()); }


public java.lang.String getInlineComments(int lines) { java.lang.StringBuilder cmts = new java.lang.StringBuilder(); final org.eclipse.jgit.lib.Repository repo = getRepository(); try { com.google.gerrit.server.patch.PatchList patchList = null; if (repo != null) { try { patchList = getPatchList(); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { patchList = null; } } com.google.gerrit.reviewdb.client.Patch.Key currentFileKey = null; com.google.gerrit.server.patch.PatchFile currentFileData = null; for (final com.google.gerrit.reviewdb.client.PatchLineComment c : inlineComments) { final com.google.gerrit.reviewdb.client.Patch.Key pk = c.getKey().getParentKey(); if (!(pk.equals(currentFileKey))) { cmts.append("....................................................\n"); if (Patch.COMMIT_MSG.equals(pk.get())) { cmts.append("Commit Message\n"); } else { cmts.append("File ").append(pk.get()).append('\n'); } currentFileKey = pk; if (patchList != null) { try { currentFileData = new com.google.gerrit.server.patch.PatchFile(repo, patchList, pk.get()); } catch (java.io.IOException e) { com.google.gerrit.server.mail.CommentSender.log.warn(java.lang.String.format("Cannot load %s from %s in %s", pk.getFileName(), patchList.getNewId().name(), projectState.getProject().getName()), e); currentFileData = null; } } } if (currentFileData != null) { appendComment(cmts, lines, currentFileData, c); } cmts.append("\n\n"); } } finally { if (repo != null) { repo.close(); } } return cmts.toString(); }

private void adjustGutter(com.google.gerrit.client.diff.SidePanel.GutterWrapper wrapper) { if ((cmB) == null) { return; } final net.codemirror.lib.CodeMirror cm = wrapper.cm; final int line = wrapper.line; com.google.gwt.user.client.ui.Label gutter = wrapper.gutter; final double height = cm.heightAtLine(line, "local"); final double scrollbarHeight = cmB.getScrollbarV().getClientHeight(); double top = ((height / ((double) (cmB.getSizer().getClientHeight()))) * scrollbarHeight) + (cmB.getScrollbarV().getAbsoluteTop()); if (top == 0) { top = -10; } gutter.getElement().getStyle().setTop(top, Unit.PX); wrapper.replaceClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); cm.scrollToY(java.lang.Math.max(0, (height - (scrollbarHeight / 2)))); cm.focus(); } }); }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); cm.scrollToY(java.lang.Math.max(0, (height - (scrollbarHeight / 2)))); cm.focus(); }
@java.lang.Override public com.google.gerrit.server.project.GetConfig.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) { com.google.gerrit.server.project.GetConfig.ConfigInfo result = new com.google.gerrit.server.project.GetConfig.ConfigInfo(); com.google.gerrit.server.project.ProjectState state = resource.getControl().getProjectState(); com.google.gerrit.reviewdb.client.Project p = state.getProject(); com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo useContributorAgreements = new com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo(); com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo useSignedOffBy = new com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo(); com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo useContentMerge = new com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo(); com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo requireChangeId = new com.google.gerrit.server.project.GetConfig.InheritedBooleanInfo(); useContributorAgreements.value = state.isUseContributorAgreements(); useSignedOffBy.value = state.isUseSignedOffBy(); useContentMerge.value = state.isUseContentMerge(); requireChangeId.value = state.isRequireChangeID(); useContributorAgreements.configuredValue = p.getUseContributorAgreements(); useSignedOffBy.configuredValue = p.getUseSignedOffBy(); useContentMerge.configuredValue = p.getUseContentMerge(); requireChangeId.configuredValue = p.getRequireChangeID(); com.google.gerrit.server.project.ProjectState parentState = com.google.common.collect.Iterables.getFirst(state.parents(), null); if (parentState != null) { useContributorAgreements.inheritedValue = parentState.isUseContributorAgreements(); useSignedOffBy.inheritedValue = parentState.isUseSignedOffBy(); useContentMerge.inheritedValue = parentState.isUseContentMerge(); requireChangeId.inheritedValue = parentState.isRequireChangeID(); } result.useContributorAgreements = useContributorAgreements; result.useSignedOffBy = useSignedOffBy; result.useContentMerge = useContentMerge; result.requireChangeId = requireChangeId; com.google.gerrit.server.project.GetConfig.MaxObjectSizeLimitInfo maxObjectSizeLimit = new com.google.gerrit.server.project.GetConfig.MaxObjectSizeLimitInfo(); maxObjectSizeLimit.value = ((config.getEffectiveMaxObjectSizeLimit(state)) == (config.getMaxObjectSizeLimit())) ? config.getFormattedMaxObjectSizeLimit() : p.getMaxObjectSizeLimit(); maxObjectSizeLimit.configuredValue = p.getMaxObjectSizeLimit(); maxObjectSizeLimit.inheritedValue = config.getFormattedMaxObjectSizeLimit(); result.maxObjectSizeLimit = maxObjectSizeLimit; result.submitType = p.getSubmitType(); result.state = ((p.getState()) != (Project.State.ACTIVE)) ? p.getState() : null; result.commentlinks = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.server.project.CommentLinkInfo cl : state.getCommentLinks()) { result.commentlinks.put(cl.name, cl); } result.theme = state.getTheme(); return result; }
private void renderPublished(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> published) { java.util.List<com.google.gerrit.client.changes.CommentInfo> sorted = sortComment(published); for (com.google.gerrit.client.changes.CommentInfo info : sorted) { com.google.gerrit.client.diff.SideBySide2.DisplaySide side; if ((info.side()) == (com.google.gerrit.common.changes.Side.PARENT)) { if ((base) != null) { continue; } side = com.google.gerrit.client.diff.SideBySide2.DisplaySide.A; } else { side = (published == (publishedBase)) ? com.google.gerrit.client.diff.SideBySide2.DisplaySide.A : com.google.gerrit.client.diff.SideBySide2.DisplaySide.B; } net.codemirror.lib.CodeMirror cm = getCmFromSide(side); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info); publishedMap.put(info.id(), box); if (!(info.has_line())) { diffTable.addFileCommentBox(box); continue; } int line = (info.line()) - 1; net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); lineLastPublishedBoxMap.put(handle, box); lineActiveBoxMap.put(handle, box); addCommentBox(info, box); } }
void removeDraft(com.google.gerrit.client.diff.DraftBox box, int line) { net.codemirror.lib.CodeMirror.LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line); lineActiveBoxMap.remove(handle); if (lineLastPublishedBoxMap.containsKey(handle)) { lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle)); } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.change.RevisionResource rev, com.googlesource.gerrit.plugins.cookbook.HelloWorldAction.Input input) { return java.lang.String.format("%s %s!", "Hello", com.google.common.base.Objects.firstNonNull(user.get().getUserName(), "world")); }
private static void initVimKeys() { net.codemirror.lib.KeyMap km = net.codemirror.lib.CodeMirror.cloneKeyMap("vim"); for (java.lang.String s : new java.lang.String[]{ "A", "C", "J", "K", "O", "R", "U", "Ctrl-C" }) { km.remove(s); } net.codemirror.lib.CodeMirror.addKeyMap("vim_ro", km); }
@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); java.lang.String projectName = token; while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } if (projectName.endsWith(".git")) { projectName = projectName.substring(0, ((projectName.length()) - 4)); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } } while (projectName.startsWith("/")) { projectName = projectName.substring(1); } final com.google.gerrit.server.project.ProjectControl control; try { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); control = projectControlFactory.validateFor(nameKey, ((com.google.gerrit.server.project.ProjectControl.OWNER) | (com.google.gerrit.server.project.ProjectControl.VISIBLE))); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new org.kohsuke.args4j.CmdLineException(owner, (("'" + token) + "': not a Gerrit project")); } setter.addValue(control); return 1; }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.PROJECT_SVC.projectDetail(getProjectKey(), new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.ProjectDetail>(this) { public void preDisplay(final com.google.gerrit.common.data.ProjectDetail result) { enableForm(result.canModifyAgreements, result.canModifyDescription, result.canModifyMergeType, result.canModifyState, result.canModifyMaxObjectSizeLimit); saveProject.setVisible(((((result.canModifyAgreements) || (result.canModifyDescription)) || (result.canModifyMergeType)) || (result.canModifyState))); display(result); } }); savedPanel = INFO; }

@java.lang.Override public void onDialogVisible(com.google.gwtexpui.user.client.DialogVisibleEvent event) { swf.getStyle().setVisibility((event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE)); }
private void initHideHandler() { if ((((hideHandler) == null) && ((swf) != null)) && (isAttached())) { hideHandler = com.google.gwtexpui.user.client.UserAgent.addDialogVisibleHandler(new com.google.gwtexpui.user.client.DialogVisibleHandler() { @java.lang.Override public void onDialogVisible(com.google.gwtexpui.user.client.DialogVisibleEvent event) { swf.getStyle().setVisibility((event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE)); } }); } }
public static java.lang.String toOpenSshPublicKey(final java.lang.String keyStr) { try { final java.lang.StringBuilder strBuf = new java.lang.StringBuilder(); final java.io.BufferedReader br = new java.io.BufferedReader(new java.io.StringReader(keyStr)); java.lang.String line = br.readLine(); if (!(line.equals("---- BEGIN SSH2 PUBLIC KEY ----"))) { return keyStr; } while ((line = br.readLine()) != null) { if ((line.indexOf(':')) == (-1)) { strBuf.append(line); break; } } while ((line = br.readLine()) != null) { if (line.startsWith("---- ")) { break; } strBuf.append(line); } final java.security.PublicKey key = new org.apache.sshd.common.util.Buffer(org.apache.commons.codec.binary.Base64.decodeBase64(org.eclipse.jgit.lib.Constants.encodeASCII(strBuf.toString()))).getRawPublicKey(); if (key instanceof java.security.interfaces.RSAPublicKey) { strBuf.insert(0, ((org.apache.sshd.common.KeyPairProvider.SSH_RSA) + " ")); } else if (key instanceof java.security.interfaces.DSAPublicKey) { strBuf.insert(0, ((org.apache.sshd.common.KeyPairProvider.SSH_DSS) + " ")); } else { return keyStr; } strBuf.append(' '); strBuf.append("converted-key"); return strBuf.toString(); } catch (java.io.IOException e) { return keyStr; } catch (java.lang.RuntimeException re) { return keyStr; } }
@java.lang.Override public java.lang.String getETag() { return java.lang.String.format("%x-%x", getChange().getLastUpdatedOn().getTime(), getChange().getRowVersion()); }

@java.lang.Override protected void configureCommands() { int schemaVersion = com.google.gerrit.server.schema.SchemaVersion.guessVersion(SchemaVersion.C); java.lang.Class<? extends com.googlesource.gerrit.plugins.deleteproject.database.DatabaseDeleteHandler> databaseDeleteHandlerClass = null; switch (schemaVersion) { case 73 : case 74 : case 75 : case 76 : databaseDeleteHandlerClass = com.googlesource.gerrit.plugins.deleteproject.database.Schema73DatabaseDeleteHandler.class; break; case 77 : case 78 : case 79 : case 80 : case 81 : case 82 : databaseDeleteHandlerClass = com.googlesource.gerrit.plugins.deleteproject.database.Schema77DatabaseDeleteHandler.class; break; default : throw new java.lang.RuntimeException(((("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: ") + schemaVersion) + "). Please update the plugin.")); } assert databaseDeleteHandlerClass != null : "No database handler set"; bind(com.googlesource.gerrit.plugins.deleteproject.database.DatabaseDeleteHandler.class).to(databaseDeleteHandlerClass); command(com.googlesource.gerrit.plugins.deleteproject.DeleteCommand.class); }

@java.lang.Override public void assertCanDelete(com.google.gerrit.reviewdb.client.Project project) throws java.lang.Exception { final java.sql.Connection conn = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); final java.lang.String projectName = project.getName(); if (conn.createStatement().executeQuery(((("SELECT * FROM submodule_subscriptions WHERE " + "super_project_project_name = '") + projectName) + "'")).first()) { throw new java.lang.Exception("Project has subscribed submodules."); } if (conn.createStatement().executeQuery(((("SELECT * FROM submodule_subscriptions WHERE " + "submodule_project_name = '") + projectName) + "'")).first()) { throw new java.lang.Exception("Project is subscribed by other projects."); } }
private void deleteGitRepository(final org.eclipse.jgit.lib.Repository repository) throws com.google.gerrit.sshd.BaseCommand.UnloggedFailure { java.io.File parentFile = repository.getDirectory().getParentFile(); if (!(recursiveDelete(repository.getDirectory()))) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(("Error trying to delete " + (repository.getDirectory().getAbsolutePath()))); } recursiveDeleteParent(parentFile, gitDir); }
@java.lang.Override public void delete(com.google.gerrit.reviewdb.client.Project project) throws java.lang.Exception { java.sql.Connection conn = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); conn.setAutoCommit(false); try { atomicDelete(project); conn.commit(); } catch (java.lang.Exception e) { conn.rollback(); throw e; } finally { conn.setAutoCommit(true); } }
@java.lang.Override public void assertCanDelete(com.google.gerrit.reviewdb.client.Project project) throws java.lang.Exception { if (db.submoduleSubscriptions().bySubmoduleProject(project.getNameKey()).iterator().hasNext()) { throw new java.lang.Exception("Project is subscribed by other projects."); } }
public void delete(com.google.gerrit.reviewdb.client.Project project) throws java.lang.Exception;
public void assertCanDelete(com.google.gerrit.reviewdb.client.Project project) throws java.lang.Exception;
@java.lang.Override protected void configure() { bind(com.googlesource.gerrit.plugins.deleteproject.cache.CacheDeleteHandler.class); bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT)).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.class); bind(com.googlesource.gerrit.plugins.deleteproject.database.DatabaseDeleteHandler.class).to(registerDatabaseHandler()); bind(com.googlesource.gerrit.plugins.deleteproject.fs.FilesystemDeleteHandler.class); }

private void renderRevisions(com.google.gerrit.client.changes.ChangeInfo info) { if ((info.revisions().size()) == 1) { com.google.gwt.user.client.ui.UIObject.setVisible(revisionParent, false); return; } com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(list); if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (com.google.gerrit.client.Gerrit.getUserAccount().getGeneralPreferences().isReversePatchSetOrder())) { java.util.Collections.reverse(com.google.gerrit.client.rpc.Natives.asList(list)); } int selected = -1; for (int i = 0; i < (list.length()); i++) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r = list.get(i); revisionList.addItem((((r._number()) + ": ") + (r.name().substring(0, 6))), ("" + (r._number()))); if (revision.equals(r.name())) { selected = i; } } if (0 <= selected) { revisionList.setSelectedIndex(selected); } }
private void renderDownload(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { downloadAction = new com.google.gerrit.client.change.DownloadAction(info.legacy_id(), info.project(), info.revision(revision), style, headerLine, download); }
@com.google.gwt.uibinder.client.UiHandler("download") void onDownload(com.google.gwt.event.dom.client.ClickEvent e) { downloadAction.show(); }

@com.google.gwt.uibinder.client.UiHandler("revisionList") void onChangeRevision(com.google.gwt.event.dom.client.ChangeEvent e) { int idx = revisionList.getSelectedIndex(); if (0 <= idx) { java.lang.String n = revisionList.getValue(idx); revisionList.setEnabled(false); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(changeId, n)); } }



@java.lang.Override public void remove() { m.remove(name.value(), cmd); }
public com.google.gerrit.extensions.registration.RegistrationHandle register(final com.google.gerrit.sshd.CommandName name, final com.google.inject.Provider<org.apache.sshd.server.Command> cmd) { final java.util.concurrent.ConcurrentMap<java.lang.String, com.google.gerrit.sshd.CommandProvider> m = getMap(); if ((m.putIfAbsent(name.value(), new com.google.gerrit.sshd.CommandProvider(cmd, null))) != null) { throw new java.lang.IllegalArgumentException(((name.value()) + " exists")); } return new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { m.remove(name.value(), cmd); } }; }

private void checkRequiresCapability(org.apache.sshd.server.Command cmd) throws com.google.gerrit.sshd.UnloggedFailure { com.google.gerrit.extensions.annotations.RequiresCapability rc = com.google.gerrit.sshd.DispatchCommand.getRequiresCapability(cmd.getClass()); if (rc != null) { com.google.gerrit.server.CurrentUser user = currentUser.get(); com.google.gerrit.server.account.CapabilityControl ctl = user.getCapabilities(); java.lang.String capability = rc.value(); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { java.lang.String pluginName = ((com.google.gerrit.sshd.BaseCommand) (cmd)).getPluginName(); if (((pluginName != null) && (!("gerrit".equals(pluginName)))) && (((rc.scope()) == (com.google.gerrit.extensions.annotations.CapabilityScope.PLUGIN)) || ((rc.scope()) == (com.google.gerrit.extensions.annotations.CapabilityScope.CONTEXT)))) { capability = java.lang.String.format("%s-%s", pluginName, rc.value()); } else if ((rc.scope()) == (com.google.gerrit.extensions.annotations.CapabilityScope.PLUGIN)) { com.google.gerrit.sshd.DispatchCommand.log.error(java.lang.String.format("Class %s uses @%s(scope=%s), but is not within a plugin", cmd.getClass().getName(), com.google.gerrit.extensions.annotations.RequiresCapability.class.getSimpleName(), CapabilityScope.PLUGIN.name())); throw new com.google.gerrit.sshd.UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability"); } } if ((!(ctl.canPerform(capability))) && (!(ctl.canAdministrateServer()))) { java.lang.String msg = java.lang.String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), capability); throw new com.google.gerrit.sshd.UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg); } } }
private static com.google.gerrit.extensions.annotations.RequiresCapability getRequiresCapability(java.lang.Class<?> clazz) { com.google.gerrit.extensions.annotations.RequiresCapability rc = clazz.getAnnotation(com.google.gerrit.extensions.annotations.RequiresCapability.class); if (rc != null) { return rc; } if ((clazz.getSuperclass()) != null) { return com.google.gerrit.httpd.restapi.RestApiServlet.getRequiresCapability(clazz.getSuperclass()); } return null; }

public org.eclipse.jgit.lib.PersonIdent getUserPersonIdent() { return userIdent; }

private void collectPluginCapabilities(java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> output) { for (java.lang.String pluginName : pluginCapabilities.plugins()) { for (java.util.Map.Entry<java.lang.String, com.google.inject.Provider<com.google.gerrit.extensions.config.CapabilityDefinition>> entry : pluginCapabilities.byPlugin(pluginName).entrySet()) { java.lang.String id = java.lang.String.format("%s-%s", pluginName, entry.getKey()); output.put(id, new com.google.gerrit.server.config.ListCapabilities.CapabilityInfo(id, entry.getValue().get().getDescription())); } } }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(b, changeDetail.getChange().getProject()) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get())); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(new com.google.gerrit.reviewdb.client.Change.Id(result._number()))); hide(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
static void call(com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, java.lang.String project, final java.lang.String commitMessage) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(b, new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
java.lang.String cherryPickedChangeDefaultMessage(java.lang.String commitMsg, java.lang.String commitId);


private java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> query() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.BitSet more = new java.util.BitSet(cnt); java.util.List<java.util.List<com.google.gerrit.server.query.change.ChangeData>> data = com.google.common.collect.Lists.newArrayListWithCapacity(cnt); for (int n = 0; n < cnt; n++) { java.lang.String query = queries.get(n); java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = imp.queryChanges(query); if (((imp.getLimit()) > 0) && ((changes.size()) > (imp.getLimit()))) { if (reverse) { changes = changes.subList(1, changes.size()); } else { changes = changes.subList(0, imp.getLimit()); } more.set(n, true); } data.add(changes); } java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> res = json.addOptions(options).formatList2(data); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> info = res.get(n); if ((more.get(n)) && (!(info.isEmpty()))) { if (reverse) { info.get(0)._moreChanges = true; } else { info.get(((info.size()) - 1))._moreChanges = true; } } } return res; }

@java.lang.Override protected void onLoad() { super.onLoad(); java.lang.String who = (mine) ? "self" : ownerId.toString(); com.google.gerrit.client.changes.ChangeList.query(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeList>>(this) { @java.lang.Override protected void preDisplay(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeList> result) { display(result); } }, ("is:open owner:" + who), ((("is:open reviewer:" + who) + " -owner:") + who), (("is:closed owner:" + who) + " -age:4w limit:10")); }




private boolean isDuplicate(com.google.gerrit.reviewdb.client.ChangeMessage msg) { try { com.google.gerrit.reviewdb.client.ChangeMessage last = com.google.common.collect.Iterables.getLast(db.changeMessages().byChange(msg.getPatchSetId().getParentKey()), null); if (last != null) { long lastMs = last.getWrittenOn().getTime(); long msgMs = msg.getWrittenOn().getTime(); if (((com.google.common.base.Objects.equal(last.getAuthor(), msg.getAuthor())) && (com.google.common.base.Objects.equal(last.getMessage(), msg.getMessage()))) && ((msgMs - lastMs) < (com.google.gerrit.server.git.MergeOp.DUPLICATE_MESSAGE_INTERVAL))) { return true; } } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.git.MergeOp.log.warn("Cannot check previous merge failure message", err); } return false; }
@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp(); index = new com.google.gerrit.server.index.IndexRewriteTest.DummyIndex(com.google.gerrit.server.index.IndexRewriteTest.V2); indexes = new com.google.gerrit.server.index.IndexCollection(); indexes.setSearchIndex(index); queryBuilder = new com.google.gerrit.server.index.IndexRewriteTest.QueryBuilder(); rewrite = new com.google.gerrit.server.index.IndexRewriteImpl(indexes, null, new com.google.gerrit.server.index.IndexRewriteImpl.BasicRewritesImpl(null), new com.google.gerrit.server.query.change.SqlRewriterImpl(null)); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.query.change.ChangeQueryRewriter.class).to(com.google.gerrit.server.index.IndexRewriteImpl.class); bind(IndexRewriteImpl.BasicRewritesImpl.class); bind(com.google.gerrit.server.index.IndexCollection.class); listener().to(com.google.gerrit.server.index.IndexCollection.class); install(new com.google.inject.assistedinject.FactoryModuleBuilder().implement(com.google.gerrit.server.index.ChangeIndexer.class, com.google.gerrit.server.index.ChangeIndexerImpl.class).build(ChangeIndexer.Factory.class)); if ((indexExecutor) != null) { bind(com.google.common.util.concurrent.ListeningScheduledExecutorService.class).annotatedWith(com.google.gerrit.server.index.IndexExecutor.class).toInstance(indexExecutor); } else { install(new com.google.gerrit.server.index.IndexModule.IndexExecutorModule(threads)); } }
public final com.google.gerrit.server.mail.ProjectWatch.Watchers getWatchers(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.mail.ProjectWatch.Watchers matching = new com.google.gerrit.server.mail.ProjectWatch.Watchers(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> projectWatchers = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) { if (w.isNotify(type)) { projectWatchers.add(w.getAccountId()); add(matching, w); } } for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) { if ((!(projectWatchers.contains(w.getAccountId()))) && (w.isNotify(type))) { add(matching, w); } } for (com.google.gerrit.server.project.ProjectState state : projectState.tree()) { for (com.google.gerrit.server.git.NotifyConfig nc : state.getConfig().getNotifyConfigs()) { if (nc.isNotify(type)) { try { add(matching, nc, state.getProject().getNameKey()); } catch (com.google.gerrit.server.query.QueryParseException e) { com.google.gerrit.server.mail.ProjectWatch.log.warn(java.lang.String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage())); } } } } return matching; }
public com.google.gerrit.common.data.LabelTypes getLabelTypes() { return getProjectControl().getLabelTypes(); }
@org.junit.Before public final void beforeTest() throws java.lang.Exception { server = com.google.gerrit.acceptance.GerritServer.start(); server.getTestInjector().injectMembers(this); }


private static java.io.File initSite() throws java.lang.Exception { java.io.File tmp = com.google.gerrit.acceptance.TempFileUtil.createTempDirectory(); com.google.gerrit.pgm.Init init = new com.google.gerrit.pgm.Init(); int rc = init.main(new java.lang.String[]{ "-d", tmp.getPath(), "--batch", "--no-auto-start", "--skip-plugins" }); if (rc != 0) { throw new java.lang.RuntimeException("Couldn't initialize site"); } java.net.InetSocketAddress http = com.google.gerrit.acceptance.GerritServer.newPort(); java.net.InetSocketAddress sshd = com.google.gerrit.acceptance.GerritServer.newPort(); java.lang.String url = ("http://" + (com.google.gerrit.acceptance.GerritServer.format(http))) + "/"; org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(new java.io.File(new java.io.File(tmp, "etc"), "gerrit.config"), org.eclipse.jgit.util.FS.DETECTED); cfg.load(); cfg.setString("gerrit", null, "canonicalWebUrl", url); cfg.setString("httpd", null, "listenUrl", url); cfg.setString("sshd", null, "listenAddress", com.google.gerrit.acceptance.GerritServer.format(sshd)); cfg.setString("cache", null, "directory", null); cfg.setBoolean("sendemail", null, "enable", false); cfg.setInt("cache", "projects", "checkFrequency", 0); cfg.setInt("plugins", null, "checkFrequency", 0); cfg.save(); return tmp; }

@java.lang.Override protected void configure() { bind(com.google.gerrit.server.config.SitePaths.class); bind(com.google.gerrit.pgm.init.InitFlags.class); bind(com.google.gerrit.pgm.init.Libraries.class); bind(com.google.gerrit.pgm.init.LibraryDownloader.class); factory(Section.Factory.class); step().to(com.google.gerrit.pgm.init.UpgradeFrom2_0_x.class); step().to(com.google.gerrit.pgm.init.InitGitManager.class); step().to(com.google.gerrit.pgm.init.InitDatabase.class); step().to(com.google.gerrit.pgm.init.InitAuth.class); step().to(com.google.gerrit.pgm.init.InitSendEmail.class); step().to(com.google.gerrit.pgm.init.InitContainer.class); step().to(com.google.gerrit.pgm.init.InitSshd.class); step().to(com.google.gerrit.pgm.init.InitHttpd.class); step().to(com.google.gerrit.pgm.init.InitCache.class); step().to(com.google.gerrit.pgm.init.InitPlugins.class); }
private com.google.inject.Injector createSysInjector(final com.google.gerrit.pgm.Init.SiteInit init) { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<java.lang.Module>(); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(init.ui); bind(com.google.gerrit.pgm.init.InitFlags.class).toInstance(init.flags); } }); return createDbInjector(com.google.gerrit.pgm.SINGLE_USER).createChildInjector(modules); }
private com.google.gerrit.pgm.Init.SiteInit createSiteInit() { final com.google.gerrit.pgm.util.ConsoleUI ui = com.google.gerrit.pgm.util.ConsoleUI.getInstance(batchMode); final java.io.File sitePath = getSitePath(); final java.util.List<java.lang.Module> m = new java.util.ArrayList<java.lang.Module>(); m.add(new com.google.gerrit.pgm.init.InitModule()); m.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); } }); try { return com.google.inject.Guice.createInjector(com.google.gerrit.pgm.PRODUCTION, m).getInstance(com.google.gerrit.pgm.Init.SiteInit.class); } catch (com.google.inject.CreationException ce) { final com.google.inject.spi.Message first = ce.getErrorMessages().iterator().next(); java.lang.Throwable why = first.getCause(); if (why instanceof com.google.gerrit.pgm.util.Die) { throw ((com.google.gerrit.pgm.util.Die) (why)); } final java.lang.StringBuilder buf = new java.lang.StringBuilder(ce.getMessage()); while (why != null) { buf.append("\n"); buf.append(why.getMessage()); why = why.getCause(); if (why != null) { buf.append("\n caused by "); } } throw die(buf.toString(), new java.lang.RuntimeException("InitInjector failed", ce)); } }



@java.lang.Override public void onNewProjectCreated(com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event) { if (configs.isEmpty()) { return; } if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.error("Replication plugin did not finish startup before event"); return; } com.google.gerrit.reviewdb.client.Project.NameKey projectName = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); for (com.googlesource.gerrit.plugins.replication.Destination config : configs) { if (!(config.wouldPushProject(projectName))) { continue; } java.util.List<org.eclipse.jgit.transport.URIish> uriList = config.getURIs(projectName, "*"); java.lang.String[] adminUrls = config.getAdminUrls(); boolean adminURLUsed = false; for (java.lang.String url : adminUrls) { if (com.google.common.base.Strings.isNullOrEmpty(url)) { continue; } org.eclipse.jgit.transport.URIish uri; try { uri = new org.eclipse.jgit.transport.URIish(url); } catch (java.net.URISyntaxException e) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn(java.lang.String.format("adminURL '%s' is invalid: %s", url, e.getMessage())); continue; } java.lang.String path = com.googlesource.gerrit.plugins.replication.ReplicationQueue.replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch()); if (path == null) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn(java.lang.String.format("adminURL %s does not contain ${name}", uri)); continue; } uri = uri.setPath(path); if (!(com.googlesource.gerrit.plugins.replication.ReplicationQueue.isSSH(uri))) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn(java.lang.String.format("adminURL '%s' is invalid: only SSH is supported", uri)); continue; } createProject(uri, event.getHeadName()); adminURLUsed = true; } if (!adminURLUsed) { for (org.eclipse.jgit.transport.URIish uri : uriList) { createProject(uri, event.getHeadName()); } } } }


private void deleteGitRepository(final org.eclipse.jgit.lib.Repository repository) throws java.io.IOException { java.io.File parentFile = repository.getDirectory().getParentFile(); if (!(recursiveDelete(repository.getDirectory()))) { throw new java.io.IOException(("Error trying to delete " + (repository.getDirectory().getAbsolutePath()))); } recursiveDeleteParent(parentFile, gitDir); }




@java.lang.Override public int run() throws java.lang.Exception { final com.google.gerrit.pgm.BaseInit.SiteInit init = createSiteInit(); beforeInit(init); init.flags.autoStart = (getAutoStart()) && (init.site.isNew); final com.google.gerrit.pgm.BaseInit.SiteRun run; try { init.initializer.run(); init.flags.deleteOnFailure = false; run = createSiteRun(init); run.upgradeSchema(); } catch (java.lang.Exception failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.BaseInit.recursiveDelete(getSitePath()); } throw failure; } catch (java.lang.Error failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.BaseInit.recursiveDelete(getSitePath()); } throw failure; } java.lang.System.err.println(("Initialized " + (getSitePath().getCanonicalPath()))); afterInit(run); return 0; }
















@java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((n.endsWith(".jar")) || (n.endsWith(".jar.disabled"))) && (pathname.isFile()); }
private java.util.List<java.io.File> scanJarsInPluginsDirectory() { if (((pluginsDir) == null) || (!(pluginsDir.exists()))) { return java.util.Collections.emptyList(); } java.io.File[] matches = pluginsDir.listFiles(new java.io.FileFilter() { @java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((n.endsWith(".jar")) || (n.endsWith(".jar.disabled"))) && (pathname.isFile()); } }); if (matches == null) { com.google.gerrit.server.plugins.PluginLoader.log.error(("Cannot list " + (pluginsDir.getAbsolutePath()))); return java.util.Collections.emptyList(); } return java.util.Arrays.asList(matches); }
public void disablePlugins(java.util.Set<java.lang.String> names) { synchronized(this) { for (java.lang.String name : names) { com.google.gerrit.server.plugins.Plugin active = running.get(name); if (active == null) { continue; } com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Disabling plugin %s", name)); java.io.File off = new java.io.File(pluginsDir, ((active.getName()) + ".jar.disabled")); active.getSrcFile().renameTo(off); unloadPlugin(active); try { org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot = org.eclipse.jgit.internal.storage.file.FileSnapshot.save(off); com.google.gerrit.server.plugins.Plugin offPlugin = loadPlugin(name, off, snapshot); disabled.put(name, offPlugin); } catch (java.lang.Throwable e) { com.google.gerrit.server.plugins.PluginLoader.log.warn(java.lang.String.format("Cannot load disabled plugin %s", name), e.getCause()); } } cleanInBackground(); } }


public void resetToDefaults() { maximumPageSize = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DEFAULT_PAGESIZE; showSiteHeader = true; useFlashClipboard = true; copySelfOnEmail = false; reversePatchSetOrder = false; showUserInReview = false; downloadUrl = null; downloadCommand = null; dateFormat = null; timeFormat = null; relativeDateInChangeTable = false; commentVisibilityStrategy = null; diffView = null; }


private void display(final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p) { showSiteHeader.setValue(p.isShowSiteHeader()); useFlashClipboard.setValue(p.isUseFlashClipboard()); copySelfOnEmails.setValue(p.isCopySelfOnEmails()); reversePatchSetOrder.setValue(p.isReversePatchSetOrder()); showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.getMaximumPageSize()); setListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, p.getDateFormat()); setListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat()); relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable()); setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.getCommentVisibilityStrategy()); setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.getDiffView()); }
private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); copySelfOnEmails.setEnabled(on); reversePatchSetOrder.setEnabled(on); showUsernameInReviewCategory.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); commentVisibilityStrategy.setEnabled(on); diffView.setEnabled(on); }
private void doSave() { final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p = new com.google.gerrit.reviewdb.client.AccountGeneralPreferences(); p.setShowSiteHeader(showSiteHeader.getValue()); p.setUseFlashClipboard(useFlashClipboard.getValue()); p.setCopySelfOnEmails(copySelfOnEmails.getValue()); p.setReversePatchSetOrder(reversePatchSetOrder.getValue()); p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue()); p.setMaximumPageSize(getListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE)); p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values())); p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values())); p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue()); p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, com.google.gerrit.reviewdb.client.AccountGeneralPreferences.CommentVisibilityStrategy.values())); p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values())); enable(false); save.setEnabled(false); Util.ACCOUNT_SVC.changePreferences(p, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.getUserAccount().setGeneralPreferences(p); com.google.gerrit.client.Gerrit.applyUserPreferences(); enable(true); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enable(true); save.setEnabled(true); super.onFailure(caught); } }); }
private static void change2(final java.lang.String token) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); com.google.gerrit.reviewdb.client.Change.Id id; int s = rest.indexOf('/'); if (0 <= s) { id = Change.Id.parse(rest.substring(0, s)); rest = rest.substring((s + 1)); } else { id = Change.Id.parse(rest); rest = ""; } com.google.gerrit.client.Dispatcher.useChangeScreen2 = true; com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.change.ChangeScreen2(id, rest, false)); }

private static com.google.gerrit.server.query.change.ChangeData toChangeData(org.apache.lucene.document.Document doc) { org.apache.lucene.util.BytesRef cb = doc.getBinaryValue(com.google.gerrit.lucene.LuceneChangeIndex.CHANGE_FIELD); if (cb == null) { int id = doc.getField(com.google.gerrit.lucene.LuceneChangeIndex.ID_FIELD).numericValue().intValue(); return new com.google.gerrit.server.query.change.ChangeData(new com.google.gerrit.reviewdb.client.Change.Id(id)); } com.google.gerrit.reviewdb.client.Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length); com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(change); org.apache.lucene.util.BytesRef[] approvalsBytes = doc.getBinaryValues(com.google.gerrit.lucene.LuceneChangeIndex.APPROVAL_FIELD); if (approvalsBytes != null) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayListWithCapacity(approvalsBytes.length); for (org.apache.lucene.util.BytesRef ab : approvalsBytes) { approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length)); } cd.setCurrentApprovals(approvals); } return cd; }
public void testBlockLabelRange_ParentBlocksChild() { grant(local, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/*"); grant(parent, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/*").setBlock(); com.google.gerrit.server.project.ProjectControl u = user(devs); com.google.gerrit.common.data.PermissionRange range = u.controlForRef("refs/heads/master").getRange(((LABEL) + "Code-Review")); assertTrue("u can vote -1", range.contains((-1))); assertTrue("u can vote +1", range.contains(1)); assertFalse("u can't vote -2", range.contains((-2))); assertFalse("u can't vote 2", range.contains(2)); }

public void testUnblockRangeOnMoreSpecificRef_Fails() { grant(local, ((LABEL) + "Code-Review"), (-1), (+1), anonymous, "refs/heads/*").setBlock(); grant(local, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/master"); com.google.gerrit.server.project.ProjectControl u = user(devs); com.google.gerrit.common.data.PermissionRange range = u.controlForRef("refs/heads/master").getRange(((LABEL) + "Code-Review")); assertFalse("u can't vote -2", range.contains((-2))); assertFalse("u can't vote +2", range.contains((-2))); }
public void testUnblockRange() { grant(local, ((LABEL) + "Code-Review"), (-1), (+1), anonymous, "refs/heads/*").setBlock(); grant(local, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/*"); com.google.gerrit.server.project.ProjectControl u = user(devs); com.google.gerrit.common.data.PermissionRange range = u.controlForRef("refs/heads/master").getRange(((LABEL) + "Code-Review")); assertTrue("u can vote -2", range.contains((-2))); assertTrue("u can vote +2", range.contains(2)); }
public void testInheritRead_SingleBranchDeniesUpload() { grant(parent, com.google.gerrit.server.project.READ, registered, "refs/*"); grant(parent, com.google.gerrit.server.project.PUSH, registered, "refs/for/refs/*"); grant(local, com.google.gerrit.server.project.READ, registered, "refs/heads/foobar"); doNotInherit(local, com.google.gerrit.server.project.READ, "refs/heads/foobar"); doNotInherit(local, com.google.gerrit.server.project.PUSH, "refs/for/refs/heads/foobar"); com.google.gerrit.server.project.ProjectControl u = user(); assertTrue("can upload", ((u.canPushToAtLeastOneRef()) == (com.google.gerrit.common.data.Capable.OK))); assertTrue("can upload refs/heads/master", u.controlForRef("refs/heads/master").canUpload()); assertFalse("deny refs/heads/foobar", u.controlForRef("refs/heads/foobar").canUpload()); }
public void testUnblockInLocalRange_Fails() { grant(parent, ((LABEL) + "Code-Review"), (-1), 1, anonymous, "refs/heads/*").setBlock(); grant(local, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/*"); com.google.gerrit.server.project.ProjectControl u = user(devs); com.google.gerrit.common.data.PermissionRange range = u.controlForRef("refs/heads/master").getRange(((LABEL) + "Code-Review")); assertFalse("u can't vote -2", range.contains((-2))); assertFalse("u can't vote 2", range.contains(2)); }


public void testUnblockRangeOnLargerScope_Fails() { grant(local, ((LABEL) + "Code-Review"), (-1), (+1), anonymous, "refs/heads/master").setBlock(); grant(local, ((LABEL) + "Code-Review"), (-2), (+2), devs, "refs/heads/*"); com.google.gerrit.server.project.ProjectControl u = user(devs); com.google.gerrit.common.data.PermissionRange range = u.controlForRef("refs/heads/master").getRange(((LABEL) + "Code-Review")); assertFalse("u can't vote -2", range.contains((-2))); assertFalse("u can't vote +2", range.contains((-2))); }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails() { grant(parent, com.google.gerrit.server.project.READ, anonymous, "refs/heads/*").setBlock(); grant(local, com.google.gerrit.server.project.READ, registered, "refs/heads/*"); com.google.gerrit.server.project.ProjectControl u = user(registered); assertFalse("u can't read", u.controlForRef("refs/heads/master").isVisibleByRegisteredUsers()); }
@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp(); projects = new com.google.gerrit.rules.GerritCommonTest.Projects(new com.google.gerrit.common.data.LabelTypes(java.util.Arrays.asList(com.google.gerrit.rules.GerritCommonTest.category("Code-Review", com.google.gerrit.rules.GerritCommonTest.value(2, "Looks good to me, approved"), com.google.gerrit.rules.GerritCommonTest.value(1, "Looks good to me, but someone else must approve"), com.google.gerrit.rules.GerritCommonTest.value(0, "No score"), com.google.gerrit.rules.GerritCommonTest.value((-1), "I would prefer that you didn't submit this"), com.google.gerrit.rules.GerritCommonTest.value((-2), "Do not submit")), com.google.gerrit.rules.GerritCommonTest.category("Verified", com.google.gerrit.rules.GerritCommonTest.value(1, "Verified"), com.google.gerrit.rules.GerritCommonTest.value(0, "No score"), com.google.gerrit.rules.GerritCommonTest.value((-1), "Fails"))))); load("gerrit", "gerrit_common_test.pl", new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(PrologEnvironment.Args.class).toInstance(new com.google.gerrit.rules.PrologEnvironment.Args(projects, null, null, null, null, null)); } }); }
public com.google.gerrit.server.git.PluginProjectConfig getPluginConfig(java.lang.String pluginName) { com.google.common.collect.LinkedListMultimap<java.lang.String, java.lang.String> pluginConfig = pluginConfigs.get(pluginName); if (pluginConfig == null) { pluginConfig = com.google.common.collect.LinkedListMultimap.create(); pluginConfigs.put(pluginName, pluginConfig); } return new com.google.gerrit.server.git.PluginProjectConfig(pluginName, pluginConfig); }
public com.google.common.util.concurrent.ListenableFuture<?> delete(com.google.gerrit.server.query.change.ChangeData cd) { return executor.submit(deleteTask(cd)); }
public boolean canUploadMerges() { return (projectControl.controlForRef(("refs/for/" + (getRefName()))).canPerform(Permission.PUSH_MERGE)) && (canWrite()); }
private synchronized void unloadPlugin(com.google.gerrit.server.plugins.Plugin plugin) { java.lang.String name = plugin.getName(); com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Unloading plugin %s", name)); plugin.stop(env); running.remove(name); disabled.remove(name); toCleanup.add(plugin); }
private void stopRemovedPlugins(java.util.List<java.io.File> jars) { java.util.Set<java.lang.String> unload = com.google.common.collect.Sets.newHashSet(running.keySet()); for (java.io.File jar : jars) { if (!(jar.getName().endsWith(".disabled"))) { unload.remove(com.google.gerrit.server.plugins.PluginLoader.nameOf(jar)); } } for (java.lang.String name : unload) { unloadPlugin(running.get(name)); } }
private com.google.gerrit.server.plugins.Plugin runPlugin(java.lang.String name, java.io.File jar, com.google.gerrit.server.plugins.Plugin oldPlugin) throws com.google.gerrit.server.plugins.PluginInstallException { org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot = org.eclipse.jgit.internal.storage.file.FileSnapshot.save(jar); try { com.google.gerrit.server.plugins.Plugin newPlugin = loadPlugin(name, jar, snapshot); boolean reload = ((oldPlugin != null) && (oldPlugin.canReload())) && (newPlugin.canReload()); if ((!reload) && (oldPlugin != null)) { unloadPlugin(oldPlugin); } if (!(newPlugin.isDisabled())) { newPlugin.start(env); } if (reload) { env.onReloadPlugin(oldPlugin, newPlugin); unloadPlugin(oldPlugin); } else if (!(newPlugin.isDisabled())) { env.onStartPlugin(newPlugin); } if (!(newPlugin.isDisabled())) { running.put(name, newPlugin); } else { disabled.put(name, newPlugin); } broken.remove(name); return newPlugin; } catch (java.lang.Throwable err) { broken.put(name, snapshot); throw new com.google.gerrit.server.plugins.PluginInstallException(err); } }
public synchronized void rescan() { java.util.List<java.io.File> jars = scanJarsInPluginsDirectory(); stopRemovedPlugins(jars); dropRemovedDisabledPlugins(jars); for (java.io.File jar : jars) { if (jar.getName().endsWith(".disabled")) { continue; } java.lang.String name = com.google.gerrit.server.plugins.PluginLoader.nameOf(jar); org.eclipse.jgit.internal.storage.file.FileSnapshot brokenTime = broken.get(name); if ((brokenTime != null) && (!(brokenTime.isModified(jar)))) { continue; } com.google.gerrit.server.plugins.Plugin active = running.get(name); if ((active != null) && (!(active.isModified(jar)))) { continue; } if (active != null) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Reloading plugin %s", name)); } try { com.google.gerrit.server.plugins.Plugin loadedPlugin = runPlugin(name, jar, active); if ((active == null) && (!(loadedPlugin.isDisabled()))) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Loaded plugin %s", name)); } } catch (com.google.gerrit.server.plugins.PluginInstallException e) { com.google.gerrit.server.plugins.PluginLoader.log.warn(java.lang.String.format("Cannot load plugin %s", name), e.getCause()); } } cleanInBackground(); }
public void installPluginFromStream(java.lang.String name, java.io.InputStream in) throws com.google.gerrit.server.plugins.PluginInstallException, java.io.IOException { if (!(name.endsWith(".jar"))) { name += ".jar"; } java.io.File jar = new java.io.File(pluginsDir, name); name = com.google.gerrit.server.plugins.PluginLoader.nameOf(jar); java.io.File old = new java.io.File(pluginsDir, ((".last_" + name) + ".zip")); java.io.File tmp = com.google.gerrit.server.plugins.PluginLoader.asTemp(in, (".next_" + name), ".zip", pluginsDir); synchronized(this) { com.google.gerrit.server.plugins.Plugin active = running.get(name); if (active != null) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Replacing plugin %s", name)); old.delete(); jar.renameTo(old); } new java.io.File(pluginsDir, (name + ".jar.disabled")).delete(); tmp.renameTo(jar); try { runPlugin(name, jar, active); if (active == null) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Installed plugin %s", name)); } } catch (com.google.gerrit.server.plugins.PluginInstallException e) { jar.delete(); throw e; } cleanInBackground(); } }
void display(final com.google.gerrit.common.data.ProjectDetail result) { project = result.project; descTxt.setText(project.getDescription()); setBool(contributorAgreements, result.useContributorAgreements); setBool(signedOffBy, result.useSignedOffBy); setBool(contentMerge, result.useContentMerge); setBool(requireChangeID, result.requireChangeID); setSubmitType(project.getSubmitType()); setState(project.getState()); maxObjectSizeLimit.setText(project.getMaxObjectSizeLimit()); saveProject.setEnabled(false); projectDetail = result; }



@java.lang.Override protected void configure() { delete(com.googlesource.gerrit.plugins.deleteproject.PROJECT_KIND).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProject.class); }
@java.lang.Override protected void configure() { bind(com.googlesource.gerrit.plugins.deleteproject.cache.CacheDeleteHandler.class); bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT)).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.class); bind(com.googlesource.gerrit.plugins.deleteproject.database.DatabaseDeleteHandler.class).to(registerDatabaseHandler()); bind(com.googlesource.gerrit.plugins.deleteproject.fs.FilesystemDeleteHandler.class); install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { delete(com.googlesource.gerrit.plugins.deleteproject.PROJECT_KIND).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProject.class); } }); }
private void loadPlugins(com.google.gerrit.common.data.HostPageData hpd, final java.lang.String token) { if ((hpd.plugins) != null) { for (final java.lang.String url : hpd.plugins) { com.google.gwt.core.client.ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new com.google.gwt.core.client.Callback<java.lang.Void, java.lang.Exception>() { @java.lang.Override public void onSuccess(java.lang.Void result) { } @java.lang.Override public void onFailure(java.lang.Exception reason) { com.google.gerrit.client.ErrorDialog d = new com.google.gerrit.client.ErrorDialog(reason); d.setTitle(com.google.gerrit.client.Gerrit.M.pluginFailed(url)); d.center(); } }).inject(); } } com.google.gwtjsonrpc.client.CallbackHandle<java.lang.Void> cb = new com.google.gwtjsonrpc.client.CallbackHandle<java.lang.Void>(new com.google.gwtjsonrpc.client.impl.ResultDeserializer<java.lang.Void>() { @java.lang.Override public java.lang.Void fromResult(com.google.gwt.core.client.JavaScriptObject responseObject) { return null; } }, new com.google.gwtjsonrpc.common.AsyncCallback<java.lang.Void>() { @java.lang.Override public void onFailure(java.lang.Throwable caught) { } @java.lang.Override public void onSuccess(java.lang.Void result) { com.google.gerrit.client.Gerrit.display(token); } }); cb.install(); com.google.gwt.core.client.ScriptInjector.fromString(((cb.getFunctionName()) + "();")).setWindow(ScriptInjector.TOP_WINDOW).inject(); }
@java.lang.Override public void onFailure(java.lang.Exception reason) { com.google.gerrit.client.ErrorDialog d = new com.google.gerrit.client.ErrorDialog(reason); d.setTitle(com.google.gerrit.client.Gerrit.M.pluginFailed(url)); d.center(); }

@java.lang.Override protected void configure() { bind(com.googlesource.gerrit.plugins.deleteproject.cache.CacheDeleteHandler.class); bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT)).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.class); bind(com.googlesource.gerrit.plugins.deleteproject.database.DatabaseDeleteHandler.class).to(registerDatabaseHandler()); bind(com.googlesource.gerrit.plugins.deleteproject.fs.FilesystemDeleteHandler.class); install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { delete(com.googlesource.gerrit.plugins.deleteproject.PROJECT_KIND).to(com.googlesource.gerrit.plugins.deleteproject.DeleteProject.class); post(com.googlesource.gerrit.plugins.deleteproject.PROJECT_KIND, "delete").to(com.googlesource.gerrit.plugins.deleteproject.DeleteProject.class); } }); }

private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "asciidoctor: FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream(zipFile)); byte[] buf = new byte[Main.BUFSIZ]; for (java.lang.String inputFile : inputFiles) { java.io.File tmp = java.io.File.createTempFile("doc", ".html"); org.asciidoctor.Options options = createOptions(tmp); renderInput(options, inputFile); java.io.FileInputStream input = new java.io.FileInputStream(tmp); int len; zip.putNextEntry(new java.util.zip.ZipEntry(mapInFileToOutFile(inputFile))); while ((len = input.read(buf)) > 0) { zip.write(buf, 0, len); } input.close(); tmp.delete(); zip.closeEntry(); } zip.close(); }








public static void deleteDraftChange(final com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.git.GitRepositoryManager gitManager, final com.google.gerrit.server.extensions.events.GitReferenceUpdated gitRefUpdated, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { final com.google.gerrit.reviewdb.client.Change.Id changeId = patchSetId.getParentKey(); final com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); if ((change == null) || ((change.getStatus()) != (Change.Status.DRAFT))) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } for (com.google.gerrit.reviewdb.client.PatchSet ps : db.patchSets().byChange(changeId)) { com.google.gerrit.server.ChangeUtil.deleteOnlyDraftPatchSet(ps, change, gitManager, gitRefUpdated, db); } db.changeMessages().delete(db.changeMessages().byChange(changeId)); db.starredChanges().delete(db.starredChanges().byChange(changeId)); db.trackingIds().delete(db.trackingIds().byChange(changeId)); db.changes().delete(java.util.Collections.singleton(change)); }



private void initChangeActions(com.google.gerrit.client.changes.ChangeInfo info, boolean hasUser) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (info.has_actions()) ? info.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); abandon.setVisible((hasUser && (actions.containsKey("abandon")))); restore.setVisible((hasUser && (actions.containsKey("restore")))); revert.setVisible((hasUser && (actions.containsKey("revert")))); if (hasUser) { for (java.lang.String id : com.google.gerrit.client.change.Actions.filterNonCore(actions)) { add(new com.google.gerrit.client.actions.ActionButton(info, actions.get(id))); } } }



private void initRevisionActions(com.google.gerrit.client.changes.ChangeInfo info, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo, boolean hasUser) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (revInfo.has_actions()) ? revInfo.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); cherrypick.setVisible((hasUser && (actions.containsKey("cherrypick")))); rebase.setVisible((hasUser && (actions.containsKey("rebase")))); canSubmit = hasUser && (actions.containsKey("submit")); if (hasUser) { for (java.lang.String id : com.google.gerrit.client.change.Actions.filterNonCore(actions)) { add(new com.google.gerrit.client.actions.ActionButton(info, revInfo, actions.get(id))); } } }

@java.lang.Override protected void configureServlets() { serve("/say-hello/*").with(com.googlesource.gerrit.plugins.cookbook.HelloWorldServlet.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class).toInstance(new com.google.gerrit.extensions.webui.JavaScriptPlugin("hello.js")); }

@org.junit.Test public void noMessages() throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange(); com.google.gerrit.acceptance.rest.change.ChangeInfo c = getChangeWithMessages(changeId); assertNotNull(c.messages); assertTrue(c.messages.isEmpty()); }

public boolean canCreate(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevObject object) { if (!(canWrite())) { return false; } boolean owner; switch (getCurrentUser().getAccessPath()) { case REST_API : case JSON_RPC : owner = isOwner(); break; default : owner = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { return owner || (canPerform(Permission.CREATE)); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if ((getCurrentUser()) instanceof com.google.gerrit.server.IdentifiedUser) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); final java.lang.String addr = tagger.getEmailAddress(); valid = user.getEmailAddresses().contains(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.PUSH_SIGNED_TAG)); } else { return owner || (canPerform(Permission.PUSH_TAG)); } } else { return false; } }
private void parseCreate(final org.eclipse.jgit.transport.ReceiveCommand cmd) { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { com.google.gerrit.server.git.ReceiveCommits.log.error((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); reject(cmd, "invalid object"); return; } if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canCreate(rp.getRevWalk(), obj)) { validateNewCommits(ctl, cmd); batch.addCommand(cmd); } else { reject(cmd); } }
private void revision(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, int index, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r) { com.google.gerrit.client.changes.ChangeInfo.CommitInfo c = r.commit(); sb.openTr(); if (revision.equals(r.name())) { sb.setStyleName(style.current()); } sb.openTd().setStyleName(style.legacy_id()).append(r._number()); if (r.draft()) { sb.append(" ").append(Resources.C.draft()); } sb.closeTd(); sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", ("#" + (url(r)))).setAttribute("onclick", ((((com.google.gerrit.client.change.RevisionsBox.OPEN) + "(event,") + index) + ")")).append(r.name().substring(0, 10)).closeAnchor().closeTd(); sb.openTd().append(com.google.gerrit.client.FormatUtil.shortFormatDayTime(c.committer().date())).closeTd(); java.lang.String an = ((c.author()) != null) ? c.author().name() : null; java.lang.String cn = ((c.committer()) != null) ? c.committer().name() : null; sb.openTd(); sb.append(an); if (((!("".equals(an))) && (!("".equals(cn)))) && (!(an.equals(cn)))) { sb.append(" / ").append(cn); } sb.closeTd(); sb.closeTr(); }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { try { final com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { context.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } @java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser() { throw new com.google.inject.OutOfScopeException("No user during ChangeIndexer"); } }); if ((indexes) != null) { for (com.google.gerrit.server.index.ChangeIndex i : indexes.getWriteIndexes()) { i.replace(cd); } } else { index.replace(cd); } return null; } finally { context.setContext(null); db.close(); } } catch (java.lang.Exception e) { com.google.gerrit.server.index.ChangeIndexerImpl.log.error(java.lang.String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e); throw e; } }
private void setMerged(final com.google.gerrit.reviewdb.client.Change c, final com.google.gerrit.reviewdb.client.ChangeMessage msg) throws com.google.gwtorm.server.OrmException { try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change.currentPatchSetId(); setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = saveApprovals(c, merged); addMergedMessage(submitter, msg); db.commit(); sendMergedEmail(c, submitter); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db); } catch (com.google.gwtorm.server.OrmException ex) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } } finally { db.rollback(); } indexer.index(c); }
@java.lang.Override public java.util.concurrent.Callable<?> indexTask(com.google.gerrit.server.query.change.ChangeData cd) { return new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() { return null; } }; }
@java.lang.Override public java.util.concurrent.Callable<?> deleteTask(com.google.gerrit.server.query.change.ChangeData cd) { return new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() { return null; } }; }


@java.lang.Override protected void configureCommands() { command(com.google.gerrit.plugins.ShowAccountCommand.class); alias("show-account", com.google.gerrit.plugins.ShowAccountCommand.class); }
private org.eclipse.jgit.lib.ObjectId createNoteContent(org.eclipse.jgit.revwalk.RevCommit c) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.reviewdb.client.PatchSet> patches = reviewDb.patchSets().byRevision(new com.google.gerrit.reviewdb.client.RevId(c.name())).toList(); com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt = new com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter(gerritServerIdent.getTimeZone(), anonymousCowardName); if (patches.isEmpty()) { return null; } else if ((patches.size()) == 1) { try { createCodeReviewNote(patches.get(0), fmt); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new java.io.IOException(e); } } else { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes.log.error((("Cannot create review note:" + " more than one patch set found for the commit ") + (c.name()))); return null; } return getInserter().insert(Constants.OBJ_BLOB, fmt.toString().getBytes("UTF-8")); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { com.google.gerrit.reviewdb.client.Account userAccount = null; try { userAccount = accountResolver.find(userName); } catch (com.google.gwtorm.server.OrmException e) { throw die(e); } if (userAccount == null) { stdout.print((("No single user could be found when searching for: " + (userName)) + '\n')); stdout.flush(); return; } com.google.gerrit.server.IdentifiedUser user = userFactory.create(userAccount.getId()); com.google.gerrit.server.project.ProjectControl userProjectControl = projectControl.forUser(user); org.eclipse.jgit.lib.Repository repo = null; try { repo = repoManager.openRepository(userProjectControl.getProject().getNameKey()); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refsMap = new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getAllRefs(), false); for (final java.lang.String ref : refsMap.keySet()) { if ((!(onlyRefsHeads)) || (ref.startsWith(Branch.R_HEADS))) { stdout.println(ref); } } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.commands.UnloggedFailure((("fatal: '" + (projectControl.getProject().getNameKey())) + "': not a git archive")); } catch (java.io.IOException e) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(("fatal: Error opening: '" + (projectControl.getProject().getNameKey()))); } finally { if (repo != null) { repo.close(); } } }
void build(org.eclipse.jgit.lib.Repository git, com.google.gerrit.server.git.TagSet old, com.google.gerrit.server.git.TagMatcher m) { if (((old != null) && (m != null)) && (refresh(old, m))) { return; } com.google.gerrit.server.git.TagSet.TagWalk rw = new com.google.gerrit.server.git.TagSet.TagWalk(git); rw.setRetainBody(false); try { for (org.eclipse.jgit.lib.Ref ref : git.getAllRefs().values()) { if (com.google.gerrit.server.git.TagSet.skip(ref)) { continue; } else if (com.google.gerrit.server.git.TagSet.isTag(ref)) { addTag(rw, git.peel(ref)); } else { addRef(rw, ref); } } com.google.gerrit.server.git.TagSet.TagCommit c; while ((c = ((com.google.gerrit.server.git.TagSet.TagCommit) (rw.next()))) != null) { java.util.BitSet mine = c.refFlags; int pCnt = c.getParentCount(); for (int pIdx = 0; pIdx < pCnt; pIdx++) { ((com.google.gerrit.server.git.TagSet.TagCommit) (c.getParent(pIdx))).refFlags.or(mine); } } } catch (java.io.IOException e) { com.google.gerrit.server.git.TagSet.log.warn((("Repository " + (projectName)) + " has corruption"), e); } finally { rw.release(); } }
private Change.Id insertPatchSet(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, org.eclipse.jgit.revwalk.RevCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit).setMessage(buildChangeMessage(patchSetId, change)).insert(); return change.getId(); }
public void setCurrentFilePaths(java.util.List<java.lang.String> filePaths) { currentFiles = filePaths; }
@java.lang.Override public Iterable<java.lang.String> get(com.google.gerrit.server.query.change.ChangeData input, com.google.gerrit.server.index.FillArgs args) throws com.google.gwtorm.server.OrmException { Set<java.lang.String> r = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.TrackingId id : input.trackingIds(args.db)) { r.add(id.getTrackingId()); } return r; }




private void redirectToNextStep(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp) throws java.io.IOException { java.lang.String nextUrl = req.getParameter("next"); if ((com.google.common.base.Strings.emptyToNull(nextUrl)) != null) { resp.sendRedirect(nextUrl); } }

public boolean isLoggedIn(java.util.Set<com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope> scopes) { boolean loggedIn = ((scopesSet.equals(scopes)) && ((token) != null)) && ((hub) != null); if (loggedIn) { try { myself = hub.getMyself(); } catch (java.lang.Throwable e) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.error("Connection to GitHub broken: logging out", e); logout(); loggedIn = false; } } return loggedIn; }
@java.lang.Override void onOneNodeReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { }
abstract void onOneNodeReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status);
@java.lang.Override void onOneNodeReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("Replicate "); sb.append(project); sb.append(" to "); if ((uri.getHost()) != null) { sb.append(uri.getHost()); } else { sb.append("localhost"); } sb.append(", "); switch (status) { case SUCCEEDED : sb.append("Succeeded!"); break; case FAILED : sb.append("FAILED!"); hasError.compareAndSet(false, true); break; case NOT_ATTEMPTED : sb.append("NOT ATTEMPTED!"); break; default : sb.append("UNKNOWN RESULT!"); break; } writeStdOut(sb.toString()); }
public void notifyRefReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { pushResultProcessing.onOneNodeReplicated(project, ref, uri, status); countingLock.lock(); try { (finishedPushTasksCount)++; if (!(allScheduled)) { return; } if ((finishedPushTasksCount) < (totalPushTasksCount)) { return; } } finally { countingLock.unlock(); } doAllPushTasksCompleted(); }
private void statesCleanUp() { if ((!(stateMap.isEmpty())) && (!(isRetrying()))) { for (java.util.Map.Entry<java.lang.String, com.googlesource.gerrit.plugins.replication.ReplicationState> entry : stateMap.entries()) { entry.getValue().notifyRefReplicated(projectName.get(), entry.getKey(), uri, RefPushResult.FAILED); } } }
private void initProjectActions(com.google.gerrit.client.projects.ConfigInfo info) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = info.actions(); if ((actions == null) || (actions.isEmpty())) { return; } actions.copyKeysIntoChildren("id"); actionsGrid.addHeader(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingProjectCommands())); com.google.gwt.user.client.ui.FlowPanel actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions()); actionsPanel.setVisible(true); actionsGrid.add(Util.C.headingCommands(), actionsPanel); for (java.lang.String id : actions.keySet()) { actionsPanel.add(new com.google.gerrit.client.actions.ActionButton(getProjectKey(), actions.get(id))); } }
protected void createCommentEditor(final int suggestRow, final int column, final int line, final short file) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { if ((com.google.gerrit.client.patches.AbstractPatchContentTable.R_HEAD) <= line) { final com.google.gerrit.reviewdb.client.Patch.Key parentKey; final short side; switch (file) { case 0 : if ((idSideA) == null) { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (0)); } else { parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideA, patchKey.get()); side = ((short) (1)); } break; case 1 : parentKey = new com.google.gerrit.reviewdb.client.Patch.Key(idSideB, patchKey.get()); side = ((short) (1)); break; default : throw new java.lang.RuntimeException(("unexpected file id " + file)); } final com.google.gerrit.reviewdb.client.PatchLineComment newComment = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(parentKey, null), line, com.google.gerrit.client.Gerrit.getUserAccount().getId(), null); newComment.setSide(side); newComment.setMessage(""); findOrCreateCommentEditor(suggestRow, column, newComment, true).setFocus(true); } } else { com.google.gerrit.client.Gerrit.doSignIn(com.google.gwt.user.client.History.getToken()); } }
private com.google.gerrit.reviewdb.client.PatchLineComment newComment() { com.google.gerrit.reviewdb.client.PatchLineComment newComment = new com.google.gerrit.reviewdb.client.PatchLineComment(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(comment.getKey().getParentKey(), null), comment.getLine(), com.google.gerrit.client.Gerrit.getUserAccount().getId(), comment.getKey().get()); newComment.setSide(comment.getSide()); return newComment; }
public static void updateMenus(com.google.gerrit.client.ui.Screen view) { com.google.gerrit.client.ui.LinkMenuBar diffBar = com.google.gerrit.client.Gerrit.menuBars.get(com.google.gerrit.client.Gerrit.DIFF_BAR); if (view instanceof com.google.gerrit.client.patches.PatchScreen) { com.google.gerrit.client.Gerrit.patchScreen = ((com.google.gerrit.client.patches.PatchScreen) (view)); com.google.gerrit.client.Gerrit.menuLeft.setVisible(diffBar, true); com.google.gerrit.client.Gerrit.menuLeft.selectTab(com.google.gerrit.client.Gerrit.menuLeft.getWidgetIndex(diffBar)); } else { if (((com.google.gerrit.client.Gerrit.patchScreen) != null) && ((com.google.gerrit.client.Gerrit.menuLeft.getSelectedWidget()) == diffBar)) { com.google.gerrit.client.Gerrit.menuLeft.selectTab((com.google.gerrit.client.Gerrit.isSignedIn() ? 1 : 0)); } com.google.gerrit.client.Gerrit.patchScreen = null; com.google.gerrit.client.Gerrit.menuLeft.setVisible(diffBar, false); } }
public boolean canDelete() { if ((!(canWrite())) || (GitRepositoryManager.REF_CONFIG.equals(refName))) { return false; } switch (getCurrentUser().getAccessPath()) { case REST_API : case JSON_RPC : case SSH_COMMAND : return (isOwner()) || (canPushWithForce()); case GIT : return canPushWithForce(); default : return false; } }


void set(com.google.gerrit.client.ui.CommentLinkProcessor commentLinkProcessor, com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = change.revision(revision); com.google.gerrit.client.changes.ChangeInfo.CommitInfo commit = revInfo.commit(); commitName.setInnerText(revision); format(commit.author(), authorNameEmail, authorDate); format(commit.committer(), committerNameEmail, committerDate); commitMessageText.setInnerSafeHtml(commentLinkProcessor.apply(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commit.message()).linkify())); com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && (gw.canLink(revInfo))) { browserLink.setInnerText(gw.getLinkName()); browserLink.setHref(gw.toRevision(change.project(), revision)); } else { com.google.gwt.user.client.ui.UIObject.setVisible(browserLink, false); } }
@java.lang.Override protected void onUnload() { super.onUnload(); removeKeyHandlerRegs(); if ((resizeHandler) != null) { resizeHandler.removeHandler(); resizeHandler = null; } cmA.getWrapperElement().removeFromParent(); cmB.getWrapperElement().removeFromParent(); com.google.gwt.user.client.Window.enableScrolling(true); com.google.gerrit.client.Gerrit.setHeaderVisible(true); }
@java.lang.Override public void onShowView() { super.onShowView(); handlers.add(com.google.gwtexpui.user.client.UserAgent.addDialogVisibleHandler(new com.google.gwtexpui.user.client.DialogVisibleHandler() { @java.lang.Override public void onDialogVisible(com.google.gwtexpui.user.client.DialogVisibleEvent event) { diffTable.getElement().getStyle().setVisibility((event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE)); } })); resizeCodeMirror(); com.google.gwt.user.client.Window.enableScrolling(false); cmA.setOption("viewportMargin", 10); cmB.setOption("viewportMargin", 10); cmB.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmB.focus(); prefetchNextFile(); }
@java.lang.Override public java.lang.String getUrl(java.lang.String project) { if (!(isEnabled())) { return null; } final java.lang.StringBuilder r = new java.lang.StringBuilder(); if ((gitHttpUrl) != null) { r.append(gitHttpUrl); } else if ((canonicalWebUrl) != null) { java.lang.String base = canonicalWebUrl; int p = base.indexOf("://"); int s = base.indexOf('/', (p + 3)); if (s < 0) { s = base.length(); } java.lang.String host = base.substring((p + 3), s); r.append(base.substring(0, (p + 3))); r.append("${username}@"); r.append(host); r.append(base.substring(s)); } else { return null; } r.append(project); return r.toString(); }
@java.lang.Override public java.lang.String getUrl(java.lang.String project) { if (!(isEnabled())) { return null; } java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(com.googlesource.gerrit.plugins.download.scheme.SshScheme.ensureSlash(sshdAddress)); r.append(project); return r.toString(); }
@java.lang.Override public com.google.gerrit.server.project.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) { return new com.google.gerrit.server.project.ConfigInfo(resource.getControl().getProjectState(), config); }

@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.config.DownloadCommand.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("Checkout")).to(com.googlesource.gerrit.plugins.download.command.CheckoutCommand.class); bind(com.google.gerrit.extensions.config.DownloadCommand.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("Cherry-Pick")).to(com.googlesource.gerrit.plugins.download.command.CherryPickCommand.class); bind(com.google.gerrit.extensions.config.DownloadCommand.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("Format-Patch")).to(com.googlesource.gerrit.plugins.download.command.FormatPatchCommand.class); bind(com.google.gerrit.extensions.config.DownloadCommand.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("Pull")).to(com.googlesource.gerrit.plugins.download.command.PullCommand.class); bind(com.google.gerrit.extensions.config.DownloadCommand.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named("Repo-Download")).to(com.googlesource.gerrit.plugins.download.command.RepoCommand.class); }

private static java.io.File tmproot() { java.lang.String userHome = java.lang.System.getProperty("user.home"); if ((userHome == null) || ("".equals(userHome))) { userHome = java.lang.System.getenv("HOME"); if ((userHome == null) || ("".equals(userHome))) { java.lang.System.err.println("warning: cannot determine home directory"); java.lang.System.err.println("warning: using system temporary directory instead"); return null; } } final java.io.File home = new java.io.File(userHome); if (!(home.exists())) { if (home.mkdirs()) { java.lang.System.err.println(("warning: created " + (home.getAbsolutePath()))); } else { java.lang.System.err.println((("warning: " + (home.getAbsolutePath())) + " not found")); java.lang.System.err.println("warning: using system temporary directory instead"); return null; } } final java.io.File tmp = new java.io.File(new java.io.File(home, ".gerritcodereview"), "tmp"); if ((!(tmp.exists())) && (!(tmp.mkdirs()))) { java.lang.System.err.println(("warning: cannot create " + (tmp.getAbsolutePath()))); java.lang.System.err.println("warning: using system temporary directory instead"); return null; } final java.io.File[] tmpEntries = tmp.listFiles(); if (tmpEntries != null) { final long now = java.lang.System.currentTimeMillis(); final long expired = now - (java.util.concurrent.TimeUnit.MILLISECONDS.convert(7, java.util.concurrent.TimeUnit.DAYS)); for (final java.io.File tmpEntry : tmpEntries) { if ((tmpEntry.isDirectory()) && ((tmpEntry.lastModified()) < expired)) { final java.lang.String[] all = tmpEntry.list(); if ((all == null) || ((all.length) == 0)) { tmpEntry.delete(); } } } } try { return tmp.getCanonicalFile(); } catch (java.io.IOException e) { return tmp; } }






void setUpPatchSetNav(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list) { com.google.gerrit.client.ui.InlineHyperlink baseLink = null; com.google.gerrit.client.ui.InlineHyperlink selectedLink = null; if (sideA) { baseLink = createLink(PatchUtil.C.patchBase(), null); linkPanel.add(baseLink); } for (int i = 0; i < (list.length()); i++) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r = list.get(i); com.google.gerrit.client.ui.InlineHyperlink link = createLink(java.lang.String.valueOf(r._number()), new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, r._number())); linkPanel.add(link); if (((revision) != null) && ((r._number()) == (revision.get()))) { selectedLink = link; } } if (selectedLink != null) { selectedLink.setStyleName(style.selected()); } else if (sideA) { baseLink.setStyleName(style.selected()); } }

@java.lang.Override protected boolean beforeInit(com.google.gerrit.pgm.SiteInit init) throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); if (!(skipPlugins)) { final java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPlugins(init.site); com.google.gerrit.pgm.util.ConsoleUI ui = com.google.gerrit.pgm.util.ConsoleUI.getInstance(false); verifyInstallPluginList(ui, plugins); if (listPlugins) { if (!(plugins.isEmpty())) { ui.message("Available plugins:\n"); for (com.google.gerrit.pgm.init.InitPlugins.PluginData plugin : plugins) { ui.message(" * %s version %s\n", plugin.name, plugin.version); } } else { ui.message("No plugins found.\n"); } return true; } } return false; }




@java.lang.Override protected void insert(int row, com.google.gerrit.client.projects.ProjectInfo k) { super.insert(row, k); if ((com.google.gerrit.client.Gerrit.getGitwebLink()) != null) { table.getFlexCellFormatter().addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); } }
@java.lang.Override protected void populate(final int row, final com.google.gerrit.client.projects.ProjectInfo k) { com.google.gwt.user.client.ui.FlowPanel fp = new com.google.gwt.user.client.ui.FlowPanel(); fp.add(new com.google.gerrit.client.ui.ProjectSearchLink(k.name_key())); fp.add(new com.google.gerrit.client.ui.HighlightingInlineHyperlink(k.name(), link(k), subname)); table.setWidget(row, 1, fp); table.setText(row, 2, k.description()); com.google.gerrit.client.GitwebLink l = com.google.gerrit.client.Gerrit.getGitwebLink(); if (l != null) { table.setWidget(row, 3, new com.google.gwt.user.client.ui.Anchor(l.getLinkName(), false, l.toProject(k.name_key()))); } setRowItem(row, k); }
@java.lang.Override protected void initColumnHeaders() { super.initColumnHeaders(); if ((com.google.gerrit.client.Gerrit.getGitwebLink()) != null) { table.setText(0, 3, Util.C.projectRepoBrowser()); table.getFlexCellFormatter().addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader()); } }
private void initProjectLink(com.google.gerrit.client.changes.ChangeInfo info) { projectLink.setText(info.project()); projectLink.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toChangeQuery(com.google.gerrit.common.PageLinks.projectQuery(info.project_name_key(), info.status()))); }

@java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(pluginName); }
private com.google.inject.Injector getPluginInjector(java.io.File jarFile) { java.lang.String jarFileName = jarFile.getName(); final java.lang.String pluginName = jarFileName.substring(0, jarFileName.lastIndexOf('.')); return initInjector.createChildInjector(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(pluginName); } }); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> oldRefs = rp.getAdvertisedRefs(); if (oldRefs == null) { try { oldRefs = rp.getRepository().getRefDatabase().getRefs(com.google.gerrit.server.git.ALL); } catch (java.io.IOException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(e.getMessage()); ex.initCause(e); throw ex; } } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> r = com.google.common.collect.Maps.newHashMapWithExpectedSize(oldRefs.size()); for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : oldRefs.entrySet()) { java.lang.String name = e.getKey(); if (!(com.google.gerrit.server.git.ReceiveCommitsAdvertiseRefsHook.skip(name))) { r.put(name, e.getValue()); } } rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp)); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { allRefs = rp.getAdvertisedRefs(); if ((allRefs) == null) { try { allRefs = rp.getRepository().getRefDatabase().getRefs(com.google.gerrit.server.git.ALL); } catch (java.io.IOException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(e.getMessage()); ex.initCause(e); throw ex; } } rp.setAdvertisedRefs(allRefs, rp.getAdvertisedObjects()); }
@java.lang.Override protected java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getAdvertisedRefs(org.eclipse.jgit.lib.Repository repository, org.eclipse.jgit.revwalk.RevWalk revWalk) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { try { return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL)); } catch (java.io.IOException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(e.getMessage()); ex.initCause(e); throw ex; } }
void cleanup() { try { jarFile.close(); } catch (java.io.IOException err) { } if ((!(tmpFile.delete())) && (tmpFile.exists())) { PluginLoader.log.warn((("Cannot delete " + (tmpFile.getAbsolutePath())) + ", retrying to delete it on termination of the virtual machine")); tmpFile.deleteOnExit(); } else { PluginLoader.log.info(("Cleaned plugin " + (tmpFile.getName()))); } }
private java.io.File getSiteFromReviewDb(java.sql.Connection conn) { try { java.sql.ResultSet rs = conn.createStatement().executeQuery("select site_path from system_config"); if (rs.next()) { return new java.io.File(rs.getString(1)); } return null; } catch (java.sql.SQLException e) { return null; } }














private void renderCheckBox(int row, final java.lang.String id, com.google.gerrit.client.changes.ChangeInfo.LabelInfo info) { com.google.gerrit.client.changes.ChangeInfo.ApprovalInfo self = (com.google.gerrit.client.Gerrit.isSignedIn()) ? info.for_user(com.google.gerrit.client.Gerrit.getUserAccount().getId().get()) : null; final com.google.gwt.user.client.ui.CheckBox b = new com.google.gwt.user.client.ui.CheckBox(); b.setText(id); b.setTitle(info.value_text("+1")); if ((self != null) && ((self.value()) == 1)) { b.setValue(true); } b.addValueChangeHandler(new com.google.gwt.event.logical.shared.ValueChangeHandler<java.lang.Boolean>() { @java.lang.Override public void onValueChange(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> event) { in.label(id, (event.getValue() ? ((short) (1)) : ((short) (0)))); } }); b.setStyleName(style.label_name()); labelsTable.setWidget(row, 0, b); lgtm.add(new java.lang.Runnable() { @java.lang.Override public void run() { b.setValue(true, true); } }); }
@com.google.gwt.uibinder.client.UiHandler("message") void onMessageKey(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((((event.getCharCode()) == '\n') || ((event.getCharCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER))) && (event.isControlKeyDown())) { event.preventDefault(); event.stopPropagation(); onSend(null); } else if ((((lgtm) != null) && ((event.getCharCode()) == 'M')) && (message.getValue().equals("LGT"))) { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { if (message.getValue().startsWith("LGTM")) { for (java.lang.Runnable r : lgtm) { r.run(); } } } }); } }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> file(java.lang.String file) throws com.google.gerrit.server.query.QueryParseException { if (file.startsWith("^")) { if ((allowFileRegex) || ((args.index) != (com.google.gerrit.server.index.ChangeIndex.DISABLED))) { return new com.google.gerrit.server.query.change.RegexFilePredicate(args.dbProvider, args.patchListCache, file); } else { throw error(("secondary index must be enabled for file:" + file)); } } else { if ((args.index) == (com.google.gerrit.server.index.ChangeIndex.DISABLED)) { throw error(("secondary index must be enabled for file:" + file)); } return new com.google.gerrit.server.query.change.EqualsFilePredicate(args.dbProvider, args.patchListCache, file); } }


@java.lang.Override public synchronized void init(javax.servlet.ServletConfig config) throws javax.servlet.ServletException { super.init(config); java.lang.String path = config.getServletContext().getContextPath(); base = (com.google.common.base.Strings.nullToEmpty(path)) + "/plugins/"; for (com.google.gerrit.server.plugins.Plugin plugin : pending) { install(plugin); } pending = null; }


@java.lang.Override protected void configureServlets() { com.googlesource.gerrit.plugins.gitblit.GitBlitModule.log.info("Configuring servlet and filters"); bind(com.gitblit.IUserService.class).to(com.googlesource.gerrit.plugins.gitblit.auth.GerritToGitBlitUserService.class); bind(com.googlesource.gerrit.plugins.gitblit.app.GerritGitBlit.class); serve("/pages/*").with(com.googlesource.gerrit.plugins.gitblit.WrappedPagesServlet.class); serve("/feed/*").with(com.googlesource.gerrit.plugins.gitblit.WrappedSyndicationServlet.class); filter("/*").through(com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.class); filter("/pages/*").through(com.googlesource.gerrit.plugins.gitblit.WrappedPagesFilter.class); filter("/feed/*").through(com.googlesource.gerrit.plugins.gitblit.WrappedSyndicationFilter.class); }
public void increasePushTaskCount() { countingLock.lock(); try { (totalPushTasksCount)++; } finally { countingLock.unlock(); } }
@java.lang.Override void onOneNodeReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("Replicate "); sb.append(project); sb.append(" to "); sb.append(com.googlesource.gerrit.plugins.replication.PushResultProcessing.resolveNodeName(uri)); sb.append(", "); switch (status) { case SUCCEEDED : sb.append("Succeeded!"); break; case FAILED : sb.append("FAILED!"); hasError.compareAndSet(false, true); break; case NOT_ATTEMPTED : sb.append("NOT ATTEMPTED!"); break; default : sb.append("UNKNOWN RESULT!"); break; } writeStdOut(sb.toString()); }

public boolean hasPushTask() { return (totalPushTasksCount) != 0; }

private void doAllPushTasksCompleted() { pushResultProcessing.onAllNodesReplicated(totalPushTasksCount); allPushTasksFinished.countDown(); }


public void notifyRefReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { pushResultProcessing.onOneNodeReplicated(project, ref, uri, status); countingLock.lock(); try { (finishedPushTasksCount)++; if (!(allScheduled)) { return; } if ((finishedPushTasksCount) < (totalPushTasksCount)) { return; } } finally { countingLock.unlock(); } doAllPushTasksCompleted(); }



public void markAllPushTasksScheduled() { countingLock.lock(); try { allScheduled = true; if ((finishedPushTasksCount) < (totalPushTasksCount)) { return; } } finally { countingLock.unlock(); } doAllPushTasksCompleted(); }
@java.lang.Override public void onSuccess(com.google.gwtjsonrpc.common.VoidResult result) { if ((com.google.gerrit.client.changes.StarredChanges.next) != null) { com.google.gerrit.client.changes.StarredChanges.start(); } else { com.google.gerrit.client.changes.StarredChanges.busy = false; } }
@java.lang.Override public void onFailure(java.lang.Throwable caught) { com.google.gerrit.client.changes.StarredChanges.rollback(req); if ((com.google.gerrit.client.changes.StarredChanges.next) != null) { com.google.gerrit.client.changes.StarredChanges.rollback(com.google.gerrit.client.changes.StarredChanges.next); com.google.gerrit.client.changes.StarredChanges.next = null; } com.google.gerrit.client.changes.StarredChanges.busy = false; super.onFailure(caught); }




private void applyReview(final com.google.gerrit.server.project.ChangeControl ctl, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.server.change.PostReview.Input review) throws java.lang.Exception { reviewProvider.get().apply(new com.google.gerrit.server.change.RevisionResource(new com.google.gerrit.server.change.ChangeResource(ctl), patchSet), review); }
com.google.gerrit.server.change.EmailReviewComments create(com.google.gerrit.server.change.PostReview.NotifyHandling notify, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account.Id authorId, com.google.gerrit.reviewdb.client.ChangeMessage message, java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments);
public com.google.gerrit.server.mail.CommentSender create(com.google.gerrit.server.change.PostReview.NotifyHandling notify, com.google.gerrit.reviewdb.client.Change change);








private void checkComments(java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.change.PostReview.Comment>> in) throws com.google.gerrit.extensions.restapi.BadRequestException { java.util.Iterator<java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.server.change.PostReview.Comment>>> mapItr = in.entrySet().iterator(); while (mapItr.hasNext()) { java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.server.change.PostReview.Comment>> ent = mapItr.next(); java.lang.String path = ent.getKey(); java.util.List<com.google.gerrit.server.change.PostReview.Comment> list = ent.getValue(); if (list == null) { mapItr.remove(); continue; } java.util.Iterator<com.google.gerrit.server.change.PostReview.Comment> listItr = list.iterator(); while (listItr.hasNext()) { com.google.gerrit.server.change.PostReview.Comment c = listItr.next(); if ((c.line) < 0) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("negative line number %d not allowed on %s", c.line, path)); } c.message = com.google.common.base.Strings.emptyToNull(c.message).trim(); if (c.message.isEmpty()) { listItr.remove(); } } if (list.isEmpty()) { mapItr.remove(); } } }



private void approve(java.lang.String changeId) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.post((("/changes/" + changeId) + "/revisions/current/review"), com.google.gerrit.acceptance.rest.change.ReviewInput.approve()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); r.consume(); }



private static ReviewInput makeReview() { ReviewInput in = new ReviewInput(); in.message = "Looks good!"; in.labels = com.google.common.collect.Maps.newHashMap(); in.labels.put("Code-Review", ((short) (2))); return in; }
@org.junit.Test public void reviewId() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.acceptance.api.revision.ReviewIT.makeReview()); }
@org.junit.Test public void reviewTriplet() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange(); gApi.changes().id(("p~master~" + (r.getChangeId()))).revision(r.getCommit().name()).review(com.google.gerrit.acceptance.api.revision.ReviewIT.makeReview()); }
@org.junit.Test public void reviewId() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.acceptance.api.revision.ReviewIT.makeReview()); }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.DeleteDraftPatchSet.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet patchSet = rsrc.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = patchSet.getId(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(patchSet.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Patch set is not a draft."); } if (!(rsrc.getControl().canDeleteDraft(dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("Not permitted to delete this draft patch set"); } deleteDraftPatchSet(patchSet, change); deleteOrUpdateDraftChange(patchSetId, change); return com.google.gerrit.extensions.restapi.Response.none(); }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource resource, com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.Input input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.Input(); } if (((input.username) != null) && (!(username.equals(input.username)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("username must match URL"); } if (com.google.common.base.Strings.isNullOrEmpty(input.sshKey)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("sshKey not set"); } com.google.gerrit.server.account.CreateAccount.Input in = new com.googlesource.gerrit.plugins.serviceuser.ServiceUserInput(username, input.sshKey, cfg.getFromGerritConfig(pluginName)); return createAccountFactory.create(username).apply(TopLevelResource.INSTANCE, in); }

@java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); }
@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(AddBranch.Factory.class); factory(AddRefRight.Factory.class); factory(ChangeProjectSettings.Factory.class); factory(DeleteBranches.Factory.class); factory(DeleteRefRights.Factory.class); factory(ListBranches.Factory.class); factory(VisibleProjects.Factory.class); factory(ProjectDetailFactory.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.project.ProjectAdminServiceImpl.class); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.reviewdb.ReviewDb.class).toProvider(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(com.google.gerrit.server.account.AccountResolver.class); bind(com.google.gerrit.server.query.change.ChangeQueryRewriter.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(GroupControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(ChangeQueryBuilder.Factory.class); factory(ReceiveCommits.Factory.class); factory(MergeOp.Factory.class); factory(AddReviewerSender.Factory.class); factory(CreateChangeSender.Factory.class); factory(PublishComments.Factory.class); factory(ReplacePatchSetSender.Factory.class); factory(AbandonedSender.Factory.class); factory(CommentSender.Factory.class); factory(MergedSender.Factory.class); factory(MergeFailSender.Factory.class); factory(RegisterNewEmailSender.Factory.class); }





private void enableForm(final boolean on) { delRight.setEnabled(on); rightEditor.enableForm(on); }
private void initParent() { parentPanel = new com.google.gwt.user.client.ui.VerticalPanel(); parentPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingParentProjectName())); parentName = new com.google.gerrit.client.ui.Hyperlink("", ""); parentPanel.add(parentName); add(parentPanel); }
private void updateParents() throws com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.client.OrmException { final java.lang.StringBuilder err = new java.lang.StringBuilder(); final java.util.Set<com.google.gerrit.reviewdb.Project.NameKey> grandParents = new java.util.HashSet<com.google.gerrit.reviewdb.Project.NameKey>(); com.google.gerrit.reviewdb.Project.NameKey newParentKey; grandParents.add(wildProject); if ((newParent) != null) { newParentKey = newParent.getProject().getNameKey(); com.google.gerrit.reviewdb.Project.NameKey gp = newParent.getProject().getParent(); while ((gp != null) && (grandParents.add(gp))) { final com.google.gerrit.server.project.ProjectState s = projectCache.get(gp); if (s != null) { gp = s.getProject().getParent(); } else { break; } } } else { newParentKey = null; } for (final com.google.gerrit.server.project.ProjectControl pc : children) { final com.google.gerrit.reviewdb.Project.NameKey key = pc.getProject().getNameKey(); final java.lang.String name = pc.getProject().getName(); if (wildProject.equals(key)) { err.append((("error: Cannot set parent of '" + name) + "\'\n")); continue; } if (grandParents.contains(key)) { err.append((((("error: Cycle exists between '" + name) + "' and '") + (newParentKey != null ? newParentKey.get() : wildProject.get())) + "\'\n")); continue; } final com.google.gerrit.reviewdb.Project child = db.projects().get(key); if (child == null) { err.append((("error: Project '" + name) + "\' not found\n")); continue; } child.setParent(newParentKey); db.projects().update(java.util.Collections.singleton(child)); } projectCache.evictAll(); if ((err.length()) > 0) { while ((err.charAt(((err.length()) - 1))) == '\n') { err.setLength(((err.length()) - 1)); } throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, err.toString()); } }



public org.eclipse.jgit.lib.Config getFromPluginConfig(com.google.gerrit.reviewdb.client.Project.NameKey projectName, java.lang.String pluginName) throws com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } return projectState.getConfig((pluginName + ".config")).get(); }



public boolean canReadCommit(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey projName = state.getProject().getNameKey(); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projName); try { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : repo.getAllRefs().entrySet()) { org.eclipse.jgit.revwalk.RevCommit tip; try { tip = rw.parseCommit(entry.getValue().getObjectId()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { continue; } if ((rw.isMergedInto(commit, tip)) && (controlForRef(entry.getKey()).canPerform(Permission.READ))) { return true; } } } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get()); com.google.gerrit.server.project.ProjectControl.log.error(msg, e); } return controlForRef("refs/*").canPerform(Permission.READ); }
@java.lang.Override void onAllNodesReplicated(int totalPushTasksCount) { }

@java.lang.Override void onOneNodeReplicated(java.lang.String project, java.lang.String ref, org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status) { }
@java.lang.Override public void onGitReferenceUpdated(com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Event event) { com.googlesource.gerrit.plugins.replication.ReplicationState state = new com.googlesource.gerrit.plugins.replication.ReplicationState(ReplicationType.GIT_UPDATED); if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.wrappedLog.warn("Replication plugin did not finish startup before event", state); return; } com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { if ((cfg.wouldPushProject(project)) && (cfg.wouldPushRef(event.getRefName()))) { for (org.eclipse.jgit.transport.URIish uri : cfg.getURIs(project, null)) { cfg.schedule(project, event.getRefName(), uri, state); } } } state.markAllPushTasksScheduled(); }
private org.eclipse.jetty.util.thread.ThreadPool threadPool(org.eclipse.jgit.lib.Config cfg) { final org.eclipse.jetty.util.thread.QueuedThreadPool pool = new org.eclipse.jetty.util.thread.QueuedThreadPool(); pool.setName("HTTP"); pool.setMinThreads(cfg.getInt("httpd", null, "minthreads", 5)); pool.setMaxThreads(cfg.getInt("httpd", null, "maxthreads", 25)); pool.setMaxQueued(cfg.getInt("httpd", null, "maxqueued", 50)); return pool; }
@java.lang.Override protected void configureServlets() { serve("/say-hello/*").with(com.googlesource.gerrit.plugins.cookbook.HelloWorldServlet.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class).toInstance(new com.google.gerrit.extensions.webui.JavaScriptPlugin("hello-project.js")); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class).toInstance(new com.google.gerrit.extensions.webui.JavaScriptPlugin("hello-revision.js")); }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> conflicts(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if ((args.index) == (com.google.gerrit.server.index.ChangeIndex.DISABLED)) { throw error(((("secondary index must be enabled for " + (com.google.gerrit.server.query.change.ChangeQueryBuilder.FIELD_CONFLICTS)) + ":") + value)); } return new com.google.gerrit.server.query.change.ConflictsPredicate(args.dbProvider, args.patchListCache, value, parseChange(value)); }


public void setEnableSmallFileFeatures(final boolean on) { enableSmallFileFeatures = on; if (enableSmallFileFeatures) { syntaxHighlighting.setValue(getValue().isSyntaxHighlighting()); } else { syntaxHighlighting.setValue(false); } toggleEnabledStatus(save.isEnabled()); }
@java.lang.Override protected void updateCursor(final com.google.gerrit.reviewdb.client.PatchLineComment newComment) { if ((newComment.getLine()) == (R_HEAD)) { final com.google.gerrit.reviewdb.client.PatchSet.Id psId = newComment.getKey().getParentKey().getParentKey(); switch (newComment.getSide()) { case FILE_SIDE_A : if (((idSideA) == null) && (idSideB.equals(psId))) { (rowOfTableHeaderB)++; (borderRowOfFileComment)++; return; } break; case FILE_SIDE_B : if (((idSideA) != null) && (idSideA.equals(psId))) { (rowOfTableHeaderB)++; (borderRowOfFileComment)++; return; } if (idSideB.equals(psId)) { (borderRowOfFileComment)++; return; } } } }
@java.lang.Override public void remove(com.google.gerrit.client.patches.CommentEditorPanel panel) { super.remove(panel); if ((panel.getComment().getLine()) == (AbstractPatchContentTable.R_HEAD)) { final com.google.gerrit.reviewdb.client.PatchSet.Id psId = panel.getComment().getKey().getParentKey().getParentKey(); switch (panel.getComment().getSide()) { case FILE_SIDE_A : if (((idSideA) == null) && (idSideB.equals(psId))) { (rowOfTableHeaderB)--; (borderRowOfFileComment)--; return; } break; case FILE_SIDE_B : if (((idSideA) != null) && (idSideA.equals(psId))) { (rowOfTableHeaderB)--; (borderRowOfFileComment)--; return; } if (idSideB.equals(psId)) { (borderRowOfFileComment)--; return; } } } }
@java.lang.Override public void init(javax.servlet.FilterConfig filterConfig) throws javax.servlet.ServletException { showGitBlitBanner(); try { java.io.InputStream resin = getClass().getResourceAsStream(com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.GITBLIT_GERRIT_PROPERTIES); java.util.Properties properties = null; try { properties = new java.util.Properties(); properties.load(resin); properties.put("git.repositoriesFolder", repoManager.getBasePath().getAbsolutePath()); properties.put("realm.userService", com.googlesource.gerrit.plugins.gitblit.auth.GerritToGitBlitUserService.class.getName()); if ((properties.get("web.otherUrls")) != null) { properties.put("web.otherUrls", ((((((config.getGitHttpUrl()) + " ") + (config.getGitSshUrl())).trim()) + " ") + (properties.get("web.otherUrls")))); } else { properties.put("web.otherUrls", (((config.getGitHttpUrl()) + " ") + (config.getGitSshUrl())).trim()); } } finally { resin.close(); } com.gitblit.IStoredSettings settings = new com.googlesource.gerrit.plugins.gitblit.app.GitBlitSettings(properties); com.gitblit.GitBlit.self().configureContext(settings, repoManager.getBasePath(), false); com.gitblit.GitBlit.self().contextInitialized(new javax.servlet.ServletContextEvent(filterConfig.getServletContext())); super.init(new com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.CustomFilterConfig(filterConfig)); } catch (java.lang.Exception e) { throw new javax.servlet.ServletException(e); } }
@java.lang.Override public void onShowView() { super.onShowView(); related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight()); if (openReplyBox) { onReply(); } else { java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView(); if ((prior != null) && (prior.startsWith("/c/"))) { scrollToPath(prior.substring(3)); } } startPoller(); }





@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.server.project.CreateBranch.Input input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Branch \"" + (rsrc.getBranchInfo().ref)) + "\" already exists")); }

@java.lang.Override public void onGitReferenceUpdated(com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Event event) { com.googlesource.gerrit.plugins.replication.ReplicationState state = new com.googlesource.gerrit.plugins.replication.ReplicationState(ReplicationType.GIT_UPDATED); if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.wrappedLog.warn("Replication plugin did not finish startup before event", state); return; } com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); for (com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Update u : event.getUpdates()) { for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { if ((cfg.wouldPushProject(project)) && (cfg.wouldPushRef(u.getRefName()))) { for (org.eclipse.jgit.transport.URIish uri : cfg.getURIs(project, null)) { cfg.schedule(project, u.getRefName(), uri, state); } } } } state.markAllPushTasksScheduled(); }
@java.lang.Override public void start() { for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { cfg.start(workQueue); } running = true; }
@java.lang.Override public void stop() { running = false; int discarded = 0; for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { discarded += cfg.shutdown(); } if (discarded > 0) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.warn(java.lang.String.format("Cancelled %d replication events during shutdown", discarded)); } }
void scheduleFullSync(final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String urlMatch, com.googlesource.gerrit.plugins.replication.ReplicationState state) { if (!(running)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.wrappedLog.warn("Replication plugin did not finish startup before event", state); return; } for (com.googlesource.gerrit.plugins.replication.Destination cfg : configs) { if (cfg.wouldPushProject(project)) { for (org.eclipse.jgit.transport.URIish uri : cfg.getURIs(project, urlMatch)) { cfg.schedule(project, PushOne.ALL_REFS, uri, state); } } } }

@java.lang.Override public void onFailure(java.lang.Throwable err) { progress.setVisible(false); scroll.setVisible(false); com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText(err.getMessage()); }
void set(com.google.gerrit.client.changes.ChangeInfo info, final java.lang.String revision) { if (info.status().isClosed()) { setVisible(false); return; } project = info.project(); com.google.gerrit.client.changes.ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.change.RelatedChanges.RelatedInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.change.RelatedChanges.RelatedInfo result) { render(revision, result.changes()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { progress.setVisible(false); scroll.setVisible(false); com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText(err.getMessage()); } }); }
private static native final void init(java.lang.String o);
void setMaxHeight(int height) { scroll.setHeight((height + "px")); }
private static boolean onOpen(com.google.gwt.dom.client.NativeEvent e, int idx) { if (com.google.gerrit.client.change.RelatedChanges.link.handleAsClick(e.<com.google.gwt.user.client.Event>cast())) { com.google.gerrit.client.change.RelatedChanges.MyTable t = com.google.gerrit.client.change.RelatedChanges.getMyTable(e); if (t != null) { t.onOpenRow(idx); e.preventDefault(); return false; } } return true; }
void set(com.google.gerrit.client.changes.ChangeInfo info, final java.lang.String revision) { if (info.status().isClosed()) { setVisible(false); return; } project = info.project(); com.google.gerrit.client.changes.ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.change.RelatedChanges.RelatedInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.change.RelatedChanges.RelatedInfo result) { tabPanel.getTabBar().setTabText(0, Resources.M.relatedChanges(result.changes().length())); render(revision, result.changes()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { tabPanel.getTabBar().setTabText(0, Resources.M.relatedChanges("na")); progress.setVisible(false); scroll.setVisible(false); com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText(err.getMessage()); } }); }




@java.lang.Override public void onFailure(java.lang.Throwable err) { tabPanel.getTabBar().setTabText(0, Resources.M.relatedChanges("na")); progress.setVisible(false); scroll.setVisible(false); com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText(err.getMessage()); }


void set(final com.google.gerrit.client.changes.ChangeInfo info, final java.lang.String revision) { if (info.status().isClosed()) { setVisible(false); return; } createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip()); tabPanel.selectTab(com.google.gerrit.client.change.RelatedChanges.RELATED_CHANGES); com.google.gerrit.client.changes.ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.change.RelatedChanges.RelatedInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.change.RelatedChanges.RelatedInfo result) { com.google.gerrit.client.change.RelatedChangesTab tab = tabs.get(com.google.gerrit.client.change.RelatedChanges.RELATED_CHANGES); tab.setTitle(Resources.M.relatedChanges(result.changes().length())); tab.setChanges(info.project(), revision, result.changes()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.RelatedChangesTab tab = tabs.get(com.google.gerrit.client.change.RelatedChanges.RELATED_CHANGES); tab.setTitle(Resources.M.relatedChanges("na")); tab.setError(err.getMessage()); } }); java.lang.StringBuilder conflictsQuery = new java.lang.StringBuilder(); conflictsQuery.append("status:open"); conflictsQuery.append(" project:").append(info.project()); conflictsQuery.append(" branch:").append(info.branch()); conflictsQuery.append(" conflicts:").append(info.change_id()); com.google.gerrit.client.changes.ChangeList.query(conflictsQuery.toString(), java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if ((result.length()) > 0) { getTab().setTitle(Resources.M.conflictingChanges(result.length())); getTab().setChanges(info.project(), revision, convertChangeList(result)); } } @java.lang.Override public void onFailure(java.lang.Throwable err) { getTab().setTitle(Resources.M.conflictingChanges("na")); getTab().setError(err.getMessage()); } private com.google.gerrit.client.change.RelatedChangesTab getTab() { if ((conflictingChangesTab) == null) { conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip()); conflictingChangesTab.registerKeys(); } return conflictingChangesTab; } }); }
private com.google.gerrit.client.change.RelatedChangesTab createTab(java.lang.String title, java.lang.String tooltip) { com.google.gwt.user.client.ui.VerticalPanel panel = new com.google.gwt.user.client.ui.VerticalPanel(); tabPanel.add(panel, title); com.google.gwt.user.client.ui.TabBar tabBar = tabPanel.getTabBar(); int index = (tabBar.getTabCount()) - 1; com.google.gwt.user.client.ui.TabBar.Tab tab = tabBar.getTab(index); tab.setWordWrap(false); ((com.google.gwt.user.client.ui.Composite) (tab)).setTitle(tooltip); com.google.gerrit.client.change.RelatedChangesTab relatedChangesTab = new com.google.gerrit.client.change.RelatedChangesTab(this, index, panel); tabs.add(relatedChangesTab); relatedChangesTab.setMaxHeight(maxHeight); return relatedChangesTab; }

private com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit> convertChangeList(com.google.gerrit.client.changes.ChangeList l) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit> arr = com.google.gwt.core.client.JavaScriptObject.createArray().cast(); for (com.google.gerrit.client.changes.ChangeInfo i : com.google.gerrit.client.rpc.Natives.asList(l)) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo currentRevision = i.revision(i.current_revision()); com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit c = com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit.create(); c.set_id(i.id()); c.set_commit(currentRevision.commit()); c.set_change_number(i._number()); c.set_revision_number(currentRevision._number()); arr.push(c); } return arr; }
@java.lang.Override public void onFailure(java.lang.Throwable err) { getTab().setTitle(Resources.M.conflictingChanges("na")); getTab().setError(err.getMessage()); }





@org.junit.Test public void submit() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.RevisionApi rApi = gApi.changes().id(("p~master~" + (r.getChangeId()))).current(); rApi.review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); rApi.submit(); }
void review(com.google.gerrit.extensions.api.changes.ReviewInput in) throws com.google.gerrit.extensions.restapi.RestApiException;

@java.lang.Override public void review(com.google.gerrit.extensions.api.changes.ReviewInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { review.get().apply(revision, in); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot post review", e); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot post review", e); } }
void resizeCodeMirror() { int rest = (((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + (header.getOffsetHeight())) + (diffTable.getHeaderHeight())) + 5; int h = (com.google.gwt.user.client.Window.getClientHeight()) - rest; cmA.setHeight(h); cmB.setHeight(h); cmA.refresh(); cmB.refresh(); diffTable.sidePanel.adjustGutters(cmB); }
@java.lang.Override public void onShowView() { super.onShowView(); resizeCodeMirror(); com.google.gwt.user.client.Window.enableScrolling(false); cmA.setOption("viewportMargin", 10); cmB.setOption("viewportMargin", 10); cmB.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmB.focus(); prefetchNextFile(); }
private void loadConfigInfo(final com.google.gerrit.client.changes.ChangeInfo info) { info.revisions().copyKeysIntoChildren("name"); final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = resolveRevisionToDisplay(info); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadDiff(rev, com.google.gerrit.client.change.ChangeScreen2.myLastReply(info), group); loadCommit(rev, group); com.google.gerrit.client.changes.RevisionInfoCache.add(changeId, rev); com.google.gerrit.client.projects.ConfigInfoCache.add(info); com.google.gerrit.client.projects.ConfigInfoCache.get(info.project_name_key(), group.add(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentLinkProcessor = result.getCommentLinkProcessor(); setTheme(result.getTheme()); renderChangeInfo(info); } })); group.done(); }

@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentLinkProcessor = result.getCommentLinkProcessor(); setTheme(result.getTheme()); renderChangeInfo(info); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { info.init(); loadConfigInfo(info); }

@java.lang.Override protected void onLoad() { super.onLoad(); loadChangeInfo(true, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { info.init(); loadConfigInfo(info); } }); }
private void render(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, int row, com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit info) { sb.openTr(); sb.openTd().setStyleName(FileTable.R.css().pointer()).closeTd(); sb.openTd().addStyleName(Gerrit.RESOURCES.css().relatedChangesSubject()); java.lang.String url = url(info); if (url != null) { sb.openAnchor().setAttribute("href", url); if (url.startsWith("#")) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.RelatedChangesTab.OPEN) + "(event,") + row) + ")")); } sb.append(((info.commit().subject()) + (showBranches ? (" (" + (info.branch())) + ")" : ""))); sb.closeAnchor(); } else { sb.append(info.commit().subject()); } sb.closeTd(); sb.closeTr(); }

void setOpen(boolean open) { com.google.gwt.user.client.ui.UIObject.setVisible(summary, (!open)); com.google.gwt.user.client.ui.UIObject.setVisible(message, open); if (open) { removeStyleName(style.closed()); } else { addStyleName(style.closed()); } }
private void renderHistory(com.google.gerrit.client.changes.ChangeInfo info) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.MessageInfo> messages = info.messages(); if (messages != null) { for (int i = 0; i < (messages.length()); i++) { history.add(new com.google.gerrit.client.change.Message(commentLinkProcessor, messages.get(i))); } } }
void onReply() { if ((popup) != null) { popup.hide(); return; } if ((replyBox) == null) { replyBox = new com.google.gerrit.client.change.ReplyBox(psId, revision, allLabels, permittedLabels); allLabels = null; permittedLabels = null; } final com.google.gwtexpui.user.client.PluginSafePopupPanel p = new com.google.gwtexpui.user.client.PluginSafePopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(replyButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(replyBox); p.showRelativeTo(replyButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); popup = p; }
@java.lang.Override public void execute() { message.setFocus(true); }

@java.lang.Override protected void onLoad() { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); }
void load(final int revisionNumber) { if ((revisionNumber > 0) && (loaded.add(revisionNumber))) { com.google.gerrit.client.changes.ChangeApi.revision(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, revisionNumber)).view("comments").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { addComments(revisionNumber, result); update(revisionNumber); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
void set(com.google.gerrit.client.ui.CommentLinkProcessor clp, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gerrit.client.changes.ChangeInfo info) { this.clp = clp; this.changeId = id; com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.MessageInfo> messages = info.messages(); if (messages != null) { for (com.google.gerrit.client.changes.ChangeInfo.MessageInfo msg : com.google.gerrit.client.rpc.Natives.asList(messages)) { com.google.gerrit.client.change.Message ui = new com.google.gerrit.client.change.Message(this, msg); if (loaded.contains(msg._revisionNumber())) { ui.addComments(comments(msg)); } add(ui); } } }





private com.google.gerrit.client.changes.ChangeInfo.RevisionInfo resolveRevisionToDisplay(com.google.gerrit.client.changes.ChangeInfo info) { if ((revision) == null) { revision = info.current_revision(); } else if (!(info.revisions().containsKey(revision))) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); for (int i = 0; i < (list.length()); i++) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r = list.get(i); if (revision.equals(java.lang.String.valueOf(r._number()))) { revision = r.name(); break; } } } return info.revision(revision); }



public com.google.gerrit.reviewdb.client.Change insert() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.ChangeUtil.insertAncestors(db, patchSet.getId(), commit); db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); com.google.gerrit.server.ChangeUtil.updateTrackingIds(db, change, trackingFooters, commit.getFooterLines()); com.google.gerrit.common.data.LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); db.commit(); } finally { db.rollback(); } if ((changeMessage) != null) { db.changeMessages().insert(java.util.Collections.singleton(changeMessage)); } com.google.common.util.concurrent.CheckedFuture<?, java.io.IOException> indexFuture = indexer.indexAsync(change); gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), org.eclipse.jgit.lib.ObjectId.zeroId(), commit); if (runHooks) { hooks.doPatchsetCreatedHook(change, patchSet, db); } if (sendMail) { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change); cm.setFrom(change.getOwner()); cm.setPatchSet(patchSet, patchSetInfo); cm.addReviewers(reviewers); cm.addExtraCC(extraCC); cm.send(); } catch (java.lang.Exception err) { com.google.gerrit.server.change.ChangeInserter.log.error(("Cannot send email for new change " + (change.getId())), err); } } indexFuture.checkedGet(); return change; }






public boolean canReadCommit(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey projName = state.getProject().getNameKey(); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projName); try { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> allRefs = repo.getRefDatabase().getRefs(com.google.gerrit.server.project.ALL); for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : allRefs.entrySet()) { java.lang.String refName = entry.getKey(); if ((!(refName.startsWith("refs/heads"))) && (!(refName.startsWith("refs/tags")))) { continue; } org.eclipse.jgit.revwalk.RevCommit tip; try { tip = rw.parseCommit(entry.getValue().getObjectId()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { continue; } if ((controlForRef(entry.getKey()).canPerform(Permission.READ)) && (rw.isMergedInto(commit, tip))) { return true; } } } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get()); com.google.gerrit.server.project.ProjectControl.log.error(msg, e); } return controlForRef("refs/*").canPerform(Permission.READ); }
public static com.google.gerrit.common.data.IncludedInDetail resolve(final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.revwalk.RevCommit commit) throws java.io.IOException { java.util.Set<org.eclipse.jgit.lib.Ref> tags = new java.util.HashSet<org.eclipse.jgit.lib.Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values()); java.util.Set<org.eclipse.jgit.lib.Ref> branches = new java.util.HashSet<org.eclipse.jgit.lib.Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values()); java.util.Set<org.eclipse.jgit.lib.Ref> allTagsAndBranches = new java.util.HashSet<org.eclipse.jgit.lib.Ref>(); allTagsAndBranches.addAll(tags); allTagsAndBranches.addAll(branches); java.util.Set<org.eclipse.jgit.lib.Ref> allMatchingTagsAndBranches = com.google.gerrit.server.change.IncludedInResolver.includedIn(repo, rw, commit, allTagsAndBranches); com.google.gerrit.common.data.IncludedInDetail detail = new com.google.gerrit.common.data.IncludedInDetail(); detail.setBranches(com.google.gerrit.server.change.IncludedInResolver.getMatchingRefNames(allMatchingTagsAndBranches, branches)); detail.setTags(com.google.gerrit.server.change.IncludedInResolver.getMatchingRefNames(allMatchingTagsAndBranches, tags)); return detail; }

private void loadConfigInfo(final com.google.gerrit.client.changes.ChangeInfo info, final java.lang.String base) { info.revisions().copyKeysIntoChildren("name"); final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = resolveRevisionToDisplay(info); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadDiff(info.revisions().get(base), rev, com.google.gerrit.client.change.ChangeScreen2.myLastReply(info), group); loadCommit(rev, group); if (loaded) { group.done(); return; } com.google.gerrit.client.changes.RevisionInfoCache.add(changeId, rev); com.google.gerrit.client.projects.ConfigInfoCache.add(info); com.google.gerrit.client.projects.ConfigInfoCache.get(info.project_name_key(), group.addFinal(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { loaded = true; commentLinkProcessor = result.getCommentLinkProcessor(); setTheme(result.getTheme()); renderChangeInfo(info); } })); }
private void renderDiffBaseListBox(com.google.gerrit.client.changes.ChangeInfo info) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(list); for (int i = (list.length()) - 1; i >= 0; i--) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r = list.get(i); diffBase.addItem((((r._number()) + ": ") + (r.name().substring(0, 6))), r.name()); if (r.name().equals(revision)) { com.google.gwt.dom.client.SelectElement.as(diffBase.getElement()).getOptions().getItem(((diffBase.getItemCount()) - 1)).setDisabled(true); } } com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revisions().get(revision); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.CommitInfo> parents = rev.commit().parents(); diffBase.addItem(((parents.length()) > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem()), ""); diffBase.setSelectedIndex(((diffBase.getItemCount()) - 1)); }

private void loadMergeable(final com.google.gerrit.reviewdb.client.Change.Status status, final boolean canSubmit) { if (com.google.gerrit.client.Gerrit.getConfig().testChangeMerge()) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo.MergeableInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo.MergeableInfo result) { if (canSubmit) { actions.setSubmitEnabled(result.mergeable()); if (status == (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { statusText.setInnerText((result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict())); } } setVisible(notMergeable, (!(result.mergeable()))); renderSubmitType(result.submit_type()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { loadSubmitType(status, canSubmit); } }); } else { loadSubmitType(status, canSubmit); } }


@com.google.gwt.uibinder.client.UiHandler("save") void onSave(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); onSave(); }
private java.lang.Runnable upToChange(final boolean openReplyBox) { return new java.lang.Runnable() { public void run() { java.lang.String b = ((base) != null) ? java.lang.String.valueOf(base.get()) : null; java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, b, rev, openReplyBox)); } }; }
@com.google.gwt.uibinder.client.UiHandler("editArea") void onKeyDown(com.google.gwt.event.dom.client.KeyDownEvent e) { if ((((e.isControlKeyDown()) || (e.isMetaKeyDown())) && (!(e.isAltKeyDown()))) && (!(e.isShiftKeyDown()))) { switch (e.getNativeKeyCode()) { case 's' : case 'S' : e.preventDefault(); onSave(); return; } } else if (((e.getNativeKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE)) && (!(isDirty()))) { if (isNew()) { removeUI(); return; } else { setEdit(false); if (autoClosed) { setOpen(false); } getCm().focus(); return; } } expandTimer.schedule(250); }

private void onSave() { java.lang.String message = editArea.getValue().trim(); if ((message.length()) == 0) { return; } com.google.gerrit.client.changes.CommentInfo original = comment; com.google.gerrit.client.changes.CommentInput input = com.google.gerrit.client.changes.CommentInput.create(original); input.setMessage(message); enableEdit(false); com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo> cb = new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { enableEdit(true); set(result); setEdit(false); if (autoClosed) { setOpen(false); } } @java.lang.Override public void onFailure(java.lang.Throwable e) { enableEdit(true); super.onFailure(e); } }; if ((original.id()) == null) { com.google.gerrit.client.changes.CommentApi.createDraft(psId, input, cb); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(psId, original.id(), input, cb); } getCm().focus(); }
public void run() { java.lang.String b = ((base) != null) ? java.lang.String.valueOf(base.get()) : null; java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, b, rev, openReplyBox)); }

@java.lang.Override protected void onUnload() { super.onUnload(); removeKeyHandlerRegs(); if ((resizeHandler) != null) { resizeHandler.removeHandler(); resizeHandler = null; } if ((cmA) != null) { cmA.getWrapperElement().removeFromParent(); } if ((cmB) != null) { cmB.getWrapperElement().removeFromParent(); } com.google.gwt.user.client.Window.enableScrolling(true); com.google.gerrit.client.Gerrit.setHeaderVisible(true); }
@java.lang.SuppressWarnings({ "rawtypes", "unchecked" }) private static <K, V> com.google.common.cache.CacheBuilder<K, V> newCacheBuilder() { return ((com.google.common.cache.CacheBuilder<K, V>) (com.google.common.cache.CacheBuilder.newBuilder())); }

@java.lang.Override public com.google.gerrit.server.change.ChangeJson.ChangeInfo apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.EditMessage.Input input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (com.google.common.base.Strings.isNullOrEmpty(input.message)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("message must be non-empty"); } final org.eclipse.jgit.lib.Repository git; try { git = gitManager.openRepository(rsrc.getChange().getProject()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } try { return json.format(com.google.gerrit.server.ChangeUtil.editCommitMessage(rsrc.getPatchSet().getId(), rsrc.getControl().getRefControl(), ((com.google.gerrit.server.IdentifiedUser) (rsrc.getControl().getCurrentUser())), input.message, dbProvider.get(), commitMessageEditedSenderFactory, git, myIdent, patchSetInserterFactory)); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } catch (org.eclipse.jgit.errors.MissingObjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } finally { git.close(); } }
public void run() throws java.lang.Exception { ui.header("SSH Daemon"); java.lang.String hostname = "*"; int port = 29418; java.lang.String listenAddress = sshd.get("listenAddress"); if (com.google.gerrit.pgm.init.InitSshd.isOff(listenAddress)) { hostname = "off"; } else if ((listenAddress != null) && (!(listenAddress.isEmpty()))) { final java.net.InetSocketAddress addr = com.google.gerrit.server.util.SocketUtil.parse(listenAddress, port); hostname = com.google.gerrit.server.util.SocketUtil.hostname(addr); port = addr.getPort(); } hostname = ui.readString(hostname, "Listen on address"); if (com.google.gerrit.pgm.init.InitSshd.isOff(hostname)) { sshd.set("listenAddress", "off"); return; } port = ui.readInt(port, "Listen on port"); sshd.set("listenAddress", com.google.gerrit.server.util.SocketUtil.format(hostname, port)); if ((site.ssh_rsa.exists()) || (site.ssh_dsa.exists())) { libraries.bouncyCastle.downloadRequired(); } else if (!(site.ssh_key.exists())) { libraries.bouncyCastle.downloadOptional(); } generateSshHostKeys(); }
@org.junit.Test public void systemGroupsCreated_ssh() throws com.jcraft.jsch.JSchException, java.io.IOException { com.google.gerrit.acceptance.SshSession session = new com.google.gerrit.acceptance.SshSession(server, admin); java.lang.String result = session.exec("gerrit ls-groups"); assertTrue(result.contains("Administrators")); assertTrue(result.contains("Anonymous Users")); assertTrue(result.contains("Non-Interactive Users")); assertTrue(result.contains("Project Owners")); assertTrue(result.contains("Registered Users")); session.close(); }
@org.junit.Test public void systemGroupsCreated_rest() throws java.io.IOException { com.google.gerrit.acceptance.RestSession session = new com.google.gerrit.acceptance.RestSession(server, admin); com.google.gerrit.acceptance.RestResponse r = session.get("/groups/"); com.google.gson.Gson gson = new com.google.gson.Gson(); java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo> result = gson.fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); java.util.Set<java.lang.String> names = result.keySet(); assertTrue(names.contains("Administrators")); assertTrue(names.contains("Anonymous Users")); assertTrue(names.contains("Non-Interactive Users")); assertTrue(names.contains("Project Owners")); assertTrue(names.contains("Registered Users")); }
@org.junit.Test public void systemGroupsCreated_internals() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = reviewDbProvider.open(); try { java.util.Set<java.lang.String> names = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.AccountGroup g : db.accountGroups().all()) { names.add(g.getName()); } assertTrue(names.contains("Administrators")); assertTrue(names.contains("Anonymous Users")); assertTrue(names.contains("Non-Interactive Users")); assertTrue(names.contains("Project Owners")); assertTrue(names.contains("Registered Users")); } finally { db.close(); } }
private void assignGroupUUIDs(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { groupMap = new java.util.HashMap<com.google.gerrit.reviewdb.client.AccountGroup.Id, com.google.gerrit.common.data.GroupReference>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> groups = db.accountGroups().all().toList(); for (com.google.gerrit.reviewdb.client.AccountGroup g : groups) { if (g.getId().equals(systemConfig.ownerGroupId)) { g.setGroupUUID(AccountGroup.PROJECT_OWNERS); projectOwners = com.google.gerrit.common.data.GroupReference.forGroup(g); } else if (g.getId().equals(systemConfig.anonymousGroupId)) { g.setGroupUUID(AccountGroup.ANONYMOUS_USERS); } else if (g.getId().equals(systemConfig.registeredGroupId)) { g.setGroupUUID(AccountGroup.REGISTERED_USERS); } else { g.setGroupUUID(com.google.gerrit.server.account.GroupUUID.make(g.getName(), serverUser)); } groupMap.put(g.getId(), com.google.gerrit.common.data.GroupReference.forGroup(g)); } db.accountGroups().update(groups); systemConfig.adminGroupUUID = toUUID(systemConfig.adminGroupId); systemConfig.batchUsersGroupUUID = toUUID(systemConfig.batchUsersGroupId); db.systemConfig().update(java.util.Collections.singleton(systemConfig)); }
public com.google.gerrit.common.data.PermissionRange getRange(java.lang.String permission) { return getRefControl().getRange(permission); }




@java.lang.Override public void onShowView() { super.onShowView(); commit.onShowView(); related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight()); if (openReplyBox) { onReply(); } else { java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView(); if ((prior != null) && (prior.startsWith("/c/"))) { scrollToPath(prior.substring(3)); } } startPoller(); }



public boolean isVisibleByRegisteredUsers() { java.util.List<com.google.gerrit.common.data.PermissionRule> access = relevant.getPermission(Permission.READ); java.util.Set<com.google.gerrit.server.project.ProjectRef> allows = com.google.common.collect.Sets.newHashSet(); java.util.Set<com.google.gerrit.server.project.ProjectRef> blocks = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.common.data.PermissionRule rule : access) { if (rule.isBlock()) { blocks.add(relevant.getRuleProps(rule)); } else if ((rule.getGroup().getUUID().equals(AccountGroup.ANONYMOUS_USERS)) || (rule.getGroup().getUUID().equals(AccountGroup.REGISTERED_USERS))) { allows.add(relevant.getRuleProps(rule)); } } blocks.removeAll(allows); return (blocks.isEmpty()) && (!(allows.isEmpty())); }
private void blockRead(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project); md.setMessage(("Grant submit on " + ref)); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection s = config.getAccessSection(ref, true); com.google.gerrit.common.data.Permission p = s.getPermission(Permission.READ, true); com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(AccountGroup.REGISTERED_USERS); com.google.gerrit.common.data.PermissionRule rule = new com.google.gerrit.common.data.PermissionRule(config.resolve(adminGroup)); rule.setBlock(); p.add(rule); config.commit(md); projectCache.evict(config.getProject()); }


private void displayComments(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> m) { comments.clear(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> l = m.get(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.COMMIT_MSG, l))); } java.util.List<java.lang.String> paths = new java.util.ArrayList<java.lang.String>(m.keySet()); java.util.Collections.sort(paths); for (java.lang.String path : paths) { if (!(path.equals(Patch.COMMIT_MSG))) { comments.add(new com.google.gerrit.client.change.FileComments(clp, psId, path, com.google.gerrit.client.change.ReplyBox.copyPath(path, m.get(path)))); } } commentsPanel.setVisible(((comments.getWidgetCount()) > 0)); }

private com.google.gerrit.client.change.RelatedChangesTab createTab(java.lang.String title, java.lang.String tooltip) { return createTab(title, tooltip, null); }
void setTitle(java.lang.String title) { parent.setTabTitle(index, title); }
void set(com.google.gerrit.client.account.DiffPreferences prefs) { this.prefs = prefs; setIgnoreWhitespace(prefs.ignoreWhitespace()); tabWidth.setIntValue(prefs.tabSize()); syntaxHighlighting.setValue(prefs.syntaxHighlighting()); whitespaceErrors.setValue(prefs.showWhitespaceErrors()); showTabs.setValue(prefs.showTabs()); topMenu.setValue((!(prefs.hideTopMenu()))); expandAllComments.setValue(prefs.expandAllComments()); switch (view.getIntraLineStatus()) { case OFF : case OK : intralineDifference.setValue(prefs.intralineDifference()); break; case TIMEOUT : case FAILURE : intralineDifference.setValue(false); intralineDifference.setEnabled(false); break; } if ((prefs.context()) == (WHOLE_FILE_CONTEXT)) { context.setText(""); } else { context.setIntValue(prefs.context()); } }
@com.google.gwt.uibinder.client.UiHandler("context") void onContext(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.String> e) { java.lang.String v = e.getValue(); int c; if ((v != null) && ((v.length()) > 0)) { c = java.lang.Math.min(java.lang.Math.max(0, java.lang.Integer.parseInt(v)), 32767); } else if ((v == null) || (v.isEmpty())) { c = WHOLE_FILE_CONTEXT; } else { return; } prefs.context(c); view.setContext(prefs.context()); }

@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } final int height = getCodeMirrorHeight(); operation(new java.lang.Runnable() { @java.lang.Override public void run() { cmA.setHeight(height); cmB.setHeight(height); cmA.refresh(); cmB.refresh(); cmB.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmB.focus(); } }); diffTable.sidePanel.adjustGutters(cmB); prefetchNextFile(); }
@java.lang.Override protected void configureServlets() { install(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(RebaseChangeHandler.Factory.class); factory(ChangeDetailFactory.Factory.class); factory(IncludedInDetailFactory.Factory.class); factory(PatchSetDetailFactory.Factory.class); factory(PatchSetPublishDetailFactory.Factory.class); } }); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeDetailServiceImpl.class); rpc(com.google.gerrit.httpd.rpc.changedetail.ChangeManageServiceImpl.class); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); Util.MANAGE_SVC.publish(patchSet.getId(), new com.google.gerrit.client.changes.ChangeDetailCache.GerritWidgetCallback(b)); }
private void populatePublishAction() { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button(Util.C.buttonPublishPatchSet()); b.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { b.setEnabled(false); Util.MANAGE_SVC.publish(patchSet.getId(), new com.google.gerrit.client.changes.ChangeDetailCache.GerritWidgetCallback(b)); } }); actionsPanel.add(b); }
@java.lang.Override public java.lang.Boolean call() throws java.lang.Exception { mergeabilityCheckQueue.updatingMergeabilityFlag(change); com.google.gerrit.server.util.RequestContext context = new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser() { return identifiedUserFactory.create(change.getOwner()); } @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return new com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb>() { @java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb get() { if ((reviewDb) == null) { try { reviewDb = schemaFactory.open(); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.inject.ProvisionException("Cannot open ReviewDb", e); } } return reviewDb; } }; } }; com.google.gerrit.server.util.RequestContext old = tl.setContext(context); com.google.gerrit.reviewdb.server.ReviewDb db = context.getReviewDbProvider().get(); try { com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().get(change.currentPatchSetId()); com.google.gerrit.server.change.Mergeable.MergeableInfo info = mergeable.get().apply(new com.google.gerrit.server.change.RevisionResource(new com.google.gerrit.server.change.ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps)); return (change.isMergeable()) != (info.mergeable); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return false; } finally { tl.setContext(old); if ((reviewDb) != null) { reviewDb.close(); reviewDb = null; } } }


private com.google.gerrit.server.plugins.Plugin loadPlugin(java.lang.String name, java.io.File srcJar, org.eclipse.jgit.storage.file.FileSnapshot snapshot) throws com.google.gerrit.server.plugins.InvalidPluginException, java.io.IOException, java.lang.ClassNotFoundException { java.io.File tmp; java.io.FileInputStream in = new java.io.FileInputStream(srcJar); try { tmp = com.google.gerrit.server.plugins.PluginLoader.asTemp(in, com.google.gerrit.server.plugins.PluginLoader.tempNameFor(name), ".jar", tmpDir); } finally { in.close(); } java.util.jar.JarFile jarFile = new java.util.jar.JarFile(tmp); boolean keep = false; try { java.util.jar.Manifest manifest = jarFile.getManifest(); com.google.gerrit.server.plugins.Plugin.ApiType type = com.google.gerrit.server.plugins.Plugin.getApiType(manifest); java.util.jar.Attributes main = manifest.getMainAttributes(); java.lang.String sysName = main.getValue("Gerrit-Module"); java.lang.String sshName = main.getValue("Gerrit-SshModule"); java.lang.String httpName = main.getValue("Gerrit-HttpModule"); if ((!(com.google.common.base.Strings.isNullOrEmpty(sshName))) && (type != (Plugin.ApiType.PLUGIN))) { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN)); } java.net.URL[] urls = new java.net.URL[]{ tmp.toURI().toURL() }; java.lang.ClassLoader parentLoader = com.google.gerrit.server.plugins.PluginLoader.parentFor(type); java.lang.ClassLoader pluginLoader = new java.net.URLClassLoader(urls, parentLoader); cleanupHandles.put(new com.google.gerrit.server.plugins.CleanupHandle(tmp, jarFile, pluginLoader, cleanupQueue), java.lang.Boolean.TRUE); java.lang.Class<? extends java.lang.Module> sysModule = load(sysName, pluginLoader); java.lang.Class<? extends java.lang.Module> sshModule = load(sshName, pluginLoader); java.lang.Class<? extends java.lang.Module> httpModule = load(httpName, pluginLoader); keep = true; return new com.google.gerrit.server.plugins.JarPlugin(name, srcJar, snapshot, jarFile, manifest, new java.io.File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule); } finally { if (!keep) { jarFile.close(); } } }

public void enablePlugins(java.util.Set<java.lang.String> names) throws com.google.gerrit.server.plugins.PluginInstallException { synchronized(this) { for (java.lang.String name : names) { com.google.gerrit.server.plugins.Plugin off = disabled.get(name); if (off == null) { continue; } com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Enabling plugin %s", name)); java.io.File on = new java.io.File(pluginsDir, ((off.getName()) + ".jar")); off.getSrcJar().renameTo(on); disabled.remove(name); runPlugin(name, on, null); } cleanInBackground(); } }

java.io.File getSrcJar() { return srcFile; }

public synchronized void rescan() { java.util.List<java.io.File> jars = scanJarsInPluginsDirectory(); stopRemovedPlugins(jars); dropRemovedDisabledPlugins(jars); for (java.io.File jar : jars) { java.lang.String name = com.google.gerrit.server.plugins.PluginLoader.nameOf(jar); org.eclipse.jgit.storage.file.FileSnapshot brokenTime = broken.get(name); if ((brokenTime != null) && (!(brokenTime.isModified(jar)))) { continue; } com.google.gerrit.server.plugins.Plugin active = running.get(name); if ((active != null) && (!(active.isModified(jar)))) { continue; } if (active != null) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Reloading plugin %s", name)); } try { com.google.gerrit.server.plugins.Plugin loadedPlugin = runPlugin(name, jar, active); if ((active == null) && (!(loadedPlugin.isDisabled()))) { com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Loaded plugin %s", name)); } } catch (com.google.gerrit.server.plugins.PluginInstallException e) { com.google.gerrit.server.plugins.PluginLoader.log.warn(java.lang.String.format("Cannot load plugin %s", name), e.getCause()); } } cleanInBackground(); }
private com.google.gerrit.server.plugins.Plugin runPlugin(java.lang.String name, java.io.File jar, com.google.gerrit.server.plugins.Plugin oldPlugin) throws com.google.gerrit.server.plugins.PluginInstallException { org.eclipse.jgit.storage.file.FileSnapshot snapshot = org.eclipse.jgit.storage.file.FileSnapshot.save(jar); try { com.google.gerrit.server.plugins.Plugin newPlugin = loadPlugin(name, jar, snapshot); boolean reload = ((oldPlugin != null) && (oldPlugin.canReload())) && (newPlugin.canReload()); if ((!reload) && (oldPlugin != null)) { oldPlugin.stop(); running.remove(name); } if (!(newPlugin.isDisabled())) { newPlugin.start(env); } if (reload) { env.onReloadPlugin(oldPlugin, newPlugin); oldPlugin.stop(); } else if (!(newPlugin.isDisabled())) { env.onStartPlugin(newPlugin); } if (!(newPlugin.isDisabled())) { running.put(name, newPlugin); } else { disabled.put(name, newPlugin); } broken.remove(name); return newPlugin; } catch (java.lang.Throwable err) { broken.put(name, snapshot); throw new com.google.gerrit.server.plugins.PluginInstallException(err); } }


@java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((n.endsWith(".jar")) || (n.endsWith(".jar.disabled"))) && (pathname.isFile()); }
public void disablePlugins(java.util.Set<java.lang.String> names) { synchronized(this) { for (java.lang.String name : names) { com.google.gerrit.server.plugins.Plugin active = running.get(name); if (active == null) { continue; } com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Disabling plugin %s", name)); java.io.File off = new java.io.File(pluginsDir, ((active.getName()) + ".jar.disabled")); active.getSrcJar().renameTo(off); active.stop(); running.remove(name); try { org.eclipse.jgit.storage.file.FileSnapshot snapshot = org.eclipse.jgit.storage.file.FileSnapshot.save(off); com.google.gerrit.server.plugins.Plugin offPlugin = loadPlugin(name, off, snapshot); disabled.put(name, offPlugin); } catch (java.lang.Throwable e) { com.google.gerrit.server.plugins.PluginLoader.log.warn(java.lang.String.format("Cannot load disabled plugin %s", name), e.getCause()); } } cleanInBackground(); } }
private void sendResource(java.util.jar.JarFile jar, java.util.jar.JarEntry entry, com.google.gerrit.httpd.plugins.ResourceKey key, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { byte[] data = null; if ((entry.getSize()) <= (com.google.gerrit.httpd.plugins.HttpPluginServlet.SMALL_RESOURCE)) { data = com.google.gerrit.httpd.plugins.HttpPluginServlet.readWholeEntry(jar, entry); } java.lang.String contentType = null; java.lang.String charEnc = null; java.util.jar.Attributes atts = entry.getAttributes(); if (atts != null) { contentType = com.google.common.base.Strings.emptyToNull(atts.getValue("Content-Type")); charEnc = com.google.common.base.Strings.emptyToNull(atts.getValue("Character-Encoding")); } if (contentType == null) { contentType = mimeUtil.getMimeType(entry.getName(), data).toString(); if (("application/octet-stream".equals(contentType)) && (entry.getName().endsWith(".js"))) { contentType = "application/javascript"; } } long time = entry.getTime(); if (0 < time) { res.setDateHeader("Last-Modified", time); } res.setHeader("Content-Length", java.lang.Long.toString(entry.getSize())); res.setContentType(contentType); if (charEnc != null) { res.setCharacterEncoding(charEnc); } if (data != null) { resourceCache.put(key, new com.google.gerrit.httpd.plugins.SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time)); res.getOutputStream().write(data); } else { java.io.InputStream in = jar.getInputStream(entry); try { java.io.OutputStream out = res.getOutputStream(); try { byte[] tmp = new byte[1024]; int n; while ((n = in.read(tmp)) > 0) { out.write(tmp, 0, n); } } finally { out.close(); } } finally { in.close(); } } }




private java.util.List<java.io.File> scanJarsInPluginsDirectory() { if (((pluginsDir) == null) || (!(pluginsDir.exists()))) { return java.util.Collections.emptyList(); } java.io.File[] matches = pluginsDir.listFiles(new java.io.FileFilter() { @java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((n.endsWith(".jar")) || (n.endsWith(".jar.disabled"))) && (pathname.isFile()); } }); if (matches == null) { com.google.gerrit.server.plugins.PluginLoader.log.error(("Cannot list " + (pluginsDir.getAbsolutePath()))); return java.util.Collections.emptyList(); } return java.util.Arrays.asList(matches); }



private java.lang.String format(final com.google.gerrit.server.git.WorkQueue.Task<?> task) { java.lang.String s = task.toString(); if ((s.length()) < (taskNameWidth)) { return s; } else { return s.substring(0, taskNameWidth); } }













void populate(final int row, final com.google.gerrit.client.plugins.PluginInfo plugin) { if (plugin.isDisabled()) { table.setText(row, 1, plugin.name()); } else { table.setWidget(row, 1, new com.google.gwt.user.client.ui.Anchor(plugin.name(), com.google.gerrit.client.Gerrit.selfRedirect((("/plugins/" + (plugin.name())) + "/")), "_blank")); } table.setText(row, 2, plugin.version()); table.setText(row, 3, (plugin.isDisabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled())); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); setRowItem(row, plugin); }

private com.googlesource.gerrit.plugins.hooks.validation.ItsAssociationPolicy getItsAssociationPolicy() { return gerritConfig.getEnum("commentLink", itsName, "association", ItsAssociationPolicy.OPTIONAL); }

void setMaxHeight(int height) { maxHeight = height - ((getTabBar().getOffsetHeight()) + 2); for (int i = 0; i < (getTabBar().getTabCount()); i++) { tabs.get(i).setMaxHeight(maxHeight); } }

private void onDone(boolean enabled) { setTabEnabled(tabInfo, enabled); (outstandingCallbacks)--; if (((outstandingCallbacks) == 0) || (enabled && ((tabInfo) == (com.google.gerrit.client.change.RelatedChanges.Tab.RELATED_CHANGES)))) { outstandingCallbacks = 0; for (int i = 0; i < (com.google.gerrit.client.change.RelatedChanges.TabCallback.getTabBar().getTabCount()); i++) { if (com.google.gerrit.client.change.RelatedChanges.TabCallback.getTabBar().isTabEnabled(i)) { com.google.gerrit.client.change.RelatedChanges.TabCallback.selectTab(i); com.google.gerrit.client.change.RelatedChanges.TabCallback.setVisible(true); break; } } } }


private static void populateBottomMenu(com.google.gwt.user.client.ui.RootPanel btmmenu, com.google.gerrit.common.data.HostPageData hpd) { java.lang.String vs = hpd.version; if ((vs == null) || (vs.isEmpty())) { vs = "dev"; } btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(com.google.gerrit.client.Gerrit.C.keyHelp())); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(new com.google.gwt.user.client.ui.InlineHTML(com.google.gerrit.client.Gerrit.M.poweredBy(vs))); if ((com.google.gerrit.client.Gerrit.getConfig().getReportBugUrl()) != null) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(com.google.gerrit.client.Gerrit.C.reportBug(), com.google.gerrit.client.Gerrit.getConfig().getReportBugUrl()); a.setTarget("_blank"); a.setStyleName(""); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(a); } }

public static boolean isRef(final java.lang.String name) { if ((name == null) || (!(name.startsWith(com.google.gerrit.reviewdb.client.PatchSet.REFS_CHANGES)))) { return false; } boolean accepted = false; int numsFound = 0; for (int i = (name.length()) - 1; i >= ((com.google.gerrit.reviewdb.client.PatchSet.REFS_CHANGES.length()) - 1); i--) { char c = name.charAt(i); if ((c >= '0') && (c <= '9')) { accepted = c != '0'; } else if (c == '/') { if (accepted) { if ((++numsFound) == 2) { return true; } accepted = false; } } else { return false; } } return false; }
public java.lang.String toRefName() { java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(com.google.gerrit.reviewdb.client.PatchSet.REFS_CHANGES); int change = changeId.get(); int m = change % 100; if (m < 10) { r.append('0'); } r.append(m); r.append('/'); r.append(change); r.append('/'); r.append(patchSetId); return r.toString(); }
@java.lang.Override public void setValue(com.google.gerrit.common.data.ProjectAccess value) { if (((editing) && (value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES))) && ((value.getLocal(AccessSection.GLOBAL_CAPABILITIES)) == null)) { value.getLocal().add(0, new com.google.gerrit.common.data.AccessSection(com.google.gerrit.common.data.AccessSection.GLOBAL_CAPABILITIES)); } this.value = value; com.google.gerrit.reviewdb.client.Project.NameKey parent = value.getInheritsFrom(); if (parent != null) { inheritsFrom.getStyle().setDisplay(Display.BLOCK); parentProject.setText(parent.get()); parentProject.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS)); parentProjectBox.setVisible(editing); parentProjectBox.setProject(value.getProjectName()); parentProjectBox.setParentProject(value.getInheritsFrom()); parentProject.setVisible((!(parentProjectBox.isVisible()))); } else { inheritsFrom.getStyle().setDisplay(Display.NONE); } final com.google.gerrit.client.GitwebLink c = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((value.isConfigVisible()) && (c != null)) { history.getStyle().setDisplay(Display.BLOCK); gitweb.setText(c.getLinkName()); gitweb.setHref(c.toFileHistory(new com.google.gerrit.reviewdb.client.Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config")); } else { history.getStyle().setDisplay(Display.NONE); } addSection.setVisible(((editing) && ((!(value.getOwnerOf().isEmpty())) || (value.canUpload())))); }
private org.eclipse.jgit.notes.NoteMap loadRejectCommitsMap() throws java.io.IOException { try { org.eclipse.jgit.lib.Ref ref = repo.getRef(GitRepositoryManager.REF_REJECT_COMMITS); if (ref == null) { return org.eclipse.jgit.notes.NoteMap.newEmptyMap(); } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit map = rw.parseCommit(ref.getObjectId()); return org.eclipse.jgit.notes.NoteMap.read(rw.getObjectReader(), map); } catch (java.io.IOException badMap) { throw new java.io.IOException(("Cannot load " + (GitRepositoryManager.REF_REJECT_COMMITS)), badMap); } }
@org.junit.Before public void setUp() throws java.lang.Exception { admin = accounts.admin(); initSsh(admin); sshSession = new com.google.gerrit.acceptance.SshSession(server, admin); project = "p"; createProject(sshSession, project, null, true); git = cloneProject((((sshSession.getUrl()) + "/") + (project))); fetch(git, ((com.google.gerrit.server.git.GitRepositoryManager.REF_CONFIG) + ":refs/heads/config")); checkout(git, "refs/heads/config"); db = reviewDbProvider.open(); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) { for (com.google.gerrit.reviewdb.client.Project.NameKey name : mgr.list()) { org.eclipse.jgit.lib.Repository git; try { git = mgr.openRepository(name); } catch (java.io.IOException e) { ui.message(("warning: Cannot open " + (name.get()))); continue; } try { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all; try { all = git.getRefDatabase().getRefs(RefDatabase.ALL); } catch (java.io.IOException e) { ui.message(((("warning: " + (name.get())) + ": Cannot read refs: ") + (e.getMessage()))); e.printStackTrace(); continue; } if ((all.keySet().equals(keysOne)) || (all.keySet().equals(keysTwo))) { try { org.eclipse.jgit.lib.RefUpdate update = git.updateRef(Constants.HEAD); update.disableRefLog(); update.link(GitRepositoryManager.REF_CONFIG); } catch (java.io.IOException err) { ui.message(((((("warning: " + (name.get())) + ": Cannot update HEAD to ") + (com.google.gerrit.server.git.GitRepositoryManager.REF_CONFIG)) + ": ") + (err.getMessage()))); } } } finally { git.close(); } } }
public static com.google.gerrit.reviewdb.client.PatchSet.Id fromRef(java.lang.String name) { if (!(name.startsWith(com.google.gerrit.reviewdb.client.PatchSet.REFS_CHANGES))) { throw new java.lang.IllegalArgumentException(("Not a PatchSet.Id: " + name)); } final java.lang.String[] parts = name.substring(com.google.gerrit.reviewdb.client.PatchSet.REFS_CHANGES.length()).split("/"); final int n = parts.length; if (n < 2) { throw new java.lang.IllegalArgumentException(("Not a PatchSet.Id: " + name)); } final int changeId = java.lang.Integer.parseInt(parts[(n - 2)]); final int patchSetId = java.lang.Integer.parseInt(parts[(n - 1)]); return new com.google.gerrit.reviewdb.client.PatchSet.Id(new com.google.gerrit.reviewdb.client.Change.Id(changeId), patchSetId); }


private static java.lang.String checkName(java.lang.String name) { if ("SUBM".equals(name)) { throw new java.lang.IllegalArgumentException((("Reserved label name \"" + name) + "\"")); } for (int i = 0; i < (name.length()); i++) { char c = name.charAt(i); if (!(((((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))) || ((c >= '0') && (c <= '9'))) || (c == '-'))) { throw new java.lang.IllegalArgumentException((("Illegal label name \"" + name) + "\"")); } } return name; }




private void render(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, int row, com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit info) { sb.openTr(); sb.openTd().setStyleName(FileTable.R.css().pointer()).closeTd(); sb.openTd().addStyleName(Gerrit.RESOURCES.css().relatedChangesSubject()); java.lang.String url = url(info); if (url != null) { sb.openAnchor().setAttribute("href", url); if (url.startsWith("#")) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.RelatedChangesTab.OPEN) + "(event,") + row) + ")")); } if (showBranches) { sb.append(info.branch()).append(": "); } sb.append(info.commit().subject()); sb.closeAnchor(); } else { sb.append(info.commit().subject()); } sb.closeTd(); sb.closeTr(); }

private void render(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, int row, com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit info) { sb.openTr(); sb.openTd().setStyleName(FileTable.R.css().pointer()).closeTd(); sb.openTd().addStyleName(Gerrit.RESOURCES.css().relatedChangesSubject()); java.lang.String url = url(info); if (url != null) { sb.openAnchor().setAttribute("href", url); if (url.startsWith("#")) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.RelatedChangesTab.OPEN) + "(event,") + row) + ")")); } if (showBranches) { sb.append(info.branch()).append(": "); } sb.append(info.commit().subject()); sb.closeAnchor(); } else { sb.append(info.commit().subject()); } sb.closeTd(); sb.openTd(); com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && ((!(info.has_change_number())) || (!(info.has_revision_number())))) { sb.addStyleName(Gerrit.RESOURCES.css().relatedChangesGitweb()); sb.setAttribute("title", gw.getLinkName()); } else if (((info.has_current_revision_number()) && (info.has_revision_number())) && ((info._current_revision_number()) != (info._revision_number()))) { sb.addStyleName(Gerrit.RESOURCES.css().relatedChangesNotCurrent()); sb.setAttribute("title", Util.C.notCurrent()); } sb.closeTd(); sb.closeTr(); }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision).view("review").post(input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId)); } }); }
public static com.google.gerrit.common.data.GitWebType fromName(final java.lang.String name) { final com.google.gerrit.common.data.GitWebType type; if (((name == null) || (name.isEmpty())) || (name.equalsIgnoreCase("gitweb"))) { type = new com.google.gerrit.common.data.GitWebType(); type.setLinkName("gitweb"); type.setProject("?p=${project}.git;a=summary"); type.setRevision("?p=${project}.git;a=commit;h=${commit}"); type.setBranch("?p=${project}.git;a=shortlog;h=${branch}"); type.setFileHistory("?p=${project}.git;a=history;hb=${branch};f=${file}"); } else if (name.equalsIgnoreCase("cgit")) { type = new com.google.gerrit.common.data.GitWebType(); type.setLinkName("cgit"); type.setProject("${project}.git/summary"); type.setRevision("${project}.git/commit/?id=${commit}"); type.setBranch("${project}.git/log/?h=${branch}"); type.setFileHistory("${project}.git/log/${file}?h=${branch}"); } else if (name.equalsIgnoreCase("custom")) { type = new com.google.gerrit.common.data.GitWebType(); type.setLinkName("gitweb"); } else if (name.equalsIgnoreCase("disabled")) { type = null; } else { type = null; } return type; }

private static com.google.gwtexpui.safehtml.client.SafeHtml formatPath(java.lang.String path) { com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); if (Patch.COMMIT_MSG.equals(path)) { return b.append(Util.C.commitMessage()); } int s = (path.lastIndexOf('/')) + 1; b.append(path.substring(0, s)); b.openElement("b"); b.append(path.substring(s)); b.closeElement("b"); return b; }
void setChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { project.setInnerText(info.project()); }


public boolean isReviewer(com.google.gerrit.reviewdb.server.ReviewDb db, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (getCurrentUser().isIdentifiedUser()) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> results; if (cd != null) { results = cd.currentApprovals(com.google.inject.util.Providers.of(db)); } else { results = db.patchSetApprovals().byChange(change.getId()); } for (com.google.gerrit.reviewdb.client.PatchSetApproval approval : results) { if (user.getAccountId().equals(approval.getAccountId())) { return true; } } } return false; }

public void addAllReviewers(com.google.gerrit.server.data.ChangeAttribute a, com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = db.get().patchSetApprovals().byChange(change.getId()).toList(); if (!(approvals.isEmpty())) { a.allReviewers = com.google.common.collect.Lists.newArrayList(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> seen = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { com.google.gerrit.reviewdb.client.Account.Id id = psa.getAccountId(); if (!(seen.contains(id))) { seen.add(id); a.allReviewers.add(asAccountAttribute(id)); } } } }



@java.lang.Override protected void applyDataRowStyle(final int row) { super.applyDataRowStyle(row); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_STAR, Gerrit.RESOURCES.css().iconCell()); for (int i = com.google.gerrit.client.changes.ChangeTable2.C_SUBJECT; i < (columns); i++) { fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell()); } fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT()); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_OWNER, Gerrit.RESOURCES.css().cOWNER()); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate()); int i = com.google.gerrit.client.changes.ChangeTable2.C_SIZE; if (useNewFeatures) { fmt.addStyleName(row, (i++), Gerrit.RESOURCES.css().cSIZE()); } for (; i < (columns); i++) { fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL()); } }
@java.lang.Override public void run() { assert (selfWidgetWrapper) != null; selfWidgetWrapper.getWidget().changed(); if ((diffChunkInfo) != null) { commentManager.getSideBySide2().resizePaddingOnOtherSide(commentManager.getSideBySide2().getSideFromCm(cm), diffChunkInfo.getEnd()); } else { assert (widgetManager) != null; widgetManager.resizePaddingWidget(); } }
void resizePaddingWidget() { if (!(getCommentInfo().has_line())) { return; } commentManager.getSideBySide2().defer(new java.lang.Runnable() { @java.lang.Override public void run() { assert (selfWidgetWrapper) != null; selfWidgetWrapper.getWidget().changed(); if ((diffChunkInfo) != null) { commentManager.getSideBySide2().resizePaddingOnOtherSide(commentManager.getSideBySide2().getSideFromCm(cm), diffChunkInfo.getEnd()); } else { assert (widgetManager) != null; widgetManager.resizePaddingWidget(); } } }); }
void reloadDiffInfo() { final int id = ++(reloadVersionId); com.google.gerrit.client.diff.DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { if ((id == (reloadVersionId)) && (isAttached())) { diff = diffInfo; operation(new java.lang.Runnable() { @java.lang.Override public void run() { skipManager.removeAll(); clearMarkers(); diffTable.sidePanel.clearDiffGutters(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); } }); } } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { if ((id == (reloadVersionId)) && (isAttached())) { diff = diffInfo; operation(new java.lang.Runnable() { @java.lang.Override public void run() { skipManager.removeAll(); clearMarkers(); diffTable.sidePanel.clearDiffGutters(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); } }); } }
com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo lineOnOther(com.google.gerrit.client.diff.DisplaySide side, int line) { return mapper.lineOnOther(side, line); }
private java.lang.Runnable maybeNextVimSearch(final net.codemirror.lib.CodeMirror cm) { return new java.lang.Runnable() { @java.lang.Override public void run() { if (cm.hasVimSearchHighlight()) { net.codemirror.lib.CodeMirror.handleVimKey(cm, "n"); } else { diffChunkNav(cm, com.google.gerrit.client.diff.SideBySide2.Direction.NEXT).run(); } } }; }
void resizePaddingOnOtherSide(com.google.gerrit.client.diff.DisplaySide mySide, int line) { net.codemirror.lib.CodeMirror cm = getCmFromSide(mySide); net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandle(line); final com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle); double myChunkHeight = (cm.heightAtLine((line + 1))) - (cm.heightAtLine(((line - (otherWrapper.getChunkLength())) + 1))); com.google.gwt.dom.client.Element otherPadding = otherWrapper.getElement(); int otherPaddingHeight = otherPadding.getOffsetHeight(); net.codemirror.lib.CodeMirror otherCm = otherCm(cm); int otherLine = otherWrapper.getOtherLine(); net.codemirror.lib.CodeMirror.LineHandle other = otherCm.getLineHandle(otherLine); if (linePaddingOnOtherSideMap.containsKey(other)) { com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other); com.google.gwt.dom.client.Element myPadding = linePaddingOnOtherSideMap.get(other).getElement(); int myPaddingHeight = myPadding.getOffsetHeight(); myChunkHeight -= myPaddingHeight; double otherChunkHeight = ((otherCm.heightAtLine((otherLine + 1))) - (otherCm.heightAtLine(((otherLine - (myWrapper.getChunkLength())) + 1)))) - otherPaddingHeight; double delta = myChunkHeight - otherChunkHeight; if (delta > 0) { if (myPaddingHeight != 0) { myPadding.getStyle().setHeight(((double) (0)), Unit.PX); myWrapper.getWidget().changed(); } if (otherPaddingHeight != delta) { otherPadding.getStyle().setHeight(delta, Unit.PX); otherWrapper.getWidget().changed(); } } else { if (myPaddingHeight != (-delta)) { myPadding.getStyle().setHeight((-delta), Unit.PX); myWrapper.getWidget().changed(); } if (otherPaddingHeight != 0) { otherPadding.getStyle().setHeight(((double) (0)), Unit.PX); otherWrapper.getWidget().changed(); } } } else if (otherPaddingHeight != myChunkHeight) { otherPadding.getStyle().setHeight(myChunkHeight, Unit.PX); otherWrapper.getWidget().changed(); } }
private void render(com.google.gerrit.client.diff.DiffInfo diff) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Region> regions = diff.content(); header.setNoDiff((((regions.length()) == 0) || (((regions.length()) == 1) && ((regions.get(0).ab()) != null)))); mapper = new com.google.gerrit.client.diff.LineMapper(); markers = new java.util.ArrayList<net.codemirror.lib.TextMarker>(); undoLineClass = new java.util.ArrayList<java.lang.Runnable>(); linePaddingOnOtherSideMap = new java.util.HashMap<net.codemirror.lib.CodeMirror.LineHandle, com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper>(); diffChunks = new java.util.ArrayList<com.google.gerrit.client.diff.DiffChunkInfo>(); java.lang.String diffColor = (((diff.meta_a()) == null) || ((diff.meta_b()) == null)) ? DiffTable.style.intralineBg() : DiffTable.style.diff(); for (int i = 0; i < (regions.length()); i++) { com.google.gerrit.client.diff.DiffInfo.Region current = regions.get(i); int origLineA = mapper.getLineA(); int origLineB = mapper.getLineB(); if ((current.ab()) != null) { mapper.appendCommon(current.ab().length()); } else { com.google.gwt.core.client.JsArrayString currentA = ((current.a()) == null) ? com.google.gerrit.client.diff.SideBySide2.EMPTY : current.a(); com.google.gwt.core.client.JsArrayString currentB = ((current.b()) == null) ? com.google.gerrit.client.diff.SideBySide2.EMPTY : current.b(); int aLength = currentA.length(); int bLength = currentB.length(); java.lang.String color = ((currentA == (com.google.gerrit.client.diff.SideBySide2.EMPTY)) || (currentB == (com.google.gerrit.client.diff.SideBySide2.EMPTY))) ? diffColor : DiffTable.style.intralineBg(); colorLines(cmA, color, origLineA, aLength); colorLines(cmB, color, origLineB, bLength); int commonCnt = java.lang.Math.min(aLength, bLength); mapper.appendCommon(commonCnt); if (aLength < bLength) { int insertCnt = bLength - aLength; mapper.appendInsert(insertCnt); } else if (aLength > bLength) { int deleteCnt = aLength - bLength; mapper.appendDelete(deleteCnt); } int chunkEndA = (mapper.getLineA()) - 1; int chunkEndB = (mapper.getLineB()) - 1; if (aLength > 0) { addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength, (bLength > 0)); } if (bLength > 0) { addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength, (aLength > 0)); } markEdit(cmA, currentA, current.edit_a(), origLineA); markEdit(cmB, currentB, current.edit_b(), origLineB); if (aLength == 0) { diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.INSERT); } else if (bLength == 0) { diffTable.sidePanel.addGutter(cmA, origLineA, SidePanel.GutterType.DELETE); } else { diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT); } } } }
@java.lang.Override public void run() { if (cm.hasVimSearchHighlight()) { net.codemirror.lib.CodeMirror.handleVimKey(cm, "n"); } else { diffChunkNav(cm, com.google.gerrit.client.diff.SideBySide2.Direction.NEXT).run(); } }
public void run() { defer(new java.lang.Runnable() { @java.lang.Override public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor("end").getLine()); if ((cm.hasActiveLine()) && (cm.getActiveLine().equals(handle))) { return; } clearActiveLine(cm); clearActiveLine(other); cm.setActiveLine(handle); cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine()); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle)); if (info.isAligned()) { net.codemirror.lib.CodeMirror.LineHandle oLineHandle = other.getLineHandle(info.getLine()); other.setActiveLine(oLineHandle); other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine()); } } }); }
@java.lang.Override public void run() { skipManager.removeAll(); clearMarkers(); diffTable.sidePanel.clearDiffGutters(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); }
private net.codemirror.lib.CodeMirror createCodeMirror(com.google.gerrit.client.diff.DiffInfo.FileMeta meta, java.lang.String contents, com.google.gwt.dom.client.Element parent) { net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("readOnly", true).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", prefs.showLineNumbers()).set("tabSize", prefs.tabSize()).set("mode", (largeFile ? null : getContentType(meta))).set("lineWrapping", false).set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("keyMap", "vim_ro").set("value", (meta != null ? contents : "")); return net.codemirror.lib.CodeMirror.create(parent, cfg); }
@java.lang.Override public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor("end").getLine()); if ((cm.hasActiveLine()) && (cm.getActiveLine().equals(handle))) { return; } clearActiveLine(cm); clearActiveLine(other); cm.setActiveLine(handle); cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine()); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle)); if (info.isAligned()) { net.codemirror.lib.CodeMirror.LineHandle oLineHandle = other.getLineHandle(info.getLine()); other.setActiveLine(oLineHandle); other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine()); } }

private net.codemirror.lib.CodeMirror.RenderLineHandler resizeLinePadding(final com.google.gerrit.client.diff.DisplaySide side) { return new net.codemirror.lib.CodeMirror.RenderLineHandler() { @java.lang.Override public void handle(final net.codemirror.lib.CodeMirror instance, final net.codemirror.lib.CodeMirror.LineHandle handle, com.google.gwt.dom.client.Element element) { commentManager.resizePadding(handle); if (linePaddingOnOtherSideMap.containsKey(handle)) { defer(new java.lang.Runnable() { @java.lang.Override public void run() { resizePaddingOnOtherSide(side, instance.getLineNumber(handle)); } }); } } }; }
private java.lang.Runnable updateActiveLine(final net.codemirror.lib.CodeMirror cm) { final net.codemirror.lib.CodeMirror other = otherCm(cm); return new java.lang.Runnable() { public void run() { defer(new java.lang.Runnable() { @java.lang.Override public void run() { net.codemirror.lib.CodeMirror.LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor("end").getLine()); if ((cm.hasActiveLine()) && (cm.getActiveLine().equals(handle))) { return; } clearActiveLine(cm); clearActiveLine(other); cm.setActiveLine(handle); cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine()); com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle)); if (info.isAligned()) { net.codemirror.lib.CodeMirror.LineHandle oLineHandle = other.getLineHandle(info.getLine()); other.setActiveLine(oLineHandle); other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine()); } } }); } }; }
@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { resizeCodeMirror(); } }); final int height = getCodeMirrorHeight(); operation(new java.lang.Runnable() { @java.lang.Override public void run() { cmA.setHeight(height); cmB.setHeight(height); cmA.refresh(); cmB.refresh(); } }); diffTable.sidePanel.adjustGutters(cmB); if (((startSide) != null) && ((startLine) > 0)) { int line = (startLine) - 1; net.codemirror.lib.CodeMirror cm = getCmFromSide(startSide); if ((cm.lineAtHeight((height - 20))) < line) { cm.scrollToY(((cm.heightAtLine(line, "local")) - (0.5 * height))); } cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); cm.focus(); } else if ((diff.meta_b()) != null) { int line = 0; if (!(diffChunks.isEmpty())) { com.google.gerrit.client.diff.DiffChunkInfo d = diffChunks.get(0); net.codemirror.lib.CodeMirror cm = getCmFromSide(d.getSide()); line = d.getStart(); if ((cm.lineAtHeight((height - 20))) < line) { cm.scrollToY(((cm.heightAtLine(line, "local")) - (0.5 * height))); } } cmB.setCursor(net.codemirror.lib.LineCharacter.create(line)); cmB.focus(); } else { cmA.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmA.focus(); } if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (prefs.autoReview())) { header.autoReview(); } prefetchNextFile(); }
private java.lang.Runnable flipCursorSide(final net.codemirror.lib.CodeMirror cmSrc, com.google.gerrit.client.diff.DisplaySide sideDst) { final net.codemirror.lib.CodeMirror cmDst = getCmFromSide(sideDst); if (cmDst == cmSrc) { return new java.lang.Runnable() { @java.lang.Override public void run() { } }; } final com.google.gerrit.client.diff.DisplaySide sideSrc = getSideFromCm(cmSrc); return new java.lang.Runnable() { public void run() { if (cmSrc.hasActiveLine()) { cmDst.setCursor(net.codemirror.lib.LineCharacter.create(mapper.lineOnOther(sideSrc, cmSrc.getLineNumber(cmSrc.getActiveLine())).getLine())); } cmDst.focus(); } }; }
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { setShowTabs(prefs.showTabs()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(DiffTable.style.showLineNumbers()); } cmA = createCodeMirror(diff.meta_a(), diff.text_a(), diffTable.cmA); cmB = createCodeMirror(diff.meta_b(), diff.text_b(), diffTable.cmB); skipManager = new com.google.gerrit.client.diff.SkipManager(this, commentManager); operation(new java.lang.Runnable() { public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments); if (prefs.expandAllComments()) { commentManager.setExpandAllComments(true); } skipManager.render(prefs.context(), diff); } }); registerCmEvents(cmA); registerCmEvents(cmB); new com.google.gerrit.client.diff.ScrollSynchronizer(diffTable, cmA, cmB, mapper); prefsAction = new com.google.gerrit.client.diff.PreferencesAction(this, prefs); header.init(prefsAction); if ((largeFile) && (prefs.syntaxHighlighting())) { com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { if ((prefs.syntaxHighlighting()) && (isAttached())) { setSyntaxHighlighting(prefs.syntaxHighlighting()); } return false; } }, 250); } }








@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); com.google.gerrit.client.diff.DraftBox box = getDiffScreen().addDraftBox(result, getSide()); registerReplyBox(box); if (!(getCommentInfo().has_line())) { getDiffScreen().addFileCommentBox(box); } }


com.google.gerrit.client.diff.DraftBox addReplyBox() { com.google.gerrit.client.diff.DraftBox box = getDiffScreen().addDraftBox(getDiffScreen().createReply(comment), getSide()); registerReplyBox(box); return box; }
void resizePaddingWidget() { if (!(getCommentInfo().has_line())) { return; } diffScreen.defer(new java.lang.Runnable() { @java.lang.Override public void run() { assert (selfWidgetWrapper) != null; selfWidgetWrapper.getWidget().changed(); if ((diffChunkInfo) != null) { diffScreen.resizePaddingOnOtherSide(side, diffChunkInfo.getEnd()); } else { assert (widgetManager) != null; widgetManager.resizePaddingWidget(); } } }); }
@java.lang.Override public void run() { assert (selfWidgetWrapper) != null; selfWidgetWrapper.getWidget().changed(); if ((diffChunkInfo) != null) { diffScreen.resizePaddingOnOtherSide(side, diffChunkInfo.getEnd()); } else { assert (widgetManager) != null; widgetManager.resizePaddingWidget(); } }
private void display(final com.google.gerrit.client.diff.CommentsCollections data) { lineActiveBoxMap = new java.util.HashMap<net.codemirror.lib.CodeMirror.LineHandle, com.google.gerrit.client.diff.CommentBox>(); linePublishedBoxesMap = new java.util.HashMap<net.codemirror.lib.CodeMirror.LineHandle, java.util.List<com.google.gerrit.client.diff.PublishedBox>>(); linePaddingManagerMap = new java.util.HashMap<net.codemirror.lib.CodeMirror.LineHandle, com.google.gerrit.client.diff.PaddingManager>(); publishedMap = new java.util.HashMap<java.lang.String, com.google.gerrit.client.diff.PublishedBox>(); setShowTabs(prefs.showTabs()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(DiffTable.style.showLineNumbers()); } cmA = createCodeMirror(diff.meta_a(), diff.text_a(), diffTable.cmA); cmB = createCodeMirror(diff.meta_b(), diff.text_b(), diffTable.cmB); operation(new java.lang.Runnable() { public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); if ((data.publishedBase) != null) { renderPublished(DisplaySide.A, data.publishedBase); } if ((data.publishedRevision) != null) { renderPublished(DisplaySide.B, data.publishedRevision); } if ((data.draftsBase) != null) { renderDrafts(DisplaySide.A, data.draftsBase); } if ((data.draftsRevision) != null) { renderDrafts(DisplaySide.B, data.draftsRevision); } renderSkips(prefs.context()); } }); registerCmEvents(cmA); registerCmEvents(cmB); prefsAction = new com.google.gerrit.client.diff.PreferencesAction(this, prefs); scrollingGlue = com.google.gwt.core.client.GWT.create(com.google.gerrit.client.diff.ScrollSynchronizer.class); scrollingGlue.init(diffTable, cmA, cmB, mapper); header.init(prefsAction); resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { resizeCodeMirror(); } }); if ((largeFile) && (prefs.syntaxHighlighting())) { com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { if ((prefs.syntaxHighlighting()) && (isAttached())) { setSyntaxHighlighting(prefs.syntaxHighlighting()); } return false; } }, 250); } }
private net.codemirror.lib.CodeMirror.GutterClickHandler onGutterClick(final net.codemirror.lib.CodeMirror cm) { return new net.codemirror.lib.CodeMirror.GutterClickHandler() { @java.lang.Override public void handle(net.codemirror.lib.CodeMirror instance, int line, java.lang.String gutter, com.google.gwt.dom.client.NativeEvent clickEvent) { if (!((cm.hasActiveLine()) && ((cm.getLineNumber(cm.getActiveLine())) == line))) { cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); } com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { insertNewDraft(cm).run(); } }); } }; }
@java.lang.Override public void handle(net.codemirror.lib.CodeMirror instance, int line, java.lang.String gutter, com.google.gwt.dom.client.NativeEvent clickEvent) { if (!((cm.hasActiveLine()) && ((cm.getLineNumber(cm.getActiveLine())) == line))) { cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); } com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { insertNewDraft(cm).run(); } }); }
@com.google.gwt.uibinder.client.UiHandler("done") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(getDiffScreen().getToken()); } else if ((replyBox) == null) { done.setEnabled(false); com.google.gerrit.client.changes.CommentInput input = com.google.gerrit.client.changes.CommentInput.create(getDiffScreen().createReply(comment)); input.setMessage(PatchUtil.C.cannedReplyDone()); com.google.gerrit.client.changes.CommentApi.createDraft(psId, input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); com.google.gerrit.client.diff.DraftBox box = getDiffScreen().addDraftBox(result, getSide()); registerReplyBox(box); if (!(getCommentInfo().has_line())) { getDiffScreen().addFileCommentBox(box); } } }); } else { openReplyBox(); setOpen(false); } }
void addFileCommentBox(com.google.gerrit.client.diff.CommentBox box) { getPanelFromSide(box.getSide()).addFileComment(box); }
void onRemoveDraftBox(com.google.gerrit.client.diff.DraftBox box) { getPanelFromSide(box.getSide()).onRemoveDraftBox(box); }
void createOrEditFileComment() { if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(parent.getToken()); return; } if (boxes.isEmpty()) { com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.createFile(path, parent.getStoredSideFromDisplaySide(side), null, null); addFileComment(parent.addDraftBox(info, side)); } else { com.google.gerrit.client.diff.CommentBox box = boxes.get(((boxes.size()) - 1)); if (box instanceof com.google.gerrit.client.diff.DraftBox) { ((com.google.gerrit.client.diff.DraftBox) (box)).setEdit(true); } else { addFileComment(((com.google.gerrit.client.diff.PublishedBox) (box)).addReplyBox()); } } }
boolean hasPrev() { return hasPrev; }
private java.lang.Runnable maybeNextVimSearch(final net.codemirror.lib.CodeMirror cm) { return new java.lang.Runnable() { @java.lang.Override public void run() { if (cm.hasVimSearchHighlight()) { net.codemirror.lib.CodeMirror.handleVimKey(cm, "n"); } else { diffChunkNav(cm, false).run(); } } }; }
private java.lang.Runnable diffChunkNav(final net.codemirror.lib.CodeMirror cm, final boolean prev) { return new java.lang.Runnable() { @java.lang.Override public void run() { int line = (cm.hasActiveLine()) ? cm.getLineNumber(cm.getActiveLine()) : 0; int res = java.util.Collections.binarySearch(diffChunks, new com.google.gerrit.client.diff.DiffChunkInfo(getSideFromCm(cm), line, 0, false), getDiffChunkComparator()); if (res < 0) { res = (-res) - (prev ? 1 : 2); } res = res + (prev ? -1 : 1); if ((res < 0) || ((diffChunks.size()) <= res)) { return; } com.google.gerrit.client.diff.DiffChunkInfo lookUp = diffChunks.get(res); if ((lookUp.isEdit()) && ((lookUp.getSide()) == (DisplaySide.A))) { res = res + (prev ? -1 : 1); if ((res < 0) || ((diffChunks.size()) <= res)) { return; } } com.google.gerrit.client.diff.DiffChunkInfo target = diffChunks.get(res); net.codemirror.lib.CodeMirror targetCm = getCmFromSide(target.getSide()); targetCm.setCursor(net.codemirror.lib.LineCharacter.create(target.getStart())); targetCm.focus(); targetCm.scrollToY(((targetCm.heightAtLine(target.getStart(), "local")) - (0.5 * (cmB.getScrollbarV().getClientHeight())))); } }; }
@java.lang.Override public void run() { int line = (cm.hasActiveLine()) ? cm.getLineNumber(cm.getActiveLine()) : 0; int res = java.util.Collections.binarySearch(diffChunks, new com.google.gerrit.client.diff.DiffChunkInfo(getSideFromCm(cm), line, 0, false), getDiffChunkComparator()); if (res < 0) { res = (-res) - (prev ? 1 : 2); } res = res + (prev ? -1 : 1); if ((res < 0) || ((diffChunks.size()) <= res)) { return; } com.google.gerrit.client.diff.DiffChunkInfo lookUp = diffChunks.get(res); if ((lookUp.isEdit()) && ((lookUp.getSide()) == (DisplaySide.A))) { res = res + (prev ? -1 : 1); if ((res < 0) || ((diffChunks.size()) <= res)) { return; } } com.google.gerrit.client.diff.DiffChunkInfo target = diffChunks.get(res); net.codemirror.lib.CodeMirror targetCm = getCmFromSide(target.getSide()); targetCm.setCursor(net.codemirror.lib.LineCharacter.create(target.getStart())); targetCm.focus(); targetCm.scrollToY(((targetCm.heightAtLine(target.getStart(), "local")) - (0.5 * (cmB.getScrollbarV().getClientHeight())))); }
@java.lang.Override public void run() { if (cm.hasVimSearchHighlight()) { net.codemirror.lib.CodeMirror.handleVimKey(cm, "n"); } else { diffChunkNav(cm, false).run(); } }
private java.lang.Runnable flipCursorSide(final net.codemirror.lib.CodeMirror cm, final boolean toLeft) { return new java.lang.Runnable() { public void run() { if ((cm.hasActiveLine()) && ((toLeft && (cm == (cmB))) || ((!toLeft) && (cm == (cmA))))) { net.codemirror.lib.CodeMirror other = otherCm(cm); other.setCursor(net.codemirror.lib.LineCharacter.create(mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(cm.getActiveLine())).getLine())); other.focus(); } } }; }

private static java.net.InetAddress getLocalHost() throws java.net.UnknownHostException { try { return java.net.InetAddress.getLocalHost(); } catch (java.net.UnknownHostException e1) { try { return java.net.InetAddress.getByName("localhost"); } catch (java.net.UnknownHostException e2) { return java.net.InetAddress.getByName("127.0.0.1"); } } }

private void expandBefore() { net.codemirror.lib.TextMarker.FromTo range = textMarker.find(); int oldStart = range.getFrom().getLine(); int newStart = oldStart + (com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND); int end = range.getTo().getLine(); clearMarkerAndWidget(); collapse(newStart, end, true); updateSelection(); }

void collapse(int start, int end, boolean attach) { if (attach) { boolean isNew = (lineWidget) == null; net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("coverGutter", true).set("noHScroll", true); if (start == 0) { lineWidget = cm.addLineWidget((end + 1), getElement(), cfg.set("above", true)); } else { lineWidget = cm.addLineWidget((start - 1), getElement(), cfg); } if (isNew) { lineWidget.onFirstRedraw(new java.lang.Runnable() { @java.lang.Override public void run() { int w = cm.getGutterElement().getOffsetWidth(); getElement().getStyle().setPaddingLeft(w, Unit.PX); } }); } } textMarker = cm.markText(net.codemirror.lib.CodeMirror.pos(start, 0), net.codemirror.lib.CodeMirror.pos(end), net.codemirror.lib.Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true)); int skipped = (end - start) + 1; if (skipped <= (com.google.gerrit.client.diff.SkipBar.UP_DOWN_THRESHOLD)) { addStyleName(style.noExpand()); } else { upArrow.setHTML(PatchUtil.M.expandBefore(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); } skipNum.setText(java.lang.Integer.toString(skipped)); }
void set(com.google.gerrit.client.ui.CommentLinkProcessor commentLinkProcessor, com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = change.revision(revision); com.google.gerrit.client.changes.ChangeInfo.CommitInfo commit = revInfo.commit(); java.lang.String sub = commit.subject(); java.lang.String msg = commit.message(); if (msg.startsWith(sub)) { msg = msg.substring(sub.length()); if (((msg.length()) > 0) && ((msg.charAt(0)) == '\n')) { msg = msg.substring(1); } } commitName.setInnerText(revision); idText.setText(("Change-Id: " + (change.change_id()))); idText.setPreviewText(change.change_id()); com.google.gerrit.client.change.CommitBox.formatLink(commit.author(), authorNameEmail, authorDate, change.status()); com.google.gerrit.client.change.CommitBox.formatLink(commit.committer(), committerNameEmail, committerDate, change.status()); text.setHTML(commentLinkProcessor.apply(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(msg).linkify())); com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && (gw.canLink(revInfo))) { browserLink.setInnerText(gw.getLinkName()); browserLink.setHref(gw.toRevision(change.project(), revision)); } else { com.google.gwt.user.client.ui.UIObject.setVisible(browserLink, false); } }


@com.google.gwt.uibinder.client.UiHandler("downArrow") void onExpandAfter(com.google.gwt.event.dom.client.ClickEvent e) { otherBar.expandAfter(); expandAfter(); cm.focus(); }
private net.codemirror.lib.CodeMirror.BeforeSelectionChangeHandler onSelectionChange(final net.codemirror.lib.CodeMirror cm) { return new net.codemirror.lib.CodeMirror.BeforeSelectionChangeHandler() { private com.google.gwt.user.client.ui.Image icon; @java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm, net.codemirror.lib.LineCharacter anchor, net.codemirror.lib.LineCharacter head) { if ((anchor == head) || (((anchor.getLine()) == (head.getLine())) && ((anchor.getCh()) == (head.getCh())))) { if ((icon) != null) { icon.setVisible(false); } return; } else if ((icon) == null) { init(anchor); } icon.setVisible(true); net.codemirror.lib.Rect r = cm.charCoords(head, "local"); com.google.gwt.dom.client.Style s = icon.getElement().getStyle(); int top = ((int) (((r.top()) - (icon.getOffsetHeight())) + 2)); if (top < 0) { s.setTop((-3), Unit.PX); s.setLeft(((r.right()) + 2), Unit.PX); } else { s.setTop(top, Unit.PX); s.setLeft(((int) ((r.right()) - ((icon.getOffsetWidth()) / 2))), Unit.PX); } } private void init(net.codemirror.lib.LineCharacter anchor) { icon = new com.google.gwt.user.client.ui.Image(Gerrit.RESOURCES.draftComments()); icon.setTitle(PatchUtil.C.commentInsert()); icon.setStyleName(DiffTable.style.insertCommentIcon()); icon.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { icon.setVisible(false); commentManager.insertNewDraft(cm).run(); } }); add(icon); cm.addWidget(anchor, icon.getElement(), false); } }; }
@java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm, net.codemirror.lib.LineCharacter anchor, net.codemirror.lib.LineCharacter head) { if ((anchor == head) || (((anchor.getLine()) == (head.getLine())) && ((anchor.getCh()) == (head.getCh())))) { if ((icon) != null) { icon.setVisible(false); } return; } else if ((icon) == null) { init(anchor); } icon.setVisible(true); net.codemirror.lib.Rect r = cm.charCoords(head, "local"); com.google.gwt.dom.client.Style s = icon.getElement().getStyle(); int top = ((int) (((r.top()) - (icon.getOffsetHeight())) + 2)); if (top < 0) { s.setTop((-3), Unit.PX); s.setLeft(((r.right()) + 2), Unit.PX); } else { s.setTop(top, Unit.PX); s.setLeft(((int) ((r.right()) - ((icon.getOffsetWidth()) / 2))), Unit.PX); } }
private void expandAfter() { net.codemirror.lib.TextMarker.FromTo range = textMarker.find(); int start = range.getFrom().getLine(); int oldEnd = range.getTo().getLine(); int newEnd = oldEnd - (com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND); textMarker.clear(); collapse(start, newEnd, false); updateSelection(); }
void expandAll() { expandSideAll(); otherBar.expandSideAll(); }
@java.lang.Override protected void configure() { if ((gerritConfig.getString(JiraItsFacade.ITS_NAME_JIRA, null, "url")) != null) { com.googlesource.gerrit.plugins.hooks.jira.JiraModule.LOG.info("JIRA is configured as ITS"); bind(com.googlesource.gerrit.plugins.hooks.its.ItsFacade.class).toInstance(new com.googlesource.gerrit.plugins.hooks.jira.JiraItsFacade(gerritConfig)); install(new com.googlesource.gerrit.plugins.hooks.ItsHookModule(JiraItsFacade.ITS_NAME_JIRA)); } }
void addCommon(int end) { end = java.lang.Math.min(end, fileA.size()); if ((nextA) >= end) { return; } nextB += end - (nextA); while ((nextA) < end) { if (fileA.contains(nextA)) { com.google.gerrit.server.change.GetDiff.ContentEntry e = entry(); e.ab = com.google.common.collect.Lists.newArrayListWithCapacity((end - (nextA))); for (int i = nextA; (i == (nextA)) && (i < end); i = fileA.next(i) , (nextA)++) { e.ab.add(fileA.get(i)); } } else { int endRegion = java.lang.Math.min(end, ((nextA) == 0 ? fileA.first() : fileA.next(((nextA) - 1)))); com.google.gerrit.server.change.GetDiff.ContentEntry e = entry(); e.skip = endRegion - (nextA); nextA = endRegion; } } }










private static java.lang.String checkName(java.lang.String name) { if ("SUBM".equals(name)) { throw new java.lang.IllegalArgumentException((("Reserved label name \"" + name) + "\"")); } for (int i = 0; i < (name.length()); i++) { char c = name.charAt(i); if (!(((((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))) || ((c >= '0') && (c <= '9'))) || (c == '-'))) { throw new java.lang.IllegalArgumentException((("Illegal label name \"" + name) + "\"")); } } return name; }











@java.lang.Override protected void onSave(org.eclipse.jgit.lib.CommitBuilder commit) { if (approvals.isEmpty()) { return; } int psId = change.currentPatchSetId().get(); java.lang.StringBuilder msg = new java.lang.StringBuilder(); if ((subject) != null) { msg.append(subject); } else { msg.append("Update patch set ").append(psId); } msg.append("\n\n"); com.google.gerrit.server.notedb.ChangeUpdate.addFooter(msg, com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_PATCH_SET, psId); for (java.util.Map.Entry<java.lang.String, java.lang.Short> e : approvals.entrySet()) { com.google.gerrit.common.data.LabelType lt = labelTypes.byLabel(e.getKey()); if (lt != null) { com.google.gerrit.server.notedb.ChangeUpdate.addFooter(msg, com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_LABEL, new com.google.gerrit.server.util.LabelVote(lt.getName(), e.getValue()).formatWithEquals()); } } commit.setMessage(msg.toString()); }

private void parse(org.eclipse.jgit.revwalk.RevCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = parsePatchSetId(commit); com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent(commit); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = approvals.get(psId); java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> curr = com.google.common.collect.Maps.newHashMapWithExpectedSize(psas.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : psas) { if (psa.getAccountId().equals(accountId)) { curr.put(psa.getLabel(), psa); } } for (java.lang.String line : commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_LABEL)) { com.google.gerrit.reviewdb.client.PatchSetApproval psa = parseVote(psId, accountId, commit, line); com.google.gerrit.reviewdb.client.PatchSetApproval old = curr.get(psa.getLabel()); if ((old == null) || ((old.getGranted().compareTo(psa.getGranted())) < 0)) { curr.put(psa.getLabel(), psa); psas.add(psa); } } }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = getRevision(); if (rev == null) { return; } approvals = com.google.common.collect.ArrayListMultimap.create(); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(reader); walk.markStart(walk.parseCommit(rev)); for (org.eclipse.jgit.revwalk.RevCommit commit : walk) { walk.parseBody(commit); parse(commit); } for (java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> v : approvals.asMap().values()) { java.util.Collections.sort(((java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval>) (v)), com.google.gerrit.server.notedb.ChangeNotes.PSA_BY_TIME); } }

private void applyAllSuccess() { if (((!(failed)) && (finalAdded)) && (remaining.isEmpty())) { for (com.google.gerrit.client.rpc.CallbackGroup.CallbackImpl<?> cb : callbacks) { cb.applySuccess(); } callbacks.clear(); } }

@java.lang.Override public void onFailure(java.lang.Throwable caught) { if (failed) { return; } failed = true; failedThrowable = caught; for (com.google.gerrit.client.rpc.CallbackGroup.CallbackImpl<?> cb : callbacks) { cb.delegate.onFailure(failedThrowable); cb.delegate = null; cb.result = null; } callbacks.clear(); remaining.clear(); }
@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.ProjectOwnerGroups.class).toProvider(com.google.gerrit.server.config.ProjectOwnerGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitUploadPackGroups.class).toProvider(com.google.gerrit.server.config.GitUploadPackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitReceivePackGroups.class).toProvider(com.google.gerrit.server.config.GitReceivePackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); factory(ProjectControl.AssistedFactory.class); }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> canSubmit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet patchSet, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) { if ((!allowClosed) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } if (!(patchSet.getId().equals(change.currentPatchSetId()))) { return ruleError((("Patch set " + (patchSet.getPatchSetId())) + " is not current")); } if ((((change.getStatus()) == (Change.Status.DRAFT)) || (patchSet.isDraft())) && (!allowDraft)) { return cannotSubmitDraft(db, patchSet, cd); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; com.google.gerrit.server.project.SubmitRuleEvaluator evaluator; try { evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, change, cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results"); results = evaluator.evaluate(); } catch (com.google.gerrit.server.project.RuleEvalException e) { return logRuleError(e.getMessage(), e); } if (results.isEmpty()) { com.google.gerrit.server.project.ChangeControl.log.error((((((("Submit rule '" + (evaluator.getSubmitRule())) + "' for change ") + (change.getId())) + " of ") + (getProject().getName())) + " has no solution.")); return ruleError("Project submit rule has no solution"); } return resultsToSubmitRecord(evaluator.getSubmitRule(), results); }
@java.lang.Override protected void configure() { bind(org.eclipse.jgit.lib.Config.class).annotatedWith(com.google.gerrit.server.config.GerritServerConfig.class).toInstance(new org.eclipse.jgit.lib.Config()); factory(CapabilityControl.Factory.class); bind(com.google.gerrit.server.project.ProjectCache.class).toInstance(projectCache); }
public boolean isReviewer(com.google.gerrit.reviewdb.server.ReviewDb db, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (getCurrentUser().isIdentifiedUser()) { java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> results = (cd != null) ? cd.reviewers(com.google.inject.util.Providers.of(db)).values() : approvalsUtil.getReviewers(db, change.getId()).values(); com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); return results.contains(user.getAccountId()); } return false; }
public com.google.gerrit.server.project.ChangeControl forUser(final com.google.gerrit.server.CurrentUser who) { return new com.google.gerrit.server.project.ChangeControl(approvalsUtil, getRefControl().forUser(who), getChange()); }
private boolean computeConnected() { if ((connected) == null) { return false; } if (!(connected.contains(revision))) { while ((connectedPos) >= 0) { com.google.gerrit.client.changes.ChangeInfo.CommitInfo c = list.get(connectedPos).commit(); connected.add(c.commit()); if (longRunning((--(connectedPos)))) { return true; } if (c.commit().equals(revision)) { break; } } } while ((connectedPos) >= 0) { com.google.gerrit.client.changes.ChangeInfo.CommitInfo c = list.get(connectedPos).commit(); for (int j = 0; j < (c.parents().length()); j++) { if (connected.contains(c.parents().get(j).commit())) { connected.add(c.commit()); break; } } if (longRunning((--(connectedPos)))) { return true; } } return false; }


private static boolean onOpen(com.google.gwt.dom.client.NativeEvent e, int idx) { if (com.google.gerrit.client.change.RelatedChangesTab.link.handleAsClick(e.<com.google.gwt.user.client.Event>cast())) { com.google.gerrit.client.change.RelatedChangesTab.MyTable t = com.google.gerrit.client.change.RelatedChangesTab.getMyTable(e); if (t != null) { t.onOpenRow(idx); e.preventDefault(); return false; } } return true; }
private static com.google.gerrit.client.change.RelatedChangesTab.MyTable getMyTable(com.google.gwt.dom.client.NativeEvent event) { com.google.gwt.user.client.Element e = event.getEventTarget().cast(); for (e = com.google.gwt.user.client.DOM.getParent(e); e != null; e = com.google.gwt.user.client.DOM.getParent(e)) { com.google.gwt.user.client.EventListener l = com.google.gwt.user.client.DOM.getEventListener(e); if (l instanceof com.google.gerrit.client.change.RelatedChangesTab.MyTable) { return ((com.google.gerrit.client.change.RelatedChangesTab.MyTable) (l)); } } return null; }
void setChanges(java.lang.String project, java.lang.String revision, com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit> changes) { this.project = project; render(revision, changes); }






public boolean execute() { boolean attachedNow = panel.isAttached(); if ((!(attached)) && attachedNow) { attached = true; } else if ((attached) && (!attachedNow)) { return false; } start = java.lang.System.currentTimeMillis(); if (computeConnected()) { return true; } while ((row) < (list.length())) { com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit info = list.get(row); if (revision.equals(info.commit().commit())) { select = row; } render(sb, row, info); if (longRunning((++(row)))) { return true; } } table.resetHtml(sb); setTable(table); table.selectRow(select); return false; }
void setError(java.lang.String message) { progress.setVisible(false); scroll.setVisible(false); panel.add(new com.google.gwt.user.client.ui.InlineLabel(message)); }






private void loadCommitData() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = change().currentPatchSetId(); java.lang.String sha1 = db.patchSets().get(psId).getRevision().get(); org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(change().getProject()); try { org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); commitFooters = c.getFooterLines(); } finally { walk.release(); } } finally { repo.close(); } }
public com.google.gerrit.reviewdb.client.Change submit(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gwtorm.server.OrmException, java.io.IOException { final java.sql.Timestamp timestamp = com.google.gerrit.server.util.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); db.changes().beginTransaction(change.getId()); try { approve(rsrc.getPatchSet(), caller, timestamp); change = db.changes().atomicUpdate(change.getId(), new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if (change.getStatus().isOpen()) { change.setStatus(Change.Status.SUBMITTED); change.setLastUpdatedOn(timestamp); com.google.gerrit.server.ChangeUtil.computeSortKey(change); return change; } return null; } }); if (change == null) { return null; } db.commit(); } finally { db.rollback(); } indexer.index(db, change); return change; }
@org.junit.Test public void multipleReviewers() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER.getId(), ReviewerState.REVIEWER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), ReviewerState.REVIEWER); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertEquals(com.google.common.collect.ImmutableSetMultimap.of(ReviewerState.REVIEWER, new com.google.gerrit.reviewdb.client.Account.Id(1), ReviewerState.REVIEWER, new com.google.gerrit.reviewdb.client.Account.Id(2)), notes.getReviewers()); }
private static com.google.gerrit.server.query.change.ChangeData change(java.lang.String... files) { java.util.Arrays.sort(files); com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, null, new com.google.gerrit.reviewdb.client.Change.Id(1)); cd.setCurrentFilePaths(java.util.Arrays.asList(files)); return cd; }
public static void ensureCurrentApprovalsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval>> pending = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentApprovals) == null) && ((cd.limitedApprovals) == null)) { pending.add(cd.db.patchSetApprovals().byPatchSet(cd.change().currentPatchSetId())); } } if (!(pending.isEmpty())) { int idx = 0; for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentApprovals) == null) && ((cd.limitedApprovals) == null)) { cd.currentApprovals = com.google.gerrit.server.ApprovalsUtil.sortApprovals(pending.get((idx++))); } } } }
private boolean isOwnerOfProjectOrBranch(com.google.gerrit.reviewdb.client.Account.Id user) { return ((projectState) != null) && (projectState.controlFor(args.identifiedUserFactory.create(user)).controlForRef(change.getDest()).isOwner()); }
private void addReviewers(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ReviewerJson.PostResult result, java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.project.ChangeControl> reviewers) throws com.google.gerrit.common.errors.EmailException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> added; db.changes().beginTransaction(rsrc.getChange().getId()); try { com.google.gerrit.server.ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db); added = approvalsUtil.addReviewers(db, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet()); db.commit(); } finally { db.rollback(); } com.google.common.util.concurrent.CheckedFuture<?, java.io.IOException> indexFuture = indexer.indexAsync(rsrc.getChange()); result.reviewers = com.google.common.collect.Lists.newArrayListWithCapacity(added.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { result.reviewers.add(json.format(new com.google.gerrit.server.change.ReviewerJson.ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), com.google.common.collect.ImmutableList.of(psa))); } accountLoaderFactory.create(true).fill(result.reviewers); postAdd(rsrc.getChange(), added); indexFuture.checkedGet(); }
protected com.google.gerrit.server.patch.PatchList getPatchList() throws com.google.gerrit.server.patch.PatchListNotAvailableException { if ((patchSet) != null) { return args.patchListCache.get(change, patchSet); } throw new com.google.gerrit.server.patch.PatchListNotAvailableException("no patchSet specified"); }
protected boolean isVisibleTo(final com.google.gerrit.reviewdb.client.Account.Id to) throws com.google.gwtorm.server.OrmException { return ((projectState) == null) || (projectState.controlFor(args.identifiedUserFactory.create(to)).controlFor(change).isVisible(args.db.get())); }
protected java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getProjectOwners() { final com.google.gerrit.server.project.ProjectState r; r = args.projectCache.get(change.getProject()); return r != null ? r.getOwners() : java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(); }
public java.lang.String getChangeDetail() { try { java.lang.StringBuilder detail = new java.lang.StringBuilder(); if ((patchSetInfo) != null) { detail.append(patchSetInfo.getMessage().trim()).append("\n"); } else { detail.append(change.getSubject().trim()).append("\n"); } if ((patchSet) != null) { detail.append("---\n"); com.google.gerrit.server.patch.PatchList patchList = getPatchList(); for (com.google.gerrit.server.patch.PatchListEntry p : patchList.getPatches()) { if (Patch.COMMIT_MSG.equals(p.getNewName())) { continue; } detail.append(p.getChangeType().getCode()).append(" ").append(p.getNewName()).append("\n"); } detail.append(java.text.MessageFormat.format(("" + ((("{0,choice,0#0 files|1#1 file|1<{0} files} changed, " + "{1,choice,0#0 insertions|1#1 insertion|1<{1} insertions}(+), ") + "{2,choice,0#0 deletions|1#1 deletion|1<{2} deletions}(-)") + "\n")), ((patchList.getPatches().size()) - 1), patchList.getInsertions(), patchList.getDeletions())); detail.append("\n"); } return detail.toString(); } catch (java.lang.Exception err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot format change detail", err); return ""; } }
public java.lang.String getChangeUrl() { if ((getGerritUrl()) != null) { final java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(getGerritUrl()); r.append(change.getChangeId()); return r.toString(); } return null; }
@java.lang.Override protected void setupVelocityContext() { super.setupVelocityContext(); velocityContext.put("change", change); velocityContext.put("changeId", change.getKey()); velocityContext.put("coverLetter", getCoverLetter()); velocityContext.put("fromName", getNameFor(fromId)); velocityContext.put("patchSet", patchSet); velocityContext.put("patchSetInfo", patchSetInfo); }
public java.lang.String getUnifiedDiff() { com.google.gerrit.server.patch.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return "[Octopus merge; cannot be formatted as a diff.]\n"; } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(args.settings.maximumDiffSize); org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf); org.eclipse.jgit.lib.Repository git; try { git = args.server.openRepository(change.getProject()); } catch (java.io.IOException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot open repository to format patch", e); return ""; } try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } finally { fmt.release(); git.close(); } }
protected void init() throws com.google.gerrit.common.errors.EmailException { if ((args.projectCache) != null) { projectState = args.projectCache.get(change.getProject()); } else { projectState = null; } if ((patchSet) == null) { try { patchSet = args.db.get().patchSets().get(change.currentPatchSetId()); } catch (com.google.gwtorm.server.OrmException err) { patchSet = null; } } if (((patchSet) != null) && ((patchSetInfo) == null)) { try { patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), patchSet.getId()); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException err) { patchSetInfo = null; } } authors = getAuthors(); super.init(); if (((changeMessage) != null) && ((changeMessage.getWrittenOn()) != null)) { setHeader("Date", new java.util.Date(changeMessage.getWrittenOn().getTime())); } setChangeSubjectHeader(); setHeader("X-Gerrit-Change-Id", ("" + (change.getKey().get()))); setChangeUrlHeader(); setCommitIdHeader(); }
protected void bccStarredBy() { try { for (com.google.gerrit.reviewdb.client.StarredChange w : args.db.get().starredChanges().byChange(change.getId())) { super.add(RecipientType.BCC, w.getAccountId()); } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot BCC users that starred updated change", err); } }
protected java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> getAuthors() { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> authors = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); authors.add(change.getOwner()); if ((patchSet) != null) { authors.add(patchSet.getUploader()); } if ((patchSetInfo) != null) { if ((patchSetInfo.getAuthor().getAccount()) != null) { authors.add(patchSetInfo.getAuthor().getAccount()); } if ((patchSetInfo.getCommitter().getAccount()) != null) { authors.add(patchSetInfo.getCommitter().getAccount()); } } return authors; }
@org.junit.Test public void removeReviewer() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), ReviewerState.REVIEWER); commit(update); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putApproval("Code-Review", ((short) (1))); commit(update); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT); update.putApproval("Code-Review", ((short) (1))); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertEquals(2, psas.size()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER.getId(), psas.get(0).getAccountId()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), psas.get(1).getAccountId()); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.removeReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId()); commit(update); notes = newNotes(c); psas = notes.getApprovals().get(c.currentPatchSetId()); assertEquals(1, psas.size()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER.getId(), psas.get(0).getAccountId()); }
private com.google.gerrit.reviewdb.client.Change newChange() { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id(1); com.google.gerrit.reviewdb.client.Change c = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), changeId, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER.getId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(project, "master"), com.google.gerrit.server.util.TimeUtil.nowTs()); com.google.gerrit.server.notedb.ChangeNotesTest.incrementPatchSet(c); return c; }
@org.junit.Test public void approvalsMultipleVotes() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putApproval("Code-Review", ((short) (-1))); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); com.google.gerrit.reviewdb.client.PatchSetApproval psa = com.google.common.collect.Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId())); assertEquals("Code-Review", psa.getLabel()); assertEquals(((short) (-1)), psa.getValue()); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putApproval("Code-Review", ((short) (1))); commit(update); notes = newNotes(c); psa = com.google.common.collect.Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId())); assertEquals("Code-Review", psa.getLabel()); assertEquals(((short) (1)), psa.getValue()); }
@org.junit.Test public void approvalsMultipleUsers() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putApproval("Code-Review", ((short) (-1))); commit(update); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT); update.putApproval("Code-Review", ((short) (1))); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertEquals(1, notes.getApprovals().keySet().size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertEquals(2, psas.size()); assertEquals(c.currentPatchSetId(), psas.get(0).getPatchSetId()); assertEquals(1, psas.get(0).getAccountId().get()); assertEquals("Code-Review", psas.get(0).getLabel()); assertEquals(((short) (-1)), psas.get(0).getValue()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.truncate(com.google.gerrit.server.notedb.ChangeNotesTest.after(c, 1000)), psas.get(0).getGranted()); assertEquals(c.currentPatchSetId(), psas.get(1).getPatchSetId()); assertEquals(2, psas.get(1).getAccountId().get()); assertEquals("Code-Review", psas.get(1).getLabel()); assertEquals(((short) (1)), psas.get(1).getValue()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.truncate(com.google.gerrit.server.notedb.ChangeNotesTest.after(c, 2000)), psas.get(1).getGranted()); }
public boolean isReviewer(com.google.gerrit.reviewdb.server.ReviewDb db, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (getCurrentUser().isIdentifiedUser()) { java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> results = (cd != null) ? cd.reviewers().values() : approvalsUtil.getReviewers(db, getChange().getId()).values(); com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); return results.contains(user.getAccountId()); } return false; }
@org.junit.Test public void approvalsOnePatchSet() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putApproval("Code-Review", ((short) (-1))); update.putApproval("Verified", ((short) (1))); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertEquals(1, notes.getApprovals().keySet().size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertEquals(2, psas.size()); assertEquals(c.currentPatchSetId(), psas.get(0).getPatchSetId()); assertEquals(1, psas.get(0).getAccountId().get()); assertEquals("Verified", psas.get(0).getLabel()); assertEquals(((short) (1)), psas.get(0).getValue()); assertEquals(com.google.gerrit.server.notedb.ChangeNotesTest.truncate(com.google.gerrit.server.notedb.ChangeNotesTest.after(c, 1000)), psas.get(0).getGranted()); assertEquals(c.currentPatchSetId(), psas.get(1).getPatchSetId()); assertEquals(1, psas.get(1).getAccountId().get()); assertEquals("Code-Review", psas.get(1).getLabel()); assertEquals(((short) (-1)), psas.get(1).getValue()); assertEquals(psas.get(0).getGranted(), psas.get(1).getGranted()); }
@org.junit.Test public void reviewerTypes() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER.getId(), ReviewerState.REVIEWER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), ReviewerState.CC); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertEquals(com.google.common.collect.ImmutableSetMultimap.of(ReviewerState.REVIEWER, new com.google.gerrit.reviewdb.client.Account.Id(1), ReviewerState.CC, new com.google.gerrit.reviewdb.client.Account.Id(2)), notes.getReviewers()); }
@org.junit.Test public void oneReviewerMultipleTypes() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.CHANGE_OWNER); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), ReviewerState.REVIEWER); commit(update); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertEquals(com.google.common.collect.ImmutableSetMultimap.of(ReviewerState.REVIEWER, new com.google.gerrit.reviewdb.client.Account.Id(2)), notes.getReviewers()); update = newUpdate(c, com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT); update.putReviewer(com.google.gerrit.server.notedb.ChangeNotesTest.OTHER_ACCOUNT.getId(), ReviewerState.CC); commit(update); notes = newNotes(c); assertEquals(com.google.common.collect.ImmutableSetMultimap.of(ReviewerState.CC, new com.google.gerrit.reviewdb.client.Account.Id(2)), notes.getReviewers()); }


protected org.apache.lucene.store.Directory readIndexDirectory() throws java.io.IOException { org.apache.lucene.store.Directory dir = new org.apache.lucene.store.RAMDirectory(); byte[] buffer = new byte[4096]; java.io.InputStream index = com.google.gerrit.server.documentation.QueryDocumentationExecutor.class.getClassLoader().getResourceAsStream(com.google.gerrit.server.documentation.QueryDocumentationExecutor.INDEX_PATH); if (index == null) { com.google.gerrit.server.documentation.QueryDocumentationExecutor.log.warn("No index available"); return null; } java.util.zip.ZipInputStream zip = new java.util.zip.ZipInputStream(index); try { java.util.zip.ZipEntry entry; while ((entry = zip.getNextEntry()) != null) { org.apache.lucene.store.IndexOutput out = dir.createOutput(entry.getName(), null); int count; while ((count = zip.read(buffer)) != (-1)) { out.writeBytes(buffer, count); } out.close(); } } finally { zip.close(); } return dir; }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } org.apache.lucene.store.NIOFSDirectory directory = new org.apache.lucene.store.NIOFSDirectory(tmpdir); org.apache.lucene.index.IndexWriterConfig config = new org.apache.lucene.index.IndexWriterConfig(DocIndexer.LUCENE_VERSION, new org.apache.lucene.analysis.standard.StandardAnalyzer(DocIndexer.LUCENE_VERSION, org.apache.lucene.analysis.util.CharArraySet.EMPTY_SET)); config.setOpenMode(OpenMode.CREATE); org.apache.lucene.index.IndexWriter iwriter = new org.apache.lucene.index.IndexWriter(directory, config); for (java.lang.String inputFile : inputFiles) { java.io.File file = new java.io.File(inputFile); java.io.BufferedReader titleReader = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), "UTF-8")); java.lang.String title = titleReader.readLine(); if ((title != null) && (title.startsWith("[["))) { title = titleReader.readLine(); } titleReader.close(); java.util.regex.Matcher matcher = DocIndexer.SECTION_HEADER.matcher(title); if (matcher.matches()) { title = matcher.group(1); } java.lang.String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt); java.io.FileReader reader = new java.io.FileReader(file); org.apache.lucene.document.Document doc = new org.apache.lucene.document.Document(); doc.add(new org.apache.lucene.document.TextField(com.google.gerrit.server.documentation.Constants.DOC_FIELD, reader)); doc.add(new org.apache.lucene.document.StringField(com.google.gerrit.server.documentation.Constants.URL_FIELD, ((prefix) + outputFile), Field.Store.YES)); doc.add(new org.apache.lucene.document.TextField(com.google.gerrit.server.documentation.Constants.TITLE_FIELD, title, Field.Store.YES)); iwriter.addDocument(doc); reader.close(); } iwriter.close(); java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream(zipFile)); DocIndexer.zipDir(tmpdir, "", zip); zip.close(); }

@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); limitThreads(); if ((version) == null) { version = com.google.gerrit.server.index.ChangeSchemas.getLatest().getVersion(); } com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); index = sysInjector.getInstance(com.google.gerrit.server.index.IndexCollection.class).getSearchIndex(); index.markReady(false); index.deleteAll(); int result = indexAll(); index.markReady(true); sysManager.stop(); dbManager.stop(); return result; }


private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); modules.add(com.google.gerrit.server.patch.PatchListCacheImpl.module()); com.google.inject.AbstractModule changeIndexModule; switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : changeIndexModule = new com.google.gerrit.lucene.LuceneIndexModule(version, threads, outputBase); break; case SOLR : changeIndexModule = new com.google.gerrit.solr.SolrIndexModule(false, threads, outputBase); break; default : throw new java.lang.IllegalStateException("unsupported index.type"); } modules.add(changeIndexModule); modules.add(new com.google.gerrit.pgm.Reindex.ReviewDbModule()); modules.add(new com.google.gerrit.server.config.FactoryModule() { @java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); factory(ChangeData.Factory.class); factory(ProjectState.Factory.class); bind(new com.google.inject.TypeLiteral<java.util.List<com.google.gerrit.server.project.CommentLinkInfo>>() {}).toProvider(com.google.gerrit.server.project.CommentLinkProvider.class).in(com.google.gerrit.pgm.SINGLETON); bind(com.google.gerrit.server.IdentifiedUser.class).toProvider(com.google.inject.util.Providers.<com.google.gerrit.server.IdentifiedUser>of(null)); bind(com.google.gerrit.server.CurrentUser.class).to(com.google.gerrit.server.IdentifiedUser.class); bind(java.lang.String.class).annotatedWith(com.google.gerrit.server.config.CanonicalWebUrl.class).toProvider(com.google.gerrit.server.config.CanonicalWebUrlProvider.class); factory(IncludingGroupMembership.Factory.class); bind(com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.account.UniversalGroupBackend.class).in(com.google.gerrit.pgm.SINGLETON); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.server.account.GroupBackend.class); bind(com.google.gerrit.server.account.InternalGroupBackend.class).in(com.google.gerrit.pgm.SINGLETON); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.group.SystemGroupBackend.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.account.InternalGroupBackend.class); factory(InternalUser.Factory.class); factory(PatchSetInserter.Factory.class); bind(com.google.gerrit.common.ChangeHooks.class).to(com.google.gerrit.common.DisabledChangeHooks.class); bind(ReplacePatchSetSender.Factory.class).toProvider(com.google.inject.util.Providers.<com.google.gerrit.server.mail.ReplacePatchSetSender.Factory>of(null)); factory(CapabilityControl.Factory.class); factory(MergeUtil.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class); factory(CommitValidators.Factory.class); } }); modules.add(com.google.gerrit.server.account.AccountCacheImpl.module()); modules.add(com.google.gerrit.server.account.AccountByEmailCacheImpl.module()); modules.add(com.google.gerrit.server.change.ChangeKindCache.module()); modules.add(com.google.gerrit.server.account.GroupCacheImpl.module()); modules.add(com.google.gerrit.server.account.GroupIncludeCacheImpl.module()); modules.add(com.google.gerrit.server.project.ProjectCacheImpl.module()); modules.add(com.google.gerrit.server.project.SectionSortCache.module()); modules.add(new com.google.gerrit.server.project.AccessControlModule()); modules.add(new com.google.gerrit.server.git.GitModule()); modules.add(new com.google.gerrit.server.notedb.NoteDbModule()); modules.add(new com.google.gerrit.rules.PrologModule()); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { } @com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.change.MergeabilityChecksExecutor public WorkQueue.Executor createMergeabilityChecksExecutor(com.google.gerrit.server.git.WorkQueue queues) { return queues.createQueue(1, "MergeabilityChecks"); } }); return dbInjector.createChildInjector(modules); }
@java.lang.SuppressWarnings("rawtypes") @java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gerrit.extensions.registration.DynamicSet<com.google.gerrit.server.cache.CacheRemovalListener>>() {}).toInstance(com.google.gerrit.extensions.registration.DynamicSet.<com.google.gerrit.server.cache.CacheRemovalListener>emptySet()); install(new com.google.gerrit.server.cache.h2.DefaultCacheFactory.Module()); factory(ChangeData.Factory.class); factory(ProjectState.Factory.class); bind(new com.google.inject.TypeLiteral<java.util.List<com.google.gerrit.server.project.CommentLinkInfo>>() {}).toProvider(com.google.gerrit.server.project.CommentLinkProvider.class).in(com.google.gerrit.pgm.SINGLETON); bind(com.google.gerrit.server.IdentifiedUser.class).toProvider(com.google.inject.util.Providers.<com.google.gerrit.server.IdentifiedUser>of(null)); bind(com.google.gerrit.server.CurrentUser.class).to(com.google.gerrit.server.IdentifiedUser.class); bind(java.lang.String.class).annotatedWith(com.google.gerrit.server.config.CanonicalWebUrl.class).toProvider(com.google.gerrit.server.config.CanonicalWebUrlProvider.class); factory(IncludingGroupMembership.Factory.class); bind(com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.account.UniversalGroupBackend.class).in(com.google.gerrit.pgm.SINGLETON); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.server.account.GroupBackend.class); bind(com.google.gerrit.server.account.InternalGroupBackend.class).in(com.google.gerrit.pgm.SINGLETON); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.group.SystemGroupBackend.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.google.gerrit.server.account.InternalGroupBackend.class); factory(InternalUser.Factory.class); factory(PatchSetInserter.Factory.class); bind(com.google.gerrit.common.ChangeHooks.class).to(com.google.gerrit.common.DisabledChangeHooks.class); bind(ReplacePatchSetSender.Factory.class).toProvider(com.google.inject.util.Providers.<com.google.gerrit.server.mail.ReplacePatchSetSender.Factory>of(null)); factory(CapabilityControl.Factory.class); factory(MergeUtil.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class); factory(CommitValidators.Factory.class); }
private void render() { if ((rows) == null) { return; } int currChildren = body.getChildCount(); int vpos = getVerticalScrollPosition(); if (((currChildren > 0) && ((top) <= vpos)) && (vpos <= (bottom))) { return; } int currStart = startRow; int currEnd = (startRow) + currChildren; ensureRowMeasurements(); int page = (maxHeight) / (rowHeight); int start = java.lang.Math.max(((vpos / (rowHeight)) - 5), 0); int end = java.lang.Math.min((((vpos / (rowHeight)) + page) + 5), rows.size()); if (end <= currStart) { renderRange(start, end, true, true); } else if (start < currStart) { renderRange(start, currStart, false, true); } else if (start >= currEnd) { renderRange(start, end, true, false); } else if (end > currEnd) { renderRange(currEnd, end, false, false); } renderSelected(selectedRow, true); if (currEnd == 0) { int width = body.getOffsetWidth(); if ((rowWidth) > width) { int w = (2 * (rowWidth)) - width; setWidth((w + "px")); } body.getStyle().clearVisibility(); } }
private void ensureRowMeasurements() { if ((rowHeight) == 0) { surrogate.setInnerSafeHtml(rows.get(0)); getContainerElement().appendChild(surrogate); rowHeight = surrogate.getOffsetHeight(); rowWidth = surrogate.getOffsetWidth(); getContainerElement().removeChild(surrogate); getContainerElement().getStyle().setHeight(((rowHeight) * (rows.size())), Style.Unit.PX); } }
public void movePointerTo(int row, boolean scroll) { if ((((rows) != null) && (0 <= row)) && (row < (rows.size()))) { renderSelected(selectedRow, false); selectedRow = row; if (scroll) { ensureRowMeasurements(); int pos = java.lang.Math.max((((rowHeight) * (selectedRow)) - ((maxHeight) / 2)), 0); setVerticalScrollPosition(pos); render(); } renderSelected(selectedRow, true); } }
public boolean execute() { if (((navList) != (view)) || (!(panel.isAttached()))) { return false; } start = java.lang.System.currentTimeMillis(); if (((connected) != null) && (computeConnected())) { return true; } int select = 0; while ((row) < (changes.length())) { com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit info = changes.get(row); java.lang.String commit = info.commit().commit(); rows.add(new com.google.gerrit.client.change.RelatedChangesTab.RowSafeHtml(info, (((connected) != null) && (!(connected.contains(commit)))))); if (revision.equals(commit)) { select = row; } if (longRunning((++(row)))) { return true; } } navList.rows = rows; navList.movePointerTo(select, true); return false; }
@java.lang.Override public void run() { if ((active) == null) { active = this; fixup.scheduleRepeating(20); } if ((active) == (this)) { net.codemirror.lib.ScrollInfo si = src.getScrollInfo(); updateScreenHeader(si); dst.scrollTo(si.getLeft(), align(si.getTop())); state = 0; } }
@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { resizeCodeMirror(); } }); final int height = getCodeMirrorHeight(); operation(new java.lang.Runnable() { @java.lang.Override public void run() { cmA.setHeight(height); cmB.setHeight(height); cmA.refresh(); cmB.refresh(); } }); diffTable.sidePanel.adjustGutters(cmB); if (((startLine) == 0) && ((diff.meta_b()) != null)) { com.google.gerrit.client.diff.DiffChunkInfo d = chunkManager.getFirst(); if (d != null) { startSide = d.getSide(); startLine = (d.getStart()) + 1; } } if (((startSide) != null) && ((startLine) > 0)) { int line = (startLine) - 1; net.codemirror.lib.CodeMirror cm = getCmFromSide(startSide); if ((cm.lineAtHeight((height - 20))) < line) { cm.scrollToY(((cm.heightAtLine(line, "local")) - (0.5 * height))); } cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); cm.focus(); } else { cmA.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmA.focus(); } if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (prefs.autoReview())) { header.autoReview(); } prefetchNextFile(); }
void resizeCodeMirror() { int height = getCodeMirrorHeight(); cmA.setHeight(height); cmB.setHeight(height); diffTable.sidePanel.adjustGutters(cmB); }
public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); }
@java.lang.Override public void run() { cmA.setHeight(height); cmB.setHeight(height); cmA.refresh(); cmB.refresh(); }
boolean set(com.google.gerrit.client.changes.ChangeInfo info, boolean current) { java.util.List<java.lang.String> names = new java.util.ArrayList<java.lang.String>(info.labels()); java.util.Collections.sort(names); boolean canSubmit = info.status().isOpen(); resize(names.size(), 2); for (int row = 0; row < (names.size()); row++) { java.lang.String name = names.get(row); com.google.gerrit.client.changes.ChangeInfo.LabelInfo label = info.label(name); setText(row, 0, name); if ((label.all()) != null) { setWidget(row, 1, renderUsers(label)); } getCellFormatter().setStyleName(row, 0, style.labelName()); getCellFormatter().addStyleName(row, 0, getStyleForLabel(label)); if (canSubmit && ((info.status()) == (Change.Status.NEW))) { switch (label.status()) { case NEED : if (current) { statusText.setTitle(("Needs " + name)); } canSubmit = false; break; case REJECT : case IMPOSSIBLE : if (current) { statusText.setTitle(("Not " + name)); } canSubmit = false; break; default : break; } } } return canSubmit; }
@org.junit.Test public void testGroupOptions() throws java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup.NameKey adminGroupName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators"); com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(adminGroupName); java.lang.String url = ("/groups/" + (adminGroup.getGroupUUID().get())) + "/options"; com.google.gerrit.acceptance.RestResponse r = session.get(url); com.google.gerrit.acceptance.rest.group.GroupOptionsInfo options = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.group.GroupOptionsInfo>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(adminGroup.isVisibleToAll(), com.google.gerrit.acceptance.rest.group.GroupAssert.toBoolean(options.visible_to_all)); r.consume(); com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupOptionsInput in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupOptionsInput(); in.visible_to_all = !(adminGroup.isVisibleToAll()); r = session.put(url, in); com.google.gerrit.acceptance.rest.group.GroupOptionsInfo newOptions = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.group.GroupOptionsInfo>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(in.visible_to_all, com.google.gerrit.acceptance.rest.group.GroupAssert.toBoolean(newOptions.visible_to_all)); adminGroup = groupCache.get(adminGroupName); assertEquals(in.visible_to_all, adminGroup.isVisibleToAll()); r.consume(); }
@org.junit.Test public void defaultGroupsCreated_rest() throws java.io.IOException { com.google.gerrit.acceptance.RestSession session = new com.google.gerrit.acceptance.RestSession(server, admin); com.google.gerrit.acceptance.RestResponse r = session.get("/groups/"); com.google.gson.Gson gson = new com.google.gson.Gson(); java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo> result = gson.fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); java.util.Set<java.lang.String> names = result.keySet(); assertTrue(names.contains("Administrators")); assertTrue(names.contains("Non-Interactive Users")); }
@org.junit.Test public void listBranches() throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { pushTo("refs/heads/master"); java.lang.String masterCommit = git.getRepository().getRef("master").getTarget().getObjectId().getName(); pushTo("refs/heads/dev"); java.lang.String devCommit = git.getRepository().getRef("master").getTarget().getObjectId().getName(); com.google.gerrit.acceptance.RestResponse r = session.get((("/projects/" + (project.get())) + "/branches")); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo>>() {}.getType()); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> expected = com.google.common.collect.Lists.asList(new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/meta/config", null, false), new com.google.gerrit.acceptance.rest.project.BranchInfo[]{ new com.google.gerrit.acceptance.rest.project.BranchInfo("HEAD", "master", false), new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/heads/master", masterCommit, false), new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/heads/dev", devCommit, true) }); com.google.gerrit.acceptance.rest.project.BranchAssert.assertBranches(expected, result); assertEquals("HEAD", result.get(0).ref); assertEquals("refs/meta/config", result.get(1).ref); assertEquals("refs/heads/dev", result.get(2).ref); assertEquals("refs/heads/master", result.get(3).ref); }
@org.junit.Test public void listBranchesOfEmptyProject() throws com.jcraft.jsch.JSchException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey emptyProject = new com.google.gerrit.reviewdb.client.Project.NameKey("empty"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, emptyProject.get(), null, false); com.google.gerrit.acceptance.RestResponse r = session.get((("/projects/" + (emptyProject.get())) + "/branches")); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo>>() {}.getType()); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> expected = com.google.common.collect.Lists.asList(new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/meta/config", null, false), new com.google.gerrit.acceptance.rest.project.BranchInfo[]{ new com.google.gerrit.acceptance.rest.project.BranchInfo("HEAD", null, false) }); com.google.gerrit.acceptance.rest.project.BranchAssert.assertBranches(expected, result); }
@org.junit.Test public void listBranchesHeadHidden() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { blockRead(project, "refs/heads/master"); com.google.gerrit.acceptance.RestSession session = new com.google.gerrit.acceptance.RestSession(server, accounts.create("user", "user@example.com", "User")); pushTo("refs/heads/master"); pushTo("refs/heads/dev"); java.lang.String devCommit = git.getRepository().getRef("master").getTarget().getObjectId().getName(); com.google.gerrit.acceptance.RestResponse r = session.get((("/projects/" + (project.get())) + "/branches")); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo>>() {}.getType()); com.google.gerrit.acceptance.rest.project.BranchAssert.assertBranches(java.util.Collections.singletonList(new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/heads/dev", devCommit, false)), result); }
@org.junit.Test public void messagesReturnedInChronologicalOrder() throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange(); java.lang.String firstMessage = "Some nits need to be fixed."; postMessage(changeId, firstMessage); java.lang.String secondMessage = "I like this feature."; postMessage(changeId, secondMessage); com.google.gerrit.acceptance.rest.change.ChangeInfo c = getChangeWithMessages(changeId); assertNotNull(c.messages); assertEquals(3, c.messages.size()); assertEquals("Uploaded patch set 1.", c.messages.get(0).message); assertMessage(firstMessage, c.messages.get(1).message); assertMessage(secondMessage, c.messages.get(2).message); }
@org.junit.Test public void listBranchesSomeHidden() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { blockRead(project, "refs/heads/dev"); com.google.gerrit.acceptance.RestSession session = new com.google.gerrit.acceptance.RestSession(server, accounts.create("user", "user@example.com", "User")); pushTo("refs/heads/master"); java.lang.String masterCommit = git.getRepository().getRef("master").getTarget().getObjectId().getName(); pushTo("refs/heads/dev"); com.google.gerrit.acceptance.RestResponse r = session.get((("/projects/" + (project.get())) + "/branches")); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo>>() {}.getType()); java.util.List<com.google.gerrit.acceptance.rest.project.BranchInfo> expected = com.google.common.collect.Lists.asList(new com.google.gerrit.acceptance.rest.project.BranchInfo("HEAD", "master", false), new com.google.gerrit.acceptance.rest.project.BranchInfo[]{ new com.google.gerrit.acceptance.rest.project.BranchInfo("refs/heads/master", masterCommit, false) }); com.google.gerrit.acceptance.rest.project.BranchAssert.assertBranches(expected, result); }
@org.junit.Test public void testAllGroupInfoFieldsSetCorrectly() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")); com.google.gerrit.acceptance.RestResponse r = session.get(("/groups/?q=" + (adminGroup.getName()))); java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); com.google.gerrit.acceptance.rest.group.GroupInfo adminGroupInfo = result.get(adminGroup.getName()); com.google.gerrit.acceptance.rest.group.GroupAssert.assertGroupInfo(adminGroup, adminGroupInfo); }
@org.junit.Test public void testOnlyVisibleGroupsReturned() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.IOException { com.google.gerrit.acceptance.TestAccount user = accounts.create("user", "user@example.com", "User"); com.google.gerrit.acceptance.RestSession userSession = new com.google.gerrit.acceptance.RestSession(server, user); java.lang.String newGroupName = "newGroup"; com.google.gerrit.acceptance.rest.group.GroupInput in = new com.google.gerrit.acceptance.rest.group.GroupInput(); in.description = "a hidden group"; in.visible_to_all = false; in.owner_id = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).getGroupUUID().get(); session.put(("/groups/" + newGroupName), in).consume(); java.util.Set<java.lang.String> expectedGroups = com.google.common.collect.Sets.newHashSet(newGroupName); com.google.gerrit.acceptance.RestResponse r = userSession.get("/groups/"); java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo> result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); assertTrue("no groups visible", result.isEmpty()); assertEquals(HttpStatus.SC_CREATED, session.put(java.lang.String.format("/groups/%s/members/%s", newGroupName, user.username)).getStatusCode()); r = userSession.get("/groups/"); result = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); com.google.gerrit.acceptance.rest.group.GroupAssert.assertGroups(expectedGroups, result.keySet()); }
private void testGetGroup(java.lang.String url, com.google.gerrit.reviewdb.client.AccountGroup expectedGroup) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.get(url); com.google.gerrit.acceptance.rest.group.GroupInfo group = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.group.GroupInfo>() {}.getType()); com.google.gerrit.acceptance.rest.group.GroupAssert.assertGroupInfo(expectedGroup, group); }
private static com.google.gson.Gson newGson(com.google.common.collect.Multimap<java.lang.String, java.lang.String> config, @com.google.gerrit.common.Nullable javax.servlet.http.HttpServletRequest req) { com.google.gson.GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder(); com.google.gerrit.httpd.restapi.RestApiServlet.enablePrettyPrint(gb, config, req); com.google.gerrit.httpd.restapi.RestApiServlet.enablePartialGetFields(gb, config); return gb.create(); }
private java.util.List<com.google.gerrit.acceptance.rest.group.GroupInfo> GET(java.lang.String endpoint) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.get(endpoint); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); return new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); }
@org.junit.Test public void defaultMessage() throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange(); com.google.gerrit.acceptance.rest.change.ChangeInfo c = getChangeWithMessages(changeId); assertNotNull(c.messages); assertEquals(1, c.messages.size()); assertEquals("Uploaded patch set 1.", c.messages.get(0).message); }
@org.junit.Test public void listChildren() throws com.jcraft.jsch.JSchException, java.io.IOException { com.google.gerrit.acceptance.SshSession sshSession = new com.google.gerrit.acceptance.SshSession(server, admin); com.google.gerrit.reviewdb.client.Project.NameKey child1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1.get()); com.google.gerrit.reviewdb.client.Project.NameKey child2 = new com.google.gerrit.reviewdb.client.Project.NameKey("p2"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child2.get()); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, "p1.1", child1); sshSession.close(); com.google.gerrit.acceptance.RestResponse r = GET((("/projects/" + (allProjects.get())) + "/children/")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.List<com.google.gerrit.acceptance.rest.project.ProjectInfo> children = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.ProjectInfo>>() {}.getType()); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjects(java.util.Arrays.asList(child1, child2), children); }
@org.junit.Test public void testGroupName() throws java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup.NameKey adminGroupName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators"); java.lang.String url = ("/groups/" + (groupCache.get(adminGroupName).getGroupUUID().get())) + "/name"; com.google.gerrit.acceptance.RestResponse r = session.get(url); java.lang.String name = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.lang.String>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals("Administrators", name); r.consume(); java.lang.String newGroupName = "newGroup"; r = session.put(("/groups/" + newGroupName)); r.consume(); assertEquals(HttpStatus.SC_CREATED, r.getStatusCode()); com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupNameInput in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupNameInput(); in.name = newGroupName; r = session.put(url, in); assertEquals(HttpStatus.SC_CONFLICT, r.getStatusCode()); r.consume(); in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupNameInput(); in.name = "Administrators"; r = session.put(url, in); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); r.consume(); in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupNameInput(); in.name = "Admins"; r = session.put(url, in); java.lang.String newName = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.lang.String>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertNotNull(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(in.name))); assertNull(groupCache.get(adminGroupName)); assertEquals(in.name, newName); r.consume(); }
@org.junit.Test public void testGroupDescription() throws java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup.NameKey adminGroupName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators"); com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(adminGroupName); java.lang.String url = ("/groups/" + (adminGroup.getGroupUUID().get())) + "/description"; com.google.gerrit.acceptance.RestResponse r = session.get(url); java.lang.String description = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.lang.String>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(adminGroup.getDescription(), description); r.consume(); com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupDescriptionInput in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupDescriptionInput(); in.description = "All users that can administrate the Gerrit Server."; r = session.put(url, in); java.lang.String newDescription = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.lang.String>() {}.getType()); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); assertEquals(in.description, newDescription); adminGroup = groupCache.get(adminGroupName); assertEquals(in.description, adminGroup.getDescription()); r.consume(); r = session.delete(url); assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode()); adminGroup = groupCache.get(adminGroupName); assertNull(adminGroup.getDescription()); in = new com.google.gerrit.acceptance.rest.group.GroupPropertiesIT.GroupDescriptionInput(); in.description = ""; r = session.put(url, in); assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode()); adminGroup = groupCache.get(adminGroupName); assertNull(adminGroup.getDescription()); }
@org.junit.Test public void listNoChildren() throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = GET((("/projects/" + (allProjects.get())) + "/children/")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.List<com.google.gerrit.acceptance.rest.project.ProjectInfo> children = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.project.ProjectInfo>>() {}.getType()); assertTrue(children.isEmpty()); }
@org.junit.Test public void setParent() throws com.jcraft.jsch.JSchException, java.io.IOException { java.lang.String parent = "parent"; com.google.gerrit.acceptance.GitUtil.createProject(sshSession, parent, null, true); com.google.gerrit.acceptance.RestResponse r = adminSession.put((("/projects/" + (project)) + "/parent"), new com.google.gerrit.acceptance.rest.project.SetParentIT.ParentInput(parent)); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); r.consume(); r = adminSession.get((("/projects/" + (project)) + "/parent")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.lang.String newParent = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.lang.String>() {}.getType()); assertEquals(parent, newParent); r.consume(); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gwtorm.server.OrmException { final java.util.Map<java.lang.String, com.google.gerrit.server.group.GroupJson.GroupInfo> output = com.google.common.collect.Maps.newTreeMap(); for (com.google.gerrit.server.group.GroupJson.GroupInfo info : get()) { output.put(com.google.common.base.Objects.firstNonNull(info.name, ("Group " + (com.google.gerrit.extensions.restapi.Url.decode(info.id)))), info); info.name = null; } return OutputFormat.JSON.newGson().toJsonTree(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.server.group.GroupJson.GroupInfo>>() {}.getType()); }
@org.junit.Test public void testCreateGroupWithProperties() throws java.io.IOException { final java.lang.String newGroupName = "newGroup"; com.google.gerrit.acceptance.rest.group.GroupInput in = new com.google.gerrit.acceptance.rest.group.GroupInput(); in.description = "Test description"; in.visible_to_all = true; in.owner_id = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).getGroupUUID().get(); com.google.gerrit.acceptance.RestResponse r = session.put(("/groups/" + newGroupName), in); com.google.gerrit.acceptance.rest.group.GroupInfo g = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.group.GroupInfo>() {}.getType()); assertEquals(newGroupName, g.name); com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(newGroupName)); assertEquals(in.description, group.getDescription()); assertEquals(in.visible_to_all, group.isVisibleToAll()); assertEquals(in.owner_id, group.getOwnerGroupUUID().get()); }
public com.google.gerrit.acceptance.RestResponse put(java.lang.String endPoint, java.lang.Object content) throws java.io.IOException { org.apache.http.client.methods.HttpPut put = new org.apache.http.client.methods.HttpPut((((url) + "/a") + endPoint)); if (content != null) { put.addHeader(new org.apache.http.message.BasicHeader("Content-Type", "application/json")); put.setEntity(new org.apache.http.entity.StringEntity(new com.google.gson.Gson().toJson(content), Charsets.UTF_8.name())); } return new com.google.gerrit.acceptance.RestResponse(getClient().execute(put)); }
public com.google.gerrit.acceptance.RestResponse post(java.lang.String endPoint, java.lang.Object content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost((((url) + "/a") + endPoint)); if (content != null) { post.addHeader(new org.apache.http.message.BasicHeader("Content-Type", "application/json")); post.setEntity(new org.apache.http.entity.StringEntity(new com.google.gson.Gson().toJson(content), Charsets.UTF_8.name())); } return new com.google.gerrit.acceptance.RestResponse(getClient().execute(post)); }
private static com.google.gerrit.server.project.ListBranches.BranchInfo createBranchInfo(org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.RefControl refControl, java.util.Set<java.lang.String> targets) { com.google.gerrit.server.project.ListBranches.BranchInfo b = new com.google.gerrit.server.project.ListBranches.BranchInfo(); b.ref = ref.getName(); if ((ref.getObjectId()) != null) { b.revision = ref.getObjectId().name(); } b.setCanDelete(((!(targets.contains(ref.getName()))) && (refControl.canDelete()))); return b; }

public com.google.gerrit.acceptance.RestResponse get(java.lang.String endPoint) throws java.io.IOException { org.apache.http.client.methods.HttpGet get = new org.apache.http.client.methods.HttpGet((((url) + "/a") + endPoint)); return new com.google.gerrit.acceptance.RestResponse(getClient().execute(get)); }
private void submit(java.lang.String changeId, int expectedStatus) throws java.io.IOException { approve(changeId); com.google.gerrit.acceptance.RestResponse r = session.post((("/changes/" + changeId) + "/submit"), com.google.gerrit.acceptance.rest.change.SubmitInput.waitForMerge()); assertEquals(expectedStatus, r.getStatusCode()); if (expectedStatus == (org.apache.http.HttpStatus.SC_OK)) { com.google.gerrit.server.change.ChangeJson.ChangeInfo change = com.google.gerrit.acceptance.rest.change.AbstractSubmit.newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.server.change.ChangeJson.ChangeInfo>() {}.getType()); assertEquals(Change.Status.MERGED, change.status); } r.consume(); }
@org.junit.Test public void testCreateProjectWithProperties() throws java.io.IOException { final java.lang.String newProjectName = "newProject"; com.google.gerrit.acceptance.rest.project.CreateProjectIT.ProjectInput in = new com.google.gerrit.acceptance.rest.project.CreateProjectIT.ProjectInput(); in.description = "Test description"; in.submit_type = com.google.gerrit.reviewdb.client.Project.SubmitType.CHERRY_PICK; in.use_contributor_agreements = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.use_signed_off_by = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.use_content_merge = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.require_change_id = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; com.google.gerrit.acceptance.RestResponse r = session.put(("/projects/" + newProjectName), in); com.google.gerrit.acceptance.rest.project.ProjectInfo p = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.project.ProjectInfo>() {}.getType()); assertEquals(newProjectName, p.name); com.google.gerrit.reviewdb.client.Project project = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newProjectName)).getProject(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertEquals(in.description, project.getDescription()); assertEquals(in.submit_type, project.getSubmitType()); assertEquals(in.use_contributor_agreements, project.getUseContributorAgreements()); assertEquals(in.use_signed_off_by, project.getUseSignedOffBy()); assertEquals(in.use_content_merge, project.getUseContentMerge()); assertEquals(in.require_change_id, project.getRequireChangeID()); }
@org.junit.Test public void addMultipleMembers() throws java.lang.Exception { group("users"); TestAccount u1 = accounts.create("u1", "u1@example.com", "Full Name 1"); TestAccount u2 = accounts.create("u2", "u2@example.com", "Full Name 2"); com.google.gerrit.acceptance.rest.group.MembersInput input = new com.google.gerrit.acceptance.rest.group.MembersInput(); input.members = com.google.common.collect.Lists.newLinkedList(); input.members.add(u1.username); input.members.add(u2.username); com.google.gerrit.acceptance.RestResponse r = POST("/groups/users/members", input); java.util.List<com.google.gerrit.acceptance.rest.account.AccountInfo> ai = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.account.AccountInfo>>() {}.getType()); assertMembers(ai, u1, u2); }
@org.junit.Test public void addMultipleIncludes() throws java.lang.Exception { group("newGroup1"); group("newGroup2"); com.google.gerrit.acceptance.rest.group.GroupsInput input = new com.google.gerrit.acceptance.rest.group.GroupsInput(); input.groups = com.google.common.collect.Lists.newLinkedList(); input.groups.add("newGroup1"); input.groups.add("newGroup2"); com.google.gerrit.acceptance.RestResponse r = POST("/groups/Administrators/groups", input); java.util.List<com.google.gerrit.acceptance.rest.group.GroupInfo> gi = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.acceptance.rest.group.GroupInfo>>() {}.getType()); assertIncludes(gi, "newGroup1", "newGroup2"); }



@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { resizeCodeMirror(); } }); final int height = getCodeMirrorHeight(); operation(new java.lang.Runnable() { @java.lang.Override public void run() { cmA.setHeight(height); cmB.setHeight(height); cmA.refresh(); cmB.refresh(); } }); setLineLength(prefs.lineLength()); diffTable.overview.adjustGutters(cmB); if (((startLine) == 0) && ((diff.meta_b()) != null)) { com.google.gerrit.client.diff.DiffChunkInfo d = chunkManager.getFirst(); if (d != null) { startSide = d.getSide(); startLine = (d.getStart()) + 1; } } if (((startSide) != null) && ((startLine) > 0)) { int line = (startLine) - 1; net.codemirror.lib.CodeMirror cm = getCmFromSide(startSide); if ((cm.lineAtHeight((height - 20))) < line) { cm.scrollToY(((cm.heightAtLine(line, "local")) - (0.5 * height))); } cm.setCursor(net.codemirror.lib.LineCharacter.create(line)); cm.focus(); } else { cmA.setCursor(net.codemirror.lib.LineCharacter.create(0)); cmA.focus(); } if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (prefs.autoReview())) { header.autoReview(); } prefetchNextFile(); }



@java.lang.Override public void run() { if ((active) == null) { active = this; fixup.scheduleRepeating(20); } if ((active) == (this)) { net.codemirror.lib.ScrollInfo si = src.getScrollInfo(); updateScreenHeader(si); dst.scrollTo(si.getLeft(), align(si.getTop())); state = 0; } }
void resizeCodeMirror() { int height = getCodeMirrorHeight(); cmA.setHeight(height); cmB.setHeight(height); diffTable.overview.adjustGutters(cmB); }

static org.eclipse.jgit.lib.Config parse(com.google.gerrit.acceptance.GerritConfigs annotation) { if (annotation == null) { return null; } org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); for (com.google.gerrit.acceptance.GerritConfig c : annotation.value()) { com.google.gerrit.acceptance.ConfigAnnotationParser.parse(cfg, c); } return cfg; }


private void export(com.google.gerrit.server.plugins.AutoRegisterModules.ClassData def) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.Class<?> clazz; try { clazz = java.lang.Class.forName(def.className, false, classLoader); } catch (java.lang.ClassNotFoundException err) { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Cannot load %s with @Export(\"%s\")", def.className, def.exportedAsName), err); } com.google.gerrit.extensions.annotations.Export export = clazz.getAnnotation(com.google.gerrit.extensions.annotations.Export.class); if (export == null) { PluginLoader.log.warn(java.lang.String.format("In plugin %s asm incorrectly parsed %s with @Export(\"%s\")", pluginName, clazz.getName(), def.exportedAsName)); return; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("org.apache.sshd.server.Command", clazz)) { if ((sshGen) != null) { sshGen.export(export, clazz); } } else if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpServlet", clazz)) { if ((httpGen) != null) { httpGen.export(export, clazz); listen(clazz, clazz); } } else { int cnt = sysListen.size(); listen(clazz, clazz); if (cnt == (sysListen.size())) { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Class %s with @Export(\"%s\") not supported", clazz.getName(), export.value())); } } }

@java.lang.Override public void postRun() throws java.lang.Exception { }
@java.lang.Override public void postRun() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { ui.message("\n"); ui.header(((itsDisplayName) + " Integration")); boolean enabled = ui.yesno(false, "By default enabled for all projects"); org.eclipse.jgit.lib.Config cfg = allProjectsConfig.load(); if (enabled) { cfg.setBoolean("plugin", pluginName, "enabled", enabled); } else { cfg.unset("plugin", pluginName, "enabled"); } allProjectsConfig.save(pluginName, (("Initialize " + (itsDisplayName)) + " Integration")); }
private static void addExtensionLink(final com.google.gerrit.client.ui.LinkMenuBar m, final com.google.gerrit.client.extensions.TopMenuItem item) { final com.google.gwt.user.client.ui.Anchor atag = com.google.gerrit.client.Gerrit.anchor(item.getName(), item.getUrl()); atag.setTarget(item.getTarget()); if ((item.getId()) != null) { atag.getElement().setAttribute("id", item.getId()); } m.add(atag); }
public void postRun() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { super.postRun(); this.bugzilla = sections.get(pluginName, null); this.bugzillaComment = sections.get(com.googlesource.gerrit.plugins.hooks.bz.COMMENT_LINK_SECTION, pluginName); ui.message("\n"); ui.header("Bugzilla connectivity"); do { enterBugzillaConnectivity(); } while (((bugzillaUrl) != null) && ((isConnectivityRequested(bugzillaUrl)) && (!(isBugzillaConnectSuccessful()))) ); if ((bugzillaUrl) == null) { return; } ui.header("Bugzilla issue-tracking association"); bugzillaComment.string("Bugzilla bug number regex", "match", "\\([Bb][Uu][Gg][ ]*[1-9][0-9]*\\)"); bugzillaComment.set("html", java.lang.String.format("<a href=\"%s/show_bug.cgi?id=$1\">$1</a>", bugzillaUrl)); bugzillaComment.select("Bug number enforced in commit message", "association", ItsAssociationPolicy.SUGGESTED); }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.query.change.ChangeData> tmp = com.google.common.collect.ImmutableList.of(cd); return formatList2(com.google.common.collect.ImmutableList.of(tmp)).get(0).get(0); }
private java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> toChangeInfo(java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeJson.ChangeInfo> out, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { com.google.gerrit.server.change.ChangeJson.ChangeInfo i = out.get(cd.getId()); if (i == null) { i = toChangeInfo(cd); out.put(cd.getId(), i); } info.add(i); } return info; }
private java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = control(cd); if (ctl == null) { return null; } java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> src; if (((cd.getLimitedPatchSets()) != null) || (has(com.google.gerrit.server.change.ALL_REVISIONS))) { src = cd.patches(); } else { src = java.util.Collections.singletonList(cd.currentPatchSet()); } java.util.Map<java.lang.String, com.google.gerrit.server.change.ChangeJson.RevisionInfo> res = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.reviewdb.client.PatchSet in : src) { if (ctl.isPatchVisible(in, db.get())) { res.put(in.getRevision().get(), toRevisionInfo(cd, in)); } } return res; }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl()); cd.limitToPatchSets(com.google.common.collect.ImmutableList.of(rsrc.getPatchSet().getId())); return format(cd); }

private com.google.gerrit.server.change.ChangeJson.ChangeInfo getChange(com.google.gerrit.acceptance.PushOneCommit.Result pr) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.get((("/changes/" + (pr.getChangeId())) + "/detail")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); return newGson().fromJson(r.getReader(), com.google.gerrit.server.change.ChangeJson.ChangeInfo.class); }
boolean wouldPushRef(java.lang.String ref) { if ((!(replicatePermissions)) && (RefNames.REFS_CONFIG.equals(ref))) { return false; } for (org.eclipse.jgit.transport.RefSpec s : remote.getPushRefSpecs()) { if (s.matchSource(ref)) { return true; } } return false; }
protected org.mortbay.jetty.AbstractConnector getConnector() { return new org.mortbay.jetty.nio.SelectChannelConnector(); }

@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gwtorm.server.OrmException { try { performCreateGroupFactory.create().createGroup(groupName, groupDescription, visibleToAll, ownerGroupId, initialMembers, initialGroups); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw die(e); } catch (com.google.gerrit.common.errors.NameAlreadyUsedException e) { throw die(e); } }



private java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> getPluginConfigValues() { java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> pluginConfigValues = new java.util.HashMap<java.lang.String, java.util.Map<java.lang.String, java.lang.String>>(pluginConfigWidgets.size()); for (java.util.Map.Entry<java.lang.String, java.util.Map<java.lang.String, com.google.gwt.user.client.ui.Widget>> e : pluginConfigWidgets.entrySet()) { java.util.Map<java.lang.String, java.lang.String> values = new java.util.HashMap<java.lang.String, java.lang.String>(e.getValue().size()); pluginConfigValues.put(e.getKey(), values); for (java.util.Map.Entry<java.lang.String, com.google.gwt.user.client.ui.Widget> e2 : e.getValue().entrySet()) { com.google.gwt.user.client.ui.Widget widget = e2.getValue(); if (widget instanceof com.google.gwt.user.client.ui.TextBox) { values.put(e2.getKey(), ((com.google.gwt.user.client.ui.TextBox) (widget)).getValue().trim()); } else if (widget instanceof com.google.gwt.user.client.ui.CheckBox) { values.put(e2.getKey(), java.lang.Boolean.toString(((com.google.gwt.user.client.ui.CheckBox) (widget)).getValue())); } else if (widget instanceof com.google.gwt.user.client.ui.ListBox) { com.google.gwt.user.client.ui.ListBox listBox = ((com.google.gwt.user.client.ui.ListBox) (widget)); java.lang.String value = listBox.getValue(listBox.getSelectedIndex()); values.put(e2.getKey(), value); } } } return pluginConfigValues; }
private java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> getPluginConfigValues() { java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> pluginConfigValues = new java.util.HashMap<java.lang.String, java.util.Map<java.lang.String, java.lang.String>>(pluginConfigWidgets.size()); for (java.util.Map.Entry<java.lang.String, java.util.Map<java.lang.String, com.google.gwt.user.client.ui.Widget>> e : pluginConfigWidgets.entrySet()) { java.util.Map<java.lang.String, java.lang.String> values = new java.util.HashMap<java.lang.String, java.lang.String>(e.getValue().size()); pluginConfigValues.put(e.getKey(), values); for (java.util.Map.Entry<java.lang.String, com.google.gwt.user.client.ui.Widget> e2 : e.getValue().entrySet()) { com.google.gwt.user.client.ui.Widget widget = e2.getValue(); if (widget instanceof com.google.gwt.user.client.ui.TextBox) { values.put(e2.getKey(), ((com.google.gwt.user.client.ui.TextBox) (widget)).getValue().trim()); } else if (widget instanceof com.google.gwt.user.client.ui.CheckBox) { values.put(e2.getKey(), java.lang.Boolean.toString(((com.google.gwt.user.client.ui.CheckBox) (widget)).getValue())); } } } return pluginConfigValues; }
private java.util.Map<java.lang.String, java.util.Collection<com.google.gerrit.server.project.ConfigInfo.ConfigParameterInfo>> getPluginConfigParameters(com.google.gerrit.server.project.ProjectState project, com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.server.config.ProjectConfigEntry> pluginConfigEntries, com.google.gerrit.server.config.PluginConfigFactory cfgFactory) { com.google.common.collect.TreeMultimap<java.lang.String, com.google.gerrit.server.project.ConfigInfo.ConfigParameterInfo> pluginConfigParameters = com.google.common.collect.TreeMultimap.create(); for (com.google.gerrit.extensions.registration.DynamicMap.Entry<com.google.gerrit.server.config.ProjectConfigEntry> e : pluginConfigEntries) { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName()); com.google.gerrit.server.config.ProjectConfigEntry configEntry = e.getProvider().get(); java.lang.String value = cfg.getString(e.getExportName(), configEntry.getDefaultValue()); com.google.gerrit.server.project.ConfigInfo.ConfigParameterInfo configParameter = new com.google.gerrit.server.project.ConfigInfo.ConfigParameterInfo(e.getExportName(), configEntry.getDisplayName(), configEntry.getType(), value); pluginConfigParameters.put(e.getPluginName(), configParameter); } return pluginConfigParameters.asMap(); }
private java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> getPluginConfigValues() { java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> pluginConfigValues = new java.util.HashMap<java.lang.String, java.util.Map<java.lang.String, java.lang.String>>(pluginConfigWidgets.size()); for (java.util.Map.Entry<java.lang.String, java.util.Map<java.lang.String, com.google.gwt.user.client.ui.Widget>> e : pluginConfigWidgets.entrySet()) { java.util.Map<java.lang.String, java.lang.String> values = new java.util.HashMap<java.lang.String, java.lang.String>(e.getValue().size()); pluginConfigValues.put(e.getKey(), values); for (java.util.Map.Entry<java.lang.String, com.google.gwt.user.client.ui.Widget> e2 : e.getValue().entrySet()) { com.google.gwt.user.client.ui.Widget widget = e2.getValue(); if (widget instanceof com.google.gwt.user.client.ui.TextBox) { values.put(e2.getKey(), ((com.google.gwt.user.client.ui.TextBox) (widget)).getValue().trim()); } } } return pluginConfigValues; }
private void initPluginOptions(com.google.gerrit.client.projects.ConfigInfo info) { pluginOptionsPanel.clear(); pluginConfigWidgets = new java.util.HashMap<java.lang.String, java.util.Map<java.lang.String, com.google.gwt.user.client.ui.Widget>>(); for (java.lang.String pluginName : com.google.gerrit.client.rpc.Natives.keys(info.pluginConfigParameters())) { java.util.Map<java.lang.String, com.google.gwt.user.client.ui.Widget> widgetMap = new java.util.HashMap<java.lang.String, com.google.gwt.user.client.ui.Widget>(); pluginConfigWidgets.put(pluginName, widgetMap); com.google.gerrit.client.admin.ProjectInfoScreen.LabeledWidgetsGrid g = new com.google.gerrit.client.admin.ProjectInfoScreen.LabeledWidgetsGrid(); g.addHeader(new com.google.gerrit.client.ui.SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName))); pluginOptionsPanel.add(g); for (com.google.gerrit.client.projects.ConfigInfo.ConfigParameterInfo param : com.google.gerrit.client.rpc.Natives.asList(info.pluginConfigParameter(pluginName))) { if ("STRING".equals(param.type())) { com.google.gwtexpui.globalkey.client.NpTextBox textBox = new com.google.gwtexpui.globalkey.client.NpTextBox(); textBox.setValue(param.value()); g.add(((param.displayName()) != null ? param.displayName() : param.name()), textBox); saveEnabler.listenTo(textBox); widgetMap.put(param.name(), textBox); } } } enableForm(); }



private void enableForm(boolean isOwner) { submitType.setEnabled(isOwner); state.setEnabled(isOwner); contentMerge.setEnabled(isOwner); descTxt.setEnabled(isOwner); contributorAgreements.setEnabled(isOwner); signedOffBy.setEnabled(isOwner); requireChangeID.setEnabled(isOwner); maxObjectSizeLimit.setEnabled(isOwner); }





























@java.lang.Override public int compare(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b) { return (a._number()) - (b._number()); }
public static void sortRevisionInfoByNumber(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list) { java.util.Collections.sort(com.google.gerrit.client.rpc.Natives.asList(list), new java.util.Comparator<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b) { return (a._number()) - (b._number()); } }); }







public com.google.gerrit.server.config.PluginConfig getFromGerritConfig(java.lang.String pluginName) { return new com.google.gerrit.server.config.PluginConfig(pluginName, cfg); }
@org.junit.Test public void noCopyNonMaxScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; codeReview.setCopyMinScore(true); codeReview.setCopyMaxScore(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, 1); assertApproval(r, 1); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 0); }
@org.junit.Test public void noCopyMinScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, (-2)); assertApproval(r, (-2)); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 0); }
@org.junit.Test public void revert() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(("p~master~" + (r.getChangeId()))).revision(r.getCommit().name()).review(com.google.gerrit.acceptance.api.change.ChangeIT.approve()); gApi.changes().id(("p~master~" + (r.getChangeId()))).revision(r.getCommit().name()).submit(); gApi.changes().id(("p~master~" + (r.getChangeId()))).revert(); }
@org.junit.Test public void reviewCurrent() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); }
@org.junit.Test public void cherryPick() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "foo"; in.message = "it goes to stable branch"; gApi.projects().name(project.get()).branch(in.destination).create(new com.google.gerrit.extensions.api.projects.BranchInput()); com.google.gerrit.extensions.api.changes.ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in); cApi.current().review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); cApi.current().submit(); }
@org.junit.Test public void submit() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(("p~master~" + (r.getChangeId()))).current().review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); gApi.changes().id(("p~master~" + (r.getChangeId()))).current().submit(); }
@org.junit.Test public void reviewTriplet() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(("p~master~" + (r.getChangeId()))).revision(r.getCommit().name()).review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); }
@org.junit.Test public void reviewNumber() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(1).review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); r = updateChange(r, "new content"); gApi.changes().id(r.getChangeId()).revision(2).review(com.google.gerrit.acceptance.api.revision.RevisionIT.approve()); }
@org.junit.Test public void noCopyAllScoresIfNoCodeChange() throws java.lang.Exception { java.lang.String file = "a.txt"; java.lang.String contents = "contents"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), "first subject", file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, 1); assertApproval(r, 1); push = pushFactory.create(db, user.getIdent(), "second subject", file, contents, r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 0); }
@org.junit.Test public void copyAllScoresOnTrivialRebase() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; java.lang.String contents = "contents"; codeReview.setCopyAllScoresOnTrivialRebase(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent()); com.google.gerrit.acceptance.PushOneCommit.Result r1 = push.to(git, "refs/for/master"); merge(r1); push = pushFactory.create(db, user.getIdent(), "non-conflicting", "b.txt", "other contents"); com.google.gerrit.acceptance.PushOneCommit.Result r2 = push.to(git, "refs/for/master"); merge(r2); git.checkout().setName(r1.getCommit().name()).call(); push = pushFactory.create(db, user.getIdent(), subject, file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r3 = push.to(git, "refs/for/master"); review(r3, 1); assertApproval(r3, 1); rebase(r3); assertApproval(r3, 1); }
@org.junit.Test public void noCopyAllScoresOnTrivialRebase() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; java.lang.String contents = "contents"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent()); com.google.gerrit.acceptance.PushOneCommit.Result r1 = push.to(git, "refs/for/master"); merge(r1); push = pushFactory.create(db, user.getIdent(), "non-conflicting", "b.txt", "other contents"); com.google.gerrit.acceptance.PushOneCommit.Result r2 = push.to(git, "refs/for/master"); merge(r2); git.checkout().setName(r1.getCommit().name()).call(); push = pushFactory.create(db, user.getIdent(), subject, file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r3 = push.to(git, "refs/for/master"); review(r3, 1); assertApproval(r3, 1); rebase(r3); assertApproval(r3, 0); }
@org.junit.Test public void noCopyNonMinScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; codeReview.setCopyMinScore(true); codeReview.setCopyMaxScore(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, (-1)); assertApproval(r, (-1)); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 0); }
@org.junit.Test public void noCopyMaxScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, 2); assertApproval(r, 2); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 0); }
@org.junit.Test public void copyMinScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; codeReview.setCopyMinScore(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, (-2)); assertApproval(r, (-2)); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, (-2)); }
@org.junit.Test public void copyAllScoresIfNoCodeChange() throws java.lang.Exception { java.lang.String file = "a.txt"; java.lang.String contents = "contents"; codeReview.setCopyAllScoresIfNoCodeChange(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), "first subject", file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, 1); assertApproval(r, 1); push = pushFactory.create(db, user.getIdent(), "second subject", file, contents, r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 1); }
private void merge(com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { review(r, 2); revision(r).submit(); org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project); try { assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId()); } finally { repo.close(); } }
@org.junit.Test public void copyMaxScoreOnRework() throws java.lang.Exception { java.lang.String subject = "test commit"; java.lang.String file = "a.txt"; codeReview.setCopyMaxScore(true); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), subject, file, "first contents"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); review(r, 2); assertApproval(r, 2); push = pushFactory.create(db, user.getIdent(), subject, file, "second contents", r.getChangeId()); r = push.to(git, "refs/for/master"); assertApproval(r, 2); }
public static java.io.File defaultFile(javax.servlet.FilterConfig filterConfig) { java.lang.String configPath = null; if (filterConfig != null) { configPath = filterConfig.getInitParameter(com.google.gitiles.GitilesConfig.FILTER_CONFIG_PARAM); } if (configPath == null) { configPath = java.lang.System.getProperty(com.google.gitiles.GitilesConfig.PROPERTY_NAME, com.google.gitiles.GitilesConfig.DEFAULT_PATH); } return new java.io.File(configPath); }
















private com.google.gerrit.server.project.ChangeControl control(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctrl = cd.changeControl(); if ((ctrl != null) && ((ctrl.getCurrentUser()) == (userProvider.get()))) { return ctrl; } else if (((lastControl) != null) && (cd.getId().equals(lastControl.getChange().getId()))) { return lastControl; } try { com.google.gerrit.reviewdb.client.Change change = cd.change(); if (change == null) { return null; } ctrl = projectControls.get(change.getProject()).controlFor(change); } catch (java.util.concurrent.ExecutionException e) { return null; } lastControl = ctrl; return ctrl; }
private boolean isSubmitForMissingCommitsStillPossible(final com.google.gerrit.server.git.CodeReviewCommit commit) { if (((commit.missing) == null) || (commit.missing.isEmpty())) { return false; } for (com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing) { loadChangeInfo(missingCommit); if ((missingCommit.patchsetId) == null) { return false; } if (!(missingCommit.getChange().currentPatchSetId().equals(missingCommit.patchsetId))) { return false; } } return true; }

@java.lang.Override public void evaluate() throws java.lang.Throwable { boolean mem = (description.getAnnotation(com.google.gerrit.acceptance.UseLocalDisk.class)) == null; beforeTest(config(description), mem); base.evaluate(); afterTest(); }
private void beforeTest(org.eclipse.jgit.lib.Config cfg, boolean memory) throws java.lang.Exception { server = startServer(cfg, memory); server.getTestInjector().injectMembers(this); admin = accounts.admin(); user = accounts.user(); adminSession = new com.google.gerrit.acceptance.RestSession(server, admin); userSession = new com.google.gerrit.acceptance.RestSession(server, user); com.google.gerrit.acceptance.GitUtil.initSsh(admin); db = reviewDbProvider.open(); atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(com.google.inject.util.Providers.of(db), admin.getId()))); sshSession = new com.google.gerrit.acceptance.SshSession(server, admin); project = new com.google.gerrit.reviewdb.client.Project.NameKey("p"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, project.get()); git = com.google.gerrit.acceptance.GitUtil.cloneProject((((sshSession.getUrl()) + "/") + (project.get()))); }
@java.lang.Override public org.junit.runners.model.Statement apply(final org.junit.runners.model.Statement base, final org.junit.runner.Description description) { return new org.junit.runners.model.Statement() { @java.lang.Override public void evaluate() throws java.lang.Throwable { boolean mem = (description.getAnnotation(com.google.gerrit.acceptance.UseLocalDisk.class)) == null; beforeTest(config(description), mem); base.evaluate(); afterTest(); } }; }
protected com.google.gerrit.acceptance.GerritServer startServer(org.eclipse.jgit.lib.Config cfg, boolean memory) throws java.lang.Exception { return com.google.gerrit.acceptance.GerritServer.start(cfg, memory); }


void populate(final int row, final com.google.gerrit.client.plugins.PluginInfo plugin) { if ((plugin.disabled()) || ((plugin.indexUrl()) == null)) { table.setText(row, 1, plugin.name()); } else { table.setWidget(row, 1, new com.google.gwt.user.client.ui.Anchor(plugin.name(), com.google.gerrit.client.Gerrit.selfRedirect(plugin.indexUrl()), "_blank")); } table.setText(row, 2, plugin.version()); table.setText(row, 3, (plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled())); final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); setRowItem(row, plugin); }



protected void command(final com.google.gerrit.sshd.CommandName parent, final java.lang.Class<? extends com.google.gerrit.sshd.BaseCommand> clazz) { com.google.gerrit.sshd.CommandMetaData meta = clazz.getAnnotation(com.google.gerrit.sshd.CommandMetaData.class); if (meta == null) { throw new java.lang.IllegalStateException("no CommandMetaData annotation found"); } bind(com.google.gerrit.sshd.Commands.key(parent, meta.name(), meta.description())).to(clazz); }




@org.junit.Before public void setMillisProvider() { clockStepMs = 1; final java.util.concurrent.atomic.AtomicLong clockMs = new java.util.concurrent.atomic.AtomicLong(((java.util.concurrent.TimeUnit.MILLISECONDS.convert(ChangeUtil.SORT_KEY_EPOCH_MINS, java.util.concurrent.TimeUnit.MINUTES)) + (java.util.concurrent.TimeUnit.MILLISECONDS.convert(60, java.util.concurrent.TimeUnit.DAYS)))); org.joda.time.DateTimeUtils.setCurrentMillisProvider(new org.joda.time.DateTimeUtils.MillisProvider() { @java.lang.Override public long getMillis() { return clockMs.getAndAdd(clockStepMs); } }); }


public static int toIndexTime(java.sql.Timestamp ts) { return ((int) ((ts.getTime()) / 60000)); }
protected void display(final com.google.gerrit.client.changes.ChangeList result) { changes = result; if ((changes.length()) != 0) { final com.google.gerrit.client.changes.ChangeInfo f = changes.get(0); final com.google.gerrit.client.changes.ChangeInfo l = changes.get(((changes.length()) - 1)); prev.setTargetHistoryToken((((anchorPrefix) + ",p,") + (f._sortkey()))); next.setTargetHistoryToken((((anchorPrefix) + ",n,") + (l._sortkey()))); if (useLoadPrev) { prev.setVisible(f._more_changes()); next.setVisible((!(com.google.gerrit.client.changes.PagedSingleListScreen.MIN_SORTKEY.equals(pos)))); } else { prev.setVisible((!(com.google.gerrit.client.changes.PagedSingleListScreen.MAX_SORTKEY.equals(pos)))); next.setVisible(l._more_changes()); } } table.updateColumnsForLabels(result); section.display(result); table.finishDisplay(); }
private static void query(final java.lang.String token) { final java.lang.String s = com.google.gerrit.client.Dispatcher.skip(token); final int c = s.indexOf(','); com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.QueryScreen(s.substring(0, c), s.substring((c + 1)))); }

private org.apache.lucene.search.Query timestampQuery(com.google.gerrit.server.index.IndexPredicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.index.TimestampRangePredicate) { com.google.gerrit.server.index.TimestampRangePredicate<com.google.gerrit.server.query.change.ChangeData> r = ((com.google.gerrit.server.index.TimestampRangePredicate<com.google.gerrit.server.query.change.ChangeData>) (p)); return org.apache.lucene.search.NumericRangeQuery.newIntRange(r.getField().getName(), com.google.gerrit.lucene.QueryBuilder.toIndexTime(r.getMinTimestamp()), com.google.gerrit.lucene.QueryBuilder.toIndexTime(r.getMaxTimestamp()), true, true); } throw new com.google.gerrit.server.query.QueryParseException(("not a timestamp: " + p)); }

private static void build(java.io.File root, java.io.File gen, java.lang.String target) throws com.google.gerrit.pgm.http.jetty.JettyServer.BuildFailureException, java.io.IOException { com.google.gerrit.pgm.http.jetty.JettyServer.log.info(("buck build " + target)); java.util.Properties properties = com.google.gerrit.pgm.http.jetty.JettyServer.loadBuckProperties(gen); java.lang.String buck = com.google.common.base.Objects.firstNonNull(properties.getProperty("buck"), "buck"); java.lang.ProcessBuilder proc = new java.lang.ProcessBuilder(buck, "build", target).directory(root).redirectErrorStream(true); if (properties.containsKey("PATH")) { proc.environment().put("PATH", properties.getProperty("PATH")); } long start = com.google.gerrit.server.util.TimeUtil.nowMs(); java.lang.Process rebuild = proc.start(); byte[] out; java.io.InputStream in = rebuild.getInputStream(); try { out = com.google.common.io.ByteStreams.toByteArray(in); } finally { rebuild.getOutputStream().close(); in.close(); } int status; try { status = rebuild.waitFor(); } catch (java.lang.InterruptedException e) { throw new java.io.InterruptedIOException(("interrupted waiting for " + buck)); } if (status != 0) { throw new com.google.gerrit.pgm.http.jetty.JettyServer.BuildFailureException(out); } long time = (com.google.gerrit.server.util.TimeUtil.nowMs()) - start; com.google.gerrit.pgm.http.jetty.JettyServer.log.info(java.lang.String.format("UPDATED %s in %.3fs", target, (time / 1000.0))); }
public void run() throws java.io.IOException { ui.header("Index"); com.google.gerrit.server.index.IndexModule.IndexType type = index.select("Type", "type", IndexType.LUCENE); if ((site.isNew) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { createLuceneIndex(); } else { final java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }

java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sort(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> incoming) throws java.io.IOException { final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = new java.util.ArrayList<com.google.gerrit.server.git.CodeReviewCommit>(); final java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> sort = new java.util.HashSet<com.google.gerrit.server.git.CodeReviewCommit>(incoming); while (!(sort.isEmpty())) { final com.google.gerrit.server.git.CodeReviewCommit n = com.google.gerrit.server.git.RebaseSorter.removeOne(sort); rw.resetRetain(canMergeFlag); rw.markStart(n); for (org.eclipse.jgit.revwalk.RevCommit c : accepted) { rw.markUninteresting(c); } com.google.gerrit.server.git.CodeReviewCommit c; final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> contents = new java.util.ArrayList<com.google.gerrit.server.git.CodeReviewCommit>(); while ((c = ((com.google.gerrit.server.git.CodeReviewCommit) (rw.next()))) != null) { if ((!(c.has(canMergeFlag))) || (!(incoming.contains(c)))) { if ((n.missing) == null) { n.statusCode = CommitMergeStatus.MISSING_DEPENDENCY; n.missing = new java.util.ArrayList<com.google.gerrit.server.git.CodeReviewCommit>(); } n.missing.add(c); } else { contents.add(c); } } if ((n.statusCode) == (CommitMergeStatus.MISSING_DEPENDENCY)) { continue; } sort.removeAll(contents); java.util.Collections.reverse(contents); sorted.removeAll(contents); sorted.addAll(contents); } return sorted; }

private void setMerged(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.ChangeMessage msg) throws com.google.gwtorm.server.OrmException, java.io.IOException { try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change().currentPatchSetId(); c = setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged); addMergedMessage(submitter, msg); db.commit(); sendMergedEmail(c, submitter); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db); } catch (com.google.gwtorm.server.OrmException ex) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } } finally { db.rollback(); } indexer.index(db, c); }
void copyFrom(final com.google.gerrit.server.git.CodeReviewCommit src) { control = src.control; patchsetId = src.patchsetId; originalOrder = src.originalOrder; statusCode = src.statusCode; missing = src.missing; }
public com.google.gerrit.reviewdb.client.PatchSetApproval markCleanMerges(final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.revwalk.RevFlag canMergeFlag, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted) throws com.google.gerrit.server.git.MergeException { if (mergeTip == null) { return null; } try { com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = null; rw.resetRetain(canMergeFlag); rw.sort(RevSort.TOPO); rw.sort(RevSort.REVERSE, true); rw.markStart(mergeTip); for (org.eclipse.jgit.revwalk.RevCommit c : alreadyAccepted) { rw.markUninteresting(c); } com.google.gerrit.server.git.CodeReviewCommit c; while ((c = ((com.google.gerrit.server.git.CodeReviewCommit) (rw.next()))) != null) { if ((c.patchsetId) != null) { c.statusCode = CommitMergeStatus.CLEAN_MERGE; if (submitApproval == null) { submitApproval = getSubmitter(c); } } } return submitApproval; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot mark clean merges", e); } }
private void runImpl() throws java.io.IOException { org.eclipse.jgit.transport.Transport tn = org.eclipse.jgit.transport.Transport.open(git, uri); org.eclipse.jgit.transport.PushResult res; try { res = pushVia(tn); } finally { try { tn.close(); } catch (java.lang.Throwable e2) { com.googlesource.gerrit.plugins.replication.PushOne.log.warn(("Unexpected error while closing " + (uri)), e2); } } for (org.eclipse.jgit.transport.RemoteRefUpdate u : res.getRemoteUpdates()) { switch (u.getStatus()) { case OK : case UP_TO_DATE : case NON_EXISTING : break; case NOT_ATTEMPTED : case AWAITING_REPORT : case REJECTED_NODELETE : case REJECTED_NONFASTFORWARD : case REJECTED_REMOTE_CHANGED : com.googlesource.gerrit.plugins.replication.PushOne.log.error(java.lang.String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus())); break; case REJECTED_OTHER_REASON : if ("non-fast-forward".equals(u.getMessage())) { com.googlesource.gerrit.plugins.replication.PushOne.log.error(java.lang.String.format(("Failed replicate of %s to %s" + ((", remote rejected non-fast-forward push." + " Check receive.denyNonFastForwards variable in config file") + " of destination repository.")), u.getRemoteName(), uri)); } else { com.googlesource.gerrit.plugins.replication.PushOne.log.error(java.lang.String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage())); } break; } } }
@org.junit.Test public void approvalsCommitFormat() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putApproval("Code-Review", ((short) (-1))); update.putApproval("Verified", ((short) (1))); update.putReviewer(changeOwner.getAccount().getId(), com.google.gerrit.server.notedb.ReviewerState.REVIEWER); update.putReviewer(otherUser.getAccount().getId(), com.google.gerrit.server.notedb.ReviewerState.CC); commit(update); assertEquals("refs/changes/01/1/meta", update.getRefName()); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = walk.parseCommit(update.getRevision()); walk.parseBody(commit); assertEquals(("Update patch set 1\n" + ((((("\n" + "Patch-Set: 1\n") + "Reviewer: Change Owner <1@gerrit>\n") + "CC: Other Account <2@gerrit>\n") + "Label: Verified=+1\n") + "Label: Code-Review=-1\n")), commit.getFullMessage()); org.eclipse.jgit.lib.PersonIdent author = commit.getAuthorIdent(); assertEquals("Change Owner", author.getName()); assertEquals("change@owner.com", author.getEmailAddress()); assertEquals(new java.util.Date(((c.getCreatedOn().getTime()) + 1000)), author.getWhen()); assertEquals(java.util.TimeZone.getTimeZone("GMT-8:00"), author.getTimeZone()); org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); assertEquals("Change Owner", committer.getName()); assertEquals("1@gerrit", committer.getEmailAddress()); assertEquals(author.getWhen(), committer.getWhen()); assertEquals(author.getTimeZone(), committer.getTimeZone()); } finally { walk.release(); } }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = getRevision(); if (rev == null) { return; } org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(reader); try { com.google.gerrit.server.notedb.ChangeNotes.Parser parser = new com.google.gerrit.server.notedb.ChangeNotes.Parser(change.getId(), rev, walk); parser.parseAll(); approvals = com.google.common.collect.ImmutableListMultimap.copyOf(parser.approvals); ImmutableSetMultimap.Builder<com.google.gerrit.server.notedb.ReviewerState, com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.ImmutableSetMultimap.builder(); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.notedb.ReviewerState> e : parser.reviewers.entrySet()) { reviewers.put(e.getValue(), e.getKey()); } this.reviewers = reviewers.build(); } finally { walk.release(); } }





public org.eclipse.jgit.lib.PersonIdent newIdent(com.google.gerrit.reviewdb.client.Account author) { return new org.eclipse.jgit.lib.PersonIdent(author.getFullName(), (((author.getId().get()) + "@") + (com.google.gerrit.server.notedb.ChangeNoteUtil.GERRIT_PLACEHOLDER_HOST)), when, tz); }

@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.server.plugins.InstallPlugin create(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { return new com.google.gerrit.server.plugins.InstallPlugin(loader, id.get(), true); }
public void disablePlugins(java.util.Set<java.lang.String> names) { synchronized(this) { for (java.lang.String name : names) { com.google.gerrit.server.plugins.Plugin active = running.get(name); if (active == null) { continue; } com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Disabling plugin %s", active.getName())); java.io.File off = new java.io.File(((active.getSrcFile()) + ".disabled")); active.getSrcFile().renameTo(off); unloadPlugin(active); try { org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot = org.eclipse.jgit.internal.storage.file.FileSnapshot.save(off); com.google.gerrit.server.plugins.Plugin offPlugin = loadPlugin(name, off, snapshot); disabled.put(name, offPlugin); } catch (java.lang.Throwable e) { com.google.gerrit.server.plugins.PluginLoader.log.warn(java.lang.String.format("Cannot load disabled plugin %s", active.getName()), e.getCause()); } } cleanInBackground(); } }


@java.lang.Override protected void run() { if (((names) != null) && (!(names.isEmpty()))) { loader.disablePlugins(com.google.common.collect.Sets.newHashSet(names)); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { if (((names) != null) && (!(names.isEmpty()))) { try { loader.enablePlugins(com.google.common.collect.Sets.newHashSet(names)); } catch (com.google.gerrit.server.plugins.PluginInstallException e) { e.printStackTrace(stderr); throw die("plugin failed to enable"); } } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { if (com.google.common.base.Strings.isNullOrEmpty(source)) { throw die("Argument \"-|URL\" is required"); } if ((com.google.common.base.Strings.isNullOrEmpty(name)) && ("-".equalsIgnoreCase(source))) { throw die("--name required when source is stdin"); } if (com.google.common.base.Strings.isNullOrEmpty(name)) { int s = source.lastIndexOf('/'); if (0 <= s) { name = source.substring((s + 1)); } else { name = source; } } java.io.InputStream data; if ("-".equalsIgnoreCase(source)) { data = in; } else if ((new java.io.File(source).isFile()) && (source.equals(new java.io.File(source).getAbsolutePath()))) { try { data = new java.io.FileInputStream(new java.io.File(source)); } catch (java.io.FileNotFoundException e) { throw die(("cannot read " + (source))); } } else { try { data = new java.net.URL(source).openStream(); } catch (java.net.MalformedURLException e) { throw die(("invalid url " + (source))); } catch (java.io.IOException e) { throw die(("cannot read " + (source))); } } try { loader.installPluginFromStream(name, data); } catch (java.io.IOException e) { throw die("cannot install plugin"); } catch (com.google.gerrit.server.plugins.PluginInstallException e) { e.printStackTrace(stderr); java.lang.String msg = java.lang.String.format("Plugin failed to install. Cause: %s", e.getMessage()); throw die(msg); } finally { try { data.close(); } catch (java.io.IOException err) { } } }
@java.lang.Override public com.google.gerrit.server.plugins.ListPlugins.PluginInfo apply(com.google.gerrit.server.plugins.PluginResource resource, com.google.gerrit.server.plugins.EnablePlugin.Input input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { java.lang.String name = resource.getName(); try { loader.enablePlugins(com.google.common.collect.ImmutableSet.of(name)); } catch (com.google.gerrit.server.plugins.PluginInstallException e) { java.io.StringWriter buf = new java.io.StringWriter(); buf.write(java.lang.String.format("cannot enable %s\n", name)); java.io.PrintWriter pw = new java.io.PrintWriter(buf); e.printStackTrace(pw); pw.flush(); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(buf.toString()); } return new com.google.gerrit.server.plugins.ListPlugins.PluginInfo(loader.get(name)); }
public void enablePlugins(java.util.Set<java.lang.String> names) throws com.google.gerrit.server.plugins.PluginInstallException { synchronized(this) { for (java.lang.String name : names) { com.google.gerrit.server.plugins.Plugin off = disabled.get(name); if (off == null) { continue; } com.google.gerrit.server.plugins.PluginLoader.log.info(java.lang.String.format("Enabling plugin %s", name)); java.lang.String n = off.getSrcFile().getName(); if (n.endsWith(".disabled")) { n = n.substring(0, n.lastIndexOf('.')); } java.io.File on = new java.io.File(pluginsDir, n); off.getSrcFile().renameTo(on); disabled.remove(name); runPlugin(name, on, null); } cleanInBackground(); } }
@java.lang.Override public com.google.gerrit.server.plugins.ListPlugins.PluginInfo apply(com.google.gerrit.server.plugins.PluginResource resource, com.google.gerrit.server.plugins.DisablePlugin.Input input) { java.lang.String name = resource.getName(); loader.disablePlugins(com.google.common.collect.ImmutableSet.of(name)); return new com.google.gerrit.server.plugins.ListPlugins.PluginInfo(loader.get(name)); }
@org.junit.Before public void setUp() throws java.lang.Exception { project = new com.google.gerrit.reviewdb.client.Project.NameKey("p"); com.google.gerrit.acceptance.SshSession sshSession = new com.google.gerrit.acceptance.SshSession(server, admin); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, project.get()); git = com.google.gerrit.acceptance.GitUtil.cloneProject((((sshSession.getUrl()) + "/") + (project.get()))); db = reviewDbProvider.open(); atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(com.google.inject.util.Providers.of(db), admin.getId()))); }


private void doSave() { com.googlesource.gerrit.plugins.serviceuser.client.ConfigInfo in = com.googlesource.gerrit.plugins.serviceuser.client.ConfigInfo.create(); in.setInfoMessage(infoMsgTxt.getValue()); in.setOnSuccessMessage(onSuccessMsgTxt.getValue()); in.setAllowEmail(allowEmailCheckBox.getValue()); new com.google.gerrit.plugin.client.rpc.RestApi("config").id("server").view(com.google.gerrit.plugin.client.Plugin.get().getPluginName(), "config").put(in, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { saveButton.setEnabled(false); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
private com.google.gerrit.server.change.RevisionResource onBehalfOf(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl caller = rsrc.getControl(); if (!(caller.canSubmit())) { throw new com.google.gerrit.extensions.restapi.AuthException("submit not permitted"); } if (!(caller.canSubmitAs())) { throw new com.google.gerrit.extensions.restapi.AuthException("submit on behalf of not permitted"); } com.google.gerrit.server.project.ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf)); return new com.google.gerrit.server.change.RevisionResource(changes.parse(target), rsrc.getPatchSet()); }




public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.server.account.PutName.Input input) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (!(realm.allowsEdit(FieldName.FULL_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing name"); } if (input == null) { input = new com.google.gerrit.server.account.PutName.Input(); } com.google.gerrit.reviewdb.client.Account a = dbProvider.get().accounts().get(user.getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } a.setFullName(input.name); dbProvider.get().accounts().update(java.util.Collections.singleton(a)); byIdCache.evict(a.getId()); return com.google.common.base.Strings.isNullOrEmpty(a.getFullName()) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(a.getFullName()); }
public static java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> listPlugins(com.google.gerrit.server.config.SitePaths site) throws java.io.IOException { return com.google.gerrit.pgm.init.InitPlugins.listPlugins(site, false); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.util.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); java.util.List<java.lang.String> plugins = com.google.common.base.Objects.firstNonNull(getInstallPlugins(), com.google.common.collect.Lists.<java.lang.String>newArrayList()); bind(new com.google.inject.TypeLiteral<java.util.List<java.lang.String>>() {}).annotatedWith(com.google.gerrit.pgm.init.InstallPlugins.class).toInstance(plugins); }
public void init() { try { if ((sitePath) != null) { java.io.File site = new java.io.File(sitePath); com.google.gerrit.httpd.SiteInitializer.LOG.info(java.lang.String.format("Initializing site at %s", site.getAbsolutePath())); new com.google.gerrit.pgm.BaseInit(site, false).run(); return; } java.sql.Connection conn = connectToDb(); try { java.io.File site = getSiteFromReviewDb(conn); if ((site == null) && ((initPath) != null)) { site = new java.io.File(initPath); } if (site != null) { com.google.gerrit.httpd.SiteInitializer.LOG.info(java.lang.String.format("Initializing site at %s", site.getAbsolutePath())); new com.google.gerrit.pgm.BaseInit(site, new com.google.gerrit.httpd.ReviewDbDataSourceProvider(), false).run(); } } finally { conn.close(); } } catch (java.lang.Exception e) { com.google.gerrit.httpd.SiteInitializer.LOG.error("Site init failed", e); throw new java.lang.RuntimeException(e); } }
protected java.util.List<java.lang.String> getInstallPlugins() { return null; }
public static java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> listPluginsAndRemoveTempFiles(com.google.gerrit.server.config.SitePaths site) throws java.io.IOException { return com.google.gerrit.pgm.init.InitPlugins.listPlugins(site, true); }
private void installPlugins() throws java.io.IOException { java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPlugins(site); for (com.google.gerrit.pgm.init.InitPlugins.PluginData plugin : plugins) { java.lang.String pluginName = plugin.name; try { final java.io.File tmpPlugin = plugin.pluginFile; if (!((initFlags.installPlugins.contains(pluginName)) || (ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version)))) { tmpPlugin.delete(); continue; } final java.io.File p = new java.io.File(site.plugins_dir, ((plugin.name) + ".jar")); if (p.exists()) { final java.lang.String installedPluginVersion = com.google.gerrit.pgm.init.InitPlugins.getVersion(p); if (!(ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion))) { tmpPlugin.delete(); continue; } if (!(p.delete())) { throw new java.io.IOException(((("Failed to delete plugin " + pluginName) + ": ") + (p.getAbsolutePath()))); } } if (!(tmpPlugin.renameTo(p))) { throw new java.io.IOException(((((("Failed to install plugin " + pluginName) + ": ") + (tmpPlugin.getAbsolutePath())) + " -> ") + (p.getAbsolutePath()))); } } finally { if (plugin.pluginFile.exists()) { plugin.pluginFile.delete(); } } } if (plugins.isEmpty()) { ui.message("No plugins found."); } }
@java.lang.Override protected boolean beforeInit(com.google.gerrit.pgm.SiteInit init) throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); if (!(skipPlugins)) { final java.util.List<com.google.gerrit.pgm.init.InitPlugins.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPluginsAndRemoveTempFiles(init.site); com.google.gerrit.pgm.util.ConsoleUI ui = com.google.gerrit.pgm.util.ConsoleUI.getInstance(false); verifyInstallPluginList(ui, plugins); if (listPlugins) { if (!(plugins.isEmpty())) { ui.message("Available plugins:\n"); for (com.google.gerrit.pgm.init.InitPlugins.PluginData plugin : plugins) { ui.message(" * %s version %s\n", plugin.name, plugin.version); } } else { ui.message("No plugins found.\n"); } return true; } } return false; }
protected java.util.List<java.lang.String> getInstallPlugins() { java.io.File root; try { root = distroLocator.locate(); } catch (java.io.FileNotFoundException e) { com.google.gerrit.pgm.BaseInit.log.warn(("Couldn't open folder containing plugins." + " No plugin will be installed")); return null; } java.util.ArrayList<java.lang.String> result = com.google.common.collect.Lists.newArrayList(); java.io.File plugins = new java.io.File(root, com.google.gerrit.pgm.init.InitPlugins.PLUGIN_DIR); for (java.io.File p : plugins.listFiles()) { java.lang.String pluginJarName = p.getName(); java.lang.String pluginName = pluginJarName.substring(0, ((pluginJarName.length()) - (InitPlugins.JAR.length()))); result.add(pluginName); } return result; }
public void init() { try { if ((sitePath) != null) { java.io.File site = new java.io.File(sitePath); com.google.gerrit.httpd.SiteInitializer.LOG.info(java.lang.String.format("Initializing site at %s", site.getAbsolutePath())); new com.google.gerrit.pgm.BaseInit(site, false, distroLocator).run(); return; } java.sql.Connection conn = connectToDb(); try { java.io.File site = getSiteFromReviewDb(conn); if ((site == null) && ((initPath) != null)) { site = new java.io.File(initPath); } if (site != null) { com.google.gerrit.httpd.SiteInitializer.LOG.info(java.lang.String.format("Initializing site at %s", site.getAbsolutePath())); new com.google.gerrit.pgm.BaseInit(site, new com.google.gerrit.httpd.ReviewDbDataSourceProvider(), false, distroLocator).run(); } } finally { conn.close(); } } catch (java.lang.Exception e) { com.google.gerrit.httpd.SiteInitializer.LOG.error("Site init failed", e); throw new java.lang.RuntimeException(e); } }

private void setLabelScores(com.google.gerrit.common.data.LabelType type, com.google.gerrit.server.change.ChangeJson.LabelInfo label, short score, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { if (((label.approved) != null) || ((label.rejected) != null)) { return; } if (((type.getMin()) == null) || ((type.getMax()) == null)) { return; } if (score != 0) { if (score == (type.getMin().getValue())) { label.rejected = accountLoader.get(accountId); } else if (score == (type.getMax().getValue())) { label.approved = accountLoader.get(accountId); } else if (score < 0) { label.disliked = accountLoader.get(accountId); label.value = score; } else if ((score > 0) && ((label.disliked) == null)) { label.recommended = accountLoader.get(accountId); label.value = score; } } return; }

private void initPluginOptions(com.google.gerrit.client.projects.ConfigInfo info) { pluginOptionsPanel.clear(); pluginConfigWidgets = new java.util.HashMap(); for (java.lang.String pluginName : info.pluginConfig().keySet()) { java.util.Map<java.lang.String, com.google.gwt.user.client.ui.FocusWidget> widgetMap = new java.util.HashMap<>(); pluginConfigWidgets.put(pluginName, widgetMap); com.google.gerrit.client.admin.ProjectInfoScreen.LabeledWidgetsGrid g = new com.google.gerrit.client.admin.ProjectInfoScreen.LabeledWidgetsGrid(); g.addHeader(new com.google.gerrit.client.ui.SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName))); pluginOptionsPanel.add(g); com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.projects.ConfigInfo.ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName); pluginConfig.copyKeysIntoChildren("name"); for (com.google.gerrit.client.projects.ConfigInfo.ConfigParameterInfo param : com.google.gerrit.client.rpc.Natives.asList(pluginConfig.values())) { com.google.gwt.user.client.ui.FocusWidget w; if ("STRING".equals(param.type())) { w = renderTextBox(g, param, false); } else if (("INT".equals(param.type())) || ("LONG".equals(param.type()))) { w = renderTextBox(g, param, true); } else if ("BOOLEAN".equals(param.type())) { w = renderCheckBox(g, param); } else if (("LIST".equals(param.type())) && ((param.permittedValues()) != null)) { w = renderListBox(g, param); } else { continue; } if (param.editable()) { widgetMap.put(param.name(), w); } else { w.setEnabled(false); } } } enableForm(); }






public boolean canCreate(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevObject object) { if (!(canWrite())) { return false; } boolean owner; switch (getCurrentUser().getAccessPath()) { case REST_API : case JSON_RPC : owner = isOwner(); break; default : owner = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { return ((getCurrentUser().getCapabilities().canAdministrateServer()) || (owner && (!(isBlocked(Permission.CREATE))))) || ((canPerform(Permission.CREATE)) && (projectControl.canReadCommit(rw, ((org.eclipse.jgit.revwalk.RevCommit) (object))))); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if (getCurrentUser().isIdentifiedUser()) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); final java.lang.String addr = tagger.getEmailAddress(); valid = user.getEmailAddresses().contains(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.PUSH_SIGNED_TAG)); } else { return owner || (canPerform(Permission.PUSH_TAG)); } } else { return false; } }
@java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { if (zip) { java.util.zip.ZipOutputStream zos = new java.util.zip.ZipOutputStream(out); java.util.zip.ZipEntry e = new java.util.zip.ZipEntry(com.google.gerrit.server.change.GetPatch.fileName(rw, commit)); e.setTime(((commit.getCommitTime()) * 1000L)); zos.putNextEntry(e); format(zos); zos.closeEntry(); zos.finish(); } else { format(out); } }
private void insertPatch() { java.lang.String id = revision.substring(0, 7); com.google.gwt.user.client.ui.Anchor patchBase64 = new com.google.gwt.user.client.ui.Anchor((id + ".diff.base64")); patchBase64.setHref(new com.google.gerrit.client.rpc.RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url()); com.google.gwt.user.client.ui.Anchor patchZip = new com.google.gwt.user.client.ui.Anchor((id + ".diff.zip")); patchZip.setHref(new com.google.gerrit.client.rpc.RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url()); com.google.gwt.user.client.ui.HorizontalPanel p = new com.google.gwt.user.client.ui.HorizontalPanel(); p.add(patchBase64); com.google.gwt.user.client.ui.InlineLabel spacer = new com.google.gwt.user.client.ui.InlineLabel("|"); spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer()); p.add(spacer); p.add(patchZip); insertCommand("Patch-File", p); }


private void setLabelScores(com.google.gerrit.common.data.LabelType type, com.google.gerrit.server.change.ChangeJson.LabelInfo label, short score, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { if (((label.approved) != null) || ((label.rejected) != null)) { return; } if (((type.getMin()) == null) || ((type.getMax()) == null)) { return; } if (score != 0) { if (score == (type.getMin().getValue())) { label.rejected = accountLoader.get(accountId); } else if (score == (type.getMax().getValue())) { label.approved = accountLoader.get(accountId); } else if (score < 0) { label.disliked = accountLoader.get(accountId); label.value = score; } else if ((score > 0) && ((label.disliked) == null)) { label.recommended = accountLoader.get(accountId); label.value = score; } } }
void render(com.google.gerrit.client.diff.DiffInfo diff) { chunks = new java.util.ArrayList(); markers = new java.util.ArrayList(); undo = new java.util.ArrayList<>(); padding = new java.util.ArrayList(); java.lang.String diffColor = (((diff.meta_a()) == null) || ((diff.meta_b()) == null)) ? DiffTable.style.intralineBg() : DiffTable.style.diff(); for (com.google.gerrit.client.diff.DiffInfo.Region current : com.google.gerrit.client.rpc.Natives.asList(diff.content())) { if ((current.ab()) != null) { mapper.appendCommon(current.ab().length()); } else if ((current.skip()) > 0) { mapper.appendCommon(current.skip()); } else if (current.common()) { mapper.appendCommon(current.b().length()); } else { render(current, diffColor); } } }
private void render(com.google.gerrit.client.diff.DiffInfo.Region region, java.lang.String diffColor) { int startA = mapper.getLineA(); int startB = mapper.getLineB(); com.google.gwt.core.client.JsArrayString a = region.a(); com.google.gwt.core.client.JsArrayString b = region.b(); int aLen = (a != null) ? a.length() : 0; int bLen = (b != null) ? b.length() : 0; java.lang.String color = ((a == null) || (b == null)) ? diffColor : DiffTable.style.intralineBg(); colorLines(cmA, color, startA, aLen); colorLines(cmB, color, startB, bLen); markEdit(cmA, startA, a, region.edit_a()); markEdit(cmB, startB, b, region.edit_b()); addPadding(cmA, ((startA + aLen) - 1), (bLen - aLen)); addPadding(cmB, ((startB + bLen) - 1), (aLen - bLen)); addGutterTag(region, startA, startB); mapper.appendReplace(aLen, bLen); int endA = (mapper.getLineA()) - 1; int endB = (mapper.getLineB()) - 1; if (aLen > 0) { addDiffChunk(cmB, endB, endA, aLen, (bLen > 0)); } if (bLen > 0) { addDiffChunk(cmA, endA, endB, bLen, (aLen > 0)); } }
private void markEdit(net.codemirror.lib.CodeMirror cm, int startLine, com.google.gwt.core.client.JsArrayString lines, com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Span> edits) { if ((lines == null) || (edits == null)) { return; } com.google.gerrit.client.diff.EditIterator iter = new com.google.gerrit.client.diff.EditIterator(lines, startLine); net.codemirror.lib.Configuration bg = net.codemirror.lib.Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true); net.codemirror.lib.Configuration diff = net.codemirror.lib.Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true); net.codemirror.lib.LineCharacter last = net.codemirror.lib.CodeMirror.pos(0, 0); for (com.google.gerrit.client.diff.DiffInfo.Span span : com.google.gerrit.client.rpc.Natives.asList(edits)) { net.codemirror.lib.LineCharacter from = iter.advance(span.skip()); net.codemirror.lib.LineCharacter to = iter.advance(span.mark()); if ((from.getLine()) == (last.getLine())) { markers.add(cm.markText(last, from, bg)); } else { markers.add(cm.markText(net.codemirror.lib.CodeMirror.pos(from.getLine(), 0), from, bg)); } markers.add(cm.markText(from, to, diff)); last = to; colorLines(cm, LineClassWhere.BACKGROUND, DiffTable.style.diff(), from.getLine(), to.getLine()); } }

public static com.google.gerrit.server.util.LabelVote parse(java.lang.String text) { checkArgument((!(com.google.common.base.Strings.isNullOrEmpty(text))), "Empty label vote"); if ((text.charAt(0)) == '-') { return new com.google.gerrit.server.util.LabelVote(text.substring(1), ((short) (0))); } short sign = 0; int i; for (i = (text.length()) - 1; i >= 0; i--) { int c = text.charAt(i); if (c == '-') { sign = ((short) (-1)); break; } else if (c == '+') { sign = ((short) (1)); break; } else if (!(('0' <= c) && (c <= '9'))) { break; } } if (sign == 0) { return new com.google.gerrit.server.util.LabelVote(text, ((short) (1))); } return new com.google.gerrit.server.util.LabelVote(text.substring(0, i), ((short) (sign * (java.lang.Short.parseShort(text.substring((i + 1))))))); }
final java.util.List<com.google.gwtexpui.safehtml.client.FindReplace> commentlinks() { com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.ConfigInfo.CommentLinkInfo> cls = commentlinks0().values(); java.util.List<com.google.gwtexpui.safehtml.client.FindReplace> commentLinks = new java.util.ArrayList(cls.length()); for (int i = 0; i < (cls.length()); i++) { com.google.gerrit.client.projects.ConfigInfo.CommentLinkInfo cl = cls.get(i); if (!(cl.enabled())) { continue; } if ((cl.link()) != null) { commentLinks.add(new com.google.gwtexpui.safehtml.client.LinkFindReplace(cl.match(), cl.link())); } else { commentLinks.add(new com.google.gwtexpui.safehtml.client.RawFindReplace(cl.match(), cl.html())); } } return commentLinks; }
private com.google.gerrit.reviewdb.client.ChangeMessage buildChangeMessage(com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.reviewdb.client.Change dest) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.ChangeMessage cmsg = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(patchSetId.getParentKey(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), currentUser.getAccountId(), com.google.gerrit.server.util.TimeUtil.nowTs(), patchSetId); java.lang.StringBuilder msgBuf = new java.lang.StringBuilder((("Patch Set " + (patchSetId.get())) + ": Cherry Picked")); msgBuf.append("\n\n"); msgBuf.append(("This patchset was cherry picked to change: " + (dest.getKey().get()))); cmsg.setMessage(msgBuf.toString()); return cmsg; }


@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { if (((names) == null) || (names.isEmpty())) { loader.rescan(); } else { try { loader.reload(names); } catch (com.google.gerrit.server.plugins.InvalidPluginException e) { throw die(e.getMessage()); } catch (com.google.gerrit.server.plugins.PluginInstallException e) { throw die(e.getMessage()); } } }



@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.validators.ProjectCreationValidationListener.class).to(com.googlesource.gerrit.plugins.quota.MaxRepositoriesQuotaValidator.class); }
private static void addExtensionLink(com.google.gerrit.client.ui.LinkMenuBar m, com.google.gerrit.client.extensions.TopMenuItem item) { com.google.gwt.user.client.ui.Anchor atag = com.google.gerrit.client.Gerrit.anchor(item.getName(), com.google.gerrit.client.Gerrit.selfRedirect(item.getUrl())); atag.setTarget(item.getTarget()); if ((item.getId()) != null) { atag.getElement().setAttribute("id", item.getId()); } m.add(atag); }

@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevObject obj = rw.peel(rw.parseAny(view.getRevision().getId())); org.eclipse.jgit.revwalk.RevTree root; switch (obj.getType()) { case OBJ_COMMIT : root = ((org.eclipse.jgit.revwalk.RevCommit) (obj)).getTree(); break; case OBJ_TREE : root = ((org.eclipse.jgit.revwalk.RevTree) (obj)); break; default : res.setStatus(com.google.gitiles.SC_NOT_FOUND); return; } org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(rw.getObjectReader()); tw.addTree(root); tw.setRecursive(false); com.google.gitiles.PathServlet.FileType type; java.lang.String path = view.getPathPart(); java.util.List<java.lang.Boolean> hasSingleTree; if (path.isEmpty()) { type = com.google.gitiles.PathServlet.FileType.TREE; hasSingleTree = com.google.common.collect.ImmutableList.<java.lang.Boolean>of(); } else { hasSingleTree = walkToPath(tw, path); if (hasSingleTree == null) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); return; } type = com.google.gitiles.PathServlet.FileType.forEntry(tw); } switch (type) { case TREE : org.eclipse.jgit.lib.ObjectId treeId; if (path.isEmpty()) { treeId = root; } else { treeId = tw.getObjectId(0); tw.enterSubtree(); tw.setRecursive(false); } showTree(req, res, rw, tw, treeId, hasSingleTree); break; case SYMLINK : showSymlink(req, res, rw, tw, hasSingleTree); break; case REGULAR_FILE : case EXECUTABLE_FILE : showFile(req, res, rw, tw, hasSingleTree); break; case GITLINK : showGitlink(req, res, tw, root); break; default : com.google.gitiles.PathServlet.log.error("Bad file type: {}", type); res.setStatus(com.google.gitiles.SC_NOT_FOUND); break; } } catch (org.eclipse.jgit.errors.LargeObjectException e) { res.setStatus(com.google.gitiles.SC_INTERNAL_SERVER_ERROR); } finally { rw.release(); } }

static com.google.gitiles.CommitJsonData.Commit toJsonData(org.eclipse.jgit.revwalk.RevCommit c, org.eclipse.jgit.util.GitDateFormatter df) { com.google.gitiles.CommitJsonData.Commit result = new com.google.gitiles.CommitJsonData.Commit(); result.commit = c.name(); result.parents = com.google.common.collect.Lists.newArrayListWithCapacity(c.getParentCount()); for (org.eclipse.jgit.revwalk.RevCommit parent : c.getParents()) { result.parents.add(parent.name()); } result.author = com.google.gitiles.CommitJsonData.toJsonData(c.getAuthorIdent(), df); result.committer = com.google.gitiles.CommitJsonData.toJsonData(c.getCommitterIdent(), df); result.message = c.getFullMessage(); return result; }


public com.google.gitiles.CommitSoyData setLinkifier(com.google.gitiles.Linkifier linkifier) { this.linkifier = checkNotNull(linkifier, "linkifier"); return this; }
public com.google.gitiles.CommitSoyData setRevWalk(org.eclipse.jgit.revwalk.RevWalk walk) { this.walk = checkNotNull(walk, "walk"); return this; }
public com.google.gitiles.CommitSoyData setArchiveFormat(com.google.gitiles.ArchiveFormat archiveFormat) { this.archiveFormat = checkNotNull(archiveFormat, "archiveFormat"); return this; }




private java.lang.String getScopesKey(javax.servlet.http.HttpServletRequest request) { java.lang.String scopeRequested = request.getParameter("scope"); return com.google.common.base.Objects.firstNonNull(scopeRequested, "scopes"); }



@java.lang.SuppressWarnings({ "unchecked", "cast" }) @java.lang.Override public <K, V> com.google.common.cache.Cache<K, V> build(com.google.gerrit.server.cache.CacheBinding<K, V> def) { com.google.common.base.Preconditions.checkState((!(started)), "cache must be built before start"); long limit = config.getLong("cache", def.name(), "diskLimit", (128 << 20)); if (((cacheDir) == null) || (limit <= 0)) { return defaultFactory.build(def); } com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit); com.google.gerrit.server.cache.h2.H2CacheImpl<K, V> cache = new com.google.gerrit.server.cache.h2.H2CacheImpl<K, V>(executor, store, def.keyType(), ((com.google.common.cache.Cache<K, com.google.gerrit.server.cache.h2.H2CacheImpl.ValueHolder<V>>) (defaultFactory.create(def, true).build()))); caches.add(cache); return cache; }
private static com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> callback(final java.lang.String target) { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject msg) { if (com.google.gerrit.client.rpc.NativeString.is(msg)) { com.google.gerrit.client.rpc.NativeString str = ((com.google.gerrit.client.rpc.NativeString) (msg)); if (!(str.asString().isEmpty())) { com.google.gwt.user.client.Window.alert(str.asString()); } } com.google.gerrit.client.Gerrit.display(target); } }; }




public void setHttpInjector(com.google.inject.Injector injector) { httpModule = copy(injector); httpGen = injector.getProvider(com.google.gerrit.server.plugins.ModuleGenerator.class); httpSets = dynamicSetsOf(injector); httpMaps = dynamicMapsOf(injector); onStart.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.StartPluginListener.class)); onReload.addAll(com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners(injector, com.google.gerrit.server.plugins.ReloadPluginListener.class)); }

void set(com.google.gerrit.client.ui.CommentLinkProcessor commentLinkProcessor, com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = change.revision(revision); com.google.gerrit.client.changes.ChangeInfo.CommitInfo commit = revInfo.commit(); commitName.setText(revision); idText.setText(("Change-Id: " + (change.change_id()))); idText.setPreviewText(change.change_id()); com.google.gerrit.client.change.CommitBox.formatLink(commit.author(), authorNameEmail, authorDate, change.status()); com.google.gerrit.client.change.CommitBox.formatLink(commit.committer(), committerNameEmail, committerDate, change.status()); text.setHTML(commentLinkProcessor.apply(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commit.message()).linkify())); com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && (gw.canLink(revInfo))) { browserLink.setInnerText(gw.getLinkName()); browserLink.setHref(gw.toRevision(change.project(), revision)); } else { com.google.gwt.user.client.ui.UIObject.setVisible(browserLink, false); } }






private void setSubmitType(com.google.gerrit.reviewdb.client.Project.SubmitType submitType) throws java.io.IOException { com.google.gerrit.server.project.PutConfig.Input in = new com.google.gerrit.server.project.PutConfig.Input(); in.submitType = submitType; in.useContentMerge = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.FALSE; com.google.gerrit.acceptance.RestResponse r = adminSession.put((("/projects/" + (project.get())) + "/config"), in); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); r.consume(); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString result) { submitTypeRecord = com.google.gerrit.common.data.SubmitTypeRecord.OK(Project.SubmitType.valueOf(result.asString())); }
private void loadProject(java.sql.ResultSet rs, com.google.gerrit.reviewdb.client.Project project) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { project.setDescription(rs.getString("description")); project.setUseContributorAgreements(com.google.gerrit.server.schema.Schema_53.asInheritableBoolean(rs, "use_contributor_agreements")); switch (rs.getString("submit_type").charAt(0)) { case 'F' : project.setSubmitType(Project.SubmitType.FAST_FORWARD_ONLY); break; case 'M' : project.setSubmitType(Project.SubmitType.MERGE_IF_NECESSARY); break; case 'A' : project.setSubmitType(Project.SubmitType.MERGE_ALWAYS); break; case 'C' : project.setSubmitType(Project.SubmitType.CHERRY_PICK); break; default : throw new com.google.gwtorm.server.OrmException(((("Unsupported submit_type=" + (rs.getString("submit_type"))) + " on project ") + (project.getName()))); } project.setUseSignedOffBy(com.google.gerrit.server.schema.Schema_53.asInheritableBoolean(rs, "use_signed_off_by")); project.setRequireChangeID(com.google.gerrit.server.schema.Schema_53.asInheritableBoolean(rs, "require_change_id")); project.setUseContentMerge(com.google.gerrit.server.schema.Schema_53.asInheritableBoolean(rs, "use_content_merge")); project.setParentName(rs.getString("parent_name")); }
@java.lang.Override protected com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType() { return com.google.gerrit.reviewdb.client.Project.SubmitType.CHERRY_PICK; }
private com.google.gerrit.server.git.SubmitStrategy createStrategy(final com.google.gerrit.reviewdb.client.Project.SubmitType submitType) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch); }
private boolean containsMissingCommits(final com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.SubmitType, com.google.gerrit.server.git.CodeReviewCommit> map, final com.google.gerrit.server.git.CodeReviewCommit commit) { if (!(isSubmitForMissingCommitsStillPossible(commit))) { return false; } for (final com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing) { if (!(map.containsValue(missingCommit))) { return false; } } return true; }
private com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet ps) { try { final com.google.gerrit.common.data.SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db, ps); if ((r.status) != (SubmitTypeRecord.Status.OK)) { com.google.gerrit.server.git.MergeOp.log.error(("Failed to get submit type for " + (change.getKey()))); return null; } return r.type; } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.git.MergeOp.log.error(("Failed to get submit type for " + (change.getKey())), e); return null; } }
@java.lang.Override protected com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType() { return com.google.gerrit.reviewdb.client.Project.SubmitType.FAST_FORWARD_ONLY; }
public final com.google.gerrit.reviewdb.client.Project.SubmitType submit_type() { return com.google.gerrit.reviewdb.client.Project.SubmitType.valueOf(submit_typeRaw()); }
public final Project.State state() { if ((stateRaw()) == null) { return Project.State.ACTIVE; } return Project.State.valueOf(stateRaw()); }
@org.junit.Test public void testCreateProjectWithProperties() throws java.io.IOException { final java.lang.String newProjectName = "newProject"; com.google.gerrit.server.project.CreateProject.Input in = new com.google.gerrit.server.project.CreateProject.Input(); in.description = "Test description"; in.submitType = com.google.gerrit.reviewdb.client.Project.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.useSignedOffBy = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; in.requireChangeId = com.google.gerrit.reviewdb.client.Project.InheritableBoolean.TRUE; com.google.gerrit.acceptance.RestResponse r = adminSession.put(("/projects/" + newProjectName), in); com.google.gerrit.server.project.ProjectJson.ProjectInfo p = newGson().fromJson(r.getReader(), com.google.gerrit.server.project.ProjectJson.ProjectInfo.class); assertEquals(newProjectName, p.name); com.google.gerrit.reviewdb.client.Project project = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newProjectName)).getProject(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertEquals(in.description, project.getDescription()); assertEquals(in.submitType, project.getSubmitType()); assertEquals(in.useContributorAgreements, project.getUseContributorAgreements()); assertEquals(in.useSignedOffBy, project.getUseSignedOffBy()); assertEquals(in.useContentMerge, project.getUseContentMerge()); assertEquals(in.requireChangeId, project.getRequireChangeID()); }
protected abstract com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType();
public static com.google.gerrit.common.data.SubmitTypeRecord OK(com.google.gerrit.reviewdb.client.Project.SubmitType type) { com.google.gerrit.common.data.SubmitTypeRecord r = new com.google.gerrit.common.data.SubmitTypeRecord(); r.status = com.google.gerrit.common.data.SubmitTypeRecord.Status.OK; r.type = type; return r; }
private void setBool(com.google.gwt.user.client.ui.ListBox box, com.google.gerrit.client.projects.ConfigInfo.InheritedBooleanInfo inheritedBoolean) { int inheritedIndex = -1; for (int i = 0; i < (box.getItemCount()); i++) { if (box.getValue(i).startsWith(InheritableBoolean.INHERIT.name())) { inheritedIndex = i; } if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) { box.setSelectedIndex(i); } } if (inheritedIndex >= 0) { if (getProjectKey().equals(com.google.gerrit.client.Gerrit.getConfig().getWildProject())) { if ((box.getSelectedIndex()) == inheritedIndex) { for (int i = 0; i < (box.getItemCount()); i++) { if (box.getValue(i).equals(InheritableBoolean.FALSE.name())) { box.setSelectedIndex(i); break; } } } box.removeItem(inheritedIndex); } else { box.setItemText(inheritedIndex, ((((InheritableBoolean.INHERIT.name()) + " (") + (inheritedBoolean.inherited_value())) + ")")); } } }
public static void setConfig(com.google.gerrit.reviewdb.client.Project.NameKey name, java.lang.String description, com.google.gerrit.reviewdb.client.Project.InheritableBoolean useContributorAgreements, com.google.gerrit.reviewdb.client.Project.InheritableBoolean useContentMerge, com.google.gerrit.reviewdb.client.Project.InheritableBoolean useSignedOffBy, com.google.gerrit.reviewdb.client.Project.InheritableBoolean requireChangeId, java.lang.String maxObjectSizeLimit, com.google.gerrit.reviewdb.client.Project.SubmitType submitType, com.google.gerrit.reviewdb.client.Project.State state, java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.String>> pluginConfigValues, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfo> cb) { com.google.gerrit.client.projects.ProjectApi.ConfigInput in = com.google.gerrit.client.projects.ProjectApi.ConfigInput.create(); in.setDescription(description); in.setUseContributorAgreements(useContributorAgreements); in.setUseContentMerge(useContentMerge); in.setUseSignedOffBy(useSignedOffBy); in.setRequireChangeId(requireChangeId); in.setMaxObjectSizeLimit(maxObjectSizeLimit); in.setSubmitType(submitType); in.setState(state); in.setPluginConfigValues(pluginConfigValues); com.google.gerrit.client.projects.ProjectApi.project(name).view("config").put(in, cb); }
final void setState(com.google.gerrit.reviewdb.client.Project.State s) { setStateRaw(s.name()); }
final void setSubmitType(com.google.gerrit.reviewdb.client.Project.SubmitType t) { setSubmitTypeRaw(t.name()); }
private com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { try { final com.google.gerrit.common.data.SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd); if ((r.status) != (SubmitTypeRecord.Status.OK)) { return null; } return r.type; } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return null; } }
private void renderSubmitType(java.lang.String action) { try { com.google.gerrit.reviewdb.client.Project.SubmitType type = Project.SubmitType.valueOf(action); submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type)); } catch (java.lang.IllegalArgumentException e) { submitActionText.setInnerText(action); } }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.lang.PrologException { engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); com.google.gerrit.server.project.ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine); com.google.gerrit.reviewdb.client.Project.SubmitType submitType = control.getProject().getSubmitType(); if (!(a1.unify(gerrit.PRED_project_default_submit_type_1.term[submitType.ordinal()], engine.trail))) { return engine.fail(); } return cont; }
public void setSubmitType(final com.google.gerrit.reviewdb.client.Project.SubmitType type) { submitType = type; }
public void setState(final com.google.gerrit.reviewdb.client.Project.State newState) { state = newState; }
public com.google.gerrit.reviewdb.client.Project.State getState() { return state; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString result) { event.getValue().setSubmitTypeRecord(com.google.gerrit.common.data.SubmitTypeRecord.OK(Project.SubmitType.valueOf(result.asString()))); }
private boolean isHidden() { return getProject().getState().equals(Project.State.HIDDEN); }
@java.lang.Override protected com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType() { return com.google.gerrit.reviewdb.client.Project.SubmitType.MERGE_IF_NECESSARY; }
@java.lang.Override public com.google.gerrit.reviewdb.client.Project.SubmitType apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException { return test.apply(resource, null); }
@java.lang.Override protected com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType() { return com.google.gerrit.reviewdb.client.Project.SubmitType.MERGE_ALWAYS; }
public final Project.State state() { return Project.State.valueOf(getStringState()); }
public Project.State getState() { return control.getProject().getState(); }
@java.lang.Override protected com.google.gerrit.reviewdb.client.Project.SubmitType getSubmitType() { return com.google.gerrit.reviewdb.client.Project.SubmitType.REBASE_IF_NECESSARY; }
private static com.google.gerrit.reviewdb.client.Project.InheritableBoolean getBool(com.google.gwt.user.client.ui.ListBox box) { int i = box.getSelectedIndex(); if (i >= 0) { final java.lang.String selectedValue = box.getValue(i); if (selectedValue.startsWith(InheritableBoolean.INHERIT.name())) { return com.google.gerrit.reviewdb.client.Project.InheritableBoolean.INHERIT; } return com.google.gerrit.reviewdb.client.Project.InheritableBoolean.valueOf(selectedValue); } return com.google.gerrit.reviewdb.client.Project.InheritableBoolean.INHERIT; }
private void setEnabledForUseContentMerge() { if (SubmitType.FAST_FORWARD_ONLY.equals(Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) { contentMerge.setEnabled(false); com.google.gerrit.client.projects.ConfigInfo.InheritedBooleanInfo b = com.google.gerrit.client.projects.ConfigInfo.InheritedBooleanInfo.create(); b.setConfiguredValue(InheritableBoolean.FALSE); setBool(contentMerge, b); } else { contentMerge.setEnabled(submitType.isEnabled()); } }
private void setSubmitType(final com.google.gerrit.reviewdb.client.Project.SubmitType newSubmitType) { int index = -1; if ((submitType) != null) { for (int i = 0; i < (submitType.getItemCount()); i++) { if (newSubmitType.name().equals(submitType.getValue(i))) { index = i; break; } } submitType.setSelectedIndex(index); setEnabledForUseContentMerge(); } }
@org.junit.Test public void createBranch() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { gApi.projects().name(project.get()).branch("foo").create(new com.google.gerrit.extensions.api.projects.BranchInput()); }
public boolean canWrite() { return getProjectControl().getProject().getState().equals(Project.State.ACTIVE); }
public static java.lang.String toLongString(final com.google.gerrit.reviewdb.client.Project.State type) { if (type == null) { return ""; } switch (type) { case ACTIVE : return com.google.gerrit.client.admin.Util.C.projectState_ACTIVE(); case READ_ONLY : return com.google.gerrit.client.admin.Util.C.projectState_READ_ONLY(); case HIDDEN : return com.google.gerrit.client.admin.Util.C.projectState_HIDDEN(); default : return type.name(); } }
private static com.google.gwt.user.client.ui.ListBox newInheritedBooleanBox() { com.google.gwt.user.client.ui.ListBox box = new com.google.gwt.user.client.ui.ListBox(); for (com.google.gerrit.reviewdb.client.Project.InheritableBoolean b : com.google.gerrit.reviewdb.client.Project.InheritableBoolean.values()) { box.addItem(b.name(), b.name()); } return box; }
public static java.lang.String toLongString(final com.google.gerrit.reviewdb.client.Project.SubmitType type) { if (type == null) { return ""; } switch (type) { case FAST_FORWARD_ONLY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_FAST_FORWARD_ONLY(); case MERGE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_IF_NECESSARY(); case REBASE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_REBASE_IF_NECESSARY(); case MERGE_ALWAYS : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_ALWAYS(); case CHERRY_PICK : return com.google.gerrit.client.admin.Util.C.projectSubmitType_CHERRY_PICK(); default : return type.name(); } }
private void doSave() { enableForm(false); saveProject.setEnabled(false); com.google.gerrit.client.projects.ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contributorAgreements), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contentMerge), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(signedOffBy), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), Project.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), Project.State.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { enableForm(); display(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableForm(); super.onFailure(caught); } }); }
private void setState(final com.google.gerrit.reviewdb.client.Project.State newState) { if ((state) != null) { for (int i = 0; i < (state.getItemCount()); i++) { if (newState.name().equals(state.getValue(i))) { state.setSelectedIndex(i); break; } } } }
public boolean canRead() { return (getProjectControl().getProject().getState().equals(Project.State.READ_ONLY)) || (canWrite()); }



@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = object.change(); if (change == null) { return false; } return getValue().equals(change.getTopic()); }
@java.lang.Override protected com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> defaultField(java.lang.String query) throws com.google.gerrit.server.query.QueryParseException { if (query.startsWith("refs/")) { return ref(query); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.DEF_CHANGE.matcher(query).matches()) { return change(query); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_COMMIT.matcher(query).matches()) { return commit(query); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_EMAIL.matcher(query).find()) { try { return com.google.gerrit.server.query.Predicate.or(owner(query), reviewer(query)); } catch (com.google.gwtorm.server.OrmException err) { throw error("Cannot lookup user", err); } } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_LABEL.matcher(query).find()) { try { return label(query); } catch (com.google.gwtorm.server.OrmException err) { throw error("Cannot lookup user", err); } } else { final java.util.List<com.google.gerrit.server.query.change.ProjectPredicate> predicate = new java.util.ArrayList<com.google.gerrit.server.query.change.ProjectPredicate>(); for (com.google.gerrit.reviewdb.client.Project.NameKey name : args.projectCache.all()) { if (name.get().toLowerCase().contains(query.toLowerCase())) { predicate.add(new com.google.gerrit.server.query.change.ProjectPredicate(name.get())); } } if ((predicate.size()) == 1) { return predicate.get(0); } else if ((predicate.size()) > 1) { return com.google.gerrit.server.query.Predicate.or(predicate); } throw error(("Unsupported query:" + query)); } }



public void preDisplay(final com.google.gerrit.reviewdb.client.Account result) { display(result.getGeneralPreferences()); }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myAccount(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.reviewdb.client.Account>(this) { public void preDisplay(final com.google.gerrit.reviewdb.client.Account result) { display(result.getGeneralPreferences()); } }); }
@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account a = db.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(a.getGeneralPreferences()); }

@java.lang.Override protected com.google.gerrit.common.data.ProjectAccess updateProjectConfig(com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.server.git.MetaDataUpdate md) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { config.commit(md); projectCache.evict(config.getProject()); return projectAccessFactory.create(projectName).call(); }
public boolean canCreate(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevObject object, boolean existsOnServer) { if (!(canWrite())) { return false; } boolean owner; switch (getCurrentUser().getAccessPath()) { case REST_API : case JSON_RPC : owner = isOwner(); break; default : owner = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { return ((getCurrentUser().getCapabilities().canAdministrateServer()) || (owner && (!(isBlocked(Permission.CREATE))))) || ((canPerform(Permission.CREATE)) && (((!existsOnServer) && (canUpdate())) || (projectControl.canReadCommit(rw, ((org.eclipse.jgit.revwalk.RevCommit) (object)))))); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if (getCurrentUser().isIdentifiedUser()) { final com.google.gerrit.server.IdentifiedUser user = ((com.google.gerrit.server.IdentifiedUser) (getCurrentUser())); final java.lang.String addr = tagger.getEmailAddress(); valid = user.getEmailAddresses().contains(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.PUSH_SIGNED_TAG)); } else { return owner || (canPerform(Permission.PUSH_TAG)); } } else { return false; } }
public com.google.gerrit.extensions.registration.RegistrationHandle set(com.google.inject.Provider<T> impl, java.lang.String pluginName) { final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> item = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(impl, pluginName); com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> old = null; while (!(ref.compareAndSet(null, item))) { old = ref.get(); if (old != null) { if ("gerrit".equals(old.pluginName)) { if (ref.compareAndSet(old, item)) { break; } old = ref.get(); } throw new com.google.inject.ProvisionException(java.lang.String.format("%s already provided by %s, ignoring plugin %s", key.getTypeLiteral(), old.pluginName, pluginName)); } } final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> defaultItem = old; return new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { ref.compareAndSet(item, defaultItem); } }; }
public com.google.gerrit.extensions.registration.ReloadableRegistrationHandle<T> set(com.google.inject.Key<T> key, com.google.inject.Provider<T> impl, java.lang.String pluginName) { final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> item = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(impl, pluginName); while (!(ref.compareAndSet(null, item))) { com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> old = ref.get(); if (old != null) { throw new com.google.inject.ProvisionException(java.lang.String.format("%s already provided by %s, ignoring plugin %s", this.key.getTypeLiteral(), old.pluginName, pluginName)); } } return new ReloadableHandle(key, item); }
@java.lang.Override public void remove() { ref.compareAndSet(item, null); }
public com.google.gerrit.extensions.registration.RegistrationHandle set(com.google.inject.Provider<T> impl, java.lang.String pluginName) { final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> item = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(impl, pluginName); while (!(ref.compareAndSet(null, item))) { com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> old = ref.get(); if (old != null) { if ("gerrit".equals(old.pluginName)) { if (ref.compareAndSet(old, item)) { break; } old = ref.get(); } throw new com.google.inject.ProvisionException(java.lang.String.format("%s already provided by %s, ignoring plugin %s", key.getTypeLiteral(), old.pluginName, pluginName)); } } return new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { ref.compareAndSet(item, null); } }; }
private org.eclipse.jetty.util.thread.ThreadPool threadPool(org.eclipse.jgit.lib.Config cfg) { int maxThreads = cfg.getInt("httpd", null, "maxthreads", 25); int minThreads = cfg.getInt("httpd", null, "minthreads", 5); int maxCapacity = cfg.getInt("httpd", null, "maxqueued", 50); int idleTimeout = ((int) (java.util.concurrent.TimeUnit.MILLISECONDS.convert(60, java.util.concurrent.TimeUnit.SECONDS))); org.eclipse.jetty.util.thread.QueuedThreadPool pool = new org.eclipse.jetty.util.thread.QueuedThreadPool(maxThreads, minThreads, idleTimeout, new org.eclipse.jetty.util.BlockingArrayQueue<java.lang.Runnable>(minThreads, minThreads, maxCapacity)); pool.setName("HTTP"); return pool; }
private boolean shouldCopy(com.google.inject.Key<?> key) { if (copyConfigKeys.contains(key)) { return false; } java.lang.Class<?> type = key.getTypeLiteral().getRawType(); if (com.google.gerrit.extensions.events.LifecycleListener.class.isAssignableFrom(type)) { return false; } if (com.google.gerrit.server.plugins.StartPluginListener.class.isAssignableFrom(type)) { return false; } if (type.getName().startsWith("com.google.inject.")) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("org.apache.sshd.server.Command", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.Filter", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.ServletContext", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.ServletRequest", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.ServletResponse", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpServlet", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpServletRequest", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpServletResponse", type)) { return false; } if (com.google.gerrit.server.plugins.PluginGuiceEnvironment.is("javax.servlet.http.HttpSession", type)) { return false; } if (((java.util.Map.class.isAssignableFrom(type)) && ((key.getAnnotationType()) != null)) && ("com.google.inject.servlet.RequestParameters".equals(key.getAnnotationType().getName()))) { return false; } if (type.getName().startsWith("com.google.gerrit.httpd.GitOverHttpServlet$")) { return false; } return true; }


private void insertArchive() { java.util.List<com.google.gwt.user.client.ui.Anchor> formats = new java.util.ArrayList<>(com.google.gerrit.client.change.DownloadBox.ARCHIVE.length); for (java.lang.String f : com.google.gerrit.client.change.DownloadBox.ARCHIVE) { com.google.gwt.user.client.ui.Anchor archive = new com.google.gwt.user.client.ui.Anchor(f); archive.setHref(new com.google.gerrit.client.rpc.RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url()); formats.add(archive); } com.google.gwt.user.client.ui.HorizontalPanel p = new com.google.gwt.user.client.ui.HorizontalPanel(); java.util.Iterator<com.google.gwt.user.client.ui.Anchor> it = formats.iterator(); while (it.hasNext()) { com.google.gwt.user.client.ui.Anchor a = it.next(); p.add(a); if (it.hasNext()) { com.google.gwt.user.client.ui.InlineLabel spacer = new com.google.gwt.user.client.ui.InlineLabel("|"); spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer()); p.add(spacer); } } insertCommand("Archive", p); }


void setMarker(net.codemirror.lib.TextMarker marker, int length) { this.marker = marker; numSkipLines = length; skipNum.setText(java.lang.Integer.toString(length)); if (checkAndUpdateArrows()) { upArrow.setHTML(PatchUtil.M.expandBefore(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); } }






private static void addExtensionLink(com.google.gerrit.client.ui.LinkMenuBar m, com.google.gerrit.client.extensions.TopMenuItem item) { com.google.gwt.user.client.ui.Anchor atag = com.google.gerrit.client.Gerrit.anchor(item.getName(), (com.google.gerrit.client.Gerrit.isAbsolute(item.getUrl()) ? item.getUrl() : com.google.gerrit.client.Gerrit.selfRedirect(item.getUrl()))); atag.setTarget(item.getTarget()); if ((item.getId()) != null) { atag.getElement().setAttribute("id", item.getId()); } m.add(atag); }
private static java.lang.String my(org.eclipse.jgit.lib.Config cfg, java.lang.String subsection, java.lang.String key, java.lang.String defaultValue) { java.lang.String value = cfg.getString(com.google.gerrit.server.account.GetPreferences.MY, subsection, key); return value != null ? value : defaultValue; }
private java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> scan() { if ((matchPrefix) != null) { return projectCache.byName(matchPrefix); } else if ((matchSubstring) != null) { return com.google.common.collect.Iterables.filter(projectCache.all(), new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.Project.NameKey>() { public boolean apply(com.google.gerrit.reviewdb.client.Project.NameKey in) { return in.get().toLowerCase(java.util.Locale.US).contains(matchSubstring.toLowerCase(java.util.Locale.US)); } }); } else { return projectCache.all(); } }

@java.lang.Override public void afterRefresh(boolean didRefresh) throws java.io.IOException { if (isSearcherCurrent()) { refreshListeners.remove(this); set(null); } }


@java.lang.Override public com.google.gerrit.extensions.api.projects.ProjectApi create(com.google.gerrit.extensions.api.projects.ProjectInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (((in.name) != null) && (!(name.equals(in.name)))) { throw new com.google.gerrit.extensions.restapi.RestApiException("name must match input.name"); } createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in); return projectApi.create(projects.parse(name)); } catch (com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.extensions.restapi.ResourceConflictException | com.google.gerrit.extensions.restapi.ResourceNotFoundException | com.google.gerrit.common.errors.ProjectCreationFailedException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create project", e); } }
public com.google.gerrit.client.ui.PatchLink createLink(int index, com.google.gerrit.client.patches.PatchScreen.Type patchType, com.google.gwtexpui.safehtml.client.SafeHtml before, com.google.gwtexpui.safehtml.client.SafeHtml after) { com.google.gerrit.reviewdb.client.Patch patch = patchList.get(index); com.google.gerrit.reviewdb.client.Patch.Key thisKey = patch.getKey(); com.google.gerrit.client.ui.PatchLink link; if (patchType == (PatchScreen.Type.SIDE_BY_SIDE)) { link = new com.google.gerrit.client.ui.PatchLink.SideBySide("", base, thisKey, index, detail, this); } else { link = new com.google.gerrit.client.ui.PatchLink.Unified("", base, thisKey, index, detail, this); } com.google.gwtexpui.safehtml.client.SafeHtmlBuilder text = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); text.append(before); text.append(com.google.gerrit.client.changes.PatchTable.getFileNameOnly(patch)); text.append(after); com.google.gwtexpui.safehtml.client.SafeHtml.set(link, text); return link; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> byPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { if (!(migration.readPatchSetApprovals())) { return com.google.gerrit.server.ApprovalsUtil.sortApprovals(db.patchSetApprovals().byPatchSet(psId)); } return notes.load().getApprovals().get(psId); }
@java.lang.Override public Iterable<java.lang.Integer> get(com.google.gerrit.server.query.change.ChangeData input, com.google.gerrit.server.index.FillArgs args) throws com.google.gwtorm.server.OrmException { Set<java.lang.Integer> r = com.google.common.collect.Sets.newHashSet(); if ((!args.allowsDrafts) && ((input.change().getStatus()) == Change.Status.DRAFT)) { return r; } for (com.google.gerrit.reviewdb.client.PatchSetApproval a : input.approvals().values()) { r.add(a.getAccountId().get()); } return r; }

public void onScreenLoad(com.google.gerrit.client.ui.ScreenLoadEvent event) { if (event.getScreen().getToken().equals(getTargetHistoryToken())) { addStyleName(Gerrit.RESOURCES.css().activeRow()); } else { removeStyleName(Gerrit.RESOURCES.css().activeRow()); } }
private java.util.List<com.google.gitiles.blame.Region> loadBlame(com.google.gitiles.blame.BlameCacheImpl.Key key) throws java.io.IOException { try { org.eclipse.jgit.blame.BlameGenerator gen = new org.eclipse.jgit.blame.BlameGenerator(key.repo, key.path); org.eclipse.jgit.blame.BlameResult blame; try { gen.push(null, key.commitId); blame = gen.computeBlameResult(); } finally { gen.release(); } if (blame == null) { return com.google.common.collect.ImmutableList.of(); } int lineCount = blame.getResultContents().size(); blame.discardResultContents(); java.util.List<com.google.gitiles.blame.Region> regions = com.google.common.collect.Lists.newArrayList(); for (int i = 0; i < lineCount; i++) { if ((regions.isEmpty()) || (!(regions.get(((regions.size()) - 1)).growFrom(blame, i)))) { regions.add(new com.google.gitiles.blame.Region(blame, i)); } } return java.util.Collections.unmodifiableList(regions); } finally { key.repo = null; } }
@java.lang.Override public java.util.List<com.google.gitiles.blame.Region> load(com.google.gitiles.blame.BlameCacheImpl.Key key) throws java.io.IOException { return loadBlame(key); }
@java.lang.Override public void run() throws java.io.IOException { ui.header("Gitiles"); if (!(confirm())) { return; } gitweb.set("type", "custom"); gitweb.set("linkname", "gitiles"); gitweb.unset("cgi"); gitweb.unset("pathSeparator"); gitweb.set("url", "plugins/gitiles/"); gitweb.set("revision", "${project}/+/${commit}"); gitweb.set("project", "${project}"); gitweb.set("branch", "${project}/+/${branch}"); gitweb.set("filehistory", "${project}/+log/${branch}/${file}"); gitilesConfig.createNewFile(); }
private void renderHeader(java.lang.String header) throws java.io.IOException { int lf = header.indexOf('\n'); java.lang.String first; java.lang.String rest; if (0 <= lf) { first = header.substring(0, lf); rest = header.substring((lf + 1)); } else { first = header; rest = ""; } getOutputStream().write(renderer.newRenderer("gitiles.diffHeader").setData(com.google.common.collect.ImmutableMap.of("first", first, "rest", rest, "fileIndex", fileIndex)).render().getBytes(Charsets.UTF_8)); }
private com.google.gwtexpui.globalkey.client.NpTextArea renderTextArea(com.google.gerrit.client.admin.ProjectInfoScreen.LabeledWidgetsGrid g, com.google.gerrit.client.projects.ConfigInfo.ConfigParameterInfo param) { com.google.gwtexpui.globalkey.client.NpTextArea txtArea = new com.google.gwtexpui.globalkey.client.NpTextArea(); txtArea.setVisibleLines(4); txtArea.setCharacterWidth(40); java.lang.StringBuilder sb = new java.lang.StringBuilder(); for (int i = 0; i < (param.values().length()); i++) { java.lang.String v = param.values().get(i); sb.append(v).append("\n"); } txtArea.setText(sb.toString()); if (param.editable()) { saveEnabler.listenTo(txtArea); } else { txtArea.setEnabled(false); } addWidget(g, txtArea, param); return txtArea; }

private void addReviewers(java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> topReviewers, com.google.gerrit.reviewdb.client.Change change) { try { com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())); com.google.gerrit.server.change.ChangeResource changeResource = new com.google.gerrit.server.change.ChangeResource(changeControl); com.google.gerrit.server.change.PostReviewers post = reviewersProvider.get(); for (com.google.gerrit.reviewdb.client.Account.Id accountId : topReviewers) { com.google.gerrit.server.change.PostReviewers.Input input = new com.google.gerrit.server.change.PostReviewers.Input(); input.reviewer = accountId.toString(); post.apply(changeResource, input); } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.reviewersbyblame.ReviewersByBlame.log.error("Couldn't add reviewers to the change", ex); } }
private void init() { final org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); try { cfg.fromText(com.google.gerrit.pgm.init.Libraries.read(com.google.gerrit.pgm.init.Libraries.RESOURCE_FILE)); } catch (java.io.IOException e) { throw new java.lang.RuntimeException(e.getMessage(), e); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(e.getMessage(), e); } for (final java.lang.reflect.Field f : com.google.gerrit.pgm.init.Libraries.class.getDeclaredFields()) { if ((((f.getModifiers()) & (java.lang.reflect.Modifier.STATIC)) == 0) && ((f.getType()) == (com.google.gerrit.pgm.init.LibraryDownloader.class))) { try { init(f, cfg); } catch (java.lang.IllegalArgumentException e) { throw new java.lang.IllegalStateException(("Cannot initialize " + (f.getName()))); } catch (java.lang.IllegalAccessException e) { throw new java.lang.IllegalStateException(("Cannot initialize " + (f.getName()))); } } } }
private net.codemirror.lib.CodeMirror newCM(com.google.gerrit.client.diff.DiffInfo.FileMeta meta, java.lang.String contents, com.google.gerrit.client.diff.DisplaySide side, com.google.gwt.dom.client.Element parent) { return net.codemirror.lib.CodeMirror.create(side, parent, net.codemirror.lib.Configuration.create().set("readOnly", true).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", prefs.showLineNumbers()).set("tabSize", prefs.tabSize()).set("mode", (largeFile ? null : getContentType(meta))).set("lineWrapping", false).set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("keyMap", "vim_ro").set("theme", prefs.theme().name().toLowerCase()).set("value", (meta != null ? contents : "")).set("viewportMargin", (prefs.renderEntireFile() ? java.lang.Double.POSITIVE_INFINITY : 10))); }
private static boolean isLargeFile(com.google.gerrit.client.diff.DiffInfo diffInfo) { return (((diffInfo.meta_a()) != null) && ((diffInfo.meta_a().lines()) > 500)) || (((diffInfo.meta_b()) != null) && ((diffInfo.meta_b().lines()) > 500)); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { diff = diffInfo; if (prefs.syntaxHighlighting()) { largeFile = com.google.gerrit.client.diff.SideBySide2.isLargeFile(diffInfo); if (largeFile) { modeInjectorCb.onSuccess(null); } else { injectMode(diffInfo, modeInjectorCb); } } else { modeInjectorCb.onSuccess(null); } }
@com.google.inject.Provides com.google.gitiles.GitilesUrls getGitilesUrls(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config gerritConfig, @com.google.gerrit.common.Nullable @com.google.gerrit.server.config.CanonicalWebUrl java.lang.String gerritUrl, @com.google.gerrit.server.ssh.SshAdvertisedAddresses java.util.List<java.lang.String> advertisedSshAddresses) throws java.net.MalformedURLException, java.net.UnknownHostException { java.net.URL u; java.lang.String hostName; if (gerritUrl != null) { u = new java.net.URL(gerritUrl); hostName = ((u.getHost()) != null) ? u.getHost() : getLocalHostName(); } else { u = null; hostName = "Gerrit"; } java.lang.String gitUrl; if (!(advertisedSshAddresses.isEmpty())) { java.lang.String addr = advertisedSshAddresses.get(0); if ((addr.startsWith("*:")) || ("".equals(addr))) { if ((u != null) && ((u.getHost()) != null)) { addr = u.getHost(); } else { addr = getLocalHostName(); } } gitUrl = ("ssh://" + addr) + "/"; } else { gitUrl = gerritConfig.getString("gerrit", null, "gitHttpUrl"); if (gitUrl == null) { gitUrl = gerritConfig.getString("gerrit", null, "canonicalGitUrl"); } } if (gitUrl == null) { throw new com.google.inject.ProvisionException("Unable to determine any canonical git URL from gerrit.config"); } return new com.google.gitiles.DefaultUrls(hostName, gitUrl, gerritUrl); }


@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { final org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; final org.eclipse.jgit.lib.AbbreviatedObjectId id = commit.abbreviate(7); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.ArrayList<com.google.gerrit.server.git.validators.CommitValidationMessage>(); if ((this.maxSubjectLength) < (commit.getShortMessage().length())) { onLineTooLong(id, messages, new java.lang.String((("commit subject >" + (this.maxSubjectLength)) + " characters; use shorter first paragraph"))); } int longLineCnt = 0; int nonEmptyCnt = 0; for (java.lang.String line : commit.getFullMessage().split("\n")) { if (!(line.trim().isEmpty())) { nonEmptyCnt++; } if ((this.maxLineLength) < (line.length())) { longLineCnt++; } } if ((0 < longLineCnt) && (33 < ((longLineCnt * 100) / nonEmptyCnt))) { onLineTooLong(id, messages, new java.lang.String((("commit message lines >" + (this.maxLineLength)) + " characters; manually wrap lines"))); } return messages; }
@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.ChangeListener.class).to(com.googlesource.gerrit.plugins.reviewersbyblame.ChangeUpdatedListener.class); factory(ReviewersByBlame.Factory.class); }
com.google.gerrit.client.diff.DiffChunkInfo getFirst() { if (!(chunks.isEmpty())) { for (com.google.gerrit.client.diff.DiffChunkInfo d : chunks) { if ((d.getSide()) == (DisplaySide.B)) { return d; } } return chunks.get(0); } return null; }
public void setCurrentFilePaths(java.util.List<java.lang.String> filePaths) { currentFiles = com.google.common.collect.ImmutableList.copyOf(filePaths); }

public void doPatchsetCreatedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.PatchSetCreatedEvent event = new com.google.gerrit.server.events.PatchSetCreatedEvent(); final com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--is-draft", (patchSet.isDraft() ? "true" : "false")); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), patchsetCreatedHook, args); }
public void doTopicChangedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final java.lang.String oldTopic, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.TopicChangedEvent event = new com.google.gerrit.server.events.TopicChangedEvent(); event.change = eventFactory.asChangeAttribute(change); event.changer = eventFactory.asAccountAttribute(account); event.oldTopic = oldTopic; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--changer", getDisplayName(account)); addArg(args, "--old-topic", oldTopic); addArg(args, "--new-topic", event.change.topic); runHook(change.getProject(), topicChangedHook, args); }
public void doReviewerAddedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ReviewerAddedEvent event = new com.google.gerrit.server.events.ReviewerAddedEvent(); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.reviewer = eventFactory.asAccountAttribute(account); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--reviewer", getDisplayName(account)); runHook(change.getProject(), reviewerAddedHook, args); }
public void doChangeAbandonedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final java.lang.String reason, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeAbandonedEvent event = new com.google.gerrit.server.events.ChangeAbandonedEvent(); event.change = eventFactory.asChangeAttribute(change); event.abandoner = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.reason = reason; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--abandoner", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeAbandonedHook, args); }
public void doDraftPublishedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.DraftPublishedEvent event = new com.google.gerrit.server.events.DraftPublishedEvent(); final com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), draftPublishedHook, args); }
public void doChangeMergedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeMergedEvent event = new com.google.gerrit.server.events.ChangeMergedEvent(); event.change = eventFactory.asChangeAttribute(change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); runHook(change.getProject(), changeMergedHook, args); }
public void doMergeFailedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final java.lang.String reason, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.MergeFailedEvent event = new com.google.gerrit.server.events.MergeFailedEvent(); event.change = eventFactory.asChangeAttribute(change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.reason = reason; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), mergeFailedHook, args); }
public void doChangeRestoredHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final java.lang.String reason, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeRestoredEvent event = new com.google.gerrit.server.events.ChangeRestoredEvent(); event.change = eventFactory.asChangeAttribute(change); event.restorer = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.reason = reason; fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<java.lang.String>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--restorer", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeRestoredHook, args); }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.reviewdb.client.Project p) { com.google.gerrit.extensions.common.ProjectInfo info = new com.google.gerrit.extensions.common.ProjectInfo(); info.name = p.getName(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = p.getParent(allProjects); info.parent = (parentName != null) ? parentName.get() : null; info.description = com.google.common.base.Strings.emptyToNull(p.getDescription()); info.state = p.getState(); info.id = com.google.gerrit.extensions.restapi.Url.encode(info.name); return info; }
private void setDefaultDateFormatterBuilder() { if ((dateFormatterBuilder) == null) { dateFormatterBuilder = new com.google.gitiles.DateFormatterBuilder(); } }
@java.lang.Override protected void doGetJson(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); com.google.gitiles.GitilesView view = com.google.gitiles.LogServlet.getView(req, repo); com.google.gitiles.Paginator paginator = com.google.gitiles.LogServlet.newPaginator(repo, view); if (paginator == null) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); return; } try { org.eclipse.jgit.util.GitDateFormatter df = new org.eclipse.jgit.util.GitDateFormatter(org.eclipse.jgit.util.GitDateFormatter.Format.DEFAULT); java.util.Map<java.lang.String, java.lang.Object> result = com.google.common.collect.Maps.newLinkedHashMap(); java.util.List<com.google.gitiles.CommitJsonData.Commit> entries = com.google.common.collect.Lists.newArrayListWithCapacity(paginator.getLimit()); for (org.eclipse.jgit.revwalk.RevCommit c : paginator) { paginator.getWalk().parseBody(c); entries.add(new com.google.gitiles.CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df)); } result.put("log", entries); if ((paginator.getPreviousStart()) != null) { result.put("previous", paginator.getPreviousStart().name()); } if ((paginator.getNextStart()) != null) { result.put("next", paginator.getNextStart().name()); } renderJson(req, res, result, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); } finally { paginator.getWalk().release(); } }
public synchronized com.google.gitiles.BaseServlet getDefaultHandler(com.google.gitiles.GitilesView.Type view) { checkNotInitialized(); switch (view) { case HOST_INDEX : return new com.google.gitiles.HostIndexServlet(accessFactory, renderer, urls); case REPOSITORY_INDEX : return new com.google.gitiles.RepositoryIndexServlet(accessFactory, renderer, timeCache); case REFS : return new com.google.gitiles.RefServlet(accessFactory, renderer, timeCache); case REVISION : return new com.google.gitiles.RevisionServlet(accessFactory, renderer, linkifier()); case PATH : return new com.google.gitiles.PathServlet(accessFactory, renderer, urls); case DIFF : return new com.google.gitiles.DiffServlet(accessFactory, renderer, linkifier()); case LOG : return new com.google.gitiles.LogServlet(accessFactory, renderer, linkifier()); case DESCRIBE : return new com.google.gitiles.DescribeServlet(accessFactory); case ARCHIVE : return new com.google.gitiles.ArchiveServlet(accessFactory); case BLAME : return new com.google.gitiles.blame.BlameServlet(accessFactory, renderer, blameCache); default : throw new java.lang.IllegalArgumentException(("Invalid view type: " + view)); } }
public static com.google.gitiles.BaseServlet notFoundServlet() { return new com.google.gitiles.BaseServlet(null, null) { private static final long serialVersionUID = 1L; @java.lang.Override public void service(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); } }; }
@java.lang.Override protected void doGetJson(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.util.GitDateFormatter df = new org.eclipse.jgit.util.GitDateFormatter(org.eclipse.jgit.util.GitDateFormatter.Format.DEFAULT); org.eclipse.jgit.revwalk.RevObject obj = walk.parseAny(view.getRevision().getId()); switch (obj.getType()) { case OBJ_COMMIT : renderJson(req, res, new com.google.gitiles.CommitJsonData().setRevWalk(walk).toJsonData(req, ((org.eclipse.jgit.revwalk.RevCommit) (obj)), com.google.gitiles.RevisionServlet.COMMIT_JSON_FIELDS, df), com.google.gitiles.CommitJsonData.Commit.class); break; default : res.setStatus(com.google.gitiles.SC_NOT_FOUND); break; } } finally { walk.release(); } }
private static boolean isFile(org.eclipse.jgit.revwalk.RevWalk walk, com.google.gitiles.GitilesView view) throws java.io.IOException { if (view.getPathPart().equals("")) { return false; } org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(walk.getObjectReader(), view.getPathPart(), walk.parseTree(view.getRevision().getId())); try { return ((tw.getRawMode(0)) & (org.eclipse.jgit.lib.FileMode.TYPE_FILE)) > 0; } finally { tw.release(); } }

com.google.gerrit.extensions.accounts.AccountApi name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException;


@java.lang.Override public com.google.gerrit.extensions.accounts.AccountApi name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }


public void doAction(com.google.gerrit.server.IdentifiedUser user, com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp, com.googlesource.gerrit.plugins.github.wizard.ControllerErrors errors) throws java.io.IOException, javax.servlet.ServletException { setAccountIdentity(user, req); setAccoutPublicKeys(user, hubLogin, req); }
public com.google.gerrit.extensions.registration.ReloadableRegistrationHandle<T> set(com.google.inject.Key<T> key, com.google.inject.Provider<T> impl, java.lang.String pluginName) { final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> item = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(impl, pluginName); while (!(ref.compareAndSet(null, item))) { com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> old = ref.get(); if (old != null) { throw new com.google.inject.ProvisionException(java.lang.String.format("%s already provided by %s, ignoring plugin %s", this.key.getTypeLiteral(), old.pluginName, pluginName)); } } return new ReloadableHandle(key, item); }
public static <T> void itemOf(com.google.inject.Binder binder, com.google.inject.TypeLiteral<T> member) { @java.lang.SuppressWarnings("unchecked") com.google.inject.Key<com.google.gerrit.extensions.registration.DynamicItem<T>> key = ((com.google.inject.Key<com.google.gerrit.extensions.registration.DynamicItem<T>>) (com.google.inject.Key.get(com.google.inject.util.Types.newParameterizedType(com.google.gerrit.extensions.registration.DynamicItem.class, member.getType())))); binder.bind(key).toProvider(new com.google.gerrit.extensions.registration.DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicItem<T>.ReloadableHandle replace(com.google.inject.Key<T> newKey, com.google.inject.Provider<T> newItem) { com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> n = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(newItem, item.pluginName); if (ref.compareAndSet(item, n)) { return new ReloadableHandle(newKey, n); } return null; }
public com.google.gerrit.extensions.registration.RegistrationHandle set(com.google.inject.Provider<T> impl, java.lang.String pluginName) { final com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> item = new com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T>(impl, pluginName); while (!(ref.compareAndSet(null, item))) { com.google.gerrit.extensions.registration.DynamicItem.NamedProvider<T> old = ref.get(); if (old != null) { throw new com.google.inject.ProvisionException(java.lang.String.format("%s already provided by %s, ignoring plugin %s", key.getTypeLiteral(), old.pluginName, pluginName)); } } return new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { ref.compareAndSet(item, null); } }; }
public com.google.gerrit.extensions.registration.DynamicItem<T> get() { return new com.google.gerrit.extensions.registration.DynamicItem<T>(key, com.google.gerrit.extensions.registration.DynamicItemProvider.find(injector, type), "gerrit"); }
com.google.gerrit.httpd.WebSessionManager.Val get(final com.google.gerrit.httpd.WebSessionManager.Key key) { com.google.gerrit.httpd.WebSessionManager.Val val = self.getIfPresent(key.token); if ((val != null) && ((val.expiresAt) <= (com.google.gerrit.httpd.WebSessionManager.now()))) { self.invalidate(key.token); return null; } return val; }
com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.reviewdb.client.Account.Id who, final boolean remember, final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin, java.lang.String sid, java.lang.String auth) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long now = com.google.gerrit.httpd.WebSessionManager.now(); final long refreshCookieAt = now + refresh; final long expiresAt = now + (sessionMaxAgeMillis); if (sid == null) { sid = newUniqueToken(who); } if (auth == null) { auth = newUniqueToken(who); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth); self.put(key.token, val); return val; }
boolean hasDynamicItem(com.google.inject.TypeLiteral<?> type) { return sysItems.containsKey(type); }
void onStartPlugin(com.google.gerrit.server.plugins.Plugin plugin) { for (com.google.gerrit.server.plugins.StartPluginListener l : onStart) { l.onStartPlugin(plugin); } com.google.gerrit.server.util.RequestContext oldContext = enter(plugin); try { attachItem(sysItems, plugin.getSysInjector(), plugin); attachSet(sysSets, plugin.getSysInjector(), plugin); attachSet(sshSets, plugin.getSshInjector(), plugin); attachSet(httpSets, plugin.getHttpInjector(), plugin); attachMap(sysMaps, plugin.getSysInjector(), plugin); attachMap(sshMaps, plugin.getSshInjector(), plugin); attachMap(httpMaps, plugin.getHttpInjector(), plugin); } finally { exit(oldContext); } }
void onReloadPlugin(com.google.gerrit.server.plugins.Plugin oldPlugin, com.google.gerrit.server.plugins.Plugin newPlugin) { for (com.google.gerrit.server.plugins.ReloadPluginListener l : onReload) { l.onReloadPlugin(oldPlugin, newPlugin); } com.google.common.collect.ListMultimap<com.google.inject.TypeLiteral<?>, com.google.gerrit.extensions.registration.ReloadableRegistrationHandle<?>> old = com.google.common.collect.LinkedListMultimap.create(); for (com.google.gerrit.extensions.registration.ReloadableRegistrationHandle<?> h : oldPlugin.getReloadableHandles()) { old.put(h.getKey().getTypeLiteral(), h); } com.google.gerrit.server.util.RequestContext oldContext = enter(newPlugin); try { reattachMap(old, sysMaps, newPlugin.getSysInjector(), newPlugin); reattachMap(old, sshMaps, newPlugin.getSshInjector(), newPlugin); reattachMap(old, httpMaps, newPlugin.getHttpInjector(), newPlugin); reattachSet(old, sysSets, newPlugin.getSysInjector(), newPlugin); reattachSet(old, sshSets, newPlugin.getSshInjector(), newPlugin); reattachSet(old, httpSets, newPlugin.getHttpInjector(), newPlugin); reattachItem(old, sysItems, newPlugin.getSysInjector(), newPlugin); } finally { exit(oldContext); } }
void destroy(final com.google.gerrit.httpd.WebSessionManager.Key key) { self.invalidate(key.token); }
public void testlinkifyMessageChangeId() throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier(TestGitilesUrls.URLS); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "I0123456789")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "Change-Id: "), com.google.common.collect.ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "Change-Id: I0123456789")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "Change-Id: "), com.google.common.collect.ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), com.google.common.collect.ImmutableMap.of("text", " exists")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "Change-Id: I0123456789 exists")); }
public void testlinkifyMessageChangeIdNoGerrit() throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier(new com.google.gitiles.GitilesUrls() { @java.lang.Override public java.lang.String getBaseGerritUrl(javax.servlet.http.HttpServletRequest req) { return null; } @java.lang.Override public java.lang.String getHostName(javax.servlet.http.HttpServletRequest req) { throw new java.lang.UnsupportedOperationException(); } @java.lang.Override public java.lang.String getBaseGitUrl(javax.servlet.http.HttpServletRequest req) { throw new java.lang.UnsupportedOperationException(); } }); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "I0123456789")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "I0123456789")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "Change-Id: I0123456789")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "Change-Id: I0123456789")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "Change-Id: I0123456789 does not exist")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "Change-Id: I0123456789 does not exist")); }
public void testlinkifyMessageUrlAndChangeId() throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier(TestGitilesUrls.URLS); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "http://my/url/I0123456789", "url", "http://my/url/I0123456789"), com.google.common.collect.ImmutableMap.of("text", " is not change "), com.google.common.collect.ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "http://my/url/I0123456789 is not change I0123456789")); }
public void testlinkifyMessageNoMatch() throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier(TestGitilesUrls.URLS); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "some message text")), l.linkify(com.google.gitiles.FakeHttpServletRequest.newRequest(), "some message text")); }
public void testGetDuration() throws java.lang.Exception { org.joda.time.Duration def = org.joda.time.Duration.standardSeconds(2); org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); org.joda.time.Duration t; config.setString("core", "dht", "timeout", "500 ms"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertEquals(500, t.getMillis()); config.setString("core", "dht", "timeout", "5.2 sec"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertEquals(5200, t.getMillis()); config.setString("core", "dht", "timeout", "1 min"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "timeout", def); assertEquals(60000, t.getMillis()); }
public void testlinkifyMessageUrl() throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier(TestGitilesUrls.URLS); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "http://my/url", "url", "http://my/url")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "http://my/url")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "https://my/url", "url", "https://my/url")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "https://my/url")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "foo "), com.google.common.collect.ImmutableMap.of("text", "http://my/url", "url", "http://my/url"), com.google.common.collect.ImmutableMap.of("text", " bar")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "foo http://my/url bar")); assertEquals(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableMap.of("text", "foo "), com.google.common.collect.ImmutableMap.of("text", "http://my/url", "url", "http://my/url"), com.google.common.collect.ImmutableMap.of("text", " bar "), com.google.common.collect.ImmutableMap.of("text", "http://my/other/url", "url", "http://my/other/url"), com.google.common.collect.ImmutableMap.of("text", " baz")), l.linkify(com.google.gitiles.LinkifierTest.REQ, "foo http://my/url bar http://my/other/url baz")); }
public java.util.Map<java.lang.String, java.lang.Object> toSoyData(com.google.gitiles.Paginator paginator, @javax.annotation.Nullable java.lang.String revision, org.eclipse.jgit.util.GitDateFormatter df) throws java.io.IOException { java.util.Map<java.lang.String, java.lang.Object> data = com.google.common.collect.Maps.newHashMapWithExpectedSize(3); java.util.List<java.util.Map<java.lang.String, java.lang.Object>> entries = com.google.common.collect.Lists.newArrayListWithCapacity(paginator.getLimit()); for (org.eclipse.jgit.revwalk.RevCommit c : paginator) { entries.add(new com.google.gitiles.CommitSoyData().toSoyData(req, c, com.google.gitiles.LogSoyData.FIELDS, df)); } data.put("entries", entries); org.eclipse.jgit.lib.ObjectId next = paginator.getNextStart(); if (next != null) { data.put("nextUrl", com.google.gitiles.LogSoyData.copyAndCanonicalize(view, revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl()); } org.eclipse.jgit.lib.ObjectId prev = paginator.getPreviousStart(); if (prev != null) { com.google.gitiles.GitilesView.Builder prevView = com.google.gitiles.LogSoyData.copyAndCanonicalize(view, revision); if (!(prevView.getRevision().getId().equals(prev))) { prevView.replaceParam(LogServlet.START_PARAM, prev.name()); } data.put("previousUrl", prevView.toUrl()); } return data; }



private void doSetUserName() { if (!(canEditUserName())) { return; } java.lang.String newName = userNameTxt.getText(); if ("".equals(newName)) { newName = null; } if ((newName != null) && (!(newName.matches(Account.USER_NAME_PATTERN)))) { invalidUserName(); return; } enableUI(false); final java.lang.String newUserName = newName; Util.ACCOUNT_SEC.changeUserName(newUserName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.getUserAccount().setUserName(newUserName); userNameLbl.setText(newUserName); userNameLbl.setVisible(true); userNameTxt.setVisible(false); setUserName.setVisible(false); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enableUI(true); if (InvalidUserNameException.MESSAGE.equals(caught.getMessage())) { invalidUserName(); } else { super.onFailure(caught); } } }); }
@java.lang.Override protected void configureServlets() { serve("/*").with(com.googlesource.gerrit.plugins.serverconfig.ServerConfigServlet.class); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> list() throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
java.util.List<com.google.gerrit.extensions.common.ChangeInfo> query() throws com.google.gerrit.extensions.restapi.RestApiException;
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> query() throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
java.util.List<com.google.gerrit.extensions.common.ProjectInfo> list() throws com.google.gerrit.extensions.restapi.RestApiException;
private void findParameters(final java.util.List<com.google.gwtorm.schema.ColumnModel> r, final org.antlr.runtime.tree.Tree node) { switch (node.getType()) { case QueryParser.WHERE : extractParameters(r, node); break; default : for (int i = 0; i < (node.getChildCount()); i++) { findParameters(r, node.getChild(i)); } break; } }



@java.lang.Override public com.google.gerrit.server.change.ChangeJson.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.RevertInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ChangeControl control = req.getControl(); com.google.gerrit.reviewdb.client.Change change = req.getChange(); if (!(control.canAddPatchSet())) { throw new com.google.gerrit.extensions.restapi.AuthException("revert not permitted"); } else if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.change.Revert.status(change)))); } try { com.google.gerrit.reviewdb.client.Change.Id revertedChangeId = changeUtil.revert(control, change.currentPatchSetId(), com.google.common.base.Strings.emptyToNull(input.message), myIdent, new com.google.gerrit.server.ssh.NoSshInfo()); return json.format(revertedChangeId); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } }
@java.lang.Override void send(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { if (0 < (lastModified)) { res.setDateHeader("Last-Modified", lastModified); } res.setContentType(contentType); if ((characterEncoding) != null) { res.setCharacterEncoding(characterEncoding); } res.setContentLength(data.length); res.getOutputStream().write(data); }
void set(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list, com.google.gerrit.client.diff.DiffInfo info) { patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a()); patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b()); com.google.gwt.core.client.JsArrayString hdr = info.diff_header(); if (hdr != null) { java.lang.StringBuilder b = new java.lang.StringBuilder(); for (int i = 1; i < (hdr.length()); i++) { java.lang.String s = hdr.get(i); if ((((s.startsWith("diff --git ")) || (s.startsWith("index "))) || (s.startsWith("+++ "))) || (s.startsWith("--- "))) { continue; } b.append(s).append('\n'); } java.lang.String hdrTxt = b.toString().trim(); header = !(hdrTxt.isEmpty()); diffHeaderText.setInnerText(hdrTxt); com.google.gwt.user.client.ui.UIObject.setVisible(diffHeaderRow, header); } else { header = false; com.google.gwt.user.client.ui.UIObject.setVisible(diffHeaderRow, false); } }


@java.lang.Override public com.google.gerrit.server.config.CacheResource parse(com.google.gerrit.server.config.ConfigResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }


private java.util.Map<java.lang.String, com.google.common.cache.Cache<?, ?>> sortedPluginCaches() { java.util.SortedMap<java.lang.String, com.google.common.cache.Cache<?, ?>> m = com.google.common.collect.Maps.newTreeMap(); for (DynamicMap.Entry<com.google.common.cache.Cache<?, ?>> e : cacheMap) { if (!("gerrit".equals(e.getPluginName()))) { m.put(cacheNameOf(e.getPluginName(), e.getExportName()), e.getProvider().get()); } } return m; }

private java.lang.String percent(final long value, final long total) { if (total <= 0) { return ""; } final long pcent = (100 * value) / total; return java.lang.String.format("%3d%%", ((int) (pcent))); }

private java.lang.String count(long cnt) { if (cnt == 0) { return ""; } return java.lang.String.format("%6d", cnt); }





private void postAdd(com.google.gerrit.reviewdb.client.Change change, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> added) throws com.google.gerrit.common.errors.EmailException, com.google.gwtorm.server.OrmException { if (added.isEmpty()) { return; } com.google.gerrit.reviewdb.client.PatchSet patchSet = dbProvider.get().patchSets().get(change.currentPatchSetId()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(psa.getAccountId()).getAccount(); hooks.doReviewerAddedHook(change, account, patchSet, dbProvider.get()); } java.util.List<com.google.gerrit.reviewdb.client.Account.Id> toMail = com.google.common.collect.Lists.newArrayListWithCapacity(added.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { if (!(psa.getAccountId().equals(currentUser.getAccountId()))) { toMail.add(psa.getAccountId()); } } if (!(toMail.isEmpty())) { try { com.google.gerrit.server.mail.AddReviewerSender cm = addReviewerSenderFactory.create(change); cm.setFrom(currentUser.getAccountId()); cm.addReviewers(toMail); cm.send(); } catch (java.lang.Exception err) { com.google.gerrit.server.change.PostReviewers.log.error(("Cannot send email to new reviewers of change " + (change.getId())), err); } } }
private static void formatLink(com.google.gerrit.client.changes.ChangeInfo.GitPerson person, com.google.gerrit.client.ui.InlineHyperlink name, com.google.gwt.dom.client.Element date, com.google.gerrit.reviewdb.client.Change.Status status) { name.setText(com.google.gerrit.client.change.CommitBox.renderName(person)); name.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toAccountQuery(com.google.gerrit.client.change.CommitBox.owner(person), status)); date.setInnerText(com.google.gerrit.client.FormatUtil.mediumFormat(person.date())); }
private void renderOwner(com.google.gerrit.client.changes.ChangeInfo info) { java.lang.String name = ((info.owner().name()) != null) ? info.owner().name() : com.google.gerrit.client.Gerrit.getConfig().getAnonymousCowardName(); ownerLink.setText(name); ownerLink.setTitle(((info.owner().email()) != null ? info.owner().email() : name)); ownerLink.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toAccountQuery(((info.owner().name()) != null ? info.owner().name() : (info.owner().email()) != null ? info.owner().email() : java.lang.String.valueOf(info.owner()._account_id())), Change.Status.NEW)); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.RevisionResource resource) { com.google.gerrit.reviewdb.client.PatchSet.Id current = resource.getChange().currentPatchSetId(); return new com.google.gerrit.extensions.webui.UiAction.Description().setTitle(java.lang.String.format("Submit patch set %d into %s", resource.getPatchSet().getPatchSetId(), resource.getChange().getDest().getShortName())).setVisible(((((!(resource.getPatchSet().isDraft())) && (resource.getChange().getStatus().isOpen())) && (resource.getPatchSet().getId().equals(current))) && (resource.getControl().canSubmit()))); }
private void initRevisionActions(com.google.gerrit.client.changes.ChangeInfo info, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo, boolean hasUser) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (revInfo.has_actions()) ? revInfo.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); canSubmit = false; if (hasUser) { canSubmit = actions.containsKey("submit"); if (canSubmit) { submit.setTitle(actions.get("submit").title()); } com.google.gerrit.client.change.Actions.a2b(actions, "/", deleteRevision); com.google.gerrit.client.change.Actions.a2b(actions, "cherrypick", cherrypick); com.google.gerrit.client.change.Actions.a2b(actions, "publish", publish); com.google.gerrit.client.change.Actions.a2b(actions, "rebase", rebase); for (java.lang.String id : com.google.gerrit.client.change.Actions.filterNonCore(actions)) { add(new com.google.gerrit.client.actions.ActionButton(info, revInfo, actions.get(id))); } } }
public java.util.Set<java.lang.String> getNames(java.lang.String section, java.lang.String subsection) { java.util.Set<java.lang.String> secureConfigNames = secureConfig.getNames(section, subsection); java.util.Set<java.lang.String> gerritConfigNames = gerritConfig.getNames(section, subsection); gerritConfigNames.addAll(secureConfigNames); return gerritConfigNames; }



@org.junit.Test public void changeMessageWithTrailingDoubleNewline() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeMessage(("Testing trailing double newline\n" + "\n")); update.commit(); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = walk.parseCommit(update.getRevision()); walk.parseBody(commit); assertEquals(("Update patch set 1\n" + ((((("\n" + "Testing trailing double newline\n") + "\n") + "\n") + "\n") + "Patch-set: 1\n")), commit.getFullMessage()); } finally { walk.release(); } com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<java.lang.String> changeMessages = notes.getChangeMessages(); assertEquals(1, changeMessages.size()); assertEquals(("Testing trailing double newline\n" + "\n"), changeMessages.get(0)); }
public com.google.common.collect.ImmutableList<java.lang.String> getChangeMessages() { return changeMessages; }
@org.junit.Test public void noChangeMessage() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putReviewer(changeOwner.getAccount().getId(), com.google.gerrit.server.notedb.ReviewerState.REVIEWER); update.commit(); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = walk.parseCommit(update.getRevision()); walk.parseBody(commit); assertEquals(("Update patch set 1\n" + (("\n" + "Patch-set: 1\n") + "Reviewer: Change Owner <1@gerrit>\n")), commit.getFullMessage()); } finally { walk.release(); } com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<java.lang.String> changeMessages = notes.getChangeMessages(); assertEquals(0, changeMessages.size()); }
@org.junit.Test public void changeMessageWithMultipleParagraphs() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeMessage(("Testing paragraph 1\n" + ((("\n" + "Testing paragraph 2\n") + "\n") + "Testing paragraph 3"))); update.commit(); org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = walk.parseCommit(update.getRevision()); walk.parseBody(commit); assertEquals(("Update patch set 1\n" + ((((((("\n" + "Testing paragraph 1\n") + "\n") + "Testing paragraph 2\n") + "\n") + "Testing paragraph 3\n") + "\n") + "Patch-set: 1\n")), commit.getFullMessage()); } finally { walk.release(); } com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<java.lang.String> changeMessages = notes.getChangeMessages(); assertEquals(1, changeMessages.size()); assertEquals(("Testing paragraph 1\n" + ((("\n" + "Testing paragraph 2\n") + "\n") + "Testing paragraph 3")), changeMessages.get(0)); }
@org.junit.Test public void changeMessageOnePatchSet() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putReviewer(changeOwner.getAccount().getId(), com.google.gerrit.server.notedb.ReviewerState.REVIEWER); update.setChangeMessage("Just a little code change.\n"); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<java.lang.String> changeMessages = notes.getChangeMessages(); assertEquals(1, changeMessages.size()); assertEquals("Just a little code change.\n", changeMessages.get(0)); }
@org.junit.Test public void changeMessagesMultiplePatchSets() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putReviewer(changeOwner.getAccount().getId(), com.google.gerrit.server.notedb.ReviewerState.REVIEWER); update.setChangeMessage("This is the change message for the first PS."); update.commit(); com.google.gerrit.reviewdb.client.PatchSet.Id ps1 = c.currentPatchSetId(); com.google.gerrit.server.notedb.ChangeNotesTest.incrementPatchSet(c); update = newUpdate(c, changeOwner); update.setChangeMessage("This is the change message for the second PS."); update.commit(); com.google.gerrit.reviewdb.client.PatchSet.Id ps2 = c.currentPatchSetId(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<java.lang.String> changeMessages = notes.getChangeMessages(); assertEquals(2, changeMessages.size()); assertEquals("This is the change message for the second PS.", changeMessages.get(0)); assertEquals("This is the change message for the first PS.", changeMessages.get(1)); }
private void parseChangeMessage(org.eclipse.jgit.revwalk.RevCommit commit) { byte[] raw = commit.getRawBuffer(); int size = raw.length; java.nio.charset.Charset enc = org.eclipse.jgit.util.RawParseUtils.parseEncoding(raw); int subjectStart = org.eclipse.jgit.util.RawParseUtils.commitMessage(raw, 0); if ((subjectStart < 0) || (subjectStart >= size)) { return; } int subjectEnd = org.eclipse.jgit.util.RawParseUtils.endOfParagraph(raw, subjectStart); if (subjectEnd == size) { return; } int changeMessageStart; if ((raw[subjectEnd]) == '\n') { changeMessageStart = subjectEnd + 2; } else if ((raw[subjectEnd]) == '\r') { changeMessageStart = subjectEnd + 4; } else { return; } int ptr = size - 1; int changeMessageEnd = -1; while (ptr > changeMessageStart) { ptr = org.eclipse.jgit.util.RawParseUtils.prevLF(raw, ptr, '\r'); if (ptr == (-1)) { break; } if ((raw[ptr]) == '\n') { changeMessageEnd = ptr - 1; break; } else if ((raw[ptr]) == '\r') { changeMessageEnd = ptr - 3; break; } } if (ptr <= changeMessageStart) { return; } java.lang.String changeMessage = org.eclipse.jgit.util.RawParseUtils.decode(enc, raw, changeMessageStart, (changeMessageEnd + 1)); changeMessages.add(changeMessage); }




public abstract java.util.jar.JarFile getJarFile();
java.io.File getSrcJar() { return getSrcFile(); }
private void scan() throws com.google.gerrit.server.plugins.InvalidPluginException { java.util.Map<java.lang.Class<? extends java.lang.annotation.Annotation>, java.lang.Iterable<com.google.gerrit.server.plugins.JarScanner.ExtensionMetaData>> extensions = com.google.gerrit.server.plugins.JarScanner.scan(jarFile, pluginName, java.util.Arrays.asList(com.google.gerrit.extensions.annotations.Export.class, com.google.gerrit.extensions.annotations.Listen.class)); for (com.google.gerrit.server.plugins.JarScanner.ExtensionMetaData export : extensions.get(com.google.gerrit.extensions.annotations.Export.class)) { export(export); } for (com.google.gerrit.server.plugins.JarScanner.ExtensionMetaData listener : extensions.get(com.google.gerrit.extensions.annotations.Listen.class)) { listen(listener); } }
public java.util.jar.JarFile getJarFile() { return jarFile; }

private static java.lang.String getPrefix(com.google.gerrit.server.plugins.Plugin plugin, java.lang.String attr, java.lang.String def) { java.util.jar.JarFile jarFile = plugin.getJarFile(); if (jarFile == null) { return def; } try { java.lang.String prefix = jarFile.getManifest().getMainAttributes().getValue(attr); if (prefix != null) { return (com.google.common.base.CharMatcher.is('/').trimFrom(prefix)) + "/"; } else { return def; } } catch (java.io.IOException e) { com.google.gerrit.httpd.plugins.HttpPluginServlet.log.warn(java.lang.String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e); return null; } }
private void setMerged(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.ChangeMessage msg) throws com.google.gwtorm.server.OrmException, java.io.IOException { try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change().currentPatchSetId(); c = setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged); addMergedMessage(submitter, msg); db.commit(); sendMergedEmail(c, submitter); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db); } catch (com.google.gwtorm.server.OrmException ex) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } } finally { db.rollback(); } indexer.index(db, c); }
public com.google.gerrit.reviewdb.client.ChangeMessage getConflictMessage(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.Iterables.getFirst(com.google.common.collect.Iterables.filter(com.google.common.collect.Lists.reverse(dbProvider.get().changeMessages().byChange(rsrc.getChange().getId()).toList()), new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.ChangeMessage>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.ChangeMessage input) { return (input.getAuthor()) == null; } }), null); }
@java.lang.Override public void run() { rc.processCommands(commands, progress); }
private Change.Key closeChange(final org.eclipse.jgit.transport.ReceiveCommand cmd, final com.google.gerrit.reviewdb.client.PatchSet.Id psi, final org.eclipse.jgit.revwalk.RevCommit commit) throws com.google.gwtorm.server.OrmException, java.io.IOException { final java.lang.String refName = cmd.getRefName(); final com.google.gerrit.reviewdb.client.Change.Id cid = psi.getParentKey(); final com.google.gerrit.reviewdb.client.Change change = db.changes().get(cid); final com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().get(psi); if ((change == null) || (ps == null)) { com.google.gerrit.server.git.ReceiveCommits.log.warn(((((project.getName()) + " ") + psi) + " is missing")); return null; } if ((((change.getStatus()) == (Change.Status.MERGED)) || ((change.getStatus()) == (Change.Status.ABANDONED))) || (!(change.getDest().get().equals(refName)))) { return null; } com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest result = new com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest(cid, commit, cmd, false); result.change = change; result.changeCtl = projectControl.controlFor(change); result.newPatchSet = ps; result.info = patchSetInfoFactory.get(commit, psi); result.mergedIntoRef = refName; markChangeMergedByPush(db, result); hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db); sendMergedEmail(result); return change.getKey(); }

private void abandonOneChange(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException, java.io.IOException { db.changes().beginTransaction(change.getId()); try { change = db.changes().atomicUpdate(change.getId(), new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if (change.getStatus().isOpen()) { change.setStatus(Change.Status.ABANDONED); return change; } return null; } }); if (change != null) { com.google.gerrit.reviewdb.client.ChangeMessage msg = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId()); msg.setMessage("Project was deleted."); db.changeMessages().insert(java.util.Collections.singleton(msg)); db.commit(); indexer.index(db, change); } } finally { db.rollback(); } }

private void saveCookie() { final java.lang.String token; final int ageSeconds; if ((key) == null) { token = ""; ageSeconds = 0; } else { token = key.getToken(); ageSeconds = manager.getCookieAge(val); } java.lang.String path = authConfig.getCookiePath(); if ((path == null) || (path.isEmpty())) { path = request.getContextPath(); if ((path == null) || (path.isEmpty())) { path = "/"; } } if ((outCookie) != null) { throw new java.lang.IllegalStateException((("Cookie " + (com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE)) + " was set")); } outCookie = new javax.servlet.http.Cookie(com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE, token); outCookie.setSecure(com.google.gerrit.httpd.CacheBasedWebSession.isSecure(request)); outCookie.setPath(path); outCookie.setMaxAge(ageSeconds); outCookie.setSecure(authConfig.getCookieSecure()); response.addCookie(outCookie); }
public static java.lang.String defaultAbbreviation(java.lang.String name) { java.lang.StringBuilder abbr = new java.lang.StringBuilder(); for (int i = 0; i < (name.length()); i++) { char c = name.charAt(i); if ((c >= 'A') && (c <= 'Z')) { abbr.append(c); } } if ((abbr.length()) == 0) { abbr.append(java.lang.Character.toUpperCase(name.charAt(0))); } return abbr.toString(); }




@org.junit.Test public void queryChangesReviewer() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.Changes.QueryRequest q = gApi.changes().query("owner:self"); assertEquals(r.getChangeId(), com.google.common.collect.Iterables.getOnlyElement(q.get()).changeId); setAccountContext(user); assertTrue(q.get().isEmpty()); }
@java.lang.Override protected void service(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { if (((req.getQueryString()) == null) || (req.getQueryString().isEmpty())) { rsp.sendRedirect(((req.getContextPath()) + "/")); return; } final java.util.Map<java.lang.String, java.lang.String> params = com.google.gerrit.httpd.gitweb.GitWebServlet.getParameters(req); if (deniedActions.contains(params.get("a"))) { rsp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } java.lang.String name = params.get("p"); if (name == null) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); return; } if (name.endsWith(".git")) { name = name.substring(0, ((name.length()) - 4)); } final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(name); final com.google.gerrit.server.project.ProjectControl project; try { project = projectControl.validateFor(nameKey); if ((!(project.allRefsAreVisible())) && (!(project.isOwner()))) { throw new com.google.gerrit.server.project.NoSuchProjectException(nameKey); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); return; } final org.eclipse.jgit.lib.Repository repo; try { repo = repoManager.openRepository(nameKey); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { getServletContext().log("Cannot open repository", e); rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; } try { com.google.gwtexpui.server.CacheHeaders.setNotCacheable(rsp); exec(req, rsp, project, repo); } finally { repo.close(); } }

@java.lang.Override public synchronized void schedule(final com.google.gerrit.reviewdb.client.Branch.NameKey branch) { com.google.gerrit.server.git.ChangeMergeQueue.MergeEntry e = active.get(branch); if (e == null) { e = new com.google.gerrit.server.git.ChangeMergeQueue.MergeEntry(branch); active.put(branch, e); } e.needMerge = true; scheduleJob(e); }
private void sendResource(java.util.jar.JarFile jar, java.util.jar.JarEntry entry, com.google.gerrit.httpd.plugins.ResourceKey key, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { byte[] data = null; if ((entry.getSize()) <= (com.google.gerrit.httpd.plugins.HttpPluginServlet.SMALL_RESOURCE)) { data = com.google.gerrit.httpd.plugins.HttpPluginServlet.readWholeEntry(jar, entry); } java.lang.String contentType = null; java.lang.String charEnc = null; java.util.jar.Attributes atts = entry.getAttributes(); if (atts != null) { contentType = com.google.common.base.Strings.emptyToNull(atts.getValue("Content-Type")); charEnc = com.google.common.base.Strings.emptyToNull(atts.getValue("Character-Encoding")); } if (contentType == null) { contentType = mimeUtil.getMimeType(entry.getName(), data).toString(); if (("application/octet-stream".equals(contentType)) && (entry.getName().endsWith(".js"))) { contentType = "application/javascript"; } } long time = entry.getTime(); if (0 < time) { res.setDateHeader("Last-Modified", time); } res.setHeader("Content-Length", java.lang.Long.toString(entry.getSize())); res.setContentType(contentType); if (charEnc != null) { res.setCharacterEncoding(charEnc); } if (data != null) { resourceCache.put(key, new com.google.gerrit.httpd.plugins.SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time)); res.getOutputStream().write(data); } else { writeToResponse(res, jar.getInputStream(entry)); } }
private void sendMarkdownAsHtml(java.util.jar.JarFile jar, java.util.jar.JarEntry entry, java.lang.String pluginName, com.google.gerrit.httpd.plugins.ResourceKey key, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { byte[] rawmd = com.google.gerrit.httpd.plugins.HttpPluginServlet.readWholeEntry(jar, entry); java.lang.String encoding = null; java.util.jar.Attributes atts = entry.getAttributes(); if (atts != null) { encoding = com.google.common.base.Strings.emptyToNull(atts.getValue("Character-Encoding")); } java.lang.String txtmd = org.eclipse.jgit.util.RawParseUtils.decode(java.nio.charset.Charset.forName((encoding != null ? encoding : "UTF-8")), rawmd); long time = entry.getTime(); if (0 < time) { res.setDateHeader("Last-Modified", time); } sendMarkdownAsHtml(txtmd, pluginName, key, res); }
private static java.lang.String getPrefix(com.google.gerrit.server.plugins.Plugin plugin, java.lang.String attr, java.lang.String def) { java.util.jar.JarFile jarFile = plugin.getJarFile(); if (jarFile == null) { return def; } try { java.lang.String prefix = jarFile.getManifest().getMainAttributes().getValue(attr); if (prefix != null) { return (com.google.common.base.CharMatcher.is('/').trimFrom(prefix)) + "/"; } else { return def; } } catch (java.io.IOException e) { com.google.gerrit.httpd.plugins.HttpPluginServlet.log.warn(java.lang.String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e); return null; } }
private static byte[] readWholeEntry(java.util.jar.JarFile jar, java.util.jar.JarEntry entry) throws java.io.IOException { byte[] data = new byte[((int) (entry.getSize()))]; java.io.InputStream in = jar.getInputStream(entry); try { org.eclipse.jgit.util.IO.readFully(in, data, 0, data.length); } finally { in.close(); } return data; }














protected void configure() { persist(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.REPO_SIZE_CACHE, Project.NameKey.class, java.util.concurrent.atomic.AtomicLong.class).loader(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.Loader.class).expireAfterWrite(1, java.util.concurrent.TimeUnit.DAYS); }
@java.lang.Override public void onPostReceive(org.eclipse.jgit.transport.ReceivePack rp, java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { com.google.gerrit.reviewdb.client.Project.NameKey project = projectName(rp); try { cache.get(project).getAndAdd(rp.getPackSize()); } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.log.warn(("Couldn't process onPostReceive for " + (project.get())), e); } }
private com.googlesource.gerrit.plugins.quota.Publisher.RepoSizeEvent createEvent() throws java.util.concurrent.ExecutionException { com.googlesource.gerrit.plugins.quota.Publisher.RepoSizeEvent event = new com.googlesource.gerrit.plugins.quota.Publisher.RepoSizeEvent(); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all()) { long size = repoSizeCache.get(p).get(); event.addData(size, p.get()); } return event; }
@java.lang.Override public void run() { if (!(listeners.iterator().hasNext())) { return; } try { com.googlesource.gerrit.plugins.quota.Publisher.RepoSizeEvent event = createEvent(); for (com.google.gerrit.extensions.events.UsageDataPublishedListener l : listeners) { try { l.onUsageDataPublished(event); } catch (java.lang.RuntimeException e) { com.googlesource.gerrit.plugins.quota.Publisher.log.warn("Failure in UsageDataPublishedListener", e); } } } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.quota.Publisher.log.warn("Error accessing repoSizeCache", e); } }
static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { protected void configure() { persist(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.REPO_SIZE_CACHE, Project.NameKey.class, java.util.concurrent.atomic.AtomicLong.class).loader(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.Loader.class).expireAfterWrite(1, java.util.concurrent.TimeUnit.DAYS); } }; }

@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { if (!(projectControl.canRunUploadPack())) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); if (!(projectControl.allRefsAreVisible())) { up.setAdvertiseRefsHook(new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true)); } up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.upload(in, out, err); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain next) throws java.io.IOException, javax.servlet.ServletException { org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(request); com.google.gerrit.server.project.ProjectControl pc = ((com.google.gerrit.server.project.ProjectControl) (request.getAttribute(com.google.gerrit.httpd.GitOverHttpServlet.ATT_CONTROL))); org.eclipse.jgit.transport.UploadPack up = ((org.eclipse.jgit.transport.UploadPack) (request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER))); if (!(pc.canRunUploadPack())) { org.eclipse.jgit.http.server.GitSmartHttpTools.sendError(((javax.servlet.http.HttpServletRequest) (request)), ((javax.servlet.http.HttpServletResponse) (response)), HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server"); return; } if (!(pc.allRefsAreVisible())) { up.setAdvertiseRefsHook(new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true)); } next.doFilter(request, response); }



@org.junit.After public void tearDown() { if ((executor) != null) { executor.close(); } executor = null; if ((db) != null) { try { db.close(); } catch (java.sql.SQLException e) { throw new java.lang.RuntimeException("Cannot close database", e); } } db = null; }
@org.junit.After public void tearDown() { if ((executor) != null) { executor.close(); } executor = null; if ((db) != null) { try { db.close(); } catch (java.sql.SQLException e) { throw new java.lang.RuntimeException("Cannot close database", e); } } db = null; }


private com.google.gerrit.server.plugins.Plugin loadPlugin(java.lang.String name, java.io.File srcPlugin, org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot) throws com.google.gerrit.server.plugins.InvalidPluginException, java.io.IOException, java.lang.ClassNotFoundException { java.lang.String pluginName = srcPlugin.getName(); if (com.google.gerrit.server.plugins.PluginLoader.isJarPlugin(pluginName)) { java.io.File tmp; java.io.FileInputStream in = new java.io.FileInputStream(srcPlugin); java.lang.String extension = com.google.gerrit.server.plugins.PluginLoader.getExtension(srcPlugin); try { tmp = com.google.gerrit.server.plugins.PluginLoader.asTemp(in, com.google.gerrit.server.plugins.PluginLoader.tempNameFor(name), extension, tmpDir); } finally { in.close(); } return loadJarPlugin(name, srcPlugin, snapshot, tmp); } else if (com.google.gerrit.server.plugins.PluginLoader.isJsPlugin(pluginName)) { return loadJsPlugin(name, srcPlugin, snapshot); } else { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Unsupported plugin type: %s", srcPlugin.getName())); } }
@java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((((com.google.gerrit.server.plugins.PluginLoader.isJarPlugin(n)) || (com.google.gerrit.server.plugins.PluginLoader.isJsPlugin(n))) && (!(n.startsWith(".last_")))) && (!(n.startsWith(".next_")))) && (pathname.isFile()); }
public static java.lang.String getPluginName(java.io.File srcFile) throws java.io.IOException { return com.google.common.base.Objects.firstNonNull(com.google.gerrit.server.plugins.PluginLoader.getGerritPluginName(srcFile), com.google.gerrit.server.plugins.PluginLoader.nameOf(srcFile)).toLowerCase(); }
private static java.util.List<java.io.File> scanJarsInPluginsDirectory(java.io.File pluginsDir) { if ((pluginsDir == null) || (!(pluginsDir.exists()))) { return java.util.Collections.emptyList(); } java.io.File[] matches = pluginsDir.listFiles(new java.io.FileFilter() { @java.lang.Override public boolean accept(java.io.File pathname) { java.lang.String n = pathname.getName(); return ((((com.google.gerrit.server.plugins.PluginLoader.isJarPlugin(n)) || (com.google.gerrit.server.plugins.PluginLoader.isJsPlugin(n))) && (!(n.startsWith(".last_")))) && (!(n.startsWith(".next_")))) && (pathname.isFile()); } }); if (matches == null) { com.google.gerrit.server.plugins.PluginLoader.log.error(("Cannot list " + (pluginsDir.getAbsolutePath()))); return java.util.Collections.emptyList(); } return java.util.Arrays.asList(matches); }





@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.cookbook.HelloTopMenu.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.PatchSetWebLink.class).to(com.googlesource.gerrit.plugins.cookbook.HelloWeblink.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.ProjectWebLink.class).to(com.googlesource.gerrit.plugins.cookbook.HelloWeblink.class); install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { post(com.googlesource.gerrit.plugins.cookbook.REVISION_KIND, "hello-revision").to(com.googlesource.gerrit.plugins.cookbook.HelloRevisionAction.class); post(com.googlesource.gerrit.plugins.cookbook.PROJECT_KIND, "hello-project").to(com.googlesource.gerrit.plugins.cookbook.HelloProjectAction.class); get(com.googlesource.gerrit.plugins.cookbook.REVISION_KIND, "greetings").to(com.googlesource.gerrit.plugins.cookbook.Greetings.class); } }); configurePluginParameters(); }


private java.util.jar.Manifest getPluginManifest(com.google.gerrit.server.plugins.PluginScanner scanner) throws com.google.gerrit.server.plugins.InvalidPluginException { try { return scanner.getManifest(); } catch (java.io.IOException e) { throw new com.google.gerrit.server.plugins.InvalidPluginException("Cannot get plugin manifest", e); } }

private void loadDefaults() { approvals = com.google.common.collect.ImmutableListMultimap.of(); reviewers = com.google.common.collect.ImmutableSetMultimap.of(); submitRecords = com.google.common.collect.ImmutableList.of(); changeMessages = com.google.common.collect.ImmutableListMultimap.of(); }
public org.eclipse.jgit.revwalk.RevCommit commit() throws java.io.IOException { com.google.gerrit.server.notedb.BatchMetaDataUpdate batch = openUpdate(); try { batch.write(new org.eclipse.jgit.lib.CommitBuilder()); return batch.commit(); } finally { batch.close(); } }




@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = getRevision(); if (rev == null) { loadDefaults(); return; } org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(reader); try { com.google.gerrit.server.notedb.ChangeNotes.Parser parser = new com.google.gerrit.server.notedb.ChangeNotes.Parser(change.getId(), rev, walk); parser.parseAll(); if ((parser.status) != null) { change.setStatus(parser.status); } approvals = parser.buildApprovals(); changeMessages = parser.buildMessages(); ImmutableSetMultimap.Builder<com.google.gerrit.server.notedb.ReviewerState, com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.ImmutableSetMultimap.builder(); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.notedb.ReviewerState> e : parser.reviewers.entrySet()) { reviewers.put(e.getValue(), e.getKey()); } this.reviewers = reviewers.build(); submitRecords = com.google.common.collect.ImmutableList.copyOf(parser.submitRecords); } finally { walk.release(); } }

private com.google.gerrit.server.plugins.Plugin loadPlugin(java.lang.String name, java.io.File srcPlugin, org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot) throws com.google.gerrit.server.plugins.InvalidPluginException, java.io.IOException, java.lang.ClassNotFoundException { java.lang.String pluginName = srcPlugin.getName(); if (com.google.gerrit.server.plugins.PluginLoader.isJarPlugin(pluginName)) { java.io.File tmp; java.io.FileInputStream in = new java.io.FileInputStream(srcPlugin); java.lang.String extension = com.google.gerrit.server.plugins.PluginLoader.getExtension(srcPlugin); try { tmp = com.google.gerrit.server.plugins.PluginLoader.asTemp(in, com.google.gerrit.server.plugins.PluginLoader.tempNameFor(name), extension, tmpDir); } finally { in.close(); } return loadJarPlugin(name, srcPlugin, snapshot, tmp); } else if (com.google.gerrit.server.plugins.PluginLoader.isJsPlugin(pluginName)) { return loadJsPlugin(name, srcPlugin, snapshot); } else if (externalPluginFactory.handles(srcPlugin)) { name = externalPluginFactory.getPluginName(srcPlugin); return loadExternalPlugin(name, srcPlugin, snapshot); } else { throw new com.google.gerrit.server.plugins.InvalidPluginException(java.lang.String.format("Unsupported plugin type: %s", srcPlugin.getName())); } }

private com.google.gerrit.server.plugins.ServerPlugin loadExternalPlugin(java.lang.String name, java.io.File scriptFile, org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot) throws com.google.gerrit.server.plugins.InvalidPluginException { return externalPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name)); }


private com.google.inject.Injector getPluginInjector(java.io.File jarFile) throws java.io.IOException { final java.lang.String pluginName = com.google.common.base.Objects.firstNonNull(com.google.gerrit.server.plugins.PluginLoader.getGerritJarPluginName(jarFile), com.google.gerrit.server.plugins.PluginLoader.nameOf(jarFile)); return initInjector.createChildInjector(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(pluginName); } }); }

@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.cookbook.HelloTopMenu.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.PatchSetWebLink.class).to(com.googlesource.gerrit.plugins.cookbook.HelloWeblink.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.ProjectWebLink.class).to(com.googlesource.gerrit.plugins.cookbook.HelloWeblink.class); install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { post(com.googlesource.gerrit.plugins.cookbook.REVISION_KIND, "hello-revision").to(com.googlesource.gerrit.plugins.cookbook.HelloRevisionAction.class); post(com.googlesource.gerrit.plugins.cookbook.PROJECT_KIND, "hello-project").to(com.googlesource.gerrit.plugins.cookbook.HelloProjectAction.class); get(com.googlesource.gerrit.plugins.cookbook.REVISION_KIND, "greetings").to(com.googlesource.gerrit.plugins.cookbook.Greetings.class); } }); configurePluginParameters(); }
private static java.lang.String formatChangeUrl(java.lang.String url, com.google.gerrit.reviewdb.client.Change change) { java.lang.StringBuilder m = new java.lang.StringBuilder().append(" ").append(url).append(change.getChangeId()); if ((change.getStatus()) == (Change.Status.DRAFT)) { m.append(" [DRAFT]"); } return m.toString(); }

@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.CacheResource.CACHE_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.CapabilityResource.CAPABILITY_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.ConfigResource.CONFIG_KIND); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.config.TopMenuResource.TOP_MENU_KIND); child(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "caches").to(com.google.gerrit.server.config.CachesCollection.class); get(com.google.gerrit.server.config.CacheResource.CACHE_KIND).to(com.google.gerrit.server.config.GetCache.class); child(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "capabilities").to(com.google.gerrit.server.config.CapabilitiesCollection.class); child(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "top-menus").to(com.google.gerrit.server.config.TopMenuCollection.class); get(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "version").to(com.google.gerrit.server.config.GetVersion.class); get(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "preferences").to(com.google.gerrit.server.config.GetPreferences.class); put(com.google.gerrit.server.config.ConfigResource.CONFIG_KIND, "preferences").to(com.google.gerrit.server.config.SetPreferences.class); }

@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCaches.CacheInfo> apply(com.google.gerrit.server.config.ConfigResource rsrc) { java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCaches.CacheInfo> cacheInfos = new java.util.TreeMap<>(); for (java.util.Map.Entry<java.lang.String, com.google.common.cache.Cache<?, ?>> entry : getCaches().entrySet()) { cacheInfos.put(entry.getKey(), new com.google.gerrit.server.config.ListCaches.CacheInfo(entry.getValue())); } return cacheInfos; }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.PostCaches.Input input) throws com.google.gerrit.extensions.restapi.BadRequestException { if (!(com.google.gerrit.server.config.PostCaches.Operation.LIST.equals(input.operation))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("unsupported operation: " + (input.operation))); } return listCaches.get().getCaches().keySet(); }


@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.PostCaches.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((input == null) || ((input.operation) == null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("operation must be specified"); } switch (input.operation) { case FLUSH_ALL : for (DynamicMap.Entry<com.google.common.cache.Cache<?, ?>> e : cacheMap) { com.google.gerrit.server.config.CacheResource cacheResource = new com.google.gerrit.server.config.CacheResource(e.getPluginName(), e.getExportName(), e.getProvider()); if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) { continue; } flushCache.get().apply(cacheResource, new com.google.gerrit.server.config.FlushCache.Input()); } return com.google.gerrit.extensions.restapi.Response.ok("ok"); default : throw new com.google.gerrit.extensions.restapi.BadRequestException(("unsupported operation: " + (input.operation))); } }

@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { if (list) { if ((all) || ((caches.size()) > 0)) { throw com.google.gerrit.sshd.commands.FlushCaches.error("error: cannot use --list with --all or --cache"); } doList(); return; } if ((all) && ((caches.size()) > 0)) { throw com.google.gerrit.sshd.commands.FlushCaches.error("error: cannot combine --all and --cache"); } else if (((!(all)) && ((caches.size()) == 1)) && (caches.contains("all"))) { caches.clear(); all = true; } else if ((!(all)) && (caches.isEmpty())) { all = true; } if (all) { postCaches.get().apply(new com.google.gerrit.server.config.ConfigResource(), new com.google.gerrit.server.config.PostCaches.Input(FLUSH_ALL)); } else { java.util.List<java.lang.String> names = cacheNames(); for (java.lang.String n : caches) { if (!(names.contains(n))) { throw com.google.gerrit.sshd.commands.FlushCaches.error((("error: cache \"" + n) + "\" not recognized")); } } doBulkFlush(); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private void doList() throws com.google.gerrit.extensions.restapi.RestApiException { for (java.lang.String name : cacheNames()) { stderr.print(name); stderr.print('\n'); } stderr.flush(); }





private java.util.TreeSet<java.util.Map.Entry<java.lang.String, java.io.File>> jarsFirstSortedPluginsSet(java.util.Map<java.lang.String, java.io.File> activePlugins) { java.util.TreeSet<java.util.Map.Entry<java.lang.String, java.io.File>> sortedPlugins = com.google.common.collect.Sets.newTreeSet(new java.util.Comparator<java.util.Map.Entry<java.lang.String, java.io.File>>() { @java.lang.Override public int compare(java.util.Map.Entry<java.lang.String, java.io.File> entry1, java.util.Map.Entry<java.lang.String, java.io.File> entry2) { java.lang.String file1 = entry1.getValue().getName(); java.lang.String file2 = entry2.getValue().getName(); int cmp = file1.compareTo(file2); if (file1.endsWith(".jar")) { return file2.endsWith(".jar") ? cmp : -1; } else { return file2.endsWith(".jar") ? +1 : cmp; } } }); sortedPlugins.addAll(activePlugins.entrySet()); return sortedPlugins; }




private static void assertComment(com.google.gerrit.reviewdb.client.PatchLineComment plc, com.google.gerrit.server.change.CommentInfo ci) { assertEquals(plc.getKey().get(), ci.id); assertEquals(plc.getParentUuid(), ci.inReplyTo); assertEquals(plc.getMessage(), ci.message); assertNotNull(ci.author); assertEquals(plc.getAuthor(), ci.author._id); assertEquals(plc.getLine(), ((int) (ci.line))); assertEquals(((plc.getSide()) == 0 ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), com.google.common.base.Objects.firstNonNull(ci.side, Side.REVISION)); assertEquals(plc.getWrittenOn(), ci.updated); assertEquals(plc.getRange(), ci.range); }

@java.lang.Override public java.lang.String toString() { java.lang.StringBuilder builder = new java.lang.StringBuilder(); builder.append("PatchLineComment{"); builder.append("key=").append(key).append(','); builder.append("lineNbr=").append(lineNbr).append(','); builder.append("author=").append(author.get()).append(','); builder.append("writtenOn=").append(writtenOn.toString()).append(','); builder.append("status=").append(status).append(','); builder.append("side=").append(side).append(','); builder.append("message=").append(java.util.Objects.toString(message, "")).append(','); builder.append("parentUuid=").append(java.util.Objects.toString(parentUuid, "")).append(','); builder.append("range=").append(java.util.Objects.toString(range, "")).append(','); builder.append("revId=").append(((revId) != null ? revId.get() : "")); builder.append('}'); return builder.toString(); }











@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(com.google.gerrit.server.project.PerRequestProjectControlCache.class).in(com.google.inject.servlet.RequestScoped.class); bind(ChangeControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(SubmoduleOp.Factory.class); factory(MergeOp.Factory.class); factory(SuggestParentCandidates.Factory.class); factory(BanCommit.Factory.class); }

@java.lang.Override public com.google.gerrit.server.config.TaskResource parse(com.google.gerrit.server.config.ConfigResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected void run() { for (final java.lang.Integer id : taskIds) { final com.google.gerrit.server.git.WorkQueue.Task<?> task = workQueue.getTask(id); if (task != null) { task.cancel(true); } else { stderr.print((("kill: " + (com.google.gerrit.server.util.IdGenerator.format(id))) + ": No such task\n")); } } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { final com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(projectControl, commitsToBan, reason); final java.util.List<org.eclipse.jgit.lib.ObjectId> newlyBannedCommits = result.getNewlyBannedCommits(); if (!(newlyBannedCommits.isEmpty())) { stdout.print("The following commits were banned:\n"); com.google.gerrit.sshd.commands.BanCommitCommand.printCommits(stdout, newlyBannedCommits); } final java.util.List<org.eclipse.jgit.lib.ObjectId> alreadyBannedCommits = result.getAlreadyBannedCommits(); if (!(alreadyBannedCommits.isEmpty())) { stdout.print("The following commits were already banned:\n"); com.google.gerrit.sshd.commands.BanCommitCommand.printCommits(stdout, alreadyBannedCommits); } final java.util.List<org.eclipse.jgit.lib.ObjectId> ignoredIds = result.getIgnoredObjectIds(); if (!(ignoredIds.isEmpty())) { stdout.print(("The following ids do not represent commits" + " and were ignored:\n")); com.google.gerrit.sshd.commands.BanCommitCommand.printCommits(stdout, ignoredIds); } } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw die(e); } catch (java.io.IOException e) { throw die(e); } catch (com.google.gerrit.server.git.MergeException e) { throw die(e); } catch (java.lang.InterruptedException e) { throw die(e); } catch (org.eclipse.jgit.api.errors.ConcurrentRefUpdateException e) { throw die(e); } }
private static void printCommits(final java.io.PrintWriter stdout, final java.util.List<org.eclipse.jgit.lib.ObjectId> commits) { boolean first = true; for (final org.eclipse.jgit.lib.ObjectId c : commits) { if (!first) { stdout.print(",\n"); } stdout.print(c.getName()); first = false; } stdout.print("\n\n"); }



public static com.google.gerrit.client.account.AccountInfo asInfo(com.google.gerrit.common.data.AccountInfo acct) { if (acct == null) { return com.google.gerrit.client.account.AccountInfo.create(0, null, null); } return com.google.gerrit.client.account.AccountInfo.create(((acct.getId()) != null ? acct.getId().get() : 0), acct.getFullName(), acct.getPreferredEmail()); }

private org.eclipse.jgit.lib.ObjectId storeCommentsInNotes() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = ctl.getNotes(); org.eclipse.jgit.notes.NoteMap noteMap = notes.getNoteMap(); if (noteMap == null) { noteMap = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); } if ((commentsForPs.isEmpty()) && (commentsForBase.isEmpty())) { return null; } com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnBases = notes.getBaseComments(); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnPs = notes.getPatchSetComments(); if (!(commentsForBase.isEmpty())) { writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase); } if (!(commentsForPs.isEmpty())) { writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs); } return noteMap.writeTree(inserter); }
private boolean isEmpty() { return ((((((approvals.isEmpty()) && (reviewers.isEmpty())) && (commentsForBase.isEmpty())) && (commentsForPs.isEmpty())) && ((status) == null)) && ((submitRecords) == null)) && ((changeMessage) == null); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { }

public com.google.gerrit.server.notedb.ChangeNotes load() throws com.google.gwtorm.server.OrmException { if (!(loaded)) { org.eclipse.jgit.lib.Repository repo; try { repo = repoManager.openRepository(change.getProject()); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } try { load(repo); loaded = true; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } finally { repo.close(); } } return this; }
private void parseComments(org.eclipse.jgit.revwalk.RevCommit commit) throws java.io.IOException, java.text.ParseException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref sharedMeta = repo.getRef(com.google.gerrit.server.notedb.ChangeNoteUtil.changeRefName(changeId)); if (sharedMeta != null) { org.eclipse.jgit.revwalk.RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId()); commentNoteMap = org.eclipse.jgit.notes.NoteMap.read(walk.getObjectReader(), sharedBaseCommit); } java.util.Iterator<org.eclipse.jgit.notes.Note> notes = commentNoteMap.iterator(); while (notes.hasNext()) { org.eclipse.jgit.notes.Note next = notes.next(); byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> result = com.google.gerrit.server.notedb.CommentsInNotesUtil.parseNote(bytes, changeId); if ((result == null) || (result.isEmpty())) { continue; } com.google.gerrit.reviewdb.client.PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey(); short side = result.get(0).getSide(); if (side == 0) { commentsForBase.putAll(psId, result); } else { commentsForPs.putAll(psId, result); } } }



@java.lang.Override public com.google.gwtorm.server.OrmException convertError(final java.lang.String op, final java.lang.String entity, final java.sql.SQLException err) { switch (getSQLStateInt(err)) { case 23505 : return new com.google.gwtorm.server.OrmDuplicateKeyException(entity, err); case 23514 : case 23503 : case 23502 : case 23001 : default : return super.convertError(op, entity, err); } }
public com.google.gwtorm.server.OrmException convertError(final java.lang.String op, final java.lang.String entity, final java.sql.SQLException err) { if (((err.getCause()) == null) && ((err.getNextException()) != null)) { err.initCause(err.getNextException()); } return new com.google.gwtorm.server.OrmException(((op + " failure on ") + entity), err); }
private java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> scan() { if ((matchPrefix) != null) { return projectCache.byName(matchPrefix); } else if ((matchSubstring) != null) { return com.google.common.collect.Iterables.filter(projectCache.all(), new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.Project.NameKey>() { public boolean apply(com.google.gerrit.reviewdb.client.Project.NameKey in) { return in.get().toLowerCase(java.util.Locale.US).contains(matchSubstring.toLowerCase(java.util.Locale.US)); } }); } else { return projectCache.all(); } }




public static synchronized java.io.File createTempDirectory() throws java.io.IOException { java.io.File tmp = java.io.File.createTempFile("gerrit_test_", ""); if ((!(tmp.delete())) || (!(tmp.mkdir()))) { throw new java.io.IOException(("Cannot create " + (tmp.getPath()))); } com.google.gerrit.acceptance.TempFileUtil.allDirsCreated.add(tmp); return tmp; }
private org.eclipse.jgit.lib.ObjectId storeCommentsInNotes() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = ctl.getNotes(); org.eclipse.jgit.notes.NoteMap noteMap = notes.getNoteMap(); if (noteMap == null) { noteMap = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); } if ((commentsForPs.isEmpty()) && (commentsForBase.isEmpty())) { return null; } com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnBases = notes.getBaseComments(); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnPs = notes.getPatchSetComments(); if (!(commentsForBase.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> baseCommentsForThisPs = new java.util.ArrayList(allCommentsOnBases.get(psId)); baseCommentsForThisPs.addAll(commentsForBase); commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter); } if (!(commentsForPs.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> commentsForThisPs = new java.util.ArrayList(allCommentsOnPs.get(psId)); commentsForThisPs.addAll(commentsForPs); commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter); } return noteMap.writeTree(inserter); }
private void sendForm(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, @com.google.gerrit.common.Nullable java.lang.String errorMessage) throws java.io.IOException { java.lang.String self = req.getRequestURI(); java.lang.String cancel = com.google.common.base.Objects.firstNonNull(urlProvider.get(req), "/"); java.lang.String token = com.google.gerrit.httpd.auth.ldap.LdapLoginServlet.getToken(req); if (!(token.equals("/"))) { cancel += "#" + token; } org.w3c.dom.Document doc = headers.parse(com.google.gerrit.httpd.auth.ldap.LdapLoginServlet.class, "LoginForm.html"); com.google.gerrit.httpd.HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName()); com.google.gerrit.httpd.HtmlDomUtil.find(doc, "login_form").setAttribute("action", self); com.google.gerrit.httpd.HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel); org.w3c.dom.Element emsg = com.google.gerrit.httpd.HtmlDomUtil.find(doc, "error_message"); if (com.google.common.base.Strings.isNullOrEmpty(errorMessage)) { emsg.getParentNode().removeChild(emsg); } else { emsg.setTextContent(errorMessage); } byte[] bin = com.google.gerrit.httpd.HtmlDomUtil.toUTF8(doc); res.setStatus(HttpServletResponse.SC_UNAUTHORIZED); res.setContentType("text/html"); res.setCharacterEncoding("UTF-8"); res.setContentLength(bin.length); javax.servlet.ServletOutputStream out = res.getOutputStream(); try { out.write(bin); } finally { out.close(); } }

public static java.lang.String loginRedirect(java.lang.String token) { if (token == null) { token = ""; } else if (token.startsWith("/")) { token = token.substring(1); } return com.google.gerrit.client.Gerrit.selfRedirect(("/login/" + token)); }
public static java.lang.String selfRedirect(java.lang.String suffix) { java.lang.String path = com.google.gwt.user.client.Window.Location.getPath(); if ((path == null) || (path.isEmpty())) { path = "/"; } else { while (path.startsWith("//")) { path = path.substring(1); } while (path.endsWith("//")) { path = path.substring(0, ((path.length()) - 1)); } if (!(path.endsWith("/"))) { path = path + "/"; } } if (suffix != null) { while (suffix.startsWith("/")) { suffix = suffix.substring(1); } path += suffix; } com.google.gwt.http.client.UrlBuilder builder = new com.google.gwt.http.client.UrlBuilder(); builder.setProtocol(com.google.gwt.user.client.Window.Location.getProtocol()); builder.setHost(com.google.gwt.user.client.Window.Location.getHost()); java.lang.String port = com.google.gwt.user.client.Window.Location.getPort(); if ((port != null) && (!(port.isEmpty()))) { builder.setPort(java.lang.Integer.parseInt(port)); } builder.setPath(path); return builder.buildString(); }
public void writeCommentsToNoteMap(org.eclipse.jgit.notes.NoteMap noteMap, java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> allComments, org.eclipse.jgit.lib.ObjectInserter inserter) throws com.google.gwtorm.server.OrmException, java.io.IOException { org.eclipse.jgit.lib.ObjectId commitOID = org.eclipse.jgit.lib.ObjectId.fromString(allComments.get(0).getRevId().get()); java.util.Collections.sort(allComments, ChangeNotes.PatchLineCommentComparator); byte[] note = buildNote(allComments); org.eclipse.jgit.lib.ObjectId noteId = inserter.insert(Constants.OBJ_BLOB, note, 0, note.length); noteMap.set(commitOID, noteId); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.account.GetEmails.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.CreateEmail.Input input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.server.account.CreateEmail.Input(); } if (!(org.apache.commons.validator.routines.EmailValidator.getInstance().isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid email address"); } if ((input.noConfirmation) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("must be administrator to use no_confirmation"); } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canGenerateHttpPassword()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to clear HTTP password"); } newPassword = null; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "need to be Gerrit administrator")); } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canGenerateHttpPassword()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to clear HTTP password"); } newPassword = null; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "need to be Gerrit administrator")); } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
@org.junit.Test public void testInheritDuplicateSections() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(util.getParentConfig(), com.google.gerrit.server.project.READ, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.Util.DEVS, "refs/heads/*"); local.getProject().setParentName(util.getParentConfig().getProject().getName()); assertTrue("a can read", util.user(local, "a", com.google.gerrit.server.project.Util.ADMIN).isVisible()); local = new com.google.gerrit.server.git.ProjectConfig(new com.google.gerrit.reviewdb.client.Project.NameKey("local")); local.load(newRepository(localKey)); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.Util.DEVS, "refs/*"); assertTrue("d can read", util.user(local, "d", com.google.gerrit.server.project.Util.DEVS).isVisible()); }
public com.google.gerrit.server.notedb.DraftCommentNotes getDraftComments(com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (((draftCommentNotes) == null) || (!(author.equals(draftCommentNotes.getAuthor())))) { draftCommentNotes = new com.google.gerrit.server.notedb.DraftCommentNotes(repoManager, allUsersRepo, getChange(), author); draftCommentNotes.load(); } return draftCommentNotes; }










private com.google.gerrit.server.notedb.ChangeUpdate newUpdate(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.IdentifiedUser user) throws java.lang.Exception { return com.google.gerrit.testutil.TestChanges.newUpdate(injector, repoManager, c, user); }



private void streamFile(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.io.File f = configFile(req); res.setStatus(HttpServletResponse.SC_OK); res.setContentType("application/octet-stream"); res.setContentLength(((int) (f.length()))); java.io.OutputStream out = res.getOutputStream(); java.io.InputStream in = new java.io.FileInputStream(f); try { com.google.common.io.ByteStreams.copy(in, out); } finally { in.close(); } }
@java.lang.Override public void doPut(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { if (!(isValidFile(req))) { res.setStatus(HttpServletResponse.SC_FORBIDDEN); return; } writeFile(req, res); }


private void verifyInstallPluginList(com.google.gerrit.pgm.init.ConsoleUI ui, java.util.List<com.google.gerrit.common.PluginData> plugins) { if ((com.google.gerrit.pgm.Init.nullOrEmpty(installPlugins)) || (com.google.gerrit.pgm.Init.nullOrEmpty(plugins))) { return; } java.util.ArrayList<java.lang.String> copy = com.google.common.collect.Lists.newArrayList(installPlugins); java.util.List<java.lang.String> pluginNames = com.google.common.collect.Lists.transform(plugins, new com.google.common.base.Function<com.google.gerrit.common.PluginData, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.common.PluginData input) { return input.name; } }); copy.removeAll(pluginNames); if (!(copy.isEmpty())) { ui.message("Cannot find plugin(s): %s\n", com.google.common.base.Joiner.on(", ").join(copy)); listPlugins = true; } }
@java.lang.Override protected com.google.gerrit.pgm.init.ConsoleUI getConsoleUI() { return com.google.gerrit.pgm.init.ConsoleUI.getInstance(batchMode); }
@java.lang.Override protected boolean beforeInit(com.google.gerrit.pgm.SiteInit init) throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); if (!(skipPlugins)) { final java.util.List<com.google.gerrit.common.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution); com.google.gerrit.pgm.init.ConsoleUI ui = com.google.gerrit.pgm.init.ConsoleUI.getInstance(false); verifyInstallPluginList(ui, plugins); if (listPlugins) { if (!(plugins.isEmpty())) { ui.message("Available plugins:\n"); for (com.google.gerrit.common.PluginData plugin : plugins) { ui.message(" * %s version %s\n", plugin.name, plugin.version); } } else { ui.message("No plugins found.\n"); } return true; } } return false; }
@java.lang.SuppressWarnings("resource") private com.google.gerrit.pgm.init.InitStep loadInitStep(java.io.File jar) { try { java.net.URLClassLoader pluginLoader = new java.net.URLClassLoader(new java.net.URL[]{ jar.toURI().toURL() }, com.google.gerrit.pgm.init.InitPluginStepsLoader.class.getClassLoader()); try (java.util.jar.JarFile jarFile = new java.util.jar.JarFile(jar)) { java.util.jar.Attributes jarFileAttributes = jarFile.getManifest().getMainAttributes(); java.lang.String initClassName = jarFileAttributes.getValue("Gerrit-InitStep"); if (initClassName == null) { return null; } @java.lang.SuppressWarnings("unchecked") java.lang.Class<? extends com.google.gerrit.pgm.init.InitStep> initStepClass = ((java.lang.Class<? extends com.google.gerrit.pgm.init.InitStep>) (pluginLoader.loadClass(initClassName))); return getPluginInjector(jar).getInstance(initStepClass); } catch (java.lang.ClassCastException e) { ui.message("WARN: InitStep from plugin %s does not implement %s (Exception: %s)", jar.getName(), com.google.gerrit.pgm.init.InitStep.class.getName(), e.getMessage()); return null; } } catch (java.lang.Exception e) { ui.message("WARN: Cannot load and get plugin init step for %s (Exception: %s)", jar, e.getMessage()); return null; } }
com.google.gerrit.pgm.init.Section get(@com.google.inject.assistedinject.Assisted("section") java.lang.String section, @com.google.inject.assistedinject.Assisted("subsection") java.lang.String subsection);
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section database) { boolean hasUrl = (com.google.common.base.Strings.emptyToNull(database.get("url"))) != null; database.string("URL", "url", null); guessDriver(database); database.string("Driver class name", "driver", null); database.string("Database username", "username", (hasUrl ? null : com.google.gerrit.pgm.init.InitUtil.username())); database.password("username", "password"); }
private void guessDriver(com.google.gerrit.pgm.init.Section database) { java.lang.String url = com.google.common.base.Strings.emptyToNull(database.get("url")); if ((url != null) && (com.google.common.base.Strings.isNullOrEmpty(database.get("driver")))) { if (url.startsWith("jdbc:h2:")) { database.set("driver", "org.h2.Driver"); } else if (url.startsWith("jdbc:mysql:")) { database.set("driver", "com.mysql.jdbc.Driver"); } else if (url.startsWith("jdbc:postgresql:")) { database.set("driver", "org.postgresql.Driver"); } } }
@java.lang.Override public com.google.gerrit.pgm.init.Section get(java.lang.String name, java.lang.String subsection) { return new com.google.gerrit.pgm.init.Section(flags, site, ui, name, subsection); }
public java.lang.String passwordForKey(java.lang.String key, java.lang.String password) { java.lang.String ov = getSecure(password); if (ov != null) { if ((ui.isBatch()) || (!(ui.yesno(false, "Change %s", key)))) { return ov; } } final java.lang.String nv = ui.password("%s", key); if (!(com.google.gerrit.pgm.init.Section.eq(ov, nv))) { setSecure(password, nv); } return nv; }
public java.util.Collection<com.google.gerrit.pgm.init.InitStep> getInitSteps() { java.util.List<java.io.File> jars = scanJarsInPluginsDirectory(); java.util.ArrayList<com.google.gerrit.pgm.init.InitStep> pluginsInitSteps = new java.util.ArrayList<>(); for (java.io.File jar : jars) { com.google.gerrit.pgm.init.InitStep init = loadInitStep(jar); if (init != null) { pluginsInitSteps.add(init); } } return pluginsInitSteps; }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.init.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); java.util.List<java.lang.String> plugins = com.google.common.base.Objects.firstNonNull(getInstallPlugins(), com.google.common.collect.Lists.<java.lang.String>newArrayList()); bind(new com.google.inject.TypeLiteral<java.util.List<java.lang.String>>() {}).annotatedWith(com.google.gerrit.pgm.init.InstallPlugins.class).toInstance(plugins); bind(com.google.gerrit.pgm.init.PluginsDistribution.class).toInstance(pluginsDistribution); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.init.ConsoleUI.class).toInstance(init.ui); bind(com.google.gerrit.pgm.init.InitFlags.class).toInstance(init.flags); }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section databaseSection) { final java.lang.String defPort = "(postgresql default)"; databaseSection.string("Server hostname", "hostname", "localhost"); databaseSection.string("Server port", "port", defPort, true); databaseSection.string("Database name", "database", "reviewdb"); databaseSection.string("Database username", "username", com.google.gerrit.pgm.init.InitUtil.username()); databaseSection.password("username", "password"); }
public java.lang.String select(final java.lang.String title, final java.lang.String name, final java.lang.String dv, java.util.Set<java.lang.String> allowedValues) { final java.lang.String ov = get(name); java.lang.String nv = ui.readString((ov != null ? ov : dv), allowedValues, "%s", title); if (!(com.google.gerrit.pgm.init.Section.eq(ov, nv))) { set(name, nv); } return nv; }
public java.lang.String string(final java.lang.String title, final java.lang.String name, final java.lang.String dv, final boolean nullIfDefault) { final java.lang.String ov = get(name); java.lang.String nv = ui.readString((ov != null ? ov : dv), "%s", title); if (nullIfDefault && (nv.equals(dv))) { nv = null; } if (!(com.google.gerrit.pgm.init.Section.eq(ov, nv))) { set(name, nv); } return nv; }
public java.lang.String password(final java.lang.String username, final java.lang.String password) { final java.lang.String ov = getSecure(password); java.lang.String user = flags.sec.getString(section, subsection, username); if (user == null) { user = get(username); } if (user == null) { flags.sec.unset(section, subsection, password); return null; } if (ov != null) { if ((ui.isBatch()) || (!(ui.yesno(false, "Change %s's password", user)))) { return ov; } } final java.lang.String nv = ui.password("%s's password", user); if (!(com.google.gerrit.pgm.init.Section.eq(ov, nv))) { setSecure(password, nv); } return nv; }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section databaseSection) { final java.lang.String defPort = "1521"; databaseSection.string("Server hostname", "hostname", "localhost"); databaseSection.string("Server port", "port", defPort, false); databaseSection.string("Instance name", "instance", "xe"); databaseSection.string("Database username", "username", com.google.gerrit.pgm.init.InitUtil.username()); databaseSection.password("username", "password"); }
private void setuser(final com.google.gerrit.pgm.init.Section database, java.lang.String username, java.lang.String password) { if ((username != null) && (!(username.isEmpty()))) { database.set("username", username); } if ((password != null) && (!(password.isEmpty()))) { sec.setString("database", null, "password", password); } }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.config.SitePaths.class); bind(com.google.gerrit.pgm.init.InitFlags.class); bind(com.google.gerrit.pgm.init.Libraries.class); bind(com.google.gerrit.pgm.init.LibraryDownloader.class); factory(Section.Factory.class); step().to(com.google.gerrit.pgm.init.UpgradeFrom2_0_x.class); step().to(com.google.gerrit.pgm.init.InitGitManager.class); if (initDb) { step().to(com.google.gerrit.pgm.init.InitDatabase.class); } step().to(com.google.gerrit.pgm.init.InitIndex.class); step().to(com.google.gerrit.pgm.init.InitAuth.class); step().to(com.google.gerrit.pgm.init.InitLabels.class); step().to(com.google.gerrit.pgm.init.InitSendEmail.class); if (standalone) { step().to(com.google.gerrit.pgm.init.InitContainer.class); } step().to(com.google.gerrit.pgm.init.InitSshd.class); step().to(com.google.gerrit.pgm.init.InitHttpd.class); step().to(com.google.gerrit.pgm.init.InitCache.class); step().to(com.google.gerrit.pgm.init.InitPlugins.class); }
protected com.google.inject.binder.LinkedBindingBuilder<com.google.gerrit.pgm.init.InitStep> step() { final java.lang.annotation.Annotation id = com.google.inject.internal.UniqueAnnotations.create(); return bind(com.google.gerrit.pgm.init.InitStep.class).annotatedWith(id); }
private static java.util.List<com.google.gerrit.pgm.init.InitStep> stepsOf(final com.google.inject.Injector injector) { final java.util.ArrayList<com.google.gerrit.pgm.init.InitStep> r = new java.util.ArrayList<>(); for (com.google.inject.Binding<com.google.gerrit.pgm.init.InitStep> b : com.google.gerrit.pgm.init.SitePathInitializer.all(injector)) { r.add(b.getProvider().get()); } return r; }
public void postRun() throws java.lang.Exception { for (com.google.gerrit.pgm.init.InitStep step : steps) { if ((step instanceof com.google.gerrit.pgm.init.InitPlugins) && (flags.skipPlugins)) { continue; } step.postRun(); } }
private void sethost(final com.google.gerrit.pgm.init.Section database, final java.net.InetSocketAddress addr) { database.set("hostname", com.google.gerrit.server.util.SocketUtil.hostname(addr)); if (0 < (addr.getPort())) { database.set("port", java.lang.String.valueOf(addr.getPort())); } }
private com.google.inject.Injector createSysInjector(final com.google.gerrit.pgm.BaseInit.SiteInit init) { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.init.ConsoleUI.class).toInstance(init.ui); bind(com.google.gerrit.pgm.init.InitFlags.class).toInstance(init.flags); } }); return createDbInjector(com.google.gerrit.pgm.SINGLE_USER).createChildInjector(modules); }
public static com.google.gerrit.pgm.init.ConsoleUI getInstance(final boolean batchMode) { java.io.Console console = (batchMode) ? null : java.lang.System.console(); return console != null ? new com.google.gerrit.pgm.init.ConsoleUI.Interactive(console) : new com.google.gerrit.pgm.init.ConsoleUI.Batch(); }
private static java.util.List<com.google.inject.Binding<com.google.gerrit.pgm.init.InitStep>> all(final com.google.inject.Injector injector) { return injector.findBindingsByType(new com.google.inject.TypeLiteral<com.google.gerrit.pgm.init.InitStep>() {}); }
public static com.google.gerrit.pgm.init.ConsoleUI getInstance() { return com.google.gerrit.pgm.init.ConsoleUI.getInstance(false); }
@org.junit.Test public void testCreate() throws java.io.FileNotFoundException { final com.google.gerrit.server.config.SitePaths site = new com.google.gerrit.server.config.SitePaths(new java.io.File(".")); final com.google.gerrit.pgm.init.ConsoleUI ui = createStrictMock(com.google.gerrit.pgm.init.ConsoleUI.class); replay(ui); com.google.gerrit.pgm.init.Libraries lib = new com.google.gerrit.pgm.init.Libraries(new com.google.inject.Provider<com.google.gerrit.pgm.init.LibraryDownloader>() { @java.lang.Override public com.google.gerrit.pgm.init.LibraryDownloader get() { return new com.google.gerrit.pgm.init.LibraryDownloader(ui, site); } }); assertNotNull(lib.bouncyCastleProvider); assertNotNull(lib.mysqlDriver); verify(ui); }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section databaseSection) { final java.lang.String defPort = "(maxdb default)"; databaseSection.string("Server hostname", "hostname", "localhost"); databaseSection.string("Server port", "port", defPort, true); databaseSection.string("Database name", "database", "reviewdb"); databaseSection.string("Database username", "username", com.google.gerrit.pgm.init.InitUtil.username()); databaseSection.password("username", "password"); }
private void postInitPlugins() throws java.lang.Exception { for (com.google.gerrit.pgm.init.InitStep initStep : pluginLoader.getInitSteps()) { initStep.postRun(); } }
private void initPlugins() throws java.lang.Exception { for (com.google.gerrit.pgm.init.InitStep initStep : pluginLoader.getInitSteps()) { initStep.run(); } }
public void initConfig(com.google.gerrit.pgm.init.Section databaseSection);
@java.lang.Override public void waitForUser() { if ((console.readLine("Press enter to continue ")) == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } }
protected com.google.gerrit.pgm.init.ConsoleUI getConsoleUI() { return com.google.gerrit.pgm.init.ConsoleUI.getInstance(false); }
@java.lang.Override public java.lang.String readString(java.lang.String def, java.lang.String fmt, java.lang.Object... args) { final java.lang.String prompt = java.lang.String.format(fmt, args); java.lang.String r; if (def != null) { r = console.readLine("%-30s [%s]: ", prompt, def); } else { r = console.readLine("%-30s : ", prompt); } if (r == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } r = r.trim(); if (r.isEmpty()) { return def; } return r; }
@java.lang.Override public boolean yesno(java.lang.Boolean def, java.lang.String fmt, java.lang.Object... args) { final java.lang.String prompt = java.lang.String.format(fmt, args); for (; ;) { java.lang.String y = "y"; java.lang.String n = "n"; if (def != null) { if (def) { y = "Y"; } else { n = "N"; } } java.lang.String yn = console.readLine("%-30s [%s/%s]? ", prompt, y, n); if (yn == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } yn = yn.trim(); if ((def != null) && (yn.isEmpty())) { return def; } if ((yn.equalsIgnoreCase("y")) || (yn.equalsIgnoreCase("yes"))) { return true; } if ((yn.equalsIgnoreCase("n")) || (yn.equalsIgnoreCase("no"))) { return false; } } }
@java.lang.Override public java.lang.String password(java.lang.String fmt, java.lang.Object... args) { final java.lang.String prompt = java.lang.String.format(fmt, args); for (; ;) { final char[] a1 = console.readPassword("%-30s : ", prompt); if (a1 == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } final char[] a2 = console.readPassword("%30s : ", "confirm password"); if (a2 == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } final java.lang.String s1 = new java.lang.String(a1); final java.lang.String s2 = new java.lang.String(a2); if (!(s1.equals(s2))) { console.printf("error: Passwords did not match; try again\n"); continue; } return !(s1.isEmpty()) ? s1 : null; } }
@java.lang.Override public <T extends java.lang.Enum<?>> T readEnum(T def, java.lang.String fmt, java.lang.Object... args) { final java.lang.String prompt = java.lang.String.format(fmt, args); final T[] options = com.google.gerrit.pgm.init.ConsoleUI.all(def); for (; ;) { java.lang.String r = console.readLine("%-30s [%s/?]: ", prompt, def.toString()); if (r == null) { throw com.google.gerrit.pgm.init.ConsoleUI.abort(); } r = r.trim(); if (r.isEmpty()) { return def; } for (final T e : options) { if (equalsIgnoreCase(e.toString(), r)) { return e; } } if (!("?".equals(r))) { console.printf("error: \'%s\' is not a valid choice\n", r); } console.printf(" Supported options are:\n"); for (final T e : options) { console.printf(" %s\n", e.toString().toLowerCase()); } } }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section databaseSection) { java.lang.String path = databaseSection.get("database"); if (path == null) { path = "db/ReviewDB"; databaseSection.set("database", path); } java.io.File db = site.resolve(path); if (db == null) { throw com.google.gerrit.pgm.init.InitUtil.die("database.database must be supplied for H2"); } db = db.getParentFile(); if ((!(db.exists())) && (!(db.mkdirs()))) { throw com.google.gerrit.pgm.init.InitUtil.die(("cannot create database.database " + (db.getAbsolutePath()))); } }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.Section databaseSection) { final java.lang.String defPort = "(mysql default)"; databaseSection.string("Server hostname", "hostname", "localhost"); databaseSection.string("Server port", "port", defPort, true); databaseSection.string("Database name", "database", "reviewdb"); databaseSection.string("Database username", "username", com.google.gerrit.pgm.init.InitUtil.username()); databaseSection.password("username", "password"); }
private boolean isEmpty() { return ((((((approvals.isEmpty()) && (reviewers.isEmpty())) && (commentsForBase.isEmpty())) && (commentsForPs.isEmpty())) && ((status) == null)) && ((submitRecords) == null)) && ((changeMessage) == null); }


private void writeFileAndFireAuditEvent(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.io.File oldFile = configFile(req); java.io.File dir = oldFile.getParentFile(); java.io.File newFile = java.io.File.createTempFile(oldFile.getName(), ".new", dir); streamRequestToFile(req, newFile); java.lang.String diff = com.googlesource.gerrit.plugins.serverconfig.ServerConfigServlet.diff(oldFile, newFile); audit("about to change config file", oldFile.getPath(), diff); newFile.renameTo(oldFile); audit("changed config file", oldFile.getPath(), diff); res.setStatus(HttpServletResponse.SC_NO_CONTENT); }

public void testChangeRefReplicated() throws com.google.gwtorm.server.OrmException, java.net.URISyntaxException { com.google.gerrit.reviewdb.client.Change expectedChange = new com.google.gerrit.reviewdb.client.Change(null, null, null, null, null); reset(changeAccessMock); expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange); replay(changeAccessMock); reset(changeHooksMock); com.googlesource.gerrit.plugins.replication.RefReplicatedEvent expectedEvent = new com.googlesource.gerrit.plugins.replication.RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult.FAILED); changeHooksMock.postEvent(eq(expectedChange), com.googlesource.gerrit.plugins.replication.RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(com.google.gerrit.reviewdb.server.ReviewDb.class)); expectLastCall().once(); replay(changeHooksMock); gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/changes/1/1/1", new org.eclipse.jgit.transport.URIish("git://someHost/someProject.git"), RefPushResult.FAILED); verify(changeHooksMock); }

public boolean canReadCommit(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(getProject().getNameKey()); try { com.google.gerrit.server.git.VisibleRefFilter filter = new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, this, db, true); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> visibleRefs = filter.filter(repo.getAllRefs(), true); if ((!(visibleRefs.isEmpty())) && (com.google.gerrit.server.change.IncludedInResolver.includedInOne(repo, rw, commit, visibleRefs.values()))) { return true; } } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey()); com.google.gerrit.server.project.ProjectControl.log.error(msg, e); } return false; }
@org.junit.Test public void canReadAfterRollbackWithAllRefsVisible() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.Util.DEVS, "refs/*"); org.eclipse.jgit.revwalk.RevCommit parent1 = repo.commit().create(); org.eclipse.jgit.lib.ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create(); com.google.gerrit.server.project.ProjectControl pc = util.user(project, com.google.gerrit.server.project.Util.DEVS); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1))); assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1))); repo.branch("branch1").update(parent1); assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1))); assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1))); }
public boolean canReadCommit(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { if (controlForRef("refs/*").canPerform(Permission.READ)) { return true; } com.google.gerrit.reviewdb.client.Project.NameKey projName = state.getProject().getNameKey(); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projName); try { org.eclipse.jgit.lib.RefDatabase refDb = repo.getRefDatabase(); java.util.List<org.eclipse.jgit.lib.Ref> allRefs = com.google.common.collect.Lists.newLinkedList(); allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values()); allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values()); java.util.List<org.eclipse.jgit.lib.Ref> canReadRefs = com.google.common.collect.Lists.newLinkedList(); for (org.eclipse.jgit.lib.Ref r : allRefs) { if (controlForRef(r.getName()).canPerform(Permission.READ)) { canReadRefs.add(r); } } if ((!(canReadRefs.isEmpty())) && (com.google.gerrit.server.change.IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs))) { return true; } } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get()); com.google.gerrit.server.project.ProjectControl.log.error(msg, e); } return false; }
@java.lang.Override public com.google.gerrit.server.project.CommitResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId objectId; try { objectId = org.eclipse.jgit.lib.ObjectId.fromString(id.get()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(parent.getNameKey()); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(objectId); if (!(parent.getControl().canReadCommit(rw, commit))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.project.CommitResource(parent.getControl(), commit.copy()); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } finally { rw.release(); } } finally { repo.close(); } }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.CommitResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { return new com.google.gerrit.server.project.FileResource(parent.getNameKey(), parent.getCommitId().getName(), id.get()); }
@java.lang.Override public com.google.gerrit.extensions.common.CommitInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey()); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { return toCommitInfo(rw, rsrc.getCommitId()); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getCommitId().name()); } finally { rw.release(); } } finally { repo.close(); } }

public static com.google.gerrit.reviewdb.client.Change newChange(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser user) { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id(1); com.google.gerrit.reviewdb.client.Change c = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), changeId, user.getAccount().getId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(project, "master"), com.google.gerrit.server.util.TimeUtil.nowTs()); com.google.gerrit.testutil.TestChanges.incrementPatchSet(c); return c; }

public com.google.gerrit.reviewdb.client.PatchLineComment get(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchLineComment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().get(key); } for (com.google.gerrit.reviewdb.client.PatchLineComment c : byChange(db, notes)) { if (key.equals(c.getKey())) { return c; } } return null; }

public java.util.Collection<com.google.gerrit.reviewdb.client.PatchLineComment> comments() throws com.google.gwtorm.server.OrmException { if ((comments) == null) { comments = plcUtil.byChange(db, notes()); } return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> byChange(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().byChange(notes.getChangeId()).toList(); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getBaseComments().values()); comments.addAll(notes.getPatchSetComments().values()); java.util.Set<java.lang.String> refNames = getRefNamesAllUsers(RefNames.REFS_USER); for (java.lang.String refName : refNames) { java.lang.String suffix = (com.google.gerrit.reviewdb.client.RefNames.REFS_DRAFT_PREFIX) + (java.lang.Integer.toString(notes.getChangeId().get())); if (!(refName.endsWith(suffix))) { continue; } com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefPart(refName); comments.addAll(draftByChangeAuthor(db, notes, account)); } return comments; }

private void appendQuotedParent(java.lang.StringBuilder out, com.google.gerrit.reviewdb.client.PatchLineComment child) { if ((child.getParentUuid()) != null) { com.google.gerrit.reviewdb.client.PatchLineComment parent; try { parent = args.db.get().patchComments().get(new com.google.gerrit.reviewdb.client.PatchLineComment.Key(child.getKey().getParentKey(), child.getParentUuid())); } catch (com.google.gwtorm.server.OrmException e) { parent = null; } if (parent != null) { java.lang.String msg = parent.getMessage().trim(); if ((msg.length()) > 75) { msg = msg.substring(0, 75); } int lf = msg.indexOf('\n'); if (lf > 0) { msg = msg.substring(0, lf); } out.append("> ").append(msg).append('\n'); } } }

public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedByPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { if (!(migration.readPublishedComments())) { return db.patchComments().publishedByPatchSet(psId).toList(); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> commentsOnPs = new java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>(); commentsOnPs.addAll(notes.getPatchSetComments().get(psId)); commentsOnPs.addAll(notes.getBaseComments().get(psId)); return commentsOnPs; }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.change.CommentInfo> apply(com.google.gerrit.server.change.DraftResource rsrc, com.google.gerrit.server.change.DeleteDraft.Input input) throws com.google.gwtorm.server.OrmException { db.get().patchComments().delete(java.util.Collections.singleton(rsrc.getComment())); return com.google.gerrit.extensions.restapi.Response.none(); }
@com.google.common.annotations.VisibleForTesting static com.google.gerrit.server.notedb.NotesMigration allEnabled() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setBoolean("notedb", null, "write", true); cfg.setBoolean("notedb", "patchSetApprovals", "read", true); cfg.setBoolean("notedb", "changeMessages", "read", true); cfg.setBoolean("notedb", "publishedComments", "read", true); return new com.google.gerrit.server.notedb.NotesMigration(cfg); }
protected boolean includeAuthorInfo() { return false; }



public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedByChangeFile(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Change.Id changeId, java.lang.String file) throws com.google.gwtorm.server.OrmException { if (!(migration.readPublishedComments())) { return db.patchComments().publishedByChangeFile(changeId, file).toList(); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> commentsOnFile = new java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>(); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsInFile(commentsOnFile, notes.getPatchSetComments().values(), file); java.util.Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator); return commentsOnFile; }




public static java.lang.String refsDraftComments(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Change.Id changeId) { java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); r.append('/'); r.append(com.google.gerrit.reviewdb.client.RefNames.REFS_DRAFT_PREFIX); r.append(changeId.get()); return r.toString(); }
private void assertRefs(java.lang.String... expected) throws java.lang.Exception { java.lang.String out = sshSession.exec(java.lang.String.format("gerrit ls-user-refs -p %s -u %s", project.get(), user.getId().get())); assertFalse(sshSession.getError(), sshSession.hasError()); com.google.common.base.Splitter s = com.google.common.base.Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings(); assertEquals(java.util.Arrays.asList(expected), com.google.common.collect.Ordering.natural().sortedCopy(s.split(out))); }
public static com.google.gerrit.reviewdb.client.Change.Id fromRef(java.lang.String ref) { int cs = com.google.gerrit.reviewdb.client.Change.Id.startIndex(ref); if (cs < 0) { return null; } int ce = com.google.gerrit.reviewdb.client.Change.Id.nextNonDigit(ref, cs); int patchSetId = PatchSet.Id.fromRef(ref, ce); if (patchSetId < 0) { return null; } return new com.google.gerrit.reviewdb.client.Change.Id(java.lang.Integer.parseInt(ref.substring(cs, ce))); }

private static com.google.gerrit.server.change.ChangeJson.GitPerson toGitPerson(com.google.gerrit.reviewdb.client.UserIdentity committer) { com.google.gerrit.server.change.ChangeJson.GitPerson p = new com.google.gerrit.server.change.ChangeJson.GitPerson(); p.name = committer.getName(); p.email = committer.getEmail(); p.date = committer.getDate(); p.tz = committer.getTimeZone(); return p; }

javax.naming.directory.DirContext open() throws javax.naming.NamingException, javax.security.auth.login.LoginException { final java.util.Properties env = createContextProperties(); env.put(javax.naming.Context.SECURITY_AUTHENTICATION, ((authentication) != null ? authentication : "simple")); env.put(javax.naming.Context.REFERRAL, ((referral) != null ? referral : "ignore")); if ("GSSAPI".equals(authentication)) { return kerberosOpen(env); } else { if ((username) != null) { env.put(javax.naming.Context.SECURITY_PRINCIPAL, username); env.put(javax.naming.Context.SECURITY_CREDENTIALS, ((password) != null ? password : "")); } return new javax.naming.directory.InitialDirContext(env); } }



public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedByChangeFile(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Change.Id changeId, java.lang.String file) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().publishedByChangeFile(changeId, file).toList(); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsOnFile(comments, notes.getBaseComments().values(), file); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsOnFile(comments, notes.getPatchSetComments().values(), file); java.util.Collections.sort(comments, ChangeNotes.PatchLineCommentComparator); return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChange(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); java.lang.Iterable<java.lang.String> filtered = getDraftRefs(notes.getChangeId()); for (java.lang.String refName : filtered) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefPart(refName); if (account != null) { comments.addAll(draftByChangeAuthor(db, notes, account)); } } return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChangeFileAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, java.lang.String file, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().draftByChangeFileAuthor(notes.getChangeId(), file, author).toList(); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsOnFile(comments, notes.getDraftBaseComments(author).values(), file); com.google.gerrit.server.PatchLineCommentsUtil.addCommentsOnFile(comments, notes.getDraftPsComments(author).values(), file); java.util.Collections.sort(comments, ChangeNotes.PatchLineCommentComparator); return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByPatchSetAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.reviewdb.client.Account.Id author, com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().draftByPatchSetAuthor(psId, author).toList(); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getDraftBaseComments(author).row(psId).values()); comments.addAll(notes.getDraftPsComments(author).row(psId).values()); java.util.Collections.sort(comments, ChangeNotes.PatchLineCommentComparator); return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedByPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().publishedByPatchSet(psId).toList(); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = new java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>(); comments.addAll(notes.getPatchSetComments().get(psId)); comments.addAll(notes.getBaseComments().get(psId)); return comments; }

public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().draftByAuthor(author).toList(); } java.util.Set<java.lang.String> refNames = getRefNamesAllUsers(com.google.gerrit.reviewdb.client.RefNames.refsUsersDrafts(author)); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); for (java.lang.String refName : refNames) { com.google.gerrit.reviewdb.client.Change.Id changeId = Change.Id.parse(refName); com.google.gerrit.server.notedb.DraftCommentNotes draftNotes = draftFactory.create(changeId, author).load(); comments.addAll(draftNotes.getDraftBaseComments().values()); comments.addAll(draftNotes.getDraftPsComments().values()); } return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChangeAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().byChange(notes.getChangeId()).toList(); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getDraftBaseComments(author).values()); comments.addAll(notes.getDraftPsComments(author).values()); return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedByChange(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.PUBLISHED); } notes.load(); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getBaseComments().values()); comments.addAll(notes.getPatchSetComments().values()); return comments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> byPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { if (!(migration.readComments())) { return db.patchComments().byPatchSet(psId).toList(); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(publishedByPatchSet(db, notes, psId)); java.lang.Iterable<java.lang.String> filtered = getDraftRefs(notes.getChangeId()); for (java.lang.String refName : filtered) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefPart(refName); if (account != null) { comments.addAll(draftByPatchSetAuthor(db, psId, account, notes)); } } return comments; }


@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.github.GitHubTopMenu.class); }
@java.lang.Override public com.google.common.collect.Multimap<java.lang.String, java.lang.String> load(java.lang.String username) throws java.lang.Exception { com.google.common.collect.Multimap<java.lang.String, java.lang.String> orgsTeams = com.google.common.collect.HashMultimap.create(); com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin = ghLoginProvider.get(username); if (ghLogin == null) { com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.warn("Cannot login to GitHub on behalf of '{}'", username); return orgsTeams; } com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.debug("Getting list of organisations/teams for user '{}'", username); java.util.Map<java.lang.String, java.util.Set<org.kohsuke.github.GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams(); for (java.util.Map.Entry<java.lang.String, java.util.Set<org.kohsuke.github.GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) { for (org.kohsuke.github.GHTeam team : teamsOrg.getValue()) { orgsTeams.put(teamsOrg.getKey(), team.getName()); } } com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.debug("GitHub user '{}' belongs to: {}", username, orgsTeams); return orgsTeams; }
public boolean login(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope... scopes) throws java.io.IOException { if (isLoggedIn()) { return true; } com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.LOG.debug(("Login " + (this))); if (com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.isOAuthFinal(request)) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.LOG.debug(("Login-FINAL " + (this))); login(oauth.loginPhase2(request, response)); if (isLoggedIn()) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.LOG.debug(("Login-SUCCESS " + (this))); response.sendRedirect(com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.getTargetUrl(request)); return true; } else { response.sendError(HttpStatus.SC_UNAUTHORIZED); return false; } } else { this.loginScopes = getScopes(getScopesKey(request, response), scopes); com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.LOG.debug(("Login-PHASE1 " + (this))); oauth.loginPhase1(request, response, loginScopes); return false; } }
@java.lang.Override public java.lang.String toString() { return ((("AccessToken [access_token=" + (access_token)) + ", token_type=") + (token_type)) + "]"; }

@org.junit.Before public void setUp() throws java.lang.Exception { db = reviewDbProvider.open(); java.lang.String changeId = newChange(git, admin.getIdent()); change = getChange(changeId); ps = getCurrentPatchSet(changeId); assertNotNull(ps); changeId = newChange2(git, admin.getIdent()); change2 = getChange(changeId); assertNotNull(change2); ps2 = getCurrentPatchSet(changeId); assertNotNull(ps2); session = new com.google.gerrit.acceptance.RestSession(server, admin); atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(com.google.inject.util.Providers.of(db), admin.getId()))); }

private static void editTree(com.google.gerrit.server.edit.ChangeEditModifier.TreeOperation op, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit base, org.eclipse.jgit.dircache.DirCacheEditor dce, org.eclipse.jgit.lib.ObjectInserter ins, java.lang.String path, byte[] content) throws com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { switch (op) { case CHANGE_ENTRY : case RESTORE_ENTRY : dce.add(com.google.gerrit.server.edit.ChangeEditModifier.getPathEdit(op, repo, rw, base, path, ins, content)); break; case DELETE_ENTRY : dce.add(new org.eclipse.jgit.dircache.DirCacheEditor.DeletePath(path)); break; default : throw new java.lang.IllegalStateException("unknown tree operation"); } dce.finish(); }




@java.lang.Override public com.google.common.util.concurrent.ListenableFuture<java.lang.Void> apply(java.util.List<?> input) { mpm.end(); return com.google.common.util.concurrent.Futures.immediateFuture(null); }
private java.util.List<com.google.gerrit.reviewdb.client.Change> getAllChanges() throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb> schemaFactory = sysInjector.getInstance(com.google.inject.Key.get(new com.google.inject.TypeLiteral<com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb>>() {})); com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { return db.changes().all().toList(); } finally { db.close(); } }









private java.lang.String urlPublishEdit() { return ((("/changes/" + (change.getChangeId())) + "/edits/") + 0) + "/publish/"; }
@org.junit.Test public void updateExistingFileRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.gerrit.server.change.PutContent.Input in = new com.google.gerrit.server.change.PutContent.Input(); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertEquals(204, session.putRaw(urlPut(change), in.content).getStatusCode()); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertTrue(edit.isPresent()); editUtil.publish(edit.get()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); }
private java.lang.String urlDelete(com.google.gerrit.reviewdb.client.Change c) { return (((("/changes/" + (c.getChangeId())) + "/edits/") + 0) + "/files/") + (com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME); }
@org.junit.Test public void restoreDeletedFileRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change2, ps2)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change2); assertTrue(edit.isPresent()); com.google.gerrit.server.change.PutContent.Input in = new com.google.gerrit.server.change.PutContent.Input(); in.restore = true; assertEquals(204, session.put(urlPut(change2), in).getStatusCode()); edit = editUtil.byChange(change2); assertTrue(edit.isPresent()); editUtil.publish(edit.get()); edit = editUtil.byChange(change2); assertFalse(edit.isPresent()); }

@org.junit.Test public void ammendExistingFileRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.gerrit.server.change.PutContent.Input in = new com.google.gerrit.server.change.PutContent.Input(); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertEquals(204, session.putRaw(urlPut(change), in.content).getStatusCode()); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertTrue(edit.isPresent()); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(((com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW) + 42)); assertEquals(204, session.putRaw(urlPut(change), in.content).getStatusCode()); edit = editUtil.byChange(change); editUtil.publish(edit.get()); edit = editUtil.byChange(change2); assertFalse(edit.isPresent()); }
@org.junit.Test public void deleteExistingFileRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertTrue(edit.isPresent()); assertEquals(204, session.delete(urlDelete(change)).getStatusCode()); edit = editUtil.byChange(change); editUtil.publish(edit.get()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); }
private java.lang.String urlPut(com.google.gerrit.reviewdb.client.Change c) { return (urlDelete(c)) + "/content"; }


private static com.google.gerrit.extensions.common.GitPerson toGitPerson(com.google.gerrit.reviewdb.client.UserIdentity committer) { com.google.gerrit.extensions.common.GitPerson p = new com.google.gerrit.extensions.common.GitPerson(); p.name = committer.getName(); p.email = committer.getEmail(); p.date = committer.getDate(); p.tz = committer.getTimeZone(); return p; }
@java.lang.Override protected void configure() { factory(ReviewerResource.Factory.class); factory(AccountInfo.Loader.Factory.class); factory(EmailReviewComments.Factory.class); factory(ChangeInserter.Factory.class); factory(PatchSetInserter.Factory.class); }



@java.lang.Override protected void configureServlets() { for (java.util.Map.Entry<java.lang.String, java.lang.Class<javax.servlet.http.HttpServlet>> e : serve.entrySet()) { bind(e.getValue()).in(Scopes.SINGLETON); serve(e.getKey()).with(e.getValue()); } for (java.util.Map.Entry<com.google.inject.TypeLiteral<?>, java.lang.Class<?>> e : listeners.entries()) { @java.lang.SuppressWarnings("unchecked") com.google.inject.TypeLiteral<java.lang.Object> type = ((com.google.inject.TypeLiteral<java.lang.Object>) (e.getKey())); @java.lang.SuppressWarnings("unchecked") java.lang.Class<java.lang.Object> impl = ((java.lang.Class<java.lang.Object>) (e.getValue())); java.lang.annotation.Annotation n = calculateBindAnnotation(impl); bind(type).annotatedWith(n).to(impl); } }
@java.lang.Override public void start(org.apache.sshd.server.Environment env) throws java.io.IOException { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws java.lang.Exception { parseCommandLine(impl); impl.display(out); } }); }
@java.lang.Override public void start(org.apache.sshd.server.Environment env) throws java.io.IOException { startThread(new com.google.gerrit.sshd.commands.CommandRunnable() { @java.lang.Override public void run() throws java.lang.Exception { stdout = toPrintWriter(out); try { parseCommandLine(); verifyCommandLine(); runGC(); } finally { stdout.flush(); } } }); }

private void setAccount() throws com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException { user = genericUserFactory.create(id); rsrc = new com.google.gerrit.server.account.AccountResource(user); try { for (java.lang.String email : addEmails) { addEmail(email); } for (java.lang.String email : deleteEmails) { deleteEmail(email); } if ((fullName) != null) { com.google.gerrit.server.account.PutName.Input in = new com.google.gerrit.server.account.PutName.Input(); in.name = fullName; putName.apply(rsrc, in); } if (((httpPassword) != null) || (clearHttpPassword)) { com.google.gerrit.server.account.PutHttpPassword.Input in = new com.google.gerrit.server.account.PutHttpPassword.Input(); in.httpPassword = httpPassword; putHttpPassword.apply(rsrc, in); } if (active) { putActive.apply(rsrc, null); } else if (inactive) { try { deleteActive.apply(rsrc, null); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } addSshKeys = readSshKey(addSshKeys); if (!(addSshKeys.isEmpty())) { addSshKeys(addSshKeys); } deleteSshKeys = readSshKey(deleteSshKeys); if (!(deleteSshKeys.isEmpty())) { deleteSshKeys(deleteSshKeys); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }

public org.eclipse.jgit.revwalk.RevCommit commit() throws java.io.IOException { com.google.gerrit.server.notedb.BatchMetaDataUpdate batch = openUpdate(); try { org.eclipse.jgit.lib.CommitBuilder builder = new org.eclipse.jgit.lib.CommitBuilder(); if (migration.write()) { org.eclipse.jgit.lib.ObjectId treeId = storeCommentsInNotes(); if (treeId != null) { builder.setTreeId(treeId); } } batch.write(builder); if ((draftUpdate) != null) { draftUpdate.commit(); } org.eclipse.jgit.revwalk.RevCommit c = batch.commit(); return c; } catch (com.google.gwtorm.server.OrmException e) { throw new java.io.IOException(e); } finally { batch.close(); } }
public static com.google.gerrit.server.notedb.NotesMigration allEnabled() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setBoolean("notedb", null, "write", true); cfg.setBoolean("notedb", "patchSetApprovals", "read", true); cfg.setBoolean("notedb", "changeMessages", "read", true); cfg.setBoolean("notedb", "comments", "read", true); return new com.google.gerrit.server.notedb.NotesMigration(cfg); }

@java.lang.Override protected com.google.gerrit.server.git.CodeReviewCommit _run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); if (mergeTip == null) { mergeTip = toMerge.remove(0); } mergeTip = args.mergeUtil.getFirstFastForward(mergeTip, args.rw, toMerge); while (!(toMerge.isEmpty())) { mergeTip = args.mergeUtil.mergeOneCommit(args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip, toMerge.remove(0)); } final com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip, args.alreadyAccepted); setRefLogIdent(submitApproval); return mergeTip; }
@java.lang.Override protected com.google.gerrit.server.git.CodeReviewCommit _run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); if (mergeTip == null) { mergeTip = toMerge.remove(0); } while (!(toMerge.isEmpty())) { mergeTip = args.mergeUtil.mergeOneCommit(args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip, toMerge.remove(0)); } final com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip, args.alreadyAccepted); setRefLogIdent(submitApproval); return mergeTip; }
private static org.eclipse.jgit.revwalk.RevObject aFor(final com.google.gerrit.server.patch.PatchListKey key, final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.revwalk.RevCommit b) throws java.io.IOException { if ((key.getOldId()) != null) { return rw.parseAny(key.getOldId()); } switch (b.getParentCount()) { case 0 : return rw.parseAny(com.google.gerrit.server.patch.PatchListLoader.emptyTree(repo)); case 1 : { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(0); rw.parseBody(r); return r; } case 2 : return com.google.gerrit.server.patch.PatchListLoader.automerge(repo, rw, b); default : return null; } }
private org.eclipse.jgit.revwalk.RevTree aFor(org.eclipse.jgit.revwalk.RevCommit b, org.eclipse.jgit.revwalk.RevWalk walk) throws java.io.IOException { switch (b.getParentCount()) { case 0 : return walk.parseTree(emptyTree()); case 1 : org.eclipse.jgit.revwalk.RevCommit a = b.getParent(0); walk.parseBody(a); return walk.parseTree(a.getTree()); case 2 : return com.google.gerrit.server.patch.PatchListLoader.automerge(repo, walk, b); default : return null; } }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.Multimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.ArrayListMultimap.create(); org.eclipse.jgit.lib.Repository repo = null; com.google.gerrit.reviewdb.server.ReviewDb db = null; try { repo = repoManager.openRepository(project); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.ALL); db = schemaFactory.open(); for (com.google.gerrit.reviewdb.client.Change c : db.changes().byProject(project)) { org.eclipse.jgit.lib.Ref r = refs.get(c.currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, c)); } } new com.google.gerrit.server.index.ChangeBatchIndexer.ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.ChangeBatchIndexer.log.error(rnfe.getMessage()); } finally { if (db != null) { db.close(); } if (repo != null) { repo.close(); } } return null; }
private java.util.concurrent.Callable<java.lang.Void> reindexProject(final com.google.gerrit.server.index.ChangeIndexer indexer, final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.server.git.MultiProgressMonitor.Task done, final com.google.gerrit.server.git.MultiProgressMonitor.Task failed, final java.io.PrintWriter verboseWriter) { return new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.Multimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.ArrayListMultimap.create(); org.eclipse.jgit.lib.Repository repo = null; com.google.gerrit.reviewdb.server.ReviewDb db = null; try { repo = repoManager.openRepository(project); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.ALL); db = schemaFactory.open(); for (com.google.gerrit.reviewdb.client.Change c : db.changes().byProject(project)) { org.eclipse.jgit.lib.Ref r = refs.get(c.currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, c)); } } new com.google.gerrit.server.index.ChangeBatchIndexer.ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.ChangeBatchIndexer.log.error(rnfe.getMessage()); } finally { if (db != null) { db.close(); } if (repo != null) { repo.close(); } } return null; } }; }
public static org.eclipse.jgit.revwalk.RevTree automerge(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit b) throws java.io.IOException { return com.google.gerrit.server.patch.PatchListLoader.automerge(repo, rw, b, true); }
private void scanGuiceModules(java.util.Set<java.lang.Class<?>> classes) throws java.io.IOException { try { java.lang.Class<?> sysModuleBaseClass = java.lang.Module.class; java.lang.Class<?> httpModuleBaseClass = java.lang.Class.forName("com.google.inject.servlet.ServletModule"); java.lang.Class<?> sshModuleBaseClass = java.lang.Class.forName("com.google.gerrit.sshd.CommandModule"); for (java.lang.Class<?> clazz : classes) { if (sshModuleBaseClass.isAssignableFrom(clazz)) { sshModuleClass = getUniqueGuiceModule(sshModuleBaseClass, sshModuleClass, clazz); } else if (httpModuleBaseClass.isAssignableFrom(clazz)) { httpModuleClass = getUniqueGuiceModule(httpModuleBaseClass, httpModuleClass, clazz); } else if (sysModuleBaseClass.isAssignableFrom(clazz)) { sysModuleClass = getUniqueGuiceModule(sysModuleBaseClass, sysModuleClass, clazz); } } } catch (java.lang.ClassNotFoundException e) { throw new java.io.IOException("Cannot find base Gerrit classes for Guice Plugin Modules", e); } }
private void setMerged(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.ChangeMessage msg) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeUpdate update = null; try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change().currentPatchSetId(); c = setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged); com.google.gerrit.server.project.ChangeControl control = commit.getControl(); update = updateFactory.create(control, c.getLastUpdatedOn()); if (msg != null) { cmUtil.addChangeMessage(db, update, msg); } db.commit(); sendMergedEmail(c, submitter); indexer.index(db, c); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db); } catch (com.google.gwtorm.server.OrmException ex) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } } finally { db.rollback(); } HEAD(37.0); com.google.gerrit.server.git.a58 Set; version((2.1 - (SNAPSHOT))); indexer.index(db, c); update.commit(); BRANCH(5.38E89); com.google.gerrit.server.git.full names; com.google.gerrit.server.git.options on; groups(com.google.gerrit.server.git.API); }
private void checkComments(java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.Comment>> in) throws com.google.gerrit.extensions.restapi.BadRequestException { java.util.Iterator<java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.Comment>>> mapItr = in.entrySet().iterator(); while (mapItr.hasNext()) { java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.Comment>> ent = mapItr.next(); java.lang.String path = ent.getKey(); java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.Comment> list = ent.getValue(); if (list == null) { mapItr.remove(); continue; } java.util.Iterator<com.google.gerrit.extensions.api.changes.ReviewInput.Comment> listItr = list.iterator(); while (listItr.hasNext()) { com.google.gerrit.extensions.api.changes.ReviewInput.Comment c = listItr.next(); if ((c.line) < 0) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("negative line number %d not allowed on %s", c.line, path)); } c.message = com.google.common.base.Strings.emptyToNull(c.message).trim(); if (c.message.isEmpty()) { listItr.remove(); } } if (list.isEmpty()) { mapItr.remove(); } } }

@java.lang.Override public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> rewrite(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in, int start) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.server.index.ChangeIndex index = indexes.getSearchIndex(); in = basicRewrites.rewrite(in); int limit = com.google.common.base.Objects.firstNonNull(com.google.gerrit.server.query.change.ChangeQueryBuilder.getLimit(in), com.google.gerrit.server.index.IndexRewriteImpl.MAX_LIMIT); limit += start; limit = java.lang.Math.max(limit, 1); limit = java.lang.Math.min(limit, com.google.gerrit.server.index.IndexRewriteImpl.MAX_LIMIT); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> out = rewriteImpl(in, index, limit); if ((in == out) || (out instanceof com.google.gerrit.server.index.IndexPredicate)) { return new com.google.gerrit.server.index.IndexedChangeQuery(index, out, limit); } else if (out == null) { return in; } else { return out; } }
private com.google.gerrit.server.index.IndexedChangeQuery query(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) throws com.google.gerrit.server.query.QueryParseException { return query(p, IndexRewriteImpl.MAX_LIMIT); }



com.google.gerrit.server.git.TagMatcher matcher(com.google.gerrit.server.git.TagCache cache, org.eclipse.jgit.lib.Repository db, java.util.Collection<org.eclipse.jgit.lib.Ref> include) { com.google.gerrit.server.git.TagSet tags = this.tags; if (tags == null) { tags = build(cache, db); } com.google.gerrit.server.git.TagMatcher m = new com.google.gerrit.server.git.TagMatcher(this, cache, db, include, tags, false); tags.prepare(m); if ((!(m.newRefs.isEmpty())) || (!(m.lostRefs.isEmpty()))) { tags = rebuild(cache, db, tags, m); m = new com.google.gerrit.server.git.TagMatcher(this, cache, db, include, tags, true); tags.prepare(m); } return m; }
private static java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> fillActions(com.google.gerrit.server.edit.ChangeEditData data) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> actions = com.google.common.collect.Maps.newTreeMap(); com.google.gerrit.extensions.webui.UiAction.Description descr = new com.google.gerrit.extensions.webui.UiAction.Description(); com.google.gerrit.extensions.webui.PrivateInternals_UiActionDescription.setId(descr, "/"); com.google.gerrit.extensions.webui.PrivateInternals_UiActionDescription.setMethod(descr, "DELETE"); descr.setTitle("Delete edit"); actions.put(descr.getId(), new com.google.gerrit.extensions.common.ActionInfo(descr)); return actions; }



@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeEditResource rsrc, com.google.gerrit.server.change.PublishChangeEdit.Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { editUtil.publish(rsrc.getChangeEdit()); return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { return format(new com.google.gerrit.server.query.change.ChangeData(rsrc.getControl())); }
@java.lang.Override public com.google.gerrit.server.change.ChangeJson.ChangeInfo apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.Rebase.Input input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = rsrc.getControl(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(control.canRebase())) { throw new com.google.gerrit.extensions.restapi.AuthException("rebase not permitted"); } else if (!(change.getStatus().isOpen())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (change.getStatus().name().toLowerCase()))); } try { rebaseChange.get().rebase(rsrc.getPatchSet().getId(), rsrc.getUser()); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(change.getId().toString()); } json.addOption(ListChangesOption.CURRENT_REVISION).addOption(ListChangesOption.CURRENT_COMMIT); return json.format(change.getId()); }
private java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> query() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } com.google.gerrit.server.IdentifiedUser self = null; try { if (user.get().isIdentifiedUser()) { self = ((com.google.gerrit.server.IdentifiedUser) (user.get())); self.asyncStarredChanges(); } return query0(); } finally { if (self != null) { self.abortStarredChanges(); } } }
private java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> query0() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { int cnt = queries.size(); java.util.BitSet more = new java.util.BitSet(cnt); java.util.List<java.util.List<com.google.gerrit.server.query.change.ChangeData>> data = imp.queryChanges(queries); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = data.get(n); if (((imp.getLimit()) > 0) && ((changes.size()) > (imp.getLimit()))) { if (reverse) { changes = changes.subList(1, changes.size()); } else { changes = changes.subList(0, imp.getLimit()); } data.set(n, changes); more.set(n, true); } } java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> res = json.addOptions(options).formatList2(data); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> info = res.get(n); if ((more.get(n)) && (!(info.isEmpty()))) { if (reverse) { info.get(0)._moreChanges = true; } else { info.get(((info.size()) - 1))._moreChanges = true; } } } return res; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> out; try { out = query(); } catch (com.google.gerrit.server.query.QueryParseException e) { java.util.regex.Pattern p = java.util.regex.Pattern.compile("^Error in operator (.*:self)$"); java.util.regex.Matcher m = p.matcher(e.getMessage()); if (m.matches()) { java.lang.String op = m.group(1); throw new com.google.gerrit.extensions.restapi.AuthException(("Must be signed-in to use " + op)); } throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } return (out.size()) == 1 ? out.get(0) : out; }
private void initRevisionsAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { int currentPatchSet; if (((info.current_revision()) != null) && (info.revisions().containsKey(info.current_revision()))) { currentPatchSet = info.revision(info.current_revision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } int currentlyViewedPatchSet = info.revision(revision)._number(); patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets); }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(rsrc.getControl()); cd.limitToPatchSets(com.google.common.collect.ImmutableList.of(rsrc.getPatchSet().getId())); return format(cd); }
private java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> toChangeInfo(java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeJson.ChangeInfo> out, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { com.google.gerrit.server.change.ChangeJson.ChangeInfo i = out.get(cd.getId()); if (i == null) { i = toChangeInfo(cd); out.put(cd.getId(), i); } info.add(i); } return info; }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.query.change.ChangeData> tmp = com.google.common.collect.ImmutableList.of(cd); return formatList2(com.google.common.collect.ImmutableList.of(tmp)).get(0).get(0); }
public java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> formatList2(java.util.List<java.util.List<com.google.gerrit.server.query.change.ChangeData>> in) throws com.google.gwtorm.server.OrmException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> all = com.google.common.collect.Iterables.concat(in); com.google.gerrit.server.query.change.ChangeData.ensureChangeLoaded(db, all); if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { com.google.gerrit.server.query.change.ChangeData.ensureAllPatchSetsLoaded(db, all); } else { com.google.gerrit.server.query.change.ChangeData.ensureCurrentPatchSetLoaded(db, all); } if (has(com.google.gerrit.server.change.REVIEWED)) { ensureReviewedLoaded(all); } com.google.gerrit.server.query.change.ChangeData.ensureCurrentApprovalsLoaded(db, all); java.util.List<java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>> res = com.google.common.collect.Lists.newArrayListWithCapacity(in.size()); java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeJson.ChangeInfo> out = com.google.common.collect.Maps.newHashMap(); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> changes : in) { res.add(toChangeInfo(out, changes)); } accountLoader.fill(); return res; }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gwtorm.server.OrmException { return format(new com.google.gerrit.server.query.change.ChangeData(id)); }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { return format(new com.google.gerrit.server.query.change.ChangeData(change)); }
public static com.google.gerrit.client.rpc.RestApi revision(com.google.gerrit.reviewdb.client.PatchSet.Id id) { int cn = id.getParentKey().get(); java.lang.String revision = com.google.gerrit.client.changes.RevisionInfoCache.get(id); if (revision != null) { return ChangeApi.revision(cn, revision); } return ChangeApi.change(cn).view("revisions").id(id.get()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.change.ChangeJson.ChangeInfo> apply(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return delegate.apply(rsrc); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.account.AccountResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { return new com.google.gerrit.extensions.restapi.RestReadView<com.google.gerrit.server.account.AccountResource>() { @java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource self) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.QueryChanges query = changes.list(); query.addQuery(("starredby:" + (self.getUser().getAccountId().get()))); return query.apply(TopLevelResource.INSTANCE); } }; }
private void revision(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, int index, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r) { com.google.gerrit.client.changes.ChangeInfo.CommitInfo c = r.commit(); sb.openTr(); if (revision.equals(r.name())) { sb.setStyleName(style.current()); } sb.openTd().setStyleName(style.legacy_id()); if (r.draft()) { sb.append(Resources.C.draft()).append(' '); } if (r.has_draft_comments()) { sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' '); } sb.append(r._number()); sb.closeTd(); sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", ("#" + (url(r)))).setAttribute("onclick", ((((com.google.gerrit.client.change.PatchSetsBox.OPEN) + "(event,") + index) + ")")).append(r.name().substring(0, 10)).closeAnchor().closeTd(); sb.openTd().append(com.google.gerrit.client.FormatUtil.shortFormatDayTime(c.committer().date())).closeTd(); java.lang.String an = ((c.author()) != null) ? c.author().name() : null; java.lang.String cn = ((c.committer()) != null) ? c.committer().name() : null; sb.openTd(); sb.append(an); if (((!("".equals(an))) && (!("".equals(cn)))) && (!(an.equals(cn)))) { sb.append(" / ").append(cn); } sb.closeTd(); sb.closeTr(); }
com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.change.ChangeJson.ChangeInfo> apply(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return cache(json.format(rsrc)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.change.ChangeJson.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { return cache(json.format(rsrc)); }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.change.ChangeJson.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { return delegate.apply(rsrc); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource self) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.QueryChanges query = changes.list(); query.addQuery(("starredby:" + (self.getUser().getAccountId().get()))); return query.apply(TopLevelResource.INSTANCE); }

@java.lang.Override protected void onLoad() { super.onLoad(); loadChangeInfo(true, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { info.init(); loadConfigInfo(info, base); } }); }

@java.lang.Override public int compare(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b) { return (a._number()) - (b._number()); }
public static void sortRevisionInfoByNumber(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list) { java.util.Collections.sort(com.google.gerrit.client.rpc.Natives.asList(list), new java.util.Comparator<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b) { return (a._number()) - (b._number()); } }); }
public java.lang.Iterable<com.google.gerrit.server.WebLinks.Link> getProjectLinks(java.lang.String project) { java.util.List<com.google.gerrit.server.WebLinks.Link> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.ProjectWebLink webLink : projectLinks) { links.add(new com.google.gerrit.server.WebLinks.Link(webLink.getLinkName(), webLink.getProjectUrl(project))); } return links; }
public java.lang.Iterable<com.google.gerrit.server.WebLinks.Link> getPatchSetLinks(java.lang.String project, java.lang.String commit) { java.util.List<com.google.gerrit.server.WebLinks.Link> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks) { links.add(new com.google.gerrit.server.WebLinks.Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit))); } return links; }
public java.lang.String getLinkName() { return ("(" + (type.getLinkName())) + ")"; }
private void addWebLink(java.lang.String href, java.lang.String name) { com.google.gwt.dom.client.AnchorElement a = com.google.gwt.user.client.DOM.createAnchor().cast(); a.setHref(href); a.setInnerText(name); webLinkCell.appendChild(a); }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.reviewdb.client.Project p) { com.google.gerrit.extensions.common.ProjectInfo info = new com.google.gerrit.extensions.common.ProjectInfo(); info.name = p.getName(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = p.getParent(allProjects); info.parent = (parentName != null) ? parentName.get() : null; info.description = com.google.common.base.Strings.emptyToNull(p.getDescription()); info.state = p.getState(); info.id = com.google.gerrit.extensions.restapi.Url.encode(info.name); info.webLinks = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.server.WebLinks.Link link : webLinks.get().getProjectLinks(p.getName())) { if ((!(com.google.common.base.Strings.isNullOrEmpty(link.name))) && (!(com.google.common.base.Strings.isNullOrEmpty(link.url)))) { info.webLinks.add(new com.google.gerrit.extensions.common.WebLinkInfo(link.name, link.url)); } } return info; }
public static void sortRevisionInfoByNumber(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list) { final int parent_number = com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.findEditParent(list); java.util.Collections.sort(com.google.gerrit.client.rpc.Natives.asList(list), new java.util.Comparator<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo>() { @java.lang.Override public int compare(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b) { int a_number = a._number(); int b_number = b._number(); if (a_number == 0) { if (b_number == (parent_number + 1)) { a_number = parent_number; } else { a_number = parent_number + 1; } } if (b_number == 0) { if (a_number == (parent_number + 1)) { b_number = parent_number; } else { b_number = parent_number + 1; } } return a_number - b_number; } }); }


public static com.google.gerrit.server.notedb.ChangeUpdate newUpdate(com.google.inject.Injector injector, com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.reviewdb.client.Change c, final com.google.gerrit.server.config.AllUsersNameProvider allUsers, final com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException { return injector.createChildInjector(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override public void configure() { factory(ChangeUpdate.Factory.class); factory(ChangeDraftUpdate.Factory.class); bind(com.google.gerrit.server.IdentifiedUser.class).toInstance(user); bind(com.google.gerrit.server.config.AllUsersName.class).toProvider(allUsers); } }).getInstance(ChangeUpdate.Factory.class).create(com.google.gerrit.testutil.TestChanges.stubChangeControl(repoManager, c, allUsers, user), com.google.gerrit.server.util.TimeUtil.nowTs(), com.google.common.collect.Ordering.<java.lang.String>natural()); }
@java.lang.Override public void onNewProjectCreated(com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event) { for (org.eclipse.jgit.transport.URIish uri : getURIs(new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()), false)) { createProject(uri, event.getHeadName()); } }
private void createRepository() { if (pool.isCreateMissingRepos()) { try { final org.eclipse.jgit.lib.Ref head = git.getRef(Constants.HEAD); com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event = new com.google.gerrit.extensions.events.NewProjectCreatedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return projectName.get(); } @java.lang.Override public java.lang.String getHeadName() { return head != null ? head.getName() : null; } }; replicationQueue.onNewProjectCreated(event); com.googlesource.gerrit.plugins.replication.PushOne.repLog.warn(("Missing repository created; retry replication to " + (uri))); pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING); } catch (java.io.IOException ioe) { com.googlesource.gerrit.plugins.replication.PushOne.stateLog.error((("Cannot replicate to " + (uri)) + "; failed to create missing repository"), ioe, getStatesAsArray()); } } else { com.googlesource.gerrit.plugins.replication.PushOne.stateLog.error((("Cannot replicate to " + (uri)) + "; repository not found"), getStatesAsArray()); } }
public void onSuccess(com.google.gerrit.client.extensions.TopMenuList result) { java.util.List<com.google.gerrit.client.extensions.TopMenu> topMenuExtensions = com.google.gerrit.client.rpc.Natives.asList(result); for (com.google.gerrit.client.extensions.TopMenu menu : topMenuExtensions) { com.google.gerrit.client.ui.LinkMenuBar existingBar = com.google.gerrit.client.Gerrit.menuBars.get(menu.getName()); com.google.gerrit.client.ui.LinkMenuBar bar = (existingBar != null) ? existingBar : new com.google.gerrit.client.ui.LinkMenuBar(); for (com.google.gerrit.client.extensions.TopMenuItem item : com.google.gerrit.client.rpc.Natives.asList(menu.getItems())) { com.google.gerrit.client.Gerrit.addExtensionLink(bar, item); } if (existingBar == null) { com.google.gerrit.client.Gerrit.menuBars.put(menu.getName(), bar); com.google.gerrit.client.Gerrit.menuLeft.add(bar, menu.getName()); } } }







public void run() { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); commentManager.saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? base.getId() : null; java.lang.String rev = revision.getId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, b, rev, openReplyBox)); } }); }
private java.lang.Runnable upToChange(final boolean openReplyBox) { return new java.lang.Runnable() { public void run() { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); commentManager.saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? base.getId() : null; java.lang.String rev = revision.getId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, b, rev, openReplyBox)); } }); } }; }
@java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? base.getId() : null; java.lang.String rev = revision.getId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, b, rev, openReplyBox)); }
@java.lang.Override protected void onLoad() { if ((fetch) == null) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(change.legacy_id().get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of((revision.equals(change.current_revision()) ? com.google.gerrit.extensions.common.ListChangesOption.CURRENT_REVISION : com.google.gerrit.extensions.common.ListChangesOption.ALL_REVISIONS), ListChangesOption.DOWNLOAD_COMMANDS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { fetch = result.revision(revision).fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (edit.isPresent()) { if (list) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = null; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(rsrc, com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); basePatchSet = baseResource.getPatchSet(); } try { return com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } } else { return com.google.gerrit.extensions.restapi.Response.ok(com.google.gerrit.server.edit.ChangeEditInfoJson.toEditInfo(edit.get())); } } return com.google.gerrit.extensions.restapi.Response.none(); }
public static com.google.gerrit.extensions.common.EditInfo toEditInfo(com.google.gerrit.server.edit.ChangeEdit edit) throws java.io.IOException { com.google.gerrit.extensions.common.EditInfo out = new com.google.gerrit.extensions.common.EditInfo(); out.commit = com.google.gerrit.server.edit.ChangeEditInfoJson.fillCommit(edit.getEditCommit()); out.actions = com.google.gerrit.server.edit.ChangeEditInfoJson.fillActions(edit); return out; }
private void columnRemove(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().removeButton()); if ((hasUser) && (isEditeable(info))) { if (!(Patch.COMMIT_MSG.equals(info.path()))) { sb.openElement("button").setAttribute("title", Resources.C.removeFileInline()).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.DELETE) + "(event,") + (info._row())) + ")")).append(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.redNot())).closeElement("button"); } } sb.closeTd(); }



private void columnEdit(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().editButton()); if (hasUser) { if (!(Patch.COMMIT_MSG.equals(info.path()))) { sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.EDIT) + "(event,") + (info._row())) + ")")).append(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button"); } } sb.closeTd(); }


@java.lang.Override @com.google.gwt.uibinder.client.UiHandler("save") void onSave(com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeFileApi.putContent(id, file, message.getText().trim(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id.getParentKey())); hide(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }

void setUpPatchSetNav(com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list, com.google.gerrit.client.diff.DiffInfo.FileMeta meta) { com.google.gerrit.client.ui.InlineHyperlink baseLink = null; com.google.gerrit.client.ui.InlineHyperlink selectedLink = null; if (sideA) { baseLink = createLink(PatchUtil.C.patchBase(), null); linkPanel.add(baseLink); } for (int i = 0; i < (list.length()); i++) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r = list.get(i); com.google.gerrit.client.ui.InlineHyperlink link = createLink(java.lang.String.valueOf(r._number()), new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, r._number())); linkPanel.add(link); if (((revision) != null) && ((r._number()) == (revision.get()))) { selectedLink = link; } } if (selectedLink != null) { selectedLink.setStyleName(style.selected()); } else if (sideA) { baseLink.setStyleName(style.selected()); } if ((meta != null) && (!(Patch.COMMIT_MSG.equals(path)))) { linkPanel.add(createDownloadLink()); } }
private static java.lang.String toPatch(java.lang.String type, com.google.gerrit.reviewdb.client.PatchSet.Id diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(); p.append("/c/").append(c).append("/"); if (diffBase != null) { p.append(diffBase.get()).append(".."); } p.append(revision.get()).append("/").append(com.google.gwtorm.client.KeyUtil.encode(fileName)); if ((type != null) && (!(type.isEmpty()))) { p.append(",").append(type); } return p.toString(); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo> m) { files.set((base != null ? new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, base._number()) : null), new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), style, editMessage, reply); files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode); }
private org.eclipse.jgit.lib.ObjectId toObjectId(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { if (!(changeId.equals(psId.getParentKey()))) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } final com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().get(psId); if (((ps == null) || ((ps.getRevision()) == null)) || ((ps.getRevision().get()) == null)) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try { return org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.patch.PatchScriptFactory.log.error((("Patch set " + psId) + " has invalid revision")); throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
@java.lang.Override public com.google.gerrit.server.change.RevisionResource parse(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (id.equals("current")) { com.google.gerrit.reviewdb.client.PatchSet.Id p = change.getChange().currentPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet ps = (p != null) ? dbProvider.get().patchSets().get(p) : null; if ((ps != null) && (visible(change, ps))) { return new com.google.gerrit.server.change.RevisionResource(change, ps).doNotCache(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } java.util.List<com.google.gerrit.reviewdb.client.PatchSet> match = com.google.common.collect.Lists.newArrayListWithExpectedSize(2); for (com.google.gerrit.reviewdb.client.PatchSet ps : find(change, id.get())) { com.google.gerrit.reviewdb.client.Change.Id changeId = ps.getId().getParentKey(); if ((changeId.equals(change.getChange().getId())) && (visible(change, ps))) { match.add(ps); } } if ((match.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.change.RevisionResource(change, match.get(0)); }






@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = getRevision(); if (rev == null) { loadDefaults(); return; } org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(reader); try (com.google.gerrit.server.notedb.ChangeNotesParser parser = new com.google.gerrit.server.notedb.ChangeNotesParser(change, rev, walk, repoManager)) { parser.parseAll(); if ((parser.status) != null) { change.setStatus(parser.status); } approvals = parser.buildApprovals(); changeMessages = parser.buildMessages(); commentsForBase = com.google.common.collect.ImmutableListMultimap.copyOf(parser.commentsForBase); commentsForPS = com.google.common.collect.ImmutableListMultimap.copyOf(parser.commentsForPs); noteMap = parser.commentNoteMap; ImmutableSetMultimap.Builder<com.google.gerrit.server.notedb.ReviewerState, com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.ImmutableSetMultimap.builder(); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.notedb.ReviewerState> e : parser.reviewers.entrySet()) { reviewers.put(e.getValue(), e.getKey()); } this.reviewers = reviewers.build(); this.allPastReviewers = com.google.common.collect.ImmutableList.copyOf(parser.allPastReviewers); submitRecords = com.google.common.collect.ImmutableList.copyOf(parser.submitRecords); } catch (java.text.ParseException e1) { throw new java.io.IOException(e1); } finally { walk.release(); } }
@org.junit.Test public void manyPastEnd() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 5, commits.get(1)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(1), commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertEquals(commits.get(6), p.getPreviousStart()); assertNull(p.getNextStart()); }
private static com.google.gitiles.Paginator newPaginator(org.eclipse.jgit.lib.Repository repo, com.google.gitiles.GitilesView view) throws java.io.IOException { if (view == null) { return null; } org.eclipse.jgit.revwalk.RevWalk walk = null; try { walk = com.google.gitiles.LogServlet.newWalk(repo, view); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { return null; } com.google.common.base.Optional<org.eclipse.jgit.lib.ObjectId> start; try { start = com.google.gitiles.LogServlet.getStart(view.getParameters(), walk.getObjectReader()); } catch (java.io.IOException e) { walk.release(); throw e; } if (start == null) { return null; } return new com.google.gitiles.Paginator(walk, com.google.gitiles.LogServlet.getLimit(view), start.orNull()); }
@org.junit.Test public void onePastEnd() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, commits.get(1)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(1), commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertEquals(commits.get(4), p.getPreviousStart()); assertNull(p.getNextStart()); }
@org.junit.Test public void oneResult() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(1); walk.markStart(commits.get(0)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 10, null); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertNull(p.getNextStart()); }
@org.junit.Test public void lessThanOnePageIn() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, commits.get(8)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(8), commits.get(7), commits.get(6)), com.google.common.collect.ImmutableList.copyOf(p)); assertEquals(commits.get(9), p.getPreviousStart()); assertEquals(commits.get(5), p.getNextStart()); }
@org.junit.Test public void atLeastOnePageIn() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, commits.get(7)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(7), commits.get(6), commits.get(5)), com.google.common.collect.ImmutableList.copyOf(p)); assertEquals(commits.get(9), p.getPreviousStart()); assertEquals(commits.get(4), p.getNextStart()); }
@org.junit.Test public void noStartCommit() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, null); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(9), commits.get(8), commits.get(7)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertEquals(commits.get(6), p.getNextStart()); }
@org.junit.Test public void end() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, commits.get(2)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(2), commits.get(1), commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertEquals(commits.get(5), p.getPreviousStart()); assertNull(p.getNextStart()); }
public org.eclipse.jgit.revwalk.RevCommit next() throws java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (done) { return null; } org.eclipse.jgit.revwalk.RevCommit commit; if ((first) != null) { commit = first; first = null; } else { commit = walk.next(); } if ((++(n)) == (limit)) { nextStart = walk.next(); done = true; } else if (commit == null) { done = true; } return commit; }
@org.junit.Test public void start() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(10); walk.markStart(commits.get(9)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, commits.get(9)); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(9), commits.get(8), commits.get(7)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertEquals(commits.get(6), p.getNextStart()); }
@org.junit.Test public void exactlyOnePage() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(3); walk.markStart(commits.get(2)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, null); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(2), commits.get(1), commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertNull(p.getNextStart()); }
@org.junit.Test public void lessThanOnePage() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(3); walk.markStart(commits.get(2)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 10, null); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(2), commits.get(1), commits.get(0)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertNull(p.getNextStart()); }
@org.junit.Test public void moreThanOnePage() throws java.lang.Exception { java.util.List<org.eclipse.jgit.revwalk.RevCommit> commits = linearCommits(5); walk.markStart(commits.get(4)); com.google.gitiles.Paginator p = new com.google.gitiles.Paginator(walk, 3, null); assertEquals(com.google.common.collect.ImmutableList.of(commits.get(4), commits.get(3), commits.get(2)), com.google.common.collect.ImmutableList.copyOf(p)); assertNull(p.getPreviousStart()); assertEquals(commits.get(1), p.getNextStart()); }

public com.google.gerrit.extensions.common.EditInfo toEditInfo(com.google.gerrit.server.edit.ChangeEdit edit, boolean downloadCommands) throws java.io.IOException { com.google.gerrit.extensions.common.EditInfo out = new com.google.gerrit.extensions.common.EditInfo(); out.commit = com.google.gerrit.server.edit.ChangeEditJson.fillCommit(edit.getEditCommit()); out.actions = com.google.gerrit.server.edit.ChangeEditJson.fillActions(edit); if (downloadCommands) { out.fetch = fillFetchMap(edit); } return out; }
private void initRevisionsAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { java.lang.String currentPatchSet; if (((info.current_revision()) != null) && (info.revisions().containsKey(info.current_revision()))) { currentPatchSet = info.revision(info.current_revision()).id(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1)).id(); } java.lang.String currentlyViewedPatchSet = info.revision(revision).id(); patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets); }
@java.lang.Override public void execute() { file.setFocus(true); }
@java.lang.Override protected void onLoad() { file.set(id, content); file.setText(fileName); file.setEnabled(fileName.isEmpty()); content.setText(fileContent); save.setEnabled(false); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { file.setFocus(true); } }); }


@java.lang.Override public boolean match(java.lang.String ref, java.lang.String username) { if ((!(ref.startsWith(prefix))) || (username == null)) { return false; } java.lang.String u; if (com.google.gerrit.server.project.RefControl.isRE(template.getPattern())) { u = java.util.regex.Pattern.quote(username); } else { u = username; } com.google.gerrit.server.project.RefPatternMatcher next = com.google.gerrit.server.project.RefPatternMatcher.getMatcher(template.replace(java.util.Collections.singletonMap("username", u))); return (next != null) && (next.match(ref, username)); }
private void initEditMode(com.google.gerrit.client.changes.ChangeInfo info) { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); } com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revision(revision); editFileAction = new com.google.gerrit.client.change.EditFileAction(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), "", "", style, editMessage, reply, ((edit) != null)); }

void set(com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gwtexpui.globalkey.client.NpTextArea content) { this.id = id; this.textArea = content; }
private void loadFileContent() { com.google.gerrit.client.changes.ChangeFileApi.getContent(id, getText(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { textArea.setText(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { } else { super.onFailure(caught); } } }); }
private static com.google.gerrit.client.rpc.RestApi contentEditOrPs(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String filename) { return (id.get()) == 0 ? com.google.gerrit.client.changes.ChangeFileApi.contentEdit(id.getParentKey(), filename) : com.google.gerrit.client.changes.ChangeApi.revision(id).view("files").id(filename).view("content"); }
@java.lang.Override protected void onLoad() { file.set(id, content); file.setText(fileName); file.setEnabled(fileName.isEmpty()); content.setText(fileContent); save.setEnabled(false); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { content.setFocus(true); } }); }
@java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.change.EditFileAction edit = new com.google.gerrit.client.change.EditFileAction(curr, result, path, style, editButton, replyButton); edit.onEdit(); }
private void initEditMode(com.google.gerrit.client.changes.ChangeInfo info) { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); } com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revision(revision); editFileAction = new com.google.gerrit.client.change.EditFileAction(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), "", "", style, editMessage, reply); }
void onEdit() { if ((popup) != null) { popup.hide(); return; } if ((editBox) == null) { editBox = new com.google.gerrit.client.change.EditFileBox(id, content, file); } final com.google.gwtexpui.user.client.PluginSafePopupPanel p = new com.google.gwtexpui.user.client.PluginSafePopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(editMessageButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(editBox); p.showRelativeTo(relativeTo); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); popup = p; }
public static void getContent(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String filename, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.changes.ChangeFileApi.contentEditOrPs(id, filename).get(new com.google.gerrit.client.changes.ChangeFileApi.CallbackWrapper<com.google.gerrit.client.rpc.NativeString, java.lang.String>(cb) { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString b64) { wrapped.onSuccess(com.google.gerrit.client.changes.ChangeFileApi.b64decode(b64.asString())); } }); }
void onEdit(int idx) { final java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeFileApi.getContent(curr, path, new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.change.EditFileAction edit = new com.google.gerrit.client.change.EditFileAction(curr, result, path, style, editButton, replyButton); edit.onEdit(); } }); }



@java.lang.Override public com.google.gerrit.server.WebLinks get() { com.google.gerrit.server.WebLinks webLinks = new com.google.gerrit.server.WebLinks(patchSetLinks, projectLinks, branchLinks); return webLinks; }


@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.xdocs.XDocLoader.Module()); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.ProjectWebLink.class).to(com.googlesource.gerrit.plugins.xdocs.XDocWebLink.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.BranchWebLink.class).to(com.googlesource.gerrit.plugins.xdocs.XDocWebLink.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).toInstance(new com.google.gerrit.extensions.webui.TopMenu() { @java.lang.Override public java.util.List<com.googlesource.gerrit.plugins.xdocs.MenuEntry> getEntries() { java.lang.StringBuilder url = new java.lang.StringBuilder(); url.append("/plugins/"); url.append(pluginName); url.append(XDocServlet.PATH_PREFIX); url.append("${projectName}/README.md"); return com.google.common.collect.Lists.newArrayList(new com.googlesource.gerrit.plugins.xdocs.MenuEntry(com.google.gerrit.extensions.webui.GerritTopMenu.PROJECTS, com.google.common.collect.Lists.newArrayList(new com.googlesource.gerrit.plugins.xdocs.MenuItem("Readme", url.toString())))); } }); }



private void enableForm(boolean isOwner) { state.setEnabled(isOwner); submitType.setEnabled(isOwner); setEnabledForUseContentMerge(); descTxt.setEnabled(isOwner); contributorAgreements.setEnabled(isOwner); signedOffBy.setEnabled(isOwner); requireChangeID.setEnabled(isOwner); maxObjectSizeLimit.setEnabled(isOwner); if ((pluginConfigWidgets) != null) { for (java.util.Map<java.lang.String, com.google.gwt.user.client.ui.HasEnabled> widgetMap : pluginConfigWidgets.values()) { for (com.google.gwt.user.client.ui.HasEnabled widget : widgetMap.values()) { widget.setEnabled(isOwner); } } } }
private void doSave() { enableForm(false); saveProject.setEnabled(false); com.google.gerrit.client.projects.ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contributorAgreements), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(contentMerge), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(signedOffBy), com.google.gerrit.client.admin.ProjectInfoScreen.getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), com.google.gerrit.extensions.common.SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), com.google.gerrit.extensions.api.projects.ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.ConfigInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.ConfigInfo result) { enableForm(); display(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableForm(); super.onFailure(caught); } }); }
public void copySettingsFrom(final com.google.gerrit.reviewdb.client.Project update) { description = update.description; useContributorAgreements = update.useContributorAgreements; useSignedOffBy = update.useSignedOffBy; useContentMerge = update.useContentMerge; requireChangeID = update.requireChangeID; submitType = update.submitType; state = update.state; maxObjectSizeLimit = update.maxObjectSizeLimit; }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.use_contributor_agreements()); setBool(signedOffBy, result.use_signed_off_by()); setBool(contentMerge, result.use_content_merge()); setBool(requireChangeID, result.require_change_id()); setSubmitType(result.submit_type()); setState(result.state()); maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value()); if ((result.max_object_size_limit().inherited_value()) != null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value())); effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value())); } else { effectiveMaxObjectSizeLimit.setVisible(false); } saveProject.setEnabled(false); initPluginOptions(result); initProjectActions(result); }



public static void setConfig(com.google.gerrit.reviewdb.client.Project.NameKey name, java.lang.String description, com.google.gerrit.extensions.common.InheritableBoolean useContributorAgreements, com.google.gerrit.extensions.common.InheritableBoolean useContentMerge, com.google.gerrit.extensions.common.InheritableBoolean useSignedOffBy, com.google.gerrit.extensions.common.InheritableBoolean requireChangeId, java.lang.String maxObjectSizeLimit, com.google.gerrit.extensions.common.SubmitType submitType, com.google.gerrit.extensions.api.projects.ProjectState state, java.util.Map<java.lang.String, java.util.Map<java.lang.String, com.google.gerrit.client.projects.ConfigInfo.ConfigParameterValue>> pluginConfigValues, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfo> cb) { com.google.gerrit.client.projects.ProjectApi.ConfigInput in = com.google.gerrit.client.projects.ProjectApi.ConfigInput.create(); in.setDescription(description); in.setUseContributorAgreements(useContributorAgreements); in.setUseContentMerge(useContentMerge); in.setUseSignedOffBy(useSignedOffBy); in.setRequireChangeId(requireChangeId); in.setMaxObjectSizeLimit(maxObjectSizeLimit); in.setSubmitType(submitType); in.setState(state); in.setPluginConfigValues(pluginConfigValues); com.google.gerrit.client.projects.ProjectApi.project(name).view("config").put(in, cb); }


private void initProjectActions(com.google.gerrit.client.projects.ConfigInfo info) { actionsGrid.clear(true); actionsGrid.removeAllRows(); com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = info.actions(); if ((actions == null) || (actions.isEmpty())) { return; } actions.copyKeysIntoChildren("id"); actionsGrid.addHeader(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingProjectCommands())); com.google.gwt.user.client.ui.FlowPanel actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions()); actionsPanel.setVisible(true); actionsGrid.add(Util.C.headingCommands(), actionsPanel); for (java.lang.String id : actions.keySet()) { actionsPanel.add(new com.google.gerrit.client.actions.ActionButton(getProjectKey(), actions.get(id))); } }












static java.lang.String editRefName(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Change.Id changeId) { return java.lang.String.format("%s/edit-%d", com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId), changeId.get()); }
public com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> byChange(com.google.gerrit.reviewdb.client.Change change) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { if (!(user.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject()); try { com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (user.get())); org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().getRef(com.google.gerrit.server.edit.ChangeEditUtil.editRefName(me.getAccountId(), change.getId())); if (ref == null) { return com.google.common.base.Optional.absent(); } org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(ref.getObjectId()); com.google.gerrit.reviewdb.client.PatchSet basePs = getBasePatchSet(change, commit); return com.google.common.base.Optional.of(new com.google.gerrit.server.edit.ChangeEdit(me, change, ref, commit, basePs)); } finally { rw.release(); } } finally { repo.close(); } }
public void publish(com.google.gerrit.server.edit.ChangeEdit edit) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change change = edit.getChange(); org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject()); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter(); try { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = edit.getBasePatchSet(); if (!(basePatchSet.getId().equals(change.currentPatchSetId()))) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("only edit for current patch set can be published"); } insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(repo, rw, inserter, edit.getEditCommit(), basePatchSet)); } finally { inserter.release(); rw.release(); } com.google.gerrit.server.edit.ChangeEditUtil.deleteRef(repo, edit); } finally { repo.close(); } }
public RefUpdate.Result createEdit(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (currentUser.get())); org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject()); java.lang.String refName = com.google.gerrit.server.edit.ChangeEditUtil.editRefName(me.getAccountId(), change.getId()); try { if ((repo.getRefDatabase().getRef(refName)) != null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("edit already exists"); } org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter(); try { org.eclipse.jgit.revwalk.RevCommit base = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())); org.eclipse.jgit.lib.ObjectId commit = createCommit(me, inserter, base, base, base.getTree()); inserter.flush(); return update(repo, me, refName, rw, org.eclipse.jgit.lib.ObjectId.zeroId(), commit); } finally { rw.release(); inserter.release(); } } finally { repo.close(); } }
public void delete(com.google.gerrit.server.edit.ChangeEdit edit) throws java.io.IOException { com.google.gerrit.reviewdb.client.Change change = edit.getChange(); org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject()); try { com.google.gerrit.server.edit.ChangeEditUtil.deleteRef(repo, edit); } finally { repo.close(); } }















private com.google.gwtexpui.safehtml.client.SafeHtmlBuilder formatHashtags(com.google.gwt.core.client.JsArrayString hashtags) { com.google.gwtexpui.safehtml.client.SafeHtmlBuilder html = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); java.util.Iterator<java.lang.String> itr = com.google.gerrit.client.rpc.Natives.asList(hashtags).iterator(); while (itr.hasNext()) { java.lang.String hashtagName = itr.next(); html.openSpan().setAttribute("role", "listitem").setAttribute(com.google.gerrit.client.change.Hashtags.DATA_ID, hashtagName).setStyleName(style.hashtagName()).append(hashtagName).openElement("button").setAttribute("title", "Remove hashtag").setAttribute("onclick", ((com.google.gerrit.client.change.Hashtags.REMOVE) + "(event)")).append(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button"); html.closeSpan(); if (itr.hasNext()) { html.append(' '); } } return html; }





private static com.google.gerrit.client.ui.LinkMenuItem addProjectLink(com.google.gerrit.client.ui.LinkMenuBar m, com.google.gerrit.client.extensions.TopMenuItem item) { com.google.gerrit.client.ui.LinkMenuItem i = new com.google.gerrit.client.ui.ProjectLinkMenuItem(item.getName(), item.getUrl()) { @java.lang.Override protected void onScreenLoad(com.google.gerrit.reviewdb.client.Project.NameKey project) { java.lang.String p = panel.replace("${projectName}", project.get()); if (panel.startsWith("/x/")) { setTargetHistoryToken(p); } else if (com.google.gerrit.client.Gerrit.isAbsolute(panel)) { getElement().setPropertyString("href", p); } else { getElement().setPropertyString("href", com.google.gerrit.client.Gerrit.selfRedirect(p)); } } @java.lang.Override public void go() { java.lang.String href = getElement().getPropertyString("href"); if (href.startsWith("#")) { super.go(); } else { com.google.gwt.user.client.Window.open(href, getElement().getPropertyString("target"), ""); } } }; if (((item.getTarget()) != null) && (!(item.getTarget().isEmpty()))) { i.getElement().setAttribute("target", item.getTarget()); } if ((item.getId()) != null) { i.getElement().setAttribute("id", item.getId()); } m.addItem(i); return i; }
@java.lang.Override protected void onScreenLoad(com.google.gerrit.reviewdb.client.Project.NameKey project) { java.lang.String p = panel.replace("${projectName}", project.get()); if (panel.startsWith("/x/")) { setTargetHistoryToken(p); } else if (com.google.gerrit.client.Gerrit.isAbsolute(panel)) { getElement().setPropertyString("href", p); } else { getElement().setPropertyString("href", com.google.gerrit.client.Gerrit.selfRedirect(p)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<? extends java.util.Set<java.lang.String>> apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.HashtagsInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((input == null) || (((input.add) == null) && ((input.remove) == null))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Hashtags are required"); } com.google.gerrit.server.project.ChangeControl control = req.getControl(); if (!(control.canEditHashtags())) { throw new com.google.gerrit.extensions.restapi.AuthException("Editing hashtags not permitted"); } com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(control); com.google.gerrit.server.notedb.ChangeNotes notes = control.getNotes().load(); java.util.Set<java.lang.String> existingHashtags = notes.getHashtags(); java.util.Set<java.lang.String> updatedHashtags = new java.util.HashSet<>(); java.util.Set<java.lang.String> toAdd = new java.util.HashSet(extractTags(input.add)); java.util.Set<java.lang.String> toRemove = new java.util.HashSet(extractTags(input.remove)); for (com.google.gerrit.server.validators.HashtagValidationListener validator : hashtagValidationListeners) { try { validator.validateHashtags(req.getChange(), toAdd, toRemove); } catch (com.google.gerrit.server.validators.ValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } if ((existingHashtags != null) && (!(existingHashtags.isEmpty()))) { updatedHashtags.addAll(existingHashtags); toAdd.removeAll(existingHashtags); toRemove.retainAll(existingHashtags); } if (((toAdd.size()) > 0) || ((toRemove.size()) > 0)) { updatedHashtags.addAll(toAdd); updatedHashtags.removeAll(toRemove); update.setHashtags(updatedHashtags); update.commit(); indexer.index(dbProvider.get(), update.getChange()); com.google.gerrit.server.IdentifiedUser currentUser = ((com.google.gerrit.server.IdentifiedUser) (control.getCurrentUser())); hooks.doHashtagsChangedHook(req.getChange(), currentUser.getAccount(), toAdd, toRemove, updatedHashtags, dbProvider.get()); } return com.google.gerrit.extensions.restapi.Response.ok(new java.util.TreeSet<java.lang.String>(updatedHashtags)); }

void setHeaderVisible(boolean show) { headerVisible = show; com.google.gwt.user.client.ui.UIObject.setVisible(patchSetNavRow, show); com.google.gwt.user.client.ui.UIObject.setVisible(diffHeaderRow, (show && (header))); if (show) { parent.header.removeStyleName(com.google.gerrit.client.diff.DiffTable.style.fullscreen()); } else { parent.header.addStyleName(com.google.gerrit.client.diff.DiffTable.style.fullscreen()); } parent.resizeCodeMirror(); }



private com.google.gwt.user.client.ui.Widget createEditIcon() { com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.edit())); anchor.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gerrit.reviewdb.client.PatchSet.Id id = ((idActive) == null) ? other.idActive : idActive; com.google.gerrit.client.changes.ChangeFileApi.getContent(id, path, new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.change.EditFileAction edit = new com.google.gerrit.client.change.EditFileAction(id, result, path, style.replyBox(), null, icon); edit.onEdit(); } }); } }); anchor.setTitle(PatchUtil.C.edit()); return anchor; }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gerrit.reviewdb.client.PatchSet.Id id = ((idActive) == null) ? other.idActive : idActive; com.google.gerrit.client.changes.ChangeFileApi.getContent(id, path, new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.change.EditFileAction edit = new com.google.gerrit.client.change.EditFileAction(id, result, path, style.replyBox(), null, icon); edit.onEdit(); } }); }


@java.lang.Override protected void configure() { install(copyConfigModule); install(cm); install(sm); }
public void setCfgInjector(com.google.inject.Injector cfgInjector) { final java.lang.Module cm = copy(cfgInjector); final java.lang.Module sm = copy(sysInjector); sysModule = new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { install(copyConfigModule); install(cm); install(sm); } }; }
@java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser() { return null; }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { req.setAttribute(com.google.gerrit.pgm.http.jetty.GetUserFilter.REQ_ATTR_KEY, userProvider.get()); chain.doFilter(req, resp); }

@java.lang.Override public java.lang.String getBranchUrl(java.lang.String projectName, java.lang.String branchName) { return getPatchUrl(projectName, branchName, "README.md"); }



@com.google.gwt.uibinder.client.UiHandler("add") void onAdd(com.google.gwt.event.dom.client.ClickEvent e) { java.lang.String hashtag = hashtagTextBox.getText(); if (!(hashtag.isEmpty())) { addHashtag(hashtag); } }





static void initialize(org.eclipse.jgit.lib.Config cfg) { cfg.setString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.SECTION_FORMATTER, MarkdownFormatter.NAME, com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_MIME_TYPE, "text/x-markdown"); cfg.setString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.SECTION_FORMATTER, PlainTextFormatter.NAME, com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_MIME_TYPE, "text/plain"); }
@java.lang.Override protected void doGetText(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader(); try { org.eclipse.jgit.lib.ObjectLoader loader = reader.open(view.getRevision().getId()); if ((loader.getType()) != (OBJ_COMMIT)) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); } else { try (java.io.Writer writer = startRenderText(req, res);java.io.OutputStream out = com.google.common.io.BaseEncoding.base64().encodingStream(writer)) { loader.copyTo(out); } } } finally { reader.release(); } }


private void assertTag(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch, java.lang.String tagName) throws java.io.IOException { org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project); try { org.eclipse.jgit.lib.ObjectId headCommit = r.getRef(branch).getObjectId(); org.eclipse.jgit.lib.ObjectId taggedCommit = r.getRef(tagName).getObjectId(); assertEquals(headCommit, taggedCommit); } finally { r.close(); } }
@org.junit.Test public void submitOnPushWithTag() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { grant(Permission.SUBMIT, project, "refs/for/refs/heads/master"); grant(Permission.CREATE, project, "refs/tags/*"); grant(Permission.PUSH, project, "refs/tags/*"); final java.lang.String tag = "v1.0"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent()); push.setTag(tag); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master%submit"); r.assertOkStatus(); r.assertChange(Change.Status.MERGED, null, admin); assertSubmitApproval(r.getPatchSetId()); assertCommit(project, "refs/heads/master"); assertTag(project, "refs/heads/master", tag); }

private com.google.gerrit.acceptance.PushOneCommit.Result execute(org.eclipse.jgit.api.Git git, java.lang.String ref) throws java.io.IOException, org.eclipse.jgit.api.errors.ConcurrentRefUpdateException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.api.errors.InvalidTagNameException, org.eclipse.jgit.api.errors.NoHeadException { com.google.gerrit.acceptance.GitUtil.Commit c; if ((changeId) != null) { c = com.google.gerrit.acceptance.GitUtil.amendCommit(git, i, subject, changeId); } else { c = com.google.gerrit.acceptance.GitUtil.createCommit(git, i, subject); changeId = c.getChangeId(); } if ((tagName) != null) { git.tag().setName(tagName).setAnnotated(false).call(); } return new com.google.gerrit.acceptance.PushOneCommit.Result(ref, com.google.gerrit.acceptance.GitUtil.pushHead(git, ref, ((tagName) != null)), c, subject); }
static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { protected void configure() { persist(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.REPO_SIZE_CACHE, Project.NameKey.class, java.util.concurrent.atomic.AtomicLong.class).loader(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.Loader.class).expireAfterWrite(1, java.util.concurrent.TimeUnit.DAYS); } }; }
protected void configure() { persist(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.REPO_SIZE_CACHE, Project.NameKey.class, java.util.concurrent.atomic.AtomicLong.class).loader(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.Loader.class).expireAfterWrite(1, java.util.concurrent.TimeUnit.DAYS); }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment() throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((rule) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.ByteArrayInputStream(rule.getBytes(java.nio.charset.StandardCharsets.UTF_8))); } } catch (com.googlecode.prolog_cafe.compiler.CompileException err) { throw new com.google.gerrit.server.project.RuleEvalException(("Cannot consult rules.pl for " + (getProjectName())), err); } env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.PATCH_SET, patchSet); env.set(StoredValues.CHANGE_CONTROL, control); return env; }
public com.google.gerrit.server.project.SubmitRuleEvaluator setPatchSet(com.google.gerrit.reviewdb.client.PatchSet ps) { checkArgument(ps.getId().getParentKey().equals(cd.getId())); patchSet = ps; return this; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> canSubmit() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = control.getChange(); if ((!(allowClosed)) && (c.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } com.google.gerrit.reviewdb.client.PatchSet ps = getPatchSet(); if (!(ps.getId().equals(c.currentPatchSetId()))) { return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError((("Patch set " + (ps.getPatchSetId())) + " is not current")); } if ((((c.getStatus()) == (Change.Status.DRAFT)) || (ps.isDraft())) && (!(allowDraft))) { return cannotSubmitDraft(); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results"); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError((((((("Submit rule '" + (getSubmitRule())) + "' for change ") + (cd.getId())) + " of ") + (getProjectName())) + " has no solution.")); } return resultsToSubmitRecord(getSubmitRule(), results); }
public com.google.gerrit.common.data.SubmitTypeRecord getSubmitType() { java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results"); } catch (com.google.gerrit.server.project.RuleEvalException e) { return typeError(e.getMessage(), e); } if (results.isEmpty()) { return typeError((((((("Submit rule '" + (getSubmitRule())) + "' for change ") + (cd.getId())) + " of ") + (getProjectName())) + " has no solution.")); } com.googlecode.prolog_cafe.lang.Term typeTerm = results.get(0); if (!(typeTerm.isSymbol())) { return typeError((((((("Submit rule '" + (getSubmitRule())) + "' for change ") + (cd.getId())) + " of ") + (getProjectName())) + " did not return a symbol.")); } java.lang.String typeName = ((com.googlecode.prolog_cafe.lang.SymbolTerm) (typeTerm)).name(); try { return com.google.gerrit.common.data.SubmitTypeRecord.OK(com.google.gerrit.extensions.common.SubmitType.valueOf(typeName.toUpperCase())); } catch (java.lang.IllegalArgumentException e) { return typeError(((((((("Submit type rule " + (getSubmitRule())) + " for change ") + (cd.getId())) + " of ") + (getProjectName())) + " output invalid result: ") + typeName)); } }
private java.util.List<com.google.gerrit.common.data.SubmitRecord> cannotSubmitDraft() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = getPatchSet(); try { if (!(control.isDraftVisible(cd.db(), cd))) { return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError((("Patch set " + (ps.getPatchSetId())) + " not found")); } else if (patchSet.isDraft()) { return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError("Cannot submit draft patch sets"); } else { return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError("Cannot submit draft changes"); } } catch (com.google.gwtorm.server.OrmException err) { java.lang.String msg = "Cannot read patch set " + ps; com.google.gerrit.server.project.SubmitRuleEvaluator.log.error(msg, err); return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError(msg); } }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> canSubmit() { java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results"); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError((((((("Submit rule '" + (getSubmitRule())) + "' for change ") + (cd.getId())) + " of ") + (getProjectName())) + " has no solution.")); } return resultsToSubmitRecord(getSubmitRule(), results); }


@java.lang.Override public com.google.gerrit.extensions.common.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.TestSubmitRule.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.change.TestSubmitRule.Input(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.server.change.TestSubmitRule.Filters.SKIP))).setRule(input.rule).evaluateSubmitType(); } catch (com.google.gerrit.server.project.RuleEvalException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule failed with exception: %s", e.getMessage())); } if (results.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s has no solution", evaluator.getSubmitRule())); } com.googlecode.prolog_cafe.lang.Term type = results.get(0); if (!(type.isSymbol())) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type)); } java.lang.String typeName = ((com.googlecode.prolog_cafe.lang.SymbolTerm) (type)).name(); try { return com.google.gerrit.extensions.common.SubmitType.valueOf(typeName.toUpperCase()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type)); } }



public java.util.List<com.googlecode.prolog_cafe.lang.Term> evaluate() throws com.google.gerrit.server.project.RuleEvalException { return evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results"); }

@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.TestSubmitRule.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.change.TestSubmitRule.Input(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet()); java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluator.setSkipSubmitFilters(((input.filters) == (com.google.gerrit.server.change.TestSubmitRule.Filters.SKIP))).setRule(input.rule).evaluate(); } catch (com.google.gerrit.server.project.RuleEvalException e) { java.lang.String msg = com.google.common.base.Joiner.on(": ").skipNulls().join(com.google.common.collect.Iterables.transform(com.google.common.base.Throwables.getCausalChain(e), new com.google.common.base.Function<java.lang.Throwable, java.lang.String>() { @java.lang.Override public java.lang.String apply(java.lang.Throwable in) { return in.getMessage(); } })); throw new com.google.gerrit.extensions.restapi.BadRequestException(("rule failed: " + msg)); } if (results.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s has no solutions", evaluator.getSubmitRule().toString())); } java.util.List<com.google.gerrit.common.data.SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountInfo.Loader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } accounts.fill(); return out; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> canSubmit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet patchSet, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) { if ((!allowClosed) && (getChange().getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } if (!(patchSet.getId().equals(getChange().currentPatchSetId()))) { return ruleError((("Patch set " + (patchSet.getPatchSetId())) + " is not current")); } cd = changeData(db, cd); if ((((getChange().getStatus()) == (Change.Status.DRAFT)) || (patchSet.isDraft())) && (!allowDraft)) { return cannotSubmitDraft(db, patchSet, cd); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; com.google.gerrit.server.project.SubmitRuleEvaluator evaluator; try { evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(cd, patchSet); results = evaluator.setFastEvalLabels(fastEvalLabels).evaluate(); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.RuleEvalException e) { return logRuleError(e.getMessage(), e); } if (results.isEmpty()) { com.google.gerrit.server.project.ChangeControl.log.error((((((("Submit rule '" + (evaluator.getSubmitRule())) + "' for change ") + (getChange().getId())) + " of ") + (getProject().getName())) + " has no solution.")); return ruleError("Project submit rule has no solution"); } return resultsToSubmitRecord(evaluator.getSubmitRule(), results); }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> canSubmit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet patchSet, @com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) { if ((!allowClosed) && (getChange().getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } if (!(patchSet.getId().equals(getChange().currentPatchSetId()))) { return ruleError((("Patch set " + (patchSet.getPatchSetId())) + " is not current")); } cd = changeData(db, cd); if ((((getChange().getStatus()) == (Change.Status.DRAFT)) || (patchSet.isDraft())) && (!allowDraft)) { return cannotSubmitDraft(db, patchSet, cd); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; com.google.gerrit.server.project.SubmitRuleEvaluator evaluator; try { evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, fastEvalLabels, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results"); results = evaluator.evaluate(); } catch (com.google.gerrit.server.project.RuleEvalException e) { return logRuleError(e.getMessage(), e); } if (results.isEmpty()) { com.google.gerrit.server.project.ChangeControl.log.error((((((("Submit rule '" + (evaluator.getSubmitRule())) + "' for change ") + (getChange().getId())) + " of ") + (getProject().getName())) + " has no solution.")); return ruleError("Project submit rule has no solution"); } return resultsToSubmitRecord(evaluator.getSubmitRule(), results); }
void set(com.google.gerrit.client.account.DiffPreferences prefs, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list, com.google.gerrit.client.diff.DiffInfo info, boolean editExists, int currentPatchSet) { this.changeType = info.change_type(); this.autoHideHeader = prefs.autoHideDiffTableHeader(); patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a(), com.google.gerrit.client.rpc.Natives.asList(info.web_links_a()), editExists, currentPatchSet); patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b(), com.google.gerrit.client.rpc.Natives.asList(info.web_links_b()), editExists, currentPatchSet); com.google.gwt.core.client.JsArrayString hdr = info.diff_header(); if (hdr != null) { java.lang.StringBuilder b = new java.lang.StringBuilder(); for (int i = 1; i < (hdr.length()); i++) { java.lang.String s = hdr.get(i); if ((((s.startsWith("diff --git ")) || (s.startsWith("index "))) || (s.startsWith("+++ "))) || (s.startsWith("--- "))) { continue; } b.append(s).append('\n'); } java.lang.String hdrTxt = b.toString().trim(); header = !(hdrTxt.isEmpty()); diffHeaderText.setInnerText(hdrTxt); com.google.gwt.user.client.ui.UIObject.setVisible(diffHeaderRow, header); } else { header = false; com.google.gwt.user.client.ui.UIObject.setVisible(diffHeaderRow, false); } setHideEmptyPane(prefs.hideEmptyPane()); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { info.revisions().copyKeysIntoChildren("name"); if ((edit) != null) { edit.set_name(edit.commit().commit()); info.set_edit(edit); info.revisions().put(edit.name(), com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.fromEdit(edit)); } int currentPatchSet = info.revision(info.current_revision())._number(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(list); diffTable.set(prefs, list, diff, ((edit) != null), currentPatchSet); header.setChangeInfo(info); }
@java.lang.Override protected void configureServlets() { filter("/*").through(com.googlesource.gerrit.plugins.serverconfig.HideFromNonAdmins.class); serve("/*").with(com.googlesource.gerrit.plugins.serverconfig.ServerConfigServlet.class); }



public java.lang.Iterable<com.google.gerrit.extensions.common.WebLinkInfo> getFileLinks(java.lang.String project, java.lang.String revision, java.lang.String file) { java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.FileWebLink webLink : fileLinks) { links.add(new com.google.gerrit.extensions.common.WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getFileUrl(project, revision, file), webLink.getTarget())); } return links; }
public java.lang.Iterable<com.google.gerrit.extensions.common.WebLinkInfo> getPatchSetLinks(java.lang.String project, java.lang.String commit) { java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks) { links.add(new com.google.gerrit.extensions.common.WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit), webLink.getTarget())); } return links; }
@java.lang.Override public java.lang.String getTarget() { return Target.BLANK; }
@java.lang.Override public java.lang.String getLinkName() { return "readme"; }
public java.lang.String getPatchUrl(java.lang.String projectName, java.lang.String revision, java.lang.String fileName) { if (!(fileName.endsWith(".md"))) { return null; } com.google.gerrit.reviewdb.client.Project.NameKey p = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(p); try { org.eclipse.jgit.lib.ObjectId revId = repo.resolve(revision); if (revId == null) { return null; } com.google.gerrit.httpd.resources.Resource rsc = docCache.getUnchecked(new com.googlesource.gerrit.plugins.xdocs.XDocResourceKey(p, fileName, revId).asString()); if (rsc != (com.google.gerrit.httpd.resources.Resource.NOT_FOUND)) { java.lang.StringBuilder url = new java.lang.StringBuilder(); url.append("plugins/"); url.append(pluginName); url.append(XDocServlet.PATH_PREFIX); url.append(com.google.gerrit.extensions.restapi.Url.encode(projectName)); if ((revision != null) && (!(Constants.HEAD.equals(revision)))) { url.append("/rev/"); url.append(com.google.gerrit.extensions.restapi.Url.encode(revision)); } url.append("/"); url.append(com.google.gerrit.extensions.restapi.Url.encode(fileName)); return url.toString(); } else { return null; } } finally { repo.close(); } } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.xdocs.XDocWebLink.log.error("Failed to check for project documentation", e); return null; } }
@java.lang.Override public java.lang.String getImageUrl() { return ("plugins/" + (pluginName)) + "/static/readme.png"; }
@java.lang.Override public java.lang.String getProjectUrl(java.lang.String projectName) { return getBranchUrl(projectName, Constants.HEAD); }
@java.lang.Override public java.lang.String getBranchUrl(java.lang.String projectName, java.lang.String branchName) { com.google.gerrit.server.project.ProjectState state = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)); if (state == null) { return null; } return getPatchUrl(projectName, branchName, cfgFactory.create(state).getIndexFile()); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { java.lang.String commandName = dcmd.getCommandName(); java.lang.String[] args = dcmd.getArguments(); if ((args.length) > 1) { return (commandName + ".") + (args[1]); } return commandName; }
private void updateSubscriptions(final java.util.List<com.google.gerrit.reviewdb.client.Change> submitted) { if (((mergeTip) != null) && (((branchTip) == null) || ((branchTip) != (mergeTip)))) { com.google.gerrit.server.git.SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip, rw, repo, destProject.getProject(), submitted, commits, getAccount(mergeTip)); try { subOp.update(); } catch (com.google.gerrit.server.git.SubmoduleException e) { com.google.gerrit.server.git.MergeOp.log.error(("The gitLinks were not updated according to the subscriptions " + (e.getMessage()))); } } }
public static void replyError(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, int statusCode, java.lang.String msg, com.google.gerrit.extensions.restapi.CacheControl c) throws java.io.IOException { res.setStatus(statusCode); com.google.gerrit.httpd.restapi.RestApiServlet.configureCaching(req, res, null, c); com.google.gerrit.httpd.restapi.RestApiServlet.replyText(req, res, msg); }
boolean wouldPushProject(com.google.gerrit.reviewdb.client.Project.NameKey project) { if ((projects.length) < 1) { return true; } java.lang.String projectName = project.get(); for (final java.lang.String projectMatch : projects) { if (com.googlesource.gerrit.plugins.replication.Destination.isRE(projectMatch)) { if (projectName.matches(projectMatch)) { return true; } } else if (com.googlesource.gerrit.plugins.replication.Destination.isWildcard(projectMatch)) { if (projectName.startsWith(projectMatch.substring(0, ((projectMatch.length()) - 1)))) { return true; } } else { if (projectName.equals(projectMatch)) { return true; } } } return false; }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.lang.String branchName = id.get(); if ((!(branchName.startsWith(Constants.R_REFS))) && (!(branchName.equals(Constants.HEAD)))) { branchName = (org.eclipse.jgit.lib.Constants.R_HEADS) + branchName; } java.util.List<com.google.gerrit.server.project.ListBranches.BranchInfo> branches = list.apply(parent); for (com.google.gerrit.server.project.ListBranches.BranchInfo b : branches) { if (branchName.equals(b.ref)) { return new com.google.gerrit.server.project.BranchResource(parent.getControl(), b); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }


@java.lang.Override public java.lang.String format(java.lang.String projectName, com.googlesource.gerrit.plugins.xdocs.ConfigSection cfg, java.lang.String raw) throws java.io.IOException { return Asciidoctor.Factory.create(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getClassLoader()).convert(raw, new java.util.HashMap<java.lang.String, java.lang.Object>()); }


private static java.lang.String readCSS() { if ((com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.css) != null) { return com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.css; } try { return com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.readCss(new java.util.concurrent.atomic.AtomicBoolean()); } catch (java.io.IOException err) { return ""; } }
@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection cfg, java.lang.String raw) throws java.io.IOException { java.io.File tmpFile = new java.io.File(baseDir, (("tmp/asciidoctor-" + (java.lang.System.currentTimeMillis())) + ".tmp")); try { Asciidoctor.Factory.create(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getClassLoader()).render(raw, createOptions(cfg, revision, tmpFile)); try (java.io.FileInputStream input = new java.io.FileInputStream(tmpFile)) { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); com.google.common.io.ByteStreams.copy(input, out); return insertCss(out.toString(java.nio.charset.StandardCharsets.UTF_8.name())); } } finally { if (!(tmpFile.delete())) { tmpFile.deleteOnExit(); } } }
private static java.lang.String readCss(java.util.concurrent.atomic.AtomicBoolean file) throws java.io.IOException { java.lang.String name = "asciidoctor.css"; java.net.URL url = com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getResource(name); if (url == null) { throw new java.io.FileNotFoundException(("Resource " + name)); } file.set("file".equals(url.getProtocol())); try (java.io.InputStream in = url.openStream()) { try (org.eclipse.jgit.util.TemporaryBuffer.Heap tmp = new org.eclipse.jgit.util.TemporaryBuffer.Heap((128 * 1024))) { tmp.copy(in); return new java.lang.String(tmp.toByteArray(), java.nio.charset.StandardCharsets.UTF_8); } } }
@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection cfg, java.lang.String raw) throws java.io.IOException { java.io.File tmpFile = new java.io.File(baseDir, (("tmp/asciidoctor-" + (java.lang.System.currentTimeMillis())) + ".tmp")); try { Asciidoctor.Factory.create(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getClassLoader()).render(raw, createOptions(cfg, revision, tmpFile)); try (java.io.FileInputStream input = new java.io.FileInputStream(tmpFile)) { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); com.google.common.io.ByteStreams.copy(input, out); return util.insertCss(out.toString(java.nio.charset.StandardCharsets.UTF_8.name()), com.google.common.base.MoreObjects.firstNonNull(util.getCss(projectName, "asciidoctor"), com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.readDefaultCSS())); } } finally { if (!(tmpFile.delete())) { tmpFile.deleteOnExit(); } } }
@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection globalCfg, java.lang.String raw) throws java.io.IOException { java.io.File tmpFile = new java.io.File(baseDir, (("tmp/asciidoctor-" + (java.lang.System.currentTimeMillis())) + ".tmp")); try { Asciidoctor.Factory.create(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getClassLoader()).render(raw, createOptions(formatters.getFormatterConfig(globalCfg.getSubsection(), projectName), revision, tmpFile)); try (java.io.FileInputStream input = new java.io.FileInputStream(tmpFile)) { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); com.google.common.io.ByteStreams.copy(input, out); return util.insertCss(out.toString(java.nio.charset.StandardCharsets.UTF_8.name()), com.google.common.base.MoreObjects.firstNonNull(util.getCss(projectName, "asciidoctor"), com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.readDefaultCSS())); } } finally { if (!(tmpFile.delete())) { tmpFile.deleteOnExit(); } } }
private java.lang.String replaceMacros(com.google.gerrit.reviewdb.client.Project.NameKey project, byte[] raw) { java.util.Map<java.lang.String, java.lang.String> macros = com.google.common.collect.Maps.newHashMap(); java.lang.String url = webUrl.get(); if (com.google.common.base.Strings.isNullOrEmpty(url)) { url = ("http://" + (com.googlesource.gerrit.plugins.xdocs.XDocLoader.DEFAULT_HOST)) + "/"; } macros.put("URL", url); macros.put("PROJECT", project.get()); macros.put("PROJECT_URL", ((url + "#/admin/projects/") + (project.get()))); java.util.regex.Matcher m = java.util.regex.Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(new java.lang.String(raw, java.nio.charset.StandardCharsets.UTF_8)); java.lang.StringBuffer sb = new java.lang.StringBuffer(); while (m.find()) { java.lang.String key = m.group(2); java.lang.String val = macros.get(key); if (((m.group(1)) != null) || (val == null)) { m.appendReplacement(sb, (("@" + key) + "@")); } else { m.appendReplacement(sb, val); } } m.appendTail(sb); return sb.toString(); }
private java.lang.String replaceMacros(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId revId, byte[] raw) { java.util.Map<java.lang.String, java.lang.String> macros = com.google.common.collect.Maps.newHashMap(); java.lang.String url = webUrl.get(); if (com.google.common.base.Strings.isNullOrEmpty(url)) { url = ("http://" + (com.googlesource.gerrit.plugins.xdocs.XDocLoader.DEFAULT_HOST)) + "/"; } macros.put("URL", url); macros.put("PROJECT", project.get()); macros.put("PROJECT_URL", ((url + "#/admin/projects/") + (project.get()))); macros.put("REVISION", revId.getName()); java.util.regex.Matcher m = java.util.regex.Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(new java.lang.String(raw, java.nio.charset.StandardCharsets.UTF_8)); java.lang.StringBuffer sb = new java.lang.StringBuffer(); while (m.find()) { java.lang.String key = m.group(2); java.lang.String val = macros.get(key); if (((m.group(1)) != null) || (val == null)) { m.appendReplacement(sb, (("@" + key) + "@")); } else { m.appendReplacement(sb, val); } } m.appendTail(sb); return sb.toString(); }

private void setWebLinks(com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo) { com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && (gw.canLink(revInfo))) { addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName(), null, null); } com.google.gwt.core.client.JsArray<com.google.gerrit.client.WebLinkInfo> links = revInfo.web_links(); if (links != null) { for (com.google.gerrit.client.WebLinkInfo link : com.google.gerrit.client.rpc.Natives.asList(links)) { addWebLink(link.url(), com.google.gerrit.client.change.CommitBox.parenthesize(link.name()), link.imageUrl(), link.target()); } } }
private void addWebLink(java.lang.String href, java.lang.String name, java.lang.String imageUrl, java.lang.String target) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(); a.setHref(href); if ((target != null) && (!(target.isEmpty()))) { a.setTarget(target); } if ((imageUrl != null) && (!(imageUrl.isEmpty()))) { com.google.gwt.user.client.ui.Image img = new com.google.gwt.user.client.ui.Image(); img.setAltText(name); img.setUrl(imageUrl); img.setTitle(name); a.getElement().appendChild(img.getElement()); } else { a.setText(name); } webLinkPanel.add(a); }


private java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> readGroupList() throws java.io.IOException { groupsByUUID = new java.util.HashMap(); java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName = new java.util.HashMap<>(); java.io.BufferedReader br = new java.io.BufferedReader(new java.io.StringReader(readUTF8(com.google.gerrit.server.git.ProjectConfig.GROUP_LIST))); java.lang.String s; for (int lineNumber = 1; (s = br.readLine()) != null; lineNumber++) { if ((s.isEmpty()) || (s.startsWith("#"))) { continue; } int tab = s.indexOf('\t'); if (tab < 0) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.GROUP_LIST, lineNumber, "missing tab delimiter")); continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(s.substring(0, tab).trim()); java.lang.String name = s.substring((tab + 1)).trim(); com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); groupsByName.put(name, ref); } return groupsByName; }








public org.eclipse.jgit.lib.Config load() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.io.File path = getPath(); if (path == null) { return null; } org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository(path); try { load(repo); } finally { repo.close(); } return cfg; }
@java.lang.Override public void run() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = allProjectsConfig.load(); if ((cfg == null) || (!(cfg.getSubsections(com.google.gerrit.pgm.init.InitLabels.KEY_LABEL).contains(com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED)))) { ui.header("Review Labels"); installVerified = ui.yesno(false, "Install Verified label"); } }

@java.lang.Override public void postRun() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = allProjectsConfig.load(); if (installVerified) { cfg.setString(com.google.gerrit.pgm.init.InitLabels.KEY_LABEL, com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED, com.google.gerrit.pgm.init.InitLabels.KEY_FUNCTION, "MaxWithBlock"); cfg.setStringList(com.google.gerrit.pgm.init.InitLabels.KEY_LABEL, com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED, com.google.gerrit.pgm.init.InitLabels.KEY_VALUE, java.util.Arrays.asList(new java.lang.String[]{ "-1 Fails", " 0 No score", "+1 Verified" })); allProjectsConfig.save("Configure 'Verified' label"); } }

@java.lang.Override public java.lang.String getBranchUrl(java.lang.String projectName, java.lang.String branchName) { com.google.gerrit.server.project.ProjectState state = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)); if (state == null) { return null; } return getPatchUrl(projectName, branchName, cfgFactory.create(state).getIndexFile()); }
public java.lang.String getPatchUrl(java.lang.String projectName, java.lang.String revision, java.lang.String fileName) { com.googlesource.gerrit.plugins.xdocs.formatter.Formatters.FormatterProvider formatter = formatters.get(projectName, fileName); if (formatter == null) { return null; } com.google.gerrit.reviewdb.client.Project.NameKey p = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(p); try { org.eclipse.jgit.lib.ObjectId revId = repo.resolve(revision); if (revId == null) { return null; } com.google.gerrit.httpd.resources.Resource rsc = docCache.getUnchecked(new com.googlesource.gerrit.plugins.xdocs.XDocResourceKey(formatter.getName(), p, fileName, revId).asString()); if (rsc != (com.google.gerrit.httpd.resources.Resource.NOT_FOUND)) { java.lang.StringBuilder url = new java.lang.StringBuilder(); url.append("plugins/"); url.append(pluginName); url.append(XDocServlet.PATH_PREFIX); url.append(com.google.gerrit.extensions.restapi.Url.encode(projectName)); if ((revision != null) && (!(Constants.HEAD.equals(revision)))) { url.append("/rev/"); url.append(com.google.gerrit.extensions.restapi.Url.encode(revision)); } url.append("/"); url.append(com.google.gerrit.extensions.restapi.Url.encode(fileName)); return url.toString(); } else { return null; } } finally { repo.close(); } } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.xdocs.XDocWebLink.log.error("Failed to check for project documentation", e); return null; } }
public java.lang.Iterable<com.google.gerrit.extensions.common.WebLinkInfo> getBranchLinks(java.lang.String project, java.lang.String branch) { java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.BranchWebLink webLink : branchLinks) { links.add(new com.google.gerrit.extensions.common.WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getBranchUrl(project, branch), webLink.getTarget())); } return links; }
public java.lang.Iterable<com.google.gerrit.extensions.common.WebLinkInfo> getProjectLinks(java.lang.String project) { java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.extensions.webui.ProjectWebLink webLink : projectLinks) { links.add(new com.google.gerrit.extensions.common.WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getProjectUrl(project), webLink.getTarget())); } return links; }
public java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> getPatchSetLinks(java.lang.String project, java.lang.String commit) { java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = new java.util.ArrayList<>(4); for (com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks) { links.add(new com.google.gerrit.extensions.common.WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit), webLink.getTarget())); } return links; }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getBranchWebLink(java.lang.String projectName, java.lang.String branchName) { return new com.google.gerrit.extensions.common.WebLinkInfo(com.googlesource.gerrit.plugins.xdocs.XDocWebLink.README, getImageUrl(), getBranchUrl(projectName, branchName), com.google.gerrit.extensions.webui.WebLinkTarget.BLANK); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getFileWebLink(java.lang.String projectName, java.lang.String revision, java.lang.String fileName) { return new com.google.gerrit.extensions.common.WebLinkInfo(com.googlesource.gerrit.plugins.xdocs.XDocWebLink.PREVIEW, getImageUrl(), getFileUrl(projectName, revision, fileName), com.google.gerrit.extensions.webui.WebLinkTarget.BLANK); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getProjectWeblink(java.lang.String projectName) { return new com.google.gerrit.extensions.common.WebLinkInfo(com.googlesource.gerrit.plugins.xdocs.XDocWebLink.README, getImageUrl(), getBranchUrl(projectName, Constants.HEAD), com.google.gerrit.extensions.webui.WebLinkTarget.BLANK); }
boolean isOwner(final com.google.gerrit.server.account.GroupMembership groups) { return com.google.common.collect.Iterables.any(tree(), new com.google.common.base.Predicate<com.google.gerrit.server.project.ProjectState>() { @java.lang.Override public boolean apply(com.google.gerrit.server.project.ProjectState in) { return groups.containsAnyOf(in.localOwners); } }); }
private boolean isDeclaredOwner() { if ((declaredOwner) == null) { declaredOwner = state.isOwner(user.getEffectiveGroups()); } return declaredOwner; }
private byte[] encrypt(final java.lang.String name, final java.util.Date date, final byte[] rawText) throws java.io.IOException, java.security.NoSuchProviderException, org.bouncycastle.openpgp.PGPException { final byte[] zText = com.google.gerrit.server.contact.EncryptedContactStore.compress(name, date, rawText); final org.bouncycastle.openpgp.PGPEncryptedDataGenerator cpk = new org.bouncycastle.openpgp.PGPEncryptedDataGenerator(org.bouncycastle.openpgp.PGPEncryptedData.CAST5, true, prng, "BC"); cpk.addMethod(dest); final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); final org.bouncycastle.bcpg.ArmoredOutputStream aout = new org.bouncycastle.bcpg.ArmoredOutputStream(buf); final java.io.OutputStream cout = cpk.open(aout, zText.length); cout.write(zText); cout.close(); aout.close(); return buf.toByteArray(); }









@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.replication.Failure { if ((all) && ((projectNames.size()) > 0)) { throw new com.googlesource.gerrit.plugins.replication.UnloggedFailure(1, "error: cannot combine --all and PROJECT"); } com.googlesource.gerrit.plugins.replication.ReplicationState state = new com.googlesource.gerrit.plugins.replication.ReplicationState(new com.googlesource.gerrit.plugins.replication.PushResultProcessing.CommandProcessing(this)); java.util.concurrent.Future<?> future = null; if (all) { future = pushAllFactory.create(urlMatch, state).schedule(0, java.util.concurrent.TimeUnit.SECONDS); } else { for (java.lang.String name : projectNames) { com.google.gerrit.reviewdb.client.Project.NameKey key = new com.google.gerrit.reviewdb.client.Project.NameKey(name); if ((projectCache.get(key)) != null) { replication.scheduleFullSync(key, urlMatch, state); } else { writeStdErrSync((("error: '" + name) + "': not a Gerrit project")); } } state.markAllPushTasksScheduled(); } if (wait) { if (future != null) { try { future.get(); } catch (java.lang.InterruptedException e) { com.googlesource.gerrit.plugins.replication.StartCommand.stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state); return; } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.replication.StartCommand.stateLog.error("An exception was thrown in PushAll operation", e, state); return; } } if (state.hasPushTask()) { try { state.waitForReplication(); } catch (java.lang.InterruptedException e) { writeStdErrSync("We are interrupted while waiting replication to complete"); } } else { writeStdOutSync("Nothing to replicate"); } } }
boolean wouldPushProject(com.google.gerrit.reviewdb.client.Project.NameKey project) { if ((projects.length) < 1) { return true; } java.lang.String projectName = project.get(); for (final java.lang.String projectMatch : projects) { if (com.googlesource.gerrit.plugins.replication.Destination.isRE(projectMatch)) { if (projectName.matches(projectMatch)) { return true; } } else if (com.googlesource.gerrit.plugins.replication.Destination.isWildcard(projectMatch)) { if (projectName.startsWith(projectMatch.substring(0, ((projectMatch.length()) - 1)))) { return true; } } else { if (projectName.equals(projectMatch)) { return true; } } } return false; }
boolean isSingleProjectMatch() { boolean ret = (projects.length) == 1; if (ret) { java.lang.String projectMatch = projects[0]; if ((com.googlesource.gerrit.plugins.replication.Destination.isRE(projectMatch)) || (com.googlesource.gerrit.plugins.replication.Destination.isWildcard(projectMatch))) { ret = false; } } return ret; }

@java.lang.Override public void service(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException, javax.servlet.ServletException { java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('/').limit(3).omitEmptyStrings().split(com.google.common.base.Strings.nullToEmpty(com.google.gerrit.httpd.RequestUtil.getEncodedPathInfo(req)))); if (com.google.gerrit.httpd.plugins.HttpPluginServlet.isApiCall(req, parts)) { managerApi.service(req, res); return; } java.lang.String name = parts.get(0); final com.google.gerrit.httpd.plugins.HttpPluginServlet.PluginHolder holder = plugins.get(name); if (holder == null) { com.google.gwtexpui.server.CacheHeaders.setNotCacheable(res); res.sendError(HttpServletResponse.SC_NOT_FOUND); return; } javax.servlet.http.HttpServletRequest wr = wrapper.create(req, name); javax.servlet.FilterChain chain = new javax.servlet.FilterChain() { @java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res) throws java.io.IOException { onDefault(holder, ((javax.servlet.http.HttpServletRequest) (req)), ((javax.servlet.http.HttpServletResponse) (res))); } }; if ((holder.filter) != null) { holder.filter.doFilter(wr, res, chain); } else { chain.doFilter(wr, res); } }
public static java.lang.Throwable getErrorTraceAttribute(javax.servlet.http.HttpServletRequest req) { return ((java.lang.Throwable) (req.getAttribute(com.google.gerrit.httpd.RequestUtil.ATTRIBUTE_ERROR_TRACE))); }
private static java.util.List<com.google.gerrit.extensions.restapi.IdString> splitPath(javax.servlet.http.HttpServletRequest req) { java.lang.String path = com.google.gerrit.httpd.RequestUtil.getEncodedPathInfo(req); if (com.google.common.base.Strings.isNullOrEmpty(path)) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.extensions.restapi.IdString> out = com.google.common.collect.Lists.newArrayList(); for (java.lang.String p : com.google.common.base.Splitter.on('/').split(path)) { out.add(com.google.gerrit.extensions.restapi.IdString.fromUrl(p)); } if (((out.size()) > 0) && (out.get(((out.size()) - 1)).isEmpty())) { out.remove(((out.size()) - 1)); } return out; }
public static void replyError(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, int statusCode, java.lang.String msg, com.google.gerrit.extensions.restapi.CacheControl c, @com.google.gerrit.common.Nullable java.lang.Throwable err) throws java.io.IOException { res.setStatus(statusCode); com.google.gerrit.httpd.restapi.RestApiServlet.configureCaching(req, res, null, c); com.google.gerrit.httpd.restapi.RestApiServlet.replyText(req, res, msg); if (err != null) { com.google.gerrit.httpd.RequestUtil.setErrorTraceAttribute(req, err); } }
public static void setErrorTraceAttribute(javax.servlet.http.HttpServletRequest req, java.lang.Throwable t) { req.setAttribute(com.google.gerrit.httpd.RequestUtil.ATTRIBUTE_ERROR_TRACE, t); }
public static java.util.List<java.lang.reflect.Field> getDeclaredFields(java.lang.Class<?> in) { return com.google.common.collect.Ordering.natural().onResultOf(new com.google.common.base.Function<java.lang.reflect.Field, java.lang.String>() { @java.lang.Override public java.lang.String apply(java.lang.reflect.Field f) { return f.getName(); } }).sortedCopy(java.util.Arrays.asList(in.getDeclaredFields())); }


@java.lang.Override public java.lang.String get(com.google.gerrit.server.query.change.ChangeData input, com.google.gerrit.server.index.FillArgs args) throws com.google.gwtorm.server.OrmException { return input.change().isMergeable() ? "1" : null; }
private <V, K> com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore<K, V> newSqlStore(java.lang.String name, com.google.inject.TypeLiteral<K> keyType, long maxSize, java.lang.Long expireAfterWrite) { java.io.File db = new java.io.File(cacheDir, name).getAbsoluteFile(); java.lang.String url = "jdbc:h2:" + (db.toURI().toString()); return new com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore(url, keyType, maxSize, (expireAfterWrite == null ? 0 : expireAfterWrite.longValue())); }
void close() { com.google.gerrit.server.cache.h2.H2CacheImpl.SqlHandle h; while ((h = handles.poll()) != null) { h.close(); } }
private static boolean isStale(com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.lib.Ref ref) { return ((change.getLastSha1MergeTested()) == null) || (!(com.google.gerrit.server.change.Mergeable.toRevId(ref).equals(change.getLastSha1MergeTested()))); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = object.change(); return (c != null) && (c.isMergeable()); }
static com.google.gerrit.server.query.change.ChangeData createForTest(com.google.gerrit.reviewdb.client.Change.Id id, int currentPatchSetId) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, null, null, null, null, null, null, null, null, id); cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, currentPatchSetId)); return cd; }



@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor com.google.common.util.concurrent.ListeningExecutorService getIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { int threads = this.threads; if (threads <= 0) { threads = config.getInt("index", null, "threads", 0); } if (threads <= 0) { return com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "index")); }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> is(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException { if ("starred".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(args, currentUser); } if ("watched".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsWatchedByPredicate(args, currentUser, false); } if ("visible".equalsIgnoreCase(value)) { return is_visible(); } if ("reviewed".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsReviewedPredicate(); } if ("owner".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.OwnerPredicate(self()); } if ("reviewer".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.ReviewerPredicate(self(), args.allowsDrafts); } if ("mergeable".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsMergeablePredicate(); } try { return status(value); } catch (java.lang.IllegalArgumentException e) { } throw new java.lang.IllegalArgumentException(); }



public java.lang.String getInlineComments(int lines) { java.lang.StringBuilder cmts = new java.lang.StringBuilder(); final org.eclipse.jgit.lib.Repository repo = getRepository(); try { com.google.gerrit.server.patch.PatchList patchList = null; if (repo != null) { try { patchList = getPatchList(); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { patchList = null; } } com.google.gerrit.reviewdb.client.Patch.Key currentFileKey = null; com.google.gerrit.server.patch.PatchFile currentFileData = null; for (final com.google.gerrit.reviewdb.client.PatchLineComment c : inlineComments) { final com.google.gerrit.reviewdb.client.Patch.Key pk = c.getKey().getParentKey(); if (!(pk.equals(currentFileKey))) { java.lang.String link = makeLink(pk); if (link != null) { cmts.append(link).append('\n'); } if (Patch.COMMIT_MSG.equals(pk.get())) { cmts.append("Commit Message:\n\n"); } else { cmts.append("File ").append(pk.get()).append(":\n\n"); } currentFileKey = pk; if (patchList != null) { try { currentFileData = new com.google.gerrit.server.patch.PatchFile(repo, patchList, pk.get()); } catch (java.io.IOException e) { com.google.gerrit.server.mail.CommentSender.log.warn(java.lang.String.format("Cannot load %s from %s in %s", pk.getFileName(), patchList.getNewId().name(), projectState.getProject().getName()), e); currentFileData = null; } } } if (currentFileData != null) { appendComment(cmts, lines, currentFileData, c); } cmts.append("\n\n"); } } finally { if (repo != null) { repo.close(); } } return cmts.toString(); }
public void assertChange(com.google.gerrit.reviewdb.client.Change.Status expectedStatus, java.lang.String expectedTopic, com.google.gerrit.acceptance.TestAccount... expectedReviewers) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = com.google.common.collect.Iterables.getOnlyElement(db.changes().byKey(new com.google.gerrit.reviewdb.client.Change.Key(commit.getChangeId())).toList()); assertEquals(subject, c.getSubject()); assertEquals(expectedStatus, c.getStatus()); assertEquals(expectedTopic, com.google.common.base.Strings.emptyToNull(c.getTopic())); assertReviewers(c, expectedReviewers); }
private void assertResult(com.google.gerrit.acceptance.RestResponse r, java.util.List<java.lang.String> expected) throws java.io.IOException { assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.List<java.lang.String> result = com.google.gerrit.acceptance.rest.change.HashtagsIT.toHashtagList(r); assertEquals(expected, result); }
@org.junit.Test @com.google.gerrit.acceptance.UseLocalDisk public void testGc() throws java.lang.Exception { java.lang.String response = sshSession.exec((((("gerrit gc \"" + (project.get())) + "\" \"") + (project2.get())) + "\"")); assertFalse(sshSession.getError(), sshSession.hasError()); assertNoError(response); gcAssert.assertHasPackFile(project, project2); gcAssert.assertHasNoPackFile(allProjects, project3); }
private void assertNoError(java.lang.String response) { assertFalse(response, response.toLowerCase(java.util.Locale.US).contains("error")); }
@org.junit.Test public void banCommit() throws java.lang.Exception { com.google.gerrit.acceptance.GitUtil.add(git, "a.txt", "some content"); com.google.gerrit.acceptance.GitUtil.Commit c = com.google.gerrit.acceptance.GitUtil.createCommit(git, admin.getIdent(), "subject"); java.lang.String response = sshSession.exec(((("gerrit ban-commit " + (project.get())) + " ") + (c.getCommit().getName()))); assertFalse(sshSession.getError(), sshSession.hasError()); assertFalse(response, response.toLowerCase(java.util.Locale.US).contains("error")); org.eclipse.jgit.transport.PushResult pushResult = com.google.gerrit.acceptance.GitUtil.pushHead(git, "refs/heads/master", false); assertTrue(pushResult.getRemoteUpdate("refs/heads/master").getMessage().startsWith("contains banned commit")); }
private void assertError(java.lang.String expectedError, java.lang.String response) { assertTrue(response, response.contains(expectedError)); }
@org.junit.Test @com.google.gerrit.acceptance.UseLocalDisk public void testGcAll() throws java.lang.Exception { java.lang.String response = sshSession.exec("gerrit gc --all"); assertFalse(sshSession.getError(), sshSession.hasError()); assertNoError(response); gcAssert.assertHasPackFile(allProjects, project, project2, project3); }
private boolean recursiveDelete(java.io.File file) { if (file.isDirectory()) { java.io.File[] contents = file.listFiles(); if (contents == null) { return false; } for (java.io.File f : contents) { if (!(recursiveDelete(f))) { return false; } } } return file.delete(); }

private void deleteGitRepository(final com.google.gerrit.reviewdb.client.Project.NameKey project, final org.eclipse.jgit.lib.Repository repository) throws java.io.IOException { java.io.File parentFile = repository.getDirectory().getParentFile(); if (!(recursiveDelete(repository.getDirectory()))) { throw new java.io.IOException(("Error trying to delete " + (repository.getDirectory().getAbsolutePath()))); } recursiveDeleteParent(parentFile, gitDir); com.google.gerrit.extensions.events.ProjectDeletedListener.Event event = new com.google.gerrit.extensions.events.ProjectDeletedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return project.get(); } }; for (com.google.gerrit.extensions.events.ProjectDeletedListener l : deletedListener) { try { l.onProjectDeleted(event); } catch (java.lang.RuntimeException e) { com.googlesource.gerrit.plugins.deleteproject.fs.FilesystemDeleteHandler.log.warn("Failure in ProjectDeletedListener", e); } } }


@org.junit.Test public void createDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1"); addDraft(changeId, revId, comment); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = getDraftComments(changeId, revId); assertEquals(1, result.size()); com.google.gerrit.extensions.common.CommentInfo actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
@org.junit.Test public void customLabelNoOp_NegativeVoteNotBlock() throws java.lang.Exception { Q.setFunctionName("NoOp"); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); revision(r).review(new com.google.gerrit.extensions.api.changes.ReviewInput().label(Q.getName(), (-1))); ChangeInfo c = get(r.getChangeId()); LabelInfo q = c.labels.get(Q.getName()); assertEquals(1, q.all.size()); assertNotNull(q.rejected); assertNull(q.blocking); }
@org.junit.Test public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws java.lang.Exception { Q.setFunctionName("MaxNoBlock"); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); revision(r).review(new com.google.gerrit.extensions.api.changes.ReviewInput().label(Q.getName(), (-1))); ChangeInfo c = get(r.getChangeId()); LabelInfo q = c.labels.get(Q.getName()); assertEquals(1, q.all.size()); assertNotNull(q.rejected); assertNull(q.blocking); }
@org.junit.Test public void customLabelAnyWithBlock_NegativeVoteBlock() throws java.lang.Exception { Q.setFunctionName("AnyWithBlock"); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); revision(r).review(new com.google.gerrit.extensions.api.changes.ReviewInput().label(Q.getName(), (-1))); ChangeInfo c = get(r.getChangeId()); LabelInfo q = c.labels.get(Q.getName()); assertEquals(1, q.all.size()); assertNull(q.disliked); assertNotNull(q.rejected); assertTrue(q.blocking); }
@org.junit.Test public void customLabelNoBlock_NegativeVoteNotBlock() throws java.lang.Exception { Q.setFunctionName("NoBlock"); saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); revision(r).review(new com.google.gerrit.extensions.api.changes.ReviewInput().label(Q.getName(), (-1))); ChangeInfo c = get(r.getChangeId()); LabelInfo q = c.labels.get(Q.getName()); assertEquals(1, q.all.size()); assertNotNull(q.rejected); assertNull(q.blocking); }
@org.junit.Test public void customLabelMaxWithBlock_NegativeVoteBlock() throws java.lang.Exception { saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); revision(r).review(new com.google.gerrit.extensions.api.changes.ReviewInput().label(Q.getName(), (-1))); ChangeInfo c = get(r.getChangeId()); LabelInfo q = c.labels.get(Q.getName()); assertEquals(1, q.all.size()); assertNull(q.disliked); assertNotNull(q.rejected); assertTrue(q.blocking); }
@org.junit.Test public void deleteDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1"); com.google.gerrit.extensions.common.CommentInfo returned = addDraft(changeId, revId, comment); deleteDraft(changeId, revId, returned.id); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> drafts = getDraftComments(changeId, revId); assertTrue(drafts.isEmpty()); }
@org.junit.Test public void postComment() throws java.lang.Exception { java.lang.String file = "file"; java.lang.String contents = "contents"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); ReviewInput input = new ReviewInput(); ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1"); input.comments = new java.util.HashMap(); input.comments.put(comment.path, Lists.newArrayList(comment)); revision(r).review(input); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = getPublishedComments(changeId, revId); assertTrue((!(result.isEmpty()))); com.google.gerrit.extensions.common.CommentInfo actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
private void doAssertApproval(int expected, ChangeInfo c) { LabelInfo cr = c.labels.get("Code-Review"); assertEquals((-1), ((int) (cr.defaultValue))); assertEquals(1, cr.all.size()); assertEquals("Administrator", cr.all.get(0).name); assertEquals(expected, cr.all.get(0).value.intValue()); }
@org.junit.Test public void retrieveFilesInEdit() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); EditInfo info = toEditInfo(true); assertEquals(2, info.files.size()); java.util.List<java.lang.String> l = com.google.common.collect.Lists.newArrayList(info.files.keySet()); assertEquals("/COMMIT_MSG", l.get(0)); assertEquals("foo", l.get(1)); }
@org.junit.Test public void retrieveEdit() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get(urlEdit()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); EditInfo info = toEditInfo(false); assertEquals(edit.get().getRevision().get(), info.commit.commit); assertEquals(1, info.commit.parents.size()); edit = editUtil.byChange(change); editUtil.delete(edit.get()); r = adminSession.get(urlEdit()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); }
public static void assertBranches(java.util.List<com.google.gerrit.server.project.ListBranches.BranchInfo> expectedBranches, java.util.List<com.google.gerrit.server.project.ListBranches.BranchInfo> actualBranches) { java.util.List<com.google.gerrit.server.project.ListBranches.BranchInfo> missingBranches = com.google.common.collect.Lists.newArrayList(actualBranches); for (final com.google.gerrit.server.project.ListBranches.BranchInfo b : expectedBranches) { com.google.gerrit.server.project.ListBranches.BranchInfo info = com.google.common.collect.Iterables.find(actualBranches, new com.google.common.base.Predicate<com.google.gerrit.server.project.ListBranches.BranchInfo>() { @java.lang.Override public boolean apply(com.google.gerrit.server.project.ListBranches.BranchInfo info) { return info.ref.equals(b.ref); } }, null); assertNotNull(("missing branch: " + (b.ref)), info); com.google.gerrit.acceptance.rest.project.BranchAssert.assertBranchInfo(b, info); missingBranches.remove(info); } assertTrue(("unexpected branches: " + missingBranches), missingBranches.isEmpty()); }
public static void assertProjects(java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> expected, java.util.Collection<com.google.gerrit.extensions.common.ProjectInfo> actual) { for (final com.google.gerrit.reviewdb.client.Project.NameKey p : expected) { com.google.gerrit.extensions.common.ProjectInfo info = com.google.common.collect.Iterables.find(actual, new com.google.common.base.Predicate<com.google.gerrit.extensions.common.ProjectInfo>() { @java.lang.Override public boolean apply(com.google.gerrit.extensions.common.ProjectInfo info) { return new com.google.gerrit.reviewdb.client.Project.NameKey(((info.name) != null ? info.name : com.google.gerrit.extensions.restapi.Url.decode(info.id))).equals(p); } }, null); assertNotNull(("missing project: " + p), info); actual.remove(info); } assertTrue(("unexpected projects: " + actual), actual.isEmpty()); }
public static void assertProjectOwners(java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> expectedOwners, com.google.gerrit.server.project.ProjectState state) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID g : state.getOwners()) { assertTrue(("unexpected owner group " + g), expectedOwners.remove(g)); } assertTrue(("missing owner groups: " + expectedOwners), expectedOwners.isEmpty()); }
@org.junit.Test public void listBranchesUsingFilter() throws java.lang.Exception { pushTo("refs/heads/master"); pushTo("refs/heads/someBranch1"); pushTo("refs/heads/someBranch2"); pushTo("refs/heads/someBranch3"); com.google.gerrit.acceptance.RestResponse r = adminSession.get((("/projects/" + (project.get())) + "/branches?m=some")); java.util.List<com.google.gerrit.server.project.ListBranches.BranchInfo> result = com.google.gerrit.acceptance.rest.project.ListBranchesIT.toBranchInfoList(r); assertEquals(3, result.size()); assertEquals("refs/heads/someBranch1", result.get(0).ref); assertEquals("refs/heads/someBranch2", result.get(1).ref); assertEquals("refs/heads/someBranch3", result.get(2).ref); r = adminSession.get((("/projects/" + (project.get())) + "/branches?m=Branch")); result = com.google.gerrit.acceptance.rest.project.ListBranchesIT.toBranchInfoList(r); assertEquals(3, result.size()); assertEquals("refs/heads/someBranch1", result.get(0).ref); assertEquals("refs/heads/someBranch2", result.get(1).ref); assertEquals("refs/heads/someBranch3", result.get(2).ref); r = adminSession.get((("/projects/" + (project.get())) + "/branches?r=.*ast.*r")); result = com.google.gerrit.acceptance.rest.project.ListBranchesIT.toBranchInfoList(r); assertEquals(1, result.size()); assertEquals("refs/heads/master", result.get(0).ref); }
@org.junit.Test public void banCommit() throws java.lang.Exception { com.google.gerrit.acceptance.GitUtil.add(git, "a.txt", "some content"); com.google.gerrit.acceptance.GitUtil.Commit c = com.google.gerrit.acceptance.GitUtil.createCommit(git, admin.getIdent(), "subject"); com.google.gerrit.acceptance.RestResponse r = adminSession.put((("/projects/" + (project.get())) + "/ban/"), BanCommit.Input.fromCommits(c.getCommit().getName())); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); com.google.gerrit.server.project.BanCommit.BanResultInfo info = newGson().fromJson(r.getReader(), com.google.gerrit.server.project.BanCommit.BanResultInfo.class); assertEquals(c.getCommit().getName(), com.google.common.collect.Iterables.getOnlyElement(info.newlyBanned)); assertNull(info.alreadyBanned); assertNull(info.ignored); org.eclipse.jgit.transport.PushResult pushResult = com.google.gerrit.acceptance.GitUtil.pushHead(git, "refs/heads/master", false); assertTrue(pushResult.getRemoteUpdate("refs/heads/master").getMessage().startsWith("contains banned commit")); }
@org.junit.Test public void listProjectsWithBranch() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = GET("/projects/?b=master"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ProjectInfo> result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertNotNull(result.get(project.get())); assertNotNull(result.get(project.get()).branches); assertEquals(1, result.get(project.get()).branches.size()); assertNotNull(result.get(project.get()).branches.get("master")); }
@org.junit.Test public void listProjectsWithLimit() throws java.lang.Exception { for (int i = 0; i < 5; i++) { com.google.gerrit.acceptance.GitUtil.createProject(sshSession, new com.google.gerrit.reviewdb.client.Project.NameKey(("someProject" + i)).get()); } com.google.gerrit.acceptance.RestResponse r = GET("/projects/"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ProjectInfo> result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(7, result.size()); r = GET("/projects/?n=2"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(2, result.size()); }
@org.junit.Test public void listProjectWithType() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = GET("/projects/?type=PERMISSIONS"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ProjectInfo> result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(1, result.size()); assertNotNull(result.get(allProjects.get())); r = GET("/projects/?type=ALL"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(3, result.size()); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjects(java.util.Arrays.asList(allProjects, allUsers, project), result.values()); }
@org.junit.Test public void listProjectsWithSkip() throws java.lang.Exception { for (int i = 0; i < 5; i++) { com.google.gerrit.acceptance.GitUtil.createProject(sshSession, new com.google.gerrit.reviewdb.client.Project.NameKey(("someProject" + i)).get()); } com.google.gerrit.acceptance.RestResponse r = GET("/projects/"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ProjectInfo> result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(7, result.size()); r = GET("/projects/?S=6"); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); result = com.google.gerrit.acceptance.rest.project.ListProjectsIT.toProjectInfoMap(r); assertEquals(1, result.size()); }
@org.junit.Test public void listNoChildren() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = GET((("/projects/" + (allProjects.get())) + "/children/")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); java.util.List<com.google.gerrit.extensions.common.ProjectInfo> projectInfoList = com.google.gerrit.acceptance.rest.project.ListChildProjectsIT.toProjectInfoList(r); assertTrue(((projectInfoList.size()) == 2)); }
private void assertMergeCommit(java.lang.String branch, java.lang.String subject) throws java.io.IOException { org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r); try { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(r.getRef(branch).getObjectId()); assertEquals(2, c.getParentCount()); assertEquals((("Merge \"" + subject) + "\""), c.getShortMessage()); assertEquals(admin.email, c.getAuthorIdent().getEmailAddress()); assertEquals(serverIdent.getEmailAddress(), c.getCommitterIdent().getEmailAddress()); } finally { rw.release(); } } finally { r.close(); } }
@org.junit.Test public void submitOnPushNewPatchSet() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content"); grant(Permission.SUBMIT, project, "refs/for/refs/heads/master"); r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId()); r.assertOkStatus(); r.assertChange(Change.Status.MERGED, null, admin); com.google.gerrit.reviewdb.client.Change c = com.google.common.collect.Iterables.getOnlyElement(db.changes().byKey(new com.google.gerrit.reviewdb.client.Change.Key(r.getChangeId())).toList()); assertEquals(2, db.patchSets().byChange(c.getId()).toList().size()); assertSubmitApproval(r.getPatchSetId()); assertCommit(project, "refs/heads/master"); }
@org.junit.Test public void testPushForMasterWithApprovals() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review"); r.assertOkStatus(); ChangeInfo ci = get(r.getChangeId()); LabelInfo cr = ci.labels.get("Code-Review"); assertEquals(1, cr.all.size()); assertEquals("Administrator", cr.all.get(0).name); assertEquals(1, cr.all.get(0).value.intValue()); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to(git, "refs/for/master/%l=Code-Review+2"); ci = get(r.getChangeId()); cr = ci.labels.get("Code-Review"); assertEquals(1, cr.all.size()); assertEquals("Administrator", cr.all.get(0).name); assertEquals(2, cr.all.get(0).value.intValue()); }

@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.Change> changes = findChanges(id.encoded()); if ((changes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.project.ChangeControl control; try { control = changeControlFactory.validateFor(changes.get(0), user.get()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.change.ChangeResource(control); }


@org.junit.Test public void getFileContentRest() throws java.lang.Exception { com.google.gerrit.server.change.ChangeEdits.Put.Input in = new com.google.gerrit.server.change.ChangeEdits.Put.Input(); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, adminSession.putRaw(urlEditFile(), in.content).getStatusCode()); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); edit = editUtil.byChange(change); com.google.gerrit.acceptance.RestResponse r = adminSession.get(urlEditFile()); assertEquals(com.google.gerrit.acceptance.edit.SC_OK, r.getStatusCode()); java.lang.String content = r.getEntityContent(); assertEquals(org.apache.commons.codec.binary.StringUtils.newStringUtf8(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2), org.apache.commons.codec.binary.StringUtils.newStringUtf8(org.apache.commons.codec.binary.Base64.decodeBase64(content))); }
@org.junit.Test public void deleteEditRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); com.google.gerrit.acceptance.RestResponse r = adminSession.delete(urlEdit()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); }
@org.junit.Test public void deleteEdit() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); editUtil.delete(editUtil.byChange(change).get()); assertFalse(editUtil.byChange(change).isPresent()); }
@org.junit.Test public void addNewFile() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2))); }
@org.junit.Test public void publishEdit() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId))); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); editUtil.publish(editUtil.byChange(change).get()); assertFalse(editUtil.byChange(change).isPresent()); }
@org.junit.Test public void publishEditRest() throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId); assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); com.google.gerrit.acceptance.RestResponse r = adminSession.post(urlPublish()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); com.google.gerrit.reviewdb.client.PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId); assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId())); }
@org.junit.Test public void amendExistingFile() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME))); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME))); }
@org.junit.Test public void rebaseEdit() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); com.google.gerrit.server.edit.ChangeEdit edit = editUtil.byChange(change).get(); com.google.gerrit.reviewdb.client.PatchSet current = getCurrentPatchSet(changeId); assertEquals(((current.getPatchSetId()) - 1), edit.getBasePatchSet().getPatchSetId()); java.util.Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen(); modifier.rebaseEdit(edit, current); edit = editUtil.byChange(change).get(); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME))); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2))); assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId()); java.util.Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen(); assertFalse(beforeRebase.equals(afterRebase)); }
@org.junit.Test public void retrieveEdit() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get(urlEdit()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); EditInfo info = toEditInfo(false); assertEquals(edit.get().getRevision().get(), info.commit.commit); assertEquals(1, info.commit.parents.size()); edit = editUtil.byChange(change); editUtil.delete(edit.get()); r = adminSession.get(urlEdit()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); }
@org.junit.Test public void addNewFileAndAmend() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2))); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2))); }
@org.junit.Test public void rebaseEditRest() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); com.google.gerrit.server.edit.ChangeEdit edit = editUtil.byChange(change).get(); com.google.gerrit.reviewdb.client.PatchSet current = getCurrentPatchSet(changeId); assertEquals(((current.getPatchSetId()) - 1), edit.getBasePatchSet().getPatchSetId()); java.util.Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen(); com.google.gerrit.acceptance.RestResponse r = adminSession.post(urlRebase()); assertEquals(com.google.gerrit.acceptance.edit.SC_NO_CONTENT, r.getStatusCode()); edit = editUtil.byChange(change).get(); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME))); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.getChange().getProject(), edit.getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2))); assertEquals(current.getPatchSetId(), edit.getBasePatchSet().getPatchSetId()); java.util.Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen(); assertFalse(beforeRebase.equals(afterRebase)); }
@org.junit.Test public void retrieveFilesInEdit() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); EditInfo info = toEditInfo(true); assertEquals(2, info.files.size()); java.util.List<java.lang.String> l = com.google.common.collect.Lists.newArrayList(info.files.keySet()); assertEquals("/COMMIT_MSG", l.get(0)); assertEquals("foo", l.get(1)); }
@org.junit.Test public void writeNoChanges() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); try { modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD); fail(); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { assertEquals("no changes were made", e.getMessage()); } }
@org.junit.Test public void updateExistingFile() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW)); edit = editUtil.byChange(change); assertArrayEquals(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW, com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME))); editUtil.delete(edit.get()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); }
public java.util.List<java.util.Map<java.lang.String, java.lang.String>> linkify(javax.servlet.http.HttpServletRequest req, java.lang.String message) { java.lang.String baseGerritUrl = urls.getBaseGerritUrl(req); java.util.List<java.util.Map<java.lang.String, java.lang.String>> parsed = com.google.common.collect.Lists.newArrayList(); java.util.regex.Matcher m = com.google.gitiles.Linkifier.LINK_PATTERN.matcher(message); int last = 0; while (m.find()) { com.google.gitiles.Linkifier.addText(parsed, message.substring(last, m.start())); if ((m.group(1)) != null) { parsed.add(com.google.gitiles.Linkifier.link(m.group(1), m.group(1))); } else if ((m.group(2)) != null) { if (baseGerritUrl != null) { parsed.add(com.google.gitiles.Linkifier.link(m.group(2), (((baseGerritUrl + "#/q/") + (m.group(2))) + ",n,z"))); } else { com.google.gitiles.Linkifier.addText(parsed, m.group(2)); } } last = m.end(); } com.google.gitiles.Linkifier.addText(parsed, message.substring(last)); return parsed; }

@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection globalCfg, java.lang.String raw) throws java.io.UnsupportedEncodingException { com.googlesource.gerrit.plugins.xdocs.ConfigSection projectCfg = formatters.getFormatterConfig(globalCfg.getSubsection(), projectName); com.google.gerrit.server.documentation.MarkdownFormatter f = new com.google.gerrit.server.documentation.MarkdownFormatter(); if (!(globalCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_ALLOW_HTML, false))) { f.suppressHtml(); } java.lang.String projectCss = util.getCss(projectName, "markdown"); if (projectCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_APPEND_CSS, true)) { byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return util.insertCss(new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8), projectCss); } else { f.setCss(projectCss); byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8); } }
@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection globalCfg, java.lang.String raw) throws java.io.IOException { com.googlesource.gerrit.plugins.xdocs.ConfigSection projectCfg = formatters.getFormatterConfig(globalCfg.getSubsection(), projectName); com.google.gerrit.server.documentation.MarkdownFormatter f = new com.google.gerrit.server.documentation.MarkdownFormatter(); if (!(globalCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_ALLOW_HTML, false))) { f.suppressHtml(); } java.lang.String globalCss = util.getGlobalCss("markdown"); f.setCss(globalCss); java.lang.String projectCss = util.getCss(projectName, "markdown"); if (projectCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_APPEND_CSS, true)) { byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return util.insertCss(new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8), projectCss); } else { if (projectCss != null) { f.setCss(projectCss); } byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8); } }

private void setMerged(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.ChangeMessage msg) throws com.google.gwtorm.server.OrmException, java.io.IOException { logDebug("Setting change {} merged", c.getId()); com.google.gerrit.server.notedb.ChangeUpdate update = null; try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id merged = commit.change().currentPatchSetId(); c = setMergedPatchSet(c.getId(), merged); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged); com.google.gerrit.server.project.ChangeControl control = commit.getControl(); update = updateFactory.create(control, c.getLastUpdatedOn()); if (msg != null) { cmUtil.addChangeMessage(db, update, msg); } db.commit(); sendMergedEmail(c, submitter); indexer.index(db, c); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db); } catch (com.google.gwtorm.server.OrmException ex) { logError(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } } finally { db.rollback(); } indexer.index(db, c); update.commit(); }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = com.google.common.collect.Lists.newLinkedList(); try { for (final com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.get().accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, com.google.gerrit.common.TimeUtil.nowTs()); auditUpdates.add(audit); } } db.get().accountGroupByIdAud().update(auditUpdates); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e); } }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = com.google.common.collect.Lists.newLinkedList(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = com.google.common.collect.Lists.newLinkedList(); com.google.gerrit.reviewdb.server.ReviewDb reviewDB = db.get(); try { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : reviewDB.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, com.google.gerrit.common.TimeUtil.nowTs()); auditUpdates.add(audit); } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, com.google.gerrit.common.TimeUtil.nowTs()); audit.removedLegacy(); auditInserts.add(audit); } } reviewDB.accountGroupMembersAudit().update(auditUpdates); reviewDB.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e); } }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, com.google.gerrit.common.TimeUtil.nowTs()); includesAudit.add(audit); } try { db.get().accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e); } }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = com.google.common.collect.Lists.newLinkedList(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, com.google.gerrit.common.TimeUtil.nowTs()); auditInserts.add(audit); } try { db.get().accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e); } }

public com.google.gerrit.httpd.resources.Resource get(com.googlesource.gerrit.plugins.xdocs.formatter.Formatters.FormatterProvider formatter, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String file, org.eclipse.jgit.lib.ObjectId revId) { com.google.gerrit.server.project.ProjectState p = projectCache.get(project); org.eclipse.jgit.lib.ObjectId metaConfigRevId = (p != null) ? p.getConfig().getRevision() : null; return cache.getUnchecked(new com.googlesource.gerrit.plugins.xdocs.XDocResourceKey(formatter.getName(), project, file, revId, metaConfigRevId).asString()); }














@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitUploadPackGroups.class).toProvider(com.google.gerrit.server.config.GitUploadPackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitReceivePackGroups.class).toProvider(com.google.gerrit.server.config.GitReceivePackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); factory(ChangeControl.AssistedFactory.class); factory(ProjectControl.AssistedFactory.class); }
public com.google.gerrit.server.project.ProjectControl user(com.google.gerrit.server.git.ProjectConfig local, java.lang.String name, com.google.gerrit.reviewdb.client.AccountGroup... memberOf) { java.lang.String canonicalWebUrl = "http://localhost"; return new com.google.gerrit.server.project.ProjectControl(java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(), projectCache, sectionSorter, repoManager, changeControlFactory, null, null, canonicalWebUrl, new com.google.gerrit.server.project.Util.MockUser(name, memberOf), newProjectState(local)); }


@org.junit.Test public void testCapabilitiesUser() throws java.lang.Exception { grantAllCapabilities(); com.google.gerrit.acceptance.RestResponse r = userSession.get("/accounts/self/capabilities"); int code = r.getStatusCode(); assertEquals(code, 200); com.google.gerrit.acceptance.rest.account.CapabilityInfo info = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.account.CapabilityInfo>() {}.getType()); for (java.lang.String c : com.google.gerrit.common.data.GlobalCapability.getAllNames()) { if (com.google.gerrit.acceptance.rest.account.ADMINISTRATE_SERVER.equals(c)) { assertFalse(info.administrateServer); } else if (com.google.gerrit.acceptance.rest.account.PRIORITY.equals(c)) { assertFalse(info.priority); } else if (com.google.gerrit.acceptance.rest.account.QUERY_LIMIT.equals(c)) { assertEquals(0, info.queryLimit.min); assertEquals(0, info.queryLimit.max); } else { assertTrue(java.lang.String.format("capability %s was not granted", c), ((java.lang.Boolean) (com.google.gerrit.acceptance.rest.account.CapabilityInfo.class.getField(c).get(info)))); } } }
private void grantAllCapabilities() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allProjects); md.setMessage("Make super user"); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection s = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES); for (java.lang.String c : com.google.gerrit.common.data.GlobalCapability.getAllNames()) { if (com.google.gerrit.acceptance.rest.account.ADMINISTRATE_SERVER.equals(c)) { continue; } com.google.gerrit.common.data.Permission p = s.getPermission(c, true); p.add(new com.google.gerrit.common.data.PermissionRule(config.resolve(com.google.gerrit.server.group.SystemGroupBackend.getGroup(SystemGroupBackend.REGISTERED_USERS)))); } config.commit(md); projectCache.evict(config.getProject()); }
@org.junit.Test public void testCapabilitiesUser() throws java.lang.Exception { grantAllCapabilitiesExceptAdministrateServerAndPriority(); com.google.gerrit.acceptance.RestResponse r = userSession.get("/accounts/self/capabilities"); int code = r.getStatusCode(); assertEquals(code, 200); com.google.gerrit.acceptance.rest.account.CapabilityInfo info = new com.google.gson.Gson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.acceptance.rest.account.CapabilityInfo>() {}.getType()); for (java.lang.String c : com.google.gerrit.common.data.GlobalCapability.getAllNames()) { if (com.google.gerrit.acceptance.rest.account.ADMINISTRATE_SERVER.equals(c)) { assertFalse(info.administrateServer); } else if (com.google.gerrit.acceptance.rest.account.PRIORITY.equals(c)) { assertFalse(info.priority); } else if (com.google.gerrit.acceptance.rest.account.QUERY_LIMIT.equals(c)) { assertEquals(0, info.queryLimit.min); assertEquals(com.google.gerrit.acceptance.rest.account.DEFAULT_MAX_QUERY_LIMIT, info.queryLimit.max); } else { assertTrue(java.lang.String.format("capability %s was not granted", c), ((java.lang.Boolean) (com.google.gerrit.acceptance.rest.account.CapabilityInfo.class.getField(c).get(info)))); } } }


static boolean needsQuotedPrintable(java.lang.String value) { for (int i = 0; i < (value.length()); i++) { if (((value.charAt(i)) < ' ') || ('~' < (value.charAt(i)))) { return true; } } return false; }





@java.lang.Override protected void configure() { bind(com.google.gerrit.server.config.SitePaths.class); bind(com.google.gerrit.pgm.init.api.InitFlags.class); bind(com.google.gerrit.pgm.init.Libraries.class); bind(com.google.gerrit.pgm.init.LibraryDownloader.class); factory(Section.Factory.class); step().to(com.google.gerrit.pgm.init.UpgradeFrom2_0_x.class); step().to(com.google.gerrit.pgm.init.InitGitManager.class); if (initDb) { step().to(com.google.gerrit.pgm.init.InitDatabase.class); } step().to(com.google.gerrit.pgm.init.InitIndex.class); step().to(com.google.gerrit.pgm.init.InitAuth.class); step().to(com.google.gerrit.pgm.init.InitLabels.class); step().to(com.google.gerrit.pgm.init.InitSendEmail.class); if (standalone) { step().to(com.google.gerrit.pgm.init.InitContainer.class); } step().to(com.google.gerrit.pgm.init.InitSshd.class); step().to(com.google.gerrit.pgm.init.InitHttpd.class); step().to(com.google.gerrit.pgm.init.InitCache.class); step().to(com.google.gerrit.pgm.init.InitPlugins.class); }

@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String revision, com.googlesource.gerrit.plugins.xdocs.ConfigSection globalCfg, java.lang.String raw) throws java.io.IOException { com.googlesource.gerrit.plugins.xdocs.ConfigSection projectCfg = formatters.getFormatterConfig(globalCfg.getSubsection(), projectName); com.google.gerrit.server.documentation.MarkdownFormatter f = new com.google.gerrit.server.documentation.MarkdownFormatter(); if (!(globalCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_ALLOW_HTML, false))) { f.suppressHtml(); } java.lang.String cssTheme = projectCfg.getString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_CSS_THEME); java.lang.String globalCss = util.getGlobalCss("markdown", cssTheme); java.lang.String projectCss = util.getCss(projectName, "markdown", cssTheme); if (projectCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_APPEND_CSS, true)) { f.setCss(globalCss); byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return util.insertCss(new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8), projectCss); } else { if (projectCss != null) { f.setCss(projectCss); } else { f.setCss(globalCss); } byte[] b = f.markdownToDocHtml(raw, java.nio.charset.StandardCharsets.UTF_8.name()); return new java.lang.String(b, java.nio.charset.StandardCharsets.UTF_8); } }

private java.util.Collection<T> attemptUpdateAsBatch(final java.lang.Iterable<T> instances) throws com.google.gwtorm.server.OrmException { java.util.Collection<T> inserts = null; try { java.sql.PreparedStatement ps = null; try { int cnt = 0; java.util.List<T> allInstances = new java.util.ArrayList<>(); for (final T o : instances) { if (ps == null) { ps = schema.getConnection().prepareStatement(getUpdateOneSql()); } bindOneUpdate(ps, o); ps.addBatch(); allInstances.add(o); cnt++; } if (0 < cnt) { final int[] states = ps.executeBatch(); if (states == null) { inserts = allInstances; } else { int i = 0; for (T o : allInstances) { if (((states.length) <= i) || ((states[i]) != 1)) { if (inserts == null) { inserts = new java.util.ArrayList<>((cnt - i)); } inserts.add(o); } i++; } } } } finally { if (ps != null) { ps.close(); } } } catch (java.sql.SQLException e) { throw convertError("update", e); } return inserts; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo> m) { files.set((base != null ? new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, base._number()) : null), new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), style, editMessage, reply, ((edit) != null)); files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { onReply(null); } else { com.google.gerrit.client.Gerrit.doSignIn(getToken()); } }
private void initEditMessageAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = info.revision(revision).actions(); if ((actions != null) && (actions.containsKey("message"))) { editMessage.setVisible(true); editMessageAction = new com.google.gerrit.client.change.EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply); keysAction.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 'e', Util.C.keyEditMessage()) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { editMessageAction.onEdit(); } }); } }
@com.google.gwt.uibinder.client.UiHandler("reply") void onReply(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { onReply(); }
private void initEditMode(com.google.gerrit.client.changes.ChangeInfo info) { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revision(revision); if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); editFileAction = new com.google.gerrit.client.change.EditFileAction(new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, ((edit) == null ? rev._number() : 0)), "", "", style, editMessage, reply); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } } }


private void recreatePK(com.google.gwtorm.server.StatementExecutor executor, java.lang.String tableName, java.util.List<java.lang.String> cols) throws com.google.gwtorm.server.OrmException { try { if ((dialect) instanceof com.google.gwtorm.schema.sql.DialectPostgreSQL) { executor.execute((((("ALTER TABLE " + tableName) + " DROP CONSTRAINT ") + tableName) + "_pkey")); } else { executor.execute((("ALTER TABLE " + tableName) + " DROP PRIMARY KEY")); } } catch (com.google.gwtorm.server.OrmException ignore) { ui.message("WARN: %s\n", ignore.getMessage()); } executor.execute((((("ALTER TABLE " + tableName) + " ADD PRIMARY KEY(") + (com.google.common.base.Joiner.on(",").join(cols))) + ")")); }



@org.junit.Test public void updateMessage() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps)); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); try { modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage()); fail("Exception expected"); } catch (com.google.gerrit.server.project.InvalidChangeOperationException ex) { assertEquals(ex.getMessage(), "New commit message cannot be same as existing commit message"); } java.lang.String msg = java.lang.String.format("New commit message\n\nChange-Id: %s", change.getKey()); assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg)); edit = editUtil.byChange(change); assertEquals(msg, edit.get().getEditCommit().getFullMessage()); editUtil.delete(edit.get()); edit = editUtil.byChange(change); assertFalse(edit.isPresent()); }



@com.google.gwt.uibinder.client.UiHandler("save") void onSave(com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeFileApi.putContent(id, file.getText(), content.getText(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(id.getParentKey())); hide(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }




@java.lang.SuppressWarnings({ "rawtypes", "unchecked" }) protected java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> query(com.google.gerrit.server.query.change.QueryChanges q) throws java.lang.Exception { java.lang.Object result = q.apply(com.google.gerrit.server.query.change.AbstractQueryChangesTest.TLR); assertTrue(java.lang.String.format("expected List<ChangeInfo>, found %s for [%s]", result, q.getQuery(0)), (result instanceof java.util.List)); java.util.List results = ((java.util.List) (result)); if (!(results.isEmpty())) { assertTrue(java.lang.String.format("expected ChangeInfo, found %s for [%s]", result, q.getQuery(0)), ((results.get(0)) instanceof com.google.gerrit.server.change.ChangeJson.ChangeInfo)); } return ((java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo>) (result)); }
protected com.google.gerrit.server.change.ChangeJson.ChangeInfo queryOne(java.lang.Object query) throws java.lang.Exception { java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results = query(query); assertTrue(java.lang.String.format("expected singleton List<ChangeInfo>, found %s for [%s]", results, query), ((results.size()) == 1)); return results.get(0); }
@org.junit.Test public void byOwnerIn() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = newChange(repo, null, null, userId.get(), null).insert(); int user2 = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("anotheruser")).getAccountId().get(); com.google.gerrit.reviewdb.client.Change change2 = newChange(repo, null, null, user2, null).insert(); assertResultEquals(change1, queryOne("ownerin:Administrators")); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results = query("ownerin:\"Registered Users\""); assertEquals(results.toString(), 2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
protected void assertResultEquals(com.google.gerrit.reviewdb.client.Change expected, com.google.gerrit.server.change.ChangeJson.ChangeInfo actual) { assertEquals(expected.getId().get(), actual._number); }
@org.junit.Test public void byBefore() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = newChange(repo, null, null, null, null).insert(); com.google.gerrit.reviewdb.client.Change change2 = newChange(repo, null, null, null, null).insert(); clockStepMs = 0; assertTrue(query("before:2009-09-29").isEmpty()); assertTrue(query("before:2009-09-30").isEmpty()); assertTrue(query("before:\"2009-09-30 16:59:00 -0400\"").isEmpty()); assertTrue(query("before:\"2009-09-30 20:59:00 -0000\"").isEmpty()); assertTrue(query("before:\"2009-09-30 20:59:00\"").isEmpty()); assertResultEquals(change1, queryOne("before:\"2009-09-30 17:02:00 -0400\"")); assertResultEquals(change1, queryOne("before:\"2009-10-01 21:02:00 -0000\"")); assertResultEquals(change1, queryOne("before:\"2009-10-01 21:02:00\"")); assertResultEquals(change1, queryOne("before:2009-10-01")); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("before:2009-10-03"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
@org.junit.Test public void byHashtagWithNotedb() throws java.lang.Exception { assumeTrue(notesMigration.enabled()); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = setUpHashtagChanges(); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results = query("hashtag:foo"); assertEquals(2, results.size()); assertResultEquals(changes.get(1), results.get(0)); assertResultEquals(changes.get(0), results.get(1)); assertResultEquals(changes.get(1), queryOne("hashtag:bar")); assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag\"")); assertResultEquals(changes.get(1), queryOne("hashtag:\"a tag \"")); assertResultEquals(changes.get(1), queryOne("hashtag:\" a tag \"")); assertResultEquals(changes.get(1), queryOne("hashtag:\"#a tag\"")); assertResultEquals(changes.get(1), queryOne("hashtag:\"# #a tag\"")); }
@org.junit.Test public void updateOrder() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(2, java.util.concurrent.TimeUnit.MINUTES); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); java.util.List<com.google.gerrit.server.change.ChangeInserter> inserters = com.google.common.collect.Lists.newArrayList(); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = com.google.common.collect.Lists.newArrayList(); for (int i = 0; i < 5; i++) { inserters.add(newChange(repo, null, null, null, null)); changes.add(inserters.get(i).insert()); } for (int i : com.google.common.collect.ImmutableList.of(2, 0, 1, 4, 3)) { com.google.gerrit.extensions.api.changes.ReviewInput input = new com.google.gerrit.extensions.api.changes.ReviewInput(); input.message = "modifying " + i; postReview.apply(new com.google.gerrit.server.change.RevisionResource(this.changes.parse(changes.get(i).getId()), inserters.get(i).getPatchSet()), input); changes.set(i, db.changes().get(changes.get(i).getId())); } java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results = query("status:new"); assertEquals(5, results.size()); assertResultEquals(changes.get(3), results.get(0)); assertResultEquals(changes.get(4), results.get(1)); assertResultEquals(changes.get(1), results.get(2)); assertResultEquals(changes.get(0), results.get(3)); assertResultEquals(changes.get(2), results.get(4)); }
@org.junit.Test public void byStatusClosed() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.MERGED); ins1.insert(); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.ABANDONED); ins2.insert(); com.google.gerrit.server.change.ChangeInserter ins3 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change3 = ins3.getChange(); change3.setStatus(Change.Status.NEW); ins3.insert(); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("status:closed"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); assertEquals(2, query("status:CLOSED").size()); assertEquals(2, query("status:c").size()); assertEquals(2, query("status:cl").size()); assertEquals(2, query("status:clo").size()); assertEquals(2, query("status:clos").size()); assertEquals(2, query("status:close").size()); assertEquals(2, query("status:closed").size()); results = query("is:closed"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
@org.junit.Test public void start() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = com.google.common.collect.Lists.newArrayList(); for (int i = 0; i < 2; i++) { changes.add(newChange(repo, null, null, null, null).insert()); } com.google.gerrit.server.query.change.QueryChanges q; java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("status:new"); assertEquals(2, results.size()); assertResultEquals(changes.get(1), results.get(0)); assertResultEquals(changes.get(0), results.get(1)); q = newQuery("status:new"); q.setStart(1); results = query(q); assertEquals(1, results.size()); assertResultEquals(changes.get(0), results.get(0)); q = newQuery("status:new"); q.setStart(2); results = query(q); assertEquals(0, results.size()); q = newQuery("status:new"); q.setStart(3); results = query(q); assertEquals(0, results.size()); }
@org.junit.Test public void byAfter() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = newChange(repo, null, null, null, null).insert(); com.google.gerrit.reviewdb.client.Change change2 = newChange(repo, null, null, null, null).insert(); clockStepMs = 0; assertTrue(query("after:2009-10-03").isEmpty()); assertResultEquals(change2, queryOne("after:\"2009-10-01 20:59:59 -0400\"")); assertResultEquals(change2, queryOne("after:\"2009-10-01 20:59:59 -0000\"")); assertResultEquals(change2, queryOne("after:2009-10-01")); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("after:2009-09-30"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
@org.junit.Test public void byAge() throws java.lang.Exception { long thirtyHours = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); clockStepMs = thirtyHours; org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = newChange(repo, null, null, null, null).insert(); com.google.gerrit.reviewdb.client.Change change2 = newChange(repo, null, null, null, null).insert(); clockStepMs = 0; long now = com.google.gerrit.common.TimeUtil.nowMs(); assertEquals(thirtyHours, ((com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)) - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)))); assertEquals(thirtyHours, (now - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)))); assertEquals(now, com.google.gerrit.common.TimeUtil.nowMs()); assertTrue(query("-age:1d").isEmpty()); assertTrue(query((("-age:" + ((30 * 60) - 1)) + "m")).isEmpty()); assertResultEquals(change2, queryOne("-age:2d")); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("-age:3d"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); assertTrue(query("age:3d").isEmpty()); assertResultEquals(change1, queryOne("age:2d")); results = query("age:1d"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
protected void assertResultEquals(java.lang.String message, com.google.gerrit.reviewdb.client.Change expected, com.google.gerrit.server.change.ChangeJson.ChangeInfo actual) { assertEquals(message, expected.getId().get(), actual._number); }
@org.junit.Test public void startWithLimit() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = com.google.common.collect.Lists.newArrayList(); for (int i = 0; i < 3; i++) { changes.add(newChange(repo, null, null, null, null).insert()); } com.google.gerrit.server.query.change.QueryChanges q; java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("status:new limit:2"); assertEquals(2, results.size()); assertResultEquals(changes.get(2), results.get(0)); assertResultEquals(changes.get(1), results.get(1)); q = newQuery("status:new limit:2"); q.setStart(1); results = query(q); assertEquals(2, results.size()); assertResultEquals(changes.get(1), results.get(0)); assertResultEquals(changes.get(0), results.get(1)); q = newQuery("status:new limit:2"); q.setStart(2); results = query(q); assertEquals(1, results.size()); assertResultEquals(changes.get(0), results.get(0)); q = newQuery("status:new limit:2"); q.setStart(3); results = query(q); assertEquals(0, results.size()); }
@org.junit.Test public void byStatusOpen() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.NEW); ins1.insert(); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.DRAFT); ins2.insert(); com.google.gerrit.server.change.ChangeInserter ins3 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change3 = ins3.getChange(); change3.setStatus(Change.Status.MERGED); ins3.insert(); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("status:open"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); assertEquals(2, query("status:OPEN").size()); assertEquals(2, query("status:o").size()); assertEquals(2, query("status:op").size()); assertEquals(2, query("status:ope").size()); assertEquals(2, query("status:pending").size()); assertEquals(2, query("status:PENDING").size()); assertEquals(2, query("status:p").size()); assertEquals(2, query("status:pe").size()); assertEquals(2, query("status:pen").size()); results = query("is:open"); assertEquals(2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
@org.junit.Test public void byProjectPrefix() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo1 = createProject("repo1"); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo2 = createProject("repo2"); com.google.gerrit.reviewdb.client.Change change1 = newChange(repo1, null, null, null, null).insert(); com.google.gerrit.reviewdb.client.Change change2 = newChange(repo2, null, null, null, null).insert(); assertTrue(query("projects:foo").isEmpty()); assertResultEquals(change1, queryOne("projects:repo1")); assertResultEquals(change2, queryOne("projects:repo2")); java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; results = query("projects:repo"); assertEquals(results.toString(), 2, results.size()); assertResultEquals(change2, results.get(0)); assertResultEquals(change1, results.get(1)); }
@org.junit.Test public void limit() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change last = null; int n = 5; for (int i = 0; i < n; i++) { last = newChange(repo, null, null, null, null).insert(); } java.util.List<com.google.gerrit.server.change.ChangeJson.ChangeInfo> results; for (int i = 1; i <= (n + 2); i++) { results = query(("status:new limit:" + i)); assertEquals(java.lang.Math.min(i, n), results.size()); assertResultEquals(last, results.get(0)); } }

public RefUpdate.Result modifyMessage(com.google.gerrit.server.edit.ChangeEdit edit, java.lang.String msg) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { checkState((!(com.google.common.base.Strings.isNullOrEmpty(msg))), "message cannot be null"); if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (currentUser.get())); org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(edit.getChange().getProject()); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter(); try { java.lang.String refName = edit.getRefName(); org.eclipse.jgit.revwalk.RevCommit prevEdit = edit.getEditCommit(); if ((prevEdit.getParentCount()) == 0) { throw new com.google.gerrit.server.project.InvalidChangeOperationException("Modify edit against root commit not implemented"); } if (prevEdit.getFullMessage().equals(msg)) { throw new com.google.gerrit.server.project.InvalidChangeOperationException("New commit message cannot be same as existing commit message"); } org.eclipse.jgit.lib.ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg); inserter.flush(); return update(repo, me, refName, rw, prevEdit, commit); } finally { rw.release(); inserter.release(); } } finally { repo.close(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeEditResource rsrc, com.google.gerrit.server.change.ChangeEdits.Put.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { try { editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), com.google.common.io.ByteStreams.toByteArray(input.content.getInputStream())); } catch (com.google.gerrit.server.project.InvalidChangeOperationException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (!(edit.isPresent())) { editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId())); edit = editUtil.byChange(rsrc.getChange()); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.message))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("commit message must be provided"); } editModifier.modifyMessage(edit.get(), input.message); return com.google.gerrit.extensions.restapi.Response.none(); }
@org.junit.Test public void updateMessage() throws java.lang.Exception { assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId))); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); try { modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage()); fail("InvalidChangeOperationException expected"); } catch (com.google.gerrit.server.project.InvalidChangeOperationException ex) { assertEquals(ex.getMessage(), "New commit message cannot be same as existing commit message"); } java.lang.String msg = java.lang.String.format("New commit message\n\nChange-Id: %s", change.getKey()); assertEquals(RefUpdate.Result.FORCED, modifier.modifyMessage(edit.get(), msg)); edit = editUtil.byChange(change); assertEquals(msg, edit.get().getEditCommit().getFullMessage()); editUtil.publish(edit.get()); assertFalse(editUtil.byChange(change).isPresent()); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertEquals(msg, info.revisions.get(info.currentRevision).commit.message); }
@org.junit.Test public void testPersonByNameAge() throws java.lang.Exception { com.google.gwtorm.nosql.IndexFunction<com.google.gwtorm.data.Person> idx = index("nameAge", "WHERE name=? AND age=?"); org.junit.Assert.assertEquals("nameAge", idx.getName()); com.google.gwtorm.nosql.IndexKeyBuilder b; com.google.gwtorm.data.Person p; b = new com.google.gwtorm.nosql.IndexKeyBuilder(); p = new com.google.gwtorm.data.Person(new com.google.gwtorm.data.Person.Key("hm"), 42); assertTrue(idx.includes(p)); idx.encode(b, p); com.google.gwtorm.nosql.IndexFunctionTest.assertEqualToBuilderResult(new byte[]{ 'h', 'm', 0, 1, 1, 42 }, b); p = new com.google.gwtorm.data.Person(new com.google.gwtorm.data.Person.Key(null), 0); assertFalse(idx.includes(p)); b = new com.google.gwtorm.nosql.IndexKeyBuilder(); assertFalse(idx.includes(p)); }
@org.junit.Test public void testAddress() { final com.google.gwtorm.protobuf.ProtobufCodec<com.google.gwtorm.data.Address> e = com.google.gwtorm.protobuf.CodecFactory.encoder(com.google.gwtorm.data.Address.class); com.google.gwtorm.data.Address a = e.decode(new byte[0]); assertNotNull(a); assertNull(a.location()); com.google.gwtorm.data.Person.Key k = new com.google.gwtorm.data.Person.Key("bob"); @java.lang.SuppressWarnings("unused") com.google.gwtorm.data.Person p = new com.google.gwtorm.data.Person(k, 42); com.google.gwtorm.data.Address b = new com.google.gwtorm.data.Address(new com.google.gwtorm.data.Address.Key(k, "ny"), "ny"); byte[] act = e.encodeToByteArray(b); com.google.gwtorm.data.Address c = e.decode(act); assertEquals(c.location(), b.location()); assertEquals(c.city(), b.city()); assertEquals(c.key(), b.key()); }
private static boolean isValidRevision(java.lang.String revision) { return (((revision.indexOf(':')) < 0) && ((revision.indexOf("^{")) < 0)) && ((revision.indexOf('@')) < 0); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse res, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { java.lang.String pkg = "gerrit-gwtui"; java.lang.String target = "ui_" + (rule.select(((javax.servlet.http.HttpServletRequest) (request)))); java.lang.String rule = (("//" + pkg) + ":") + target; java.lang.String child = java.lang.String.format("%s/__gwt_binary_%s__", pkg, target); java.io.File zip = new java.io.File(new java.io.File(gen, child), (target + ".zip")); synchronized(this) { try { com.google.gerrit.pgm.http.jetty.JettyServer.build(root, gen, rule); } catch (com.google.gerrit.pgm.http.jetty.JettyServer.BuildFailureException e) { displayFailure(rule, e.why, ((javax.servlet.http.HttpServletResponse) (res))); return; } if ((!(target.equals(lastTarget))) || ((lastTime) != (zip.lastModified()))) { lastTarget = target; lastTime = zip.lastModified(); com.google.gerrit.pgm.http.jetty.JettyServer.unpack(zip, dstwar); } } chain.doFilter(request, res); }
@java.lang.Override public void onPluginLoad() { com.google.gerrit.plugin.client.Plugin.get().screenRegex("project/(.*)/rev/(.*)/(.*)", new com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.Factory()); com.google.gerrit.plugin.client.Plugin.get().screenRegex("project/(.*)/(.*)", new com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.HeadFactory()); }








@java.lang.Override public void onLoad(com.google.gerrit.plugin.client.screen.Screen screen) { java.lang.String projectName = com.google.gwt.http.client.URL.decode(screen.getToken(1)); java.lang.String fileName = com.google.gwt.http.client.URL.decode(screen.getToken(2)); screen.show(new com.googlesource.gerrit.plugins.xdocs.client.XDocScreen(projectName, "HEAD", fileName)); }
@java.lang.Override public void onLoad(com.google.gerrit.plugin.client.screen.Screen screen) { java.lang.String change = com.google.gwt.http.client.URL.decode(screen.getToken(1)); java.lang.String patchSet = com.google.gwt.http.client.URL.decode(screen.getToken(2)); java.lang.String file = com.google.gwt.http.client.URL.decode(screen.getToken(3)); screen.show(new com.googlesource.gerrit.plugins.xdocs.client.XDocSideBySideDiffScreen(change, patchSet, file)); }
@java.lang.Override public void onLoad(com.google.gerrit.plugin.client.screen.Screen screen) { java.lang.String change = com.google.gwt.http.client.URL.decode(screen.getToken(1)); java.lang.String patchSet = com.google.gwt.http.client.URL.decode(screen.getToken(2)); java.lang.String file = com.google.gwt.http.client.URL.decode(screen.getToken(3)); screen.show(new com.googlesource.gerrit.plugins.xdocs.client.XDocUnifiedDiffScreen(change, patchSet, file)); }



@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo get() throws com.google.gerrit.extensions.restapi.RestApiException { return get(java.util.EnumSet.allOf(com.google.gerrit.extensions.common.ListChangesOption.class)); }

public java.util.List<java.lang.String> check(com.google.gerrit.reviewdb.client.Change c) { reset(); change = c; try { checkImpl(); return messages; } finally { if ((rw) != null) { rw.release(); } if ((repo) != null) { repo.close(); } } }
@java.lang.Override public com.google.gerrit.server.change.CheckResult apply(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.server.change.CheckResult result = new com.google.gerrit.server.change.CheckResult(); result.messages = checkerProvider.get().check(rsrc.getChange()); try { result.change = json.format(rsrc); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = "Error rendering final ChangeInfo"; com.google.gerrit.server.change.Check.log.warn(msg, e); result.messages.add(msg); result.change = com.google.gerrit.server.change.Check.basicChangeInfo(rsrc.getChange()); } return result; }

@java.lang.Override public void init(javax.servlet.FilterConfig filterConfig) throws javax.servlet.ServletException { showGitBlitBanner(); try { com.gitblit.GitBlit.self().configureContext(settings, settings.getBasePath(), false); com.gitblit.GitBlit.self().contextInitialized(new javax.servlet.ServletContextEvent(filterConfig.getServletContext())); super.init(new com.googlesource.gerrit.plugins.gitblit.GerritWicketFilter.CustomFilterConfig(filterConfig)); } catch (java.lang.Exception e) { throw new javax.servlet.ServletException(e); } }


@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> change(java.lang.String query) { if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_LEGACY_ID.matcher(query).matches()) { return new com.google.gerrit.server.query.change.LegacyChangeIdPredicate(args, Change.Id.parse(query)); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_CHANGE_ID.matcher(query).matches()) { return new com.google.gerrit.server.query.change.ChangeIdPredicate(args, com.google.gerrit.server.query.change.ChangeQueryBuilder.parseChangeId(query)); } throw new java.lang.IllegalArgumentException(); }

private java.lang.String describe(final com.google.gerrit.reviewdb.client.AccountExternalId k) { if (k.isScheme(AccountExternalId.SCHEME_GERRIT)) { return k.getSchemeRest(); } else if (k.isScheme(AccountExternalId.SCHEME_USERNAME)) { return k.getSchemeRest(); } else if (k.isScheme(AccountExternalId.SCHEME_MAILTO)) { return ""; } else if (k.isScheme("https://www.google.com/accounts/o8/id")) { return OpenIdUtil.C.nameGoogle(); } else if (k.isScheme(OpenIdUrls.URL_YAHOO)) { return OpenIdUtil.C.nameYahoo(); } else { return k.getExternalId(); } }
void init(com.google.gerrit.client.diff.PreferencesAction pa, java.util.List<com.google.gerrit.client.DiffWebLinkInfo> webLinks) { prefsAction = pa; prefsAction.setPartner(preferences); if (webLinks != null) { for (com.google.gerrit.client.DiffWebLinkInfo webLink : webLinks) { webLinksPanel.add(webLink.toAnchor()); } } }


void display(int patchIndex, com.google.gerrit.client.patches.PatchScreen.Type type, com.google.gerrit.client.changes.PatchTable fileList) { if (fileList != null) { setupNav(com.google.gerrit.client.patches.NavLinks.Nav.PREV, fileList.getPreviousPatchLink(patchIndex, type)); setupNav(com.google.gerrit.client.patches.NavLinks.Nav.NEXT, fileList.getNextPatchLink(patchIndex, type)); } else { setupNav(com.google.gerrit.client.patches.NavLinks.Nav.PREV, null); setupNav(com.google.gerrit.client.patches.NavLinks.Nav.NEXT, null); } }

void init(com.google.gerrit.client.diff.PreferencesAction pa) { prefsAction = pa; prefsAction.setPartner(preferences); }




@java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if (change.getStatus().isClosed()) { return null; } if (!(change.currentPatchSetId().equals(priorPatchSet))) { return change; } if (((magicBranch) != null) && ((magicBranch.topic) != null)) { change.setTopic(magicBranch.topic); } if (((change.getStatus()) == (Change.Status.DRAFT)) && (newPatchSet.isDraft())) { } else { change.setStatus(Change.Status.NEW); } change.setCurrentPatchSet(info); final java.util.List<java.lang.String> idList = newCommit.getFooterLines(com.google.gerrit.server.git.ReceiveCommits.CHANGE_ID); if (idList.isEmpty()) { change.setKey(new com.google.gerrit.reviewdb.client.Change.Key(("I" + (newCommit.name())))); } else { change.setKey(new com.google.gerrit.reviewdb.client.Change.Key(idList.get(((idList.size()) - 1)).trim())); } com.google.gerrit.server.ChangeUtil.updated(change); return change; }
private static com.google.gerrit.reviewdb.client.Patch.ChangeType toChangeType(final org.eclipse.jgit.patch.FileHeader hdr) { switch (hdr.getChangeType()) { case ADD : return com.google.gerrit.reviewdb.client.Patch.ChangeType.ADDED; case MODIFY : return com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED; case DELETE : return com.google.gerrit.reviewdb.client.Patch.ChangeType.DELETED; case RENAME : return com.google.gerrit.reviewdb.client.Patch.ChangeType.RENAMED; case COPY : return com.google.gerrit.reviewdb.client.Patch.ChangeType.COPIED; default : throw new java.lang.IllegalArgumentException(("Unsupported type " + (hdr.getChangeType()))); } }
public com.google.gerrit.reviewdb.client.Patch.ChangeType getChangeType() { return com.google.gerrit.reviewdb.client.Patch.ChangeType.forCode(changeType); }
public final com.google.gerrit.reviewdb.client.Patch.ChangeType change_type() { return com.google.gerrit.reviewdb.client.Patch.ChangeType.valueOf(change_typeRaw()); }
private static com.googlecode.prolog_cafe.lang.SymbolTerm getTypeSymbol(com.google.gerrit.reviewdb.client.Patch.ChangeType type) { switch (type) { case ADDED : return gerrit.PRED_commit_delta_4.add; case MODIFIED : return gerrit.PRED_commit_delta_4.modify; case DELETED : return gerrit.PRED_commit_delta_4.delete; case RENAMED : return gerrit.PRED_commit_delta_4.rename; case COPIED : return gerrit.PRED_commit_delta_4.copy; case REWRITE : break; } throw new java.lang.IllegalArgumentException("ChangeType not recognized"); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo> result) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.FileInfo> fileInfos = result.values(); com.google.gerrit.client.diff.FileInfo.sortFileInfoByPath(fileInfos); java.util.List<com.google.gerrit.reviewdb.client.Patch> list = new java.util.ArrayList(fileInfos.length()); for (com.google.gerrit.client.diff.FileInfo f : com.google.gerrit.client.rpc.Natives.asList(fileInfos)) { com.google.gerrit.reviewdb.client.Patch p = patches.get(f.path()); if (p == null) { p = new com.google.gerrit.reviewdb.client.Patch(new com.google.gerrit.reviewdb.client.Patch.Key(psId, f.path())); patches.put(f.path(), p); } p.setInsertions(f.lines_inserted()); p.setDeletions(f.lines_deleted()); p.setPatchType((f.binary() ? com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY : com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED)); if ((f.status()) == null) { p.setChangeType(ChangeType.MODIFIED); } else { p.setChangeType(com.google.gerrit.reviewdb.client.Patch.ChangeType.forCode(f.status().charAt(0))); } list.add(p); } event.getValue().getCurrentPatchSetDetail().setPatches(list); }
public void setChangeType(final com.google.gerrit.reviewdb.client.Patch.ChangeType type) { changeType = type.getCode(); }
void setHideEmptyPane(boolean hide) { if ((changeType) == (com.google.gerrit.reviewdb.client.Patch.ChangeType.ADDED)) { setVisibleA((!hide)); } else if ((changeType) == (com.google.gerrit.reviewdb.client.Patch.ChangeType.DELETED)) { setVisibleB((!hide)); } }
com.google.gerrit.reviewdb.client.Patch.ChangeType getChangeType() { return changeType; }
static com.google.gerrit.server.patch.PatchListEntry empty(final java.lang.String fileName) { return new com.google.gerrit.server.patch.PatchListEntry(com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.patch.PatchListEntry.EMPTY_HEADER, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList(), 0, 0); }
void set(com.google.gerrit.client.account.DiffPreferences prefs) { this.prefs = prefs; setIgnoreWhitespace(prefs.ignoreWhitespace()); tabWidth.setIntValue(prefs.tabSize()); lineLength.setIntValue(prefs.lineLength()); syntaxHighlighting.setValue(prefs.syntaxHighlighting()); whitespaceErrors.setValue(prefs.showWhitespaceErrors()); showTabs.setValue(prefs.showTabs()); lineNumbers.setValue(prefs.showLineNumbers()); leftSide.setValue(view.diffTable.isVisibleA()); emptyPane.setValue((!(prefs.hideEmptyPane()))); leftSide.setEnabled((!((prefs.hideEmptyPane()) && ((view.diffTable.getChangeType()) == (com.google.gerrit.reviewdb.client.Patch.ChangeType.ADDED))))); topMenu.setValue((!(prefs.hideTopMenu()))); manualReview.setValue(prefs.manualReview()); expandAllComments.setValue(prefs.expandAllComments()); renderEntireFile.setValue(prefs.renderEntireFile()); renderEntireFile.setEnabled(view.canEnableRenderEntireFile(prefs)); setTheme(prefs.theme()); mode.setEnabled(prefs.syntaxHighlighting()); if (prefs.syntaxHighlighting()) { setMode(view.getCmFromSide(DisplaySide.B).getStringOption("mode")); } switch (view.getIntraLineStatus()) { case OFF : case OK : intralineDifference.setValue(prefs.intralineDifference()); break; case TIMEOUT : case FAILURE : intralineDifference.setValue(false); intralineDifference.setEnabled(false); break; } if ((prefs.context()) == (WHOLE_FILE_CONTEXT)) { contextLastValue = DEFAULT_CONTEXT; context.setText(""); contextEntireFile.setValue(true); } else { context.setIntValue(prefs.context()); contextEntireFile.setValue(false); } }
@com.google.gwt.uibinder.client.UiHandler("emptyPane") void onHideEmptyPane(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> e) { prefs.hideEmptyPane((!(e.getValue()))); view.diffTable.setHideEmptyPane(prefs.hideEmptyPane()); if (prefs.hideEmptyPane()) { if ((view.diffTable.getChangeType()) == (com.google.gerrit.reviewdb.client.Patch.ChangeType.ADDED)) { leftSide.setValue(false); leftSide.setEnabled(false); } } else { leftSide.setValue(view.diffTable.isVisibleA()); leftSide.setEnabled(true); } }
@org.junit.Test public void testEmpty1() { final java.lang.String name = "empty-file"; final com.google.gerrit.server.patch.PatchListEntry e = com.google.gerrit.server.patch.PatchListEntry.empty(name); assertNull(e.getOldName()); assertEquals(name, e.getNewName()); assertSame(Patch.PatchType.UNIFIED, e.getPatchType()); assertSame(Patch.ChangeType.MODIFIED, e.getChangeType()); assertTrue(e.getEdits().isEmpty()); }
public static <T extends com.google.gerrit.reviewdb.client.CodedEnum> T readEnum(final java.io.InputStream input, final T[] all) throws java.io.IOException { final int val = com.google.gerrit.server.ioutil.BasicSerialization.readVarInt32(input); for (T t : all) { if ((t.getCode()) == val) { return t; } } throw new java.io.IOException(((("Invalid enum " + val) + " for ") + (all[0].getClass()))); }
static com.google.gerrit.server.patch.PatchListEntry readFrom(final java.io.InputStream in) throws java.io.IOException { final com.google.gerrit.reviewdb.client.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.ChangeType.values()); final com.google.gerrit.reviewdb.client.Patch.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.PatchType.values()); final java.lang.String oldName = readString(in); final java.lang.String newName = readString(in); final byte[] hdr = readBytes(in); final int ins = readVarInt32(in); final int del = readVarInt32(in); final int editCount = readVarInt32(in); final org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { int beginA = readVarInt32(in); int endA = readVarInt32(in); int beginB = readVarInt32(in); int endB = readVarInt32(in); editArray[i] = new org.eclipse.jgit.diff.Edit(beginA, endA, beginB, endB); } return new com.google.gerrit.server.patch.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.gerrit.server.patch.PatchListEntry.toList(editArray), ins, del); }
public static <T extends com.google.gerrit.reviewdb.client.CodedEnum> void writeEnum(final java.io.OutputStream output, final T e) throws java.io.IOException { com.google.gerrit.server.ioutil.BasicSerialization.writeVarInt32(output, e.getCode()); }
@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.rpc.CallbackGroup cmGroup = new com.google.gerrit.client.rpc.CallbackGroup(); net.codemirror.lib.CodeMirror.initLibrary(cmGroup.add(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback())); initPath(); com.google.gerrit.client.changes.ChangeFileApi.getContentOrMessage(revision, path, cmGroup.addFinal(new com.google.gerrit.client.rpc.ScreenLoadCallback<java.lang.String>(this) { @java.lang.Override protected void preDisplay(java.lang.String content) { initEditor(content); } })); }




public com.google.gerrit.server.project.ChangeControl forUser(final com.google.gerrit.server.CurrentUser who) { if (getCurrentUser().equals(who)) { return this; } return new com.google.gerrit.server.project.ChangeControl(changeDataFactory, getRefControl().forUser(who), notes); }
public java.util.List<com.googlecode.prolog_cafe.lang.Term> evaluate() throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.rules.PrologEnvironment env = getPrologEnvironment(); try { submitRule = env.once("gerrit", userRuleLocatorName, new com.googlecode.prolog_cafe.lang.VariableTerm()); if (fastEvalLabels) { env.once("gerrit", "assume_range_from_label"); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results = new java.util.ArrayList<>(); try { for (com.googlecode.prolog_cafe.lang.Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new com.googlecode.prolog_cafe.lang.VariableTerm())) { results.add(template[1]); } } catch (com.googlecode.prolog_cafe.lang.PrologException err) { throw new com.google.gerrit.server.project.RuleEvalException(((((("Exception calling " + (submitRule)) + " on change ") + (change.getId())) + " of ") + (getProjectName())), err); } catch (java.lang.RuntimeException err) { throw new com.google.gerrit.server.project.RuleEvalException(((((("Exception calling " + (submitRule)) + " on change ") + (change.getId())) + " of ") + (getProjectName())), err); } com.googlecode.prolog_cafe.lang.Term resultsTerm = com.google.gerrit.server.project.SubmitRuleEvaluator.toListTerm(results); if (!(skipFilters)) { resultsTerm = runSubmitFilters(resultsTerm, env); } if (resultsTerm.isList()) { java.util.List<com.googlecode.prolog_cafe.lang.Term> r = com.google.common.collect.Lists.newArrayList(); for (com.googlecode.prolog_cafe.lang.Term t = resultsTerm; t.isList();) { com.googlecode.prolog_cafe.lang.ListTerm l = ((com.googlecode.prolog_cafe.lang.ListTerm) (t)); r.add(l.car().dereference()); t = l.cdr().dereference(); } return r; } return java.util.Collections.emptyList(); } finally { env.close(); } }









private RefUpdate.Result update(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.IdentifiedUser me, java.lang.String refName, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId oldObjectId, org.eclipse.jgit.lib.ObjectId newEdit) throws java.io.IOException { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(refName); ru.setExpectedOldObjectId(oldObjectId); ru.setNewObjectId(newEdit); ru.setRefLogIdent(getRefLogIdent(me)); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result res = ru.update(rw); if ((res != (RefUpdate.Result.NEW)) && (res != (RefUpdate.Result.FORCED))) { throw new java.io.IOException(("update failed: " + ru)); } return res; }
public RefUpdate.Result modifyMessage(com.google.gerrit.server.edit.ChangeEdit edit, java.lang.String msg) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.edit.UnchangedCommitMessageException, com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { checkState((!(com.google.common.base.Strings.isNullOrEmpty(msg))), "message cannot be null"); if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } org.eclipse.jgit.revwalk.RevCommit prevEdit = edit.getEditCommit(); if ((prevEdit.getParentCount()) == 0) { throw new com.google.gerrit.server.project.InvalidChangeOperationException("Modify edit against root commit not supported"); } if (prevEdit.getFullMessage().equals(msg)) { throw new com.google.gerrit.server.edit.UnchangedCommitMessageException(); } com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (currentUser.get())); org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(edit.getChange().getProject()); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter(); try { java.lang.String refName = edit.getRefName(); org.eclipse.jgit.lib.ObjectId commit = createCommit(me, inserter, prevEdit, rw.parseCommit(prevEdit.getParent(0)), prevEdit.getTree(), msg); inserter.flush(); return update(repo, me, refName, rw, prevEdit, commit); } finally { rw.release(); inserter.release(); } } finally { repo.close(); } }
public java.util.Set<java.lang.String> getEmailAddresses() { if ((emailAddresses) == null) { emailAddresses = state().getEmailAddresses(); } return emailAddresses; }
public boolean hasEmailAddress(java.lang.String email) { return getEmailAddresses().contains(email); }
private void initEditMessageAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = info.revision(revision).actions(); if ((actions != null) && (actions.containsKey("message"))) { editMessage.setVisible(true); editMessageAction = new com.google.gerrit.client.change.EditMessageAction(info.legacy_id(), info.revision(revision).commit().message(), style, editMessage, reply); keysAction.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 'e', Util.C.keyEditMessage()) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { editMessageAction.onEdit(); } }); } }
private void columnPathEdit(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().pathColumn()); java.lang.String path = info.path(); sb.openAnchor(); if (!(isEditable(info))) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.RESTORE) + "(event,") + (info._row())) + ")")); } else { sb.setAttribute("href", ("#" + (url(info)))).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.OPEN) + "(event,") + (info._row())) + ")")); } if (!(Patch.COMMIT_MSG.equals(path))) { int commonPrefixLen = commonPrefix(path); if (commonPrefixLen > 0) { sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan(); } sb.append(path.substring(commonPrefixLen)); } else { sb.append(Util.C.commitMessage()); } sb.closeAnchor(); sb.closeTd(); }
private void columnPath(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().pathColumn()).openAnchor(); java.lang.String path = info.path(); if (((mode) == (com.google.gerrit.client.change.FileTable.Mode.EDIT)) && (!(isEditable(info)))) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.RESTORE) + "(event,") + (info._row())) + ")")); } else { sb.setAttribute("href", ("#" + (url(info)))).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.OPEN) + "(event,") + (info._row())) + ")")); } if (Patch.COMMIT_MSG.equals(path)) { sb.append(Util.C.commitMessage()); } else { int commonPrefixLen = commonPrefix(path); if (commonPrefixLen > 0) { sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan(); } sb.append(path.substring(commonPrefixLen)); lastPath = path; } sb.closeAnchor(); if ((info.old_path()) != null) { sb.br(); sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().renameCopySource()).append(info.old_path()).closeSpan(); } sb.closeTd(); }
private void columnDeleteRestore(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().removeButton()); if (hasUser) { if (!(Patch.COMMIT_MSG.equals(info.path()))) { boolean editable = isEditable(info); sb.openElement("button").setAttribute("title", (editable ? Resources.C.removeFileInline() : Resources.C.restoreFileInline())).setAttribute("onclick", ((((editable ? com.google.gerrit.client.change.FileTable.DELETE : com.google.gerrit.client.change.FileTable.RESTORE) + "(event,") + (info._row())) + ")")).append(new com.google.gwt.user.client.ui.ImageResourceRenderer().render((editable ? Gerrit.RESOURCES.redNot() : Gerrit.RESOURCES.editUndo()))).closeElement("button"); } } sb.closeTd(); }
@java.lang.Override protected void onOpenRow(int row) { if ((1 <= row) && (row <= (list.length()))) { com.google.gerrit.client.Gerrit.display(url(list.get((row - 1)))); } }
public static com.google.gerrit.reviewdb.client.Change.Id parse(final java.lang.String str) { final com.google.gerrit.reviewdb.client.Change.Id r = new com.google.gerrit.reviewdb.client.Change.Id(); r.fromString(str); return r; }

void setLimit(int n) { limit = n; }

private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query0() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { int cnt = queries.size(); java.util.BitSet more = new java.util.BitSet(cnt); java.util.List<java.util.List<com.google.gerrit.server.query.change.ChangeData>> data = imp.queryChanges(queries); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = data.get(n); if (((imp.getLimit()) > 0) && ((changes.size()) > (imp.getLimit()))) { if (reverse) { changes = changes.subList(1, changes.size()); } else { changes = changes.subList(0, imp.getLimit()); } data.set(n, changes); more.set(n, true); } } java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = json.addOptions(options).formatList2(data); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if ((more.get(n)) && (!(info.isEmpty()))) { if (reverse) { info.get(0)._moreChanges = true; } else { info.get(((info.size()) - 1))._moreChanges = true; } } } return res; }

public java.util.List<com.google.gerrit.server.query.change.ChangeData> queryChanges(java.lang.String queryString) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { return queryChanges(com.google.common.collect.ImmutableList.of(queryString)).get(0); }
@org.junit.Test public void testLimit() throws java.lang.Exception { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> in = parse("file:a limit:3"); com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> out = rewrite(in); assertSame(com.google.gerrit.server.query.change.AndSource.class, out.getClass()); assertEquals(com.google.common.collect.ImmutableList.of(query(in.getChild(0), 3), in.getChild(1)), out.getChildren()); }
private void assertIncludes(java.lang.String group, java.lang.String... includes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(group)); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> ids = com.google.common.collect.Sets.newHashSet(); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> all = db.accountGroupById().byGroup(g.getId()); for (com.google.gerrit.reviewdb.client.AccountGroupById m : all) { ids.add(m.getIncludeUUID()); } assertTrue(((ids.size()) == (includes.length))); for (java.lang.String i : includes) { com.google.gerrit.reviewdb.client.AccountGroup.UUID id = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(i)).getGroupUUID(); assertTrue(ids.contains(id)); } }
@org.junit.Test public void defaultGroupsCreated_internals() throws java.lang.Exception { java.util.Set<java.lang.String> names = com.google.common.collect.Sets.newHashSet(); for (com.google.gerrit.reviewdb.client.AccountGroup g : db.accountGroups().all()) { names.add(g.getName()); } assertTrue(names.contains("Administrators")); assertTrue(names.contains("Non-Interactive Users")); }
@org.junit.Test public void defaultGroupsCreated_rest() throws java.lang.Exception { com.google.gerrit.acceptance.RestSession session = new com.google.gerrit.acceptance.RestSession(server, admin); com.google.gerrit.acceptance.RestResponse r = session.get("/groups/"); java.util.Map<java.lang.String, com.google.gerrit.server.group.GroupJson.GroupInfo> result = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.server.group.GroupJson.GroupInfo>>() {}.getType()); java.util.Set<java.lang.String> names = result.keySet(); assertTrue(names.contains("Administrators")); assertTrue(names.contains("Non-Interactive Users")); }
private void assertMembers(java.lang.String group, com.google.gerrit.acceptance.TestAccount... members) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup g = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> ids = com.google.common.collect.Sets.newHashSet(); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> all = db.accountGroupMembers().byGroup(g.getId()); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : all) { ids.add(m.getAccountId()); } assertTrue(((ids.size()) == (members.length))); for (com.google.gerrit.acceptance.TestAccount a : members) { assertTrue(ids.contains(a.id)); } }
private void assertMembers(java.util.List<com.google.gerrit.extensions.common.AccountInfo> members, java.lang.String name, java.lang.String... names) { java.util.Collection<java.lang.String> memberNames = com.google.common.collect.Collections2.transform(members, new com.google.common.base.Function<com.google.gerrit.extensions.common.AccountInfo, java.lang.String>() { @java.lang.Override public java.lang.String apply(@com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.AccountInfo info) { return info.name; } }); assertTrue(memberNames.contains(name)); for (java.lang.String n : names) { assertTrue(memberNames.contains(n)); } assertEquals(members.size(), ((names.length) + 1)); }
private void assertIncludes(java.util.List<com.google.gerrit.server.group.GroupJson.GroupInfo> includes, java.lang.String name, java.lang.String... names) { java.util.Collection<java.lang.String> includeNames = com.google.common.collect.Collections2.transform(includes, new com.google.common.base.Function<com.google.gerrit.server.group.GroupJson.GroupInfo, java.lang.String>() { @java.lang.Override public java.lang.String apply(@com.google.gerrit.common.Nullable com.google.gerrit.server.group.GroupJson.GroupInfo info) { return info.name; } }); assertTrue(includeNames.contains(name)); for (java.lang.String n : names) { assertTrue(includeNames.contains(n)); } assertEquals(includes.size(), ((names.length) + 1)); }
public static void assertGroups(java.lang.Iterable<java.lang.String> expected, java.util.Set<java.lang.String> actual) { for (java.lang.String g : expected) { assertTrue(("missing group " + g), actual.remove(g)); } assertTrue(("unexpected groups: " + actual), actual.isEmpty()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.DeleteDraftPatchSet.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet patchSet = rsrc.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = patchSet.getId(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(patchSet.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Patch set is not a draft."); } if (!(allowDrafts)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Draft workflow is disabled."); } if (!(rsrc.getControl().canDeleteDraft(dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("Not permitted to delete this draft patch set"); } deleteDraftPatchSet(patchSet, change); deleteOrUpdateDraftChange(patchSetId, change); return com.google.gerrit.extensions.restapi.Response.none(); }
private void assertChanges(java.util.Set<java.lang.String> actualChanges, com.google.gerrit.acceptance.PushOneCommit... expectedChanges) { assertEquals(expectedChanges.length, actualChanges.size()); for (com.google.gerrit.acceptance.PushOneCommit.Result c : expectedChanges) { assertTrue(actualChanges.contains(id(c))); } }
@org.junit.Test public void noConflictingChanges() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(git, true); createChange(git, false); java.util.Set<java.lang.String> changes = queryConflictingChanges(change); assertEquals(0, changes.size()); }
@org.junit.Test public void currentRevisionAndMessages() throws java.lang.Exception { ChangeInfo c = get(changeId, com.google.gerrit.acceptance.rest.change.CURRENT_REVISION, com.google.gerrit.acceptance.rest.change.MESSAGES); assertEquals(1, c.revisions.size()); assertEquals(commitId(2), c.currentRevision); assertEquals(com.google.common.collect.ImmutableSet.of(commitId(2)), c.revisions.keySet()); assertEquals(3, c.revisions.get(commitId(2))._number); }
@org.junit.Test public void currentRevision() throws java.lang.Exception { ChangeInfo c = get(changeId, com.google.gerrit.acceptance.rest.change.CURRENT_REVISION); assertEquals(commitId(2), c.currentRevision); assertEquals(com.google.common.collect.ImmutableSet.of(commitId(2)), c.revisions.keySet()); assertEquals(3, c.revisions.get(commitId(2))._number); }
@org.junit.Test public void allRevisions() throws java.lang.Exception { ChangeInfo c = get(changeId, com.google.gerrit.acceptance.rest.change.ALL_REVISIONS); assertEquals(commitId(2), c.currentRevision); assertEquals(com.google.common.collect.ImmutableSet.of(commitId(0), commitId(1), commitId(2)), c.revisions.keySet()); assertEquals(1, c.revisions.get(commitId(0))._number); assertEquals(2, c.revisions.get(commitId(1))._number); assertEquals(3, c.revisions.get(commitId(2))._number); }
@org.junit.Test public void messagesReturnedInChronologicalOrder() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.lang.String firstMessage = "Some nits need to be fixed."; postMessage(changeId, firstMessage); java.lang.String secondMessage = "I like this feature."; postMessage(changeId, secondMessage); ChangeInfo c = get(changeId); assertNotNull(c.messages); assertEquals(3, c.messages.size()); java.util.Iterator<com.google.gerrit.extensions.common.ChangeMessageInfo> it = c.messages.iterator(); assertEquals("Uploaded patch set 1.", it.next().message); assertMessage(firstMessage, it.next().message); assertMessage(secondMessage, it.next().message); }
@org.junit.Test public void messagesNotReturnedByDefault() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); postMessage(changeId, "Some nits need to be fixed."); com.google.gerrit.extensions.common.ChangeInfo c = info(changeId); assertNull(c.messages); }
@org.junit.Test public void defaultMessage() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); ChangeInfo c = get(changeId); assertNotNull(c.messages); assertEquals(1, c.messages.size()); assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message); }
@java.lang.Override public void doHashtagsChangedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.util.Set<java.lang.String> added, java.util.Set<java.lang.String> removed, java.util.Set<java.lang.String> hashtags, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.HashtagsChangedEvent event = new com.google.gerrit.server.events.HashtagsChangedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(change); event.editor = eventFactory.asAccountAttribute(account); event.hashtags = hashtagArray(hashtags); event.added = hashtagArray(added); event.removed = hashtagArray(removed); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--editor", getDisplayName(account)); if (hashtags != null) { for (java.lang.String hashtag : hashtags) { addArg(args, "--hashtag", hashtag); } } if (added != null) { for (java.lang.String hashtag : added) { addArg(args, "--added", hashtag); } } if (removed != null) { for (java.lang.String hashtag : removed) { addArg(args, "--removed", hashtag); } } runHook(change.getProject(), hashtagsChangedHook, args); }
public final void removeLineClass(net.codemirror.lib.CodeMirror.LineHandle line, net.codemirror.lib.CodeMirror.LineClassWhere where, java.lang.String className) { removeLineClassNative(line, where.name().toLowerCase(), className); }
private void markEdit(net.codemirror.lib.CodeMirror cm, int startLine, com.google.gwt.core.client.JsArrayString lines, com.google.gwt.core.client.JsArray<com.google.gerrit.client.diff.DiffInfo.Span> edits) { if ((lines == null) || (edits == null)) { return; } com.google.gerrit.client.diff.EditIterator iter = new com.google.gerrit.client.diff.EditIterator(lines, startLine); net.codemirror.lib.Configuration bg = net.codemirror.lib.Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true); net.codemirror.lib.Configuration diff = net.codemirror.lib.Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true); net.codemirror.lib.LineCharacter last = net.codemirror.lib.CodeMirror.pos(0, 0); for (com.google.gerrit.client.diff.DiffInfo.Span span : com.google.gerrit.client.rpc.Natives.asList(edits)) { net.codemirror.lib.LineCharacter from = iter.advance(span.skip()); net.codemirror.lib.LineCharacter to = iter.advance(span.mark()); if ((from.getLine()) == (last.getLine())) { markers.add(cm.markText(last, from, bg)); } else { markers.add(cm.markText(net.codemirror.lib.CodeMirror.pos(from.getLine(), 0), from, bg)); } markers.add(cm.markText(from, to, diff)); last = to; colorLines(cm, LineClassWhere.BACKGROUND, DiffTable.style.diff(), from.getLine(), to.getLine()); } }
void collapse(int start, int end, boolean attach) { if (attach) { boolean isNew = (lineWidget) == null; net.codemirror.lib.Configuration cfg = net.codemirror.lib.Configuration.create().set("coverGutter", true).set("noHScroll", true); if (start == 0) { lineWidget = cm.addLineWidget((end + 1), getElement(), cfg.set("above", true)); } else { lineWidget = cm.addLineWidget((start - 1), getElement(), cfg); } if (isNew) { lineWidget.onFirstRedraw(new java.lang.Runnable() { @java.lang.Override public void run() { int w = cm.getGutterElement().getOffsetWidth(); getElement().getStyle().setPaddingLeft(w, Unit.PX); } }); } } textMarker = cm.markText(net.codemirror.lib.CodeMirror.pos(start, 0), net.codemirror.lib.CodeMirror.pos(end), net.codemirror.lib.Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true)); textMarker.on("beforeCursorEnter", new java.lang.Runnable() { @java.lang.Override public void run() { expandAll(); } }); int skipped = (end - start) + 1; if (skipped <= (com.google.gerrit.client.diff.SkipBar.UP_DOWN_THRESHOLD)) { addStyleName(style.noExpand()); } else { upArrow.setHTML(PatchUtil.M.expandBefore(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND)); } skipNum.setText(PatchUtil.M.patchSkipRegion(java.lang.Integer.toString(skipped))); }

public final void addLineClass(int line, net.codemirror.lib.CodeMirror.LineClassWhere where, java.lang.String className) { addLineClassNative(line, where.name().toLowerCase(), className); }
private net.codemirror.lib.CodeMirror.BeforeSelectionChangeHandler onSelectionChange(final net.codemirror.lib.CodeMirror cm) { return new net.codemirror.lib.CodeMirror.BeforeSelectionChangeHandler() { private com.google.gerrit.client.diff.InsertCommentBubble bubble; @java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm, net.codemirror.lib.LineCharacter anchor, net.codemirror.lib.LineCharacter head) { if ((anchor == head) || (((anchor.getLine()) == (head.getLine())) && ((anchor.getCh()) == (head.getCh())))) { if ((bubble) != null) { bubble.setVisible(false); } return; } else if ((bubble) == null) { init(anchor); } else { bubble.setVisible(true); } bubble.position(cm.charCoords(head, "local")); } private void init(net.codemirror.lib.LineCharacter anchor) { bubble = new com.google.gerrit.client.diff.InsertCommentBubble(commentManager, cm); add(bubble); cm.addWidget(anchor, bubble.getElement(), false); } }; }
public final void addLineClass(net.codemirror.lib.CodeMirror.LineHandle line, net.codemirror.lib.CodeMirror.LineClassWhere where, java.lang.String className) { addLineClassNative(line, where.name().toLowerCase(), className); }
@java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm, net.codemirror.lib.LineCharacter anchor, net.codemirror.lib.LineCharacter head) { if ((anchor == head) || (((anchor.getLine()) == (head.getLine())) && ((anchor.getCh()) == (head.getCh())))) { if ((bubble) != null) { bubble.setVisible(false); } return; } else if ((bubble) == null) { init(anchor); } else { bubble.setVisible(true); } bubble.position(cm.charCoords(head, "local")); }
public final void removeLineClass(int line, net.codemirror.lib.CodeMirror.LineClassWhere where, java.lang.String className) { removeLineClassNative(line, where.name().toLowerCase(), className); }


@java.lang.Override public void _onRequestSuggestions(final com.google.gerrit.client.ui.Request req, final com.google.gerrit.client.ui.Callback callback) { com.google.gerrit.client.RpcStatus.hide(new java.lang.Runnable() { @java.lang.Override public void run() { SuggestUtil.SVC.suggestAccount(req.getQuery(), java.lang.Boolean.TRUE, req.getLimit(), new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.AccountInfo>>() { @java.lang.Override public void onSuccess(final java.util.List<com.google.gerrit.common.data.AccountInfo> result) { final java.util.ArrayList<com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion> r = new java.util.ArrayList(result.size()); for (final com.google.gerrit.common.data.AccountInfo p : result) { r.add(new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion(p)); } callback.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(r)); } }); } }); }
private void addSuggestion(java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> map, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.extensions.common.AccountInfo info, com.google.gerrit.server.change.SuggestReviewers.VisibilityControl visibilityControl) throws com.google.gwtorm.server.OrmException { if ((((!(map.containsKey(account.getId()))) && (account.isActive())) && (visibilityControl.isVisibleTo(account))) && (accountControlFactory.get().canSee(account))) { map.put(account.getId(), info); } }



@java.lang.Override public void onSuccess(final com.google.gerrit.client.projects.ProjectMap result) { projectsTab.display(result, subname); if (firstPopupLoad) { firstPopupLoad = false; displayPopup(); } }
protected void populateProjects() { com.google.gerrit.client.projects.ProjectMap.match(subname, new com.google.gerrit.client.ui.IgnoreOutdatedFilterResultsCallbackWrapper(this, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.ProjectMap>() { @java.lang.Override public void onSuccess(final com.google.gerrit.client.projects.ProjectMap result) { projectsTab.display(result, subname); if (firstPopupLoad) { firstPopupLoad = false; displayPopup(); } } })); }
@java.lang.Override public java.lang.String getCurrentFilter() { return subname; }
@java.lang.Override public void onKeyUp(com.google.gwt.event.dom.client.KeyUpEvent event) { subname = filterTxt.getValue(); populateProjects(); }
public void displayPopup() { poppingUp = true; if (firstPopupLoad) { populateProjects(); } else { popup.setPopupPositionAndShow(popupPosition); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(popup); try { com.google.gwtexpui.globalkey.client.GlobalKey.addApplication(popup, new com.google.gwtexpui.globalkey.client.HidePopupPanelCommand(0, com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE, popup)); } catch (java.lang.Throwable e) { } projectsTab.setRegisterKeys(true); projectsTab.finishDisplay(); filterTxt.setFocus(true); poppingUp = false; } }

static void initialize(org.eclipse.jgit.lib.Config cfg) { cfg.setString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.SECTION_FORMATTER, AsciidoctorFormatter.NAME, com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_EXT, "adoc"); cfg.setString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.SECTION_FORMATTER, MarkdownFormatter.NAME, com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_MIME_TYPE, "text/x-markdown"); cfg.setString(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.SECTION_FORMATTER, PlainTextFormatter.NAME, com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_MIME_TYPE, "text/plain"); }

com.google.gerrit.extensions.common.CommitInfo toCommit(com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.patch.PatchSetInfoNotAvailableException { com.google.gerrit.reviewdb.client.PatchSetInfo info = patchSetInfoFactory.get(db.get(), in.getId()); com.google.gerrit.extensions.common.CommitInfo commit = new com.google.gerrit.extensions.common.CommitInfo(); commit.parents = com.google.common.collect.Lists.newArrayListWithCapacity(info.getParents().size()); commit.author = com.google.gerrit.server.change.ChangeJson.toGitPerson(info.getAuthor()); commit.committer = com.google.gerrit.server.change.ChangeJson.toGitPerson(info.getCommitter()); commit.subject = info.getSubject(); commit.message = info.getMessage(); for (ParentInfo parent : info.getParents()) { com.google.gerrit.extensions.common.CommitInfo i = new com.google.gerrit.extensions.common.CommitInfo(); i.commit = parent.id.get(); i.subject = parent.shortMessage; commit.parents.add(i); } return commit; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { try { com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> r = com.google.gerrit.extensions.restapi.Response.ok(json.toCommit(resource.getPatchSet())); if (resource.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } }
@java.lang.Override public void onSuccess(java.lang.Void result) { if ((prefs.syntaxHighlighting()) && (view.isAttached())) { view.operation(new java.lang.Runnable() { @java.lang.Override public void run() { view.getCmFromSide(DisplaySide.A).setOption("mode", mode); view.getCmFromSide(DisplaySide.B).setOption("mode", mode); } }); } }
@com.google.gwt.uibinder.client.UiHandler("mode") void onMode(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ChangeEvent e) { java.lang.String m = mode.getValue(mode.getSelectedIndex()); final java.lang.String mode = ((m != null) && (!(m.isEmpty()))) ? m : null; prefs.syntaxHighlighting(true); syntaxHighlighting.setValue(true, false); new net.codemirror.mode.ModeInjector().add(mode).inject(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { if ((prefs.syntaxHighlighting()) && (view.isAttached())) { view.operation(new java.lang.Runnable() { @java.lang.Override public void run() { view.getCmFromSide(DisplaySide.A).setOption("mode", mode); view.getCmFromSide(DisplaySide.B).setOption("mode", mode); } }); } } }); }

@com.google.gwt.uibinder.client.UiHandler("theme") void onTheme(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ChangeEvent e) { prefs.theme(com.google.gerrit.extensions.common.Theme.valueOf(theme.getValue(theme.getSelectedIndex()))); view.setThemeStyles(prefs.theme().isDark()); view.operation(new java.lang.Runnable() { @java.lang.Override public void run() { java.lang.String t = prefs.theme().name().toLowerCase(); view.getCmFromSide(DisplaySide.A).setOption("theme", t); view.getCmFromSide(DisplaySide.B).setOption("theme", t); } }); }
private net.codemirror.lib.Configuration getConfig() { return net.codemirror.lib.Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", 4).set("lineWrapping", false).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("mode", net.codemirror.lib.ModeInjector.getContentType(type)); }



private int getPermittedLimit() { return userProvider.get().getCapabilities().getRange(GlobalCapability.QUERY_LIMIT).getMax(); }

private boolean filterMatch(com.google.gerrit.server.CurrentUser user, java.lang.String filter) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeQueryBuilder qb; com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p = null; if (user == null) { qb = args.queryBuilder.create(args.anonymousUser); } else { qb = args.queryBuilder.create(user); p = qb.is_visible(); } if (filter != null) { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> filterPredicate = qb.parse(filter); if (p == null) { p = filterPredicate; } else { p = com.google.gerrit.server.query.Predicate.and(filterPredicate, p); } } return (p == null) || (p.match(changeData)); }
@java.lang.Override public void addProjectWatch(final java.lang.String projectName, final java.lang.String filter, final com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.AccountProjectWatchInfo> callback) { run(callback, new com.google.gerrit.httpd.rpc.account.Action<com.google.gerrit.common.data.AccountProjectWatchInfo>() { @java.lang.Override public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.common.errors.InvalidQueryException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); if (filter != null) { try { queryBuilder.create(currentUser.get()).parse(filter); } catch (QueryParseException badFilter) { throw new com.google.gerrit.common.errors.InvalidQueryException(badFilter.getMessage(), filter); } } com.google.gerrit.reviewdb.client.AccountProjectWatch watch = new com.google.gerrit.reviewdb.client.AccountProjectWatch(new com.google.gerrit.reviewdb.client.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey, filter)); try { db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); } catch (OrmDuplicateKeyException alreadyHave) { watch = db.accountProjectWatches().get(watch.getKey()); } return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); } }); }
boolean isDisabled() { return (permittedLimit) <= 0; }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> is(java.lang.String value) { if ("starred".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(args, currentUser); } if ("watched".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsWatchedByPredicate(args, currentUser, false); } if ("visible".equalsIgnoreCase(value)) { return is_visible(); } if ("reviewed".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsReviewedPredicate(); } if ("owner".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.OwnerPredicate(self()); } if ("reviewer".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.ReviewerPredicate(self(), args.allowsDrafts); } if ("mergeable".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsMergeablePredicate(com.google.gerrit.server.query.change.ChangeQueryBuilder.schema(args.indexes), args.fillArgs); } try { return status(value); } catch (java.lang.IllegalArgumentException e) { } throw new java.lang.IllegalArgumentException(); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> parentproject(java.lang.String name) { return new com.google.gerrit.server.query.change.ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> watchedby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = parseAccount(who); java.util.List<com.google.gerrit.server.query.change.IsWatchedByPredicate> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { if ((currentUser.isIdentifiedUser()) && (id.equals(((com.google.gerrit.server.IdentifiedUser) (currentUser)).getAccountId()))) { p.add(new com.google.gerrit.server.query.change.IsWatchedByPredicate(args, currentUser, false)); } else { p.add(new com.google.gerrit.server.query.change.IsWatchedByPredicate(args, args.userFactory.create(args.db, id), true)); } } return com.google.gerrit.server.query.Predicate.or(p); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> starredby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if ("self".equals(who)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(args, currentUser); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = parseAccount(who); java.util.List<com.google.gerrit.server.query.change.IsStarredByPredicate> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { p.add(new com.google.gerrit.server.query.change.IsStarredByPredicate(args, args.userFactory.create(args.db, id))); } return com.google.gerrit.server.query.Predicate.or(p); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> has(java.lang.String value) { if ("star".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(args, currentUser); } if ("draft".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.HasDraftByPredicate(args, self()); } throw new java.lang.IllegalArgumentException(); }
private Account.Id self() { if (currentUser.isIdentifiedUser()) { return ((com.google.gerrit.server.IdentifiedUser) (currentUser)).getAccountId(); } throw new java.lang.IllegalArgumentException(); }
private int getEffectiveLimit(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(3); possibleLimits.add(permittedLimit); if ((limitFromCaller) > 0) { possibleLimits.add(limitFromCaller); } java.lang.Integer limitFromPredicate = com.google.gerrit.server.query.change.LimitPredicate.getLimit(p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } return com.google.common.collect.Ordering.natural().min(possibleLimits); }
@java.lang.Override public com.google.gerrit.common.data.AccountProjectWatchInfo run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gerrit.common.errors.InvalidQueryException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); final com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.validateFor(nameKey); if (filter != null) { try { queryBuilder.create(currentUser.get()).parse(filter); } catch (QueryParseException badFilter) { throw new com.google.gerrit.common.errors.InvalidQueryException(badFilter.getMessage(), filter); } } com.google.gerrit.reviewdb.client.AccountProjectWatch watch = new com.google.gerrit.reviewdb.client.AccountProjectWatch(new com.google.gerrit.reviewdb.client.AccountProjectWatch.Key(((com.google.gerrit.server.IdentifiedUser) (ctl.getCurrentUser())).getAccountId(), nameKey, filter)); try { db.accountProjectWatches().insert(java.util.Collections.singleton(watch)); } catch (OrmDuplicateKeyException alreadyHave) { watch = db.accountProjectWatches().get(watch.getKey()); } return new com.google.gerrit.common.data.AccountProjectWatchInfo(watch, ctl.getProject()); }
public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> is_visible() { return visibleto(currentUser); }
static void initLibrary(final com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void> cb) { if (net.codemirror.lib.Loader.isLibLoaded()) { cb.onSuccess(null); } else { net.codemirror.lib.Loader.injectCss(Lib.I.css()); net.codemirror.lib.Loader.injectScript(Lib.I.js().getSafeUri(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { net.codemirror.lib.Vim.initKeyMap(); cb.onSuccess(null); } }); } }


@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeFileApi.putContentOrMessage(revision, path, cm.getValue(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey())); } }); }
@com.google.gwt.uibinder.client.UiHandler("cancel") void onCancel(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((cm.isClean(generation)) || (com.google.gwt.user.client.Window.confirm(EditConstants.I.cancelUnsavedChanges()))) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey())); } }
private void initEditor(java.lang.String content) { java.lang.String mode = (prefs.syntaxHighlighting()) ? net.codemirror.lib.ModeInjector.getContentType(type) : null; cm = net.codemirror.lib.CodeMirror.create(editor, net.codemirror.lib.Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode)); cm.setValue(content); columnMargin = com.google.gwt.user.client.DOM.createDiv(); columnMargin.setClassName(style.columnMargin()); cm.mover().appendChild(columnMargin); }

@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); com.google.gerrit.client.JumpKeys.enable(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { adjustCodeMirrorHeight(); } }); adjustCodeMirrorHeight(); cm.refresh(); cm.focus(); }
@com.google.gwt.uibinder.client.UiHandler("cancel") void onCancel(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey())); }
private net.codemirror.lib.Configuration getConfig() { return net.codemirror.lib.Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", 4).set("lineWrapping", false).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("mode", net.codemirror.lib.ModeInjector.getContentType(type)); }
@java.lang.Override protected void preDisplay(java.lang.String content) { initEditor(content); }
private void initEditor(java.lang.String content) { cm = net.codemirror.lib.CodeMirror.create(editor, getConfig()); cm.setValue(content); }
private void initEditor(java.lang.String content) { java.lang.String mode = (prefs.syntaxHighlighting()) ? net.codemirror.lib.ModeInjector.getContentType(type) : null; cm = net.codemirror.lib.CodeMirror.create(editor, net.codemirror.lib.Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode)); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save())); cm.setValue(content); columnMargin = com.google.gwt.user.client.DOM.createDiv(); columnMargin.setClassName(style.columnMargin()); cm.mover().appendChild(columnMargin); }
@java.lang.Override public void onShowView() { super.onShowView(); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } int rest = (com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 30; cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - rest)); cm.refresh(); cm.focus(); }

void save(com.google.gerrit.client.rpc.CallbackGroup group) { if ((pendingGroup) != null) { pendingGroup.addListener(group); return; } java.lang.String message = editArea.getValue().trim(); if ((message.length()) == 0) { return; } com.google.gerrit.client.changes.CommentInfo input = com.google.gerrit.client.changes.CommentInfo.copy(comment); input.message(message); enableEdit(false); pendingGroup = group; com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo> cb = new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { enableEdit(true); pendingGroup = null; set(result); setEdit(false); if (autoClosed) { setOpen(false); } getCommentManager().setUnsaved(com.google.gerrit.client.diff.DraftBox.this, false); } @java.lang.Override public void onFailure(java.lang.Throwable e) { enableEdit(true); pendingGroup = null; super.onFailure(e); } }; if ((input.id()) == null) { com.google.gerrit.client.changes.CommentApi.createDraft(psId, input, group.add(cb)); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(psId, input.id(), input, group.add(cb)); } getCm().focus(); }



@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); com.google.gerrit.client.JumpKeys.enable(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { adjustCodeMirrorHeight(); } }); closeHandler = com.google.gwt.user.client.Window.addWindowClosingHandler(new com.google.gwt.user.client.Window.ClosingHandler() { @java.lang.Override public void onWindowClosing(com.google.gwt.user.client.Window.ClosingEvent event) { if (!(cm.isClean(generation))) { event.setMessage(EditConstants.I.closeUnsavedChanges()); } } }); generation = cm.changeGeneration(true); save.setEnabled(false); cm.on(new net.codemirror.lib.CodeMirror.ChangesHandler() { @java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm) { save.setEnabled((!(cm.isClean(generation)))); } }); adjustCodeMirrorHeight(); setLineLength(prefs.lineLength()); cm.refresh(); cm.focus(); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeFileApi.FileContent fc) { content = fc; type = fc.contentType(); injectMode(type, modeInjectorCb); }
private void loadFileContent() { com.google.gerrit.client.changes.ChangeFileApi.getContent(id, getText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeFileApi.FileContent>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeFileApi.FileContent result) { textArea.setText(result.text()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { } else { super.onFailure(caught); } } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeFileApi.FileContent result) { textArea.setText(result.text()); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeFileApi.putContentOrMessage(revision, path, cm.getValue(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(revision.getParentKey())); } }); }

@java.lang.Override protected void preDisplay(java.lang.String content) { setShowTabs(prefs.showTabs()); initEditor(content); }

private void loadFileContent() { com.google.gerrit.client.changes.ChangeFileApi.getContent(id, getText(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { textArea.setText(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { } else { super.onFailure(caught); } } }); }
public static void getContent(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String filename, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.changes.ChangeFileApi.contentEditOrPs(id, filename).get(com.google.gerrit.client.changes.ChangeFileApi.wrapper(cb)); }
public static void getContentOrMessage(com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.rpc.RestApi api = ((Patch.COMMIT_MSG.equals(path)) && ((id.get()) == 0)) ? com.google.gerrit.client.changes.ChangeFileApi.messageEdit(id) : com.google.gerrit.client.changes.ChangeFileApi.contentEditOrPs(id, path); api.get(com.google.gerrit.client.changes.ChangeFileApi.wrapper(cb)); }
@java.lang.Override public void execute() { try { cb.onSuccess(data); } finally { if (!(background)) { RpcStatus.INSTANCE.onRpcComplete(); } } }
public <T extends com.google.gwt.core.client.JavaScriptObject> void get(com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { send(com.google.gerrit.client.rpc.GET, cb); }
private <T extends com.google.gwt.core.client.JavaScriptObject> void sendJSON(com.google.gwt.http.client.RequestBuilder.Method method, com.google.gwt.core.client.JavaScriptObject content, com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { com.google.gerrit.client.rpc.RestApi.HttpCallback<T> httpCallback = new com.google.gerrit.client.rpc.RestApi.HttpCallback(background, cb); try { if (!(background)) { RpcStatus.INSTANCE.onRpcStart(); } com.google.gwt.http.client.RequestBuilder req = request(method); req.setHeader("Content-Type", com.google.gerrit.client.rpc.RestApi.JSON_UTF8); req.sendRequest(com.google.gerrit.client.rpc.RestApi.str(content), httpCallback); } catch (com.google.gwt.http.client.RequestException e) { httpCallback.onError(null, e); } }
public <T extends com.google.gwt.core.client.JavaScriptObject> void delete(com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { send(com.google.gerrit.client.rpc.DELETE, cb); }
private <T extends com.google.gwt.core.client.JavaScriptObject> void sendRaw(com.google.gwt.http.client.RequestBuilder.Method method, java.lang.String body, com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { com.google.gerrit.client.rpc.RestApi.HttpCallback<T> httpCallback = new com.google.gerrit.client.rpc.RestApi.HttpCallback(background, cb); try { if (!(background)) { RpcStatus.INSTANCE.onRpcStart(); } com.google.gwt.http.client.RequestBuilder req = request(method); req.setHeader("Content-Type", com.google.gerrit.client.rpc.RestApi.TEXT_TYPE); req.sendRequest(body, httpCallback); } catch (com.google.gwt.http.client.RequestException e) { httpCallback.onError(null, e); } }
private <T extends com.google.gwt.core.client.JavaScriptObject> void send(com.google.gwt.http.client.RequestBuilder.Method method, com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { com.google.gerrit.client.rpc.RestApi.HttpCallback<T> httpCallback = new com.google.gerrit.client.rpc.RestApi.HttpCallback(background, cb); try { if (!(background)) { RpcStatus.INSTANCE.onRpcStart(); } request(method).sendRequest(null, httpCallback); } catch (com.google.gwt.http.client.RequestException e) { httpCallback.onError(null, e); } }
public <T extends com.google.gwt.core.client.JavaScriptObject> void put(com.google.gwt.user.client.rpc.AsyncCallback<T> cb) { send(com.google.gerrit.client.rpc.PUT, cb); }
@java.lang.Override public void onSuccess(java.lang.String result) { textArea.setText(result); }
@java.lang.Override public void onSuccess(java.lang.String result) { type = result; injectMode(type, modeInjectorCb); }



@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { com.google.gwtorm.jdbc.JdbcSchema schema = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); com.google.gwtorm.schema.sql.SqlDialect dialect = schema.getDialect(); try (java.sql.Statement stmt = schema.getConnection().createStatement()) { stmt.executeUpdate("DROP INDEX changes_byProjectOpen"); if (dialect instanceof com.google.gwtorm.schema.sql.DialectPostgreSQL) { stmt.executeUpdate(("CREATE INDEX changes_byProjectOpen" + (" ON changes (dest_project_name, last_updated_on)" + " WHERE open = 'Y'"))); } else { stmt.executeUpdate(("CREATE INDEX changes_byProjectOpen" + " ON changes (open, dest_project_name, last_updated_on)")); } } }
@java.lang.Override protected void applyDataRowStyle(final int row) { super.applyDataRowStyle(row); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter(); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_STAR, Gerrit.RESOURCES.css().iconCell()); for (int i = com.google.gerrit.client.changes.ChangeTable2.C_ID; i < (columns); i++) { fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell()); } fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT()); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_STATUS, Gerrit.RESOURCES.css().cSTATUS()); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_OWNER, Gerrit.RESOURCES.css().cOWNER()); fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate()); if ((!(com.google.gerrit.client.Gerrit.isSignedIn())) || (!(com.google.gerrit.client.Gerrit.getUserAccount().getGeneralPreferences().isLegacycidInChangeTable()))) { fmt.addStyleName(row, com.google.gerrit.client.changes.ChangeTable2.C_ID, Gerrit.RESOURCES.css().dataCellHidden()); } int i = com.google.gerrit.client.changes.ChangeTable2.C_SIZE; fmt.addStyleName(row, (i++), Gerrit.RESOURCES.css().cSIZE()); for (; i < (columns); i++) { fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL()); } }
private void initEditMode(com.google.gerrit.client.changes.ChangeInfo info) { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (info.status().isOpen())) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revision(revision); if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); addFileAction = new com.google.gerrit.client.change.AddFileAction(changeId, info.revision(revision), style, addFile); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } } }
@com.google.gwt.uibinder.client.UiHandler("reviewMode") void onReviewMode(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { fileTableMode = FileTable.Mode.REVIEW; refreshFileTable(); editMode.setVisible(true); addFile.setVisible(false); reviewMode.setVisible(false); }
@com.google.gwt.uibinder.client.UiHandler("editMode") void onEditMode(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { fileTableMode = FileTable.Mode.EDIT; refreshFileTable(); editMode.setVisible(false); addFile.setVisible(true); reviewMode.setVisible(true); }
private void initRevisionsAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { int currentPatchSet; if (((info.current_revision()) != null) && (info.revisions().containsKey(info.current_revision()))) { currentPatchSet = info.revision(info.current_revision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } java.lang.String currentlyViewedPatchSet; if (info.revision(revision).id().equals("edit")) { currentlyViewedPatchSet = Resources.M.editPatchSet(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.findEditParent(info.revisions().values())); currentPatchSet = (info.revisions().values().length()) - 1; } else { currentlyViewedPatchSet = info.revision(revision).id(); } patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets); }



private void initEditMode(com.google.gerrit.client.changes.ChangeInfo info) { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (info.status().isOpen())) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev = info.revision(revision); if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); addFileAction = new com.google.gerrit.client.change.AddFileAction(changeId, info.revision(revision), style, addFile); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } boolean hasEdit = (info.has_edit()) && (info.current_revision().equals(info.edit().name())); reply.setVisible((!hasEdit)); quickApprove.setVisible((!hasEdit)); } }











@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.api.changes.Changes.class).to(com.google.gerrit.server.api.changes.ChangesImpl.class); factory(ChangeApiImpl.Factory.class); factory(RevisionApiImpl.Factory.class); factory(FileApiImpl.Factory.class); }
protected java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchLineComment> listComments(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return db.get().patchComments().publishedByPatchSet(rsrc.getPatchSet().getId()); }

private com.google.gerrit.reviewdb.client.PatchLineComment update(com.google.gerrit.reviewdb.client.PatchLineComment e, com.google.gerrit.server.change.PutDraft.Input in) { if ((in.side) != null) { e.setSide(((in.side) == (com.google.gerrit.common.changes.Side.PARENT) ? ((short) (0)) : ((short) (1)))); } if ((in.inReplyTo) != null) { e.setParentUuid(com.google.gerrit.extensions.restapi.Url.decode(in.inReplyTo)); } e.setMessage(in.message.trim()); if (((in.range) != null) || ((in.line) != null)) { e.setRange(in.range); e.setLine(((in.range) != null ? in.range.getEndLine() : in.line)); } e.setWrittenOn(com.google.gerrit.server.util.TimeUtil.nowTs()); return e; }

private static void assertComment(com.google.gerrit.reviewdb.client.PatchLineComment plc, com.google.gerrit.server.change.CommentInfo ci) { assertEquals(plc.getKey().get(), ci.id); assertEquals(plc.getParentUuid(), ci.inReplyTo); assertEquals(plc.getMessage(), ci.message); assertNotNull(ci.author); assertEquals(plc.getAuthor(), ci.author._id); assertEquals(plc.getLine(), ((int) (ci.line))); assertEquals(((plc.getSide()) == 0 ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION), com.google.common.base.Objects.firstNonNull(ci.side, Side.REVISION)); assertEquals(plc.getWrittenOn(), ci.updated); assertEquals(plc.getRange(), ci.range); }
private static com.google.gerrit.reviewdb.client.PatchLineComment newPatchLineComment(com.google.gerrit.reviewdb.client.PatchSet.Id psId, java.lang.String uuid, java.lang.String inReplyToUuid, java.lang.String filename, com.google.gerrit.common.changes.Side side, int line, com.google.gerrit.reviewdb.client.Account.Id authorId, long millis, java.lang.String message, com.google.gerrit.reviewdb.client.CommentRange range) { com.google.gerrit.reviewdb.client.Patch.Key p = new com.google.gerrit.reviewdb.client.Patch.Key(psId, filename); com.google.gerrit.reviewdb.client.PatchLineComment.Key id = new com.google.gerrit.reviewdb.client.PatchLineComment.Key(p, uuid); com.google.gerrit.reviewdb.client.PatchLineComment plc = new com.google.gerrit.reviewdb.client.PatchLineComment(id, line, authorId, inReplyToUuid, com.google.gerrit.server.util.TimeUtil.nowTs()); plc.setMessage(message); plc.setRange(range); plc.setSide((side == (com.google.gerrit.common.changes.Side.PARENT) ? ((short) (0)) : ((short) (1)))); plc.setStatus(Status.PUBLISHED); plc.setWrittenOn(new java.sql.Timestamp(millis)); return plc; }










@org.junit.Test public void testListIndexes() throws com.google.gwtorm.server.OrmException, java.sql.SQLException { assertTrue(dialect.listTables(db).isEmpty()); execute("CREATE TABLE foo (cnt INT, bar INT, baz INT)"); execute("CREATE UNIQUE INDEX FOO_PRIMARY_IND ON foo(cnt)"); execute("CREATE INDEX FOO_SECOND_IND ON foo(bar, baz)"); java.util.Set<java.lang.String> s = dialect.listIndexes(db, "foo"); assertEquals(2, s.size()); assertTrue(s.contains("foo_primary_ind")); assertTrue(s.contains("foo_second_ind")); }
static com.google.gerrit.server.schema.Schema_77.LegacyLabelTypes getLegacyTypes(com.google.gerrit.reviewdb.server.ReviewDb db) throws java.sql.SQLException { java.util.List<com.google.gerrit.server.schema.Schema_77.LegacyLabelType> types = com.google.common.collect.Lists.newArrayListWithCapacity(2); java.sql.Statement catStmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement(); try { java.sql.ResultSet catRs = catStmt.executeQuery(("SELECT category_id, name, function_name, copy_min_score" + (" FROM approval_categories" + " ORDER BY position, name"))); java.sql.PreparedStatement valStmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().prepareStatement(("SELECT value, name" + (" FROM approval_category_values" + " WHERE category_id = ?"))); try { while (catRs.next()) { java.lang.String id = catRs.getString("category_id"); valStmt.setString(1, id); java.util.List<com.google.gerrit.common.data.LabelValue> values = com.google.common.collect.Lists.newArrayListWithCapacity(5); java.sql.ResultSet valRs = valStmt.executeQuery(); while (valRs.next()) { values.add(new com.google.gerrit.common.data.LabelValue(valRs.getShort("value"), valRs.getString("name"))); } com.google.gerrit.server.schema.Schema_77.LegacyLabelType type = new com.google.gerrit.server.schema.Schema_77.LegacyLabelType(com.google.gerrit.server.schema.Schema_77.getLabelName(catRs.getString("name")), values); type.setId(id); type.setFunctionName(catRs.getString("function_name")); type.setCopyMinScore("Y".equals(catRs.getString("copy_min_score"))); types.add(type); } } finally { valStmt.close(); } } finally { catStmt.close(); } return new com.google.gerrit.server.schema.Schema_77.LegacyLabelTypes(types); }
private java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.Id> scanSystemGroups(com.google.gerrit.reviewdb.server.ReviewDb db) throws java.sql.SQLException { com.google.gwtorm.jdbc.JdbcSchema s = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); java.sql.Statement stmt = s.getConnection().createStatement(); try { java.sql.ResultSet rs = stmt.executeQuery("SELECT group_id FROM account_groups WHERE group_type = 'SYSTEM'"); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.Id> ids = new java.util.HashSet<>(); while (rs.next()) { ids.add(new com.google.gerrit.reviewdb.client.AccountGroup.Id(rs.getInt(1))); } return ids; } finally { stmt.close(); } }
private java.io.File getSiteFromReviewDb(java.sql.Connection conn) { try { java.sql.Statement stmt = conn.createStatement(); try { java.sql.ResultSet rs = stmt.executeQuery("SELECT site_path FROM system_config"); if (rs.next()) { return new java.io.File(rs.getString(1)); } } finally { stmt.close(); } return null; } catch (java.sql.SQLException e) { return null; } }
public com.google.gerrit.server.git.CodeReviewCommit run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { refLogIdent = null; return _run(mergeTip, toMerge); }
static void call(com.google.gwt.user.client.ui.Button b, final com.google.gerrit.client.changes.ChangeInfo info, final java.lang.String revision, java.lang.String project, final java.lang.String commitMessage) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(b, new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); if (info.status().isClosed()) { message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision)); } else { message.setText(commitMessage.trim()); } } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.legacy_id().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
static void invoke(com.google.gerrit.client.changes.ChangeInfo change, com.google.gerrit.client.actions.ActionInfo action, com.google.gerrit.client.rpc.RestApi api) { final com.google.gerrit.reviewdb.client.Change.Id id = change.legacy_id(); com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb = new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject msg) { if (com.google.gerrit.client.rpc.NativeString.is(msg)) { com.google.gerrit.client.rpc.NativeString str = ((com.google.gerrit.client.rpc.NativeString) (msg)); if (!(str.asString().isEmpty())) { com.google.gwt.user.client.Window.alert(str.asString()); } } com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(id)); } }; if ("PUT".equalsIgnoreCase(action.method())) { api.put(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } else if ("DELETE".equalsIgnoreCase(action.method())) { api.delete(cb); } else { api.post(com.google.gwt.core.client.JavaScriptObject.createObject(), cb); } }
static void call(com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, java.lang.String project, final java.lang.String commitSubject) { b.setEnabled(false); new com.google.gerrit.client.ui.ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) { { sendButton.setText(Util.C.buttonRevertChangeSend()); message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(id)); }
private java.lang.Runnable upToChange(final boolean openReplyBox) { return new java.lang.Runnable() { public void run() { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(changeId, rev), new com.google.gerrit.client.change.ChangeScreen2(changeId, rev, openReplyBox)); } }; }
static void call(final com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision) { com.google.gerrit.client.changes.ChangeApi.submit(id.get(), revision, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.SubmitInfo>() { public void onSuccess(com.google.gerrit.client.changes.SubmitInfo result) { redisplay(); } public void onFailure(java.lang.Throwable err) { if (com.google.gerrit.client.changes.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.changes.SubmitFailureDialog(err.getMessage()).center(); redisplay(); } else { super.onFailure(err); } } private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange2(id)); } }); }
private void initEditor(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> file) { net.codemirror.mode.ModeInfo mode = null; java.lang.String content = ""; if (file != null) { content = file.getResult().asString(); if (prefs.syntaxHighlighting()) { mode = net.codemirror.mode.ModeInfo.findMode(file.getContentType(), path); } } cm = net.codemirror.lib.CodeMirror.create(editor, net.codemirror.lib.Configuration.create().set("value", content).set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", (mode != null ? mode.mode() : null))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save())); }
@java.lang.Override public void onShowView() { super.onShowView(); com.google.gwt.user.client.Window.enableScrolling(false); com.google.gerrit.client.JumpKeys.enable(false); if (prefs.hideTopMenu()) { com.google.gerrit.client.Gerrit.setHeaderVisible(false); } resizeHandler = com.google.gwt.user.client.Window.addResizeHandler(new com.google.gwt.event.logical.shared.ResizeHandler() { @java.lang.Override public void onResize(com.google.gwt.event.logical.shared.ResizeEvent event) { cm.adjustHeight(header.getOffsetHeight()); } }); closeHandler = com.google.gwt.user.client.Window.addWindowClosingHandler(new com.google.gwt.user.client.Window.ClosingHandler() { @java.lang.Override public void onWindowClosing(com.google.gwt.user.client.Window.ClosingEvent event) { if (!(cm.isClean(generation))) { event.setMessage(EditConstants.I.closeUnsavedChanges()); } } }); generation = cm.changeGeneration(true); setClean(true); cm.on(new net.codemirror.lib.CodeMirror.ChangesHandler() { @java.lang.Override public void handle(net.codemirror.lib.CodeMirror cm) { setClean(cm.isClean(generation)); } }); cm.adjustHeight(header.getOffsetHeight()); cm.on("cursorActivity", updateCursorPosition()); cm.extras().showTabs(prefs.showTabs()); cm.extras().lineLength((Patch.COMMIT_MSG.equals(path) ? 72 : prefs.lineLength())); cm.refresh(); cm.focus(); if ((com.google.gerrit.client.editor.EditScreen.scrollToLine) != 0) { cm.scrollToLine(com.google.gerrit.client.editor.EditScreen.scrollToLine); com.google.gerrit.client.editor.EditScreen.scrollToLine = 0; } updateActiveLine(); }

private java.util.List<com.google.gerrit.reviewdb.client.Change> parseChange(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_LEGACY_ID.matcher(value).matches()) { return java.util.Collections.singletonList(args.db.get().changes().get(Change.Id.parse(value))); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_CHANGE_ID.matcher(value).matches()) { com.google.gerrit.reviewdb.client.Change.Key a = new com.google.gerrit.reviewdb.client.Change.Key(com.google.gerrit.server.query.change.ChangeQueryBuilder.parseChangeId(value)); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = args.db.get().changes().byKeyRange(a, a.max()).toList(); if (changes.isEmpty()) { throw error((("Change " + value) + " not found")); } return changes; } throw error((("Change " + value) + " not found")); }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> change(java.lang.String query) throws com.google.gerrit.server.query.QueryParseException { if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_LEGACY_ID.matcher(query).matches()) { return new com.google.gerrit.server.query.change.LegacyChangeIdPredicate(Change.Id.parse(query)); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.PAT_CHANGE_ID.matcher(query).matches()) { return new com.google.gerrit.server.query.change.ChangeIdPredicate(com.google.gerrit.server.query.change.ChangeQueryBuilder.parseChangeId(query)); } com.google.common.base.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(query); if (triplet.isPresent()) { return com.google.gerrit.server.query.Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new com.google.gerrit.server.query.change.ChangeIdPredicate(com.google.gerrit.server.query.change.ChangeQueryBuilder.parseChangeId(triplet.get().id().get()))); } throw new com.google.gerrit.server.query.QueryParseException("Invalid change format"); }

@java.lang.Override public void run() { final java.util.HashSet<com.google.gerrit.reviewdb.client.Branch.NameKey> pending = new java.util.HashSet<>(); try { final com.google.gerrit.reviewdb.server.ReviewDb c = schema.open(); try { for (final com.google.gerrit.reviewdb.client.Change change : c.changes().allSubmitted()) { pending.add(change.getDest()); } } finally { c.close(); } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.ReloadSubmitQueueOp.log.error("Cannot reload MergeQueue", e); } for (final com.google.gerrit.reviewdb.client.Branch.NameKey branch : pending) { mergeQueue.schedule(branch); } }

@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.from", value = "2") public void suggestReviewersNoResult3() throws java.io.IOException, java.lang.Exception, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6); assertEquals(reviewers.size(), 0); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.fullTextSearch", value = "true") public void suggestReviewersFullTextSearch() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5); assertEquals(4, reviewers.size()); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.accounts", value = "false") public void suggestReviewersNoResult1() throws java.io.IOException, java.lang.Exception, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6); assertEquals(reviewers.size(), 0); }
@org.junit.Test public void suggestReviewersChange() throws java.io.IOException, java.lang.Exception, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6); assertEquals(reviewers.size(), 6); reviewers = suggestReviewers(changeId, "u", 5); assertEquals(reviewers.size(), 5); reviewers = suggestReviewers(changeId, "users3", 10); assertEquals(reviewers.size(), 1); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersSameGroupVisibility() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(changeId, "user2", 2); assertEquals(1, reviewers.size()); assertEquals("User2", com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name); reviewers = suggestReviewers(new com.google.gerrit.acceptance.RestSession(server, user1), changeId, "user2", 2); assertTrue(reviewers.isEmpty()); reviewers = suggestReviewers(new com.google.gerrit.acceptance.RestSession(server, user2), changeId, "user2", 2); assertEquals(1, reviewers.size()); assertEquals("User2", com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name); reviewers = suggestReviewers(new com.google.gerrit.acceptance.RestSession(server, user3), changeId, "user2", 2); assertEquals(1, reviewers.size()); assertEquals("User2", com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name); }

@org.junit.Test @com.google.gerrit.acceptance.GerritConfigs({ @com.google.gerrit.acceptance.GerritConfig(name = "suggest.accounts", value = "true"), @com.google.gerrit.acceptance.GerritConfig(name = "suggest.from", value = "1"), @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "NONE") }) public void suggestReviewersNoResult2() throws java.io.IOException, java.lang.Exception, org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6); assertEquals(reviewers.size(), 0); }

@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2") public void suggestReviewersMaxNbrSuggestions() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5); assertEquals(2, reviewers.size()); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersViewAllAccounts() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(new com.google.gerrit.acceptance.RestSession(server, user1), changeId, "user2", 2); assertTrue(reviewers.isEmpty()); grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1); reviewers = suggestReviewers(new com.google.gerrit.acceptance.RestSession(server, user1), changeId, "user2", 2); assertEquals(1, reviewers.size()); assertEquals("User2", com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name); }


@org.junit.Test @com.google.gerrit.acceptance.GerritConfigs({ @com.google.gerrit.acceptance.GerritConfig(name = "suggest.fulltextsearch", value = "true"), @com.google.gerrit.acceptance.GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") }) public void suggestReviewersFullTextSearchLimitMaxMatches() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3); assertEquals(2, reviewers.size()); }
private int getEffectiveLimit(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(3); possibleLimits.add(getPermittedLimit()); if ((limitFromCaller) > 0) { possibleLimits.add(limitFromCaller); } java.lang.Integer limitFromPredicate = com.google.gerrit.server.query.change.LimitPredicate.getLimit(p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } return com.google.common.collect.Ordering.natural().min(possibleLimits); }
@java.lang.Override public void onSuccess(java.lang.Void result) { net.codemirror.lib.Vim.initKeyMap(); }
static void initLibrary(final com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void> cb) { if (net.codemirror.lib.Loader.isLibLoaded()) { cb.onSuccess(null); return; } com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); net.codemirror.lib.Loader.injectCss(Lib.I.css(), group.<java.lang.Void>addEmpty()); net.codemirror.lib.Loader.injectScript(Lib.I.js().getSafeUri(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { net.codemirror.lib.Vim.initKeyMap(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); group.addListener(cb); group.done(); }

public com.google.gerrit.reviewdb.client.Change submit(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.IdentifiedUser caller, boolean force) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords = checkSubmitRule(rsrc, force); final java.sql.Timestamp timestamp = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp); update.submit(submitRecords); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp); batch.write(update, new org.eclipse.jgit.lib.CommitBuilder()); change = submitToDatabase(db, change, timestamp); if (change == null) { return null; } db.commit(); } finally { db.rollback(); } indexer.index(db, change); return change; }
@java.lang.Override protected com.google.gerrit.server.git.CodeReviewCommit _run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); if (mergeTip == null) { mergeTip = toMerge.remove(0); } mergeTip = args.mergeUtil.getFirstFastForward(mergeTip, args.rw, toMerge); while (!(toMerge.isEmpty())) { mergeTip = args.mergeUtil.mergeOneCommit(args.serverIdent.get(), args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip, toMerge.remove(0)); } final com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip, args.alreadyAccepted); setRefLogIdent(submitApproval); return mergeTip; }

protected abstract com.google.gerrit.server.git.CodeReviewCommit _run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException;
@java.lang.Override protected com.google.gerrit.server.git.CodeReviewCommit _run(final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); final com.google.gerrit.server.git.CodeReviewCommit newMergeTip = args.mergeUtil.getFirstFastForward(mergeTip, args.rw, toMerge); while (!(toMerge.isEmpty())) { final com.google.gerrit.server.git.CodeReviewCommit n = toMerge.remove(0); n.setStatusCode(CommitMergeStatus.NOT_FAST_FORWARD); } final com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted); setRefLogIdent(submitApproval); return newMergeTip; }

public final com.google.gerrit.server.git.CodeReviewCommit run(final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { refLogIdent = null; return _run(mergeTip, toMerge); }
@java.lang.Override public void doChangeMergedHook(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.Account account, final com.google.gerrit.reviewdb.client.PatchSet patchSet, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.events.ChangeMergedEvent event = new com.google.gerrit.server.events.ChangeMergedEvent(); final com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); fireEvent(change, event, db); final java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); runHook(change.getProject(), changeMergedHook, args); }
@java.lang.Override protected com.google.gerrit.server.git.CodeReviewCommit _run(com.google.gerrit.server.git.CodeReviewCommit mergeTip, java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); if (mergeTip == null) { mergeTip = toMerge.remove(0); } while (!(toMerge.isEmpty())) { mergeTip = args.mergeUtil.mergeOneCommit(args.serverIdent.get(), args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip, toMerge.remove(0)); } final com.google.gerrit.reviewdb.client.PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip, args.alreadyAccepted); setRefLogIdent(submitApproval); return mergeTip; }

@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }

public static void createChange(java.lang.String project, java.lang.String branch, java.lang.String subject, java.lang.String base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.CreateChangeInput input = com.google.gerrit.client.changes.ChangeApi.CreateChangeInput.create(); input.project(com.google.gerrit.client.changes.ChangeApi.emptyToNull(project)); input.branch(com.google.gerrit.client.changes.ChangeApi.emptyToNull(branch)); input.subject(com.google.gerrit.client.changes.ChangeApi.emptyToNull(subject)); input.base_change(com.google.gerrit.client.changes.ChangeApi.emptyToNull(base)); new com.google.gerrit.client.rpc.RestApi("/changes/").post(input, cb); }
static void call(com.google.gwt.user.client.ui.Button b, final java.lang.String project) { b.setEnabled(false); new com.google.gerrit.client.ui.CreateChangeDialog(new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(Util.C.buttonCreate()); message.setText(Util.C.buttonCreateDescription()); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
private org.eclipse.jgit.revwalk.RevCommit updateRef(org.eclipse.jgit.lib.AnyObjectId oldId, org.eclipse.jgit.lib.AnyObjectId newId, java.lang.String refName) throws java.io.IOException { org.eclipse.jgit.lib.BatchRefUpdate bru = update.getBatch(); if (bru != null) { bru.addCommand(new org.eclipse.jgit.transport.ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName)); inserter.flush(); revision = rw.parseCommit(newId); return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(refName); ru.setExpectedOldObjectId(oldId); ru.setNewObjectId(src); ru.disableRefLog(); inserter.flush(); org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : case FAST_FORWARD : revision = rw.parseCommit(ru.getNewObjectId()); update.fireGitRefUpdatedEvent(ru); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }


private org.eclipse.jgit.revwalk.RevCommit updateRef(org.eclipse.jgit.lib.AnyObjectId oldId, org.eclipse.jgit.lib.AnyObjectId newId, java.lang.String refName) throws java.io.IOException { org.eclipse.jgit.lib.BatchRefUpdate bru = update.getBatch(); if (bru != null) { bru.addCommand(new org.eclipse.jgit.transport.ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName)); inserter.flush(); revision = rw.parseCommit(newId); return revision; } org.eclipse.jgit.lib.RefUpdate ru = db.updateRef(refName); ru.setExpectedOldObjectId(oldId); ru.setNewObjectId(src); ru.setRefLogIdent(update.getCommitBuilder().getAuthor()); try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.StringReader(update.getCommitBuilder().getMessage()))) { ru.setRefLogMessage(("commit: " + (reader.readLine())), true); } inserter.flush(); org.eclipse.jgit.lib.RefUpdate.Result result = ru.update(); switch (result) { case NEW : case FAST_FORWARD : revision = rw.parseCommit(ru.getNewObjectId()); update.fireGitRefUpdatedEvent(ru); return revision; default : throw new java.io.IOException(((((("Cannot update " + (ru.getName())) + " in ") + (db.getDirectory())) + ": ") + (ru.getResult()))); } }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); checkNotSlaveMode(); disableLuceneAutomaticCommit(); if ((version) == null) { version = com.google.gerrit.server.index.ChangeSchemas.getLatest().getVersion(); } com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); index = sysInjector.getInstance(com.google.gerrit.server.index.IndexCollection.class).getSearchIndex(); int result = 0; try { index.markReady(false); index.deleteAll(); result = indexAll(); index.markReady(true); } catch (java.lang.Exception e) { throw die(e.getMessage(), e); } sysManager.stop(); dbManager.stop(); return result; }


@java.lang.Override public boolean equals(java.lang.Object other) { if (other instanceof com.google.gerrit.server.project.PermissionCollection.SeenRule) { com.google.gerrit.server.project.PermissionCollection.SeenRule a = this; com.google.gerrit.server.project.PermissionCollection.SeenRule b = ((com.google.gerrit.server.project.PermissionCollection.SeenRule) (other)); return ((a.refPattern.equals(b.refPattern)) && (a.permissionName.equals(b.permissionName))) && (eq(a.group, b.group)); } return false; }

@java.lang.Override public int hashCode() { int hc = refPattern.hashCode(); hc = (hc * 31) + (permissionName.hashCode()); if ((group) != null) { hc = (hc * 31) + (group.hashCode()); } return hc; }
public static com.google.gerrit.sshd.CommandName named(final java.lang.String name) { return new com.google.gerrit.sshd.CommandName() { @java.lang.Override public java.lang.String value() { return name; } @java.lang.Override public java.lang.Class<? extends java.lang.annotation.Annotation> annotationType() { return com.google.gerrit.sshd.CommandName.class; } @java.lang.Override public int hashCode() { return (127 * ("value".hashCode())) ^ (value().hashCode()); } @java.lang.Override public boolean equals(final java.lang.Object obj) { return (obj instanceof com.google.gerrit.sshd.CommandName) && (value().equals(((com.google.gerrit.sshd.CommandName) (obj)).value())); } @java.lang.Override public java.lang.String toString() { return ((("@" + (com.google.gerrit.sshd.CommandName.class.getName())) + "(value=") + (value())) + ")"; } }; }
private static boolean needsSuperSerializer(com.google.gwt.core.ext.typeinfo.JClassType type) { type = type.getSuperclass(); while (!(java.lang.Object.class.getName().equals(type.getQualifiedSourceName()))) { if ((com.google.gwtjsonrpc.rebind.SerializerCreator.sortFields(type).length) > 0) { return true; } type = type.getSuperclass(); } return false; }
public boolean canCherryPick(final com.google.gerrit.server.git.MergeSorter mergeSorter, final org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final org.eclipse.jgit.revwalk.RevWalk rw, final com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { if (mergeTip == null) { return true; } if ((toMerge.getParentCount()) == 0) { return false; } if ((toMerge.getParentCount()) == 1) { try { org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo)); m.setBase(toMerge.getParent(0)); return m.merge(mergeTip, toMerge); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (toMerge.name())), e); } } return (canFastForward(mergeSorter, mergeTip, rw, toMerge)) || (canMerge(mergeSorter, repo, mergeTip, toMerge)); }
public boolean canMerge(final com.google.gerrit.server.git.MergeSorter mergeSorter, final org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { if (hasMissingDependencies(mergeSorter, toMerge)) { return false; } org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo)); try { return m.merge(new org.eclipse.jgit.lib.AnyObjectId[]{ mergeTip, toMerge }); } catch (org.eclipse.jgit.errors.NoMergeBaseException e) { return false; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (toMerge.name())), e); } }
public org.eclipse.jgit.revwalk.RevCommit createCherryPickFromCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.revwalk.RevCommit mergeTip, org.eclipse.jgit.revwalk.RevCommit originalCommit, org.eclipse.jgit.lib.PersonIdent cherryPickCommitterIdent, java.lang.String commitMsg, org.eclipse.jgit.revwalk.RevWalk rw) throws java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { final org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, inserter); m.setBase(originalCommit.getParent(0)); if (m.merge(mergeTip, originalCommit)) { final org.eclipse.jgit.lib.CommitBuilder mergeCommit = new org.eclipse.jgit.lib.CommitBuilder(); mergeCommit.setTreeId(m.getResultTreeId()); mergeCommit.setParentId(mergeTip); mergeCommit.setAuthor(originalCommit.getAuthorIdent()); mergeCommit.setCommitter(cherryPickCommitterIdent); mergeCommit.setMessage(commitMsg); final org.eclipse.jgit.lib.ObjectId id = commit(inserter, mergeCommit); return rw.parseCommit(id); } else { return null; } }
public org.eclipse.jgit.merge.ThreeWayMerger newThreeWayMerger(final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.lib.ObjectInserter inserter) { org.eclipse.jgit.merge.ThreeWayMerger m; if (useContentMerge) { if (useRecursiveMerge) { m = MergeStrategy.RECURSIVE.newMerger(repo, true); } else { m = MergeStrategy.RESOLVE.newMerger(repo, true); } } else { m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(repo); } m.setObjectInserter(new org.eclipse.jgit.lib.ObjectInserter.Filter() { @java.lang.Override protected org.eclipse.jgit.lib.ObjectInserter delegate() { return inserter; } @java.lang.Override public void flush() { } @java.lang.Override public void release() { } }); return m; }
public java.util.List<com.google.gerrit.server.query.change.ChangeData> byTopic(java.lang.String topic) throws com.google.gwtorm.server.OrmException { return query(com.google.gerrit.server.query.change.InternalChangeQuery.topic(topic)); }


private void renderLinks() { for (com.google.gerrit.client.ui.InlineHyperlink link : getLinks()) { linkPanel.add(link); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> fc) { content = fc; if (prefs.syntaxHighlighting()) { injectMode(fc.getContentType(), modeCallback); } else { modeCallback.onSuccess(null); } }
private void initEditor(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> file) { net.codemirror.mode.ModeInfo mode = null; java.lang.String content = ""; if (file != null) { content = file.getResult().asString(); if (prefs.syntaxHighlighting()) { mode = net.codemirror.mode.ModeInfo.findMode(file.getContentType(), path); } } renderLinks(); cm = net.codemirror.lib.CodeMirror.create(editor, net.codemirror.lib.Configuration.create().set("value", content).set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", (mode != null ? mode.mode() : null))); cm.addKeyMap(net.codemirror.lib.KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save())); }
@java.lang.Override protected void preDisplay(java.lang.Void result) { initEditor(content); content = null; }

@java.lang.Override public void onFailure(java.lang.Throwable e) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(e)) { content = null; modeCallback.onSuccess(null); } else { com.google.gerrit.client.rpc.GerritCallback.showFailure(e); } }
private void fireEventForUnrestrictedListeners(final com.google.gerrit.server.events.ChangeEvent event) { for (com.google.gerrit.common.ChangeListener listener : unrestrictedListeners) { listener.onChangeEvent(event); } }
private void fireEvent(com.google.gerrit.reviewdb.client.Branch.NameKey branchName, final com.google.gerrit.server.events.ChangeEvent event) { for (com.google.gerrit.common.ChangeHookRunner.ChangeListenerHolder holder : listeners.values()) { if (isVisibleTo(branchName, holder.user)) { holder.listener.onChangeEvent(event); } } fireEventForUnrestrictedListeners(event); }
private void fireEvent(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.server.events.ChangeEvent event, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.common.ChangeHookRunner.ChangeListenerHolder holder : listeners.values()) { if (isVisibleTo(change, holder.user, db)) { holder.listener.onChangeEvent(event); } } fireEventForUnrestrictedListeners(event); }
private void writeEvents() { int processed = 0; while (processed < (com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE)) { if ((java.lang.Thread.interrupted()) || (stdout.checkError())) { hooks.removeChangeListener(listener); flush(); onExit(0); return; } if (dropped) { write(droppedOutputEvent); dropped = false; } final com.google.gerrit.server.events.ChangeEvent event = poll(); if (event == null) { break; } write(event); processed++; } flush(); if ((com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE) <= processed) { synchronized(taskLock) { task = pool.submit(writer); } } }
private com.google.gerrit.server.git.strategy.SubmitStrategy createStrategy(com.google.gerrit.extensions.common.SubmitType submitType) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch); }
public java.lang.String insertCss(java.lang.String html, java.lang.String css1, java.lang.String css2) { if ((html == null) || ((css1 == null) && (css2 == null))) { return html; } int p = html.lastIndexOf("</head>"); if (p > 0) { java.lang.StringBuilder b = new java.lang.StringBuilder(); b.append(html.substring(0, p)); if (css1 != null) { b.append("<style type=\"text/css\">\n"); b.append(css1); b.append("</style>\n"); } if (css2 != null) { b.append("<style type=\"text/css\">\n"); b.append(css2); b.append("</style>\n"); } b.append(html.substring(p)); return b.toString(); } else { return html; } }

@org.junit.Test public void createDraftChangeNotAllowed() throws java.lang.Exception { assume().that(isAllowDrafts()).isFalse(); com.google.gerrit.extensions.common.ChangeInfo ci = newChangeInfo(ChangeStatus.DRAFT); com.google.gerrit.acceptance.RestResponse r = adminSession.post("/changes/", ci); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_METHOD_NOT_ALLOWED); assertThat(r.getEntityContent()).contains("cannot upload drafts"); }
@org.junit.Test public void createDraftChangeWhenDraftsNotAllowed() throws java.lang.Exception { assume().that(isAllowDrafts()).isFalse(); com.google.gerrit.acceptance.PushOneCommit.Result r = createDraftChange(); r.assertErrorStatus("cannot upload drafts"); }



@org.junit.Test public void deleteDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, 1, "comment 1"); com.google.gerrit.extensions.common.CommentInfo returned = addDraft(changeId, revId, comment); deleteDraft(changeId, revId, returned.id); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> drafts = getDraftComments(changeId, revId); assertThat(drafts).isEmpty(); }
@org.junit.Test public void getDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, 1, "comment 1"); com.google.gerrit.extensions.common.CommentInfo returned = addDraft(changeId, revId, comment); com.google.gerrit.extensions.common.CommentInfo actual = getDraftComment(changeId, revId, returned.id); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
@org.junit.Test public void createDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, 1, "comment 1"); addDraft(changeId, revId, comment); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = getDraftComments(changeId, revId); assertThat(result).hasSize(1); com.google.gerrit.extensions.common.CommentInfo actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
@org.junit.Test public void postComment() throws java.lang.Exception { java.lang.String file = "file"; java.lang.String contents = "contents"; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to(git, "refs/for/master"); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); ReviewInput input = new ReviewInput(); ReviewInput.CommentInput comment = newCommentInfo(file, Side.REVISION, 1, "comment 1"); input.comments = new java.util.HashMap(); input.comments.put(comment.path, Lists.newArrayList(comment)); revision(r).review(input); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = getPublishedComments(changeId, revId); assertThat(result).isNotEmpty(); com.google.gerrit.extensions.common.CommentInfo actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
@org.junit.Test public void putDraft() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); java.lang.String changeId = r.getChangeId(); java.lang.String revId = r.getCommit().getName(); com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, 1, "comment 1"); addDraft(changeId, revId, comment); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = getDraftComments(changeId, revId); com.google.gerrit.extensions.common.CommentInfo actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); java.lang.String uuid = actual.id; comment.message = "updated comment 1"; updateDraft(changeId, revId, comment, uuid); result = getDraftComments(changeId, revId); actual = com.google.common.collect.Iterables.getOnlyElement(result.get(comment.path)); com.google.gerrit.acceptance.server.change.CommentsIT.assertCommentInfo(comment, actual); }
private ReviewInput.CommentInput newCommentInfo(java.lang.String path, com.google.gerrit.extensions.common.Side side, int line, java.lang.String message) { com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput input = new com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput(); input.path = path; input.side = side; input.line = line; input.message = message; return input; }
@java.lang.Override public void foreach(com.google.gerrit.pgm.Processor processor) throws java.io.FileNotFoundException, java.io.IOException { java.io.File myWar = com.google.gerrit.launcher.GerritLauncher.getDistributionArchive(); if (myWar.isFile()) { try (java.util.zip.ZipFile zf = new java.util.zip.ZipFile(myWar)) { java.util.Enumeration<? extends java.util.zip.ZipEntry> e = zf.entries(); while (e.hasMoreElements()) { java.util.zip.ZipEntry ze = e.nextElement(); if (ze.isDirectory()) { continue; } if ((ze.getName().startsWith(com.google.gerrit.pgm.PLUGIN_DIR)) && (ze.getName().endsWith(com.google.gerrit.pgm.JAR))) { java.lang.String pluginJarName = new java.io.File(ze.getName()).getName(); java.lang.String pluginName = pluginJarName.substring(0, ((pluginJarName.length()) - (com.google.gerrit.pgm.JAR.length()))); final java.io.InputStream in = zf.getInputStream(ze); processor.process(pluginName, in); } } } } }
@java.lang.Override public org.eclipse.jgit.notes.Note merge(org.eclipse.jgit.notes.Note base, org.eclipse.jgit.notes.Note ours, org.eclipse.jgit.notes.Note theirs, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.ObjectInserter inserter) throws java.io.IOException { if (ours == null) { return theirs; } if (theirs == null) { return ours; } if (ours.getData().equals(theirs.getData())) { return ours; } org.eclipse.jgit.lib.ObjectLoader lo = reader.open(ours.getData()); byte[] sep = new byte[]{ '\n' }; org.eclipse.jgit.lib.ObjectLoader lt = reader.open(theirs.getData()); org.eclipse.jgit.util.io.UnionInputStream union = new org.eclipse.jgit.util.io.UnionInputStream(lo.openStream(), new java.io.ByteArrayInputStream(sep), lt.openStream()); org.eclipse.jgit.lib.ObjectId noteData = inserter.insert(Constants.OBJ_BLOB, (((lo.getSize()) + (sep.length)) + (lt.getSize())), union); return new org.eclipse.jgit.notes.Note(ours, noteData); }
private com.google.inject.Injector newRootInjector(final com.google.gerrit.server.plugins.PluginGuiceEnvironment env) { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayListWithCapacity(4); if ((getApiType()) == (ApiType.PLUGIN)) { modules.add(env.getSysModule()); } modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.server.PluginUser.class).toInstance(getPluginUser()); bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(getName()); bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl); bind(java.io.File.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginData.class).toProvider(new com.google.inject.Provider<java.io.File>() { private volatile boolean ready; @java.lang.Override public java.io.File get() { if (!(ready)) { synchronized(dataDir) { if ((!(dataDir.exists())) && (!(dataDir.mkdirs()))) { throw new com.google.inject.ProvisionException(java.lang.String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName())); } ready = true; } } return dataDir; } }); } }); return com.google.inject.Guice.createInjector(modules); }
@java.lang.Override public java.io.File get() { if (!(ready)) { synchronized(dataDir) { if ((!(dataDir.exists())) && (!(dataDir.mkdirs()))) { throw new com.google.inject.ProvisionException(java.lang.String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName())); } ready = true; } } return dataDir; }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.PluginUser.class).toInstance(getPluginUser()); bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance(getName()); bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl); bind(java.io.File.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginData.class).toProvider(new com.google.inject.Provider<java.io.File>() { private volatile boolean ready; @java.lang.Override public java.io.File get() { if (!(ready)) { synchronized(dataDir) { if ((!(dataDir.exists())) && (!(dataDir.mkdirs()))) { throw new com.google.inject.ProvisionException(java.lang.String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName())); } ready = true; } } return dataDir; } }); }
private static com.google.gerrit.extensions.restapi.BinaryResult stackBase64(javax.servlet.http.HttpServletResponse res, final com.google.gerrit.extensions.restapi.BinaryResult src) throws java.io.IOException { com.google.gerrit.extensions.restapi.BinaryResult b64; long len = src.getContentLength(); if ((0 <= len) && (len <= (7 << 20))) { b64 = com.google.gerrit.httpd.restapi.RestApiServlet.base64(src); } else { b64 = new com.google.gerrit.extensions.restapi.BinaryResult() { @java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { java.io.OutputStream e = com.google.common.io.BaseEncoding.base64().encodingStream(new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.ISO_8859_1)); src.writeTo(e); e.flush(); } }; } res.setHeader("X-FYI-Content-Encoding", "base64"); res.setHeader("X-FYI-Content-Type", src.getContentType()); return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1"); }
@java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { java.io.OutputStream e = com.google.common.io.BaseEncoding.base64().encodingStream(new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.ISO_8859_1)); src.writeTo(e); e.flush(); }

private void columnPath(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().pathColumn()).openAnchor(); java.lang.String path = info.path(); if (((mode) == (com.google.gerrit.client.change.FileTable.Mode.EDIT)) && (!(isEditable(info)))) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.RESTORE) + "(event,") + (info._row())) + ")")); } else { sb.setAttribute("href", ("#" + (url(info)))).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.OPEN) + "(event,") + (info._row())) + ")")); } if (Patch.COMMIT_MSG.equals(path)) { sb.append(Util.C.commitMessage()); } else { int commonPrefixLen = commonPrefix(path); if (commonPrefixLen > 0) { sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan(); } sb.append(path.substring(commonPrefixLen)); lastPath = path; } sb.closeAnchor(); if ((info.old_path()) != null) { sb.br(); sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().renameCopySource()).append(info.old_path()).closeSpan(); } sb.closeTd(); }

@java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { try (java.io.OutputStreamWriter w = new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.ISO_8859_1);java.io.OutputStream e = com.google.common.io.BaseEncoding.base64().encodingStream(w)) { src.writeTo(e); e.flush(); } }
private static com.google.gerrit.extensions.restapi.BinaryResult stackBase64(javax.servlet.http.HttpServletResponse res, final com.google.gerrit.extensions.restapi.BinaryResult src) throws java.io.IOException { com.google.gerrit.extensions.restapi.BinaryResult b64; long len = src.getContentLength(); if ((0 <= len) && (len <= (7 << 20))) { b64 = com.google.gerrit.httpd.restapi.RestApiServlet.base64(src); } else { b64 = new com.google.gerrit.extensions.restapi.BinaryResult() { @java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { try (java.io.OutputStreamWriter w = new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.ISO_8859_1);java.io.OutputStream e = com.google.common.io.BaseEncoding.base64().encodingStream(w)) { src.writeTo(e); e.flush(); } } }; } res.setHeader("X-FYI-Content-Encoding", "base64"); res.setHeader("X-FYI-Content-Type", src.getContentType()); return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1"); }
@org.junit.Test public void cherryPick() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic"); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "foo"; in.message = "it goes to stable branch"; gApi.projects().name(project.get()).branch(in.destination).create(new com.google.gerrit.extensions.api.projects.BranchInput()); com.google.gerrit.extensions.api.changes.ChangeApi orig = gApi.changes().id(("p~master~" + (r.getChangeId()))); assertThat(((java.lang.Iterable<?>) (orig.get().messages))).hasSize(1); com.google.gerrit.extensions.api.changes.ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in); assertThat(((java.lang.Iterable<?>) (orig.get().messages))).hasSize(2); assertThat(cherry.get().subject).contains(in.message); assertThat(cherry.get().topic).isEqualTo("someTopic"); cherry.current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); cherry.current().submit(); }



private Change.Id insertPatchSet(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.revwalk.RevCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.IdentifiedUser identifiedUser) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { final com.google.gerrit.server.project.ChangeControl changeControl = refControl.getProjectControl().controlFor(change); final com.google.gerrit.server.change.PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, changeControl, cherryPickCommit); final com.google.gerrit.reviewdb.client.PatchSet.Id newPatchSetId = inserter.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet current = db.get().patchSets().get(change.currentPatchSetId()); inserter.setMessage((("Uploaded patch set " + (newPatchSetId.get())) + ".")).setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).insert(); return change.getId(); }
@org.junit.Test public void patchSetObjectMissing() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(project, userId); db.changes().insert(java.util.Collections.singleton(c)); com.google.gerrit.reviewdb.client.PatchSet ps = newPatchSet(c.currentPatchSetId(), org.eclipse.jgit.lib.ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"), userId); db.patchSets().insert(java.util.Collections.singleton(ps)); assertProblems(c, "Object missing: patch set 1: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); }

@org.junit.Test public void duplicatePatchSetRevisions() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(project, userId); db.changes().insert(java.util.Collections.singleton(c)); org.eclipse.jgit.revwalk.RevCommit commit1 = repo.branch(c.currentPatchSetId().toRefName()).commit().parent(tip).create(); com.google.gerrit.reviewdb.client.PatchSet ps1 = newPatchSet(c.currentPatchSetId(), commit1, userId); db.patchSets().insert(java.util.Collections.singleton(ps1)); incrementPatchSet(c); com.google.gerrit.reviewdb.client.PatchSet ps2 = newPatchSet(c.currentPatchSetId(), commit1, userId); db.patchSets().insert(java.util.Collections.singleton(ps2)); assertProblems(c, (("Multiple patch sets pointing to " + (commit1.name())) + ": [1, 2]")); }
@org.junit.Before public void setUp() throws java.lang.Exception { schemaFactory = com.google.gerrit.testutil.InMemoryDatabase.newDatabase(); schemaFactory.create(); db = schemaFactory.open(); repoManager = new com.google.gerrit.testutil.InMemoryRepositoryManager(); checker = new com.google.gerrit.server.change.ConsistencyChecker(com.google.inject.util.Providers.<com.google.gerrit.reviewdb.server.ReviewDb>of(db), repoManager); project = new com.google.gerrit.reviewdb.client.Project.NameKey("repo"); repo = new org.eclipse.jgit.junit.TestRepository(repoManager.createRepository(project)); userId = new com.google.gerrit.reviewdb.client.Account.Id(1); db.accounts().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()))); tip = repo.branch("master").commit().create(); }
@org.junit.Test public void missingDestRef() throws java.lang.Exception { org.eclipse.jgit.lib.RefUpdate ru = repo.getRepository().updateRef("refs/heads/master"); ru.setForceUpdate(true); assertThat(ru.delete()).isEqualTo(RefUpdate.Result.FORCED); com.google.gerrit.reviewdb.client.Change c = newChange(project, userId); db.changes().insert(java.util.Collections.singleton(c)); org.eclipse.jgit.revwalk.RevCommit commit = repo.commit().create(); com.google.gerrit.reviewdb.client.PatchSet ps = newPatchSet(c.currentPatchSetId(), commit, userId); db.patchSets().insert(java.util.Collections.singleton(ps)); assertProblems(c, "Destination ref not found (may be new branch): master"); }



@com.google.gwt.uibinder.client.UiHandler("diffBase") void onChangeRevision(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ChangeEvent e) { int idx = diffBase.getSelectedIndex(); if (0 <= idx) { java.lang.String n = diffBase.getValue(idx); loadConfigInfo(changeInfo, (!(n.isEmpty()) ? n : null)); } }
private void loadDiff(final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo base, final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev, final java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(rev, group); final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts = loadDrafts(rev, group); com.google.gerrit.client.diff.DiffApi.list(changeId.get(), (base != null ? base.name() : null), rev.name(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.diff.FileInfo> m) { files.set((base != null ? new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, base._number()) : null), new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, comments.get(0), drafts.get(0)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((fileTableMode) == (FileTable.Mode.REVIEW))) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { files.markReviewed(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } }



private void showDoc(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, com.google.gitiles.GitilesView view, com.google.gitiles.doc.MarkdownHelper fmt, org.pegdown.ast.RootNode nav, org.pegdown.ast.RootNode doc) throws java.io.IOException { java.lang.String title = com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(fmt.getTitle(doc)), view.getPathPart()); java.util.Map<java.lang.String, java.lang.Object> data = new java.util.HashMap<>(); data.put("breadcrumbs", null); data.put("repositoryName", null); data.put("title", title); data.put("navbarHtml", fmt.renderHTML(nav)); data.put("bodyHtml", fmt.renderHTML(doc)); data.put("sourceUrl", com.google.gitiles.GitilesView.path().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl()); data.put("logUrl", com.google.gitiles.GitilesView.log().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl()); data.put("blameUrl", com.google.gitiles.GitilesView.blame().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl()); renderHtml(req, res, "gitiles.markdownDoc", data); }
public org.parboiled.Rule note() { org.parboiled.support.StringBuilderVar body = new org.parboiled.support.StringBuilderVar(); return NodeSequence(string("***"), whitespace(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), BaseParser.ANY, body.append(matchedChar())), string("***"), Newline(), push(new com.google.gitiles.doc.DivNode(((com.google.gitiles.doc.DivNode.Style) (pop())), parse(body).getChildren()))); }

@java.lang.Override public org.parboiled.Rule[] blockPluginRules() { return new org.parboiled.Rule[]{ toc(), note() }; }




@java.lang.Override public org.parboiled.Rule[] blockPluginRules() { return new org.parboiled.Rule[]{ toc() }; }



@org.junit.Test public void getFileContentRest() throws java.lang.Exception { com.google.gerrit.server.change.ChangeEdits.Put.Input in = new com.google.gerrit.server.change.ChangeEdits.Put.Input(); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.RestResponse r = adminSession.getJsonAccept(urlEditFile()); assertThat(r.getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_OK); assertThat(readContentFromJson(r)).isEqualTo(org.apache.commons.codec.binary.StringUtils.newStringUtf8(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); }
@org.junit.Test public void addNewFileAndAmend() throws java.lang.Exception { assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2); }
@org.junit.Test public void rebaseEdit() throws java.lang.Exception { assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); assertThat(modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED); com.google.gerrit.server.edit.ChangeEdit edit = editUtil.byChange(change).get(); com.google.gerrit.reviewdb.client.PatchSet current = getCurrentPatchSet(changeId); assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(((current.getPatchSetId()) - 1)); java.util.Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen(); modifier.rebaseEdit(edit, current); edit = editUtil.byChange(change).get(); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME2), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2); assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId()); java.util.Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen(); assertThat(beforeRebase.equals(afterRebase)).isFalse(); }
@org.junit.Test public void createAndChangeEditInOneRequestRest() throws java.lang.Exception { com.google.gerrit.server.change.ChangeEdits.Put.Input in = new com.google.gerrit.server.change.ChangeEdits.Put.Input(); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); in.content = com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2); assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2); }
@org.junit.Test public void amendExistingFile() throws java.lang.Exception { assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME), com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2); }

private void columnDelta1(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.diff.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().deltaColumn1()); if ((!(Patch.COMMIT_MSG.equals(info.path()))) && (!(info.binary()))) { sb.append(((info.lines_inserted()) + (info.lines_deleted()))); } sb.closeTd(); }
private void writeEvents() { int processed = 0; while (processed < (com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE)) { if ((java.lang.Thread.interrupted()) || (stdout.checkError())) { hooks.removeChangeListener(listener); flush(); onExit(0); return; } if (dropped) { write(droppedOutputEvent); dropped = false; } final com.google.gerrit.server.events.Event event = poll(); if (event == null) { break; } write(event); processed++; } flush(); if ((com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE) <= processed) { synchronized(taskLock) { task = pool.submit(writer); } } }
@java.lang.Override protected void onExit(final int rc) { hooks.removeChangeListener(listener); synchronized(taskLock) { done = true; } super.onExit(rc); }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes("UTF-8")); err.flush(); onExit(1); return; } stdout = toPrintWriter(out); hooks.addChangeListener(listener, currentUser); }

@java.lang.Override public void destroy() { hooks.removeChangeListener(listener); final boolean exit; synchronized(taskLock) { if ((task) != null) { task.cancel(true); exit = false; } else { exit = !(done); } done = true; } if (exit) { onExit(0); } }



@java.lang.Override public void onSuccess(com.google.gerrit.client.projects.BranchInfo branch) { showAddedBranch(branch); addBranch.setEnabled(true); nameTxtBox.setText(""); irevTxtBox.setText(""); branchTable.insert(branch); delBranch.setVisible(branchTable.hasBranchCanDelete()); }
private void deleteBranches(final java.util.Set<java.lang.String> branches) { com.google.gerrit.client.projects.ProjectApi.deleteBranches(getProjectKey(), branches, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { for (int row = 1; row < (table.getRowCount());) { com.google.gerrit.client.projects.BranchInfo k = getRowItem(row); if ((k != null) && (branches.contains(k.ref()))) { table.removeRow(row); } else { row++; } } updateDeleteButton(); delBranch.setVisible(branchTable.hasBranchCanDelete()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { query = new com.google.gerrit.client.admin.ProjectBranchesScreen.Query().start(start).run(); super.onFailure(caught); } }); }
@java.lang.Override public boolean apply(com.google.gerrit.server.project.ListBranches.BranchInfo in) { return a.run(in.ref); }
@java.lang.Override public boolean apply(com.google.gerrit.server.project.ListBranches.BranchInfo in) { return in.ref.toLowerCase(java.util.Locale.US).contains(matchSubstring.toLowerCase(java.util.Locale.US)); }
private void doAddNewBranch() { final java.lang.String branchName = nameTxtBox.getText().trim(); if ("".equals(branchName)) { nameTxtBox.setFocus(true); return; } final java.lang.String rev = irevTxtBox.getText().trim(); if ("".equals(rev)) { irevTxtBox.setText("HEAD"); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { irevTxtBox.selectAll(); irevTxtBox.setFocus(true); } }); return; } addBranch.setEnabled(false); com.google.gerrit.client.projects.ProjectApi.createBranch(getProjectKey(), branchName, rev, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.projects.BranchInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.projects.BranchInfo branch) { showAddedBranch(branch); addBranch.setEnabled(true); nameTxtBox.setText(""); irevTxtBox.setText(""); branchTable.insert(branch); delBranch.setVisible(branchTable.hasBranchCanDelete()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { addBranch.setEnabled(true); com.google.gerrit.client.admin.ProjectBranchesScreen.selectAllAndFocus(nameTxtBox); new com.google.gerrit.client.ErrorDialog(caught.getMessage()).center(); } }); }
void showList(com.google.gwt.core.client.JsArray<com.google.gerrit.client.projects.BranchInfo> result) { if ((open) && ((result.length()) != 0)) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toProjectBranches(getProjectKey())); return; } setToken(getTokenForScreen(qStart)); this.start = qStart; if ((result.length()) <= (pageSize)) { branchTable.display(com.google.gerrit.client.rpc.Natives.asList(result)); next.setVisible(false); } else { branchTable.displaySubset(com.google.gerrit.client.rpc.Natives.asList(result), 0, ((result.length()) - 1)); setupNavigationLink(next, ((qStart) + (pageSize))); } if ((qStart) > 0) { setupNavigationLink(prev, ((qStart) - (pageSize))); } else { prev.setVisible(false); } delBranch.setVisible(branchTable.hasBranchCanDelete()); java.util.Set<java.lang.String> checkedRefs = branchTable.getCheckedRefs(); branchTable.setChecked(checkedRefs); updateForm(); if (!(isCurrentView())) { display(); } }


@java.lang.Override public synchronized void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException { super.init(config); setDefaultFields(config); for (com.google.gitiles.GitilesView.Type type : GitilesView.Type.values()) { if (!(servlets.containsKey(type))) { servlets.put(type, getDefaultHandler(type)); } } javax.servlet.Filter repositoryFilter = new org.eclipse.jgit.http.server.RepositoryFilter(resolver); javax.servlet.Filter viewFilter = new com.google.gitiles.ViewFilter(accessFactory, urls, visibilityCache); javax.servlet.Filter dispatchFilter = new com.google.gitiles.GitilesFilter.DispatchFilter(filters, servlets); org.eclipse.jgit.http.server.glue.ServletBinder root = serveRegex(com.google.gitiles.GitilesFilter.ROOT_REGEX).through(viewFilter); if ((gitwebRedirect) != null) { root.through(gitwebRedirect); } root.through(dispatchFilter); serveRegex(com.google.gitiles.GitilesFilter.REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter); serveRegex(com.google.gitiles.GitilesFilter.REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter); initialized = true; }


@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.editWithFiles(changeId.get(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo.EditInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo.EditInfo result) { edit = result; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } loadChangeInfo(true, group.addFinal(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { info.init(); loadConfigInfo(info, base); } })); }
void loadChangeInfo(boolean fg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS)); if (!fg) { call.background(); } call.get(cb); }

private boolean areChangesSubmittable(java.util.List<com.google.gerrit.server.query.change.ChangeData> changes, com.google.gerrit.server.IdentifiedUser identifiedUser) { for (com.google.gerrit.server.query.change.ChangeData c : changes) { try { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl().forUser(identifiedUser); if (!(changeControl.canSubmit())) { return false; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error(("Failed to get a ChangeControl for Change.Id " + (java.lang.String.valueOf(c.getId()))), e); return false; } } return true; }

@java.lang.Override public PatchSet.Id call() throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { try { if (caller == (java.lang.Thread.currentThread())) { return insertPatchSet(db); } else { com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { return insertPatchSet(db); } finally { db.close(); } } } finally { synchronized(replaceProgress) { replaceProgress.update(1); } } }
com.google.common.util.concurrent.CheckedFuture<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.server.git.InsertException> insertPatchSet() throws java.io.IOException { rp.getRevWalk().parseBody(newCommit); final java.lang.Thread caller = java.lang.Thread.currentThread(); com.google.common.util.concurrent.ListenableFuture<com.google.gerrit.reviewdb.client.PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new java.util.concurrent.Callable<com.google.gerrit.reviewdb.client.PatchSet.Id>() { @java.lang.Override public PatchSet.Id call() throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { try { if (caller == (java.lang.Thread.currentThread())) { return insertPatchSet(db); } else { com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open(); try { return insertPatchSet(db); } finally { db.close(); } } } finally { synchronized(replaceProgress) { replaceProgress.update(1); } } } })); return com.google.common.util.concurrent.Futures.makeChecked(future, com.google.gerrit.server.git.ReceiveCommits.INSERT_EXCEPTION); }

public boolean isVisible() { com.google.gerrit.reviewdb.client.AccountGroup accountGroup = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); return (((((accountGroup != null) && (accountGroup.isVisibleToAll())) || ((user) instanceof com.google.gerrit.server.InternalUser)) || (user.getEffectiveGroups().contains(group.getGroupUUID()))) || (isOwner())) || (user.getCapabilities().canAdministrateServer()); }
public boolean isVisible() { return (((((user) instanceof com.google.gerrit.server.InternalUser) || (groupBackend.isVisibleToAll(group.getGroupUUID()))) || (user.getCapabilities().canAdministrateServer())) || (isOwner())) || (user.memberOf(group.getGroupUUID())); }
private void showDoc(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, com.google.gitiles.GitilesView view, org.pegdown.ast.RootNode nav, org.pegdown.ast.RootNode doc) throws java.io.IOException { java.util.Map<java.lang.String, java.lang.Object> data = new java.util.HashMap<>(); data.putAll(com.google.gitiles.doc.Navbar.bannerSoyData(view, nav)); data.put("pageTitle", com.google.common.base.MoreObjects.firstNonNull(com.google.gitiles.doc.MarkdownUtil.getTitle(doc), view.getPathPart())); data.put("sourceUrl", com.google.gitiles.GitilesView.show().copyFrom(view).toUrl()); data.put("logUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl()); data.put("blameUrl", com.google.gitiles.GitilesView.blame().copyFrom(view).toUrl()); data.put("navbarHtml", new com.google.gitiles.doc.MarkdownToHtml(view).toSoyHtml(nav)); data.put("bodyHtml", new com.google.gitiles.doc.MarkdownToHtml(view).toSoyHtml(doc)); java.lang.String page = renderer.render(com.google.gitiles.doc.DocServlet.SOY_TEMPLATE, data); byte[] raw = page.getBytes(java.nio.charset.StandardCharsets.UTF_8); res.setContentType(FormatType.HTML.getMimeType()); res.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); setCacheHeaders(res); if (acceptsGzipEncoding(req)) { res.setHeader(HttpHeaders.CONTENT_ENCODING, "gzip"); raw = gzip(raw); } res.setContentLength(raw.length); res.setStatus(HttpServletResponse.SC_OK); res.getOutputStream().write(raw); }





private void submit(com.google.gerrit.server.project.ChangeControl changeCtl, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.Submit submit = submitProvider.get(); com.google.gerrit.server.change.RevisionResource rsrc = new com.google.gerrit.server.change.RevisionResource(changes.parse(changeCtl), ps); com.google.gerrit.reviewdb.client.Change c; try { c = submit.submit(rsrc, currentUser, true); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new java.io.IOException(e); } if (c == null) { addError((("Submitting change " + (changeCtl.getChange().getChangeId())) + " failed.")); } else { addMessage(""); mergeQueue.merge(c.getDest()); c = db.changes().get(c.getId()); switch (c.getStatus()) { case SUBMITTED : addMessage((("Change " + (c.getChangeId())) + " submitted.")); break; case MERGED : addMessage((("Change " + (c.getChangeId())) + " merged.")); break; case NEW : com.google.gerrit.reviewdb.client.ChangeMessage msg = submit.getConflictMessage(rsrc); if (msg != null) { addMessage(((("Change " + (c.getChangeId())) + ": ") + (msg.getMessage()))); break; } default : addMessage(((("change " + (c.getChangeId())) + " is ") + (c.getStatus().name().toLowerCase()))); } } }


void display(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { this.revision = revision; boolean hasUser = com.google.gerrit.client.Gerrit.isSignedIn(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = info.revision(revision); com.google.gerrit.client.changes.ChangeInfo.CommitInfo commit = revInfo.commit(); changeId = info.legacy_id(); project = info.project(); subject = commit.subject(); message = commit.message(); branch = info.branch(); key = info.change_id(); changeInfo = info; initChangeActions(info, hasUser); initRevisionActions(info, revInfo, hasUser); }
private void initRevisionActions(com.google.gerrit.client.changes.ChangeInfo info, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo, boolean hasUser) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (revInfo.has_actions()) ? revInfo.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); canSubmit = false; if (hasUser) { canSubmit = actions.containsKey("submit"); if (canSubmit) { com.google.gerrit.client.actions.ActionInfo action = actions.get("submit"); submit.setTitle(action.title()); submit.setEnabled(action.enabled()); submit.setHTML(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openDiv().append(action.label()).closeDiv()); } com.google.gerrit.client.change.Actions.a2b(actions, "cherrypick", cherrypick); com.google.gerrit.client.change.Actions.a2b(actions, "rebase", rebase); for (java.lang.String id : com.google.gerrit.client.change.Actions.filterNonCore(actions)) { add(new com.google.gerrit.client.actions.ActionButton(info, revInfo, actions.get(id))); } } }

private void initRevisionsAction(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { int currentPatchSet; if (((info.current_revision()) != null) && (info.revisions().containsKey(info.current_revision()))) { currentPatchSet = info.revision(info.current_revision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } java.lang.String currentlyViewedPatchSet; if (info.revision(revision).id().equals("edit")) { currentlyViewedPatchSet = Resources.M.editPatchSet(com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.findEditParent(info.revisions().values())); currentPatchSet = (info.revisions().values().length()) - 1; } else { currentlyViewedPatchSet = info.revision(revision).id(); } patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (revInfo.has_actions()) ? revInfo.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); if (actions.containsKey("publish")) { publish.setVisible(true); publish.setTitle(actions.get("publish").title()); } if (actions.containsKey("/")) { deleteRevision.setVisible(true); deleteRevision.setTitle(actions.get("/").title()); } } }
private void initChangeAction(com.google.gerrit.client.changes.ChangeInfo info) { if ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.DRAFT)) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = (info.has_actions()) ? info.actions() : com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); actions.copyKeysIntoChildren("id"); if (actions.containsKey("/")) { deleteChange.setVisible(true); deleteChange.setTitle(actions.get("/").title()); } } }
private void renderChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { changeInfo = info; lastDisplayedUpdate = info.updated(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revisionInfo = info.revision(revision); boolean current = ((info.status().isOpen()) && (revision.equals(info.current_revision()))) && (!(revisionInfo.is_edit())); if (revisionInfo.is_edit()) { statusText.setInnerText(Util.C.changeEdit()); } else if ((!current) && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { statusText.setInnerText(Util.C.notCurrent()); labels.setVisible(false); } else { statusText.setInnerText(com.google.gerrit.client.changes.Util.toLongString(info.status())); } labels.set(info); renderOwner(info); renderActionTextDate(info); renderDiffBaseListBox(info); initReplyButton(info, revision); initIncludedInAction(info); initChangeAction(info); initRevisionsAction(info, revision); initDownloadAction(info, revision); initProjectLinks(info); initBranchLink(info); initEditMode(info, revision); actions.display(info, revision); star.setValue(info.starred()); permalink.setHref(com.google.gerrit.client.ui.ChangeLink.permalink(changeId)); permalink.setText(java.lang.String.valueOf(info.legacy_id())); topic.set(info, revision); commit.set(commentLinkProcessor, info, revision); related.set(info, revision); reviewers.set(info); if (com.google.gerrit.client.Gerrit.isNoteDbEnabled()) { hashtags.set(info); } else { setVisible(hashtagTableRow, false); } if (com.google.gerrit.client.Gerrit.isSignedIn()) { replyAction = new com.google.gerrit.client.change.ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove); if (topic.canEdit()) { keysAction.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 't', Util.C.keyEditTopic()) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { topic.onEdit(); } }); } } history.set(commentLinkProcessor, replyAction, changeId, info); if (current) { quickApprove.set(info, revision, replyAction); loadSubmitType(info.status(), isSubmittable(info)); } else { quickApprove.setVisible(false); setVisible(strategy, false); } java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append(Util.M.changeScreenTitleId(info.id_abbreviated())); if ((info.subject()) != null) { sb.append(": "); sb.append(info.subject()); } setWindowTitle(sb.toString()); }
private static boolean notModified(javax.servlet.http.HttpServletRequest req, com.google.gerrit.extensions.restapi.RestResource rsrc) { if (!(com.google.gerrit.httpd.restapi.RestApiServlet.isGetOrHead(req))) { return false; } if (rsrc instanceof com.google.gerrit.extensions.restapi.RestResource.HasETag) { java.lang.String have = req.getHeader(HttpHeaders.IF_NONE_MATCH); if (have != null) { return have.equals(((com.google.gerrit.extensions.restapi.RestResource.HasETag) (rsrc)).getETag()); } } if (rsrc instanceof com.google.gerrit.extensions.restapi.RestResource.HasLastModified) { java.sql.Timestamp m = ((com.google.gerrit.extensions.restapi.RestResource.HasLastModified) (rsrc)).getLastModified(); long d = req.getDateHeader(HttpHeaders.IF_MODIFIED_SINCE); return (d / 1000L) == ((m.getTime()) / 1000L); } return false; }


@java.lang.Override public java.lang.String getETag() { return change.getETag(); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.config.SitePaths.class); bind(com.google.gerrit.pgm.init.api.InitFlags.class); bind(com.google.gerrit.pgm.init.Libraries.class); bind(com.google.gerrit.pgm.init.LibraryDownloader.class); factory(Section.Factory.class); step().to(com.google.gerrit.pgm.init.UpgradeFrom2_0_x.class); step().to(com.google.gerrit.pgm.init.InitGitManager.class); if (initDb) { step().to(com.google.gerrit.pgm.init.InitDatabase.class); } step().to(com.google.gerrit.pgm.init.InitIndex.class); step().to(com.google.gerrit.pgm.init.InitAuth.class); step().to(com.google.gerrit.pgm.init.InitLabels.class); step().to(com.google.gerrit.pgm.init.InitSendEmail.class); if (standalone) { step().to(com.google.gerrit.pgm.init.InitContainer.class); } step().to(com.google.gerrit.pgm.init.InitSshd.class); step().to(com.google.gerrit.pgm.init.InitHttpd.class); step().to(com.google.gerrit.pgm.init.InitCache.class); step().to(com.google.gerrit.pgm.init.InitPlugins.class); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.pgm.init.api.ConsoleUI.class).toInstance(ui); bind(java.io.File.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toInstance(sitePath); java.util.List<java.lang.String> plugins = com.google.common.base.Objects.firstNonNull(getInstallPlugins(), com.google.common.collect.Lists.<java.lang.String>newArrayList()); bind(new com.google.inject.TypeLiteral<java.util.List<java.lang.String>>() {}).annotatedWith(com.google.gerrit.pgm.init.api.InstallPlugins.class).toInstance(plugins); bind(com.google.gerrit.pgm.init.PluginsDistribution.class).toInstance(pluginsDistribution); }




public void setSecure(java.lang.String name, java.lang.String value) { if (value != null) { flags.sec.setString(section, subsection, name, value); } else { flags.sec.unset(section, subsection, name); } }






static void call(final com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision) { com.google.gerrit.client.changes.ChangeApi.rebase(id.get(), revision, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(id)); } }); }



@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.RevisionResource resource) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Rebase").setTitle("Rebase onto tip of branch or parent change").setVisible((((resource.getChange().getStatus().isOpen()) && (resource.getControl().canRebase())) && (rebaseChange.get().canRebase(resource)))); }

public com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> byChange(com.google.gerrit.reviewdb.client.Change change) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException { com.google.gerrit.server.CurrentUser currentUser = user.get(); if (!(currentUser.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } return byChange(change, ((com.google.gerrit.server.IdentifiedUser) (currentUser))); }

public static void copy(final java.io.File dst, final java.nio.ByteBuffer buf) throws java.io.FileNotFoundException, java.io.IOException { try { if (buf.equals(java.nio.ByteBuffer.wrap(org.eclipse.jgit.util.IO.readFully(dst)))) { return; } } catch (java.io.FileNotFoundException notFound) { } dst.getParentFile().mkdirs(); org.eclipse.jgit.internal.storage.file.LockFile lf = new org.eclipse.jgit.internal.storage.file.LockFile(dst, org.eclipse.jgit.util.FS.DETECTED); if (!(lf.lock())) { throw new java.io.IOException(("Cannot lock " + dst)); } try { final java.io.OutputStream out = lf.getOutputStream(); try { final byte[] tmp = new byte[4096]; while (0 < (buf.remaining())) { int n = java.lang.Math.min(buf.remaining(), tmp.length); buf.get(tmp, 0, n); out.write(tmp, 0, n); } } finally { out.close(); } if (!(lf.commit())) { throw new java.io.IOException(("Cannot commit " + dst)); } } finally { lf.unlock(); } }
boolean isCurrent() { return (path.lastModified()) == (modified); }
com.google.gerrit.sshd.DatabasePubKeyAuth.PeerKeyCache reload() { return new com.google.gerrit.sshd.DatabasePubKeyAuth.PeerKeyCache(path); }
private java.util.Set<java.security.PublicKey> getPeerKeys() { com.google.gerrit.sshd.DatabasePubKeyAuth.PeerKeyCache p = peerKeyCache; if (!(p.isCurrent())) { p = p.reload(); peerKeyCache = p; } return p.keys; }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> toActionMap(com.google.gerrit.server.change.RevisionResource rsrc) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> out = new java.util.LinkedHashMap<>(); if (rsrc.getControl().getCurrentUser().isIdentifiedUser()) { com.google.inject.Provider<com.google.gerrit.server.CurrentUser> userProvider = com.google.inject.util.Providers.of(rsrc.getControl().getCurrentUser()); for (com.google.gerrit.extensions.webui.UiAction.Description d : com.google.gerrit.server.extensions.webui.UiActions.from(revisions, rsrc, userProvider)) { out.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } } return out; }
public static com.google.gerrit.extensions.events.LifecycleListener start(java.nio.file.Path sitePath) throws java.io.FileNotFoundException { java.nio.file.Path logdir = com.google.gerrit.common.FileUtil.mkdirsOrDie(new com.google.gerrit.server.config.SitePaths(sitePath).logs_dir, "Cannot create log directory"); if (com.google.gerrit.server.util.SystemLog.shouldConfigure()) { com.google.gerrit.pgm.util.GarbageCollectionLogFile.initLogSystem(logdir); } return new com.google.gerrit.extensions.events.LifecycleListener() { @java.lang.Override public void start() { } @java.lang.Override public void stop() { org.apache.log4j.LogManager.getLogger(GarbageCollection.LOG_NAME).removeAllAppenders(); } }; }
@java.lang.Override public void initConfig(com.google.gerrit.pgm.init.api.Section databaseSection) { java.lang.String path = databaseSection.get("database"); if (path == null) { path = "db/ReviewDB"; databaseSection.set("database", path); } java.io.File db = site.resolve(path); if (db == null) { throw com.google.gerrit.pgm.init.api.InitUtil.die("database.database must be supplied for H2"); } db = db.getParentFile(); if ((!(db.exists())) && (!(db.mkdirs()))) { throw com.google.gerrit.pgm.init.api.InitUtil.die(("cannot create database.database " + (db.getAbsolutePath()))); } }
public static com.google.gerrit.extensions.events.LifecycleListener start(final java.nio.file.Path sitePath) throws java.io.FileNotFoundException { java.nio.file.Path logdir = com.google.gerrit.common.FileUtil.mkdirsOrDie(new com.google.gerrit.server.config.SitePaths(sitePath).logs_dir, "Cannot create log directory"); if (com.google.gerrit.server.util.SystemLog.shouldConfigure()) { com.google.gerrit.pgm.util.ErrorLogFile.initLogSystem(logdir); } return new com.google.gerrit.extensions.events.LifecycleListener() { @java.lang.Override public void start() { } @java.lang.Override public void stop() { org.apache.log4j.LogManager.shutdown(); } }; }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource rsrc, com.googlesource.gerrit.plugins.deleteproject.DeleteProject.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (!(canDelete(rsrc))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete project"); } try { pcHandler.assertCanDelete(rsrc); } catch (com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } com.google.gerrit.reviewdb.client.Project project = rsrc.getControl().getProject(); try { dbHandler.assertCanDelete(project); } catch (com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } if ((input == null) || (!(input.force))) { java.util.Collection<java.lang.String> warnings = dbHandler.getWarnings(project); if (!(warnings.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("Project %s has open changes", project.getName())); } } dbHandler.delete(project); try { fsHandler.delete(project, (input == null ? false : input.preserve)); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } cacheHandler.delete(project); return com.google.gerrit.extensions.restapi.Response.none(); }
public void apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try { com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(rsrc.getNameKey()); com.google.gerrit.server.git.ProjectConfig projectConfig = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.reviewdb.client.Project p = projectConfig.getProject(); p.setState(ProjectState.HIDDEN); for (com.google.gerrit.common.data.AccessSection as : projectConfig.getAccessSections()) { projectConfig.remove(as); } createParentForDeletedProjectsIfMissing(); p.setParentName(com.googlesource.gerrit.plugins.deleteproject.HideProject.PARENT_FOR_DELETED_PROJECTS); md.setMessage("Hide project\n"); projectConfig.commit(md); projectCache.evict(projectConfig.getProject()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
private void createParentForDeletedProjectsIfMissing() throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if ((projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(com.googlesource.gerrit.plugins.deleteproject.HideProject.PARENT_FOR_DELETED_PROJECTS))) == null) { try { createProjectFactory.create(com.googlesource.gerrit.plugins.deleteproject.HideProject.PARENT_FOR_DELETED_PROJECTS).apply(TopLevelResource.INSTANCE, null); } catch (com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.extensions.restapi.ResourceNotFoundException | com.google.gerrit.common.errors.ProjectCreationFailedException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("Failed to create project %s", com.googlesource.gerrit.plugins.deleteproject.HideProject.PARENT_FOR_DELETED_PROJECTS)); } } }
public void doDelete(com.google.gerrit.server.project.ProjectResource rsrc, boolean preserve) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Project project = rsrc.getControl().getProject(); dbHandler.delete(project); try { fsHandler.delete(project, preserve); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } cacheHandler.delete(project); }



@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource rsrc, com.googlesource.gerrit.plugins.deleteproject.DeleteProject.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { assertDeletePermission(rsrc); assertCanDelete(rsrc); if ((input == null) || (!(input.force))) { java.util.Collection<java.lang.String> warnings = getWarnings(rsrc); if (!(warnings.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("Project %s has open changes", rsrc.getControl().getProject().getName())); } } doDelete(rsrc, (input == null ? false : input.preserve)); return com.google.gerrit.extensions.restapi.Response.none(); }


public void assertCanDelete(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { try { pcHandler.assertCanDelete(rsrc); dbHandler.assertCanDelete(rsrc.getControl().getProject()); } catch (com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
public void onDelete(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.deleteproject.DeleteProject.Input options, java.lang.Exception ex) { org.apache.log4j.spi.LoggingEvent event = new org.apache.log4j.spi.LoggingEvent(org.apache.log4j.Logger.class.getName(), com.googlesource.gerrit.plugins.deleteproject.DeleteLog.log, com.google.gerrit.common.TimeUtil.nowMs(), (ex == null ? org.apache.log4j.Level.INFO : org.apache.log4j.Level.ERROR), (ex == null ? "ProjectDeletion" : "ProjectDeletionFailure"), java.lang.Thread.currentThread().getName(), null, null, null, null); event.setProperty(com.googlesource.gerrit.plugins.deleteproject.DeleteLog.ACCOUNT_ID, user.getAccountId().toString()); event.setProperty(com.googlesource.gerrit.plugins.deleteproject.DeleteLog.USER_NAME, user.getUserName()); event.setProperty(com.googlesource.gerrit.plugins.deleteproject.DeleteLog.PROJECT_NAME, project.get()); if (options != null) { event.setProperty(com.googlesource.gerrit.plugins.deleteproject.DeleteLog.OPTIONS, OutputFormat.JSON_COMPACT.newGson().toJson(options)); } if (ex != null) { event.setProperty(com.googlesource.gerrit.plugins.deleteproject.DeleteLog.ERROR, ex.toString()); } com.googlesource.gerrit.plugins.deleteproject.DeleteLog.log.callAppenders(event); }

@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw new com.google.gerrit.sshd.UnloggedFailure(1, msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": ") + (commandName)) + ": not found"; throw new com.google.gerrit.sshd.UnloggedFailure(1, msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) bc.setName(commandName); else bc.setName((((getName()) + " ") + (commandName))); bc.setArguments(args.toArray(new java.lang.String[args.size()])); } else if (!(args.isEmpty())) { throw new com.google.gerrit.sshd.UnloggedFailure(1, ((commandName) + " does not take arguments")); } provideStateTo(cmd); atomicCmd.set(cmd); cmd.start(env); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes(com.google.gerrit.sshd.ENC)); err.flush(); onExit(e.exitCode); } }
@org.junit.Before public void setUp() { easyMock = new org.easymock.EasyMockSupport(); storeMock = easyMock.createMock(com.ericsson.gerrit.plugins.eventslog.EventStore.class); listener = new com.ericsson.gerrit.plugins.eventslog.EventHandler(storeMock); }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (event instanceof com.google.gerrit.server.events.ProjectEvent) { database.storeEvent(((com.google.gerrit.server.events.ProjectEvent) (event))); } }

@java.lang.Override protected void configure() { bind(com.ericsson.gerrit.plugins.eventslog.EventStore.class).to(com.ericsson.gerrit.plugins.eventslog.SQLStore.class); bind(com.google.gerrit.extensions.events.LifecycleListener.class).annotatedWith(com.google.inject.internal.UniqueAnnotations.create()).to(com.ericsson.gerrit.plugins.eventslog.SQLStore.class); bind(com.ericsson.gerrit.plugins.eventslog.QueryMaker.class).to(com.ericsson.gerrit.plugins.eventslog.SQLQueryMaker.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.ericsson.gerrit.plugins.eventslog.EventHandler.class); }
private java.util.List<java.lang.String> query(com.google.gerrit.server.change.RevisionResource resource) throws java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository git = gitManager.openRepository(resource.getChange().getProject()); try { org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(git); try { org.eclipse.jgit.revwalk.RevCommit c = new org.eclipse.jgit.revwalk.RevWalk(tw.getObjectReader()).parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(resource.getPatchSet().getRevision().get())); tw.addTree(c.getTree()); tw.setRecursive(true); java.util.List<java.lang.String> paths = new java.util.ArrayList<>(); while ((tw.next()) && ((paths.size()) < 20)) { java.lang.String s = tw.getPathString(); if (s.contains(query)) { paths.add(s); } } return paths; } finally { tw.release(); } } finally { git.close(); } }
private void save(org.eclipse.jgit.lib.PersonIdent ident, java.lang.String msg) throws java.io.IOException { java.io.File path = getPath(); if (path == null) { throw new java.io.IOException("All-Projects does not exist."); } org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository(path); try { inserter = repo.newObjectInserter(); reader = repo.newObjectReader(); try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader); try { org.eclipse.jgit.revwalk.RevTree srcTree = ((revision) != null) ? rw.parseTree(revision) : null; newTree = readTree(srcTree); saveConfig(ProjectConfig.PROJECT_CONFIG, cfg); saveGroupList(); org.eclipse.jgit.lib.ObjectId res = newTree.writeTree(inserter); if (res.equals(srcTree)) { return; } org.eclipse.jgit.lib.CommitBuilder commit = new org.eclipse.jgit.lib.CommitBuilder(); commit.setAuthor(ident); commit.setCommitter(ident); commit.setMessage(msg); commit.setTreeId(res); if ((revision) != null) { commit.addParentId(revision); } org.eclipse.jgit.lib.ObjectId newRevision = inserter.insert(commit); updateRef(repo, ident, newRevision, ("commit: " + msg)); revision = newRevision; } finally { rw.release(); } } finally { if ((inserter) != null) { inserter.release(); inserter = null; } if ((reader) != null) { reader.release(); reader = null; } } } finally { repo.close(); } org.eclipse.jgit.lib.RepositoryCache.clear(); }
private void assertEmptyCommit(java.lang.String projectName, java.lang.String... refs) throws java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)); org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(repo); try { for (java.lang.String ref : refs) { org.eclipse.jgit.revwalk.RevCommit commit = rw.lookupCommit(repo.getRef(ref).getObjectId()); rw.parseBody(commit); tw.addTree(commit.getTree()); assertThat(tw.next()).isFalse(); tw.reset(); } } finally { rw.release(); repo.close(); } }

public static void load(java.util.List<java.lang.String> plugins, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> callback) { if ((plugins == null) || (plugins.isEmpty())) { callback.onSuccess(com.google.gerrit.client.VoidResult.create()); } else { com.google.gerrit.client.api.PluginLoader.self = new com.google.gerrit.client.api.PluginLoader(callback); com.google.gerrit.client.api.PluginLoader.self.load(plugins); com.google.gerrit.client.api.PluginLoader.self.startTimers(); com.google.gerrit.client.api.PluginLoader.self.center(); } }
private java.util.TreeSet<java.util.Map.Entry<java.lang.String, java.nio.file.Path>> jarsFirstSortedPluginsSet(java.util.Map<java.lang.String, java.nio.file.Path> activePlugins) { java.util.TreeSet<java.util.Map.Entry<java.lang.String, java.nio.file.Path>> sortedPlugins = com.google.common.collect.Sets.newTreeSet(new java.util.Comparator<java.util.Map.Entry<java.lang.String, java.nio.file.Path>>() { @java.lang.Override public int compare(java.util.Map.Entry<java.lang.String, java.nio.file.Path> e1, java.util.Map.Entry<java.lang.String, java.nio.file.Path> e2) { java.nio.file.Path n1 = e1.getValue().getFileName(); java.nio.file.Path n2 = e2.getValue().getFileName(); return com.google.common.collect.ComparisonChain.start().compareTrueFirst(n1.endsWith(".jar"), n2.endsWith(".jar")).compare(n1, n2).result(); } }); addAllEntries(activePlugins, sortedPlugins); return sortedPlugins; }
@java.lang.Override public int compare(java.util.Map.Entry<java.lang.String, java.nio.file.Path> e1, java.util.Map.Entry<java.lang.String, java.nio.file.Path> e2) { java.nio.file.Path n1 = e1.getValue().getFileName(); java.nio.file.Path n2 = e2.getValue().getFileName(); return com.google.common.collect.ComparisonChain.start().compareTrueFirst(n1.endsWith(".jar"), n2.endsWith(".jar")).compare(n1, n2).result(); }

protected void executePredicate() throws com.googlecode.prolog_cafe.exceptions.PrologException { com.googlecode.prolog_cafe.lang.Prolog engine = this.engine; com.googlecode.prolog_cafe.lang.Operation code = this.code; try { engine.init(); do { if (isEngineStopped()) return; code = code.exec(engine); } while ((engine.halt) == 0 ); if ((engine.halt) != 1) { throw new com.googlecode.prolog_cafe.exceptions.HaltException(((engine.halt) - 1)); } } finally { this.code = code; com.googlecode.prolog_cafe.lang.SymbolTerm.gc(); } }
public void setPredicate(com.googlecode.prolog_cafe.lang.Predicate p) { p.cont = Success.SUCCESS; code = p; }





@org.junit.Test public void listChildrenRecursively() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey child1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1.get()); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, "p2"); com.google.gerrit.reviewdb.client.Project.NameKey child1_1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1.1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1_1.get(), child1); com.google.gerrit.reviewdb.client.Project.NameKey child1_2 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1.2"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1_2.get(), child1); com.google.gerrit.reviewdb.client.Project.NameKey child1_1_1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1.1.1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1_1_1.get(), child1_1); com.google.gerrit.reviewdb.client.Project.NameKey child1_1_1_1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1.1.1.1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1_1_1_1.get(), child1_1_1); com.google.gerrit.acceptance.RestResponse r = GET((("/projects/" + (child1.get())) + "/children/?recursive")); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjects(java.util.Arrays.asList(child1_1, child1_2, child1_1_1, child1_1_1_1), com.google.gerrit.acceptance.rest.project.ListChildProjectsIT.toProjectInfoList(r)); }
@org.junit.Test public void listChildren() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey existingProject = new com.google.gerrit.reviewdb.client.Project.NameKey("p"); com.google.gerrit.reviewdb.client.Project.NameKey child1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child1.get()); com.google.gerrit.reviewdb.client.Project.NameKey child2 = new com.google.gerrit.reviewdb.client.Project.NameKey("p2"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, child2.get()); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, "p1.1", child1); com.google.gerrit.acceptance.RestResponse r = GET((("/projects/" + (allProjects.get())) + "/children/")); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjects(java.util.Arrays.asList(new com.google.gerrit.reviewdb.client.Project.NameKey("All-Users"), existingProject, child1, child2), com.google.gerrit.acceptance.rest.project.ListChildProjectsIT.toProjectInfoList(r)); }
protected void approve(java.lang.String changeId) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.post((("/changes/" + changeId) + "/revisions/current/review"), new com.google.gerrit.extensions.api.changes.ReviewInput().label("Code-Review", 2)); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); r.consume(); }
@java.lang.Override public com.google.gerrit.rules.PrologCompiler.Status call() throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { org.eclipse.jgit.lib.ObjectId metaConfig = git.resolve(RefNames.REFS_CONFIG); if (metaConfig == null) { return com.google.gerrit.rules.PrologCompiler.Status.NO_RULES; } org.eclipse.jgit.lib.ObjectId rulesId = git.resolve(((metaConfig.name()) + ":rules.pl")); if (rulesId == null) { return com.google.gerrit.rules.PrologCompiler.Status.NO_RULES; } if ((ruleDir) == null) { throw new com.googlecode.prolog_cafe.compiler.CompileException("Caching not enabled"); } try { java.nio.file.Files.createDirectory(ruleDir); } catch (java.io.IOException e) { throw new java.io.IOException(("Cannot create " + (ruleDir))); } java.io.File tempDir = java.io.File.createTempFile("GerritCodeReview_", ".rulec"); if ((!(tempDir.delete())) || (!(tempDir.mkdir()))) { throw new java.io.IOException(("Cannot create " + tempDir)); } try { tempDir.setReadable(true, true); tempDir.setWritable(true, true); tempDir.setExecutable(true, true); compileProlog(rulesId, tempDir); compileJava(tempDir); java.nio.file.Path jarPath = ruleDir.resolve((("rules-" + (rulesId.getName())) + ".jar")); java.util.List<java.lang.String> classFiles = getRelativePaths(tempDir, ".class"); createJar(jarPath, classFiles, tempDir, metaConfig, rulesId); return com.google.gerrit.rules.PrologCompiler.Status.COMPILED; } finally { deleteAllFiles(tempDir); } }


protected void load(java.lang.String pkg, java.lang.String prologResource, java.lang.Module... modules) throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { java.util.ArrayList<java.lang.Module> moduleList = new java.util.ArrayList<>(); moduleList.add(new com.google.gerrit.rules.PrologModule.EnvironmentModule()); moduleList.addAll(java.util.Arrays.asList(modules)); envFactory = com.google.inject.Guice.createInjector(moduleList).getInstance(PrologEnvironment.Factory.class); com.google.gerrit.rules.PrologEnvironment env = envFactory.create(newMachine()); consult(env, getClass(), prologResource); this.pkg = pkg; hasSetup = has(env, "setup"); hasTeardown = has(env, "teardown"); com.googlecode.prolog_cafe.lang.StructureTerm head = new com.googlecode.prolog_cafe.lang.StructureTerm(":", com.googlecode.prolog_cafe.lang.SymbolTerm.intern(pkg), new com.googlecode.prolog_cafe.lang.StructureTerm(com.google.gerrit.rules.PrologTestCase.test_1, new com.googlecode.prolog_cafe.lang.VariableTerm())); tests = new java.util.ArrayList(); for (com.googlecode.prolog_cafe.lang.Term[] pair : env.all(Prolog.BUILTIN, "clause", head, new com.googlecode.prolog_cafe.lang.VariableTerm())) { tests.add(pair[0]); } assertTrue("has tests", ((tests.size()) > 0)); machine = com.googlecode.prolog_cafe.lang.PrologMachineCopy.save(env); }
protected void consult(com.googlecode.prolog_cafe.lang.BufferingPrologControl env, java.lang.Class<?> clazz, java.lang.String prologResource) throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { java.io.InputStream in = clazz.getResourceAsStream(prologResource); if (in == null) { throw new java.io.FileNotFoundException(prologResource); } try { com.googlecode.prolog_cafe.lang.SymbolTerm pathTerm = com.googlecode.prolog_cafe.lang.SymbolTerm.create(prologResource); com.googlecode.prolog_cafe.lang.JavaObjectTerm inTerm = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(new java.io.PushbackReader(new java.io.BufferedReader(new java.io.InputStreamReader(in, "UTF-8")), com.googlecode.prolog_cafe.lang.Prolog.PUSHBACK_SIZE)); if (!(env.execute(Prolog.BUILTIN, "consult_stream", pathTerm, inTerm))) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot consult " + prologResource)); } } finally { in.close(); } }
private void compileProlog(org.eclipse.jgit.lib.ObjectId prolog, java.io.File tempDir) throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { java.io.File tempRules = copyToTempFile(prolog, tempDir); try { java.lang.Compiler comp = new java.lang.Compiler(); comp.prologToJavaSource(tempRules.getPath(), tempDir.getPath()); } finally { tempRules.delete(); } }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment(com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.RuleEvalException { checkState(((patchSet) != null), "getPrologEnvironment() called before initPatchSet()"); com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((rule) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.ByteArrayInputStream(rule.getBytes(java.nio.charset.StandardCharsets.UTF_8))); } } catch (com.googlecode.prolog_cafe.compiler.CompileException err) { throw new com.google.gerrit.server.project.RuleEvalException(("Cannot consult rules.pl for " + (getProjectName())), err); } env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.PATCH_SET, patchSet); env.set(StoredValues.CHANGE_CONTROL, control); if (user != null) { env.set(StoredValues.CURRENT_USER, user); } return env; }
public synchronized com.googlecode.prolog_cafe.lang.PrologMachineCopy loadMachine(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId rulesId) throws com.googlecode.prolog_cafe.compiler.CompileException { if (((!(enableProjectRules)) || (project == null)) || (rulesId == null)) { return defaultMachine; } java.lang.ref.Reference<? extends com.googlecode.prolog_cafe.lang.PrologMachineCopy> ref = machineCache.get(rulesId); if (ref != null) { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = ref.get(); if (pmc != null) { return pmc; } machineCache.remove(rulesId); ref.enqueue(); } gc(); com.googlecode.prolog_cafe.lang.PrologMachineCopy pcm = createMachine(project, rulesId); com.google.gerrit.rules.RulesCache.MachineRef newRef = new com.google.gerrit.rules.RulesCache.MachineRef(rulesId, pcm, dead); machineCache.put(rulesId, newRef); return pcm; }
private com.googlecode.prolog_cafe.lang.PrologMachineCopy createMachine(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId rulesId) throws com.googlecode.prolog_cafe.compiler.CompileException { if ((rulesDir) != null) { java.nio.file.Path jarPath = rulesDir.resolve((("rules-" + (rulesId.getName())) + ".jar")); if (java.nio.file.Files.isRegularFile(jarPath)) { java.net.URL[] cp = new java.net.URL[]{ com.google.gerrit.rules.RulesCache.toURL(jarPath) }; return save(newEmptyMachine(new java.net.URLClassLoader(cp, systemLoader))); } } java.lang.String rules = read(project, rulesId); com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = consultRules("rules.pl", new java.io.StringReader(rules)); if (pmc == null) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot consult rules of " + project)); } return pmc; }
@java.lang.Override public int run() throws java.lang.Exception { dbInjector = createDbInjector(com.google.gerrit.pgm.SINGLE_USER); manager.add(dbInjector); manager.start(); dbInjector.createChildInjector(new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { factory(PrologCompiler.Factory.class); } }).injectMembers(this); java.util.LinkedHashSet<com.google.gerrit.reviewdb.client.Project.NameKey> names = new java.util.LinkedHashSet<>(); for (java.lang.String name : projectNames) { names.add(new com.google.gerrit.reviewdb.client.Project.NameKey(name)); } if (all) { names.addAll(gitManager.list()); } boolean error = false; for (com.google.gerrit.reviewdb.client.Project.NameKey project : names) { org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project); try { switch (jarFactory.create(git).call()) { case NO_RULES : if ((!(all)) || (projectNames.contains(project.get()))) { java.lang.System.err.println(("error: No rules.pl in " + (project.get()))); error = true; } break; case COMPILED : if (!(quiet)) { java.lang.System.out.format("Compiled %-60s ... SUCCESS", project.get()); java.lang.System.out.println(); } break; } } catch (com.googlecode.prolog_cafe.compiler.CompileException err) { if (showStackTrace) { err.printStackTrace(); } else { java.lang.System.err.println(("fatal: " + (err.getMessage()))); } error = true; } finally { git.close(); } } return !error ? 0 : 1; }
private com.googlecode.prolog_cafe.lang.PrologMachineCopy consultRules(java.lang.String name, java.io.Reader rules) throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.BufferingPrologControl ctl = newEmptyMachine(systemLoader); java.io.PushbackReader in = new java.io.PushbackReader(rules, com.googlecode.prolog_cafe.lang.Prolog.PUSHBACK_SIZE); try { if (!(ctl.execute(Prolog.BUILTIN, "consult_stream", com.googlecode.prolog_cafe.lang.SymbolTerm.intern(name), new com.googlecode.prolog_cafe.lang.JavaObjectTerm(in)))) { return null; } } catch (java.lang.RuntimeException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Error while consulting rules from " + name), e); } return save(ctl); }
@org.junit.Test public void testReductionLimit() throws com.googlecode.prolog_cafe.compiler.CompileException { com.google.gerrit.rules.PrologEnvironment env = envFactory.create(machine); setUpEnvironment(env); env.setEnabled(Prolog.Feature.IO, true); java.lang.String script = "loopy :- b(5).\n" + ("b(N) :- N > 0, !, S = N - 1, b(S).\n" + "b(_) :- true.\n"); com.googlecode.prolog_cafe.lang.SymbolTerm nameTerm = com.googlecode.prolog_cafe.lang.SymbolTerm.create("testReductionLimit"); com.googlecode.prolog_cafe.lang.JavaObjectTerm inTerm = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(new java.io.PushbackReader(new java.io.StringReader(script), com.googlecode.prolog_cafe.lang.Prolog.PUSHBACK_SIZE)); if (!(env.execute(Prolog.BUILTIN, "consult_stream", nameTerm, inTerm))) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot consult " + nameTerm)); } try { env.once(Prolog.BUILTIN, "call", new com.googlecode.prolog_cafe.lang.StructureTerm(":", com.googlecode.prolog_cafe.lang.SymbolTerm.create("user"), com.googlecode.prolog_cafe.lang.SymbolTerm.create("loopy"))); fail("long running loop did not abort with ReductionLimitException"); } catch (com.google.gerrit.rules.ReductionLimitException e) { assertThat(e.getMessage()).isEqualTo("exceeded reduction limit of 1300"); } }
private java.lang.String read(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId rulesId) throws com.googlecode.prolog_cafe.compiler.CompileException { org.eclipse.jgit.lib.Repository git; try { git = gitMgr.openRepository(project); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot open repository " + project), e); } catch (java.io.IOException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot open repository " + project), e); } try { org.eclipse.jgit.lib.ObjectLoader ldr = git.open(rulesId, Constants.OBJ_BLOB); byte[] raw = ldr.getCachedBytes(com.google.gerrit.rules.RulesCache.SRC_LIMIT); return org.eclipse.jgit.util.RawParseUtils.decode(raw); } catch (org.eclipse.jgit.errors.LargeObjectException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException((("rules of " + project) + " are too large"), e); } catch (java.lang.RuntimeException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot load rules of " + project), e); } catch (java.io.IOException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot load rules of " + project), e); } finally { git.close(); } }
public com.google.gerrit.rules.PrologEnvironment newPrologEnvironment() throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = rulesMachine; if (pmc == null) { pmc = rulesCache.loadMachine(getProject().getNameKey(), config.getRulesId()); rulesMachine = pmc; } return envFactory.create(pmc); }
@java.lang.Override public com.google.gerrit.rules.PrologCompiler.Status call() throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { org.eclipse.jgit.lib.ObjectId metaConfig = git.resolve(RefNames.REFS_CONFIG); if (metaConfig == null) { return com.google.gerrit.rules.PrologCompiler.Status.NO_RULES; } org.eclipse.jgit.lib.ObjectId rulesId = git.resolve(((metaConfig.name()) + ":rules.pl")); if (rulesId == null) { return com.google.gerrit.rules.PrologCompiler.Status.NO_RULES; } if ((ruleDir) == null) { throw new com.googlecode.prolog_cafe.compiler.CompileException("Caching not enabled"); } try { java.nio.file.Files.createDirectory(ruleDir); } catch (java.io.IOException e) { throw new java.io.IOException(("Cannot create " + (ruleDir))); } java.io.File tempDir = java.io.File.createTempFile("GerritCodeReview_", ".rulec"); if ((!(tempDir.delete())) || (!(tempDir.mkdir()))) { throw new java.io.IOException(("Cannot create " + tempDir)); } try { tempDir.setReadable(true, true); tempDir.setWritable(true, true); tempDir.setExecutable(true, true); compileProlog(rulesId, tempDir); compileJava(tempDir); java.nio.file.Path jarPath = ruleDir.resolve((("rules-" + (rulesId.getName())) + ".jar")); java.util.List<java.lang.String> classFiles = getRelativePaths(tempDir, ".class"); createJar(jarPath, classFiles, tempDir, metaConfig, rulesId); return com.google.gerrit.rules.PrologCompiler.Status.COMPILED; } finally { deleteAllFiles(tempDir); } }
public static void main(java.lang.String[] argv) throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { int i = 0; BuckPrologCompiler.tmpdir = new File(argv[(i++)]); File out = new File(argv[(i++)]); File java = BuckPrologCompiler.tmpdir("java"); for (; i < (argv.length); i++) { new java.lang.Compiler().prologToJavaSource(argv[i], java.getPath()); } BuckPrologCompiler.jar(out, java); }
private void compileJava(java.io.File tempDir) throws com.googlecode.prolog_cafe.compiler.CompileException, java.io.IOException { javax.tools.JavaCompiler compiler = javax.tools.ToolProvider.getSystemJavaCompiler(); if (compiler == null) { throw new com.googlecode.prolog_cafe.compiler.CompileException("JDK required (running inside of JRE)"); } javax.tools.DiagnosticCollector<javax.tools.JavaFileObject> diagnostics = new javax.tools.DiagnosticCollector<>(); javax.tools.StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null); try { java.lang.Iterable<? extends javax.tools.JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(getAllFiles(tempDir, ".java")); java.util.ArrayList<java.lang.String> options = new java.util.ArrayList<>(); java.lang.String classpath = getMyClasspath(); if (classpath != null) { options.add("-classpath"); options.add(classpath); } options.add("-d"); options.add(tempDir.getPath()); javax.tools.JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, options, null, compilationUnits); if (!(task.call())) { java.util.Locale myLocale = java.util.Locale.getDefault(); java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Cannot compile to Java bytecode:"); for (javax.tools.Diagnostic<? extends javax.tools.JavaFileObject> err : diagnostics.getDiagnostics()) { msg.append('\n'); msg.append(err.getKind()); msg.append(": "); if ((err.getSource()) != null) { msg.append(err.getSource().getName()); } msg.append(':'); msg.append(err.getLineNumber()); msg.append(": "); msg.append(err.getMessage(myLocale)); } throw new com.googlecode.prolog_cafe.compiler.CompileException(msg.toString()); } } finally { fileManager.close(); } }
public com.googlecode.prolog_cafe.lang.PrologMachineCopy loadMachine(java.lang.String name, java.io.InputStream in) throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = consultRules(name, new java.io.InputStreamReader(in)); if (pmc == null) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot consult rules from the stream " + name)); } return pmc; }
private static java.net.URL toURL(java.nio.file.Path jarPath) throws com.googlecode.prolog_cafe.compiler.CompileException { try { return jarPath.toUri().toURL(); } catch (java.net.MalformedURLException e) { throw new com.googlecode.prolog_cafe.compiler.CompileException(("Cannot create URL for " + jarPath), e); } }
public com.google.gerrit.rules.PrologEnvironment newPrologEnvironment(java.lang.String name, java.io.InputStream in) throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = rulesCache.loadMachine(name, in); return envFactory.create(pmc); }
public java.lang.String getUnifiedDiff() { com.google.gerrit.server.patch.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return "[Octopus merge; cannot be formatted as a diff.]\n"; } } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(args.settings.maximumDiffSize); try (org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf)) { org.eclipse.jgit.lib.Repository git; try { git = args.server.openRepository(change.getProject()); } catch (java.io.IOException e) { com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot open repository to format patch", e); return ""; } try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.ChangeEmail.log.error("Cannot format patch", e); return ""; } finally { git.close(); } } }
private static com.google.gerrit.extensions.restapi.BinaryResult base64(com.google.gerrit.extensions.restapi.BinaryResult bin) throws java.io.IOException { int max = 4 * (com.google.common.math.IntMath.divide(((int) (bin.getContentLength())), 3, java.math.RoundingMode.CEILING)); org.eclipse.jgit.util.TemporaryBuffer.Heap buf = com.google.gerrit.httpd.restapi.RestApiServlet.heap(max); java.io.OutputStream encoded = com.google.common.io.BaseEncoding.base64().encodingStream(new java.io.OutputStreamWriter(buf, java.nio.charset.StandardCharsets.ISO_8859_1)); bin.writeTo(encoded); encoded.close(); return com.google.gerrit.httpd.restapi.RestApiServlet.asBinaryResult(buf); }

private void setParents(java.lang.String project, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.CommitInfo> commits) { setVisible(parents, true); for (com.google.gerrit.client.changes.ChangeInfo.CommitInfo c : com.google.gerrit.client.rpc.Natives.asList(commits)) { com.google.gwtexpui.clippy.client.CopyableLabel copyLabel = new com.google.gwtexpui.clippy.client.CopyableLabel(c.commit()); copyLabel.setTitle(c.subject()); copyLabel.setStyleName(style.clippy()); parentCommits.add(copyLabel); com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if (gw != null) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(gw.getLinkName(), gw.toRevision(project, c.commit())); a.setStyleName(style.parentWebLink()); parentWebLinks.add(a); } com.google.gwt.core.client.JsArray<com.google.gerrit.client.WebLinkInfo> links = c.web_links(); if (links != null) { for (com.google.gerrit.client.WebLinkInfo link : com.google.gerrit.client.rpc.Natives.asList(links)) { parentWebLinks.add(link.toAnchor()); } } } }
private static void logGcConfiguration(com.google.gerrit.reviewdb.client.Project.NameKey projectName, org.eclipse.jgit.lib.Repository repo) { java.lang.StringBuilder b = new java.lang.StringBuilder(); org.eclipse.jgit.lib.Config cfg = repo.getConfig(); b.append(com.google.gerrit.server.git.GarbageCollection.formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, null)); for (java.lang.String subsection : cfg.getSubsections(ConfigConstants.CONFIG_GC_SECTION)) { b.append(com.google.gerrit.server.git.GarbageCollection.formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, subsection)); } if ((b.length()) == 0) { b.append("no set"); } com.google.gerrit.server.git.GarbageCollection.logGcInfo(projectName, ("gc config: " + (b.toString()))); com.google.gerrit.server.git.GarbageCollection.logGcInfo(projectName, ("pack config: " + (new org.eclipse.jgit.storage.pack.PackConfig(repo).toString()))); }

private void runGC() { java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> projectNames; if (all) { projectNames = com.google.common.collect.Lists.newArrayList(projectCache.all()); } else { projectNames = com.google.common.collect.Lists.newArrayListWithCapacity(projects.size()); for (com.google.gerrit.server.project.ProjectControl pc : projects) { projectNames.add(pc.getProject().getNameKey()); } } com.google.gerrit.common.data.GarbageCollectionResult result = garbageCollectionFactory.create().run(projectNames, (showProgress ? stdout : null)); if (result.hasErrors()) { for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { java.lang.String msg; switch (e.getType()) { case REPOSITORY_NOT_FOUND : msg = ("error: project \"" + (e.getProjectName())) + "\" not found"; break; case GC_ALREADY_SCHEDULED : msg = ("error: garbage collection for project \"" + (e.getProjectName())) + "\" was already scheduled"; break; case GC_FAILED : msg = ("error: garbage collection for project \"" + (e.getProjectName())) + "\" failed"; break; default : msg = (("error: garbage collection for project \"" + (e.getProjectName())) + "\" failed: ") + (e.getType()); } stdout.print((msg + "\n")); } } }
public com.google.gerrit.common.data.GarbageCollectionResult run(java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> projectNames, java.io.PrintWriter writer) { com.google.gerrit.common.data.GarbageCollectionResult result = new com.google.gerrit.common.data.GarbageCollectionResult(); java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> projectsToGc = gcQueue.addAll(projectNames); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : com.google.common.collect.Sets.difference(com.google.common.collect.Sets.newHashSet(projectNames), projectsToGc)) { result.addError(new com.google.gerrit.common.data.GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_ALREADY_SCHEDULED, projectName)); } for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectsToGc) { org.eclipse.jgit.lib.Repository repo = null; try { repo = repoManager.openRepository(p); com.google.gerrit.server.git.GarbageCollection.logGcConfiguration(p, repo); com.google.gerrit.server.git.GarbageCollection.print(writer, (("collecting garbage for \"" + p) + "\":\n")); org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); com.google.gerrit.server.git.GarbageCollection.logGcInfo(p, "before:", gc.getStatistics()); gc.setProgressMonitor((writer != null ? new org.eclipse.jgit.lib.TextProgressMonitor(writer) : org.eclipse.jgit.lib.NullProgressMonitor.INSTANCE)); java.util.Properties statistics = gc.call(); com.google.gerrit.server.git.GarbageCollection.logGcInfo(p, "after: ", statistics); com.google.gerrit.server.git.GarbageCollection.print(writer, "done.\n\n"); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { com.google.gerrit.server.git.GarbageCollection.logGcError(writer, p, e); result.addError(new com.google.gerrit.common.data.GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, p)); } catch (java.lang.Exception e) { com.google.gerrit.server.git.GarbageCollection.logGcError(writer, p, e); result.addError(new com.google.gerrit.common.data.GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, p)); } finally { if (repo != null) { repo.close(); } gcQueue.gcFinished(p); } } return result; }
@java.lang.SuppressWarnings("resource") @java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(final com.google.gerrit.server.project.ProjectResource rsrc, final com.google.gerrit.server.project.GarbageCollect.Input input) { return new com.google.gerrit.extensions.restapi.BinaryResult() { @java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.UTF_8)) { @java.lang.Override public void println() { write('\n'); } }; try { com.google.gerrit.common.data.GarbageCollectionResult result = garbageCollectionFactory.create().run(java.util.Collections.singletonList(rsrc.getNameKey()), (input.showProgress ? writer : null)); java.lang.String msg = "Garbage collection completed successfully."; if (result.hasErrors()) { for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case REPOSITORY_NOT_FOUND : msg = ("Error: project \"" + (e.getProjectName())) + "\" not found."; break; case GC_ALREADY_SCHEDULED : msg = ("Error: garbage collection for project \"" + (e.getProjectName())) + "\" was already scheduled."; break; case GC_FAILED : msg = ("Error: garbage collection for project \"" + (e.getProjectName())) + "\" failed."; break; default : msg = ((("Error: garbage collection for project \"" + (e.getProjectName())) + "\" failed: ") + (e.getType())) + "."; } } } writer.println(msg); } finally { writer.flush(); } } }.setContentType("text/plain").setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()).disableGzip(); }
@java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { java.io.PrintWriter writer = new java.io.PrintWriter(new java.io.OutputStreamWriter(out, java.nio.charset.StandardCharsets.UTF_8)) { @java.lang.Override public void println() { write('\n'); } }; try { com.google.gerrit.common.data.GarbageCollectionResult result = garbageCollectionFactory.create().run(java.util.Collections.singletonList(rsrc.getNameKey()), (input.showProgress ? writer : null)); java.lang.String msg = "Garbage collection completed successfully."; if (result.hasErrors()) { for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case REPOSITORY_NOT_FOUND : msg = ("Error: project \"" + (e.getProjectName())) + "\" not found."; break; case GC_ALREADY_SCHEDULED : msg = ("Error: garbage collection for project \"" + (e.getProjectName())) + "\" was already scheduled."; break; case GC_FAILED : msg = ("Error: garbage collection for project \"" + (e.getProjectName())) + "\" failed."; break; default : msg = ((("Error: garbage collection for project \"" + (e.getProjectName())) + "\" failed: ") + (e.getType())) + "."; } } } writer.println(msg); } finally { writer.flush(); } }

@java.lang.Override public com.google.gerrit.server.patch.IntraLineDiff load(com.google.gerrit.server.patch.IntraLineDiffKey key) throws java.lang.Exception { com.google.gerrit.server.patch.IntraLineWorkerPool.Worker w = workerPool.acquire(); com.google.gerrit.server.patch.IntraLineWorkerPool.Worker.Result r = w.computeWithTimeout(key, timeoutMillis); if (r == (IntraLineWorkerPool.Worker.Result.TIMEOUT)) { return new com.google.gerrit.server.patch.IntraLineDiff(IntraLineDiff.Status.TIMEOUT); } workerPool.release(w); if ((r.error) != null) { throw r.error; } return r.diff; }

public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.patch.PatchListKey.class, com.google.gerrit.server.patch.PatchList.class).maximumWeight((10 << 20)).loader(com.google.gerrit.server.patch.PatchListLoader.class).weigher(com.google.gerrit.server.patch.PatchListWeigher.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.patch.IntraLineDiffKey.class, com.google.gerrit.server.patch.IntraLineDiff.class).maximumWeight((10 << 20)).loader(com.google.gerrit.server.patch.IntraLineLoader.class).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.patch.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); } }; }
@java.lang.Override public com.google.gerrit.server.patch.PatchList load(final com.google.gerrit.server.patch.PatchListKey key) throws com.google.gerrit.server.patch.PatchListNotAvailableException, java.io.IOException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(key.projectKey); try { return readPatchList(key, repo); } finally { repo.close(); } }


public static org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> cloneProject(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String uri) throws java.lang.Exception { org.eclipse.jgit.internal.storage.dfs.InMemoryRepository dest = new org.eclipse.jgit.internal.storage.dfs.InMemoryRepository.Builder().setRepositoryDescription(new org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription(project.get())).setFS(org.eclipse.jgit.util.FS.detect()).build(); org.eclipse.jgit.lib.Config cfg = dest.getConfig(); cfg.setString("remote", "origin", "url", uri); cfg.setString("remote", "origin", "fetch", "+refs/heads/*:refs/remotes/origin/*"); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> testRepo = new org.eclipse.jgit.junit.TestRepository(dest); org.eclipse.jgit.transport.FetchResult result = testRepo.git().fetch().setRemote("origin").call(); java.lang.String originMaster = "refs/remotes/origin/master"; if ((result.getTrackingRefUpdate(originMaster)) != null) { testRepo.reset(originMaster); } return new org.eclipse.jgit.junit.TestRepository(dest); }
void close() { reopenThread.close(); try { searcherManager.maybeRefreshBlocking(); } catch (java.io.IOException e) { com.google.gerrit.lucene.SubIndex.log.warn("error finishing pending Lucene writes", e); } try { writer.getIndexWriter().commit(); try { writer.getIndexWriter().close(); } catch (org.apache.lucene.store.AlreadyClosedException e) { } } catch (java.io.IOException e) { com.google.gerrit.lucene.SubIndex.log.warn("error closing Lucene writer", e); } try { dir.close(); } catch (java.io.IOException e) { com.google.gerrit.lucene.SubIndex.log.warn("error closing Lucene directory", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.StarredChanges.EmptyInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if ((self.get()) != (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add starred change"); } try { dbProvider.get().starredChanges().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(rsrc.getUser().getAccountId(), change.getChange().getId())))); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { return com.google.gerrit.extensions.restapi.Response.none(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.StarredChange rsrc, com.google.gerrit.server.account.StarredChanges.EmptyInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if ((self.get()) != (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed remove starred change"); } dbProvider.get().starredChanges().delete(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(rsrc.getUser().getAccountId(), rsrc.getChange().getId())))); return com.google.gerrit.extensions.restapi.Response.none(); }


@java.lang.Override public void storeEvent(com.google.gerrit.server.events.ProjectEvent event) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = event.getProjectNameKey(); if (projectName == null) { return; } java.lang.String json = gson.toJson(event); try { java.sql.Connection conn = ds.getConnection(); java.sql.Statement stat = conn.createStatement(); try { stat.execute(((java.lang.String.format("INSERT INTO %s(%s, %s, %s) ", com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME, com.ericsson.gerrit.plugins.eventslog.SQLTable.PROJECT_ENTRY, com.ericsson.gerrit.plugins.eventslog.SQLTable.DATE_ENTRY, com.ericsson.gerrit.plugins.eventslog.SQLTable.EVENT_ENTRY)) + (java.lang.String.format("VALUES('%s', '%s', '%s')", projectName.get(), new java.sql.Timestamp(((event.eventCreatedOn) * 1000L)), json)))); } finally { closeStatement(stat); closeConnection(conn); } } catch (java.sql.SQLException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn(("Cannot store ChangeEvent for: " + (projectName.get())), e); } }
@java.lang.Override public void stop() { try { sqlClient.close(); } catch (java.sql.SQLException e) { throw new java.lang.RuntimeException("Cannot close datasource ", e); } }

private java.lang.String problemsForSubmittingChanges(java.util.List<com.google.gerrit.server.query.change.ChangeData> changes, com.google.gerrit.server.IdentifiedUser identifiedUser) { for (com.google.gerrit.server.query.change.ChangeData c : changes) { try { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl().forUser(identifiedUser); if (!(changeControl.isVisible(dbProvider.get()))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_TOPIC_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } checkSubmitRule(c, c.currentPatchSet(), false); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException(e); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } } return null; }
private void renderChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { changeInfo = info; lastDisplayedUpdate = info.updated(); labels.set(info); renderOwner(info); renderActionTextDate(info); renderDiffBaseListBox(info); initReplyButton(info, revision); initIncludedInAction(info); initChangeAction(info); initDownloadAction(info, revision); initProjectLinks(info); initBranchLink(info); initEditMode(info, revision); actions.display(info, revision); star.setValue(info.starred()); permalink.setHref(com.google.gerrit.client.ui.ChangeLink.permalink(changeId)); permalink.setText(java.lang.String.valueOf(info.legacy_id())); topic.set(info, revision); commit.set(commentLinkProcessor, info, revision); related.set(info, revision); reviewers.set(info); if (com.google.gerrit.client.Gerrit.isNoteDbEnabled()) { hashtags.set(info); } else { setVisible(hashtagTableRow, false); } java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append(Util.M.changeScreenTitleId(info.id_abbreviated())); if ((info.subject()) != null) { sb.append(": "); sb.append(info.subject()); } setWindowTitle(sb.toString()); com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> emptyMap = com.google.gerrit.client.rpc.NativeMap.<com.google.gerrit.client.actions.ActionInfo>create(); initRevisionsAction(info, revision, emptyMap); quickApprove.setVisible(false); setVisible(strategy, false); actions.reloadRevisionActions(emptyMap); }
private com.google.gerrit.extensions.api.projects.ProjectInput projectInput(org.junit.runner.Description description) { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); com.google.gerrit.acceptance.TestProjectInput ann = description.getAnnotation(com.google.gerrit.acceptance.TestProjectInput.class); if (ann != null) { in.name = ann.name(); in.parent = com.google.common.base.Strings.emptyToNull(ann.parent()); in.createEmptyCommit = ann.createEmptyCommit(); in.submitType = ann.submitType(); in.useContentMerge = ann.useContributorAgreements(); in.useSignedOffBy = ann.useSignedOffBy(); in.useContentMerge = ann.useContentMerge(); } else { in.createEmptyCommit = true; } if (com.google.common.base.Strings.isNullOrEmpty(in.name)) { in.name = "p"; } updateProjectInput(in); return in; }
@org.junit.Test public void listProjectsWithPrefix() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey someProject = new com.google.gerrit.reviewdb.client.Project.NameKey("some-project"); createProject(someProject.get()); com.google.gerrit.reviewdb.client.Project.NameKey someOtherProject = new com.google.gerrit.reviewdb.client.Project.NameKey("some-other-project"); createProject(someOtherProject.get()); com.google.gerrit.reviewdb.client.Project.NameKey projectAwesome = new com.google.gerrit.reviewdb.client.Project.NameKey("project-awesome"); createProject(projectAwesome.get()); com.google.gerrit.acceptance.rest.project.ListProjectsIT.assertBadRequest(gApi.projects().list().withPrefix("some").withRegex(".*")); com.google.gerrit.acceptance.rest.project.ListProjectsIT.assertBadRequest(gApi.projects().list().withPrefix("some").withSubstring("some")); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().list().withPrefix("some").get()).containsExactly(someOtherProject, someProject).inOrder(); }
@org.junit.Test public void listProjectsWithRegex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey someProject = new com.google.gerrit.reviewdb.client.Project.NameKey("some-project"); createProject(someProject.get()); com.google.gerrit.reviewdb.client.Project.NameKey someOtherProject = new com.google.gerrit.reviewdb.client.Project.NameKey("some-other-project"); createProject(someOtherProject.get()); com.google.gerrit.reviewdb.client.Project.NameKey projectAwesome = new com.google.gerrit.reviewdb.client.Project.NameKey("project-awesome"); createProject(projectAwesome.get()); com.google.gerrit.acceptance.rest.project.ListProjectsIT.assertBadRequest(gApi.projects().list().withRegex("[.*")); com.google.gerrit.acceptance.rest.project.ListProjectsIT.assertBadRequest(gApi.projects().list().withRegex(".*").withPrefix("p")); com.google.gerrit.acceptance.rest.project.ListProjectsIT.assertBadRequest(gApi.projects().list().withRegex(".*").withSubstring("p")); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().list().withRegex(".*some").get()).containsExactly(projectAwesome); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().list().withRegex("some-project$").get()).containsExactly(someProject); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().list().withRegex(".*").get()).containsExactly(allProjects, allUsers, project, projectAwesome, someOtherProject, someProject).inOrder(); }
@org.junit.Test public void listProjectsWithStart() throws java.lang.Exception { for (int i = 0; i < 5; i++) { createProject(new com.google.gerrit.reviewdb.client.Project.NameKey(("someProject" + i)).get()); } java.util.List<com.google.gerrit.extensions.common.ProjectInfo> all = gApi.projects().list().get(); int n = 8; assertThat(all).hasSize(n); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().list().withStart((n - 1)).get()).containsExactly(new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.common.collect.Iterables.getLast(all).name)); }
@org.junit.Test public void listProjectsWithLimit() throws java.lang.Exception { for (int i = 0; i < 5; i++) { createProject(new com.google.gerrit.reviewdb.client.Project.NameKey(("someProject" + i)).get()); } int n = 8; for (int i = 1; i <= (n + 2); i++) { assertThat(gApi.projects().list().withLimit(i).get()).hasSize(java.lang.Math.min(i, n)); } }


@org.junit.Test public void listChildren() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey child1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1"); createProject(child1.get()); com.google.gerrit.reviewdb.client.Project.NameKey child2 = new com.google.gerrit.reviewdb.client.Project.NameKey("p2"); createProject(child2.get()); com.google.gerrit.reviewdb.client.Project.NameKey child1_1 = new com.google.gerrit.reviewdb.client.Project.NameKey("p1.1"); createProject(child1_1.get(), child1); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().name(allProjects.get()).children()).containsExactly(allUsers, project, child1, child2).inOrder(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertThatNameList(gApi.projects().name(child1.get()).children()).containsExactly(child1_1); }

private void beforeTest(org.junit.runner.Description description, boolean memory, boolean enableHttpd) throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = config(description); server = startServer(cfg, memory, enableHttpd); server.getTestInjector().injectMembers(this); admin = accounts.admin(); user = accounts.user(); adminSession = new com.google.gerrit.acceptance.RestSession(server, admin); userSession = new com.google.gerrit.acceptance.RestSession(server, user); com.google.gerrit.acceptance.GitUtil.initSsh(admin); db = reviewDbProvider.open(); com.google.gerrit.acceptance.AcceptanceTestRequestScope.Context ctx = newRequestContext(admin); atrScope.set(ctx); sshSession = ctx.getSession(); sshSession.open(); com.google.gerrit.extensions.api.projects.ProjectInput projectInput = projectInput(description); project = new com.google.gerrit.reviewdb.client.Project.NameKey(projectInput.name); createProject(projectInput); testRepo = com.google.gerrit.acceptance.GitUtil.cloneProject(project, sshSession); }

protected void createProject(java.lang.String name, com.google.gerrit.reviewdb.client.Project.NameKey parent, boolean createEmptyCommit) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name; in.parent = (parent != null) ? parent.get() : null; in.createEmptyCommit = createEmptyCommit; createProject(in); }


private static void recursivelyDelete(java.io.File dir) throws java.io.IOException { if (!(dir.getPath().equals(dir.getCanonicalPath()))) { return; } java.io.File[] contents = dir.listFiles(); if (contents != null) { for (java.io.File d : contents) { if (d.isDirectory()) { com.google.gerrit.testutil.TempFileUtil.recursivelyDelete(d); } else { com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit(d); } } } com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit(dir); }
private void afterTest() throws java.lang.Exception { db.close(); sshSession.close(); server.stop(); com.google.gerrit.testutil.TempFileUtil.cleanup(); }

private void beforeTest(org.eclipse.jgit.lib.Config cfg, boolean memory, boolean enableHttpd) throws java.lang.Exception { server = startServer(cfg, memory, enableHttpd); server.getTestInjector().injectMembers(this); admin = accounts.admin(); user = accounts.user(); adminSession = new com.google.gerrit.acceptance.RestSession(server, admin); userSession = new com.google.gerrit.acceptance.RestSession(server, user); com.google.gerrit.acceptance.GitUtil.initSsh(admin); db = reviewDbProvider.open(); com.google.gerrit.acceptance.AcceptanceTestRequestScope.Context ctx = newRequestContext(admin); atrScope.set(ctx); sshSession = ctx.getSession(); project = new com.google.gerrit.reviewdb.client.Project.NameKey("p"); com.google.gerrit.acceptance.GitUtil.createProject(sshSession, project.get()); git = com.google.gerrit.acceptance.GitUtil.cloneProject((((sshSession.getUrl()) + "/") + (project.get()))); }

@org.junit.Before public void setUp() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig(); codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review")); codeReview.setDefaultValue(((short) (-1))); saveProjectConfig(cfg); }

private static void mergeTestConfig(org.eclipse.jgit.lib.Config cfg) { java.lang.String forceEphemeralPort = java.lang.String.format("%s:0", com.google.gerrit.acceptance.GerritServer.getLocalHost().getHostName()); java.lang.String url = ("http://" + forceEphemeralPort) + "/"; cfg.setString("gerrit", null, "canonicalWebUrl", url); cfg.setString("httpd", null, "listenUrl", url); cfg.setString("sshd", null, "listenAddress", forceEphemeralPort); cfg.setBoolean("sshd", null, "testUseInsecureRandom", true); cfg.setString("cache", null, "directory", null); cfg.setString("gerrit", null, "basePath", "git"); cfg.setBoolean("sendemail", null, "enable", false); cfg.setInt("cache", "projects", "checkFrequency", 0); cfg.setInt("plugins", null, "checkFrequency", 0); }
@java.lang.Override public java.lang.String toString() { return runnable.toString(); }
private void initFileSystemFactory() { setFileSystemFactory(new org.apache.sshd.common.file.FileSystemFactory() { @java.lang.Override public org.apache.sshd.common.file.FileSystemView createFileSystemView(org.apache.sshd.common.Session session) throws java.io.IOException { return new org.apache.sshd.common.file.FileSystemView() { @java.lang.Override public org.apache.sshd.common.file.SshFile getFile(org.apache.sshd.common.file.SshFile baseDir, java.lang.String file) { return null; } @java.lang.Override public org.apache.sshd.common.file.SshFile getFile(java.lang.String file) { return null; } }; } }); }
@java.lang.Override public org.apache.sshd.common.file.FileSystemView createFileSystemView(org.apache.sshd.common.Session session) throws java.io.IOException { return new org.apache.sshd.common.file.FileSystemView() { @java.lang.Override public org.apache.sshd.common.file.SshFile getFile(org.apache.sshd.common.file.SshFile baseDir, java.lang.String file) { return null; } @java.lang.Override public org.apache.sshd.common.file.SshFile getFile(java.lang.String file) { return null; } }; }
public static java.lang.String getSecureStoreClassName(final java.io.File sitePath) { if (sitePath != null) { return com.google.gerrit.server.config.GerritServerConfigModule.getSecureStoreFromGerritConfig(sitePath); } java.lang.String secureStoreProperty = java.lang.System.getProperty("gerrit.secure_store_class"); return com.google.gerrit.server.config.GerritServerConfigModule.nullToDefault(secureStoreProperty); }
private org.eclipse.jgit.patch.FileHeader toFileHeader(com.google.gerrit.server.patch.PatchListKey key, final org.eclipse.jgit.diff.DiffFormatter diffFormatter, final org.eclipse.jgit.diff.DiffEntry diffEntry) throws java.io.IOException { java.util.concurrent.Future<org.eclipse.jgit.patch.FileHeader> result = diffExecutor.submit(new java.util.concurrent.Callable<org.eclipse.jgit.patch.FileHeader>() { @java.lang.Override public org.eclipse.jgit.patch.FileHeader call() throws java.io.IOException { return diffFormatter.toFileHeader(diffEntry); } }); { return result.get(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS); } }
@java.lang.Override public java.util.List<java.lang.String> queryChangeEvents(java.lang.String query) throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException, com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException { if (!(online)) { throw new com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException(); } java.util.List<java.lang.String> events = new java.util.ArrayList<>(); com.google.gerrit.reviewdb.client.Project.NameKey project = null; for (java.util.Map.Entry<java.lang.String, java.util.Collection<java.lang.String>> entry : eventsDb.getEvents(query).asMap().entrySet()) { try { project = new com.google.gerrit.reviewdb.client.Project.NameKey(entry.getKey()); if (projectControlFactory.controlFor(project, userProvider.get()).isVisible()) { events.addAll(entry.getValue()); } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn((("Database contains a non-existing project, " + (project.get())) + ", removing project from database"), e); removeProjectEvents(project.get()); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn((("Cannot get project visibility info for " + (project.get())) + " from cache"), e); } } return events; }

@java.lang.Override public com.google.gerrit.extensions.api.projects.ProjectApi create(com.google.gerrit.extensions.api.projects.ProjectInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { if ((name) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Project already exists"); } if (((in.name) != null) && (!(name.equals(in.name)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("name must match input.name"); } createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in); return projectApi.create(projects.parse(name)); } catch (com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.extensions.restapi.ResourceNotFoundException | com.google.gerrit.common.errors.ProjectCreationFailedException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException(("Cannot create project: " + (e.getMessage())), e); } }
@java.lang.Override public java.lang.Boolean load(com.google.gerrit.server.change.MergeabilityCacheImpl.EntryKey key) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { checkArgument(((key.load) != null), "Key cannot be loaded: %s", key); if (key.into.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return true; } try { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = key.load.repo.getAllRefs(); org.eclipse.jgit.revwalk.RevWalk rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(key.load.repo); try { org.eclipse.jgit.revwalk.RevFlag canMerge = rw.newFlag("CAN_MERGE"); com.google.gerrit.server.git.CodeReviewCommit rev = com.google.gerrit.server.change.MergeabilityCacheImpl.Loader.parse(rw, key.commit); rev.add(canMerge); com.google.gerrit.server.git.CodeReviewCommit tip = com.google.gerrit.server.change.MergeabilityCacheImpl.Loader.parse(rw, key.into); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> accepted = com.google.gerrit.server.change.MergeabilityCacheImpl.Loader.alreadyAccepted(rw, refs.values()); accepted.add(tip); accepted.addAll(java.util.Arrays.asList(rev.getParents())); return submitStrategyFactory.create(key.submitType, key.load.db, key.load.repo, rw, null, canMerge, accepted, key.load.dest).dryRun(tip, rev); } finally { rw.release(); } } finally { key.load = null; } }

@org.junit.Before public void setUp() throws java.lang.Exception { new com.google.gerrit.testutil.InMemoryModule().inject(this); }
@org.junit.Before public void setUp() throws java.lang.Exception { com.google.gerrit.testutil.FakeAccountByEmailCache accountCache = new com.google.gerrit.testutil.FakeAccountByEmailCache(); schemaFactory = com.google.gerrit.testutil.InMemoryDatabase.newDatabase(); schemaFactory.create(); db = schemaFactory.open(); repoManager = new com.google.gerrit.testutil.InMemoryRepositoryManager(); checker = new com.google.gerrit.server.change.ConsistencyChecker(com.google.inject.util.Providers.<com.google.gerrit.reviewdb.server.ReviewDb>of(db), repoManager, com.google.inject.util.Providers.<com.google.gerrit.server.CurrentUser>of(new com.google.gerrit.server.InternalUser(null)), com.google.inject.util.Providers.of(new org.eclipse.jgit.lib.PersonIdent("server", "noreply@example.com")), new com.google.gerrit.server.patch.PatchSetInfoFactory(repoManager, accountCache)); project = new com.google.gerrit.reviewdb.client.Project.NameKey("repo"); repo = new org.eclipse.jgit.junit.TestRepository(repoManager.createRepository(project)); userId = new com.google.gerrit.reviewdb.client.Account.Id(1); accountCache.putAny(userId); db.accounts().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()))); tip = repo.branch("master").commit().create(); }







@com.google.gwt.uibinder.client.UiHandler("cancel") void onCancel(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { hide(); }
@java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gerrit.client.ui.RemoteSuggestBox> event) { hide(); }



private void createEditCommand() { cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), newCommit, com.google.gerrit.server.edit.ChangeEditUtil.editRefName(currentUser.getAccountId(), change.getId(), newPatchSet.getId())); }
@org.junit.Test public void changeEditRef() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1000042); com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id(56414); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, 50); java.lang.String refName = com.google.gerrit.server.edit.ChangeEditUtil.editRefName(accountId, changeId, psId); assertEquals("refs/users/42/1000042/edit-56414/50", refName); }


public com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> byChange(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser user) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject())) { java.lang.String editRefPrefix = com.google.gerrit.server.edit.ChangeEditUtil.editRefPrefix(user.getAccountId(), change.getId()); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix); if (refs.isEmpty()) { return com.google.common.base.Optional.absent(); } org.eclipse.jgit.lib.Ref ref = com.google.common.collect.Iterables.getOnlyElement(refs.values()); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(ref.getObjectId()); com.google.gerrit.reviewdb.client.PatchSet basePs = getBasePatchSet(change, ref); return com.google.common.base.Optional.of(new com.google.gerrit.server.edit.ChangeEdit(user, change, ref, commit, basePs)); } } }
public RefUpdate.Result createEdit(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.server.IdentifiedUser me = ((com.google.gerrit.server.IdentifiedUser) (currentUser.get())); java.lang.String refPrefix = com.google.gerrit.server.edit.ChangeEditUtil.editRefPrefix(me.getAccountId(), change.getId()); try (org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject())) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(refPrefix); if (!(refs.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("edit already exists"); } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId revision = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); java.lang.String editRefName = com.google.gerrit.server.edit.ChangeEditUtil.editRefName(me.getAccountId(), change.getId(), ps.getId()); return update(repo, me, editRefName, rw, org.eclipse.jgit.lib.ObjectId.zeroId(), revision); } } }
public java.lang.String getRefName() { return com.google.gerrit.server.edit.ChangeEditUtil.editRefName(user.getAccountId(), change.getId(), basePatchSet.getId()); }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { boolean link = (req.getParameter("link")) != null; java.lang.String id = com.google.common.base.Strings.nullToEmpty(req.getParameter("id")).trim(); if (id.isEmpty()) { sendForm(req, res, link, null); return; } if ((!(id.startsWith("http://"))) && (!(id.startsWith("https://")))) { id = "http://" + id; } if ((((ssoUrl) != null) && (!(ssoUrl.equals(id)))) || (!(impl.isAllowedOpenID(id)))) { sendForm(req, res, link, "OpenID provider not permitted by site policy."); return; } boolean remember = "1".equals(req.getParameter("rememberme")); java.lang.String token = com.google.gerrit.httpd.LoginUrlToken.getToken(req); com.google.gerrit.httpd.auth.openid.SignInMode mode; if (link) { mode = SignInMode.LINK_IDENTIY; } else if (PageLinks.REGISTER.equals(token)) { mode = SignInMode.REGISTER; token = com.google.gerrit.common.PageLinks.MINE; } else { mode = SignInMode.SIGN_IN; } discover(req, res, link, id, remember, token, mode); }


private org.eclipse.jgit.revwalk.RevWalk verifyConnected(final org.eclipse.jgit.lib.Repository repo, final org.eclipse.jgit.lib.ObjectId revid) throws com.google.gerrit.common.errors.InvalidRevisionException { try { final org.eclipse.jgit.revwalk.ObjectWalk rw = new org.eclipse.jgit.revwalk.ObjectWalk(repo); try { rw.markStart(rw.parseCommit(revid)); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException err) { throw new com.google.gerrit.common.errors.InvalidRevisionException(); } for (final org.eclipse.jgit.lib.Ref r : repo.getRefDatabase().getRefs(com.google.gerrit.server.project.ALL).values()) { try { rw.markUninteresting(rw.parseAny(r.getObjectId())); } catch (org.eclipse.jgit.errors.MissingObjectException err) { continue; } } rw.checkConnectivity(); return rw; } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException err) { throw new com.google.gerrit.common.errors.InvalidRevisionException(); } catch (org.eclipse.jgit.errors.MissingObjectException err) { throw new com.google.gerrit.common.errors.InvalidRevisionException(); } catch (java.io.IOException err) { com.google.gerrit.server.project.CreateBranch.log.error((("Repository \"" + (repo.getDirectory())) + "\" may be corrupt; suggest running git fsck"), err); throw new com.google.gerrit.common.errors.InvalidRevisionException(); } }

@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.importer.Failure, com.googlesource.gerrit.plugins.importer.UnloggedFailure, java.lang.Exception { try { com.googlesource.gerrit.plugins.importer.ImportProjectResource rsrc = projects.parse(project); if (!(quiet)) { resume.setErr(stderr); } com.googlesource.gerrit.plugins.importer.ResumeProjectImport.Input input = new com.googlesource.gerrit.plugins.importer.ResumeProjectImport.Input(); input.user = user; input.pass = pass; input.force = force; com.googlesource.gerrit.plugins.importer.ResumeImportStatistic stats = resume.apply(rsrc, input); stdout.print((("Created Changes: " + (stats.numChangesCreated)) + "\n")); stdout.print((("Updated Changes: " + (stats.numChangesUpdated)) + "\n")); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private com.google.gerrit.server.account.CreateGroupArgs toCreateGroupArgs(GroupInfo groupInfo) throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.account.CreateGroupArgs args = new com.google.gerrit.server.account.CreateGroupArgs(); args.setGroupName(groupInfo.name); args.groupDescription = groupInfo.description; args.visibleToAll = cfg.getBoolean("groups", "newGroupsVisibleToAll", false); if (!(groupInfo.ownerId.equals(groupInfo.id))) { args.ownerGroupId = getGroupByUUID(groupInfo.ownerId).getId(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> initialMembers = new java.util.HashSet<>(); for (com.google.gerrit.extensions.common.AccountInfo member : groupInfo.members) { initialMembers.add(accountUtil.resolveUser(api, member)); } args.initialMembers = initialMembers; java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> initialGroups = new java.util.HashSet<>(); for (GroupInfo member : groupInfo.includes) { initialGroups.add(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(member.id)); } args.initialGroups = initialGroups; return args; }
void reloadRevisionActions(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions) { if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { return; } boolean canSubmit = actions.containsKey("submit"); if (canSubmit) { com.google.gerrit.client.actions.ActionInfo action = actions.get("submit"); submit.setTitle(action.title()); submit.setEnabled(action.enabled()); submit.setHTML(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openDiv().append(action.label()).closeDiv()); submit.setEnabled(action.enabled()); } submit.setVisible(canSubmit); com.google.gerrit.client.change.b6b6ee Fix; }
private static com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> topic(java.lang.String topic) { return new com.google.gerrit.server.query.change.TopicPredicate(topic); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> topic(java.lang.String name) { if (name.startsWith("^")) { return new com.google.gerrit.server.query.change.RegexTopicPredicate(name); } return new com.google.gerrit.server.query.change.TopicPredicate(name); }


private com.google.gerrit.reviewdb.client.SubmoduleSubscription parse(final java.lang.String id) { final java.lang.String url = bbc.getString("submodule", id, "url"); final java.lang.String path = bbc.getString("submodule", id, "path"); java.lang.String branch = bbc.getString("submodule", id, "branch"); try { if ((((((url != null) && ((url.length()) > 0)) && (path != null)) && ((path.length()) > 0)) && (branch != null)) && ((branch.length()) > 0)) { boolean urlIsRelative = url.startsWith("../"); java.lang.String server = null; if (!urlIsRelative) { server = new java.net.URI(url).getHost(); } if (urlIsRelative || ((server != null) && (server.equalsIgnoreCase(thisServer)))) { if (branch.equals(".")) { branch = superProjectBranch.get(); } else if (!(branch.startsWith(Constants.R_REFS))) { branch = (org.eclipse.jgit.lib.Constants.R_HEADS) + branch; } final java.lang.String urlExtractedPath = new java.net.URI(url).getPath(); java.lang.String projectName; int fromIndex = (urlExtractedPath.length()) - 1; while (fromIndex > 0) { fromIndex = urlExtractedPath.lastIndexOf('/', (fromIndex - 1)); projectName = urlExtractedPath.substring((fromIndex + 1)); if (projectName.endsWith(Constants.DOT_GIT_EXT)) { projectName = projectName.substring(0, ((projectName.length()) - (Constants.DOT_GIT_EXT.length()))); } if (repoManager.list().contains(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName))) { return new com.google.gerrit.reviewdb.client.SubmoduleSubscription(superProjectBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), branch), path); } } } } } catch (java.net.URISyntaxException e) { } return null; }
private static com.google.inject.Injector createTestInjector(com.google.gerrit.pgm.Daemon daemon) throws java.lang.Exception { com.google.inject.Injector sysInjector = com.google.gerrit.acceptance.GerritServer.get(daemon, "sysInjector"); java.lang.Module module = new com.google.gerrit.server.config.FactoryModule() { @java.lang.Override protected void configure() { bind(com.google.gerrit.acceptance.AccountCreator.class); factory(PushOneCommit.Factory.class); factory(SubmoduleOp.Factory.class); install(com.google.gerrit.acceptance.InProcessProtocol.module()); install(new com.google.gerrit.server.ssh.NoSshModule()); install(new com.google.gerrit.server.git.AsyncReceiveCommits.Module()); } }; return sysInjector.createChildInjector(module); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.acceptance.AccountCreator.class); factory(PushOneCommit.Factory.class); factory(SubmoduleOp.Factory.class); install(com.google.gerrit.acceptance.InProcessProtocol.module()); install(new com.google.gerrit.server.ssh.NoSshModule()); install(new com.google.gerrit.server.git.AsyncReceiveCommits.Module()); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.RequestCleanup.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.server.config.RequestScopedReviewDbProvider.class); bind(IdentifiedUser.RequestFactory.class).in(com.google.gerrit.server.config.SINGLETON); bind(com.google.gerrit.server.project.PerRequestProjectControlCache.class).in(com.google.inject.servlet.RequestScoped.class); bind(ProjectControl.Factory.class).in(com.google.gerrit.server.config.SINGLETON); factory(SubmoduleOp.Factory.class); factory(MergeOp.Factory.class); }
@java.lang.Override protected com.google.gerrit.common.data.ProjectAccess updateProjectConfig(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.server.git.MetaDataUpdate md, boolean parentProjectUpdate) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.revwalk.RevCommit commit = config.commit(md); hooks.doRefUpdatedHook(new com.google.gerrit.reviewdb.client.Branch.NameKey(config.getProject().getNameKey(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), base, commit.getId(), user.getAccount()); projectCache.evict(config.getProject()); return projectAccessFactory.create(projectName).call(); }
protected abstract T updateProjectConfig(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.server.git.MetaDataUpdate md, boolean parentProjectUpdate) throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException;











private java.lang.String getScope(java.util.Set<com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope> scopes) { if ((scopes.size()) <= 0) { return ""; } java.lang.StringBuilder out = new java.lang.StringBuilder(); for (com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope scope : scopes) { if ((out.length()) > 0) { out.append(","); } out.append(scope.getValue()); } return ("&" + "scope=") + (out.toString()); }
private void configureAuth() { github.string("ClientId", "clientId", null); github.string("ClientSecret", "clientSecret", null); auth.string("HTTP Authentication Header", "httpHeader", "GITHUB_USER"); auth.set("type", "HTTP"); httpd.set("filterClass", "com.googlesource.gerrit.plugins.github.oauth.OAuthFilter"); }


private java.lang.String problemsForSubmittingChanges(java.util.List<com.google.gerrit.server.query.change.ChangeData> changes, com.google.gerrit.server.IdentifiedUser identifiedUser) { for (com.google.gerrit.server.query.change.ChangeData c : changes) { try { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl().forUser(identifiedUser); if (!(changeControl.isVisible(dbProvider.get()))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_TOPIC_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } checkSubmitRule(c, c.currentPatchSet(), false); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException(e); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } } return null; }
public static com.google.gerrit.server.index.IndexConfig create(int maxLimit) { checkArgument((maxLimit > 0), "maxLimit must be positive: %s", maxLimit); return new com.google.gerrit.server.index.AutoValue_IndexConfig(maxLimit); }
public static com.google.gerrit.server.index.IndexConfig fromConfig(org.eclipse.jgit.lib.Config cfg) { return com.google.gerrit.server.index.IndexConfig.create(cfg.getInt("index", null, "maxLimit", java.lang.Integer.MAX_VALUE)); }
public static com.google.gerrit.server.index.IndexConfig createDefault() { return com.google.gerrit.server.index.IndexConfig.create(java.lang.Integer.MAX_VALUE); }

static void call(com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, final java.lang.String commitSubject) { b.setEnabled(false); new com.google.gerrit.client.ui.TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) { { sendButton.setText(Util.C.buttonRevertChangeSend()); message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.legacy_id())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } }.center(); }
private void updateNonChangeRefs(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(ConfigureRepositoryStep.R_IMPORTS); for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : refs.entrySet()) { java.lang.String name = e.getKey(); if (name.startsWith("changes/")) { continue; } if ((name.startsWith("users/")) && (name.contains("/edit"))) { continue; } java.lang.String targetRef = (org.eclipse.jgit.lib.Constants.R_REFS) + (e.getKey()); org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(targetRef); ru.setNewObjectId(e.getValue().getObjectId()); org.eclipse.jgit.lib.RefUpdate.Result result = ru.forceUpdate(); switch (result) { case NEW : case FAST_FORWARD : case FORCED : case NO_CHANGE : break; default : throw new java.io.IOException(java.lang.String.format("Failed to update %s, RefUpdate.Result = %s", targetRef, result)); } } }
@java.lang.Override protected void onInitUI() { super.onInitUI(); table = new com.google.gerrit.client.changes.ChangeTable() { { keysNavigation.add(new com.google.gwtexpui.globalkey.client.KeyCommand(0, 'R', Util.C.keyReloadSearch()) { @java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(getToken()); } }); } }; table.addStyleName(Gerrit.RESOURCES.css().accountDashboard()); outgoing = new com.google.gerrit.client.changes.ChangeTable.Section(); incoming = new com.google.gerrit.client.changes.ChangeTable.Section(); closed = new com.google.gerrit.client.changes.ChangeTable.Section(); outgoing.setTitleText(Util.C.outgoingReviews()); incoming.setTitleText(Util.C.incomingReviews()); incoming.setHighlightUnreviewed(mine); closed.setTitleText(Util.C.recentlyClosed()); table.addSection(outgoing); table.addSection(incoming); table.addSection(closed); add(table); table.setSavePointerId(("owner:" + (ownerId))); }
@java.lang.Override public com.google.gerrit.server.account.GroupMembership membershipsOf(com.google.gerrit.server.IdentifiedUser user) { return ghMembershipProvider.get(user.getUserName()); }


@org.junit.Test public void testPatchLineCommentsUtilByCommentStatus() throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedActual = plcUtil.publishedByChange(db, revRes2.getNotes()); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftActual = plcUtil.draftByChange(db, revRes2.getNotes()); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> publishedExpected = com.google.common.collect.Lists.newArrayList(plc1, plc2, plc3); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftExpected = com.google.common.collect.Lists.newArrayList(plc4, plc5); assertEquals(publishedExpected.size(), publishedActual.size()); assertEquals(draftExpected.size(), draftActual.size()); assertEquals(publishedExpected, publishedActual); assertEquals(draftExpected, draftActual); }
@java.lang.Override void apply(com.google.gerrit.server.notedb.ChangeUpdate update) throws com.google.gwtorm.server.OrmException { checkUpdate(update); if ((c.getRevId()) == null) { com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId(c, cache, change, ps); } update.insertComment(c); }
void applyDraft(com.google.gerrit.server.notedb.ChangeDraftUpdate draftUpdate) throws com.google.gwtorm.server.OrmException { if ((c.getRevId()) == null) { com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId(c, cache, change, ps); } draftUpdate.insertComment(c); }
public static void setCommentRevId(com.google.gerrit.reviewdb.client.PatchLineComment c, com.google.gerrit.server.patch.PatchListCache cache, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { if ((c.getRevId()) != null) { return; } com.google.gerrit.server.patch.PatchList patchList; try { patchList = cache.get(change, ps); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.google.gwtorm.server.OrmException(e); } c.setRevId(((c.getSide()) == ((short) (0)) ? new com.google.gerrit.reviewdb.client.RevId(org.eclipse.jgit.lib.ObjectId.toString(patchList.getOldId())) : new com.google.gerrit.reviewdb.client.RevId(org.eclipse.jgit.lib.ObjectId.toString(patchList.getNewId())))); }
private void assertListComments(com.google.gerrit.server.change.RevisionResource res, java.util.Map<java.lang.String, java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>> expected) throws java.lang.Exception { com.google.gerrit.extensions.restapi.RestReadView<com.google.gerrit.server.change.RevisionResource> listView = ((com.google.gerrit.extensions.restapi.RestReadView<com.google.gerrit.server.change.RevisionResource>) (comments.list())); @java.lang.SuppressWarnings("unchecked") java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> actual = ((java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>>) (listView.apply(res))); assertNotNull(actual); assertEquals(expected.size(), actual.size()); assertEquals(expected.keySet(), actual.keySet()); for (java.util.Map.Entry<java.lang.String, java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>> entry : expected.entrySet()) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> expectedComments = entry.getValue(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> actualComments = actual.get(entry.getKey()); assertNotNull(actualComments); assertEquals(expectedComments.size(), actualComments.size()); for (int i = 0; i < (expectedComments.size()); i++) { com.google.gerrit.server.change.CommentsTest.assertComment(expectedComments.get(i), actualComments.get(i), true); } } }
private org.eclipse.jgit.lib.ObjectId storeCommentsInNotes() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = ctl.getNotes().load(); org.eclipse.jgit.notes.NoteMap noteMap = notes.getNoteMap(); if (noteMap == null) { noteMap = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); } if ((commentsForPs.isEmpty()) && (commentsForBase.isEmpty())) { return null; } com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnBases = notes.getBaseComments(); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchLineComment> allCommentsOnPs = notes.getPatchSetComments(); if (!(commentsForBase.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> baseCommentsForThisPs = new java.util.ArrayList(allCommentsOnBases.get(psId)); baseCommentsForThisPs.addAll(commentsForBase); commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter); } if (!(commentsForPs.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> commentsForThisPs = new java.util.ArrayList(allCommentsOnPs.get(psId)); commentsForThisPs.addAll(commentsForPs); commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter); } return noteMap.writeTree(inserter); }
public void writeCommentsToNoteMap(org.eclipse.jgit.notes.NoteMap noteMap, java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> allComments, org.eclipse.jgit.lib.ObjectInserter inserter) throws java.io.IOException { checkArgument((!(allComments.isEmpty())), "No comments to write; to delete, use removeNoteFromNoteMap()."); org.eclipse.jgit.lib.ObjectId commit = org.eclipse.jgit.lib.ObjectId.fromString(allComments.get(0).getRevId().get()); java.util.Collections.sort(allComments, ChangeNotes.PLC_ORDER); noteMap.set(commit, inserter.insert(com.google.gerrit.server.notedb.OBJ_BLOB, buildNote(allComments))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> apply(com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gerrit.server.change.DeleteDraftComment.Input input) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(rsrc.getControl()); com.google.gerrit.reviewdb.client.PatchLineComment c = rsrc.getComment(); com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet()); plcUtil.deleteComments(db.get(), update, java.util.Collections.singleton(c)); update.commit(); return com.google.gerrit.extensions.restapi.Response.none(); }
private void assertListDrafts(com.google.gerrit.server.change.RevisionResource res, java.util.Map<java.lang.String, java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>> expected) throws java.lang.Exception { com.google.gerrit.extensions.restapi.RestReadView<com.google.gerrit.server.change.RevisionResource> listView = ((com.google.gerrit.extensions.restapi.RestReadView<com.google.gerrit.server.change.RevisionResource>) (drafts.list())); @java.lang.SuppressWarnings("unchecked") java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> actual = ((java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>>) (listView.apply(res))); assertNotNull(actual); assertEquals(expected.size(), actual.size()); assertEquals(expected.keySet(), actual.keySet()); for (java.util.Map.Entry<java.lang.String, java.util.ArrayList<com.google.gerrit.reviewdb.client.PatchLineComment>> entry : expected.entrySet()) { java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> expectedComments = entry.getValue(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> actualComments = actual.get(entry.getKey()); assertNotNull(actualComments); assertEquals(expectedComments.size(), actualComments.size()); for (int i = 0; i < (expectedComments.size()); i++) { com.google.gerrit.server.change.CommentsTest.assertComment(expectedComments.get(i), actualComments.get(i), false); } } }

public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChangeAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return com.google.gerrit.server.PatchLineCommentsUtil.sort(db.patchComments().byChange(notes.getChangeId()).toList()); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getDraftBaseComments(author).values()); comments.addAll(notes.getDraftPsComments(author).values()); return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
public static com.google.gerrit.client.changes.ReviewInput create() { com.google.gerrit.client.changes.ReviewInput r = createObject().cast(); r.init(); r.drafts(com.google.gerrit.client.changes.ReviewInput.DraftHandling.PUBLISH); return r; }
private void attachComments(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { in.drafts(ReviewInput.DraftHandling.KEEP); in.comments(result); }
public void putComment(com.google.gerrit.reviewdb.client.PatchLineComment comment) { checkArgument(((psId) != null), "setPatchSetId must be called before putComment"); checkArgument(com.google.gerrit.server.notedb.CommentsInNotesUtil.getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", com.google.gerrit.server.notedb.CommentsInNotesUtil.getCommentPsId(comment), psId); checkArgument(((comment.getRevId()) != null)); if ((comment.getSide()) == 0) { commentsForBase.add(comment); } else { commentsForPs.add(comment); } }
@java.lang.Override protected void onLoad() { commentsPanel.setVisible(false); post.setEnabled(false); com.google.gerrit.client.changes.CommentApi.drafts(psId, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { attachComments(result); displayComments(result); post.setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { post.setEnabled(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { java.lang.String t = message.getText(); if (t != null) { message.setCursorPos(t.length()); } return false; } }, 0); }


@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(result); history.addComments(id, result); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gwtorm.server.OrmException { try { com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> r = com.google.gerrit.extensions.restapi.Response.ok(json.toCommit(resource.getPatchSet(), resource.getChange().getProject(), addLinks)); if (resource.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e) { throw new com.google.gwtorm.server.OrmException(e); } }

private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map) throws com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = com.google.common.collect.Maps.newLinkedHashMap(); for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { if (((has(com.google.gerrit.server.change.ALL_REVISIONS)) || (in.getId().equals(cd.change().currentPatchSetId()))) && (ctl.isPatchVisible(in, db.get()))) { res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in)); } } return res; }
private java.lang.String problemsForSubmittingChanges(java.util.List<com.google.gerrit.server.query.change.ChangeData> changeList, com.google.gerrit.server.IdentifiedUser identifiedUser) { try { for (com.google.gerrit.server.query.change.ChangeData c : changeList) { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl().forUser(identifiedUser); if (!(changeControl.isVisible(dbProvider.get()))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_TOPIC_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } c.setMergeable(null); if (!(c.isMergeable())) { return com.google.gerrit.server.change.Submit.CLICK_FAILURE_OTHER_TOOLTIP; } checkSubmitRule(c, c.currentPatchSet(), false); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException("Could not determine problems for the change", e); } return null; }
private com.google.gerrit.httpd.raw.StaticServlet.Resource loadResource(java.lang.String name) throws java.io.IOException { java.io.File p = new java.io.File(staticBase, name); try { p = p.getCanonicalFile(); } catch (java.io.IOException e) { return com.google.gerrit.httpd.raw.StaticServlet.Resource.NOT_FOUND; } if (!(p.getPath().startsWith(staticBasePath))) { return com.google.gerrit.httpd.raw.StaticServlet.Resource.NOT_FOUND; } long ts = p.lastModified(); java.io.FileInputStream in; try { in = new java.io.FileInputStream(p); } catch (java.io.FileNotFoundException e) { return com.google.gerrit.httpd.raw.StaticServlet.Resource.NOT_FOUND; } byte[] raw; try { raw = com.google.common.io.ByteStreams.toByteArray(in); } finally { in.close(); } return new com.google.gerrit.httpd.raw.StaticServlet.Resource(p, ts, com.google.gerrit.httpd.raw.StaticServlet.contentType(name), raw); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChangeAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { final com.google.gerrit.reviewdb.client.Change.Id matchId = notes.getChangeId(); return com.google.common.collect.FluentIterable.from(db.patchComments().draftByAuthor(author)).filter(new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.PatchLineComment>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.PatchLineComment in) { com.google.gerrit.reviewdb.client.Change.Id changeId = in.getKey().getParentKey().getParentKey().getParentKey(); return changeId.equals(matchId); } }).toSortedList(com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(notes.getDraftComments(author).values()); return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { javax.servlet.http.HttpServletRequest httpRequest = ((javax.servlet.http.HttpServletRequest) (request)); javax.servlet.http.HttpSession httpSession = ((javax.servlet.http.HttpServletRequest) (request)).getSession(false); com.google.gerrit.httpd.auth.oauth.OAuthSession oauthSession = oauthSessionProvider.get(); boolean link = (request.getParameter("link")) != null; if (link) { oauthSession.setLinkMode(link); } if ((!(oauthSession.isLinkMode())) && (currentUserProvider.get().isIdentifiedUser())) { if (httpSession != null) { httpSession.invalidate(); } chain.doFilter(request, response); return; } else { if (oauthSession.isLoggedIn()) { oauthSession.logout(); } } javax.servlet.http.HttpServletResponse httpResponse = ((javax.servlet.http.HttpServletResponse) (response)); java.lang.String provider = httpRequest.getParameter("provider"); com.google.gerrit.extensions.auth.oauth.OAuthServiceProvider service = ((ssoProvider) == null) ? oauthSession.getServiceProvider() : ssoProvider; if (((com.google.gerrit.httpd.auth.oauth.OAuthWebFilter.isGerritLogin(httpRequest)) || (oauthSession.isOAuthFinal(httpRequest))) && (!(oauthSession.isLoggedIn()))) { if ((service == null) && (com.google.common.base.Strings.isNullOrEmpty(provider))) { selectProvider(httpRequest, httpResponse, null); return; } else { if (service == null) { service = findService(provider); } oauthSession.setServiceProvider(service); oauthSession.login(httpRequest, httpResponse, service); } } else { chain.doFilter(httpRequest, response); } }



java.util.List<com.google.gerrit.reviewdb.client.Account> get() { try { return cache.get(true); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.change.ReviewerSuggestionCache.log.warn("Cannot fetch reviewers from cache", e); return java.util.Collections.emptyList(); } }


@com.google.common.annotations.VisibleForTesting public void start() { if ((dbInjector) == null) { dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); } cfgInjector = createCfgInjector(); sysInjector = createSysInjector(); sysInjector.getInstance(com.google.gerrit.server.plugins.PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector); manager.add(dbInjector, cfgInjector, sysInjector); sshd &= !(sshdOff()); if (sshd) { initSshd(); } if (com.google.common.base.MoreObjects.firstNonNull(httpd, true)) { initHttpd(); } manager.start(); }
void set(com.google.gerrit.client.changes.ChangeInfo info) { this.changeId = info.legacy_id(); display(info); openForm.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> evaluate() { try { initPatchSet(); } catch (com.google.gwtorm.server.OrmException e) { return ruleError(("Error looking up patch set " + (control.getChange().currentPatchSetId()))); } com.google.gerrit.reviewdb.client.Change c = control.getChange(); if ((!(allowClosed)) && (c.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } if ((((c.getStatus()) == (Change.Status.DRAFT)) || (patchSet.isDraft())) && (!(allowDraft))) { return cannotSubmitDraft(); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getCurrentUser()); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError(java.lang.String.format(("Submit rule '%s' for change %s of %s has " + "no solution."), getSubmitRule(), cd.getId(), getProjectName())); } return resultsToSubmitRecord(getSubmitRule(), results); }

@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersSameGroupVisibility() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(changeId, user2.fullName, 2); assertThat(reviewers).hasSize(1); }
private java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> suggestReviewers(java.lang.String changeId, java.lang.String query, int n) throws java.lang.Exception { return gApi.changes().id(changeId).suggestReviewers(query).withLimit(n).get(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersViewAllAccounts() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; setApiUser(user1); reviewers = suggestReviewers(changeId, user2.fullName, 2); assertThat(reviewers).isEmpty(); setApiUser(user1); allowGlobalCapabilities(group1.getGroupUUID(), GlobalCapability.VIEW_ALL_ACCOUNTS); reviewers = suggestReviewers(changeId, user2.fullName, 2); assertThat(reviewers).hasSize(1); }
@org.junit.Before public void setUp() throws java.lang.Exception { group1 = group("users1"); group2 = group("users2"); group3 = group("users3"); }
public AMQP.BasicProperties getBasicProperties() { if ((amqpProperties) == null) { java.util.Map<java.lang.String, java.lang.Object> headers = new java.util.HashMap<>(); for (com.googlesource.gerrit.plugins.rabbitmq.config.section.Section section : properties.getSections()) { for (java.lang.reflect.Field f : section.getClass().getFields()) { if (f.isAnnotationPresent(com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader.class)) { com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader mh = f.getAnnotation(com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader.class); try { switch (f.getType().getSimpleName()) { case "String" : headers.put(mh.value(), f.get(section).toString()); break; case "Integer" : headers.put(mh.value(), f.getInt(section)); break; case "Long" : headers.put(mh.value(), f.getLong(section)); break; case "Boolean" : headers.put(mh.value(), f.getBoolean(section)); break; default : break; } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.LOGGER.info(ex.getMessage()); } } } } com.googlesource.gerrit.plugins.rabbitmq.config.section.Message message = properties.getSection(com.googlesource.gerrit.plugins.rabbitmq.config.section.Message.class); amqpProperties = new com.rabbitmq.client.AMQP.BasicProperties.Builder().appId(com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.EVENT_APPID).contentEncoding(CharEncoding.UTF_8).contentType(com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.CONTENT_TYPE_JSON).deliveryMode(message.deliveryMode).priority(message.priority).headers(headers).build(); } return amqpProperties; }
void set(com.google.gerrit.client.ui.CommentLinkProcessor commentLinkProcessor, com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision) { com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo = change.revision(revision); com.google.gerrit.client.changes.ChangeInfo.CommitInfo commit = revInfo.commit(); commitName.setText(revision); idText.setText(("Change-Id: " + (change.change_id()))); idText.setPreviewText(change.change_id()); com.google.gerrit.client.change.CommitBox.formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change); com.google.gerrit.client.change.CommitBox.formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change); text.setHTML(commentLinkProcessor.apply(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commit.message()).linkify())); setWebLinks(change, revision, revInfo); if ((revInfo.commit().parents().length()) > 1) { mergeCommit.setVisible(true); } setParents(change.project(), revInfo.commit().parents()); boolean parentNotCurrent = false; if (revInfo.has_actions()) { com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.actions.ActionInfo> actions = revInfo.actions(); if (actions.containsKey("rebase")) { parentNotCurrent = actions.get("rebase").enabled(); } } com.google.gwt.user.client.ui.UIObject.setVisible(parentNotCurrentText, parentNotCurrent); parentNotCurrentText.setInnerText((parentNotCurrent ? "\u25cf" : "")); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.extensions.common.CommentInfo> getComments(int changeId, java.lang.String rev) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { try { com.google.gerrit.server.change.ChangeResource changeRsrc = changes.parse(new com.google.gerrit.reviewdb.client.Change.Id(changeId)); com.google.gerrit.server.change.RevisionResource revRsrc = revisions.parse(changeRsrc, com.google.gerrit.extensions.restapi.IdString.fromDecoded(rev)); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> result = listComments.apply(revRsrc); for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.common.CommentInfo>> e : result.entrySet()) { for (com.google.gerrit.extensions.common.CommentInfo i : e.getValue()) { i.path = e.getKey(); } } return com.google.common.collect.Iterables.concat(result.values()); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { return null; } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } }
public AMQP.BasicProperties getBasicProperties() { if ((amqpProperties) == null) { java.util.Map<java.lang.String, java.lang.Object> headers = new java.util.HashMap<>(); for (com.googlesource.gerrit.plugins.rabbitmq.config.section.Section section : properties.getSections()) { for (java.lang.reflect.Field f : section.getClass().getFields()) { if (f.isAnnotationPresent(com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader.class)) { com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader mh = f.getAnnotation(com.googlesource.gerrit.plugins.rabbitmq.annotation.MessageHeader.class); try { switch (f.getType().getSimpleName()) { case "String" : headers.put(mh.value(), f.get(section).toString()); break; case "Integer" : headers.put(mh.value(), f.getInt(section)); break; case "Long" : headers.put(mh.value(), f.getLong(section)); break; case "Boolean" : headers.put(mh.value(), f.getBoolean(section)); break; default : break; } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.LOGGER.info(ex.getMessage()); } } } } com.googlesource.gerrit.plugins.rabbitmq.config.section.Message message = properties.getSection(com.googlesource.gerrit.plugins.rabbitmq.config.section.Message.class); amqpProperties = new com.rabbitmq.client.AMQP.BasicProperties.Builder().appId(com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.EVENT_APPID).contentEncoding(CharEncoding.UTF_8).contentType(com.googlesource.gerrit.plugins.rabbitmq.config.AMQProperties.CONTENT_TYPE_JSON).deliveryMode(message.deliveryMode).priority(message.priority).headers(headers).timestamp(new java.util.Date(com.google.gerrit.server.util.TimeUtil.nowMs())).build(); } return amqpProperties; }
@java.lang.Override public void shutdownCompleted(com.rabbitmq.client.ShutdownSignalException cause) { if (cause != null) { java.lang.Object obj = cause.getReference(); if (com.rabbitmq.client.Channel.class.isInstance(obj)) { com.rabbitmq.client.Channel.class.cast(obj).removeShutdownListener(this); } else if (com.rabbitmq.client.Connection.class.isInstance(obj)) { com.rabbitmq.client.Connection.class.cast(obj).removeShutdownListener(this); } if (clazz.isInstance(obj)) { if ((clazz) == (com.rabbitmq.client.Channel.class)) { com.rabbitmq.client.Channel ch = com.rabbitmq.client.Channel.class.cast(obj); if (cause.isInitiatedByApplication()) { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.info(MSG("Channel #{} closed by application."), ch.getChannelNumber()); } else { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.warn(MSG("Channel #{} closed. Cause: {}"), ch.getChannelNumber(), cause.getMessage()); } if (ch.equals(this.channel)) { this.channel = null; } } else if ((clazz) == (com.rabbitmq.client.Connection.class)) { com.rabbitmq.client.Connection conn = com.rabbitmq.client.Connection.class.cast(obj); if (cause.isInitiatedByApplication()) { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.info(MSG("Connection closed.")); } else { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.info(MSG("Connection suddenly closed.")); } if (conn.equals(this.connection)) { this.connection = null; } } } } }
public com.google.gerrit.server.data.RefUpdateAttribute asRefUpdateAttribute(final org.eclipse.jgit.lib.ObjectId oldId, final org.eclipse.jgit.lib.ObjectId newId, final com.google.gerrit.reviewdb.client.Branch.NameKey refName) { com.google.gerrit.server.data.RefUpdateAttribute ru = new com.google.gerrit.server.data.RefUpdateAttribute(); ru.newRev = (newId != null) ? newId.getName() : org.eclipse.jgit.lib.ObjectId.zeroId().getName(); ru.oldRev = (oldId != null) ? oldId.getName() : org.eclipse.jgit.lib.ObjectId.zeroId().getName(); ru.project = refName.getParentKey().get(); ru.refName = refName.getShortName(); return ru; }





@java.lang.Override public void onSubmit(final com.google.gwt.user.client.ui.FormPanel.SubmitEvent event) { event.cancel(); final java.lang.String addr = inEmail.getText().trim(); if (!(addr.contains("@"))) { new com.google.gerrit.client.ErrorDialog(Util.C.invalidUserEmail()).center(); return; } inEmail.setEnabled(false); register.setEnabled(false); com.google.gerrit.client.account.AccountApi.registerEmail("self", addr, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.account.EmailInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.account.EmailInfo result) { box.hide(); if ((com.google.gerrit.client.Gerrit.getConfig().getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT)) { currentEmail = addr; if ((emailPick.getItemCount()) == 0) { final com.google.gerrit.reviewdb.client.Account me = com.google.gerrit.client.Gerrit.getUserAccount(); me.setPreferredEmail(addr); onSaveSuccess(me); } else { save.setEnabled(true); } updateEmailList(); } } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { inEmail.setEnabled(true); register.setEnabled(true); if (caught.getMessage().startsWith(EmailException.MESSAGE)) { final com.google.gerrit.client.ErrorDialog d = new com.google.gerrit.client.ErrorDialog(caught.getMessage().substring(EmailException.MESSAGE.length())); d.setText(Util.C.errorDialogTitleRegisterNewEmail()); d.center(); } else { super.onFailure(caught); } } }); }
private void setBool(com.google.gwt.user.client.ui.ListBox box, com.google.gerrit.client.projects.ConfigInfo.InheritedBooleanInfo inheritedBoolean) { int inheritedIndex = -1; for (int i = 0; i < (box.getItemCount()); i++) { if (box.getValue(i).startsWith(InheritableBoolean.INHERIT.name())) { inheritedIndex = i; } if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) { box.setSelectedIndex(i); } } if (inheritedIndex >= 0) { if (getProjectKey().equals(com.google.gerrit.client.Gerrit.getConfig().getWildProject())) { if ((box.getSelectedIndex()) == inheritedIndex) { for (int i = 0; i < (box.getItemCount()); i++) { if (box.getValue(i).equals(InheritableBoolean.FALSE.name())) { box.setSelectedIndex(i); break; } } } box.removeItem(inheritedIndex); } else { box.setItemText(inheritedIndex, ((((InheritableBoolean.INHERIT.name()) + " (") + (inheritedBoolean.inherited_value())) + ")")); } } }
@java.lang.Override public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gwt.dom.client.Document.get().getElementById("gerrit_hostpagedata").removeFromParent(); com.google.gerrit.client.Gerrit.myConfig = result.config; com.google.gerrit.client.Gerrit.myTheme = result.theme; com.google.gerrit.client.Gerrit.isNoteDbEnabled = result.isNoteDbEnabled; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.xGerritAuth = result.xGerritAuth; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } onModuleLoad2(result); }
@java.lang.Override com.google.gerrit.reviewdb.client.ContactInformation toContactInformation() { final com.google.gerrit.reviewdb.client.ContactInformation info; if (com.google.gerrit.client.Gerrit.getConfig().isUseContactInfo()) { info = new com.google.gerrit.reviewdb.client.ContactInformation(); info.setAddress(addressTxt.getText()); info.setCountry(countryTxt.getText()); info.setPhoneNumber(phoneTxt.getText()); info.setFaxNumber(faxTxt.getText()); } else { info = null; } return info; }
private void initAgreements() { grid.addHeader(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingAgreements())); contributorAgreements = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); if (com.google.gerrit.client.Gerrit.getConfig().isUseContributorAgreements()) { saveEnabler.listenTo(contributorAgreements); grid.add(Util.C.useContributorAgreements(), contributorAgreements); } signedOffBy = com.google.gerrit.client.admin.ProjectInfoScreen.newInheritedBooleanBox(); saveEnabler.listenTo(signedOffBy); grid.addHtml(Util.C.useSignedOffBy(), signedOffBy); }
private boolean canEditFullName() { return com.google.gerrit.client.Gerrit.getConfig().canEdit(Account.FieldName.FULL_NAME); }

public static boolean siteReliesOnHttp() { return (((com.google.gerrit.client.Gerrit.getConfig().getGitHttpUrl()) != null) && ((com.google.gerrit.client.Gerrit.getConfig().getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.CUSTOM_EXTENSION))) && (!(com.google.gerrit.client.Gerrit.getConfig().siteHasUsernames())); }
private void addPermission(final java.lang.String permissionName, final java.util.List<java.lang.String> permissionList) { if ((value.getPermission(permissionName)) != null) { return; } if ((com.google.gerrit.client.Gerrit.getConfig().getWildProject().equals(projectAccess.getProjectName())) && (!(com.google.gerrit.common.data.Permission.canBeOnAllProjects(value.getName(), permissionName)))) { return; } permissionList.add(permissionName); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); identites = new com.google.gerrit.client.account.MyIdentitiesScreen.IdTable(); add(identites); deleteIdentity = new com.google.gwt.user.client.ui.Button(Util.C.buttonDeleteIdentity()); deleteIdentity.setEnabled(false); deleteIdentity.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { identites.deleteChecked(); } }); add(deleteIdentity); if ((com.google.gerrit.client.Gerrit.getConfig().getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.OPENID)) { com.google.gwt.user.client.ui.Button linkIdentity = new com.google.gwt.user.client.ui.Button(Util.C.buttonLinkIdentity()); linkIdentity.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { com.google.gwt.user.client.Window.Location.assign(((com.google.gerrit.client.Gerrit.loginRedirect(com.google.gwt.user.client.History.getToken())) + "?link")); } }); add(linkIdentity); } }


private boolean canRegisterNewEmail() { return com.google.gerrit.client.Gerrit.getConfig().canEdit(Account.FieldName.REGISTER_NEW_EMAIL); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.account.EmailInfo result) { box.hide(); if ((com.google.gerrit.client.Gerrit.getConfig().getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT)) { currentEmail = addr; if ((emailPick.getItemCount()) == 0) { final com.google.gerrit.reviewdb.client.Account me = com.google.gerrit.client.Gerrit.getUserAccount(); me.setPreferredEmail(addr); onSaveSuccess(me); } else { save.setEnabled(true); } updateEmailList(); } }

private boolean canEditUserName() { return com.google.gerrit.client.Gerrit.getConfig().canEdit(Account.FieldName.USER_NAME); }

public static java.util.List<com.google.gerrit.client.download.DownloadUrlLink> createDownloadUrlLinks(java.lang.String project, boolean allowAnonymous) { java.util.List<com.google.gerrit.client.download.DownloadUrlLink> urls = new java.util.ArrayList<>(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme> allowedSchemes = com.google.gerrit.client.Gerrit.getConfig().getDownloadSchemes(); if ((allowAnonymous && ((com.google.gerrit.client.Gerrit.getConfig().getGitDaemonUrl()) != null)) && ((allowedSchemes.contains(DownloadScheme.ANON_GIT)) || (allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS)))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.AnonGitLink(project)); } if (allowAnonymous && ((allowedSchemes.contains(DownloadScheme.ANON_HTTP)) || (allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS)))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.AnonHttpLink(project)); } if ((((com.google.gerrit.client.Gerrit.getConfig().getSshdAddress()) != null) && (com.google.gerrit.client.download.DownloadUrlLink.hasUserName())) && ((allowedSchemes.contains(DownloadScheme.SSH)) || (allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS)))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.SshLink(project)); } if (((com.google.gerrit.client.download.DownloadUrlLink.hasUserName()) || (com.google.gerrit.client.download.DownloadUrlLink.siteReliesOnHttp())) && ((allowedSchemes.contains(DownloadScheme.HTTP)) || (allowedSchemes.contains(DownloadScheme.DEFAULT_DOWNLOADS)))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.HttpLink(project, allowAnonymous)); } return urls; }
public static void query(com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeList>> callback, java.util.EnumSet<com.google.gerrit.extensions.client.ListChangesOption> options, java.lang.String... queries) { assert (queries.length) >= 2; com.google.gerrit.client.rpc.RestApi call = new com.google.gerrit.client.rpc.RestApi(com.google.gerrit.client.changes.ChangeList.URI); for (java.lang.String q : queries) { call.addParameterRaw("q", com.google.gwtorm.client.KeyUtil.encode(q)); } com.google.gerrit.client.changes.ChangeList.OPTIONS.addAll(options); com.google.gerrit.client.changes.ChangeList.addOptions(call, com.google.gerrit.client.changes.ChangeList.OPTIONS); call.get(callback); }

public static final <T extends com.googlesource.gerrit.plugins.rabbitmq.config.section.Section> T initialize(T section) { java.lang.reflect.Field[] fs = section.getClass().getFields(); for (java.lang.reflect.Field f : fs) { try { if (f.isAnnotationPresent(com.googlesource.gerrit.plugins.rabbitmq.annotation.Default.class)) { com.googlesource.gerrit.plugins.rabbitmq.annotation.Default a = f.getAnnotation(com.googlesource.gerrit.plugins.rabbitmq.annotation.Default.class); java.lang.Class<?> type = f.getType(); if (type == (java.lang.String.class)) { f.set(section, new java.lang.String(a.value())); } else if (type == (java.lang.Integer.class)) { f.set(section, new java.lang.Integer(a.value())); } else if (type == (java.lang.Long.class)) { f.set(section, new java.lang.Long(a.value())); } else if (type == (java.lang.Boolean.class)) { f.set(section, new java.lang.Boolean(a.value())); } } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.LOGGER.warn("Exception during initialize: {}", f.getName()); } } return section; }
public static final <T extends com.googlesource.gerrit.plugins.rabbitmq.config.section.Section> T initialize(T section) { java.lang.reflect.Field[] fs = section.getClass().getFields(); for (java.lang.reflect.Field f : fs) { try { if (f.isAnnotationPresent(com.googlesource.gerrit.plugins.rabbitmq.annotation.Default.class)) { com.googlesource.gerrit.plugins.rabbitmq.annotation.Default a = f.getAnnotation(com.googlesource.gerrit.plugins.rabbitmq.annotation.Default.class); java.lang.Class<?> type = f.getType(); if (type == (java.lang.String.class)) { f.set(section, a.value()); } else if (type == (java.lang.Integer.class)) { f.set(section, a.value()); } else if (type == (java.lang.Long.class)) { f.set(section, a.value()); } else if (type == (java.lang.Boolean.class)) { f.set(section, a.value()); } } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.LOGGER.warn("Exception during initialize: {}", f.getName()); } } return section; }
public static final <T extends com.googlesource.gerrit.plugins.rabbitmq.config.section.Section> com.googlesource.gerrit.plugins.rabbitmq.config.section.Section fromConfig(T section, org.eclipse.jgit.lib.Config... configs) { for (org.eclipse.jgit.lib.Config config : configs) { if (config != null) { java.util.Set<java.lang.String> names = config.getNames(com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.getName(section)); java.lang.reflect.Field[] fs = section.getClass().getFields(); for (java.lang.reflect.Field f : fs) { try { if (names.contains(f.getName())) { java.lang.Class<?> type = f.getType(); if (type == (java.lang.String.class)) { f.set(section, config.getString(com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.getName(section), null, f.getName())); } else if (type == (java.lang.Integer.class)) { f.set(section, config.getInt(com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.getName(section), null, f.getName(), 0)); } else if (type == (java.lang.Long.class)) { f.set(section, config.getLong(com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.getName(section), null, f.getName(), 0)); } else if (type == (java.lang.Boolean.class)) { f.set(section, config.getBoolean(com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.getName(section), null, f.getName(), false)); } } } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.config.section.Sections.LOGGER.warn("Exception during fromConfig: {}", f.getName()); } } } } return section; }
private com.rabbitmq.client.Channel getChannel() { com.rabbitmq.client.Channel ch = null; if ((connection) == null) { connect(); } else { try { ch = connection.createChannel(); ch.addShutdownListener(channelListener); failureCount = 0; com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.info(MSG("Channel #{} opened."), ch.getChannelNumber()); } catch (java.lang.Exception ex) { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.warn(MSG("Failed to open channel.")); (failureCount)++; } if ((failureCount) > (properties.getSection(com.googlesource.gerrit.plugins.rabbitmq.config.section.Monitor.class).failureCount)) { com.googlesource.gerrit.plugins.rabbitmq.session.type.AMQPSession.LOGGER.warn("Connection has something wrong. So will be disconnected."); disconnect(); } } return ch; }

@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.googlesource.gerrit.plugins.github.oauth.UserScopedProvider<com.googlesource.gerrit.plugins.github.oauth.GitHubLogin>>() {}).to(com.googlesource.gerrit.plugins.github.oauth.IdentifiedUserGitHubLoginProvider.class); install(com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.module()); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.github.GitHubTopMenu.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.account.GroupBackend.class).to(com.googlesource.gerrit.plugins.github.group.GitHubGroupBackend.class); install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(GitHubOrganisationGroup.Factory.class)); install(new com.google.inject.assistedinject.FactoryModuleBuilder().build(GitHubGroupMembership.Factory.class)); }



@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.changes.ChangeApi.includedIn(changeId.get(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo.IncludedInInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo.IncludedInInfo r) { branches.setInnerSafeHtml(formatList(r.branches())); tags.setInnerSafeHtml(formatList(r.tags())); loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo.IncludedInInfo r) { branches.setInnerSafeHtml(formatList(r.branches())); tags.setInnerSafeHtml(formatList(r.tags())); loaded = true; }

void replay() throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.validators.ValidationException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> changes = api.queryChanges(srcProject.get()); pm.beginTask("Replay Changes", changes.size()); org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { for (com.google.gerrit.extensions.common.ChangeInfo c : changes) { try { replayChange(rw, c); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.importer.ReplayChangesStep.log.error(java.lang.String.format("Failed to replay change %s.", com.google.gerrit.extensions.restapi.Url.decode(c.id)), e); throw e; } pm.update(1); } } finally { rw.release(); } pm.endTask(); }
static com.google.gerrit.server.query.change.ChangeData createForTest(com.google.gerrit.reviewdb.client.Change.Id id, int currentPatchSetId) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id); cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, currentPatchSetId)); return cd; }

public void publish(com.google.gerrit.server.edit.ChangeEdit edit) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change change = edit.getChange(); try (org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter()) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = edit.getBasePatchSet(); if (!(basePatchSet.getId().equals(change.currentPatchSetId()))) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("only edit for current patch set can be published"); } insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet)); com.google.gerrit.server.edit.ChangeEditUtil.deleteRef(repo, edit); } }


private java.util.List<com.google.gerrit.extensions.webui.TopMenu.MenuItem> my(com.google.gerrit.server.account.VersionedAccountPreferences v, org.eclipse.jgit.lib.Repository allUsers) { java.util.List<com.google.gerrit.extensions.webui.TopMenu.MenuItem> my = my(v); if ((my.isEmpty()) && (!(v.isDefaults()))) { try { com.google.gerrit.server.account.VersionedAccountPreferences d = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); d.load(allUsers); my = my(d); } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { com.google.gerrit.server.account.GetPreferences.log.warn("cannot read default preferences", e); } } if (my.isEmpty()) { my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Changes", "#/dashboard/self", null)); my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Drafts", "#/q/owner:self+is:draft", null)); my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Draft Comments", "#/q/has:draft", null)); my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Watched Changes", "#/q/is:watched+is:open", null)); my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Starred Changes", "#/q/is:starred", null)); my.add(new com.google.gerrit.extensions.webui.TopMenu.MenuItem("Groups", "#/groups/self", null)); } return my; }
@org.junit.Test public void updateMessage() throws java.lang.Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); try { modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage()); fail("UnchangedCommitMessageException expected"); } catch (com.google.gerrit.server.edit.UnchangedCommitMessageException ex) { assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message"); } java.lang.String msg = java.lang.String.format("New commit message\n\nChange-Id: %s", change.getKey()); assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg); editUtil.publish(edit.get()); assertThat(editUtil.byChange(change).isPresent()).isFalse(); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg); }
@org.junit.Test public void getFileNotFoundRest() throws java.lang.Exception { assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); try { fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(edit.get().getRevision().get()), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME); fail("ResourceNotFoundException expected"); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException rnfe) { } com.google.gerrit.acceptance.RestResponse r = adminSession.get(urlEditFile()); assertThat(r.getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); }


@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = object.change(); if (c == null) { return false; } com.google.gerrit.reviewdb.client.PatchSet.Id current = c.currentPatchSetId(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : object.approvals().get(current)) { if ((p.getValue()) != 0) { return true; } } return false; }


private java.util.List<com.google.gerrit.server.query.change.ChangeData> getChangesByTopic(java.lang.String topic) { try { return queryProvider.get().byTopicOpen(topic); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gwtorm.server.OrmRuntimeException(e); } }
@java.lang.SuppressWarnings("deprecation") static com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> create(com.google.gerrit.server.index.Schema<com.google.gerrit.server.query.change.ChangeData> schema) { if ((schema == null) || (schema.hasField(ChangeField.LEGACY_REVIEWED))) { return new com.google.gerrit.server.query.change.LegacyIsReviewedPredicate(); } com.google.gerrit.server.query.change.IsReviewedPredicate.checkSchema(schema); return com.google.gerrit.server.query.Predicate.not(new com.google.gerrit.server.query.change.IsReviewedPredicate(com.google.gerrit.server.query.change.IsReviewedPredicate.NOT_REVIEWED)); }



@org.junit.Test public void updateMessage() throws java.lang.Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); java.lang.String msg = java.lang.String.format("New commit message\n\nChange-Id: %s", change.getKey()); assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg); editUtil.publish(edit.get()); assertThat(editUtil.byChange(change).isPresent()).isFalse(); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg); }
@org.junit.Test public void publishEdit() throws java.lang.Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); assertThat(modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.acceptance.RestSession.newRawInput(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); editUtil.publish(editUtil.byChange(change).get()); assertThat(editUtil.byChange(change).isPresent()).isFalse(); }
@org.junit.Test public void updateMessageRest() throws java.lang.Exception { assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NOT_FOUND); com.google.gerrit.server.change.ChangeEdits.EditMessage.Input in = new com.google.gerrit.server.change.ChangeEdits.EditMessage.Input(); in.message = java.lang.String.format((("New commit message\n\n" + (com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2_STR)) + "\n\nChange-Id: %s"), change.getKey()); assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); com.google.gerrit.acceptance.RestResponse r = adminSession.getJsonAccept(urlEditMessage()); assertThat(r.getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_OK); assertThat(readContentFromJson(r)).isEqualTo(in.message); com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message); in.message = java.lang.String.format("New commit message2\n\nChange-Id: %s", change.getKey()); assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(com.google.gerrit.acceptance.edit.SC_NO_CONTENT); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message); }
protected java.io.File getHook(final java.lang.String name) throws java.io.IOException { java.io.File hook = hooks.get(name); if (hook != null) { return hook; } final java.lang.String scproot = "com/google/gerrit/server/tools/root"; final java.lang.String path = (scproot + "/hooks/") + name; java.net.URL url = cl().getResource(path); if (url == null) { fail((("Cannot locate " + path) + " in CLASSPATH")); } if ("file".equals(url.getProtocol())) { hook = new java.io.File(url.getPath()); if (!(hook.isFile())) { fail((("Cannot locate " + path) + " in CLASSPATH")); } long time = hook.lastModified(); hook.setExecutable(true); hook.setLastModified(time); hooks.put(name, hook); return hook; } else if ("jar".equals(url.getProtocol())) { java.io.InputStream in = url.openStream(); try { hook = java.io.File.createTempFile("hook_", ".sh"); cleanup.add(hook); java.io.FileOutputStream out = new java.io.FileOutputStream(hook); try { com.google.common.io.ByteStreams.copy(in, out); } finally { out.close(); } } finally { in.close(); } hook.setExecutable(true); hooks.put(name, hook); return hook; } else { fail(("Cannot invoke " + url)); return null; } }



@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.api.GerritApi.class).to(com.google.gerrit.server.api.GerritApiImpl.class); install(new com.google.gerrit.server.api.changes.Module()); install(new com.google.gerrit.server.api.projects.Module()); install(new com.google.gerrit.server.api.accounts.Module()); }
@org.junit.Test public void testBranchDelegation1() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.ProjectControl uDev = util.user(local, com.google.gerrit.server.project.Util.DEVS); assertFalse("not owner", uDev.isOwner()); assertTrue("owns ref", uDev.isOwnerAnyRef()); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/*", uDev); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y", uDev); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y/*", uDev); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/*", uDev); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/heads/master", uDev); }
@org.junit.Test public void testBranchDelegation2() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, fixers, "refs/heads/x/y/*"); com.google.gerrit.server.project.Util.doNotInherit(local, com.google.gerrit.server.project.OWNER, "refs/heads/x/y/*"); com.google.gerrit.server.project.ProjectControl uDev = util.user(local, com.google.gerrit.server.project.Util.DEVS); assertFalse("not owner", uDev.isOwner()); assertTrue("owns ref", uDev.isOwnerAnyRef()); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/*", uDev); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y", uDev); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y/*", uDev); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/*", uDev); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/heads/master", uDev); com.google.gerrit.server.project.ProjectControl uFix = util.user(local, fixers); assertFalse("not owner", uFix.isOwner()); assertTrue("owns ref", uFix.isOwnerAnyRef()); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y/*", uFix); com.google.gerrit.server.project.RefControlTest.assertOwner("refs/heads/x/y/bar", uFix); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/heads/x/*", uFix); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/heads/x/y", uFix); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/*", uFix); com.google.gerrit.server.project.RefControlTest.assertNotOwner("refs/heads/master", uFix); }
@org.junit.Test public void testBlockPushDrafts() { com.google.gerrit.server.project.Util.allow(parent, com.google.gerrit.server.project.PUSH, com.google.gerrit.server.project.REGISTERED_USERS, "refs/for/refs/*"); com.google.gerrit.server.project.Util.block(parent, com.google.gerrit.server.project.PUSH, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/drafts/*"); com.google.gerrit.server.project.ProjectControl u = util.user(local); assertTrue("can upload refs/heads/master", u.controlForRef("refs/heads/master").canUpload()); assertTrue("push is blocked to refs/drafts/master", u.controlForRef("refs/drafts/refs/heads/master").isBlocked(com.google.gerrit.server.project.PUSH)); }
@java.lang.Override public com.google.gerrit.server.change.ChangeKind load(com.google.gerrit.server.change.ChangeKindCacheImpl.Key key) throws java.io.IOException { if (java.util.Objects.equals(key.prior, key.next)) { return ChangeKind.NO_CODE_CHANGE; } try (org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(key.repo)) { org.eclipse.jgit.revwalk.RevCommit prior = walk.parseCommit(key.prior); walk.parseBody(prior); org.eclipse.jgit.revwalk.RevCommit next = walk.parseCommit(key.next); walk.parseBody(next); if (!(next.getFullMessage().equals(prior.getFullMessage()))) { if (com.google.gerrit.server.change.ChangeKindCacheImpl.Loader.isSameDeltaAndTree(prior, next)) { return ChangeKind.NO_CODE_CHANGE; } else { return ChangeKind.REWORK; } } if (com.google.gerrit.server.change.ChangeKindCacheImpl.Loader.isSameDeltaAndTree(prior, next)) { return ChangeKind.NO_CHANGE; } if (((prior.getParentCount()) != 1) || ((next.getParentCount()) != 1)) { return ChangeKind.REWORK; } org.eclipse.jgit.merge.ThreeWayMerger merger = com.google.gerrit.server.git.MergeUtil.newThreeWayMerger(key.repo, com.google.gerrit.server.git.MergeUtil.createDryRunInserter(key.repo), key.strategyName); merger.setBase(prior.getParent(0)); if ((merger.merge(next.getParent(0), prior)) && (merger.getResultTreeId().equals(next.getTree()))) { return ChangeKind.TRIVIAL_REBASE; } else { return ChangeKind.REWORK; } } finally { key.repo = null; } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException, javax.servlet.ServletException { if (!(userProvider.get().isIdentifiedUser())) { rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED); return; } rsp.setContentType("text/html"); java.util.Map<java.lang.String, java.lang.String> params = ((req.getQueryString()) != null) ? com.ericsson.gerrit.plugins.eventslog.EventsRestApiServlet.getParameters(req) : null; java.io.Writer out = rsp.getWriter(); java.lang.String query = null; try { query = queryMaker.formQueryFromRequestParameters(params); for (java.lang.String event : store.queryChangeEvents(query)) { out.write((event + "\n")); } } catch (com.ericsson.gerrit.plugins.eventslog.MalformedQueryException e) { rsp.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } catch (com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException e) { rsp.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE); return; } }
@org.junit.Test(expected = com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException.class) public void throwSQLExceptionIfNotOnline() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException, com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException, java.sql.SQLException { com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); setUpClientMock(); eventsDb.createDBIfNotCreated(); expectLastCall().andThrow(new java.sql.SQLException(new java.net.ConnectException())).once(); eventsDb.queryOne(); expectLastCall().andThrow(new java.sql.SQLException()); easyMock.replayAll(); store = new com.ericsson.gerrit.plugins.eventslog.SQLStore(pcFactoryMock, userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock); store.start(); store.storeEvent(mockEvent); store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); easyMock.verifyAll(); }
@org.junit.Test(expected = com.ericsson.gerrit.plugins.eventslog.MalformedQueryException.class) public void throwBadRequestTriggerOnBadQuery() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException, com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException { setUpClient(); java.lang.String badQuery = "bad query"; easyMock.resetAll(); easyMock.replayAll(); store.queryChangeEvents(badQuery); easyMock.verifyAll(); }
@org.junit.Test public void bothDateTime() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); params.put("t1", "2013-10-10 10:00:00"); params.put("t2", "2014-10-10 10:00:00"); java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertFalse(query.equals(com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.defaultQuery)); }
@org.junit.Test public void dateOneOnly() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); java.lang.String oldDate = "1990-10-10 10:00:00"; params.put("t1", oldDate); java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertTrue(query.contains(java.lang.String.format("'%s' and ", oldDate))); }
@org.junit.Test public void dateOrdering() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.lang.String query; java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); java.lang.String olderDate = "2013-10-10 10:00:00"; java.lang.String newerDate = "2014-10-10 10:00:00"; params.put("t1", olderDate); params.put("t2", newerDate); query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertTrue(query.contains(java.lang.String.format("'%s' and '%s'", olderDate, newerDate))); params.put("t1", newerDate); params.put("t2", olderDate); query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertTrue(query.contains(java.lang.String.format("'%s' and '%s'", olderDate, newerDate))); }
@org.junit.Test public void onlyDateNoTime() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); params.put("t1", "2013-10-10"); params.put("t2", "2014-10-10"); java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertFalse(query.equals(com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.defaultQuery)); }
@org.junit.Test(expected = com.ericsson.gerrit.plugins.eventslog.MalformedQueryException.class) public void noDate() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); }
@org.junit.Test public void dateTwoOnly() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); java.lang.String oldDate = "1990-10-10 10:00:00"; params.put("t2", oldDate); java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); assertTrue(query.contains(java.lang.String.format("'%s' and ", oldDate))); }
@org.junit.Test(expected = com.ericsson.gerrit.plugins.eventslog.MalformedQueryException.class) public void badParameters() throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); params.put("t1", "bad format"); params.put("t2", "bad format"); com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters(params); }
@org.junit.Test public void storeThenQueryNotVisible() throws java.lang.Exception { setUpClient(); java.lang.String genericQuery = "SELECT * FROM " + (com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME); com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); com.google.gerrit.server.project.ProjectControl pcMock = easyMock.createNiceMock(com.google.gerrit.server.project.ProjectControl.class); com.google.gerrit.server.CurrentUser userMock = easyMock.createNiceMock(com.google.gerrit.server.CurrentUser.class); easyMock.resetAll(); expect(userProviderMock.get()).andStubReturn(userMock); expect(pcFactoryMock.controlFor(mockEvent.getProjectNameKey(), userMock)).andStubReturn(pcMock); expect(pcMock.isVisible()).andStubReturn(false); easyMock.replayAll(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(genericQuery); assertEquals(0, events.size()); tearDown(); }
@org.junit.Test public void notReturnEventOfNonExistingProject() throws java.lang.Exception { setUpClient(); java.lang.String genericQuery = "SELECT * FROM " + (com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME); com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); com.google.gerrit.reviewdb.client.Project.NameKey projectMock = easyMock.createMock(Project.NameKey.class); easyMock.resetAll(); expect(projectMock.get()).andStubReturn(" "); expect(pcFactoryMock.controlFor(org.easymock.EasyMock.anyObject(Project.NameKey.class), org.easymock.EasyMock.anyObject(com.google.gerrit.server.CurrentUser.class))).andThrow(new com.google.gerrit.server.project.NoSuchProjectException(projectMock)); easyMock.replayAll(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(genericQuery); assertEquals(0, events.size()); tearDown(); }
@org.junit.Test public void storeThenQueryVisible() throws java.lang.Exception { setUpClient(); java.lang.String genericQuery = "SELECT * FROM " + (com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME); com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); com.google.gerrit.server.project.ProjectControl pcMock = easyMock.createNiceMock(com.google.gerrit.server.project.ProjectControl.class); com.google.gerrit.server.CurrentUser userMock = easyMock.createNiceMock(com.google.gerrit.server.CurrentUser.class); easyMock.resetAll(); expect(userProviderMock.get()).andStubReturn(userMock); expect(pcFactoryMock.controlFor(mockEvent.getProjectNameKey(), userMock)).andStubReturn(pcMock); expect(pcMock.isVisible()).andStubReturn(true); easyMock.replayAll(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(genericQuery); com.google.gson.Gson gson = new com.google.gson.Gson(); java.lang.String json = gson.toJson(mockEvent); assertEquals(1, events.size()); assertEquals(json, events.get(0)); tearDown(); }
@org.junit.Test public void checkConnectionAndRestore() throws java.sql.SQLException { com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); eventsDb = easyMock.createNiceMock(com.ericsson.gerrit.plugins.eventslog.SQLClient.class); easyMock.resetAll(); localEventsDb = new com.ericsson.gerrit.plugins.eventslog.SQLClient(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_DRIVER, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_LOCAL_PATH, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_OPTIONS); localEventsDb.createDBIfNotCreated(); localEventsDb.storeEvent(mockEvent); expect(cfgMock.getMaxAge()).andReturn(5); eventsDb.createDBIfNotCreated(); expectLastCall().andThrow(new java.sql.SQLException(new java.net.ConnectException())).once(); eventsDb.queryOne(); expectLastCall().once(); eventsDb.storeEvent(org.easymock.EasyMock.anyString(), org.easymock.EasyMock.anyObject(java.sql.Timestamp.class), org.easymock.EasyMock.anyString()); expectLastCall().once(); easyMock.replayAll(); store = new com.ericsson.gerrit.plugins.eventslog.SQLStore(pcFactoryMock, userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock); store.start(); java.util.List<com.ericsson.gerrit.plugins.eventslog.SQLClient.SQLEntry> entries = localEventsDb.getAll(); assertEquals(0, entries.size()); easyMock.verifyAll(); }


@org.junit.Test public void notReturnEventWithNoVisibilityInfo() throws java.lang.Exception { setUpClient(); java.lang.String genericQuery = "SELECT * FROM " + (com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME); com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); com.google.gerrit.reviewdb.client.Project.NameKey projectMock = easyMock.createMock(Project.NameKey.class); easyMock.resetAll(); expect(projectMock.get()).andStubReturn(" "); expect(pcFactoryMock.controlFor(org.easymock.EasyMock.anyObject(Project.NameKey.class), org.easymock.EasyMock.anyObject(com.google.gerrit.server.CurrentUser.class))).andThrow(new java.io.IOException()); easyMock.replayAll(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(genericQuery); assertEquals(0, events.size()); tearDown(); }

protected java.util.List<java.lang.String> getFiles(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { java.util.List<java.lang.String> files = new java.util.ArrayList<>(); if ((c.getParentCount()) > 0) { org.eclipse.jgit.api.Git git = new org.eclipse.jgit.api.Git(repo); java.util.List<org.eclipse.jgit.diff.DiffEntry> diffEntries = git.diff().setOldTree(getTreeIterator(repo, ((c.getName()) + "^"))).setNewTree(getTreeIterator(repo, c.getName())).call(); for (org.eclipse.jgit.diff.DiffEntry e : diffEntries) { if ((e.getNewPath()) != null) { files.add(e.getNewPath()); } } } else { org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(repo); tw.addTree(c.getTree()); tw.setRecursive(true); while (tw.next()) { files.add(tw.getPathString()); } } return files; }
private org.eclipse.jgit.treewalk.AbstractTreeIterator getTreeIterator(org.eclipse.jgit.lib.Repository repo, java.lang.String name) throws java.io.IOException { org.eclipse.jgit.treewalk.CanonicalTreeParser p = new org.eclipse.jgit.treewalk.CanonicalTreeParser(); org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader(); try { p.reset(or, new org.eclipse.jgit.revwalk.RevWalk(repo).parseTree(repo.resolve(name))); return p; } finally { or.release(); } }
private static com.google.gwt.user.client.ui.Widget getSizeWidget(com.google.gerrit.client.changes.ChangeInfo c) { int largeChangeSize = com.google.gerrit.client.Gerrit.getConfig().getLargeChangeSize(); int changedLines = (c.insertions()) + (c.deletions()); int p = 100; if (changedLines < largeChangeSize) { p = (changedLines * 100) / largeChangeSize; } int width = java.lang.Math.max(2, ((70 * p) / 100)); int red = (p >= 50) ? 255 : ((int) (java.lang.Math.round((p * 5.12)))); int green = (p <= 50) ? 255 : ((int) (java.lang.Math.round((256 - ((p - 50) * 5.12))))); java.lang.String bg = (("#" + (com.google.gerrit.client.changes.ChangeTable.toHex(red))) + (com.google.gerrit.client.changes.ChangeTable.toHex(green))) + "00"; com.google.gwt.user.client.ui.SimplePanel panel = new com.google.gwt.user.client.ui.SimplePanel(); panel.setStyleName(Gerrit.RESOURCES.css().changeSize()); panel.setWidth((width + "px")); panel.getElement().getStyle().setBackgroundColor(bg); return panel; }
private void setWebLinks(com.google.gerrit.client.changes.ChangeInfo change, java.lang.String revision, com.google.gerrit.client.changes.ChangeInfo.RevisionInfo revInfo) { com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && (gw.canLink(revInfo))) { toAnchor(gw.toRevision(change.project(), revision), gw.getLinkName()); } com.google.gwt.core.client.JsArray<com.google.gerrit.client.WebLinkInfo> links = revInfo.commit().web_links(); if (links != null) { for (com.google.gerrit.client.WebLinkInfo link : com.google.gerrit.client.rpc.Natives.asList(links)) { webLinkPanel.add(link.toAnchor()); } } }
private java.lang.String url() { if ((info.has_change_number()) && (info.has_revision_number())) { com.google.gerrit.reviewdb.client.PatchSet.Id id = info.patch_set_id(); return "#" + (com.google.gerrit.common.PageLinks.toChange(id.getParentKey(), id.getId())); } com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((gw != null) && ((project) != null)) { return gw.toRevision(project, info.commit().commit()); } return null; }
@java.lang.Override public void setValue(com.google.gerrit.common.data.ProjectAccess value) { if (((editing) && (value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES))) && ((value.getLocal(AccessSection.GLOBAL_CAPABILITIES)) == null)) { value.getLocal().add(0, new com.google.gerrit.common.data.AccessSection(com.google.gerrit.common.data.AccessSection.GLOBAL_CAPABILITIES)); } this.value = value; com.google.gerrit.reviewdb.client.Project.NameKey parent = value.getInheritsFrom(); if (parent != null) { inheritsFrom.getStyle().setDisplay(Display.BLOCK); parentProject.setText(parent.get()); parentProject.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS)); parentProjectBox.setVisible(editing); parentProjectBox.setProject(value.getProjectName()); parentProjectBox.setParentProject(value.getInheritsFrom()); parentProject.setVisible((!(parentProjectBox.isVisible()))); } else { inheritsFrom.getStyle().setDisplay(Display.NONE); } final com.google.gerrit.client.GitwebLink c = com.google.gerrit.client.Gerrit.getGitwebLink(); if ((value.isConfigVisible()) && (c != null)) { history.getStyle().setDisplay(Display.BLOCK); gitweb.setText(c.getLinkName()); gitweb.setHref(c.toFileHistory(new com.google.gerrit.reviewdb.client.Branch.NameKey(value.getProjectName(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), "project.config")); } else { history.getStyle().setDisplay(Display.NONE); } addSection.setVisible(((editing) && ((!(value.getOwnerOf().isEmpty())) || (value.canUpload())))); }
private void startPoller() { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && (0 < (com.google.gerrit.client.Gerrit.getConfig().getChangeUpdateDelay()))) { updateCheck = new com.google.gerrit.client.change.UpdateCheckTimer(this); updateCheck.schedule(); handlers.add(com.google.gerrit.client.ui.UserActivityMonitor.addValueChangeHandler(updateCheck)); } }

public static void createChange(java.lang.String project, java.lang.String branch, java.lang.String subject, java.lang.String base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.CreateChangeInput input = com.google.gerrit.client.changes.ChangeApi.CreateChangeInput.create(); input.project(com.google.gerrit.client.changes.ChangeApi.emptyToNull(project)); input.branch(com.google.gerrit.client.changes.ChangeApi.emptyToNull(branch)); input.subject(com.google.gerrit.client.changes.ChangeApi.emptyToNull(subject)); input.base_change(com.google.gerrit.client.changes.ChangeApi.emptyToNull(base)); if (com.google.gerrit.client.Gerrit.getConfig().isAllowDraftChanges()) { input.status(Change.Status.DRAFT.toString()); } new com.google.gerrit.client.rpc.RestApi("/changes/").post(input, cb); }



public static java.lang.String nameEmail(com.google.gerrit.client.account.AccountInfo info) { java.lang.String name = info.name(); if ((name == null) || (name.trim().isEmpty())) { name = com.google.gerrit.client.Gerrit.getConfig().getAnonymousCowardName(); } java.lang.StringBuilder b = new java.lang.StringBuilder().append(name); if ((info.email()) != null) { b.append(" <").append(info.email()).append(">"); } else if ((info._account_id()) > 0) { b.append(" (").append(info._account_id()).append(")"); } return b.toString(); }
private void renderOwner(com.google.gerrit.client.changes.ChangeInfo info) { java.lang.String name = ((info.owner().name()) != null) ? info.owner().name() : com.google.gerrit.client.Gerrit.getConfig().getAnonymousCowardName(); if ((info.owner().avatar(AvatarInfo.DEFAULT_SIZE)) != null) { ownerPanel.insert(new com.google.gerrit.client.AvatarImage(info.owner()), 0); } ownerLink.setText(name); ownerLink.setTitle(((info.owner().email()) != null ? info.owner().email() : name)); ownerLink.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toAccountQuery(((info.owner().name()) != null ? info.owner().name() : (info.owner().email()) != null ? info.owner().email() : java.lang.String.valueOf(info.owner()._account_id())), Change.Status.NEW)); }



private static void populateBottomMenu(com.google.gwt.user.client.ui.RootPanel btmmenu, com.google.gerrit.common.data.HostPageData hpd) { java.lang.String vs = hpd.version; if ((vs == null) || (vs.isEmpty())) { vs = "dev"; } btmmenu.add(new com.google.gwt.user.client.ui.InlineHTML(com.google.gerrit.client.Gerrit.M.poweredBy(vs))); java.lang.String reportBugUrl = com.google.gerrit.client.Gerrit.getConfig().getReportBugUrl(); if (reportBugUrl != null) { java.lang.String reportBugText = com.google.gerrit.client.Gerrit.getConfig().getReportBugText(); com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor((reportBugText == null ? com.google.gerrit.client.Gerrit.C.reportBug() : reportBugText), reportBugUrl); a.setTarget("_blank"); a.setStyleName(""); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(a); } btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(com.google.gerrit.client.Gerrit.C.keyHelp())); }
@java.lang.Override public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gwt.dom.client.Document.get().getElementById("gerrit_hostpagedata").removeFromParent(); com.google.gerrit.client.Gerrit.myConfig = result.config; com.google.gerrit.client.Gerrit.myTheme = result.theme; com.google.gerrit.client.Gerrit.isNoteDbEnabled = result.isNoteDbEnabled; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.xGerritAuth = result.xGerritAuth; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } RpcStatus.INSTANCE = new com.google.gerrit.client.RpcStatus(); com.google.gerrit.client.config.ConfigServerApi.serverInfo(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.config.ServerInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.config.ServerInfo info) { com.google.gerrit.client.Gerrit.myServerInfo = info; onModuleLoad2(result); } }); }
public static com.google.gerrit.common.data.GerritConfig getConfig() { return com.google.gerrit.client.Gerrit.myConfig; }
private void insertArchive() { java.util.List<java.lang.String> activated = com.google.gerrit.client.Gerrit.getConfig().getArchiveFormats(); if (activated.isEmpty()) { return; } java.util.List<com.google.gwt.user.client.ui.Anchor> anchors = new java.util.ArrayList<>(activated.size()); for (java.lang.String f : activated) { com.google.gwt.user.client.ui.Anchor archive = new com.google.gwt.user.client.ui.Anchor(f); archive.setHref(new com.google.gerrit.client.rpc.RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url()); anchors.add(archive); } com.google.gwt.user.client.ui.HorizontalPanel p = new com.google.gwt.user.client.ui.HorizontalPanel(); java.util.Iterator<com.google.gwt.user.client.ui.Anchor> it = anchors.iterator(); while (it.hasNext()) { com.google.gwt.user.client.ui.Anchor a = it.next(); p.add(a); if (it.hasNext()) { com.google.gwt.user.client.ui.InlineLabel spacer = new com.google.gwt.user.client.ui.InlineLabel("|"); spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer()); p.add(spacer); } } insertCommand("Archive", p); }


void setChangeInfo(com.google.gerrit.client.changes.ChangeInfo info) { com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if (gw != null) { for (com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev : com.google.gerrit.client.rpc.Natives.asList(info.revisions().values())) { if (patchSetId.getId().equals(rev.id())) { java.lang.String c = rev.name(); com.google.gwtexpui.safehtml.client.SafeHtml.setInnerHTML(filePath, com.google.gerrit.client.diff.Header.formatPath(path, info.project(), c)); com.google.gwtexpui.safehtml.client.SafeHtml.setInnerHTML(project, new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openAnchor().setAttribute("href", gw.toFile(info.project(), c, "")).setAttribute("title", gw.getLinkName()).append(info.project()).closeAnchor()); return; } } } project.setInnerText(info.project()); }
public static java.util.List<com.google.gerrit.client.download.DownloadUrlLink> createDownloadUrlLinks(java.lang.String project, boolean allowAnonymous) { java.util.List<com.google.gerrit.client.download.DownloadUrlLink> urls = new java.util.ArrayList<>(); java.util.Set<java.lang.String> allowedSchemes = com.google.gerrit.client.Gerrit.getInfo().download().schemes(); if ((allowAnonymous && ((com.google.gerrit.client.Gerrit.getConfig().getGitDaemonUrl()) != null)) && (allowedSchemes.contains("git"))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.AnonGitLink(project)); } if (allowAnonymous && (allowedSchemes.contains("anonymous http"))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.AnonHttpLink(project)); } if ((((com.google.gerrit.client.Gerrit.getConfig().getSshdAddress()) != null) && (com.google.gerrit.client.download.DownloadUrlLink.hasUserName())) && (allowedSchemes.contains("ssh"))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.SshLink(project)); } if (((com.google.gerrit.client.download.DownloadUrlLink.hasUserName()) || (com.google.gerrit.client.download.DownloadUrlLink.siteReliesOnHttp())) && (allowedSchemes.contains("http"))) { urls.add(new com.google.gerrit.client.download.DownloadUrlLink.HttpLink(project, allowAnonymous)); } return urls; }



public static com.google.gwtexpui.safehtml.client.SafeHtml formatPath(java.lang.String path, java.lang.String project, java.lang.String commit) { com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder(); if (Patch.COMMIT_MSG.equals(path)) { return b.append(Util.C.commitMessage()); } com.google.gerrit.client.GitwebLink gw = ((project != null) && (commit != null)) ? com.google.gerrit.client.Gerrit.getGitwebLink() : null; int s = (path.lastIndexOf('/')) + 1; if ((gw != null) && (s > 0)) { java.lang.String base = path.substring(0, (s - 1)); b.openAnchor().setAttribute("href", gw.toFile(project, commit, base)).setAttribute("title", gw.getLinkName()).append(base).closeAnchor().append('/'); } else { b.append(path.substring(0, s)); } b.openElement("b"); b.append(path.substring(s)); b.closeElement("b"); return b; }
private void addLinks(java.lang.String project, com.google.gerrit.client.changes.ChangeInfo.CommitInfo c, com.google.gwt.user.client.ui.FlowPanel panel) { com.google.gerrit.client.GitwebLink gw = com.google.gerrit.client.Gerrit.getGitwebLink(); if (gw != null) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(gw.getLinkName(), gw.toRevision(project, c.commit())); a.setStyleName(style.parentWebLink()); panel.add(a); } com.google.gwt.core.client.JsArray<com.google.gerrit.client.WebLinkInfo> links = c.web_links(); if (links != null) { for (com.google.gerrit.client.WebLinkInfo link : com.google.gerrit.client.rpc.Natives.asList(links)) { panel.add(link.toAnchor()); } } }

@java.lang.Override public com.google.gerrit.server.config.GetServerInfo.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.server.config.GetServerInfo.ServerInfo info = new com.google.gerrit.server.config.GetServerInfo.ServerInfo(); info.auth = new com.google.gerrit.server.config.GetServerInfo.AuthInfo(authConfig, realm); info.contactStore = getContactStoreInfo(); info.download = new com.google.gerrit.server.config.GetServerInfo.DownloadInfo(downloadSchemes, downloadCommands, archiveFormats); info.gerrit = new com.google.gerrit.server.config.GetServerInfo.GerritInfo(allProjectsName, allUsersName); info.gitWeb = getGitWebInfo(gitWebConfig); return info; }

static java.lang.String authorName(com.google.gerrit.client.changes.ChangeInfo.MessageInfo info) { if ((info.author()) != null) { if ((info.author().name()) != null) { return info.author().name(); } return com.google.gerrit.client.Gerrit.getConfig().getAnonymousCowardName(); } return Util.C.messageNoAuthor(); }

@java.lang.Override protected void onRequestSuggestions(com.google.gerrit.client.ui.Request req, com.google.gerrit.client.ui.Callback cb) { if ((req.getQuery().length()) >= (com.google.gerrit.client.Gerrit.getConfig().getSuggestFrom())) { _onRequestSuggestions(req, cb); } else { java.util.List<com.google.gerrit.client.ui.Suggestion> none = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.ui.Response(none)); } }
private static java.lang.String authorName(com.google.gerrit.client.changes.CommentInfo info) { if ((info.author()) != null) { if ((info.author().name()) != null) { return info.author().name(); } return com.google.gerrit.client.Gerrit.getConfig().getAnonymousCowardName(); } return Util.C.messageNoAuthor(); }

@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { com.google.gwt.user.client.Window.open(com.google.gerrit.client.Gerrit.getConfig().getEditFullNameUrl(), "_blank", null); }
private void addWebLinks(int row, com.google.gerrit.client.projects.ProjectInfo k) { com.google.gerrit.client.GitwebLink gitWebLink = com.google.gerrit.client.Gerrit.getGitwebLink(); java.util.List<com.google.gerrit.client.WebLinkInfo> webLinks = com.google.gerrit.client.rpc.Natives.asList(k.web_links()); if ((gitWebLink != null) || ((webLinks != null) && (!(webLinks.isEmpty())))) { com.google.gwt.user.client.ui.FlowPanel p = new com.google.gwt.user.client.ui.FlowPanel(); table.setWidget(row, ProjectsTable.C_REPO_BROWSER, p); if (gitWebLink != null) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(); a.setText(gitWebLink.getLinkName()); a.setHref(gitWebLink.toProject(k.name_key())); p.add(a); } if (webLinks != null) { for (com.google.gerrit.client.WebLinkInfo weblink : webLinks) { p.add(weblink.toAnchor()); } } } }
void display(final com.google.gerrit.reviewdb.client.Account account) { avatar.setAccount(com.google.gerrit.client.FormatUtil.asInfo(account), 93, false); new com.google.gerrit.client.rpc.RestApi("/accounts/").id("self").view("avatar.change.url").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeString changeUrl) { changeAvatar.setHref(changeUrl.asString()); changeAvatar.setVisible(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); int row = 0; if (com.google.gerrit.client.Gerrit.getConfig().siteHasUsernames()) { info.setWidget((row++), fieldIdx, new com.google.gerrit.client.account.UsernameField()); } info.setText((row++), fieldIdx, account.getFullName()); info.setText((row++), fieldIdx, account.getPreferredEmail()); info.setText((row++), fieldIdx, com.google.gerrit.client.FormatUtil.mediumFormat(account.getRegisteredOn())); info.setText(row, fieldIdx, account.getId().toString()); }
@java.lang.Override protected void onInitUI() { super.onInitUI(); com.google.gwt.user.client.ui.HorizontalPanel h = new com.google.gwt.user.client.ui.HorizontalPanel(); add(h); com.google.gwt.user.client.ui.VerticalPanel v = new com.google.gwt.user.client.ui.VerticalPanel(); v.addStyleName(Gerrit.RESOURCES.css().avatarInfoPanel()); h.add(v); avatar = new com.google.gerrit.client.AvatarImage(); v.add(avatar); changeAvatar = new com.google.gwt.user.client.ui.Anchor(Util.C.changeAvatar(), "", "_blank"); changeAvatar.setVisible(false); v.add(changeAvatar); if (com.google.gwt.i18n.client.LocaleInfo.getCurrentLocale().isRTL()) { labelIdx = 1; fieldIdx = 0; } else { labelIdx = 0; fieldIdx = 1; } info = new com.google.gwt.user.client.ui.Grid(((com.google.gerrit.client.Gerrit.getConfig().siteHasUsernames() ? 1 : 0) + 4), 2); info.setStyleName(Gerrit.RESOURCES.css().infoBlock()); info.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock()); h.add(info); int row = 0; if (com.google.gerrit.client.Gerrit.getConfig().siteHasUsernames()) { infoRow((row++), Util.C.userName()); } infoRow((row++), Util.C.fullName()); infoRow((row++), Util.C.preferredEmail()); infoRow((row++), Util.C.registeredOn()); infoRow((row++), Util.C.accountId()); final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = info.getCellFormatter(); fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost()); fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost()); fmt.addStyleName((row - 1), 0, Gerrit.RESOURCES.css().bottomheader()); }


private void initReplyButton(com.google.gerrit.client.changes.ChangeInfo info, java.lang.String revision) { if (!(info.revision(revision).is_edit())) { reply.setTitle(com.google.gerrit.client.Gerrit.getConfig().getReplyTitle()); reply.setHTML(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().openDiv().append(com.google.gerrit.client.Gerrit.getConfig().getReplyLabel()).closeDiv()); if (hasDraftComments) { reply.setStyleName(style.highlight()); } reply.setVisible(true); } }

final Account.FieldName get() { return Account.FieldName.valueOf(getRaw()); }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.config.CacheResource rsrc, com.google.gerrit.server.config.FlushCache.Input input) throws com.google.gerrit.extensions.restapi.AuthException { if ((com.google.gerrit.server.config.FlushCache.WEB_SESSIONS.equals(rsrc.getName())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("only site administrators can flush %s", com.google.gerrit.server.config.FlushCache.WEB_SESSIONS)); } rsrc.getCache().invalidateAll(); return com.google.gerrit.extensions.restapi.Response.ok(""); }

public java.nio.file.Path getGitwebCGI() { return gitweb_cgi; }
public static com.google.gerrit.client.GitwebLink getGitwebLink() { com.google.gerrit.common.data.GitwebConfig gw = com.google.gerrit.client.Gerrit.getConfig().getGitwebLink(); return (gw != null) && ((gw.type) != null) ? new com.google.gerrit.client.GitwebLink(gw) : null; }
@org.junit.Test public void testInalidPathSeparator() { for (char c : com.google.gerrit.httpd.GitWebConfigTest.SOME_INVALID_CHARACTERS.toCharArray()) { assertFalse(("invalid character accepted: " + c), com.google.gerrit.httpd.GitWebConfig.isValidPathSeparator(c)); } }
private void addWebLinks(int row, com.google.gerrit.client.projects.ProjectInfo k) { com.google.gerrit.client.GitwebLink gitWebLink = com.google.gerrit.client.Gerrit.getGitwebLink(); java.util.List<com.google.gerrit.client.WebLinkInfo> webLinks = com.google.gerrit.client.rpc.Natives.asList(k.webLinks()); if ((gitWebLink != null) || ((webLinks != null) && (!(webLinks.isEmpty())))) { com.google.gwt.user.client.ui.FlowPanel p = new com.google.gwt.user.client.ui.FlowPanel(); table.setWidget(row, ProjectsTable.C_REPO_BROWSER, p); if (gitWebLink != null) { com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(); a.setText(gitWebLink.getLinkName()); a.setHref(gitWebLink.toProject(k.name_key())); p.add(a); } if (webLinks != null) { for (com.google.gerrit.client.WebLinkInfo weblink : webLinks) { p.add(weblink.toAnchor()); } } } }

public com.google.gerrit.httpd.gitweb.GitWebCgiConfig disabled() { return new com.google.gerrit.httpd.gitweb.GitWebCgiConfig(); }
@org.junit.Test public void testValidPathSeparator() { for (char c : com.google.gerrit.httpd.GitWebConfigTest.VALID_CHARACTERS.toCharArray()) { assertTrue(("valid character rejected: " + c), com.google.gerrit.httpd.GitWebConfig.isValidPathSeparator(c)); } }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.util.RequestScopePropagator.class).to(com.google.gerrit.server.util.GuiceRequestScopePropagator.class); bind(com.google.gerrit.httpd.HttpRequestContext.class); if (wantSSL) { install(new com.google.gerrit.httpd.RequireSslFilter.Module()); } install(new com.google.gerrit.httpd.RunAsFilter.Module()); installAuthModule(); if (options.enableMasterFeatures()) { install(new com.google.gerrit.httpd.UrlModule(options, authConfig)); install(new com.google.gerrit.httpd.rpc.UiRpcModule()); } install(new com.google.gerrit.server.config.GerritRequestModule()); install(new com.google.gerrit.httpd.GitOverHttpServlet.Module(options.enableMasterFeatures())); if ((gitWebCgiConfig.getGitwebCgi()) != null) { install(new com.google.gerrit.httpd.gitweb.GitWebModule()); } bind(com.google.gerrit.httpd.GerritConfigProvider.class); bind(com.google.gerrit.common.data.GerritConfig.class).toProvider(com.google.gerrit.httpd.GerritConfigProvider.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class); install(new com.google.gerrit.server.git.AsyncReceiveCommits.Module()); bind(java.net.SocketAddress.class).annotatedWith(com.google.gerrit.server.RemotePeer.class).toProvider(com.google.gerrit.httpd.HttpRemotePeerProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.httpd.ProxyProperties.class).toProvider(com.google.gerrit.httpd.ProxyPropertiesProvider.class); listener().toInstance(registerInParentInjectors()); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.util.RequestScopePropagator.class).to(com.google.gerrit.server.util.GuiceRequestScopePropagator.class); bind(com.google.gerrit.httpd.HttpRequestContext.class); if (wantSSL) { install(new com.google.gerrit.httpd.RequireSslFilter.Module()); } install(new com.google.gerrit.httpd.RunAsFilter.Module()); installAuthModule(); if (options.enableMasterFeatures()) { install(new com.google.gerrit.httpd.UrlModule(options, authConfig)); install(new com.google.gerrit.httpd.rpc.UiRpcModule()); } install(new com.google.gerrit.server.config.GerritRequestModule()); install(new com.google.gerrit.httpd.GitOverHttpServlet.Module(options.enableMasterFeatures())); bind(com.google.gerrit.httpd.GitWebConfig.class).toInstance(gitWebConfig); if ((gitWebConfig.getGitwebCGI()) != null) { install(new com.google.gerrit.httpd.gitweb.GitWebModule()); } bind(com.google.gerrit.httpd.GerritConfigProvider.class); bind(com.google.gerrit.common.data.GerritConfig.class).toProvider(com.google.gerrit.httpd.GerritConfigProvider.class); com.google.gerrit.extensions.registration.DynamicSet.setOf(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class); install(new com.google.gerrit.server.git.AsyncReceiveCommits.Module()); bind(java.net.SocketAddress.class).annotatedWith(com.google.gerrit.server.RemotePeer.class).toProvider(com.google.gerrit.httpd.HttpRemotePeerProvider.class).in(com.google.inject.servlet.RequestScoped.class); bind(com.google.gerrit.httpd.ProxyProperties.class).toProvider(com.google.gerrit.httpd.ProxyPropertiesProvider.class); listener().toInstance(registerInParentInjectors()); }

public static void main(java.lang.String[] args) throws java.lang.Exception { new com.google.gitiles.dev.DevServer(com.google.gitiles.GitilesConfig.defaultFile()).start(); }


private org.eclipse.jetty.server.Handler appHandler() { com.google.gitiles.GitilesServlet servlet = new com.google.gitiles.GitilesServlet(cfg, new com.google.gitiles.DebugRenderer(com.google.gitiles.GitilesServlet.STATIC_PREFIX, java.util.Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), new java.io.File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/templates").getPath(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles")), null, null, null, null, null, null, null); org.eclipse.jetty.servlet.ServletContextHandler handler = new org.eclipse.jetty.servlet.ServletContextHandler(); handler.setContextPath(""); handler.addServlet(new org.eclipse.jetty.servlet.ServletHolder(servlet), "/*"); return handler; }
void start() throws java.lang.Exception { httpd.start(); httpd.join(); }





private void testCopyLocal() { expect(cfgMock.getCopyLocal()).andReturn(true).once(); expect(cfgMock.getLocalStoreUrl()).andReturn(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_LOCAL_PATH).once(); }
private void checkConnectionAndRestore(boolean copy) throws java.lang.Exception { com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); eventsDb = easyMock.createNiceMock(com.ericsson.gerrit.plugins.eventslog.SQLClient.class); easyMock.resetAll(); localEventsDb = new com.ericsson.gerrit.plugins.eventslog.SQLClient(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_DRIVER, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_LOCAL_PATH, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_OPTIONS); localEventsDb.createDBIfNotCreated(); localEventsDb.storeEvent(mockEvent); expect(cfgMock.getMaxAge()).andReturn(5); eventsDb.createDBIfNotCreated(); expectLastCall().andThrow(new java.sql.SQLException(new java.net.ConnectException())).once(); eventsDb.queryOne(); expectLastCall().once(); eventsDb.storeEvent(org.easymock.EasyMock.anyString(), org.easymock.EasyMock.anyObject(java.sql.Timestamp.class), org.easymock.EasyMock.anyString()); expectLastCall().once(); if (copy) { testCopyLocal(); } easyMock.replayAll(); store = new com.ericsson.gerrit.plugins.eventslog.SQLStore(pcFactoryMock, userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock); store.start(); java.util.List<com.ericsson.gerrit.plugins.eventslog.SQLEntry> entries = localEventsDb.getAll(); assertThat(entries).isEmpty(); easyMock.verifyAll(); }
@org.junit.Test public void noRetryOnMessage() throws java.lang.Exception { com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent mockEvent = new com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MockEvent(); setUpClientMock(); expect(cfgMock.getMaxTries()).andReturn(3).once(); eventsDb.storeEvent(mockEvent); expectLastCall().andThrow(new java.sql.SQLException(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.MSG)).once(); expect(localEventsDb.getAll()).andReturn(results); easyMock.replayAll(); store = new com.ericsson.gerrit.plugins.eventslog.SQLStore(pcFactoryMock, userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock); store.start(); store.storeEvent(mockEvent); easyMock.verifyAll(); }
@org.junit.Test public void testConnectionTask() throws java.lang.Exception { eventsDb = new com.ericsson.gerrit.plugins.eventslog.SQLClient(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_DRIVER, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_PATH, com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.TEST_OPTIONS); localEventsDb = easyMock.createMock(com.ericsson.gerrit.plugins.eventslog.SQLClient.class); expect(localEventsDb.getAll()).andReturn(new java.util.ArrayList<com.ericsson.gerrit.plugins.eventslog.SQLEntry>()); org.easymock.EasyMock.replay(localEventsDb); store = new com.ericsson.gerrit.plugins.eventslog.SQLStore(pcFactoryMock, userProviderMock, cfgMock, eventsDb, localEventsDb, poolMock); eventsDb.createDBIfNotCreated(); poolMock.scheduleWithFixedDelay(store.new com.ericsson.gerrit.plugins.eventslog.CheckConnectionTask(), 0, 0, java.util.concurrent.TimeUnit.MILLISECONDS); easyMock.verifyAll(); }
private void restoreEventsFromLocal() { if (copyLocal) { copyFile(); } java.util.List<com.ericsson.gerrit.plugins.eventslog.SQLEntry> entries; try { entries = localEventsDb.getAll(); if (entries.isEmpty()) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.debug("No events to restore from local"); return; } for (com.ericsson.gerrit.plugins.eventslog.SQLEntry entry : entries) { restoreEvent(entry); } } catch (java.sql.SQLException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn("Could not query all events from local", e); } try { localEventsDb.removeOldEvents(0); } catch (java.sql.SQLException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn("Could not destroy local database", e); } }
private void copyFile() { java.nio.file.Path localPath = java.nio.file.Paths.get(localUrl.substring(com.ericsson.gerrit.plugins.eventslog.SQLStore.H2_DB_PREFIX.length())); java.io.File file = localPath.resolve(((com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME) + (com.ericsson.gerrit.plugins.eventslog.SQLStore.H2_DB_SUFFIX))).toFile(); java.io.File copyFile = localPath.resolve((((com.ericsson.gerrit.plugins.eventslog.SQLTable.TABLE_NAME) + (java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(com.google.gerrit.common.TimeUtil.nowMs()))) + (com.ericsson.gerrit.plugins.eventslog.SQLStore.H2_DB_SUFFIX))).toFile(); try { com.google.common.io.Files.copy(file, copyFile); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn("Could not copy local database file with timestamp", e); } }
private static java.util.List<org.eclipse.jgit.revwalk.RevCommit> findMergeBases(org.eclipse.jgit.revwalk.RevWalk rw, java.lang.Iterable<org.eclipse.jgit.revwalk.RevCommit> commits) throws java.io.IOException { rw.setRevFilter(RevFilter.MERGE_BASE); com.google.gerrit.server.change.WalkSorter.markStart(rw, commits); java.util.List<org.eclipse.jgit.revwalk.RevCommit> result = new java.util.ArrayList<>(); org.eclipse.jgit.revwalk.RevCommit c; while ((c = rw.next()) != null) { result.add(c); } return result; }



private static java.sql.Timestamp parseTimestamp(byte[] note, org.eclipse.jgit.util.MutableInteger curr, com.google.gerrit.reviewdb.client.Change.Id changeId, java.nio.charset.Charset enc) throws org.eclipse.jgit.errors.ConfigInvalidException { int endOfLine = org.eclipse.jgit.util.RawParseUtils.nextLF(note, curr.value); java.sql.Timestamp commentTime; java.lang.String dateString = org.eclipse.jgit.util.RawParseUtils.decode(enc, note, curr.value, (endOfLine - 1)); try { commentTime = new java.sql.Timestamp(org.eclipse.jgit.util.GitDateParser.parse(dateString, null).getTime()); } catch (java.text.ParseException e) { throw new org.eclipse.jgit.errors.ConfigInvalidException("could not parse comment timestamp", e); } curr.value = endOfLine; return com.google.gerrit.server.notedb.CommentsInNotesUtil.checkResult(commentTime, "comment timestamp", changeId); }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.PublishChangeEdit.Publish.Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (!(edit.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("no edit exists for change %s", rsrc.getChange().getChangeId())); } editUtil.publish(edit.get()); return com.google.gerrit.extensions.restapi.Response.none(); }
private static java.lang.String getVersion(final java.io.File me) { if (me == null) { return ""; } try { final java.util.jar.JarFile jar = new java.util.jar.JarFile(me); try { java.util.jar.Manifest mf = jar.getManifest(); java.util.jar.Attributes att = mf.getMainAttributes(); java.lang.String val = att.getValue(java.util.jar.Attributes.Name.IMPLEMENTATION_VERSION); return val != null ? val : ""; } finally { jar.close(); } } catch (java.io.IOException e) { return ""; } }
private static void extractJar(java.util.zip.ZipFile zf, java.util.zip.ZipEntry ze, java.util.SortedMap<java.lang.String, java.net.URL> jars) throws java.io.IOException { java.io.File tmp = com.google.gerrit.launcher.GerritLauncher.createTempFile(com.google.gerrit.launcher.GerritLauncher.safeName(ze), ".jar"); java.io.FileOutputStream out = new java.io.FileOutputStream(tmp); try { java.io.InputStream in = zf.getInputStream(ze); try { byte[] buf = new byte[4096]; int n; while ((n = in.read(buf, 0, buf.length)) > 0) { out.write(buf, 0, n); } } finally { in.close(); } } finally { out.close(); } java.lang.String name = ze.getName(); jars.put(name.substring(name.lastIndexOf('/'), name.length()), tmp.toURI().toURL()); }
private void exec(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp, final com.google.gerrit.server.project.ProjectControl project) throws java.io.IOException { final java.lang.Process proc = java.lang.Runtime.getRuntime().exec(new java.lang.String[]{ gitwebCgi.toAbsolutePath().toString() }, makeEnv(req, project), gitwebCgi.toAbsolutePath().getParent().toFile()); copyStderrToLog(proc.getErrorStream()); if (0 < (req.getContentLength())) { copyContentToCGI(req, proc.getOutputStream()); } else { proc.getOutputStream().close(); } try { final java.io.InputStream in; in = new java.io.BufferedInputStream(proc.getInputStream(), bufferSize); try { readCgiHeaders(rsp, in); final java.io.OutputStream out = rsp.getOutputStream(); try { final byte[] buf = new byte[bufferSize]; int n; while ((n = in.read(buf)) > 0) { out.write(buf, 0, n); } } finally { out.close(); } } finally { in.close(); } } catch (java.io.IOException e) { proc.destroy(); return; } try { proc.waitFor(); final int status = proc.exitValue(); if (0 != status) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.error(((("Non-zero exit status (" + status) + ") from ") + (gitwebCgi))); if (!(rsp.isCommitted())) { rsp.sendError(500); } } } catch (java.lang.InterruptedException ie) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.debug("CGI: interrupted waiting for CGI to terminate"); } }
@java.lang.Override public void run() { try { final java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(in, "ISO-8859-1")); try { java.lang.String line; while ((line = br.readLine()) != null) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.error(("CGI: " + line)); } } finally { br.close(); } } catch (java.io.IOException e) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.debug("Unexpected error copying stderr from CGI", e); } }
private void copyStderrToLog(final java.io.InputStream in) { new java.lang.Thread(new java.lang.Runnable() { @java.lang.Override public void run() { try { final java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(in, "ISO-8859-1")); try { java.lang.String line; while ((line = br.readLine()) != null) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.error(("CGI: " + line)); } } finally { br.close(); } } catch (java.io.IOException e) { com.google.gerrit.httpd.gitweb.GitWebServlet.log.debug("Unexpected error copying stderr from CGI", e); } } }, "GitWeb-ErrorLogger").start(); }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = com.google.common.collect.Lists.newLinkedList(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, com.google.gerrit.common.TimeUtil.nowTs()); auditInserts.add(audit); } try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { db.accountGroupMembersAudit().insert(auditInserts); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e); } }
private static java.io.File locateMyArchive() throws java.io.FileNotFoundException { final java.lang.ClassLoader myCL = com.google.gerrit.launcher.GerritLauncher.class.getClassLoader(); final java.lang.String myName = (com.google.gerrit.launcher.GerritLauncher.class.getName().replace('.', '/')) + ".class"; final java.net.URL myClazz = myCL.getResource(myName); if (myClazz == null) { throw new java.io.FileNotFoundException(("Cannot find JAR: no " + myName)); } try { java.util.jar.JarFile jar = ((java.net.JarURLConnection) (myClazz.openConnection())).getJarFile(); java.io.File path = new java.io.File(jar.getName()); if (path.isFile()) { return path; } } catch (java.lang.Exception e) { } if ("file".equals(myClazz.getProtocol())) { final java.io.File path = new java.io.File(myClazz.getPath()); if ((path.isFile()) && (path.getParentFile().isDirectory())) { throw new java.io.FileNotFoundException(com.google.gerrit.launcher.GerritLauncher.NOT_ARCHIVED); } } final java.security.CodeSource src = com.google.gerrit.launcher.GerritLauncher.class.getProtectionDomain().getCodeSource(); if (src != null) { try { final java.io.InputStream in = src.getLocation().openStream(); try { final java.io.File tmp = com.google.gerrit.launcher.GerritLauncher.createTempFile("gerrit_", ".zip"); final java.io.FileOutputStream out = new java.io.FileOutputStream(tmp); try { final byte[] buf = new byte[4096]; int n; while ((n = in.read(buf, 0, buf.length)) > 0) { out.write(buf, 0, n); } } finally { out.close(); } return tmp; } finally { in.close(); } } catch (java.io.IOException e) { } } throw new java.io.FileNotFoundException("Cannot find local copy of JAR"); }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, com.google.gerrit.common.TimeUtil.nowTs()); includesAudit.add(audit); } try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { db.accountGroupByIdAud().insert(includesAudit); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e); } }
private java.lang.String name(final com.google.gwt.core.ext.TreeLogger logger, final com.google.gwt.core.ext.linker.PublicResource r) throws com.google.gwt.core.ext.UnableToCompleteException { final java.io.InputStream in = r.getContents(logger); final java.io.ByteArrayOutputStream tmp = new java.io.ByteArrayOutputStream(); try { try { final byte[] buf = new byte[2048]; int n; while ((n = in.read(buf)) >= 0) { tmp.write(buf, 0, n); } tmp.close(); } finally { in.close(); } } catch (java.io.IOException e) { final com.google.gwt.core.ext.UnableToCompleteException ute = new com.google.gwt.core.ext.UnableToCompleteException(); ute.initCause(e); throw ute; } java.lang.String base = r.getPartialPath(); final int s = base.lastIndexOf('/'); if (0 < s) { base = base.substring(0, (s + 1)); } else { base = ""; } return (base + (com.google.gwt.dev.util.Util.computeStrongName(tmp.toByteArray()))) + ".cache.css"; }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup> all() { try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { return java.util.Collections.unmodifiableList(db.accountGroups().all().toList()); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn("Cannot list internal groups", e); return java.util.Collections.emptyList(); } }
@java.lang.Override public void run() { com.google.gerrit.reviewdb.client.PatchSet patchSet; try { com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schemaFactory.open(); try { patchSet = reviewDb.patchSets().get(c.currentPatchSetId()); } finally { reviewDb.close(); } } catch (java.lang.Exception e) { logError(("Cannot send email for submitted patch set " + (c.getId())), e); return; } try { com.google.gerrit.server.mail.MergedSender cm = mergedSenderFactory.create(c.getId()); if (from != null) { cm.setFrom(from.getAccountId()); } cm.setPatchSet(patchSet); cm.send(); } catch (java.lang.Exception e) { logError(("Cannot send email for submitted patch set " + (c.getId())), e); } }
@java.lang.Override public void run() { com.google.gerrit.reviewdb.client.PatchSet patchSet; try { com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schemaFactory.open(); try { patchSet = reviewDb.patchSets().get(c.currentPatchSetId()); } finally { reviewDb.close(); } } catch (java.lang.Exception e) { logError("Cannot send email notifications about merge failure", e); return; } try { com.google.gerrit.server.mail.MergeFailSender cm = mergeFailSenderFactory.create(c.getId()); if (from != null) { cm.setFrom(from.getAccountId()); } cm.setPatchSet(patchSet); cm.setChangeMessage(msg); cm.send(); } catch (java.lang.Exception e) { logError("Cannot send email notifications about merge failure", e); } }
private void sendMergedEmail(final com.google.gerrit.reviewdb.client.Change c, final com.google.gerrit.reviewdb.client.PatchSetApproval from) { workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { com.google.gerrit.reviewdb.client.PatchSet patchSet; try { com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schemaFactory.open(); try { patchSet = reviewDb.patchSets().get(c.currentPatchSetId()); } finally { reviewDb.close(); } } catch (java.lang.Exception e) { logError(("Cannot send email for submitted patch set " + (c.getId())), e); return; } try { com.google.gerrit.server.mail.MergedSender cm = mergedSenderFactory.create(c.getId()); if (from != null) { cm.setFrom(from.getAccountId()); } cm.setPatchSet(patchSet); cm.send(); } catch (java.lang.Exception e) { logError(("Cannot send email for submitted patch set " + (c.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email merged"; } })); }
@java.lang.Override public com.google.gerrit.server.project.RepositoryStatistics apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey()); try { org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); return new com.google.gerrit.server.project.RepositoryStatistics(gc.getStatistics()); } catch (org.eclipse.jgit.api.errors.GitAPIException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (org.eclipse.jgit.api.errors.JGitInternalException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } finally { repo.close(); } } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getName()); } }
@java.lang.Override protected void doGet(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { if ((raw_css) != null) { rsp.setContentType("text/css"); rsp.setCharacterEncoding(com.google.gerrit.httpd.gitweb.GitWebCssServlet.ENC); final byte[] toSend; if (com.google.gwtjsonrpc.server.RPCServletUtils.acceptsGzipEncoding(req)) { rsp.setHeader("Content-Encoding", "gzip"); toSend = gz_css; } else { toSend = raw_css; } rsp.setContentLength(toSend.length); rsp.setDateHeader("Last-Modified", modified); com.google.gwtexpui.server.CacheHeaders.setCacheable(req, rsp, 5, java.util.concurrent.TimeUnit.MINUTES); final javax.servlet.ServletOutputStream os = rsp.getOutputStream(); try { os.write(toSend); } finally { os.close(); } } else { com.google.gwtexpui.server.CacheHeaders.setNotCacheable(rsp); rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } }
private boolean isRevisionOutOfDate() { try { org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(getProject().getNameKey()); try { org.eclipse.jgit.lib.Ref ref = git.getRef(RefNames.REFS_CONFIG); if ((ref == null) || ((ref.getObjectId()) == null)) { return true; } return !(ref.getObjectId().equals(config.getRevision())); } finally { git.close(); } } catch (java.io.IOException gone) { return true; } }
public com.google.gerrit.server.git.ProjectLevelConfig getConfig(java.lang.String fileName) { if (configs.containsKey(fileName)) { return configs.get(fileName); } com.google.gerrit.server.git.ProjectLevelConfig cfg = new com.google.gerrit.server.git.ProjectLevelConfig(fileName, this); try { org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(getProject().getNameKey()); try { cfg.load(git); } finally { git.close(); } } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectState.log.warn(((("Failed to load " + fileName) + " for ") + (getProject().getName())), e); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.project.ProjectState.log.warn(((("Failed to load " + fileName) + " for ") + (getProject().getName())), e); } configs.put(fileName, cfg); return cfg; }
@java.lang.Override public void start() { try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.client.CurrentSchemaVersion currentVer = getSchemaVersion(db); final int expectedVer = com.google.gerrit.server.schema.SchemaVersion.getBinaryVersion(); if (currentVer == null) { throw new com.google.inject.ProvisionException((("Schema not yet initialized." + (" Run init to initialize the schema:\n" + "$ java -jar gerrit.war init -d ")) + (site.site_path.toAbsolutePath()))); } if ((currentVer.versionNbr) < expectedVer) { throw new com.google.inject.ProvisionException((((((((("Unsupported schema version " + (currentVer.versionNbr)) + "; expected schema version ") + expectedVer) + ". Run init to upgrade:\n") + "$ java -jar ") + (site.gerrit_war.toAbsolutePath())) + " init -d ") + (site.site_path.toAbsolutePath()))); } else if ((currentVer.versionNbr) > expectedVer) { throw new com.google.inject.ProvisionException((((("Unsupported schema version " + (currentVer.versionNbr)) + "; expected schema version ") + expectedVer) + ". Downgrade is not supported.")); } } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.inject.ProvisionException("Cannot read schema_version", e); } }
private static java.lang.String readPegdownCss(java.util.concurrent.atomic.AtomicBoolean file) throws java.io.IOException { java.lang.String name = "pegdown.css"; java.net.URL url = com.google.gerrit.server.documentation.MarkdownFormatter.class.getResource(name); if (url == null) { throw new java.io.FileNotFoundException(("Resource " + name)); } file.set("file".equals(url.getProtocol())); java.io.InputStream in = url.openStream(); try { org.eclipse.jgit.util.TemporaryBuffer.Heap tmp = new org.eclipse.jgit.util.TemporaryBuffer.Heap((128 * 1024)); try { tmp.copy(in); return new java.lang.String(tmp.toByteArray(), "UTF-8"); } finally { tmp.close(); } } finally { in.close(); } }
private com.google.gerrit.server.account.AuthResult byPreferredEmail(final java.lang.String email) { try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { java.util.List<com.google.gerrit.reviewdb.client.Account> matches = db.accounts().byPreferredEmail(email).toList(); return (matches.size()) == 1 ? auth(matches.get(0)) : null; } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log("cannot query database", e); return null; } }
private static void unpack(java.io.File srcwar, java.io.File dstwar) throws java.io.IOException { final java.util.zip.ZipFile zf = new java.util.zip.ZipFile(srcwar); try { final java.util.Enumeration<? extends java.util.zip.ZipEntry> e = zf.entries(); while (e.hasMoreElements()) { final java.util.zip.ZipEntry ze = e.nextElement(); final java.lang.String name = ze.getName(); if (((((ze.isDirectory()) || (name.startsWith("WEB-INF/"))) || (name.startsWith("META-INF/"))) || (name.startsWith("com/google/gerrit/launcher/"))) || (name.equals("Main.class"))) { continue; } final java.io.File rawtmp = new java.io.File(dstwar, name); com.google.gerrit.pgm.http.jetty.JettyServer.mkdir(rawtmp.getParentFile()); rawtmp.deleteOnExit(); final java.io.FileOutputStream rawout = new java.io.FileOutputStream(rawtmp); try { final java.io.InputStream in = zf.getInputStream(ze); try { final byte[] buf = new byte[4096]; int n; while ((n = in.read(buf, 0, buf.length)) > 0) { rawout.write(buf, 0, n); } } finally { in.close(); } } finally { rawout.close(); } } } finally { zf.close(); } }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = com.google.common.collect.Lists.newLinkedList(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = com.google.common.collect.Lists.newLinkedList(); try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, com.google.gerrit.common.TimeUtil.nowTs()); auditUpdates.add(audit); } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, com.google.gerrit.common.TimeUtil.nowTs()); audit.removedLegacy(); auditInserts.add(audit); } } db.accountGroupMembersAudit().update(auditUpdates); db.accountGroupMembersAudit().insert(auditInserts); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e); } }
private com.google.gerrit.server.account.AuthResult byAccountId(final java.lang.String idStr) { final com.google.gerrit.reviewdb.client.Account.Id id; try { id = Account.Id.parse(idStr); } catch (java.lang.NumberFormatException nfe) { return null; } try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { return auth(db.accounts().get(id)); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log("cannot query database", e); return null; } }
private byte[] zip(org.apache.lucene.store.RAMDirectory dir) throws java.io.IOException { java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(buf); for (java.lang.String name : dir.listAll()) { org.apache.lucene.store.IndexInput in = dir.openInput(name, null); try { int len = ((int) (in.length())); byte[] tmp = new byte[len]; java.util.zip.ZipEntry entry = new java.util.zip.ZipEntry(name); entry.setSize(len); in.readBytes(tmp, 0, len); zip.putNextEntry(entry); zip.write(tmp, 0, len); zip.closeEntry(); } finally { in.close(); } } zip.close(); return buf.toByteArray(); }
@java.lang.Override protected void doPost(final javax.servlet.http.HttpServletRequest req, final javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException, javax.servlet.ServletException { com.google.gwtexpui.server.CacheHeaders.setNotCacheable(rsp); final com.google.gerrit.server.account.AuthResult res; if ("create_account".equals(req.getParameter("action"))) { res = create(); } else if ((req.getParameter("user_name")) != null) { res = byUserName(req.getParameter("user_name")); } else if ((req.getParameter("preferred_email")) != null) { res = byPreferredEmail(req.getParameter("preferred_email")); } else if ((req.getParameter("account_id")) != null) { res = byAccountId(req.getParameter("account_id")); } else { byte[] raw; try { raw = prepareHtmlOutput(); } catch (com.google.gwtorm.server.OrmException e) { throw new javax.servlet.ServletException(e); } rsp.setContentType("text/html"); rsp.setCharacterEncoding(HtmlDomUtil.ENC.name()); rsp.setContentLength(raw.length); final java.io.OutputStream out = rsp.getOutputStream(); try { out.write(raw); } finally { out.close(); } return; } if (res != null) { webSession.get().login(res, false); final java.lang.StringBuilder rdr = new java.lang.StringBuilder(); rdr.append(req.getContextPath()); rdr.append("/"); if (res.isNew()) { rdr.append(('#' + (com.google.gerrit.common.PageLinks.REGISTER))); } else { rdr.append(com.google.gerrit.httpd.LoginUrlToken.getToken(req)); } rsp.sendRedirect(rdr.toString()); } else { rsp.setContentType("text/html"); rsp.setCharacterEncoding(HtmlDomUtil.ENC.name()); final java.io.Writer out = rsp.getWriter(); out.write("<html>"); out.write("<body>"); out.write("<h1>Account Not Found</h1>"); out.write("</body>"); out.write("</html>"); out.close(); } }
private com.google.gerrit.server.account.AuthResult byUserName(final java.lang.String userName) { try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, userName); return auth(db.accountExternalIds().get(key)); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log("cannot query database", e); return null; } }
public com.google.gerrit.testutil.InMemoryDatabase create() throws com.google.gwtorm.server.OrmException { if (!(created)) { created = true; final com.google.gerrit.reviewdb.server.ReviewDb c = open(); try { try { schemaCreator.create(c); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException("Cannot create in-memory database", e); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Cannot create in-memory database", e); } } finally { c.close(); } } return this; }
@java.lang.Override public void funnel(K from, com.google.common.hash.PrimitiveSink into) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream(new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream(into)); try { ser.writeObject(from); ser.flush(); } finally { ser.close(); } } catch (java.io.IOException err) { throw new java.lang.RuntimeException("Cannot hash as Serializable", err); } }
com.google.common.hash.Funnel<K> funnel() { return new com.google.common.hash.Funnel<K>() { private static final long serialVersionUID = 1L; @java.lang.Override public void funnel(K from, com.google.common.hash.PrimitiveSink into) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream(new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream(into)); try { ser.writeObject(from); ser.flush(); } finally { ser.close(); } } catch (java.io.IOException err) { throw new java.lang.RuntimeException("Cannot hash as Serializable", err); } } }; }
@java.lang.Override public void setProjectDescription(final com.google.gerrit.reviewdb.client.Project.NameKey name, final java.lang.String description) { try { final org.eclipse.jgit.lib.Repository e = openRepository(name); try { final java.lang.String old = getProjectDescription(e); if (((old == null) && (description == null)) || ((old != null) && (old.equals(description)))) { return; } final org.eclipse.jgit.internal.storage.file.LockFile f = new org.eclipse.jgit.internal.storage.file.LockFile(new java.io.File(e.getDirectory(), "description"), org.eclipse.jgit.util.FS.DETECTED); if (f.lock()) { java.lang.String d = description; if (d != null) { d = d.trim(); if ((d.length()) > 0) { d += "\n"; } } else { d = ""; } f.write(org.eclipse.jgit.lib.Constants.encode(d)); f.commit(); } } finally { e.close(); } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { com.google.gerrit.server.git.LocalDiskRepositoryManager.log.error(("Cannot update description for " + name), e); } catch (java.io.IOException e) { com.google.gerrit.server.git.LocalDiskRepositoryManager.log.error(("Cannot update description for " + name), e); } }
protected org.apache.lucene.store.Directory readIndexDirectory() throws java.io.IOException { org.apache.lucene.store.Directory dir = new org.apache.lucene.store.RAMDirectory(); byte[] buffer = new byte[4096]; java.io.InputStream index = getClass().getResourceAsStream(Constants.INDEX_ZIP); if (index == null) { com.google.gerrit.server.documentation.QueryDocumentationExecutor.log.warn("No index available"); return null; } java.util.zip.ZipInputStream zip = new java.util.zip.ZipInputStream(index); try { java.util.zip.ZipEntry entry; while ((entry = zip.getNextEntry()) != null) { org.apache.lucene.store.IndexOutput out = dir.createOutput(entry.getName(), null); int count; while ((count = zip.read(buffer)) != (-1)) { out.writeBytes(buffer, count); } out.close(); } } finally { zip.close(); } return dir; }
public boolean canReadCommit(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.Repository repo = openRepository(); try { return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values()); } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey()); com.google.gerrit.server.project.ProjectControl.log.error(msg, e); return false; } }
private boolean isMergedIntoBranchOrTag(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.Repository repo = projectControl.openRepository(); try { java.util.List<org.eclipse.jgit.lib.Ref> refs = new java.util.ArrayList(repo.getRefDatabase().getRefs(Constants.R_HEADS).values()); refs.addAll(repo.getRefDatabase().getRefs(Constants.R_TAGS).values()); return projectControl.isMergedIntoVisibleRef(repo, db, rw, commit, refs); } finally { repo.close(); } } catch (java.io.IOException e) { java.lang.String msg = java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projectControl.getProject().getNameKey()); com.google.gerrit.server.project.RefControl.log.error(msg, e); } return false; }
private java.util.List<org.eclipse.jgit.lib.Ref> getBranchRefs(com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.project.ProjectControl projectControl) { org.eclipse.jgit.lib.Ref[] result = new org.eclipse.jgit.lib.Ref[showBranch.size()]; try { org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName); try { for (int i = 0; i < (showBranch.size()); i++) { org.eclipse.jgit.lib.Ref ref = git.getRef(showBranch.get(i)); if ((((ref != null) && ((ref.getObjectId()) != null)) && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible())) || ((all) && (projectControl.isOwner()))) { result[i] = ref; } } } finally { git.close(); } } catch (java.io.IOException ioe) { } return java.util.Arrays.asList(result); }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = com.google.common.collect.Lists.newLinkedList(); try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { for (final com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } if (audit != null) { audit.removed(me, com.google.gerrit.common.TimeUtil.nowTs()); auditUpdates.add(audit); } } db.accountGroupByIdAud().update(auditUpdates); } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e); } }
@java.lang.Override public boolean allowsEdit(final com.google.gerrit.reviewdb.client.Account.FieldName field) { if ((authConfig.getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.HTTP)) { switch (field) { case USER_NAME : return false; case FULL_NAME : return (com.google.common.base.Strings.emptyToNull(authConfig.getHttpDisplaynameHeader())) == null; case REGISTER_NEW_EMAIL : return (com.google.common.base.Strings.emptyToNull(authConfig.getHttpEmailHeader())) == null; default : return true; } } else { return true; } }

private void verifySignature(org.eclipse.jgit.transport.PushCertificate cert, java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands, java.io.Writer msgOut) throws java.io.IOException { org.bouncycastle.openpgp.PGPSignature sig = readSignature(cert); if (sig == null) { msgOut.write("Invalid signature format\n"); com.google.gerrit.server.git.SignedPushPreReceiveHook.rejectInvalid(commands); return; } org.bouncycastle.openpgp.PGPPublicKey key = readPublicKey(sig.getKeyID()); if (key == null) { msgOut.write((("No valid public key found for ID " + (com.google.gerrit.server.git.SignedPushPreReceiveHook.keyIdToString(sig.getKeyID()))) + "\n")); com.google.gerrit.server.git.SignedPushPreReceiveHook.rejectInvalid(commands); return; } try { sig.init(new org.bouncycastle.openpgp.operator.bc.BcPGPContentVerifierBuilderProvider(), key); sig.verify(); return; } catch (org.bouncycastle.openpgp.PGPException e) { msgOut.write((("Push certificate verification failed: " + (e.getMessage())) + "\n")); com.google.gerrit.server.git.SignedPushPreReceiveHook.rejectInvalid(commands); return; } }


@java.lang.Override public void init(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.transport.ReceivePack rp) { rp.setSignedPushConfig(signedPushConfig); if ((signedPushConfig) != null) { rp.setPreReceiveHook(org.eclipse.jgit.transport.PreReceiveHookChain.newChain(com.google.common.collect.Lists.newArrayList(hook, rp.getPreReceiveHook()))); } }



@java.lang.Override public void visit(org.pegdown.ast.HeaderNode node) { java.lang.String id = toc.idFromHeader(node); if (id != null) { html.open("a").attribute("name", id); } try { outputNamedAnchor = false; wrapChildren(("h" + (node.getLevel())), node); } finally { outputNamedAnchor = true; } if (id != null) { html.close("a"); } }




public void abandonInactiveOpenChanges() { if ((cfg.getAbandonAfter()) <= 0) { return; } try { for (com.google.gerrit.server.query.change.ChangeData cd : query(com.google.gerrit.server.change.ChangeCleanupUtil.inactiveChangesQuery(cfg.getAbandonAfter()))) { abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null); } } catch (java.lang.Throwable e) { com.google.gerrit.server.change.ChangeCleanupUtil.log.error("Failed to auto-abandon inactive open changes.", e); } }
private java.lang.String projectBaseName(java.lang.String project) { int i = project.lastIndexOf('/'); if (i < 0) { return project; } else { return project.substring((i + 1)); } }
private java.lang.String getBaseName(java.lang.String project) { int i = project.lastIndexOf('/'); if (i < 0) { return project; } else { return project.substring((i + 1)); } }

private com.google.gerrit.server.config.GetServerInfo.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllUsersName allUsersName) { com.google.gerrit.server.config.GetServerInfo.GerritInfo info = new com.google.gerrit.server.config.GetServerInfo.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugText"); return info; }

protected java.util.List<org.eclipse.jgit.revwalk.RevCommit> getRemoteLog() throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { rw.markStart(rw.parseCommit(repo.getRef("refs/heads/master").getObjectId())); return com.google.common.collect.Lists.newArrayList(rw); } }
@org.junit.Test public void killTask_NotFound() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get("/config/server/tasks/"); java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo> result = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo>>() {}.getType()); r.consume(); assertThat(result.size()).isGreaterThan(0); r = userSession.delete(("/config/server/tasks/" + (result.get(0).id))); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NOT_FOUND); }

public static com.google.gerrit.server.git.ChangeSet create(com.google.gerrit.reviewdb.client.Change change) { com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Project.NameKey> rb = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Branch.NameKey> bb = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> ib = com.google.common.collect.ImmutableSet.builder(); rb.add(change.getDest().getParentKey()); bb.add(change.getDest()); ib.add(change.getId()); return new com.google.gerrit.server.git.AutoValue_ChangeSet(rb.build(), bb.build(), ib.build()); }
private void openRepository() throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.reviewdb.client.Project.NameKey name = destBranch.getParentKey(); try { repo = repoManager.openRepository(name); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notFound) { throw new com.google.gerrit.server.project.NoSuchProjectException(name, notFound); } catch (java.io.IOException err) { java.lang.String m = ("Error opening repository \"" + (name.get())) + '"'; throw new com.google.gerrit.server.git.MergeException(m, err); } rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo); rw.sort(RevSort.TOPO); rw.sort(RevSort.COMMIT_TIME_DESC, true); canMergeFlag = rw.newFlag("CAN_MERGE"); inserter = repo.newObjectInserter(); }
private com.google.gerrit.common.data.Capable isSubmitStillPossible(com.google.gerrit.server.git.CodeReviewCommit commit) throws com.google.gerrit.extensions.restapi.ResourceConflictException { com.google.gerrit.common.data.Capable capable; com.google.gerrit.reviewdb.client.Change c = commit.change(); boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit); long now = com.google.gerrit.common.TimeUtil.nowMs(); long waitUntil = (c.getLastUpdatedOn().getTime()) + (com.google.gerrit.server.git.MergeOp.DEPENDENCY_DELAY); if (submitStillPossible && (now < waitUntil)) { long recheckIn = waitUntil - now; logDebug("Submit for {} is still possible; rechecking in {}ms", c.getId(), recheckIn); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Cannot integrate " + c)); } else if (submitStillPossible) { logDebug("Submit for {} is still possible after missing dependencies", c.getId()); java.lang.StringBuilder m = new java.lang.StringBuilder(); m.append("Change could not be merged because of a missing dependency."); m.append("\n"); m.append("\n"); m.append("The following changes must also be submitted:\n"); m.append("\n"); for (com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing) { m.append("* "); m.append(missingCommit.change().getKey().get()); m.append("\n"); } capable = new com.google.gerrit.common.data.Capable(m.toString()); } else { logDebug("Submit for {} is not possible", c.getId()); java.lang.StringBuilder m = new java.lang.StringBuilder(); m.append("Change cannot be merged due to unsatisfiable dependencies.\n"); m.append("\n"); m.append("The following dependency errors were found:\n"); m.append("\n"); for (com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing) { com.google.gerrit.reviewdb.client.PatchSet.Id missingPsId = missingCommit.getPatchsetId(); if (missingPsId != null) { m.append("* Depends on patch set "); m.append(missingPsId.get()); m.append(" of "); m.append(missingCommit.change().getKey().abbreviate()); com.google.gerrit.reviewdb.client.PatchSet.Id currPsId = missingCommit.change().currentPatchSetId(); if (!(missingPsId.equals(currPsId))) { m.append(", however the current patch set is "); m.append(currPsId.get()); } m.append(".\n"); } else { m.append("* Depends on commit "); m.append(missingCommit.name()); m.append(" which has no change associated with it.\n"); } } m.append("\n"); m.append("Please rebase the change and upload a replacement commit."); capable = new com.google.gerrit.common.data.Capable(m.toString()); } return capable; }
private void fireRefUpdated(org.eclipse.jgit.lib.RefUpdate branchUpdate) { logDebug("Firing ref updated hooks for {}", branchUpdate.getName()); gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate); hooks.doRefUpdatedHook(destBranch, branchUpdate, getAccount(mergeTip.getCurrentTip())); }

private boolean isSubmitForMissingCommitsStillPossible(com.google.gerrit.server.git.CodeReviewCommit commit) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = commit.getPatchsetId(); if (((commit.missing) == null) || (commit.missing.isEmpty())) { logDebug("Patch set {} is not submittable: no list of missing commits", psId); return false; } for (com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing) { try { loadChangeInfo(missingCommit); } catch (com.google.gerrit.server.project.NoSuchChangeException | com.google.gwtorm.server.OrmException e) { logError("Cannot check if missing commits can be submitted", e); return false; } if ((missingCommit.getPatchsetId()) == null) { logDebug(("Patch set {} is not submittable: dependency {} has no" + " associated patch set"), psId, missingCommit.name()); return false; } if (!(missingCommit.change().currentPatchSetId().equals(missingCommit.getPatchsetId()))) { com.google.gerrit.reviewdb.client.PatchSet.Id missingId = missingCommit.getPatchsetId(); logDebug(("Patch set {} is not submittable: depends on patch set {} of" + " change {}, but current patch set is {}"), psId, missingId, missingId.getParentKey(), missingCommit.change().currentPatchSetId()); return false; } } return true; }
private org.eclipse.jgit.lib.RefUpdate openBranch() throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { try { org.eclipse.jgit.lib.RefUpdate branchUpdate = repo.updateRef(destBranch.get()); if ((branchUpdate.getOldObjectId()) != null) { branchTip = ((com.google.gerrit.server.git.CodeReviewCommit) (rw.parseCommit(branchUpdate.getOldObjectId()))); } else if (repo.getFullBranch().equals(destBranch.get())) { branchTip = null; branchUpdate.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); } else { for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().submitted(destBranch)) { try { com.google.gerrit.reviewdb.client.Change c = cd.change(); setNew(c, message(c, ("Change could not be merged, " + "because the destination branch does not exist anymore."))); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.MergeOp.log.error("Error setting change new", e); } } } logDebug("Opened branch {}: {}", destBranch.get(), branchTip); return branchUpdate; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot open branch", e); } }
private com.google.gerrit.reviewdb.client.Change submitThisChange(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.IdentifiedUser caller, boolean force) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db, rsrc.getControl()); java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force); final java.sql.Timestamp timestamp = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp); update.submit(submitRecords); db.changes().beginTransaction(change.getId()); try { com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch = approve(rsrc.getPatchSet().getId(), cd.changeControl(), update, caller, timestamp); batch.write(update, new org.eclipse.jgit.lib.CommitBuilder()); change = submitToDatabase(db, change.getId(), timestamp); db.commit(); } finally { db.rollback(); } indexer.index(db, change); return change; }
@org.junit.Test public void killTask() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get("/config/server/tasks/"); java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo> result = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo>>() {}.getType()); r.consume(); int taskCount = result.size(); assertThat(taskCount).isGreaterThan(0); r = adminSession.delete(("/config/server/tasks/" + (result.get(0).id))); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NO_CONTENT); r.consume(); r = adminSession.get("/config/server/tasks/"); result = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo>>() {}.getType()); r.consume(); assertThat(result).hasSize((taskCount - 1)); }
private void submit(com.google.gerrit.server.project.ChangeControl changeCtl, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.Submit submit = submitProvider.get(); com.google.gerrit.server.change.RevisionResource rsrc = new com.google.gerrit.server.change.RevisionResource(changes.parse(changeCtl), ps); java.util.List<com.google.gerrit.reviewdb.client.Change> changes; try { changes = submit.submit(rsrc, currentUser, true); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new java.io.IOException(e); } addMessage(""); try { integrationProvider.get().create(com.google.gerrit.server.git.ChangeSet.create(changes)).merge(); } catch (com.google.gerrit.server.git.MergeException | com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } for (com.google.gerrit.reviewdb.client.Change c : changes) { c = db.changes().get(c.getId()); switch (c.getStatus()) { case SUBMITTED : addMessage((("Change " + (c.getChangeId())) + " submitted.")); break; case MERGED : addMessage((("Change " + (c.getChangeId())) + " merged.")); break; case NEW : com.google.gerrit.reviewdb.client.ChangeMessage msg = submit.getConflictMessage(rsrc); if (msg != null) { addMessage(((("Change " + (c.getChangeId())) + ": ") + (msg.getMessage()))); break; } default : addMessage(((("change " + (c.getChangeId())) + " is ") + (c.getStatus().name().toLowerCase()))); } } }
private com.google.gerrit.server.git.strategy.SubmitStrategy createStrategy(com.google.gerrit.extensions.client.SubmitType submitType) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch); }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead() throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { return getHead(repo, "refs/heads/master"); } }
private void abandonAllOpenChanges() throws com.google.gerrit.server.project.NoSuchChangeException { java.lang.Exception err = null; try { openSchema(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byProjectOpen(destBranch.getParentKey())) { abandonOneChange(cd.change()); } db.close(); db = null; } catch (java.io.IOException e) { err = e; } catch (com.google.gwtorm.server.OrmException e) { err = e; } if (err != null) { logWarn(("Cannot abandon changes for deleted project " + (destBranch.getParentKey().get())), err); } }
private void setDestProject() throws com.google.gerrit.server.git.MergeException { destProject = projectCache.get(destBranch.getParentKey()); if ((destProject) == null) { throw new com.google.gerrit.server.git.MergeException(("No such project: " + (destBranch.getParentKey()))); } }
public static com.google.gerrit.server.git.ChangeSet create(java.lang.Iterable<com.google.gerrit.reviewdb.client.Change> changes) { com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Project.NameKey> rb = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Branch.NameKey> bb = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> ib = com.google.common.collect.ImmutableSet.builder(); for (com.google.gerrit.reviewdb.client.Change c : changes) { rb.add(c.getDest().getParentKey()); bb.add(c.getDest()); ib.add(c.getId()); } return new com.google.gerrit.server.git.AutoValue_ChangeSet(rb.build(), bb.build(), ib.build()); }
@org.junit.Test public void killTask_NotFound() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get("/config/server/tasks/"); java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo> result = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo>>() {}.getType()); r.consume(); assertThat(result.size()).isGreaterThan(0); r = userSession.delete(("/config/server/tasks/" + (result.get(0).id))); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NOT_FOUND); }
private void submit(com.google.gerrit.server.project.ChangeControl changeCtl, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.Submit submit = submitProvider.get(); com.google.gerrit.server.change.RevisionResource rsrc = new com.google.gerrit.server.change.RevisionResource(changes.parse(changeCtl), ps); java.util.List<com.google.gerrit.reviewdb.client.Change> changes; try { changes = submit.submit(rsrc, currentUser, true); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new java.io.IOException(e); } addMessage(""); for (com.google.gerrit.reviewdb.client.Change c : changes) { mergeQueue.merge(c.getDest()); c = db.changes().get(c.getId()); switch (c.getStatus()) { case SUBMITTED : addMessage((("Change " + (c.getChangeId())) + " submitted.")); break; case MERGED : addMessage((("Change " + (c.getChangeId())) + " merged.")); break; case NEW : com.google.gerrit.reviewdb.client.ChangeMessage msg = submit.getConflictMessage(rsrc); if (msg != null) { addMessage(((("Change " + (c.getChangeId())) + ": ") + (msg.getMessage()))); break; } default : addMessage(((("change " + (c.getChangeId())) + " is ") + (c.getStatus().name().toLowerCase()))); } } }
private void updateSubscriptions(java.util.List<com.google.gerrit.reviewdb.client.Change> submitted) { if (((mergeTip) != null) && (((branchTip) == null) || ((branchTip) != (mergeTip.getCurrentTip())))) { logDebug("Updating submodule subscriptions for {} changes", submitted.size()); com.google.gerrit.server.git.SubmoduleOp subOp = subOpFactory.create(destBranch, mergeTip.getCurrentTip(), rw, repo, destProject.getProject(), submitted, commits, getAccount(mergeTip.getCurrentTip())); try { subOp.update(); } catch (com.google.gerrit.server.git.SubmoduleException e) { logError("The gitLinks were not updated according to the subscriptions", e); } } }
com.google.gerrit.server.git.MergeOp create(com.google.gerrit.reviewdb.client.Branch.NameKey branch);
private void setUpEnforced(java.lang.String[] refPatterns) { expect(pluginConfig.getString("enabled")).andReturn("enforced").once(); expect(pluginConfigWithInheritance.getStringList("branch")).andReturn(refPatterns); easyMock.replayAll(); }
public java.lang.String[] getIssueIds(java.lang.String haystack) { java.util.regex.Pattern pattern = itsConfig.getIssuePattern(); if (pattern == null) return new java.lang.String[]{ }; com.googlesource.gerrit.plugins.hooks.util.IssueExtractor.log.debug(((("Matching '" + haystack) + "' against ") + (pattern.pattern()))); java.util.Set<java.lang.String> issues = com.google.common.collect.Sets.newHashSet(); java.util.regex.Matcher matcher = pattern.matcher(haystack); while (matcher.find()) { int groupIdx = java.lang.Math.min(matcher.groupCount(), 1); issues.add(matcher.group(groupIdx)); } return issues.toArray(new java.lang.String[issues.size()]); }
public void testInlineWithSingleProperty() throws java.io.IOException { com.googlesource.gerrit.plugins.its.workflow.ActionRequest actionRequest = createMock(com.googlesource.gerrit.plugins.its.workflow.ActionRequest.class); expect(actionRequest.getParameter(1)).andReturn("inline"); expect(actionRequest.getParameters()).andReturn(new java.lang.String[]{ "inline", "${subject}" }); java.util.Set<com.googlesource.gerrit.plugins.its.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); com.googlesource.gerrit.plugins.its.workflow.Property propertySubject = createMock(com.googlesource.gerrit.plugins.its.workflow.Property.class); expect(propertySubject.getKey()).andReturn("subject").anyTimes(); expect(propertySubject.getValue()).andReturn("Rosebud").anyTimes(); properties.add(propertySubject); org.easymock.IAnswer<java.lang.Boolean> answer = new com.googlesource.gerrit.plugins.hooks.workflow.action.AddVelocityCommentTest.VelocityWriterFiller("Rosebud"); org.easymock.Capture<org.apache.velocity.VelocityContext> contextCapture = new org.easymock.Capture(); expect(velocityRuntime.evaluate(capture(contextCapture), ((java.io.Writer) (anyObject())), ((java.lang.String) (anyObject())), eq("${subject}"))).andAnswer(answer); its.addComment("4711", "Rosebud"); replayMocks(); com.googlesource.gerrit.plugins.its.workflow.action.AddVelocityComment addVelocityComment = createAddVelocityComment(); addVelocityComment.execute("4711", actionRequest, properties); org.apache.velocity.VelocityContext context = contextCapture.getValue(); assertEquals("Subject property of context did not match", "Rosebud", context.get("subject")); }
@java.lang.Override public java.util.List<ChangeInfo> queryChanges(java.lang.String projectName) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException { java.lang.String endPoint = (("/changes/?q=project:" + projectName) + "&O=") + (java.lang.Integer.toHexString(com.google.gerrit.extensions.client.ListChangesOption.toBits(java.util.EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS)))); java.util.List<ChangeInfo> result; try (com.googlesource.gerrit.plugins.importer.RestResponse r = checkedGet(endPoint)) { result = com.googlesource.gerrit.plugins.importer.RemoteApi.newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<ChangeInfo>>() {}.getType()); } for (ChangeInfo c : result) { for (java.util.Map.Entry<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> e : c.revisions.entrySet()) { e.getValue().commit.commit = e.getKey(); } } return result; }
void replay() throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.validators.ValidationException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> changes = api.queryChanges(srcProject.get()); pm.beginTask("Replay Changes", changes.size()); org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo); try { for (com.google.gerrit.extensions.common.ChangeInfo c : changes) { try { replayChange(rw, c); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.importer.ReplayChangesStep.log.error(java.lang.String.format("Failed to replay change %s.", com.google.gerrit.extensions.restapi.Url.decode(c.id)), e); throw e; } pm.update(1); } } finally { rw.close(); } pm.endTask(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> queryChanges(java.lang.String projectName) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException { try { return gApi.changes().query(("project:" + projectName)).withOptions(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS).get(); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } }
@java.lang.Override public long size() { java.lang.String[] files = dir.list(); if (files == null) { return 0; } return files.length; }
private com.google.gerrit.httpd.WebSessionManager.Val readFile(java.io.File f) { try (java.io.InputStream fileStream = new java.io.FileInputStream(f);java.io.ObjectInputStream objStream = new java.io.ObjectInputStream(fileStream)) { return ((com.google.gerrit.httpd.WebSessionManager.Val) (objStream.readObject())); } catch (java.lang.ClassNotFoundException e) { com.googlesource.gerrit.plugins.websession.flatfile.FlatFileWebSessionCache.log.warn(((((("Entry " + (f.getName())) + " in cache ") + (dir.getAbsolutePath())) + " has an incompatible class and can't be deserialized. ") + "Invalidating entry.")); invalidate(f.getName()); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.websession.flatfile.FlatFileWebSessionCache.log.warn(("Cannot read cache " + (dir.getAbsolutePath())), e); } return null; }
@java.lang.Override public void invalidateAll() { java.io.File[] files = dir.listFiles(); if (files != null) { for (java.io.File f : files) { deleteFile(f); } } }
@java.lang.Override public java.util.concurrent.ConcurrentMap<java.lang.String, com.google.gerrit.httpd.WebSessionManager.Val> asMap() { java.util.concurrent.ConcurrentMap<java.lang.String, com.google.gerrit.httpd.WebSessionManager.Val> map = new java.util.concurrent.ConcurrentHashMap<>(); java.io.File[] files = dir.listFiles(); if (files == null) { return map; } for (java.io.File f : files) { com.google.gerrit.httpd.WebSessionManager.Val v = readFile(f); if (v != null) { map.put(f.getName(), v); } } return map; }
@java.lang.Override public java.lang.String getUrl(com.google.gerrit.server.IdentifiedUser forUser, int imageSize) { if ((externalAvatarUrl) == null) { org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.class); log.warn("Avatar URL is not configured, cannot show avatars. Please configure avatar.url in etc/gerrit.config"); return null; } if (!(externalAvatarUrl.contains(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER))) { org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.class); log.warn((((("Avatar provider url '" + (externalAvatarUrl)) + "' does not contain ") + (com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER)) + ", so cannot replace it with username")); return null; } if ((ssl) && (externalAvatarUrl.startsWith("http://"))) { externalAvatarUrl = externalAvatarUrl.replace("http://", "https://"); } return replaceInUrl(externalAvatarUrl, forUser.getUserName()); }

@java.lang.Override public final java.lang.String getCommand(com.google.gerrit.extensions.config.DownloadScheme scheme, java.lang.String project, java.lang.String ref) { if ((commandAllowed) && (com.googlesource.gerrit.plugins.download.command.GitDownloadCommand.isRecognizedScheme(scheme))) { java.lang.String url = scheme.getUrl(project); if ((url != null) && (com.googlesource.gerrit.plugins.download.command.GitDownloadCommand.isValidUrl(url))) { return getCommand(url, ref); } } return null; }




@java.lang.Override public int hashCode() { final int prime = 31; int result = 1; result = (prime * result) + (id); return result; }


private void abandonAllOpenChanges(com.google.gerrit.reviewdb.client.Project.NameKey destProject) throws com.google.gerrit.server.project.NoSuchChangeException { try { openSchema(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byProjectOpen(destProject)) { abandonOneChange(cd.change()); } db.close(); db = null; } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { logWarn("Cannot abandon changes for deleted project ", e); } }

@java.lang.Override public void onSuccess(com.google.gerrit.client.documentation.DocInfo indexInfo) { com.google.gerrit.client.Gerrit.hasDocumentation = indexInfo != null; }
private com.google.gerrit.server.config.GetServerInfo.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllUsersName allUsersName) { com.google.gerrit.server.config.GetServerInfo.GerritInfo info = new com.google.gerrit.server.config.GetServerInfo.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugText"); return info; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.config.ServerInfo info) { com.google.gerrit.client.Gerrit.myServerInfo = info; }


















@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); submitStatusOnly(change2.getChangeId()); submitStatusOnly(change3.getChangeId()); submit(change4.getChangeId()); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); org.eclipse.jgit.revwalk.RevCommit tip = log.get(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId()); }
protected void submitStatusOnly(java.lang.String changeId) throws java.lang.Exception { approve(changeId); com.google.gerrit.reviewdb.client.Change c = queryProvider.get().byKeyPrefix(changeId).get(0).change(); c.setStatus(Change.Status.SUBMITTED); db.changes().update(java.util.Collections.singleton(c)); db.patchSetApprovals().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.PatchSetApproval(new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(c.currentPatchSetId(), admin.id, com.google.gerrit.reviewdb.client.LabelId.SUBMIT), ((short) (1)), new java.sql.Timestamp(java.lang.System.currentTimeMillis())))); indexer.index(db, c); }
@org.junit.Test public void submitTwoChangesWithFastForward() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); approve(change.getChangeId()); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change2.getCommitId()); assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId()); assertSubmitter(change.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 1); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); submitStatusOnly(change2.getChangeId()); submitStatusOnly(change3.getChangeId()); submit(change4.getChangeId()); org.eclipse.jgit.revwalk.RevCommit tip = getRemoteLog().get(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId()); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithRebase() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); submit(change2.getChangeId()); assertRebase(testRepo, false); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getParent(0)).isEqualTo(oldHead); assertApproved(change2.getChangeId()); assertCurrentRevision(change2.getChangeId(), 2, head); assertSubmitter(change2.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 2); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); submitStatusOnly(change2.getChangeId()); submitStatusOnly(change3.getChangeId()); submit(change4.getChangeId()); org.eclipse.jgit.revwalk.RevCommit tip = getRemoteLog().get(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); tip = tip.getParent(0); assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId()); }
@org.junit.Test public void submitWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change.getCommitId()); assertThat(head.getParent(0)).isEqualTo(oldHead); assertSubmitter(change.getChangeId(), 1); }

@org.junit.Test public void submitWithCherryPick() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); submit(change2.getChangeId()); assertCherryPick(testRepo, false); org.eclipse.jgit.revwalk.RevCommit newHead = getRemoteHead(); assertThat(newHead.getParentCount()).isEqualTo(1); assertThat(newHead.getParent(0)).isEqualTo(oldHead); assertCurrentRevision(change2.getChangeId(), 2, newHead); assertSubmitter(change2.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 2); }
@org.junit.Test public void submitWithMergeIfFastForwardPossible() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getParentCount()).isEqualTo(2); assertThat(head.getParent(0)).isEqualTo(oldHead); assertThat(head.getParent(1)).isEqualTo(change.getCommitId()); assertSubmitter(change.getChangeId(), 1); }

private java.lang.String href(java.lang.String url) { if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return url; } if (com.google.gitiles.doc.MarkdownUtil.isAbsolutePathToMarkdown(url)) { return com.google.gitiles.GitilesView.doc().copyFrom(view).setPathPart(url).build().toUrl(); } if (((readme) && (!(url.startsWith("../")))) && (!(url.startsWith("./")))) { java.lang.String dir = ""; if (((view.getPathPart()) != null) && (view.getPathPart().endsWith("/"))) { dir = view.getPathPart(); } else if ((view.getPathPart()) != null) { dir = (view.getPathPart()) + '/'; } return com.google.gitiles.GitilesView.path().copyFrom(view).setPathPart((dir + url)).build().toUrl(); } return url; }
@java.lang.Override public java.lang.String getCommand(com.google.gerrit.extensions.config.DownloadScheme scheme, java.lang.String project) { java.lang.String username = userProvider.get().getUserName(); if ((!(sshScheme.isEnabled())) || (username == null)) { return null; } return new java.lang.StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p -P ").append(sshScheme.getSshdPort()).append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":hooks/commit-msg ").append(com.googlesource.gerrit.plugins.download.command.CloneWithCommitMsgHook.getBaseName(project)).append("/.git/hooks/").toString(); }
public com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> byChange(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser user) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject())) { java.lang.String editRefPrefix = com.google.gerrit.reviewdb.client.RefNames.refsEditPrefix(user.getAccountId(), change.getId()); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix); if (refs.isEmpty()) { return com.google.common.base.Optional.absent(); } org.eclipse.jgit.lib.Ref ref = com.google.common.collect.Iterables.getOnlyElement(refs.values()); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(ref.getObjectId()); com.google.gerrit.reviewdb.client.PatchSet basePs = getBasePatchSet(change, ref); return com.google.common.base.Optional.of(new com.google.gerrit.server.edit.ChangeEdit(user, change, ref, commit, basePs)); } } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.account.SetPreferences.Input i) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((((((((((((((i.changesPerPage) != null) || ((i.showSiteHeader) != null)) || ((i.useFlashClipboard) != null)) || ((i.downloadScheme) != null)) || ((i.downloadCommand) != null)) || ((i.copySelfOnEmail) != null)) || ((i.dateFormat) != null)) || ((i.timeFormat) != null)) || ((i.relativeDateInChangeTable) != null)) || ((i.sizeBarInChangeTable) != null)) || ((i.legacycidInChangeTable) != null)) || ((i.muteCommonPathPrefixes) != null)) || ((i.reviewCategoryStrategy) != null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported option"); } com.google.gerrit.server.account.VersionedAccountPreferences p; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName); try { p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); p.commit(md); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, md.getRepository()); } finally { md.close(); } }
private void initUUID() { final com.google.gwt.user.client.ui.VerticalPanel groupUUIDPanel = new com.google.gwt.user.client.ui.VerticalPanel(); groupUUIDPanel.setStyleName(Gerrit.RESOURCES.css().groupUUIDPanel()); groupUUIDPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingGroupUUID())); groupUUIDLabel = new com.google.gwtexpui.clippy.client.CopyableLabel(""); groupUUIDPanel.add(groupUUIDLabel); add(groupUUIDPanel); }


public static void applyUserPreferences() { if ((com.google.gerrit.client.Gerrit.myAccount) != null) { final com.google.gerrit.reviewdb.client.AccountGeneralPreferences p = com.google.gerrit.client.Gerrit.myAccount.getGeneralPreferences(); com.google.gwtexpui.clippy.client.CopyableLabel.setFlashEnabled(p.isUseFlashClipboard()); if ((com.google.gerrit.client.Gerrit.siteHeader) != null) { com.google.gerrit.client.Gerrit.siteHeader.setVisible(p.isShowSiteHeader()); } if ((com.google.gerrit.client.Gerrit.siteFooter) != null) { com.google.gerrit.client.Gerrit.siteFooter.setVisible(p.isShowSiteHeader()); } com.google.gerrit.client.FormatUtil.setPreferences(com.google.gerrit.client.Gerrit.myAccount.getGeneralPreferences()); } }
@java.lang.Override public void setText(final java.lang.String newText) { text = newText; visibleLen = newText.length(); if ((textLabel) != null) { textLabel.setText(getText()); } if ((textBox) != null) { textBox.setText(getText()); textBox.selectAll(); } embedMovie(); }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { showTextBox(); }
public void resetToDefaults() { maximumPageSize = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DEFAULT_PAGESIZE; showSiteHeader = true; useFlashClipboard = true; copySelfOnEmail = false; reviewCategoryStrategy = null; downloadUrl = null; downloadCommand = null; dateFormat = null; timeFormat = null; relativeDateInChangeTable = false; diffView = null; sizeBarInChangeTable = true; legacycidInChangeTable = false; muteCommonPathPrefixes = true; }
void addOneKey(final com.google.gerrit.client.account.SshKeyInfo k) { final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); final com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); if (k.isValid()) { table.setText(row, 2, ""); fmt.removeStyleName(row, 2, Gerrit.RESOURCES.css().sshKeyPanelInvalid()); } else { table.setText(row, 2, Util.C.sshKeyInvalid()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().sshKeyPanelInvalid()); } table.setText(row, 3, k.algorithm()); com.google.gwtexpui.clippy.client.CopyableLabel keyLabel = new com.google.gwtexpui.clippy.client.CopyableLabel(k.sshPublicKey()); keyLabel.setPreviewText(com.google.gerrit.client.account.SshPanel.elide(k.encodedKey(), 40)); table.setWidget(row, 4, keyLabel); table.setText(row, 5, k.comment()); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().sshKeyPanelEncodedKey()); for (int c = 2; c <= 5; c++) { fmt.addStyleName(row, c, Gerrit.RESOURCES.css().dataCell()); } setRowItem(row, k); }
public void setPreviewText(final java.lang.String text) { if ((textLabel) != null) { textLabel.setText(text); } }
private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); copySelfOnEmails.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); sizeBarInChangeTable.setEnabled(on); legacycidInChangeTable.setEnabled(on); muteCommonPathPrefixes.setEnabled(on); reviewCategoryStrategy.setEnabled(on); diffView.setEnabled(on); }
private void display(com.google.gerrit.client.account.Preferences p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); copySelfOnEmails.setValue(p.copySelfOnEmail()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes()); setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView()); display(p.my()); }

private com.google.gwtexpui.clippy.client.CopyableLabel getCommitLabel(com.google.gerrit.client.changes.ChangeInfo.CommitInfo c) { com.google.gwtexpui.clippy.client.CopyableLabel copyLabel; copyLabel = new com.google.gwtexpui.clippy.client.CopyableLabel(c.commit()); copyLabel.setTitle(c.subject()); copyLabel.setStyleName(style.clippy()); return copyLabel; }
private void renderCommands() { commandTable.removeAllRows(); if ((scheme.getItemCount()) > 0) { com.google.gerrit.client.changes.ChangeInfo.FetchInfo fetchInfo = fetch.get(scheme.getValue(scheme.getSelectedIndex())); for (java.lang.String commandName : com.google.gerrit.client.rpc.Natives.keys(fetchInfo.commands())) { com.google.gwtexpui.clippy.client.CopyableLabel copyLabel = new com.google.gwtexpui.clippy.client.CopyableLabel(fetchInfo.command(commandName)); copyLabel.setStyleName(Gerrit.RESOURCES.css().downloadBoxCopyLabel()); insertCommand(commandName, copyLabel); } } if ((change.revision(revision).commit().parents().length()) == 1) { insertPatch(); } insertArchive(); insertCommand(null, scheme); }
private static native boolean hasFlash();
public static com.google.gerrit.client.account.Preferences create(com.google.gerrit.reviewdb.client.AccountGeneralPreferences in, java.util.List<com.google.gerrit.client.extensions.TopMenuItem> myMenus) { com.google.gerrit.client.account.Preferences p = createObject().cast(); if (in == null) { in = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.createDefault(); } p.changesPerPage(in.getMaximumPageSize()); p.showSiteHeader(in.isShowSiteHeader()); p.useFlashClipboard(in.isUseFlashClipboard()); p.downloadScheme(in.getDownloadUrl()); p.downloadCommand(in.getDownloadCommand()); p.copySelfOnEmail(in.isCopySelfOnEmails()); p.dateFormat(in.getDateFormat()); p.timeFormat(in.getTimeFormat()); p.relativeDateInChangeTable(in.isRelativeDateInChangeTable()); p.sizeBarInChangeTable(in.isSizeBarInChangeTable()); p.legacycidInChangeTable(in.isLegacycidInChangeTable()); p.muteCommonPathPrefixes(in.isMuteCommonPathPrefixes()); p.reviewCategoryStrategy(in.getReviewCategoryStrategy()); p.diffView(in.getDiffView()); p.setMyMenus(myMenus); return p; }
private void setParents(java.lang.String project, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.CommitInfo> commits) { setVisible(firstParent, true); com.google.gwt.dom.client.TableRowElement next = firstParent; com.google.gwt.dom.client.TableRowElement previous = null; for (com.google.gerrit.client.changes.ChangeInfo.CommitInfo c : com.google.gerrit.client.rpc.Natives.asList(commits)) { if (next == (firstParent)) { com.google.gwtexpui.clippy.client.CopyableLabel copyLabel = getCommitLabel(c); parentCommits.add(copyLabel); addLinks(project, c, parentWebLinks); } else { next.appendChild(com.google.gwt.user.client.DOM.createTD()); com.google.gwt.dom.client.Element td1 = com.google.gwt.user.client.DOM.createTD(); td1.appendChild(getCommitLabel(c).getElement()); next.appendChild(td1); com.google.gwt.user.client.ui.FlowPanel linksPanel = new com.google.gwt.user.client.ui.FlowPanel(); linksPanel.addStyleName(style.parentWebLink()); addLinks(project, c, linksPanel); com.google.gwt.dom.client.Element td2 = com.google.gwt.user.client.DOM.createTD(); td2.appendChild(linksPanel.getElement()); next.appendChild(td2); previous.getParentElement().insertAfter(next, previous); } previous = next; next = com.google.gwt.user.client.DOM.createTR().cast(); } }

private java.lang.String replaceInUrl(java.lang.String url, java.lang.String replacement) { if (((replacement == null) || (url == null)) || ((url.contains(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER)) == false)) { return url; } return url.replace(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER, com.google.gerrit.extensions.restapi.Url.encode(replacement)); }
@java.lang.Override public java.lang.String getUrl(com.google.gerrit.server.IdentifiedUser forUser, int imageSize) { if ((externalAvatarUrl) == null) { org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.class); log.warn("Avatar URL is not configured, cannot show avatars. Please configure avatar.url in etc/gerrit.config"); return null; } if (!(externalAvatarUrl.contains(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER))) { org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.class); log.warn((((("Avatar provider url '" + (externalAvatarUrl)) + "' does not contain ") + (com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.REPLACE_MARKER)) + ", so cannot replace it with username")); return null; } if ((ssl) && (externalAvatarUrl.startsWith("http://"))) { externalAvatarUrl = externalAvatarUrl.replace("http://", "https://"); } java.lang.StringBuilder avatarUrl = new java.lang.StringBuilder(); avatarUrl.append(replaceInUrl(externalAvatarUrl, forUser.getUserName())); if ((imageSize > 0) && ((sizeParameter) != null)) { avatarUrl.append("?"); avatarUrl.append(sizeParameter.replaceAll("\\$\\{size\\}", java.lang.Integer.toString(imageSize))); } return avatarUrl.toString(); }

private boolean addSuggestion(java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> map, com.google.gerrit.reviewdb.client.Account.Id id) { if ((!(map.containsKey(id))) && (accountControl.canSee(id))) { map.put(id, accountLoader.get(id)); return true; } return false; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), com.google.gerrit.server.git.ChangeSet.create(resource.getChange())); json.addOptions(java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS)); return json.format(cs.ids()); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { com.google.gerrit.server.change.SubmittedTogether.log.error("Error on getting a ChangeSet", e); throw e; } }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.PatchSet p : object.patchSets()) { if (((p.getRevision()) != null) && ((p.getRevision().get()) != null)) { final org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString(p.getRevision().get()); if ((abbrevId.prefixCompare(id)) == 0) { return true; } } } return false; }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { java.lang.String idStr = id.name(); for (com.google.gerrit.reviewdb.client.PatchSet p : object.patchSets()) { if (((p.getRevision()) != null) && ((p.getRevision().get()) != null)) { if (java.util.Objects.equals(p.getRevision().get(), idStr)) { return true; } } } return false; }
@java.lang.Override public void onPluginLoad() { com.google.gerrit.plugin.client.Plugin.get().screen("", new com.googlesource.gerrit.plugins.cookbook.client.IndexScreen.Factory()); }
@java.lang.Override protected void onLoad() { super.onLoad(); display(com.google.gerrit.client.Gerrit.getUserAccount()); display(); }







@org.junit.Test public void createEmptyChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo in = new com.google.gerrit.extensions.common.ChangeInfo(); in.branch = org.eclipse.jgit.lib.Constants.MASTER; in.subject = "Create a change from the API"; in.project = project.get(); com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().create(in).get(); assertThat(info.project).isEqualTo(in.project); assertThat(info.branch).isEqualTo(in.branch); assertThat(info.subject).isEqualTo(in.subject); }
private java.lang.String problemsForSubmittingChanges(java.util.List<com.google.gerrit.server.query.change.ChangeData> changeList, com.google.gerrit.server.IdentifiedUser identifiedUser) { try { for (com.google.gerrit.server.query.change.ChangeData c : changeList) { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl().forUser(identifiedUser); if (!(changeControl.isVisible(dbProvider.get()))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_TOPIC_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } c.setMergeable(null); java.lang.Boolean mergeable = c.isMergeable(); if (mergeable == null) { com.google.gerrit.server.change.Submit.log.error("Ephemeral error checking if change is submittable"); return com.google.gerrit.server.change.Submit.CLICK_FAILURE_TOOLTIP; } if (!mergeable) { return com.google.gerrit.server.change.Submit.CLICK_FAILURE_OTHER_TOOLTIP; } checkSubmitRule(c, c.currentPatchSet(), false); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_TOPIC_TOOLTIP; } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException("Could not determine problems for the change", e); } return null; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { changeStatus = info.status(); info.revisions().copyKeysIntoChildren("name"); if ((edit) != null) { edit.set_name(edit.commit().commit()); info.set_edit(edit); info.revisions().put(edit.name(), com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.fromEdit(edit)); } int currentPatchSet = info.revision(info.current_revision())._number(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(list); diffTable.set(prefs, list, diff, ((edit) != null), currentPatchSet, changeStatus.isOpen(), diff.binary()); header.setChangeInfo(info); }

@org.junit.Test public void testSubmodulesParseWithSubProjectFound() throws java.lang.Exception { java.util.Map<java.lang.String, com.google.gerrit.server.util.SubmoduleSection> sectionsToReturn = new java.util.TreeMap<>(); sectionsToReturn.put("a/b", new com.google.gerrit.server.util.SubmoduleSection("ssh://localhost/a/b", "a/b", ".")); java.util.Map<java.lang.String, java.lang.String> reposToBeFound = new java.util.HashMap<>(); reposToBeFound.put("a/b", "a/b"); reposToBeFound.put("b", "b"); com.google.gerrit.reviewdb.client.Branch.NameKey superBranchNameKey = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("super-project"), "refs/heads/master"); com.google.gerrit.server.util.List<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expectedSubscriptions = new com.google.gerrit.server.util.ArrayList(); expectedSubscriptions.add(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(superBranchNameKey, new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("a/b"), "refs/heads/master"), "a/b")); execute(superBranchNameKey, sectionsToReturn, reposToBeFound, expectedSubscriptions); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> apply(com.google.gerrit.server.change.RevisionResource rsrc) throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey p = rsrc.getChange().getProject(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(p);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String rev = rsrc.getPatchSet().getRevision().get(); org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(rev)); rw.parseBody(commit); com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommitInfo> r = com.google.gerrit.extensions.restapi.Response.ok(json.toCommit(rsrc.getControl(), rw, commit, addLinks)); if (rsrc.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; } }
private boolean isSubmittable(com.google.gerrit.client.changes.ChangeInfo info) { boolean canSubmit = info.status().isOpen(); if (canSubmit && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { for (java.lang.String name : info.labels()) { com.google.gerrit.client.changes.ChangeInfo.LabelInfo label = info.label(name); switch (label.status()) { case NEED : statusText.setInnerText(("Needs " + name)); canSubmit = false; break; case REJECT : case IMPOSSIBLE : if (label.blocking()) { statusText.setInnerText(("Not " + name)); canSubmit = false; } break; default : break; } } } return canSubmit; }
public static com.google.gerrit.client.account.Preferences create(com.google.gerrit.reviewdb.client.AccountGeneralPreferences in, java.util.List<com.google.gerrit.client.extensions.TopMenuItem> myMenus, java.util.Map<java.lang.String, java.lang.String> urlAliases) { com.google.gerrit.client.account.Preferences p = createObject().cast(); if (in == null) { in = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.createDefault(); } p.changesPerPage(in.getMaximumPageSize()); p.showSiteHeader(in.isShowSiteHeader()); p.useFlashClipboard(in.isUseFlashClipboard()); p.downloadScheme(in.getDownloadUrl()); p.downloadCommand(in.getDownloadCommand()); p.copySelfOnEmail(in.isCopySelfOnEmails()); p.dateFormat(in.getDateFormat()); p.timeFormat(in.getTimeFormat()); p.relativeDateInChangeTable(in.isRelativeDateInChangeTable()); p.sizeBarInChangeTable(in.isSizeBarInChangeTable()); p.legacycidInChangeTable(in.isLegacycidInChangeTable()); p.muteCommonPathPrefixes(in.isMuteCommonPathPrefixes()); p.reviewCategoryStrategy(in.getReviewCategoryStrategy()); p.diffView(in.getDiffView()); p.setMyMenus(myMenus); if (urlAliases != null) { p.setUrlAliases(urlAliases); } return p; }
private static void addMyMenus() { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((com.google.gerrit.client.Gerrit.myMenuItems) != null)) { com.google.gerrit.client.ui.LinkMenuBar myBar = com.google.gerrit.client.Gerrit.menuBars.get(GerritTopMenu.MY.menuName); myBar.clear(); java.lang.String url = null; if (!(com.google.gerrit.client.Gerrit.myMenuItems.isEmpty())) { if (com.google.gerrit.client.Gerrit.myMenuItems.get(0).getUrl().startsWith("#")) { url = com.google.gerrit.client.Gerrit.myMenuItems.get(0).getUrl().substring(1); } for (com.google.gerrit.client.extensions.TopMenuItem item : com.google.gerrit.client.Gerrit.myMenuItems) { com.google.gerrit.client.Gerrit.addExtensionLink(myBar, item); } } com.google.gerrit.client.Gerrit.defaultScreenToken = url; } }
static void deleteSessionCookie() { com.google.gerrit.client.Gerrit.myAccount = null; com.google.gerrit.client.Gerrit.myAccountDiffPref = null; com.google.gerrit.client.Gerrit.xGerritAuth = null; com.google.gerrit.client.Gerrit.refreshMenuBar(); com.google.gwt.user.client.Cookies.removeCookie("GerritAccount"); }
@java.lang.Override public void onSuccess(final com.google.gerrit.common.data.HostPageData result) { com.google.gwt.dom.client.Document.get().getElementById("gerrit_hostpagedata").removeFromParent(); com.google.gerrit.client.Gerrit.myTheme = result.theme; com.google.gerrit.client.Gerrit.isNoteDbEnabled = result.isNoteDbEnabled; if ((result.account) != null) { com.google.gerrit.client.Gerrit.myAccount = result.account; com.google.gerrit.client.Gerrit.xGerritAuth = result.xGerritAuth; } if ((result.accountDiffPref) != null) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref; com.google.gerrit.client.Gerrit.applyUserPreferences(); } onModuleLoad2(result); }
private static com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountPreferencesInfo> createMyMenuBarCallback() { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountPreferencesInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountPreferencesInfo prefs) { com.google.gerrit.client.ui.LinkMenuBar myBar = com.google.gerrit.client.Gerrit.menuBars.get(GerritTopMenu.MY.menuName); myBar.clear(); java.util.List<com.google.gerrit.client.info.TopMenuItem> myMenuItems = com.google.gerrit.client.rpc.Natives.asList(prefs.my()); java.lang.String url = null; if (!(myMenuItems.isEmpty())) { if (myMenuItems.get(0).getUrl().startsWith("#")) { url = myMenuItems.get(0).getUrl().substring(1); } for (com.google.gerrit.client.info.TopMenuItem item : myMenuItems) { com.google.gerrit.client.Gerrit.addExtensionLink(myBar, item); } } com.google.gerrit.client.Gerrit.defaultScreenToken = url; } }; }
public static com.google.gerrit.client.info.AccountPreferencesInfo create(com.google.gerrit.reviewdb.client.AccountGeneralPreferences in, java.util.List<com.google.gerrit.client.info.TopMenuItem> myMenus) { com.google.gerrit.client.info.AccountPreferencesInfo p = createObject().cast(); if (in == null) { in = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.createDefault(); } p.changesPerPage(in.getMaximumPageSize()); p.showSiteHeader(in.isShowSiteHeader()); p.useFlashClipboard(in.isUseFlashClipboard()); p.downloadScheme(in.getDownloadUrl()); p.downloadCommand(in.getDownloadCommand()); p.copySelfOnEmail(in.isCopySelfOnEmails()); p.dateFormat(in.getDateFormat()); p.timeFormat(in.getTimeFormat()); p.relativeDateInChangeTable(in.isRelativeDateInChangeTable()); p.sizeBarInChangeTable(in.isSizeBarInChangeTable()); p.legacycidInChangeTable(in.isLegacycidInChangeTable()); p.muteCommonPathPrefixes(in.isMuteCommonPathPrefixes()); p.reviewCategoryStrategy(in.getReviewCategoryStrategy()); p.diffView(in.getDiffView()); p.setMyMenus(myMenus); return p; }
public final short changesPerPage() { return get("changes_per_page", AccountGeneralPreferences.DEFAULT_PAGESIZE); }




@java.lang.Override public com.google.gerrit.server.config.GetServerInfo.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.server.config.GetServerInfo.ServerInfo info = new com.google.gerrit.server.config.GetServerInfo.ServerInfo(); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.contactStore = getContactStoreInfo(); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.gitweb = getGitwebInfo(gitwebConfig); info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(config); return info; }
@org.junit.Test public void testFormatWeeks() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(14, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "2 weeks ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(69, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "10 weeks ago"); }
@org.junit.Test public void testFormatMonths() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(70, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "2 months ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(75, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "3 months ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(364, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "12 months ago"); }
@org.junit.Test public void testFormatDays() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(36, com.google.gerrit.client.RelativeDateFormatter.HOUR_IN_MILLIS, "2 days ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(13, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "13 days ago"); }
@org.junit.Test public void testFuture() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat((-100), com.google.gerrit.client.RelativeDateFormatter.YEAR_IN_MILLIS, "in the future"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat((-1), com.google.gerrit.client.RelativeDateFormatter.SECOND_IN_MILLIS, "in the future"); }
@org.junit.Test public void testFormatYearsMonths() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(366, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "1 year ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(380, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "1 year, 1 month ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(410, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "1 year, 2 months ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(2, com.google.gerrit.client.RelativeDateFormatter.YEAR_IN_MILLIS, "2 years ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(1824, com.google.gerrit.client.RelativeDateFormatter.DAY_IN_MILLIS, "4 years, 12 months ago"); }
@org.junit.Test public void testFormatSeconds() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(1, com.google.gerrit.client.RelativeDateFormatter.SECOND_IN_MILLIS, "1 seconds ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(89, com.google.gerrit.client.RelativeDateFormatter.SECOND_IN_MILLIS, "89 seconds ago"); }
@org.junit.Test public void testFormatYears() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(5, com.google.gerrit.client.RelativeDateFormatter.YEAR_IN_MILLIS, "5 years ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(60, com.google.gerrit.client.RelativeDateFormatter.YEAR_IN_MILLIS, "60 years ago"); }
@org.junit.Test public void testFormatHours() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(90, com.google.gerrit.client.RelativeDateFormatter.MINUTE_IN_MILLIS, "2 hours ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(149, com.google.gerrit.client.RelativeDateFormatter.MINUTE_IN_MILLIS, "2 hours ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(35, com.google.gerrit.client.RelativeDateFormatter.HOUR_IN_MILLIS, "35 hours ago"); }
@org.junit.Test public void testFormatMinutes() { com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(90, com.google.gerrit.client.RelativeDateFormatter.SECOND_IN_MILLIS, "2 minutes ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(3, com.google.gerrit.client.RelativeDateFormatter.MINUTE_IN_MILLIS, "3 minutes ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(60, com.google.gerrit.client.RelativeDateFormatter.MINUTE_IN_MILLIS, "60 minutes ago"); com.google.gerrit.client.RelativeDateFormatterTest.assertFormat(89, com.google.gerrit.client.RelativeDateFormatter.MINUTE_IN_MILLIS, "89 minutes ago"); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeInfo info) { changeStatus = info.status(); info.revisions().copyKeysIntoChildren("name"); if ((edit) != null) { edit.setName(edit.commit().commit()); info.setEdit(edit); info.revisions().put(edit.name(), com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.fromEdit(edit)); } HEAD((ec436a = "Fix updating of username from AccountManager")); int currentPatchSet = info.revision(info.currentRevision())._number(); java.lang.String currentRevision = info.current_revision(); boolean current = (currentRevision != null) && ((revision.get()) == (info.revision(currentRevision)._number())); BRANCH(4); com.google.gerrit.client.diff.bc067 Show; com.google.gerrit.client.diff.change status; draft(sets); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.ChangeInfo.RevisionInfo> list = info.revisions().values(); com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(list); diffTable.set(prefs, list, diff, ((edit) != null), current, changeStatus.isOpen(), diff.binary()); header.setChangeInfo(info); }
HEAD(com.google.gerrit.client.diff.ec436a Merge) { }
private boolean isSubmittable(com.google.gerrit.client.changes.ChangeInfo info) { boolean canSubmit = ((info.status().isOpen()) && (revision.equals(info.current_revision()))) && (!(info.revision(revision).draft())); if (canSubmit && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { for (java.lang.String name : info.labels()) { com.google.gerrit.client.changes.ChangeInfo.LabelInfo label = info.label(name); switch (label.status()) { case NEED : statusText.setInnerText(("Needs " + name)); canSubmit = false; break; case REJECT : case IMPOSSIBLE : if (label.blocking()) { statusText.setInnerText(("Not " + name)); canSubmit = false; } break; default : break; } } } return canSubmit; }






private void initCompression() { setCompressionFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Compression>>asList(new org.apache.sshd.common.compression.CompressionNone.Factory())); }
private void deleteGitRepository(final com.google.gerrit.reviewdb.client.Project.NameKey project, final org.eclipse.jgit.lib.Repository repository) throws java.io.IOException { java.io.File parentFile = repository.getDirectory().getParentFile(); java.nio.file.Path trash = moveToTrash(repository.getDirectory().toPath(), project); try { recursiveDelete(trash); } catch (java.io.IOException e) { throw new java.io.IOException(("Error trying to delete " + trash), e); } recursiveDeleteParent(parentFile, gitDir); com.google.gerrit.extensions.events.ProjectDeletedListener.Event event = new com.google.gerrit.extensions.events.ProjectDeletedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return project.get(); } }; for (com.google.gerrit.extensions.events.ProjectDeletedListener l : deletedListener) { try { l.onProjectDeleted(event); } catch (java.lang.RuntimeException e) { com.googlesource.gerrit.plugins.deleteproject.fs.FilesystemDeleteHandler.log.warn("Failure in ProjectDeletedListener", e); } } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException { who = realm.authenticate(who); try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); final com.google.gerrit.reviewdb.client.AccountExternalId id = db.accountExternalIds().get(key); if (id == null) { return create(db, who); } else { com.google.gerrit.reviewdb.client.Account act = db.accounts().get(id.getAccountId()); if ((act == null) || (!(act.isActive()))) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.getAccountId(), key, false); } } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }


private void doSetUserName() { if (!(canEditUserName())) { return; } enableUI(false); java.lang.String newName = userNameTxt.getText(); if ("".equals(newName)) { newName = null; } final java.lang.String newUserName = newName; Util.ACCOUNT_SEC.changeUserName(newUserName, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.getUserAccount().setUserName(newUserName); userNameLbl.setText(newUserName); userNameLbl.setVisible(true); userNameTxt.setVisible(false); setUserName.setVisible(false); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { enableUI(true); if (caught instanceof com.google.gerrit.common.errors.InvalidUserNameException) { new com.google.gerrit.client.ErrorDialog(Util.C.invalidUserName()).center(); } else { super.onFailure(caught); } } }); }

@java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.getUserAccount().setUserName(newUserName); userNameLbl.setText(newUserName); userNameLbl.setVisible(true); userNameTxt.setVisible(false); setUserName.setVisible(false); }


@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SEC.validateEmail(magicToken, new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gwtjsonrpc.common.VoidResult>(this) { @java.lang.Override protected void preDisplay(final com.google.gwtjsonrpc.common.VoidResult result) { } @java.lang.Override protected void postDisplay() { com.google.gerrit.client.Gerrit.display(PageLinks.SETTINGS_CONTACT); } }); }



public static com.google.gerrit.client.account.Preferences create(com.google.gerrit.reviewdb.client.AccountGeneralPreferences in, java.util.List<com.google.gerrit.client.extensions.TopMenuItem> myMenus) { com.google.gerrit.client.account.Preferences p = createObject().cast(); if (in == null) { in = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.createDefault(); } p.changesPerPage(in.getMaximumPageSize()); p.showSiteHeader(in.isShowSiteHeader()); p.useFlashClipboard(in.isUseFlashClipboard()); p.downloadScheme(in.getDownloadUrl()); p.downloadCommand(in.getDownloadCommand()); p.copySelfOnEmail(in.isCopySelfOnEmails()); p.dateFormat(in.getDateFormat()); p.timeFormat(in.getTimeFormat()); p.relativeDateInChangeTable(in.isRelativeDateInChangeTable()); p.sizeBarInChangeTable(in.isSizeBarInChangeTable()); p.legacycidInChangeTable(in.isLegacycidInChangeTable()); p.muteCommonPathPrefixes(in.isMuteCommonPathPrefixes()); p.reviewCategoryStrategy(in.getReviewCategoryStrategy()); p.diffView(in.getDiffView()); p.setMyMenus(myMenus); return p; }



@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(git); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, git); } }






@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.account.SetPreferences.Input i) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((((((((((((((i.changesPerPage) != null) || ((i.showSiteHeader) != null)) || ((i.useFlashClipboard) != null)) || ((i.downloadScheme) != null)) || ((i.downloadCommand) != null)) || ((i.copySelfOnEmail) != null)) || ((i.dateFormat) != null)) || ((i.timeFormat) != null)) || ((i.relativeDateInChangeTable) != null)) || ((i.sizeBarInChangeTable) != null)) || ((i.legacycidInChangeTable) != null)) || ((i.muteCommonPathPrefixes) != null)) || ((i.reviewCategoryStrategy) != null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported option"); } com.google.gerrit.server.account.VersionedAccountPreferences p; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName); try { p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); p.commit(md); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, md.getRepository()); } finally { md.close(); } }
@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account a = db.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId()); p.load(git); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(a.getGeneralPreferences(), p, git); } }




private void submit(java.lang.String changeId, int expectedStatus) throws java.lang.Exception { approve(changeId); com.google.gerrit.extensions.api.changes.SubmitInput subm = new com.google.gerrit.extensions.api.changes.SubmitInput(); com.google.gerrit.acceptance.RestResponse r = adminSession.post((("/changes/" + changeId) + "/submit"), subm); assertThat(r.getStatusCode()).isEqualTo(expectedStatus); if (expectedStatus == (org.apache.http.HttpStatus.SC_OK)) { com.google.gerrit.extensions.common.ChangeInfo change = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.extensions.common.ChangeInfo>() {}.getType()); assertThat(change.status).isEqualTo(ChangeStatus.MERGED); checkMergeResult(change); } r.consume(); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content"); submitWithConflict(change2.getChangeId()); assertThat(getRemoteHead()).isEqualTo(oldHead); }
@org.junit.Test public void submitOutOfOrder_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); createChange("Change 2", "b.txt", "other content"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content"); submitWithConflict(change3.getChangeId()); assertThat(getRemoteHead()).isEqualTo(oldHead); assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId()); assertNoSubmitter(change3.getChangeId(), 1); }
@org.junit.Test public void submitDependentConflictingChangesOutOfOrder() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b1"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "b", "b2"); assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit()); submitWithConflict(change3.getChangeId()); com.google.gerrit.extensions.common.ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES); assertThat(info3.status).isEqualTo(ChangeStatus.NEW); assertThat(com.google.common.collect.Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict"); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); assertThat(log.get(0)).isEqualTo(initialHead.getId()); assertNoSubmitter(change3.getChangeId(), 1); }
@org.junit.Test public void submitTwoChangesWithFastForward_missingDependency() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); submitWithConflict(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(oldHead.getId()); }
@org.junit.Test public void submitFastForwardNotPossible_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); approve(change2.getChangeId()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> actions = getActions(change2.getChangeId()); assertThat(actions).containsKey("submit"); com.google.gerrit.extensions.common.ActionInfo info = actions.get("submit"); assertThat(info.enabled).isNull(); submitWithConflict(change2.getChangeId()); assertThat(getRemoteHead()).isEqualTo(oldHead); assertSubmitter(change.getChangeId(), 1); }
protected void submitWithConflict(java.lang.String changeId) throws java.lang.Exception { submit(changeId, HttpStatus.SC_CONFLICT); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content"); submitWithConflict(change2.getChangeId()); assertThat(getRemoteHead()).isEqualTo(oldHead); assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId()); assertNoSubmitter(change2.getChangeId(), 1); }
public void prepareETag(com.google.common.hash.Hasher h, com.google.gerrit.server.CurrentUser user) { h.putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt((user.isIdentifiedUser() ? ((com.google.gerrit.server.IdentifiedUser) (user)).getAccountId().get() : 0)); byte[] buf = new byte[20]; org.eclipse.jgit.lib.ObjectId noteId; try { noteId = getNotes().loadRevision(); } catch (com.google.gwtorm.server.OrmException e) { noteId = null; } hashObjectId(h, noteId, buf); for (com.google.gerrit.server.project.ProjectState p : control.getProjectControl().getProjectState().tree()) { hashObjectId(h, p.getConfig().getRevision(), buf); } }
private static long keyId(byte[] fp) { return java.nio.ByteBuffer.wrap(fp).getLong(((fp.length) - 8)); }












@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> putGpgKeys(java.util.List<java.lang.String> add) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.PostGpgKeys.Input in = new com.google.gerrit.server.account.PostGpgKeys.Input(); in.add = add; try { return postGpgKeys.apply(account, in); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add GPG key", e); } }
@org.junit.Test public void addOtherUsersGpgKey() throws java.lang.Exception { addExternalIdEmail(admin, "test5@example.com"); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key("foo:myId")); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); com.google.gerrit.server.git.gpg.TestKey key = com.google.gerrit.server.git.gpg.TestKey.key5(); java.lang.String id = keyIdToString(key.getKeyId()); gApi.accounts().self().putGpgKeys(com.google.common.collect.ImmutableList.of(key.getPublicKeyArmored())).get(id); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("GPG key already associated with another account"); gApi.accounts().self().putGpgKeys(com.google.common.collect.ImmutableList.of(key.getPublicKeyArmored())).get(id); }
private java.util.List<org.bouncycastle.openpgp.PGPPublicKeyRing> readKeys(com.google.gerrit.server.account.PostGpgKeys.Input input) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException { if (((input.add) == null) || (input.add.isEmpty())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<org.bouncycastle.openpgp.PGPPublicKeyRing> keyRings = new java.util.ArrayList<>(input.add.size()); for (java.lang.String armored : input.add) { try (java.io.InputStream in = new java.io.ByteArrayInputStream(armored.getBytes(java.nio.charset.StandardCharsets.UTF_8));org.bouncycastle.bcpg.ArmoredInputStream ain = new org.bouncycastle.bcpg.ArmoredInputStream(in)) { @java.lang.SuppressWarnings("unchecked") java.util.List<java.lang.Object> objs = com.google.common.collect.Lists.newArrayList(new org.bouncycastle.openpgp.bc.BcPGPObjectFactory(ain)); if (((objs.size()) != 1) || (!((objs.get(0)) instanceof org.bouncycastle.openpgp.PGPPublicKeyRing))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Expected exactly one PUBLIC KEY BLOCK"); } keyRings.add(((org.bouncycastle.openpgp.PGPPublicKeyRing) (objs.get(0)))); } } return keyRings; }


@java.lang.Override public com.google.gerrit.server.account.AccountResource.GpgKey parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { com.google.gerrit.server.account.GpgKeys.checkEnabled(); java.lang.String str = CharMatcher.WHITESPACE.removeFrom(id.get()).toUpperCase(); if ((((str.length()) != 8) && ((str.length()) != 40)) || (!(com.google.common.base.CharMatcher.anyOf("0123456789ABCDEF").matchesAllOf(str)))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } byte[] fp = null; for (com.google.gerrit.reviewdb.client.AccountExternalId extId : getGpgExtIds(parent)) { java.lang.String fpStr = extId.getSchemeRest(); if (!(fpStr.endsWith(str))) { continue; } else if (fp != null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple keys found for " + id)); } fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); } if (fp == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (com.google.gerrit.server.git.gpg.PublicKeyStore store = storeProvider.get()) { long keyId = java.nio.ByteBuffer.wrap(fp).getLong(((fp.length) - 8)); for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(keyId)) { org.bouncycastle.openpgp.PGPPublicKey key = keyRing.getPublicKey(); if (java.util.Arrays.equals(key.getFingerprint(), fp)) { return new com.google.gerrit.server.account.AccountResource.GpgKey(parent.getUser(), keyRing); } } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }


@org.junit.After public void tearDown() throws java.lang.Exception { db.accountExternalIds().delete(com.google.gerrit.server.account.GpgKeys.getGpgExtIds(db, admin.getId())); db.accountExternalIds().delete(com.google.gerrit.server.account.GpgKeys.getGpgExtIds(db, user.getId())); }






















@java.lang.Override protected void configure() { if (com.google.gerrit.server.util.BouncyCastleUtil.havePGP()) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.ReceivePackInitializer.class).to(com.google.gerrit.server.git.gpg.SignedPushModule.Initializer.class); } else { com.google.gerrit.server.git.gpg.SignedPushModule.log.info(("BouncyCastle PGP not installed; signed push verification is" + " disabled")); } }


private void load() throws java.io.IOException { close(); reader = repo.newObjectReader(); org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(RefNames.REFS_GPG_KEYS); if (ref == null) { return; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { notes = org.eclipse.jgit.notes.NoteMap.read(reader, rw.parseCommit(ref.getObjectId())); } }


@java.lang.Override public void setValue(com.google.gerrit.common.data.ProjectAccess value) { if (((editing) && (value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES))) && ((value.getLocal(AccessSection.GLOBAL_CAPABILITIES)) == null)) { value.getLocal().add(0, new com.google.gerrit.common.data.AccessSection(com.google.gerrit.common.data.AccessSection.GLOBAL_CAPABILITIES)); } this.value = value; com.google.gerrit.reviewdb.client.Project.NameKey parent = value.getInheritsFrom(); if (parent != null) { inheritsFrom.getStyle().setDisplay(Display.BLOCK); parentProject.setText(parent.get()); parentProject.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS)); parentProjectBox.setVisible(editing); parentProjectBox.setProject(value.getProjectName()); parentProjectBox.setParentProject(value.getInheritsFrom()); parentProject.setVisible((!(parentProjectBox.isVisible()))); } else { inheritsFrom.getStyle().setDisplay(Display.NONE); } com.google.gerrit.client.config.GitWebInfo c = com.google.gerrit.client.Gerrit.info().gitWeb(); if ((value.isConfigVisible()) && (c != null)) { history.getStyle().setDisplay(Display.BLOCK); gitweb.setText(c.getLinkName()); gitweb.setHref(c.toFileHistory(new com.google.gerrit.reviewdb.client.Branch.NameKey(value.getProjectName(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), "project.config")); } else { history.getStyle().setDisplay(Display.NONE); } addSection.setVisible(((editing) && ((!(value.getOwnerOf().isEmpty())) || (value.canUpload())))); }








private com.google.gerrit.extensions.auth.oauth.OAuthUserInfo getAsOAuthUserInfo(com.googlesource.gerrit.plugins.cfoauth.AccessToken accessToken) { return new com.google.gerrit.extensions.auth.oauth.OAuthUserInfo(accessToken.getExternalId(), accessToken.getUserName(), accessToken.getEmailAddress(), null, null); }
@org.junit.Test public void testChildrenUnmodifiable() { final com.google.gerrit.server.query.AndPredicateTest.TestPredicate a = com.google.gerrit.server.query.AndPredicateTest.f("author", "alice"); final com.google.gerrit.server.query.AndPredicateTest.TestPredicate b = com.google.gerrit.server.query.AndPredicateTest.f("author", "bob"); final com.google.gerrit.server.query.Predicate<java.lang.String> n = com.google.gerrit.server.query.Predicate.and(a, b); try { n.getChildren().clear(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.AndPredicateTest.assertChildren("clear", n, of(a, b)); try { n.getChildren().remove(0); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.AndPredicateTest.assertChildren("remove(0)", n, of(a, b)); try { n.getChildren().iterator().remove(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.AndPredicateTest.assertChildren("remove(0)", n, of(a, b)); }
@org.junit.Test public void testChildrenUnmodifiable() { final com.google.gerrit.server.query.NotPredicateTest.TestPredicate p = com.google.gerrit.server.query.NotPredicateTest.f("author", "bob"); final com.google.gerrit.server.query.Predicate<java.lang.String> n = com.google.gerrit.server.query.Predicate.not(p); try { n.getChildren().clear(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.NotPredicateTest.assertOnlyChild("clear", p, n); try { n.getChildren().remove(0); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.NotPredicateTest.assertOnlyChild("remove(0)", p, n); try { n.getChildren().iterator().remove(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.NotPredicateTest.assertOnlyChild("remove(0)", p, n); }
@org.junit.Test public void testChildrenUnmodifiable() { final com.google.gerrit.server.query.OrPredicateTest.TestPredicate a = com.google.gerrit.server.query.OrPredicateTest.f("author", "alice"); final com.google.gerrit.server.query.OrPredicateTest.TestPredicate b = com.google.gerrit.server.query.OrPredicateTest.f("author", "bob"); final com.google.gerrit.server.query.Predicate<java.lang.String> n = com.google.gerrit.server.query.Predicate.or(a, b); try { n.getChildren().clear(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.OrPredicateTest.assertChildren("clear", n, of(a, b)); try { n.getChildren().remove(0); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.OrPredicateTest.assertChildren("remove(0)", n, of(a, b)); try { n.getChildren().iterator().remove(); } catch (java.lang.RuntimeException e) { } com.google.gerrit.server.query.OrPredicateTest.assertChildren("remove(0)", n, of(a, b)); }



Account.Id resolveUser(com.googlesource.gerrit.plugins.importer.GerritApi api, com.google.gerrit.extensions.common.AccountInfo acc) throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((acc.username) == null) { throw new com.google.gerrit.common.errors.NoSuchAccountException(java.lang.String.format("User %s <%s> (%s) doesn't have a username and cannot be looked up.", acc.name, acc.email, acc._accountId)); } com.google.gerrit.server.account.AccountState a = accountCache.getByUsername(acc.username); if (a == null) { switch (authType) { case HTTP_LDAP : case CLIENT_SSL_CERT_LDAP : case LDAP : return createAccountByLdapAndAddSshKeys(api, acc); default : throw new com.google.gerrit.common.errors.NoSuchAccountException(java.lang.String.format("User %s not found", acc.username)); } } if (!(java.util.Objects.equals(a.getAccount().getPreferredEmail(), acc.email))) { com.googlesource.gerrit.plugins.importer.AccountUtil.log.warn(java.lang.String.format("Email mismatch for user %s: expected %s but found %s", acc.username, acc.email, a.getAccount().getPreferredEmail())); } return a.getAccount().getId(); }
@java.lang.Override public void run() { final com.google.gerrit.reviewdb.server.ReviewDb db; try { db = database.open(); } catch (com.google.gwtorm.server.OrmException e) { e.printStackTrace(); return; } try { for (; ;) { final com.google.gerrit.reviewdb.client.AccountExternalId extId = next(); if (extId == null) { break; } convertLocalUserToLowerCase(db, extId); synchronized(monitor) { monitor.update(1); } } } finally { db.close(); } }
private java.lang.String problemsForSubmittingChangeset(com.google.gerrit.server.git.ChangeSet cs, com.google.gerrit.server.IdentifiedUser identifiedUser) { try { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); for (com.google.gerrit.reviewdb.client.PatchSet.Id psId : cs.patchIds()) { com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.controlFor(psId.getParentKey(), identifiedUser); com.google.gerrit.server.query.change.ChangeData c = changeDataFactory.create(db, changeControl); if (!(changeControl.isVisible(db))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_SUBMIT_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; } c.setMergeable(null); java.lang.Boolean mergeable = c.isMergeable(); if (mergeable == null) { com.google.gerrit.server.change.Submit.log.error("Ephemeral error checking if change is submittable"); return com.google.gerrit.server.change.Submit.CLICK_FAILURE_TOOLTIP; } if (!mergeable) { return com.google.gerrit.server.change.Submit.CLICK_FAILURE_OTHER_TOOLTIP; } com.google.gerrit.server.git.MergeOp.checkSubmitRule(c); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; } catch (com.google.gerrit.server.project.NoSuchChangeException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException("Could not determine problems for the change", e); } return null; }
private void createReviewNotes(com.googlesource.gerrit.plugins.reviewnotes.Event e) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = new com.google.gerrit.reviewdb.client.Project.NameKey(e.getProjectName()); org.eclipse.jgit.lib.Repository git; try { git = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } catch (java.io.IOException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } com.google.gerrit.reviewdb.server.ReviewDb reviewDb; try { try { reviewDb = schema.open(); } catch (com.google.gwtorm.server.OrmException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } try { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes crn = reviewNotesFactory.create(reviewDb, projectName, git); if (e.getRefName().startsWith("refs/heads/")) { crn.createNotes(e.getRefName(), org.eclipse.jgit.lib.ObjectId.fromString(e.getOldObjectId()), org.eclipse.jgit.lib.ObjectId.fromString(e.getNewObjectId()), null); crn.commitNotes(); } } catch (com.google.gwtorm.server.OrmException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); } catch (java.io.IOException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); } catch (org.eclipse.jgit.api.errors.ConcurrentRefUpdateException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); } finally { reviewDb.close(); } } finally { git.close(); } }
@java.lang.Override public void run() { com.google.gerrit.reviewdb.server.ReviewDb db; try { db = database.open(); } catch (com.google.gwtorm.server.OrmException e) { stderr.println(e.getMessage()); return; } try { for (; ;) { java.util.Map.Entry<com.google.gerrit.reviewdb.client.Project.NameKey, java.util.List<com.google.gerrit.reviewdb.client.Change>> next = next(); if (next != null) { try { export(db, next.getKey(), next.getValue()); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { stderr.println(e.getMessage()); } } else { break; } } } finally { monitor.endWorker(); db.close(); } }
private void export(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.List<com.google.gerrit.reviewdb.client.Change> changes) throws com.google.gwtorm.server.OrmException, java.io.IOException { final org.eclipse.jgit.lib.Repository git; try { git = gitManager.openRepository(project); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { stderr.println(("Unable to open project: " + (project.get()))); return; } try { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes crn = reviewNotesFactory.create(db, project, git); crn.createNotes(changes, monitor); crn.commitNotes(); } catch (org.eclipse.jgit.api.errors.ConcurrentRefUpdateException e) { stderr.println(e.getMessage()); } finally { git.close(); } }
private void createReviewNotes(com.googlesource.gerrit.plugins.reviewnotes.Event e) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = new com.google.gerrit.reviewdb.client.Project.NameKey(e.getProjectName()); org.eclipse.jgit.lib.Repository git; try { git = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } catch (java.io.IOException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } try (com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schema.open()) { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes crn = reviewNotesFactory.create(reviewDb, projectName, git); if (e.getRefName().startsWith("refs/heads/")) { crn.createNotes(e.getRefName(), org.eclipse.jgit.lib.ObjectId.fromString(e.getOldObjectId()), org.eclipse.jgit.lib.ObjectId.fromString(e.getNewObjectId()), null); crn.commitNotes(); } } catch (com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.api.errors.ConcurrentRefUpdateException x) { com.googlesource.gerrit.plugins.reviewnotes.RefUpdateListener.log.error(x.getMessage(), x); return; } finally { git.close(); } }
@java.lang.Override protected void configure() { if (!(com.google.gerrit.server.util.BouncyCastleUtil.havePGP())) { com.google.gerrit.server.git.gpg.SignedPushModule.log.info(("BouncyCastle PGP not installed; signed push verification is" + " disabled")); return; } bind(com.google.gerrit.server.git.gpg.PublicKeyChecker.class).to(com.google.gerrit.server.git.gpg.GerritPublicKeyChecker.class); bind(com.google.gerrit.server.git.gpg.PublicKeyStore.class).toProvider(com.google.gerrit.server.git.gpg.SignedPushModule.StoreProvider.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.ReceivePackInitializer.class).to(com.google.gerrit.server.git.gpg.SignedPushModule.Initializer.class); }

@java.lang.Override protected void configure() { bind(com.google.gerrit.server.config.SitePaths.class); bind(com.google.gerrit.pgm.init.api.InitFlags.class); bind(com.google.gerrit.pgm.init.Libraries.class); bind(com.google.gerrit.pgm.init.LibraryDownloader.class); factory(Section.Factory.class); step().to(com.google.gerrit.pgm.init.UpgradeFrom2_0_x.class); step().to(com.google.gerrit.pgm.init.InitGitManager.class); if (initDb) { step().to(com.google.gerrit.pgm.init.InitDatabase.class); } step().to(com.google.gerrit.pgm.init.InitIndex.class); step().to(com.google.gerrit.pgm.init.InitAuth.class); step().to(com.google.gerrit.pgm.init.InitAdminUser.class); step().to(com.google.gerrit.pgm.init.InitLabels.class); step().to(com.google.gerrit.pgm.init.InitSendEmail.class); if (standalone) { step().to(com.google.gerrit.pgm.init.InitContainer.class); } step().to(com.google.gerrit.pgm.init.InitSshd.class); step().to(com.google.gerrit.pgm.init.InitHttpd.class); step().to(com.google.gerrit.pgm.init.InitCache.class); step().to(com.google.gerrit.pgm.init.InitPlugins.class); }


public java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> listRepositories(java.util.Set<java.lang.String> branches) throws java.io.IOException, org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException, org.eclipse.jgit.transport.resolver.ServiceNotEnabledException;
@java.lang.Override protected void doGetHtml(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> descs = getDescriptions(req, res); if (descs == null) { return; } com.google.template.soy.data.SoyListData repos = new com.google.template.soy.data.SoyListData(); for (com.google.gitiles.RepositoryDescription desc : descs.values()) { repos.add(toSoyMapData(desc, com.google.gitiles.ViewFilter.getView(req))); } renderHtml(req, res, "gitiles.hostIndex", com.google.common.collect.ImmutableMap.of("hostName", urls.getHostName(req), "baseUrl", urls.getBaseGitUrl(req), "repositories", repos)); }
private GitilesView.Builder parseNoCommand(java.lang.String repoName) { return com.google.gitiles.GitilesView.repositoryIndex().setRepositoryName(repoName); }
@java.lang.Override public synchronized void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException { super.init(config); setDefaultFields(config); for (com.google.gitiles.GitilesView.Type type : GitilesView.Type.values()) { if (!(servlets.containsKey(type))) { servlets.put(type, getDefaultHandler(type)); } } javax.servlet.Filter repositoryFilter = new org.eclipse.jgit.http.server.RepositoryFilter(resolver); javax.servlet.Filter viewFilter = new com.google.gitiles.ViewFilter(accessFactory, urls, visibilityCache); javax.servlet.Filter dispatchFilter = new com.google.gitiles.GitilesFilter.DispatchFilter(filters, servlets); org.eclipse.jgit.http.server.glue.ServletBinder root = serveRegex(com.google.gitiles.GitilesFilter.ROOT_REGEX).through(viewFilter); if ((gitwebRedirect) != null) { root.through(gitwebRedirect); } root.through(dispatchFilter); serveRegex(com.google.gitiles.GitilesFilter.REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter); serveRegex(com.google.gitiles.GitilesFilter.REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter); initialized = true; }
public com.google.gitiles.GitilesView.Builder setRepositoryName(java.lang.String repositoryName) { switch (type) { case HOST_INDEX : throw new java.lang.IllegalStateException(java.lang.String.format("cannot set repository name on %s view", type)); default : this.repositoryName = checkNotNull(repositoryName); return this; } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> listRepositories(java.util.Set<java.lang.String> branches) { if ((branches != null) && (!(branches.isEmpty()))) { throw new java.lang.UnsupportedOperationException("branches set not yet supported"); } com.google.gitiles.RepositoryDescription desc = new com.google.gitiles.RepositoryDescription(); desc.name = repo.getDescription().getRepositoryName(); desc.cloneUrl = ((TestGitilesUrls.URLS.getBaseGitUrl(req)) + "/") + (desc.name); return com.google.common.collect.ImmutableMap.of(desc.name, desc); }

private java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> getDescriptions(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, java.util.Set<java.lang.String> branches) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> descs; try { descs = getAccess(req).listRepositories(branches); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { res.sendError(com.google.gitiles.SC_NOT_FOUND); return null; } catch (org.eclipse.jgit.transport.resolver.ServiceNotEnabledException e) { res.sendError(com.google.gitiles.SC_FORBIDDEN); return null; } catch (org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException e) { res.sendError(com.google.gitiles.SC_UNAUTHORIZED); return null; } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { res.sendError(com.google.gitiles.SC_FORBIDDEN); return null; } catch (java.io.IOException err) { java.lang.String name = urls.getHostName(req); com.google.gitiles.HostIndexServlet.log.warn(("Cannot scan repositories" + (name != null ? " for " + name : "")), err); res.sendError(com.google.gitiles.SC_SERVICE_UNAVAILABLE); return null; } return descs; }
@java.lang.Override public com.google.gitiles.GitilesAccess forRequest(final javax.servlet.http.HttpServletRequest req) { return new com.google.gitiles.GitilesAccess() { @java.lang.Override public java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> listRepositories(java.util.Set<java.lang.String> branches) { if ((branches != null) && (!(branches.isEmpty()))) { throw new java.lang.UnsupportedOperationException("branches set not yet supported"); } com.google.gitiles.RepositoryDescription desc = new com.google.gitiles.RepositoryDescription(); desc.name = repo.getDescription().getRepositoryName(); desc.cloneUrl = ((TestGitilesUrls.URLS.getBaseGitUrl(req)) + "/") + (desc.name); return com.google.common.collect.ImmutableMap.of(desc.name, desc); } @java.lang.Override public java.lang.Object getUserKey() { return "a user"; } @java.lang.Override public java.lang.String getRepositoryName() { return repo.getDescription().getRepositoryName(); } @java.lang.Override public com.google.gitiles.RepositoryDescription getRepositoryDescription() { com.google.gitiles.RepositoryDescription d = new com.google.gitiles.RepositoryDescription(); d.name = getRepositoryName(); d.description = "a test data set"; d.cloneUrl = ((TestGitilesUrls.URLS.getBaseGitUrl(req)) + "/") + (d.name); return d; } @java.lang.Override public org.eclipse.jgit.lib.Config getConfig() { return new org.eclipse.jgit.lib.Config(); } }; }
@java.lang.Override protected void doGetText(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.util.Set<java.lang.String> branches = com.google.gitiles.HostIndexServlet.parseShowBranch(req); java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> descs = getDescriptions(req, res, branches); if (descs == null) { return; } java.io.Writer writer = startRenderText(req, res); for (com.google.gitiles.RepositoryDescription repo : descs.values()) { for (java.lang.String name : branches) { java.lang.String ref = repo.branches.get(name); if (ref == null) { ref = "----------------------------------------"; } writer.write(ref); writer.write(' '); } writer.write(GitilesUrls.NAME_ESCAPER.apply(repo.name)); writer.write('\n'); } writer.flush(); writer.close(); }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> listRepositories(java.util.Set<java.lang.String> branches) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> repos = com.google.common.collect.Maps.newTreeMap(com.google.gitiles.DefaultAccess.US_COLLATOR); for (org.eclipse.jgit.lib.Repository repo : scanRepositories(basePath, req)) { repos.put(getRepositoryName(repo), buildDescription(repo, branches)); repo.close(); } return repos; }
@java.lang.Override protected void doGetJson(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription> descs = getDescriptions(req, res); if (descs == null) { return; } renderJson(req, res, descs, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gitiles.RepositoryDescription>>() {}.getType()); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res) throws java.io.IOException, javax.servlet.ServletException { if (itr.hasNext()) { itr.next().doFilter(req, res, this); } else { last.doFilter(req, res); } }

@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res, final javax.servlet.FilterChain last) throws java.io.IOException, javax.servlet.ServletException { final java.util.Iterator<com.google.gerrit.httpd.AllRequestFilter> itr = filters.iterator(); new javax.servlet.FilterChain() { @java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res) throws java.io.IOException, javax.servlet.ServletException { if (itr.hasNext()) { itr.next().doFilter(req, res, this); } else { last.doFilter(req, res); } } }.doFilter(req, res); }
@java.lang.Override public void init(javax.servlet.FilterConfig config) throws javax.servlet.ServletException { for (com.google.gerrit.httpd.AllRequestFilter f : filters) { f.init(config); } }
public final com.google.gerrit.gpg.CheckResult check(org.eclipse.jgit.transport.PushCertificate cert) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { if ((cert.getNonceStatus()) != (org.eclipse.jgit.transport.PushCertificate.NonceStatus.OK)) { return new com.google.gerrit.gpg.CheckResult("Invalid nonce"); } org.bouncycastle.openpgp.PGPSignature sig = readSignature(cert); if (sig == null) { return new com.google.gerrit.gpg.CheckResult("Invalid signature format"); } org.eclipse.jgit.lib.Repository repo = getRepository(); java.util.List<java.lang.String> problems = new java.util.ArrayList<>(); try (com.google.gerrit.gpg.PublicKeyStore store = new com.google.gerrit.gpg.PublicKeyStore(repo)) { checkSignature(sig, cert, store.get(sig.getKeyID()), problems); checkCustom(repo, problems); return new com.google.gerrit.gpg.CheckResult(problems); } finally { if (shouldClose(repo)) { repo.close(); } } }












@java.lang.Override protected com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> defaultField(java.lang.String query) throws com.google.gerrit.server.query.QueryParseException { if (query.startsWith("refs/")) { return ref(query); } else if (com.google.gerrit.server.query.change.ChangeQueryBuilder.DEF_CHANGE.matcher(query).matches()) { try { return change(query); } catch (com.google.gerrit.server.query.QueryParseException e) { } } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates = com.google.common.collect.Lists.newArrayListWithCapacity(9); try { predicates.add(commit(query)); } catch (java.lang.IllegalArgumentException e) { } try { predicates.add(owner(query)); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException e) { } try { predicates.add(reviewer(query)); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException e) { } predicates.add(file(query)); try { predicates.add(label(query)); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException e) { } predicates.add(message(query)); predicates.add(comment(query)); predicates.add(projects(query)); predicates.add(ref(query)); predicates.add(branch(query)); predicates.add(topic(query)); return com.google.gerrit.server.query.Predicate.or(predicates); }











private boolean loadCommitData() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return false; } java.lang.String sha1 = ps.getRevision().get(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(change().getProject());org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); commitFooters = c.getFooterLines(); } return true; }

private void saveScheme() { com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme scheme = getSelectedScheme(); com.google.gerrit.client.info.AccountPreferencesInfo prefs = com.google.gerrit.client.Gerrit.getUserPreferences(); if (((com.google.gerrit.client.Gerrit.isSignedIn()) && (scheme != null)) && (scheme != (prefs.downloadScheme()))) { prefs.downloadScheme(scheme); com.google.gerrit.client.info.AccountPreferencesInfo in = com.google.gerrit.client.info.AccountPreferencesInfo.create(); in.downloadScheme(scheme); com.google.gerrit.client.account.AccountApi.self().view("preferences").put(in, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }

public void setDownloadUrl(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme url) { if (url != null) { downloadUrl = url.name(); } else { downloadUrl = null; } }
public com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme getDownloadUrl() { if ((downloadUrl) == null) { return null; } return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.valueOf(downloadUrl); }

private void checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys, java.util.List<java.lang.String> problems) { java.util.List<java.lang.String> deferredProblems = new java.util.ArrayList<>(); boolean anyKeys = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing kr : keys) { org.bouncycastle.openpgp.PGPPublicKey k = kr.getPublicKey(); anyKeys = true; try { sig.init(new org.bouncycastle.openpgp.operator.bc.BcPGPContentVerifierBuilderProvider(), k); sig.update(org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (!(sig.verify())) { deferredProblems.add(("Signature not valid with public key: " + (com.google.gerrit.gpg.PublicKeyStore.keyToString(k)))); continue; } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(k, sig.getKeyID()); if (result.isOk()) { return; } java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(k)).append(":"); for (int i = 0; i < (result.getProblems().size()); i++) { err.append('\n').append(" ").append(result.getProblems().get(i)); } problems.add(err.toString()); return; } catch (org.bouncycastle.openpgp.PGPException e) { deferredProblems.add(((("Error checking signature with public key " + (com.google.gerrit.gpg.PublicKeyStore.keyToString(k))) + ": ") + (e.getMessage()))); } } if (!anyKeys) { problems.add(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID())))); } else { problems.addAll(deferredProblems); } }
public final com.google.gerrit.gpg.CheckResult check(org.eclipse.jgit.transport.PushCertificate cert) { if ((cert.getNonceStatus()) != (org.eclipse.jgit.transport.PushCertificate.NonceStatus.OK)) { return new com.google.gerrit.gpg.CheckResult("Invalid nonce"); } java.util.List<java.lang.String> problems = new java.util.ArrayList<>(); try { org.bouncycastle.openpgp.PGPSignature sig = readSignature(cert); if (sig != null) { org.eclipse.jgit.lib.Repository repo = getRepository(); try (com.google.gerrit.gpg.PublicKeyStore store = new com.google.gerrit.gpg.PublicKeyStore(repo)) { checkSignature(sig, cert, store.get(sig.getKeyID()), problems); checkCustom(repo, problems); } finally { if (shouldClose(repo)) { repo.close(); } } } else { problems.add("Invalid signature format"); } } catch (org.bouncycastle.openpgp.PGPException | java.io.IOException e) { java.lang.String msg = "Internal error checking push certificate"; com.google.gerrit.gpg.PushCertificateChecker.log.error(msg, e); problems.add(msg); } return new com.google.gerrit.gpg.CheckResult(problems); }
private void checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, com.google.gerrit.gpg.PublicKeyStore store, java.util.List<java.lang.String> problems) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys = store.get(sig.getKeyID()); if (!(keys.getKeyRings().hasNext())) { problems.add(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID())))); return; } org.bouncycastle.openpgp.PGPPublicKey signer = com.google.gerrit.gpg.PublicKeyStore.getSigner(keys, sig, org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (signer == null) { problems.add((("Signature by " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))) + " is not valid")); return; } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(signer, sig.getKeyID()); if (!(result.isOk())) { java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(signer)).append(":"); for (int i = 0; i < (result.getProblems().size()); i++) { err.append('\n').append(" ").append(result.getProblems().get(i)); } problems.add(err.toString()); } }























private net.codemirror.lib.Configuration getConfig() { return net.codemirror.lib.Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", 4).set("lineWrapping", false).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("mode", net.codemirror.lib.ModeInjector.getContentType(type)); }
private void initEditor(java.lang.String content) { cm = net.codemirror.lib.CodeMirror.create(editor, getConfig()); cm.setValue(content); }




@java.lang.Override protected void onInitUI() { super.onInitUI(); initPath(); setHeaderVisible(false); }

@java.lang.Override public void onShowView() { super.onShowView(); int rest = (com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 30; cm.setHeight(((com.google.gwt.user.client.Window.getClientHeight()) - rest)); cm.refresh(); cm.focus(); }

@java.lang.Override protected void configure() { bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class); bind(new com.google.inject.TypeLiteral<org.eclipse.jgit.transport.resolver.RepositoryResolver<javax.servlet.http.HttpServletRequest>>() {}).to(com.googlesource.gerrit.plugins.gitiles.Resolver.class); listener().to(com.googlesource.gerrit.plugins.gitiles.Module.Lifecycle.class); }



public static void validateRefPattern(java.lang.String refPattern) throws com.google.gerrit.common.errors.InvalidNameException { if (refPattern.startsWith(RefConfigSection.REGEX_PREFIX)) { if (!(org.eclipse.jgit.lib.Repository.isValidRefName(com.google.gerrit.server.project.RefControl.shortestExample(refPattern)))) { throw new com.google.gerrit.common.errors.InvalidNameException(refPattern); } } else if (refPattern.equals(RefConfigSection.ALL)) { } else if (refPattern.endsWith("/*")) { java.lang.String prefix = refPattern.substring(0, ((refPattern.length()) - 2)); if (!(org.eclipse.jgit.lib.Repository.isValidRefName(prefix))) { throw new com.google.gerrit.common.errors.InvalidNameException(refPattern); } } else if (!(org.eclipse.jgit.lib.Repository.isValidRefName(refPattern))) { throw new com.google.gerrit.common.errors.InvalidNameException(refPattern); } }
private void updateRemoteExternalId(com.google.gerrit.server.account.AuthResult arsp, java.lang.String remoteAuthToken) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountExternalId remoteAuthExtId = new com.google.gerrit.reviewdb.client.AccountExternalId(arsp.getAccountId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_EXTERNAL, remoteAuthToken)); accountManager.updateLink(arsp.getAccountId(), new com.google.gerrit.server.account.AuthRequest(remoteAuthExtId.getExternalId())); }
private static <T extends java.lang.Enum<?>> T getEnum(final java.lang.String section, final java.lang.String subsection, final java.lang.String setting, java.lang.String valueString, final T[] all) { java.lang.String n = valueString.replace(' ', '_').replace('-', '_'); for (final T e : all) { if (equalsIgnoreCase(e.name(), n)) { return e; } } final java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append("Value \""); r.append(valueString); r.append("\" not recognized in "); r.append(section); if (subsection != null) { r.append("."); r.append(subsection); } r.append("."); r.append(setting); r.append("; supported values are: "); for (final T e : all) { r.append(e.name()); r.append(" "); } throw new java.lang.IllegalArgumentException(r.toString().trim()); }
static com.google.gerrit.common.data.ParameterizedString paramString(org.eclipse.jgit.lib.Config c, java.lang.String n, java.lang.String d) { java.lang.String expression = com.google.gerrit.server.auth.ldap.LdapRealm.optdef(c, n, d); if (expression == null) { return null; } else if (expression.contains("${")) { return new com.google.gerrit.common.data.ParameterizedString(expression); } else { return new com.google.gerrit.common.data.ParameterizedString((("${" + expression) + "}")); } }

private org.kohsuke.github.PagedIterable<org.kohsuke.github.GHRepository> getRepositories(com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin, java.lang.String organisation) throws java.io.IOException { if (organisation.equals(hubLogin.getMyself().getLogin())) { return hubLogin.getMyself().listRepositories(config.repositoryListPageSize); } else { org.kohsuke.github.GHOrganization ghOrganisation = hubLogin.getMyself().getAllOrganizations().byLogin(organisation); return ghOrganisation.listRepositories(config.repositoryListPageSize); } }
@org.junit.Test public void getSetEditPreferences() throws java.lang.Exception { java.lang.String endPoint = ("/accounts/" + (admin.email)) + "/preferences.edit"; com.google.gerrit.acceptance.RestResponse r = adminSession.get(endPoint); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); com.google.gerrit.extensions.client.EditPreferencesInfo out = getEditPrefInfo(r); assertThat(out.lineLength).isEqualTo(100); assertThat(out.tabSize).isEqualTo(8); assertThat(out.cursorBlinkRate).isEqualTo(0); assertThat(out.hideTopMenu).isNull(); assertThat(out.showTabs).isTrue(); assertThat(out.showWhitespaceErrors).isNull(); assertThat(out.syntaxHighlighting).isTrue(); assertThat(out.hideLineNumbers).isNull(); assertThat(out.theme).isEqualTo(Theme.DEFAULT); assertThat(out.keyMapType).isEqualTo(KeyMapType.DEFAULT); out.lineLength = 80; out.tabSize = 4; out.cursorBlinkRate = 500; out.hideTopMenu = true; out.showTabs = false; out.showWhitespaceErrors = true; out.syntaxHighlighting = false; out.hideLineNumbers = true; out.theme = com.google.gerrit.extensions.client.Theme.TWILIGHT; out.keyMapType = com.google.gerrit.extensions.client.KeyMapType.EMACS; r = adminSession.put(endPoint, out); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NO_CONTENT); r = adminSession.get(endPoint); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); com.google.gerrit.extensions.client.EditPreferencesInfo info = getEditPrefInfo(r); assertEditPreferences(info, out); }
public static com.google.gerrit.extensions.client.EditPreferencesInfo defaults() { com.google.gerrit.extensions.client.EditPreferencesInfo i = new com.google.gerrit.extensions.client.EditPreferencesInfo(); i.tabSize = 8; i.lineLength = 100; i.cursorBlinkRate = 0; i.hideTopMenu = false; i.showTabs = true; i.showWhitespaceErrors = false; i.syntaxHighlighting = true; i.hideLineNumbers = false; i.theme = com.google.gerrit.extensions.client.Theme.DEFAULT; i.keyMapType = KeyMapType.DEFAULT; return i; }
private void assertEditPreferences(com.google.gerrit.extensions.client.EditPreferencesInfo out, com.google.gerrit.extensions.client.EditPreferencesInfo in) { assertThat(out.lineLength).isEqualTo(in.lineLength); assertThat(out.tabSize).isEqualTo(in.tabSize); assertThat(out.cursorBlinkRate).isEqualTo(in.cursorBlinkRate); assertThat(out.hideTopMenu).isEqualTo(in.hideTopMenu); assertThat(out.showTabs).isNull(); assertThat(out.showWhitespaceErrors).isEqualTo(in.showWhitespaceErrors); assertThat(out.syntaxHighlighting).isNull(); assertThat(out.hideLineNumbers).isEqualTo(in.hideLineNumbers); assertThat(out.theme).isEqualTo(in.theme); assertThat(out.keyMapType).isEqualTo(in.keyMapType); }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = com.google.common.collect.Lists.newArrayList(); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getControl(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).setStart(start).setLimit(limit).filter(tags); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = com.google.common.collect.Lists.newArrayList(); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getControl(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return tags; }





@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { com.google.common.collect.FluentIterable<com.google.gerrit.extensions.api.projects.BranchInfo> branches = allBranches(rsrc); branches = filterBranches(branches); if ((start) > 0) { branches = branches.skip(start); } if ((limit) > 0) { branches = branches.limit(limit); } return branches.toList(); }

private com.google.inject.AbstractModule createIndexModule() { if (slave) { return new com.google.gerrit.server.index.DummyIndexModule(); } com.google.gerrit.server.index.IndexModule.IndexType indexType = com.google.gerrit.server.index.IndexModule.getIndexType(cfgInjector); switch (indexType) { case LUCENE : return (luceneModule) != null ? luceneModule : new com.google.gerrit.lucene.LuceneIndexModule(); default : throw new java.lang.IllegalStateException(("unsupported index.type = " + indexType)); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException { who = realm.authenticate(who); try { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); final com.google.gerrit.reviewdb.client.AccountExternalId id = db.accountExternalIds().get(key); if (id == null) { return create(db, who); } else { com.google.gerrit.reviewdb.client.Account act = db.accounts().get(id.getAccountId()); if ((act == null) || (!(act.isActive()))) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.getAccountId(), key, false); } } finally { db.close(); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
public com.google.gerrit.server.account.AuthResult unlink(final com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { who = realm.unlink(db, from, who); final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId extId = db.accountExternalIds().get(key); if (extId != null) { if (!(extId.getAccountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } db.accountExternalIds().delete(java.util.Collections.singleton(extId)); if ((who.getEmailAddress()) != null) { final com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException("Identity not found"); } return new com.google.gerrit.server.account.AuthResult(from, key, false); } finally { db.close(); } }

public com.google.gerrit.server.account.AuthResult link(final com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { who = realm.link(db, to, who); final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId extId = db.accountExternalIds().get(key); if (extId != null) { if (!(extId.getAccountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { extId = com.google.gerrit.server.account.AccountManager.createId(to, who); extId.setEmailAddress(who.getEmailAddress()); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); if ((who.getEmailAddress()) != null) { final com.google.gerrit.reviewdb.client.Account a = db.accounts().get(to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress()) != null) { byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(to); } } return new com.google.gerrit.server.account.AuthResult(to, key, false); } finally { db.close(); } }
private com.google.gerrit.reviewdb.client.AccountExternalId getAccountExternalId(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountExternalId.Key key) throws com.google.gwtorm.server.OrmException { java.lang.String keyValue = key.get(); java.lang.String keyScheme = keyValue.substring(0, ((keyValue.indexOf(':')) + 1)); if ((keyScheme.equals(AccountExternalId.SCHEME_GERRIT)) || (keyScheme.equals(AccountExternalId.SCHEME_USERNAME))) { java.lang.String username = keyValue.substring(keyScheme.length()); java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds = byIdCache.getByUsername(username).getExternalIds(); for (com.google.gerrit.reviewdb.client.AccountExternalId accountExternalId : externalIds) { if (accountExternalId.isScheme(keyScheme)) { return accountExternalId; } } com.google.gerrit.server.account.AccountManager.log.warn("Cannot find account external id for user {} in cache, possibly a stale entry", username); } return db.accountExternalIds().get(key); }
private com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Change.Id> getOpenChangesByProject(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Change.Id> openByProject = com.google.common.collect.HashMultimap.create(); for (com.google.gerrit.reviewdb.client.Change c : db.changes().all()) { if (c.getStatus().isOpen()) { openByProject.put(c.getProject(), c.getId()); } } return openByProject; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { ui.message("Listing all changes ..."); com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Change.Id> openByProject = getOpenChangesByProject(db); ui.message("done"); ui.message("Updating groups for open changes ..."); int i = 0; for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Project.NameKey, java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id>> e : openByProject.asMap().entrySet()) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(e.getKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.schema.Schema_108.updateProjectGroups(db, repo, rw, ((java.util.Set<com.google.gerrit.reviewdb.client.Change.Id>) (e.getValue()))); } catch (java.io.IOException err) { throw new com.google.gwtorm.server.OrmException(err); } if (((++i) % 100) == 0) { ui.message(((" done " + i) + " projects ...")); } } ui.message("done"); }
private void checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, com.google.gerrit.gpg.PublicKeyStore store, java.util.List<java.lang.String> problems) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys = store.get(sig.getKeyID()); if (!(keys.getKeyRings().hasNext())) { problems.add(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID())))); return; } org.bouncycastle.openpgp.PGPPublicKey signer = com.google.gerrit.gpg.PublicKeyStore.getSigner(keys, sig, org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (signer == null) { problems.add((("Signature by " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))) + " is not valid")); return; } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(signer, store); if (!(result.isOk())) { java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(signer)).append(":"); for (java.lang.String problem : result.getProblems()) { err.append("\n ").append(problem); } problems.add(err.toString()); } }




@org.junit.Test public void submitTwoChangesWithFastForward() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); approve(change.getChangeId()); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change2.getCommitId()); assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId()); assertSubmitter(change.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 1); assertPersonEquals(admin.getIdent(), head.getAuthorIdent()); assertPersonEquals(admin.getIdent(), head.getCommitterIdent()); }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), resource.getChange()); if ((cs.size()) > 1) { return json.create(java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).format(cs.ids()); } else { return java.util.Collections.emptyList(); } } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { com.google.gerrit.server.change.SubmittedTogether.log.error("Error on getting a ChangeSet", e); throw e; } }


@java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change c) { c.setStatus(Change.Status.MERGED); if (!(merged.equals(c.currentPatchSetId()))) { try { c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged)); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e1) { logError(("Cannot read merged patch set " + merged), e1); } } com.google.gerrit.server.ChangeUtil.updated(c); return c; }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { logPrefix = java.lang.String.format("[%s]: ", java.lang.String.valueOf(change.hashCode())); this.db = db; logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } try { integrateIntoHistory(cs, caller); } catch (com.google.gerrit.server.git.MergeException e) { logError("Merge Conflict", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Merge Conflict", e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private com.google.gerrit.reviewdb.client.Change setMergedPatchSet(com.google.gerrit.reviewdb.client.Change.Id changeId, final com.google.gerrit.reviewdb.client.PatchSet.Id merged) throws com.google.gwtorm.server.OrmException { return db.changes().atomicUpdate(changeId, new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change c) { c.setStatus(Change.Status.MERGED); if (!(merged.equals(c.currentPatchSetId()))) { try { c.setCurrentPatchSet(patchSetInfoFactory.get(db, merged)); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e1) { logError(("Cannot read merged patch set " + merged), e1); } } com.google.gerrit.server.ChangeUtil.updated(c); return c; } }); }



private void postEvent(java.lang.String projectName, com.google.gerrit.server.events.RefEvent event) { com.google.gerrit.reviewdb.client.Project.NameKey project = Project.NameKey.parse(projectName); if (com.google.gerrit.reviewdb.client.PatchSet.isRef(event.getRefName())) { dispatcher.postEvent(project, event); } else { com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, event.getRefName()); dispatcher.postEvent(branch, event); } }
public com.google.gerrit.reviewdb.client.Change insert() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { init(); validate(); com.google.gerrit.server.change.PatchSetInserter.Op op = new com.google.gerrit.server.change.PatchSetInserter.Op(); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db, ctl.getChange().getProject(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(ctl, op); bu.execute(); } return op.change; }
public static java.io.File getDeveloperBuckOut() throws java.io.FileNotFoundException { java.lang.Class<com.google.gerrit.launcher.GerritLauncher> self = com.google.gerrit.launcher.GerritLauncher.class; java.net.URL u = self.getResource(((self.getSimpleName()) + ".class")); if (u == null) { throw new java.io.FileNotFoundException(("Cannot find class " + (self.getName()))); } else if (!("file".equals(u.getProtocol()))) { throw new java.io.FileNotFoundException(("Cannot find extract path from " + u)); } java.io.File dir = new java.io.File(u.getPath()); java.lang.String myName = self.getName(); for (; ;) { int dot = myName.lastIndexOf('.'); if (dot < 0) { dir = dir.getParentFile(); break; } myName = myName.substring(0, dot); dir = dir.getParentFile(); } dir = com.google.gerrit.launcher.GerritLauncher.popdir(u, dir, "classes"); dir = com.google.gerrit.launcher.GerritLauncher.popdir(u, dir, "eclipse"); if ("buck-out".equals(dir.getName())) { return dir; } throw new java.io.FileNotFoundException(("Cannot find buck-out from " + u)); }
private static java.io.File popdir(java.net.URL u, java.io.File dir, java.lang.String name) throws java.io.FileNotFoundException { if (dir.getName().equals(name)) { return dir.getParentFile(); } throw new java.io.FileNotFoundException(("Cannot find buck-out from " + u)); }
@org.junit.Before public void setUp() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.reviewdb.client.AccountGroup.UUID anonymousUsers = com.google.gerrit.server.group.SystemGroupBackend.getGroup(com.google.gerrit.acceptance.server.project.ANONYMOUS_USERS).getUUID(); HEAD((fda7f7 = "Fix broken JSON syntax in documentation")); }
public boolean isDraftVisible(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return ((isOwner()) || (isReviewer(db, cd))) || (getRefControl().canViewDrafts()); }


@org.junit.Test public void noExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(db.accountExternalIds().byAccount(user.getAccountId())); reloadUser(); assertProblems(com.google.gerrit.gpg.testutil.TestKey.key5(), ("No identities found for user; check" + " http://test/#/settings/web-identities")); }
@org.junit.Test public void defaultGpgCertificationDoesNotMatchEmail() throws java.lang.Exception { addExternalId("test", "test", "nobody@example.com"); assertProblems(com.google.gerrit.gpg.testutil.TestKey.key5(), ("Key must contain a valid certification for one of the following " + (((("identities:\n" + " gerrit:user\n") + " nobody@example.com\n") + " test:test\n") + " username:user"))); }
@org.junit.Test public void manualCertificationMatchesExternalId() throws java.lang.Exception { addExternalId("foo", "myId", null); assertNoProblems(com.google.gerrit.gpg.testutil.TestKey.key5()); }
@org.junit.Test public void defaultGpgCertificationMatchesEmail() throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key = com.google.gerrit.gpg.testutil.TestKey.key5(); assertProblems(com.google.gerrit.gpg.testutil.TestKey.key5(), ("Key must contain a valid certification for one of the following " + (("identities:\n" + " gerrit:user\n") + " username:user"))); addExternalId("test", "test", "test5@example.com"); assertNoProblems(key); }
@org.junit.Test public void manualCertificationDoesNotExternalId() throws java.lang.Exception { addExternalId("foo", "otherId", null); assertProblems(com.google.gerrit.gpg.testutil.TestKey.key5(), ("Key must contain a valid certification for one of the following " + ((("identities:\n" + " foo:otherId\n") + " gerrit:user\n") + " username:user"))); }
private void assertProblems(com.google.gerrit.gpg.testutil.TestKey key, java.lang.String... expected) throws java.lang.Exception { checkArgument(((expected.length) > 0)); assertThat(checker.check(key.getPublicKey()).getProblems()).containsExactly(((java.lang.Object[]) (expected))).inOrder(); }




private void checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, com.google.gerrit.gpg.PublicKeyStore store, java.util.List<java.lang.String> problems) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys = store.get(sig.getKeyID()); if (!(keys.getKeyRings().hasNext())) { problems.add(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID())))); return; } org.bouncycastle.openpgp.PGPPublicKey signer = com.google.gerrit.gpg.PublicKeyStore.getSigner(keys, sig, org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (signer == null) { problems.add((("Signature by " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))) + " is not valid")); return; } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(signer, store); if (!(result.isOk())) { java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(signer)).append(":"); for (java.lang.String problem : result.getProblems()) { err.append("\n ").append(problem); } problems.add(err.toString()); } }

private static com.google.gerrit.gpg.CheckResult combine(com.google.gerrit.gpg.CheckResult sigResult, java.util.List<com.google.gerrit.gpg.CheckResult> results) { java.util.List<java.lang.String> problems = new java.util.ArrayList<>(); boolean bad = false; for (com.google.gerrit.gpg.CheckResult result : results) { problems.addAll(result.getProblems()); bad |= (result.getStatus()) == (BAD); } com.google.gerrit.extensions.common.GpgKeyInfo.Status status = (bad) ? BAD : OK; if (sigResult != null) { problems.addAll(sigResult.getProblems()); if ((sigResult.getStatus()) == (BAD)) { status = BAD; } else if ((sigResult.getStatus()) == (TRUSTED)) { status = TRUSTED; } } return com.google.gerrit.gpg.CheckResult.create(status, problems); }
public final com.google.gerrit.gpg.CheckResult check(org.eclipse.jgit.transport.PushCertificate cert) { if ((cert.getNonceStatus()) != (org.eclipse.jgit.transport.PushCertificate.NonceStatus.OK)) { return com.google.gerrit.gpg.CheckResult.bad("Invalid nonce"); } java.util.List<com.google.gerrit.gpg.CheckResult> results = new java.util.ArrayList<>(2); com.google.gerrit.gpg.CheckResult sigResult = null; try { org.bouncycastle.openpgp.PGPSignature sig = readSignature(cert); if (sig != null) { @java.lang.SuppressWarnings("resource") org.eclipse.jgit.lib.Repository repo = getRepository(); try (com.google.gerrit.gpg.PublicKeyStore store = new com.google.gerrit.gpg.PublicKeyStore(repo)) { sigResult = checkSignature(sig, cert, store); results.add(checkCustom(repo)); } finally { if (shouldClose(repo)) { repo.close(); } } } else { results.add(com.google.gerrit.gpg.CheckResult.bad("Invalid signature format")); } } catch (org.bouncycastle.openpgp.PGPException | java.io.IOException e) { java.lang.String msg = "Internal error checking push certificate"; com.google.gerrit.gpg.PushCertificateChecker.log.error(msg, e); results.add(com.google.gerrit.gpg.CheckResult.bad(msg)); } return com.google.gerrit.gpg.PushCertificateChecker.combine(sigResult, results); }


private com.google.gerrit.gpg.CheckResult checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, com.google.gerrit.gpg.PublicKeyStore store) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys = store.get(sig.getKeyID()); if (!(keys.getKeyRings().hasNext())) { return com.google.gerrit.gpg.CheckResult.bad(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID())))); } org.bouncycastle.openpgp.PGPPublicKey signer = com.google.gerrit.gpg.PublicKeyStore.getSigner(keys, sig, org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (signer == null) { return com.google.gerrit.gpg.CheckResult.bad((("Signature by " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))) + " is not valid")); } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(signer, store); if (!(result.getProblems().isEmpty())) { java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(signer)).append(":"); for (java.lang.String problem : result.getProblems()) { err.append("\n ").append(problem); } return com.google.gerrit.gpg.CheckResult.create(result.getStatus(), err.toString()); } return result; }
@java.lang.Override public com.google.gerrit.extensions.common.GpgKeyInfo apply(com.google.gerrit.gpg.server.GpgKey rsrc) throws java.io.IOException { try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { return com.google.gerrit.gpg.server.GpgKeys.toJson(rsrc.getKeyRing(), checker, store); } }


private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> toJson(java.util.Collection<org.bouncycastle.openpgp.PGPPublicKeyRing> keys, java.util.Set<com.google.gerrit.gpg.Fingerprint> deleted, com.google.gerrit.gpg.PublicKeyStore store) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> infos = com.google.common.collect.Maps.newHashMapWithExpectedSize(((keys.size()) + (deleted.size()))); for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : keys) { com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing, checker, store); infos.put(info.id, info); info.id = null; } for (com.google.gerrit.gpg.Fingerprint fp : deleted) { infos.put(com.google.gerrit.gpg.PublicKeyStore.keyIdToString(fp.getId()), new com.google.gerrit.extensions.common.GpgKeyInfo()); } return infos; }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keys = new java.util.HashMap<>(); try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { for (com.google.gerrit.reviewdb.client.AccountExternalId extId : getGpgExtIds(rsrc)) { java.lang.String fpStr = extId.getSchemeRest(); byte[] fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); boolean found = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(com.google.gerrit.gpg.server.GpgKeys.keyId(fp))) { if (java.util.Arrays.equals(keyRing.getPublicKey().getFingerprint(), fp)) { found = true; com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing, checker, store); keys.put(info.id, info); info.id = null; break; } } if (!found) { com.google.gerrit.gpg.server.GpgKeys.log.warn("No public key stored for fingerprint {}", com.google.gerrit.gpg.Fingerprint.toString(fp)); } } } return keys; }
@java.lang.Override public void onPreReceive(org.eclipse.jgit.transport.ReceivePack rp, java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { org.eclipse.jgit.transport.PushCertificate cert = rp.getPushCertificate(); if (cert == null) { return; } com.google.gerrit.gpg.PushCertificateChecker checker = new com.google.gerrit.gpg.PushCertificateChecker(keyChecker) { @java.lang.Override protected org.eclipse.jgit.lib.Repository getRepository() throws java.io.IOException { return repoManager.openRepository(allUsers); } @java.lang.Override protected boolean shouldClose(org.eclipse.jgit.lib.Repository repo) { return true; } }; com.google.gerrit.gpg.CheckResult result = checker.check(cert); if (!(result.isOk())) { for (java.lang.String problem : result.getProblems()) { rp.sendMessage(problem); } com.google.gerrit.gpg.SignedPushPreReceiveHook.reject(commands, "invalid push cert"); } }
@java.lang.Override public void onPreReceive(org.eclipse.jgit.transport.ReceivePack rp, java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> commands) { org.eclipse.jgit.transport.PushCertificate cert = rp.getPushCertificate(); if (cert == null) { return; } com.google.gerrit.gpg.PushCertificateChecker checker = new com.google.gerrit.gpg.PushCertificateChecker(keyChecker) { @java.lang.Override protected org.eclipse.jgit.lib.Repository getRepository() throws java.io.IOException { return repoManager.openRepository(allUsers); } @java.lang.Override protected boolean shouldClose(org.eclipse.jgit.lib.Repository repo) { return true; } }; com.google.gerrit.gpg.CheckResult result = checker.check(cert).getCheckResult(); if (!(result.isOk())) { for (java.lang.String problem : result.getProblems()) { rp.sendMessage(problem); } com.google.gerrit.gpg.SignedPushPreReceiveHook.reject(commands, "invalid push cert"); } }
static com.google.gerrit.extensions.common.GpgKeyInfo toJson(org.bouncycastle.openpgp.PGPPublicKeyRing keyRing) throws java.io.IOException { org.bouncycastle.openpgp.PGPPublicKey key = keyRing.getPublicKey(); com.google.gerrit.extensions.common.GpgKeyInfo info = new com.google.gerrit.extensions.common.GpgKeyInfo(); info.id = com.google.gerrit.gpg.PublicKeyStore.keyIdToString(key.getKeyID()); info.fingerprint = com.google.gerrit.gpg.Fingerprint.toString(key.getFingerprint()); @java.lang.SuppressWarnings("unchecked") java.util.Iterator<java.lang.String> userIds = key.getUserIDs(); info.userIds = com.google.common.collect.ImmutableList.copyOf(userIds); try (java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(4096);org.bouncycastle.bcpg.ArmoredOutputStream aout = new org.bouncycastle.bcpg.ArmoredOutputStream(out)) { key.encode(aout); info.key = new java.lang.String(out.toByteArray(), java.nio.charset.StandardCharsets.UTF_8); } return info; }
private static java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> toJson(java.util.Collection<org.bouncycastle.openpgp.PGPPublicKeyRing> keys, java.util.Set<com.google.gerrit.gpg.Fingerprint> deleted) throws java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> infos = com.google.common.collect.Maps.newHashMapWithExpectedSize(((keys.size()) + (deleted.size()))); for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : keys) { com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing); infos.put(info.id, info); info.id = null; } for (com.google.gerrit.gpg.Fingerprint fp : deleted) { infos.put(com.google.gerrit.gpg.PublicKeyStore.keyIdToString(fp.getId()), new com.google.gerrit.extensions.common.GpgKeyInfo()); } return infos; }
private static void assertKeyEquals(com.google.gerrit.gpg.testutil.TestKey expected, com.google.gerrit.extensions.common.GpgKeyInfo actual) { java.lang.String id = expected.getKeyIdString(); assertThat(actual.id).named(id).isEqualTo(id); assertThat(actual.fingerprint).named(id).isEqualTo(com.google.gerrit.gpg.Fingerprint.toString(expected.getPublicKey().getFingerprint())); @java.lang.SuppressWarnings("unchecked") java.util.List<java.lang.String> userIds = com.google.common.collect.ImmutableList.copyOf(expected.getPublicKey().getUserIDs()); assertThat(actual.userIds).named(id).containsExactlyElementsIn(userIds); assertThat(actual.key).named(id).startsWith("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"); }
private void newPatchSet() { com.google.gerrit.reviewdb.client.PatchSet.Id id = com.google.gerrit.server.ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId()); newPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(id); newPatchSet.setCreatedOn(com.google.gerrit.common.TimeUtil.nowTs()); newPatchSet.setUploader(currentUser.getAccountId()); newPatchSet.setRevision(com.google.gerrit.server.git.ReceiveCommits.toRevId(newCommit)); newPatchSet.setGroups(groups); if (((magicBranch) != null) && (magicBranch.draft)) { newPatchSet.setDraft(true); } info = patchSetInfoFactory.get(newCommit, newPatchSet.getId()); cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), newCommit, newPatchSet.getRefName()); }

private void columnDelta1(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.info.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().deltaColumn1()); if ((!(Patch.COMMIT_MSG.equals(info.path()))) && (!(info.binary()))) { if (showChangeSizeBars) { sb.append(((info.linesInserted()) + (info.linesDeleted()))); } else if (!(ChangeType.DELETED.matches(info.status()))) { if (ChangeType.ADDED.matches(info.status())) { sb.append(info.linesInserted()).append(" lines"); } else { sb.append("+").append(info.linesInserted()).append(", -").append(info.linesDeleted()); } } } sb.closeTd(); }

public void validate() throws com.google.gerrit.server.project.InvalidChangeOperationException, java.io.IOException { if ((validated) || ((validatePolicy) == (CommitValidators.Policy.NONE))) { return; } com.google.gerrit.server.git.validators.CommitValidators cv = commitValidatorsFactory.create(refControl, new com.google.gerrit.server.ssh.NoSshInfo(), git); java.lang.String refName = patchSet.getId().toRefName(); com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, user); try { switch (validatePolicy) { case RECEIVE_COMMITS : org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(git, revWalk); cv.validateForReceiveCommits(event, rejectCommits); break; case GERRIT : cv.validateForGerritCommits(event); break; case NONE : break; } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.server.project.InvalidChangeOperationException(e.getMessage()); } validated = true; }
public static java.lang.String getToken(final javax.servlet.http.HttpServletRequest req) { java.lang.String encodedToken = req.getPathInfo(); if (com.google.common.base.Strings.isNullOrEmpty(encodedToken)) { return com.google.gerrit.httpd.LoginUrlToken.DEFAULT_TOKEN; } else { return com.google.common.base.CharMatcher.is('/').trimLeadingFrom(com.google.gerrit.extensions.restapi.Url.decode(encodedToken)); } }

private com.google.gerrit.reviewdb.client.ChangeMessage newChangeMessage(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.change.ChangeKind changeKind) throws com.google.gwtorm.server.OrmException { msg = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId()); java.lang.String message = "Uploaded patch set " + (newPatchSet.getPatchSetId()); switch (changeKind) { case TRIVIAL_REBASE : case NO_CHANGE : message += (": Patch Set " + (priorPatchSet.get())) + " was rebased"; break; case NO_CODE_CHANGE : message += ": Commit message was updated"; break; case REWORK : default : break; } msg.setMessage((message + ".")); return msg; }
@org.junit.Test public void testPushForMasterWithApprovals() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review"); r.assertOkStatus(); ChangeInfo ci = get(r.getChangeId()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value.intValue()).is(1); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to(git, "refs/for/master/%l=Code-Review+2"); ci = get(r.getChangeId()); cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value.intValue()).is(2); }

private void insertChange(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException, java.io.IOException { final com.google.gerrit.reviewdb.client.PatchSet ps = ins.getPatchSet(); final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); java.util.Map<java.lang.String, java.lang.Short> approvals = new java.util.HashMap<>(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); approvals = magicBranch.labels; ins.setHashtags(magicBranch.hashtags); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); com.google.gerrit.reviewdb.client.ChangeMessage msg = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId()); msg.setMessage((("Uploaded patch set " + (ps.getPatchSetId())) + ".")); ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert(); created = true; if (((magicBranch) != null) && (magicBranch.submit)) { submit(projectControl.controlFor(change), ps); } }
private void insertChangeImpl() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.PatchSet ps = ins.setGroups(groups).getPatchSet(); final com.google.gerrit.reviewdb.client.Account.Id me = currentUser.getAccountId(); final java.util.List<org.eclipse.jgit.revwalk.FooterLine> footerLines = commit.getFooterLines(); final com.google.gerrit.server.mail.MailUtil.MailRecipients recipients = new com.google.gerrit.server.mail.MailUtil.MailRecipients(); java.util.Map<java.lang.String, java.lang.Short> approvals = new java.util.HashMap<>(); if ((magicBranch) != null) { recipients.add(magicBranch.getMailRecipients()); approvals = magicBranch.labels; ins.setHashtags(magicBranch.hashtags); } recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines)); recipients.remove(me); try (org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter();com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db, change.getProject(), currentUser, change.getCreatedOn())) { bu.setRepository(repo, rp.getRevWalk(), oi); bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage((("Uploaded patch set " + (ps.getPatchSetId())) + ".")).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false)); bu.execute(); } created = true; if (((magicBranch) != null) && (magicBranch.submit)) { submit(projectControl.controlFor(change), ps); } }
com.google.common.util.concurrent.CheckedFuture<java.lang.Void, com.google.gerrit.extensions.restapi.RestApiException> insertChange() throws java.io.IOException { rp.getRevWalk().parseBody(commit); com.google.common.util.concurrent.ListenableFuture<java.lang.Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { insertChangeImpl(); synchronized(newProgress) { newProgress.update(1); } return null; } })); return com.google.common.util.concurrent.Futures.makeChecked(future, com.google.gerrit.server.git.ReceiveCommits.INSERT_EXCEPTION); }
@java.lang.Override public java.lang.Void call() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { insertChangeImpl(); synchronized(newProgress) { newProgress.update(1); } return null; }
private java.lang.StringBuilder renderMessageWithApprovals(int patchSetId, java.util.Map<java.lang.String, java.lang.Short> n, java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> c) { java.lang.StringBuilder msgs = new java.lang.StringBuilder(("Uploaded patch set " + patchSetId)); if (!(n.isEmpty())) { boolean first = true; for (java.util.Map.Entry<java.lang.String, java.lang.Short> e : n.entrySet()) { if ((c.containsKey(e.getKey())) && ((c.get(e.getKey()).getValue()) == (e.getValue()))) { continue; } if (first) { msgs.append(":"); first = false; } msgs.append(" ").append(com.google.gerrit.server.util.LabelVote.create(e.getKey(), e.getValue()).format()); } } return msgs; }

@java.lang.Override public void onGitReferenceUpdated(final com.googlesource.gerrit.plugins.refprotection.Event event) { if (isRelevantRef(event)) { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); try { com.google.gerrit.server.project.ProjectResource project = new com.google.gerrit.server.project.ProjectResource(projectControl.controlFor(nameKey, user)); if ((isRefDeleted(event)) || (isNonFastForwardUpdate(event, project))) { createBackupBranch(event, project); } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.googlesource.gerrit.plugins.refprotection.RefUpdateListener.log.error(e.getMessage(), e); } } }
public static java.lang.String get(java.lang.String branchName) { if ((branchName.startsWith(com.googlesource.gerrit.plugins.refprotection.R_HEADS)) || (branchName.startsWith(com.googlesource.gerrit.plugins.refprotection.R_TAGS))) { return java.lang.String.format("%s-%s", ((com.googlesource.gerrit.plugins.refprotection.BackupBranch.R_BACKUPS) + (branchName.replaceFirst(com.googlesource.gerrit.plugins.refprotection.R_REFS, ""))), new java.text.SimpleDateFormat("YYYYMMdd-HHmmss").format(new java.util.Date())); } return branchName; }

public boolean login(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol oauth, com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope... scopes) throws java.io.IOException { if (isLoggedIn()) { return true; } com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.debug(("Login " + (this))); if (com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.isOAuthFinal(request)) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.debug(("Login-FINAL " + (this))); login(oauth.loginPhase2(request, response, state)); this.state = ""; if (isLoggedIn()) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.debug(("Login-SUCCESS " + (this))); response.sendRedirect(com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.getTargetUrl(request)); return true; } else { return false; } } else { this.loginScopes = getScopes(getScopesKey(request, response), scopes); com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.debug(("Login-PHASE1 " + (this))); state = oauth.loginPhase1(request, response, loginScopes); return false; } }
private java.lang.String getScopesKey(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) { java.lang.String scopeRequested = request.getParameter("scope"); if (scopeRequested == null) { scopeRequested = getScopesKeyFromCookie(request); } if (scopeRequested != null) { javax.servlet.http.Cookie scopeCookie = new javax.servlet.http.Cookie("scope", scopeRequested); scopeCookie.setPath("/"); scopeCookie.setMaxAge(((int) (com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.SCOPE_COOKIE_NEVER_EXPIRES))); response.addCookie(scopeCookie); } return com.google.common.base.MoreObjects.firstNonNull(scopeRequested, "scopes"); }
@org.junit.Test public void testPushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws com.google.gerrit.acceptance.git.GitAPIException, com.google.gerrit.acceptance.git.IOException, com.google.gerrit.acceptance.git.RestApiException { com.google.gerrit.common.data.LabelType Q = category("CustomLabel", value(1, "Positive"), value(0, "No score"), value((-1), "Negative")); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig(); cfg.getLabelSections().put(Q.getName(), Q); com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allProjects); try { cfg.commit(md); } finally { md.close(); } projectCache.evict(allProjects); com.google.gerrit.acceptance.GitUtil.Commit c = com.google.gerrit.acceptance.GitUtil.createCommit(git, user.getIdent(), PushOneCommit.SUBJECT); com.google.gerrit.acceptance.GitUtil.pushHead(git, "refs/for/master/%l=Code-Review+1", false); ChangeInfo ci = get(c.getChangeId()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(2); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value.intValue()).is(1); assertThat(cr.all.get(1).name).isEqualTo("User"); assertThat(cr.all.get(1).value.intValue()).is(0); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1."); }
private static java.util.Set<java.security.PublicKey> read(java.nio.file.Path path) { try (java.io.BufferedReader br = java.nio.file.Files.newBufferedReader(path, java.nio.charset.StandardCharsets.UTF_8)) { final java.util.Set<java.security.PublicKey> keys = new java.util.HashSet<>(); java.lang.String line; while ((line = br.readLine()) != null) { line = line.trim(); if ((line.startsWith("#")) || (line.isEmpty())) { continue; } try { byte[] bin = org.apache.commons.codec.binary.Base64.decodeBase64(line.getBytes("ISO-8859-1")); keys.add(new org.apache.sshd.common.util.Buffer(bin).getRawPublicKey()); } catch (java.lang.RuntimeException | org.apache.sshd.common.SshException e) { com.google.gerrit.sshd.DatabasePubKeyAuth.PeerKeyCache.logBadKey(path, line, e); } } return java.util.Collections.unmodifiableSet(keys); } catch (java.nio.file.NoSuchFileException noFile) { return java.util.Collections.emptySet(); } catch (java.io.IOException err) { com.google.gerrit.sshd.DatabasePubKeyAuth.log.error(("Cannot read " + path), err); return java.util.Collections.emptySet(); } }
com.google.gerrit.server.change.ChangeInserter create(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.reviewdb.client.Change c, org.eclipse.jgit.revwalk.RevCommit rc);
private void newPatchSet() { com.google.gerrit.reviewdb.client.PatchSet.Id id = com.google.gerrit.server.ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId()); newPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(id); newPatchSet.setCreatedOn(com.google.gerrit.common.TimeUtil.nowTs()); newPatchSet.setUploader(currentUser.getAccountId()); newPatchSet.setRevision(com.google.gerrit.server.git.ReceiveCommits.toRevId(newCommit)); newPatchSet.setGroups(groups); if (((magicBranch) != null) && (magicBranch.draft)) { newPatchSet.setDraft(true); } info = patchSetInfoFactory.get(newCommit, newPatchSet.getId()); cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), newCommit, newPatchSet.getRefName()); }
@java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if ((change.getStatus().isClosed()) && (!(allowClosed))) { return null; } if (!(change.currentPatchSetId().equals(currentPatchSetId))) { return null; } if (((change.getStatus()) != (Change.Status.DRAFT)) && (!(allowClosed))) { change.setStatus(Change.Status.NEW); } change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId())); com.google.gerrit.server.ChangeUtil.updated(change); return change; }

void loadChangeInfo(boolean fg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(changeId.get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of(ListChangesOption.CHANGE_ACTIONS, ListChangesOption.ALL_REVISIONS)); if (!fg) { call.background(); } call.get(cb); }


void set(com.google.gerrit.client.ui.CommentLinkProcessor commentLinkProcessor, com.google.gerrit.client.info.ChangeInfo change, java.lang.String revision) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo revInfo = change.revision(revision); com.google.gerrit.client.info.ChangeInfo.CommitInfo commit = revInfo.commit(); commitName.setText(revision); idText.setText(("Change-Id: " + (change.changeId()))); idText.setPreviewText(change.changeId()); com.google.gerrit.client.change.CommitBox.formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change); com.google.gerrit.client.change.CommitBox.formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change); text.setHTML(commentLinkProcessor.apply(new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder().append(commit.message()).linkify())); setWebLinks(change, revision, revInfo); if ((revInfo.commit().parents().length()) > 1) { mergeCommit.setVisible(true); } setParents(change.project(), revInfo.commit().parents()); }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); com.google.gerrit.server.project.ChangeControl ctl = ctx.getChangeControl(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getChangeUpdate(); com.google.gerrit.server.ChangeUtil.insertAncestors(db, patchSet.getId(), commit); if ((patchSet.getGroups()) == null) { patchSet.setGroups(com.google.gerrit.server.git.GroupCollector.getDefaultGroups(patchSet)); } db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctx.getChangeControl(), approvals); if ((message) != null) { changeMessage = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId()); changeMessage.setMessage(message); cmUtil.addChangeMessage(db, update, changeMessage); } if (((hashtags) != null) && ((hashtags.size()) > 0)) { try { com.google.gerrit.extensions.api.changes.HashtagsInput input = new com.google.gerrit.extensions.api.changes.HashtagsInput(); input.add = hashtags; hashtagsUtil.setHashtags(ctl, input, false, false); } catch (com.google.gerrit.server.validators.ValidationException | com.google.gerrit.extensions.restapi.AuthException e) { com.google.gerrit.server.change.ChangeInserter.log.error(("Cannot add hashtags to change " + (change.getId())), e); } } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { if (sendMail) { java.lang.Runnable sender = new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create(change.getId()); cm.setFrom(change.getOwner()); cm.setPatchSet(patchSet, patchSetInfo); cm.addReviewers(reviewers); cm.addExtraCC(extraCC); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.ChangeInserter.log.error(("Cannot send email for new change " + (change.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newchange"; } }; if ((requestScopePropagator) != null) { workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender)); } else { sender.run(); } } if (runHooks) { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); hooks.doPatchsetCreatedHook(change, patchSet, db); if (((hashtags) != null) && ((hashtags.size()) > 0)) { hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db); } if (((approvals) != null) && (!(approvals.isEmpty()))) { hooks.doCommentAddedHook(change, ((com.google.gerrit.server.IdentifiedUser) (refControl.getCurrentUser())).getAccount(), patchSet, null, approvals, db); } } }

java.lang.StringBuilder refPrefixBuilder() { java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES); int m = (id) % 100; if (m < 10) { r.append('0'); } r.append(m); r.append('/'); r.append(id); r.append('/'); return r; }




private com.google.gerrit.reviewdb.client.PatchSet updateDraftPatchSet(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return dbProvider.get().patchSets().atomicUpdate(rsrc.getPatchSet().getId(), new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.PatchSet>() { @java.lang.Override public com.google.gerrit.reviewdb.client.PatchSet update(com.google.gerrit.reviewdb.client.PatchSet patchset) { patchset.setDraft(false); return patchset; } }); }
private com.google.gerrit.extensions.auth.oauth.OAuthUserInfo getAsOAuthUserInfo(com.googlesource.gerrit.plugins.cfoauth.AccessToken accessToken, java.lang.String displayName) { return new com.google.gerrit.extensions.auth.oauth.OAuthUserInfo(accessToken.getExternalId(), accessToken.getUserName(), accessToken.getEmailAddress(), displayName, null); }

@java.lang.Override public com.google.gerrit.extensions.auth.oauth.OAuthUserInfo getUserInfo(com.google.gerrit.extensions.auth.oauth.OAuthToken token) throws java.io.IOException { com.googlesource.gerrit.plugins.cfoauth.AccessToken accessToken = uaaClient.toAccessToken(token.getToken()); java.lang.String displayName = uaaClient.getDisplayName(token.getToken()); return getAsOAuthUserInfo(accessToken, displayName); }




public java.lang.String getDisplayName(java.lang.String accessToken) { org.scribe.model.OAuthRequest request = new org.scribe.model.OAuthRequest(GET, userInfoEndpoint); request.addHeader(com.googlesource.gerrit.plugins.cfoauth.UAAClient.AUTHORIZATION_HEADER, (((com.googlesource.gerrit.plugins.cfoauth.UAAClient.BEARER_AUTHENTICATION) + " ") + accessToken)); org.scribe.model.Response response = request.send(); if ((response.getCode()) != (java.net.HttpURLConnection.HTTP_OK)) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException(java.text.MessageFormat.format("GET /userinfo failed with status {0}", response.getCode())); } com.google.gson.JsonObject userInfoResponse = getAsJsonObject(response.getBody()); return getAttribute(userInfoResponse, com.googlesource.gerrit.plugins.cfoauth.UAAClient.NAME_ATTRIBUTE); }
public com.googlesource.gerrit.plugins.cfoauth.AccessToken toAccessToken(java.lang.String accessToken) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { com.google.gson.JsonObject jsonWebToken = toJsonWebToken(accessToken); long expiresAt = getLongAttribute(jsonWebToken, com.googlesource.gerrit.plugins.cfoauth.UAAClient.EXP_ATTRIBUTE, 0); java.lang.String username = getAttribute(jsonWebToken, com.googlesource.gerrit.plugins.cfoauth.UAAClient.USER_NAME_ATTRIBUTE); if (username == null) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException("Invalid token: missing or invalid 'user_name' attribute"); } java.lang.String emailAddress = getAttribute(jsonWebToken, com.googlesource.gerrit.plugins.cfoauth.UAAClient.EMAIL_ATTRIBUTE); if (emailAddress == null) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException("Invalid token: missing or invalid 'email' attribute"); } return new com.googlesource.gerrit.plugins.cfoauth.AccessToken(accessToken, username, emailAddress, expiresAt); }
public com.googlesource.gerrit.plugins.cfoauth.AccessToken getAccessToken(java.lang.String authorizationCode) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { org.scribe.model.OAuthRequest request = new org.scribe.model.OAuthRequest(POST, accessTokenEndpoint); request.addHeader(com.googlesource.gerrit.plugins.cfoauth.UAAClient.AUTHORIZATION_HEADER, clientCredentials); request.addBodyParameter(com.googlesource.gerrit.plugins.cfoauth.UAAClient.GRANT_TYPE, com.googlesource.gerrit.plugins.cfoauth.UAAClient.BY_AUTHORIZATION_CODE); request.addBodyParameter(com.googlesource.gerrit.plugins.cfoauth.CODE, authorizationCode); request.addBodyParameter(com.googlesource.gerrit.plugins.cfoauth.REDIRECT_URI, redirectUrl); org.scribe.model.Response response = request.send(); if ((response.getCode()) != (java.net.HttpURLConnection.HTTP_OK)) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException(java.text.MessageFormat.format("POST /oauth/token failed with status {0}", response.getCode())); } return parseAccessTokenResponse(response.getBody()); }



public com.google.gerrit.reviewdb.client.Change.Id addCommitToChange(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Project project, final org.eclipse.jgit.lib.Repository git, final java.lang.String destinationBranch, final com.google.gerrit.reviewdb.client.Account.Id pullRequestOwner, final org.eclipse.jgit.revwalk.RevCommit pullRequestCommit, final java.lang.String pullRequestMesage, final java.lang.String topic, boolean doValidation) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { com.google.gerrit.reviewdb.client.Change.Id newChange = null; if ((destinationBranch == null) || ((destinationBranch.length()) == 0)) { throw new com.google.gerrit.server.project.InvalidChangeOperationException("Destination branch cannot be null or empty"); } com.google.gerrit.server.project.RefControl refControl = projectControlFactory.controlFor(project.getNameKey()).controlForRef(destinationBranch); try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(git)) { try { org.eclipse.jgit.lib.Ref destRef = git.getRef(destinationBranch); if (destRef == null) { throw new com.google.gerrit.server.project.InvalidChangeOperationException((("Branch " + destinationBranch) + " does not exist.")); } java.lang.String pullRequestSha1 = pullRequestCommit.getId().getName(); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> existingPatchSet = db.patchSets().byRevision(new com.google.gerrit.reviewdb.client.RevId(pullRequestSha1)); java.util.Iterator<com.google.gerrit.reviewdb.client.PatchSet> patchSetIterator = existingPatchSet.iterator(); if (patchSetIterator.hasNext()) { com.google.gerrit.reviewdb.client.PatchSet patchSet = patchSetIterator.next(); com.googlesource.gerrit.plugins.github.git.PullRequestCreateChange.LOG.debug(((((("Pull request commit ID " + pullRequestSha1) + " has been already uploaded as PatchSetID=") + (patchSet.getPatchSetId())) + " in ChangeID=") + (patchSet.getId()))); return null; } com.google.gerrit.reviewdb.client.Change.Key changeKey; final java.util.List<java.lang.String> idList = pullRequestCommit.getFooterLines(com.googlesource.gerrit.plugins.github.git.PullRequestCreateChange.CHANGE_ID); if (!(idList.isEmpty())) { final java.lang.String idStr = idList.get(((idList.size()) - 1)).trim(); changeKey = new com.google.gerrit.reviewdb.client.Change.Key(idStr); } else { final org.eclipse.jgit.lib.ObjectId computedChangeId = org.eclipse.jgit.util.ChangeIdUtil.computeChangeId(pullRequestCommit.getTree(), pullRequestCommit, pullRequestCommit.getAuthorIdent(), pullRequestCommit.getCommitterIdent(), pullRequestMesage); changeKey = new com.google.gerrit.reviewdb.client.Change.Key(("I" + (computedChangeId.name()))); } java.util.List<com.google.gerrit.server.query.change.ChangeData> destChanges = queryProvider.get().byBranchKey(new com.google.gerrit.reviewdb.client.Branch.NameKey(project.getNameKey(), destRef.getName()), changeKey); if ((destChanges.size()) > 1) { throw new com.google.gerrit.server.project.InvalidChangeOperationException(((("Multiple Changes with Change-ID " + changeKey) + " already exist on the target branch: cannot add a new patch-set ") + destinationBranch)); } else if ((destChanges.size()) == 1) { com.google.gerrit.reviewdb.client.Change destChange = destChanges.get(0).change(); com.google.gerrit.server.project.ChangeControl changeControl = projectControlFactory.controlFor(project.getNameKey()).controlFor(destChange).forUser(userFactory.create(pullRequestOwner)); return insertPatchSet(git, revWalk, destChange, pullRequestCommit, changeControl, pullRequestOwner, pullRequestMesage, doValidation); } else { return newChange = createNewChange(db, git, revWalk, changeKey, project.getNameKey(), destRef, pullRequestOwner, pullRequestCommit, refControl, pullRequestMesage, topic, doValidation); } } finally { if (newChange == null) { db.rollback(); } } } finally { git.close(); } }
private void validate(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevCommit pullRequestCommit, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.reviewdb.client.PatchSet newPatchSet) throws com.google.gerrit.server.project.InvalidChangeOperationException { com.google.gerrit.server.git.validators.CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new com.google.gerrit.server.ssh.NoSshInfo(), git); com.google.gerrit.server.events.CommitReceivedEvent commitReceivedEvent = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), pullRequestCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), pullRequestCommit, currentUser); try { commitValidators.validateForGerritCommits(commitReceivedEvent); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.server.project.InvalidChangeOperationException(e.getMessage()); } }
private static boolean guessJavaScriptClipboard() { java.lang.String ua = Window.Navigator.getUserAgent(); int chrome = com.google.gwtexpui.user.client.UserAgent.major(ua, "Chrome/"); if (chrome > 0) { return 42 <= chrome; } int ff = com.google.gwtexpui.user.client.UserAgent.major(ua, "Firefox/"); if (ff > 0) { return 41 <= ff; } int opera = com.google.gwtexpui.user.client.UserAgent.major(ua, "OPR/"); if (opera > 0) { return 29 <= opera; } int msie = com.google.gwtexpui.user.client.UserAgent.major(ua, "MSIE "); if (msie > 0) { return 9 <= msie; } if (com.google.gwtexpui.user.client.UserAgent.nativeHasCopy()) { return true; } return false; }
private java.lang.Runnable save() { return new java.lang.Runnable() { @java.lang.Override public void run() { if (!(cm.isClean(generation))) { close.setEnabled(false); java.lang.String text = cm.getValue(); final int g = cm.changeGeneration(false); com.google.gerrit.client.changes.ChangeEditApi.put(revision.getParentKey().get(), path, text, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { generation = g; setClean(cm.isClean(g)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { close.setEnabled(true); } }); } } }; }
@java.lang.Override public void run() { if (!(cm.isClean(generation))) { close.setEnabled(false); java.lang.String text = cm.getValue(); final int g = cm.changeGeneration(false); com.google.gerrit.client.changes.ChangeEditApi.put(revision.getParentKey().get(), path, text, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { generation = g; setClean(cm.isClean(g)); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { close.setEnabled(true); } }); } }
private void loadOrganisations(java.lang.String username, com.google.common.collect.Multimap<java.lang.String, java.lang.String> orgsTeams, com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin) throws java.io.IOException { com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.debug("Getting list of public organisations for user '{}'", username); java.util.Set<java.lang.String> organisations = ghLogin.getMyOrganisationsLogins(); for (java.lang.String org : organisations) { orgsTeams.put(org, com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.EVERYONE_TEAM_NAME); } }
@java.lang.Override public com.google.common.collect.Multimap<java.lang.String, java.lang.String> load(java.lang.String username) throws java.lang.Exception { com.google.common.collect.Multimap<java.lang.String, java.lang.String> orgsTeams = com.google.common.collect.HashMultimap.create(); com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin = ghLoginProvider.get(username); if (ghLogin == null) { com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.warn("Cannot login to GitHub on behalf of '{}'", username); return orgsTeams; } try { loadOrganisationsAndTeams(username, orgsTeams, ghLogin); } catch (java.io.FileNotFoundException teamsNotFound) { com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.info("Cannot access teams for user '{}': falling back to list of public organisations", username); loadOrganisations(username, orgsTeams, ghLogin); } com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.debug("GitHub user '{}' belongs to: {}", username, orgsTeams); return orgsTeams; }
private void loadOrganisationsAndTeams(java.lang.String username, com.google.common.collect.Multimap<java.lang.String, java.lang.String> orgsTeams, com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin) throws java.io.IOException { com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.OrganisationLoader.log.debug("Getting list of organisations/teams for user '{}'", username); java.util.Map<java.lang.String, java.util.Set<org.kohsuke.github.GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams(); for (java.util.Map.Entry<java.lang.String, java.util.Set<org.kohsuke.github.GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) { orgsTeams.put(teamsOrg.getKey(), com.googlesource.gerrit.plugins.github.group.GitHubGroupsCache.EVERYONE_TEAM_NAME); for (org.kohsuke.github.GHTeam team : teamsOrg.getValue()) { orgsTeams.put(teamsOrg.getKey(), team.getName()); } } }
public org.eclipse.jgit.transport.CredentialsProvider getCredentialsProvider() { return new org.eclipse.jgit.transport.CredentialsProvider() { @java.lang.Override public boolean supports(org.eclipse.jgit.transport.CredentialItem... items) { for (org.eclipse.jgit.transport.CredentialItem i : items) { if (i instanceof org.eclipse.jgit.transport.CredentialItem.Username) { continue; } else if (i instanceof org.eclipse.jgit.transport.CredentialItem.Password) { continue; } else { return false; } } return true; } @java.lang.Override public boolean isInteractive() { return false; } @java.lang.Override public boolean get(org.eclipse.jgit.transport.URIish uri, org.eclipse.jgit.transport.CredentialItem... items) throws org.eclipse.jgit.errors.UnsupportedCredentialItem { java.lang.String username = uri.getUser(); if (username == null) { username = com.googlesource.gerrit.plugins.github.git.GitHubRepository.this.username; } if (username == null) { return false; } java.lang.String password = com.googlesource.gerrit.plugins.github.git.GitHubRepository.this.password; if (password == null) { return false; } for (org.eclipse.jgit.transport.CredentialItem i : items) { if (i instanceof org.eclipse.jgit.transport.CredentialItem.Username) { ((org.eclipse.jgit.transport.CredentialItem.Username) (i)).setValue(username); } else if (i instanceof org.eclipse.jgit.transport.CredentialItem.Password) { ((org.eclipse.jgit.transport.CredentialItem.Password) (i)).setValue(password.toCharArray()); } else { throw new org.eclipse.jgit.errors.UnsupportedCredentialItem(uri, i.getPromptText()); } } return true; } }; }
@java.lang.Override public boolean get(org.eclipse.jgit.transport.URIish uri, org.eclipse.jgit.transport.CredentialItem... items) throws org.eclipse.jgit.errors.UnsupportedCredentialItem { java.lang.String username = uri.getUser(); if (username == null) { username = this.username; } if (username == null) { return false; } java.lang.String password = this.password; if (password == null) { return false; } for (org.eclipse.jgit.transport.CredentialItem i : items) { if (i instanceof org.eclipse.jgit.transport.CredentialItem.Username) { ((org.eclipse.jgit.transport.CredentialItem.Username) (i)).setValue(username); } else if (i instanceof org.eclipse.jgit.transport.CredentialItem.Password) { ((org.eclipse.jgit.transport.CredentialItem.Password) (i)).setValue(password.toCharArray()); } else { throw new org.eclipse.jgit.errors.UnsupportedCredentialItem(uri, i.getPromptText()); } } return true; }
public com.google.gerrit.reviewdb.client.Account.Id importAccount(java.lang.String login, java.lang.String name, java.lang.String email) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.get()) { com.google.gerrit.server.account.CreateAccount createAccount = createAccountFactory.create(login); com.google.gerrit.server.account.CreateAccount.Input accountInput = new com.google.gerrit.server.account.CreateAccount.Input(); accountInput.email = email; accountInput.username = login; accountInput.name = com.google.common.base.MoreObjects.firstNonNull(name, login); com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> accountResponse = ((com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo>) (createAccount.apply(TopLevelResource.INSTANCE, accountInput))); if ((accountResponse.statusCode()) == (org.apache.http.HttpStatus.SC_CREATED)) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(accountResponse.value()._accountId); db.accountExternalIds().insert(java.util.Arrays.asList(new com.google.gerrit.reviewdb.client.AccountExternalId(accountId, new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GERRIT, login)))); return accountId; } else { throw new java.io.IOException(((("Cannot import GitHub account " + login) + ": HTTP Status ") + (accountResponse.statusCode()))); } } }
private void assertRelated(com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.server.change.GetRelated.ChangeAndCommit... expected) throws java.lang.Exception { java.util.List<com.google.gerrit.server.change.GetRelated.ChangeAndCommit> actual = getRelated(psId); assertThat(actual).hasSize(expected.length); for (int i = 0; i < (actual.size()); i++) { java.lang.String name = (("index " + i) + " related to ") + psId; com.google.gerrit.server.change.GetRelated.ChangeAndCommit a = actual.get(i); com.google.gerrit.server.change.GetRelated.ChangeAndCommit e = expected[i]; assertThat(a.changeId).named(("Change-Id of " + name)).isEqualTo(e.changeId); assertThat(a.commit.commit).named(("commit of " + name)).isEqualTo(e.commit.commit); assertThat(a._revisionNumber).named(("revision of " + name)).isEqualTo(e._revisionNumber); assertThat(a._currentRevisionNumber).named(("current revision of " + name)).isEqualTo(e._currentRevisionNumber); } }






private com.google.gerrit.gpg.CheckResult checkBasic(org.bouncycastle.openpgp.PGPPublicKey key) { java.util.List<java.lang.String> problems = new java.util.ArrayList<>(2); if (key.isRevoked()) { problems.add("Key is revoked"); } long validSecs = key.getValidSeconds(); if (validSecs != 0) { long createdSecs = (key.getCreationTime().getTime()) / 1000; long nowSecs = (java.lang.System.currentTimeMillis()) / 1000; if ((nowSecs - createdSecs) > validSecs) { problems.add("Key is expired"); } } return com.google.gerrit.gpg.CheckResult.create(problems); }

@org.junit.Test public void selfRevokedKey() throws java.lang.Exception { assertProblems(com.google.gerrit.gpg.testutil.TestKeys.selfRevokedKey(), "Key is revoked"); }

public final com.google.gerrit.gpg.CheckResult check(org.bouncycastle.openpgp.PGPPublicKey key) { return check(key, null, 0, false, null); }
@org.junit.Test public void expiredKey() throws java.lang.Exception { assertProblems(com.google.gerrit.gpg.testutil.TestKeys.key3(), "Key is expired"); }
@org.junit.Test public void selfRevokedKey() throws java.lang.Exception { assertProblems(com.google.gerrit.gpg.testutil.TestKeys.key4(), "Key is revoked"); }
private com.google.gerrit.gpg.CheckResult checkBasic(org.bouncycastle.openpgp.PGPPublicKey key) { java.util.List<java.lang.String> problems = new java.util.ArrayList<>(2); checkRevocation(key, problems); long validSecs = key.getValidSeconds(); if (validSecs != 0) { long createdSecs = (key.getCreationTime().getTime()) / 1000; long nowSecs = (java.lang.System.currentTimeMillis()) / 1000; if ((nowSecs - createdSecs) > validSecs) { problems.add("Key is expired"); } } return com.google.gerrit.gpg.CheckResult.create(problems); }
private com.google.gerrit.gpg.PushCertificateChecker.Result checkSignature(org.bouncycastle.openpgp.PGPSignature sig, org.eclipse.jgit.transport.PushCertificate cert, com.google.gerrit.gpg.PublicKeyStore store) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { org.bouncycastle.openpgp.PGPPublicKeyRingCollection keys = store.get(sig.getKeyID()); if (!(keys.getKeyRings().hasNext())) { return new com.google.gerrit.gpg.PushCertificateChecker.Result(null, com.google.gerrit.gpg.CheckResult.bad(("No public keys found for key ID " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))))); } org.bouncycastle.openpgp.PGPPublicKey signer = com.google.gerrit.gpg.PublicKeyStore.getSigner(keys, sig, org.eclipse.jgit.lib.Constants.encode(cert.toText())); if (signer == null) { return new com.google.gerrit.gpg.PushCertificateChecker.Result(null, com.google.gerrit.gpg.CheckResult.bad((("Signature by " + (com.google.gerrit.gpg.PublicKeyStore.keyIdToString(sig.getKeyID()))) + " is not valid"))); } com.google.gerrit.gpg.CheckResult result = publicKeyChecker.check(signer); if (!(result.getProblems().isEmpty())) { java.lang.StringBuilder err = new java.lang.StringBuilder("Invalid public key ").append(com.google.gerrit.gpg.PublicKeyStore.keyToString(signer)).append(":\n ").append(com.google.common.base.Joiner.on("\n ").join(result.getProblems())); return new com.google.gerrit.gpg.PushCertificateChecker.Result(signer, com.google.gerrit.gpg.CheckResult.create(result.getStatus(), err.toString())); } return new com.google.gerrit.gpg.PushCertificateChecker.Result(signer, result); }
private void checkRevocations(org.bouncycastle.openpgp.PGPPublicKey key, java.util.List<org.bouncycastle.openpgp.PGPSignature> revocations, java.util.Map<java.lang.Long, org.bouncycastle.bcpg.sig.RevocationKey> revokers, java.util.List<java.lang.String> problems) throws java.io.IOException, org.bouncycastle.openpgp.PGPException { for (org.bouncycastle.openpgp.PGPSignature revocation : revocations) { org.bouncycastle.bcpg.sig.RevocationKey revoker = revokers.get(revocation.getKeyID()); if (revoker == null) { continue; } org.bouncycastle.openpgp.PGPPublicKeyRing rkr = store.get(revoker.getFingerprint()); if ((rkr == null) || ((rkr.getPublicKey().getAlgorithm()) != (revoker.getAlgorithm()))) { continue; } revocation.init(new org.bouncycastle.openpgp.operator.bc.BcPGPContentVerifierBuilderProvider(), rkr.getPublicKey()); if (revocation.verifyCertification(key)) { problems.add(com.google.gerrit.gpg.PublicKeyChecker.reasonToString(com.google.gerrit.gpg.PublicKeyChecker.getRevocationReason(revocation))); } } }


private void checkRevocation(org.bouncycastle.openpgp.PGPPublicKey key, java.util.List<java.lang.String> problems) { try { java.util.List<org.bouncycastle.openpgp.PGPSignature> revocations = new java.util.ArrayList<>(); java.util.Map<java.lang.Long, org.bouncycastle.bcpg.sig.RevocationKey> revokers = new java.util.HashMap<>(); org.bouncycastle.openpgp.PGPSignature selfRevocation = scanRevocations(key, revocations, revokers); if (selfRevocation != null) { problems.add(com.google.gerrit.gpg.PublicKeyChecker.reasonToString(com.google.gerrit.gpg.PublicKeyChecker.getRevocationReason(selfRevocation))); } else { checkRevocations(key, revocations, revokers, problems); } } catch (org.bouncycastle.openpgp.PGPException | java.io.IOException e) { problems.add("Error checking key revocation"); } }
@org.junit.Test public void revokedByKeyNotPresentInStore() throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey k = add(revokedCompromisedKey()); save(); assertProblems(k); }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(signedOffBy, result.useSignedOffBy()); setBool(contentMerge, result.useContentMerge()); setBool(newChangeForAllNotInTarget, result.createNewChangeForAllNotInTarget()); setBool(requireChangeID, result.requireChangeId()); if ((enableSignedPush) != null) { setBool(enableSignedPush, result.enableSignedPush()); } setSubmitType(result.submitType()); setState(result.state()); maxObjectSizeLimit.setText(result.maxObjectSizeLimit().configuredValue()); if ((result.maxObjectSizeLimit().inheritedValue()) != null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value())); effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.maxObjectSizeLimit().inheritedValue())); } else { effectiveMaxObjectSizeLimit.setVisible(false); } saveProject.setEnabled(false); initPluginOptions(result); initProjectActions(result); }
private java.lang.String buildJsonRaw(java.lang.String path, java.lang.String additionalQueryString) throws java.lang.Exception { com.google.gitiles.FakeHttpServletResponse res = buildResponse(path, ("format=json" + additionalQueryString), com.google.gitiles.SC_OK); assertThat(res.getHeader(HttpHeaders.CONTENT_TYPE)).isEqualTo("application/json"); java.lang.String body = res.getActualBodyString(); java.lang.String magic = ")]}\'\n"; assertThat(body).startsWith(magic); return body.substring(magic.length()); }
private void verifyJsonCommit(com.google.gitiles.CommitJsonData.Commit jsonCommit, org.eclipse.jgit.revwalk.RevCommit commit, com.google.gitiles.DateFormatter df) throws java.lang.Exception { assertThat(jsonCommit.commit).isEqualTo(commit.name()); assertThat(jsonCommit.tree).isEqualTo(commit.getTree().name()); java.util.ArrayList<java.lang.String> expectedParents = new java.util.ArrayList<>(); for (int i = 0; i < (commit.getParentCount()); i++) { expectedParents.add(commit.getParent(i).name()); } assertThat(jsonCommit.parents).containsExactlyElementsIn(expectedParents); assertThat(jsonCommit.author.name).isEqualTo(commit.getAuthorIdent().getName()); assertThat(jsonCommit.author.email).isEqualTo(commit.getAuthorIdent().getEmailAddress()); assertThat(jsonCommit.author.time).isEqualTo(df.format(commit.getAuthorIdent())); assertThat(jsonCommit.committer.name).isEqualTo(commit.getCommitterIdent().getName()); assertThat(jsonCommit.committer.email).isEqualTo(commit.getCommitterIdent().getEmailAddress()); assertThat(jsonCommit.committer.time).isEqualTo(df.format(commit.getCommitterIdent())); assertThat(jsonCommit.message).isEqualTo(commit.getFullMessage()); }
@org.junit.Test public void basicLog() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit commit = repo.branch("HEAD").commit().create(); repo.getRevWalk().parseBody(commit); com.google.gson.JsonElement result = buildJson("/repo/+log", ""); com.google.gson.JsonArray log = result.getAsJsonObject().get("log").getAsJsonArray(); com.google.gitiles.GitilesAccess access = new com.google.gitiles.TestGitilesAccess(repo.getRepository()).forRequest(null); com.google.gitiles.DateFormatter df = new com.google.gitiles.DateFormatter(access, com.google.gitiles.DateFormatter.Format.DEFAULT); assertThat(log).hasSize(1); com.google.gitiles.CommitJsonData.Commit jsonCommit = getJsonCommit(log.get(0)); verifyJsonCommit(jsonCommit, commit, df); assertThat(jsonCommit.treeDiff).isNull(); }
@org.junit.Test public void treeDiffLog() throws java.lang.Exception { java.lang.String contents1 = "foo\n"; java.lang.String contents2 = "foo\ncontents\n"; org.eclipse.jgit.revwalk.RevCommit c1 = repo.update("master", repo.commit().add("foo", contents1)); org.eclipse.jgit.revwalk.RevCommit c2 = repo.update("master", repo.commit().parent(c1).add("foo", contents2)); repo.getRevWalk().parseBody(c1); repo.getRevWalk().parseBody(c2); com.google.gson.JsonElement result = buildJson("/repo/+log/master", "&name-status=1"); com.google.gson.JsonArray log = result.getAsJsonObject().get("log").getAsJsonArray(); com.google.gitiles.GitilesAccess access = new com.google.gitiles.TestGitilesAccess(repo.getRepository()).forRequest(null); com.google.gitiles.DateFormatter df = new com.google.gitiles.DateFormatter(access, com.google.gitiles.DateFormatter.Format.DEFAULT); assertThat(log).hasSize(2); com.google.gitiles.CommitJsonData.Commit jsonCommit2 = getJsonCommit(log.get(0)); verifyJsonCommit(jsonCommit2, c2, df); assertThat(jsonCommit2.treeDiff).hasSize(1); assertThat(jsonCommit2.treeDiff.get(0).type).isEqualTo("modify"); assertThat(jsonCommit2.treeDiff.get(0).oldPath).isEqualTo("foo"); assertThat(jsonCommit2.treeDiff.get(0).newPath).isEqualTo("foo"); com.google.gitiles.CommitJsonData.Commit jsonCommit1 = getJsonCommit(log.get(1)); verifyJsonCommit(jsonCommit1, c1, df); assertThat(jsonCommit1.treeDiff.get(0).type).isEqualTo("add"); assertThat(jsonCommit1.treeDiff.get(0).oldPath).isEqualTo("/dev/null"); assertThat(jsonCommit1.treeDiff.get(0).newPath).isEqualTo("foo"); }
@org.junit.Test public void basicLog() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit commit = repo.branch("HEAD").commit().create(); repo.getRevWalk().parseBody(commit); Log log = buildJson("/repo/+log", com.google.gitiles.LogServletTest.LOG.getType(), ""); assertThat(log.log).hasSize(1); verifyJsonCommit(log.log.get(0), commit); assertThat(log.log.get(0).treeDiff).isNull(); }
@org.junit.Test public void treeDiffLog() throws java.lang.Exception { java.lang.String contents1 = "foo\n"; java.lang.String contents2 = "foo\ncontents\n"; org.eclipse.jgit.revwalk.RevCommit c1 = repo.update("master", repo.commit().add("foo", contents1)); org.eclipse.jgit.revwalk.RevCommit c2 = repo.update("master", repo.commit().parent(c1).add("foo", contents2)); repo.getRevWalk().parseBody(c1); repo.getRevWalk().parseBody(c2); Log log = buildJson("/repo/+log/master", com.google.gitiles.LogServletTest.LOG.getType(), "&name-status=1"); assertThat(log.log).hasSize(2); Commit jc2 = log.log.get(0); verifyJsonCommit(jc2, c2); assertThat(jc2.treeDiff).hasSize(1); assertThat(jc2.treeDiff.get(0).type).isEqualTo("modify"); assertThat(jc2.treeDiff.get(0).oldPath).isEqualTo("foo"); assertThat(jc2.treeDiff.get(0).newPath).isEqualTo("foo"); Commit jc1 = log.log.get(1); verifyJsonCommit(jc1, c1); assertThat(jc1.treeDiff).hasSize(1); assertThat(jc1.treeDiff.get(0).type).isEqualTo("add"); assertThat(jc1.treeDiff.get(0).oldPath).isEqualTo("/dev/null"); assertThat(jc1.treeDiff.get(0).newPath).isEqualTo("foo"); }
@org.junit.Test public void basicLog() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit commit = repo.branch("HEAD").commit().create(); repo.getRevWalk().parseBody(commit); Log log = buildJson("/repo/+log", com.google.gitiles.LogServletTest.LOG, ""); assertThat(log.log).hasSize(1); verifyJsonCommit(log.log.get(0), commit); assertThat(log.log.get(0).treeDiff).isNull(); }
@org.junit.Test public void treeDiffLog() throws java.lang.Exception { java.lang.String contents1 = "foo\n"; java.lang.String contents2 = "foo\ncontents\n"; org.eclipse.jgit.revwalk.RevCommit c1 = repo.update("master", repo.commit().add("foo", contents1)); org.eclipse.jgit.revwalk.RevCommit c2 = repo.update("master", repo.commit().parent(c1).add("foo", contents2)); repo.getRevWalk().parseBody(c1); repo.getRevWalk().parseBody(c2); Log log = buildJson("/repo/+log/master", com.google.gitiles.LogServletTest.LOG, "&name-status=1"); assertThat(log.log).hasSize(2); Commit jc2 = log.log.get(0); verifyJsonCommit(jc2, c2); assertThat(jc2.treeDiff).hasSize(1); assertThat(jc2.treeDiff.get(0).type).isEqualTo("modify"); assertThat(jc2.treeDiff.get(0).oldPath).isEqualTo("foo"); assertThat(jc2.treeDiff.get(0).newPath).isEqualTo("foo"); Commit jc1 = log.log.get(1); verifyJsonCommit(jc1, c1); assertThat(jc1.treeDiff).hasSize(1); assertThat(jc1.treeDiff.get(0).type).isEqualTo("add"); assertThat(jc1.treeDiff.get(0).oldPath).isEqualTo("/dev/null"); assertThat(jc1.treeDiff.get(0).newPath).isEqualTo("foo"); }


private void savePluginSections(org.eclipse.jgit.lib.Config rc) { java.util.List<java.lang.String> existing = com.google.common.collect.Lists.newArrayList(rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)); for (java.lang.String name : existing) { rc.unsetSection(com.google.gerrit.server.git.ProjectConfig.PLUGIN, name); } for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Config> e : pluginConfigs.entrySet()) { java.lang.String plugin = e.getKey(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); for (java.lang.String name : pluginConfig.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(pluginConfig.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } }

public void publish(com.google.gerrit.server.edit.ChangeEdit edit) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change change = edit.getChange(); try (org.eclipse.jgit.lib.Repository repo = gitManager.openRepository(change.getProject());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);org.eclipse.jgit.lib.ObjectInserter inserter = repo.newObjectInserter()) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = edit.getBasePatchSet(); if (!(basePatchSet.getId().equals(change.currentPatchSetId()))) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("only edit for current patch set can be published"); } insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet)); com.google.gerrit.server.edit.ChangeEditUtil.deleteRef(repo, edit); } }
private static org.eclipse.jgit.diff.RawTextComparator comparatorFor(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace ws) { switch (ws) { case IGNORE_ALL_SPACE : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_ALL; case IGNORE_SPACE_AT_EOL : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_TRAILING; case IGNORE_SPACE_CHANGE : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_CHANGE; case IGNORE_NONE : default : return org.eclipse.jgit.diff.RawTextComparator.DEFAULT; } }
private void initIgnoreWhitespace(com.google.gwt.user.client.ui.ListBox ws) { ws.addItem(PatchUtil.C.whitespaceIGNORE_NONE(), Whitespace.IGNORE_NONE.name()); ws.addItem(PatchUtil.C.whitespaceIGNORE_SPACE_AT_EOL(), Whitespace.IGNORE_SPACE_AT_EOL.name()); ws.addItem(PatchUtil.C.whitespaceIGNORE_SPACE_CHANGE(), Whitespace.IGNORE_SPACE_CHANGE.name()); ws.addItem(PatchUtil.C.whitespaceIGNORE_ALL_SPACE(), Whitespace.IGNORE_ALL_SPACE.name()); }
public com.google.gerrit.client.diff.DiffApi ignoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace w) { switch (w) { default : case IGNORE_NONE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.NONE); case IGNORE_SPACE_AT_EOL : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.TRAILING); case IGNORE_SPACE_CHANGE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.CHANGED); case IGNORE_ALL_SPACE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.ALL); } }
private void initIgnoreWhitespace() { ignoreWhitespace.addItem(PatchUtil.C.whitespaceIGNORE_NONE(), com.google.gerrit.client.diff.IGNORE_NONE.name()); ignoreWhitespace.addItem(PatchUtil.C.whitespaceIGNORE_SPACE_AT_EOL(), com.google.gerrit.client.diff.IGNORE_SPACE_AT_EOL.name()); ignoreWhitespace.addItem(PatchUtil.C.whitespaceIGNORE_SPACE_CHANGE(), com.google.gerrit.client.diff.IGNORE_SPACE_CHANGE.name()); ignoreWhitespace.addItem(PatchUtil.C.whitespaceIGNORE_ALL_SPACE(), com.google.gerrit.client.diff.IGNORE_ALL_SPACE.name()); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to members of Modify Accounts"); } try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId()); p.load(git); return loadSection(p.getConfig(), UserConfigSections.EDIT, null, new com.google.gerrit.extensions.client.EditPreferencesInfo(), com.google.gerrit.extensions.client.EditPreferencesInfo.defaults()); } }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.EditPreferencesInfo in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to members of Modify Accounts"); } if (in == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("input must be provided"); } com.google.gerrit.reviewdb.client.Account.Id accountId = rsrc.getUser().getAccountId(); com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName); com.google.gerrit.server.account.VersionedAccountPreferences prefs; try { prefs = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(accountId); prefs.load(md); storeSection(prefs.getConfig(), UserConfigSections.EDIT, null, in, com.google.gerrit.extensions.client.EditPreferencesInfo.defaults()); prefs.commit(md); } finally { md.close(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.IdentifiedUser runAs(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.server.CurrentUser caller) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, remotePeerProvider, dbProvider, id, caller); }
public final com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace ignoreWhitespace() { java.lang.String s = ignoreWhitespaceRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.valueOf(s) : com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE; }
public static com.google.gerrit.client.account.DiffPreferences create(com.google.gerrit.reviewdb.client.AccountDiffPreference in) { com.google.gerrit.client.account.DiffPreferences p = createObject().cast(); if (in == null) { in = com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(null); } p.ignoreWhitespace(in.getIgnoreWhitespace()); p.tabSize(in.getTabSize()); p.lineLength(in.getLineLength()); p.context(in.getContext()); p.intralineDifference(in.isIntralineDifference()); p.showLineEndings(in.isShowLineEndings()); p.showTabs(in.isShowTabs()); p.showWhitespaceErrors(in.isShowWhitespaceErrors()); p.syntaxHighlighting(in.isSyntaxHighlighting()); p.hideTopMenu(in.isHideTopMenu()); p.autoHideDiffTableHeader(in.isAutoHideDiffTableHeader()); p.hideLineNumbers(in.isHideLineNumbers()); p.expandAllComments(in.isExpandAllComments()); p.manualReview(in.isManualReview()); p.renderEntireFile(in.isRenderEntireFile()); p.theme(in.getTheme()); p.hideEmptyPane(in.isHideEmptyPane()); return p; }
public com.google.gerrit.reviewdb.client.AccountDiffPreference getAccountDiffPreference() { com.google.gerrit.reviewdb.client.AccountDiffPreference diffPref; try { diffPref = dbProvider.get().accountDiffPreferences().get(getAccountId()); if (diffPref == null) { diffPref = com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(getAccountId()); } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.IdentifiedUser.log.warn("Cannot query account diff preferences", e); diffPref = com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(getAccountId()); } return diffPref; }
public com.google.gerrit.server.IdentifiedUser create(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db, com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, null, db, id, null); }
public boolean isIgnoreWhitespace() { return (diffPrefs.getIgnoreWhitespace()) != (com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE); }
public com.google.gerrit.server.IdentifiedUser create(com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, remotePeerProvider, dbProvider, id, null); }
public java.lang.Iterable<com.google.gerrit.prettify.common.EditList.Hunk> getHunks() { int ctx = diffPrefs.getContext(); if (ctx == (com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT)) { ctx = java.lang.Math.max(a.size(), b.size()); } return new com.google.gerrit.prettify.common.EditList(edits, ctx, a.size(), b.size()).getHunks(); }
public void setDiffPrefs(com.google.gerrit.reviewdb.client.AccountDiffPreference how) { diffPrefs = how; }
@java.lang.Override public com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.SetDiffPreferences.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to members of Modify Accounts"); } if (input == null) { input = new com.google.gerrit.server.account.SetDiffPreferences.Input(); } com.google.gerrit.reviewdb.client.Account.Id accountId = rsrc.getUser().getAccountId(); com.google.gerrit.reviewdb.client.AccountDiffPreference p; db.get().accounts().beginTransaction(accountId); try { p = db.get().accountDiffPreferences().get(accountId); if (p == null) { p = new com.google.gerrit.reviewdb.client.AccountDiffPreference(accountId); } if ((input.context) != null) { p.setContext(input.context); } if ((input.ignoreWhitespace) != null) { p.setIgnoreWhitespace(input.ignoreWhitespace); } if ((input.expandAllComments) != null) { p.setExpandAllComments(input.expandAllComments); } if ((input.intralineDifference) != null) { p.setIntralineDifference(input.intralineDifference); } if ((input.lineLength) != null) { p.setLineLength(input.lineLength); } if ((input.manualReview) != null) { p.setManualReview(input.manualReview); } if ((input.retainHeader) != null) { p.setRetainHeader(input.retainHeader); } if ((input.showLineEndings) != null) { p.setShowLineEndings(input.showLineEndings); } if ((input.showTabs) != null) { p.setShowTabs(input.showTabs); } if ((input.showWhitespaceErrors) != null) { p.setShowWhitespaceErrors(input.showWhitespaceErrors); } if ((input.skipDeleted) != null) { p.setSkipDeleted(input.skipDeleted); } if ((input.skipUncommented) != null) { p.setSkipUncommented(input.skipUncommented); } if ((input.syntaxHighlighting) != null) { p.setSyntaxHighlighting(input.syntaxHighlighting); } if ((input.hideTopMenu) != null) { p.setHideTopMenu(input.hideTopMenu); } if ((input.autoHideDiffTableHeader) != null) { p.setAutoHideDiffTableHeader(input.autoHideDiffTableHeader); } if ((input.hideLineNumbers) != null) { p.setHideLineNumbers(input.hideLineNumbers); } if ((input.renderEntireFile) != null) { p.setRenderEntireFile(input.renderEntireFile); } if ((input.tabSize) != null) { p.setTabSize(input.tabSize); } if ((input.theme) != null) { p.setTheme(input.theme); } if ((input.hideEmptyPane) != null) { p.setHideEmptyPane(input.hideEmptyPane); } db.get().accountDiffPreferences().upsert(java.util.Collections.singleton(p)); db.get().commit(); } finally { db.get().rollback(); } return com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo.parse(p); }
private com.google.gerrit.server.patch.PatchListKey getKey(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) { return new com.google.gerrit.server.patch.PatchListKey(project, revisionIdA, revisionIdB, com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE); }
@java.lang.Override public void patchSetDetail2(com.google.gerrit.reviewdb.client.PatchSet.Id baseId, com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs, com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.PatchSetDetail> callback) { patchSetDetail.create(baseId, id, diffPrefs).to(callback); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.account.AccountApi.putDiffPreferences(prefs, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.account.DiffPreferences>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.account.DiffPreferences result) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = com.google.gerrit.client.Gerrit.getAccountDiffPreference(); if (p == null) { p = com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(com.google.gerrit.client.Gerrit.getUserAccount().getId()); } result.copyTo(p); com.google.gerrit.client.Gerrit.setAccountDiffPreference(p); } }); close(); }
public com.google.gerrit.server.CurrentUser runAs(java.net.SocketAddress remotePeer, com.google.gerrit.reviewdb.client.Account.Id id, @com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, com.google.inject.util.Providers.of(remotePeer), null, id, caller); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.account.DiffPreferences result) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = com.google.gerrit.client.Gerrit.getAccountDiffPreference(); if (p == null) { p = com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(com.google.gerrit.client.Gerrit.getUserAccount().getId()); } result.copyTo(p); com.google.gerrit.client.Gerrit.setAccountDiffPreference(p); }
@com.google.gwt.uibinder.client.UiHandler("ignoreWhitespace") void onIgnoreWhitespace(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ChangeEvent e) { prefs.ignoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.valueOf(ignoreWhitespace.getValue(ignoreWhitespace.getSelectedIndex()))); view.reloadDiffInfo(); }
@java.lang.Override public com.google.gwtjsonrpc.common.VoidResult run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if (!(diffPref.getAccountId().equals(getAccountId()))) { throw new java.lang.IllegalArgumentException((((("diffPref.getAccountId() " + (diffPref.getAccountId())) + " doesn't match") + " the accountId of the signed in user ") + (getAccountId()))); } db.accountDiffPreferences().upsert(java.util.Collections.singleton(diffPref)); return com.google.gwtjsonrpc.common.VoidResult.INSTANCE; }
@java.lang.Override public void changeDiffPreferences(final com.google.gerrit.reviewdb.client.AccountDiffPreference diffPref, com.google.gwtjsonrpc.common.AsyncCallback<com.google.gwtjsonrpc.common.VoidResult> callback) { run(callback, new com.google.gerrit.httpd.rpc.account.Action<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public com.google.gwtjsonrpc.common.VoidResult run(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if (!(diffPref.getAccountId().equals(getAccountId()))) { throw new java.lang.IllegalArgumentException((((("diffPref.getAccountId() " + (diffPref.getAccountId())) + " doesn't match") + " the accountId of the signed in user ") + (getAccountId()))); } db.accountDiffPreferences().upsert(java.util.Collections.singleton(diffPref)); return com.google.gwtjsonrpc.common.VoidResult.INSTANCE; } }); }
public com.google.gerrit.reviewdb.client.AccountDiffPreference getDiffPrefs() { return diffPrefs; }
public void setDiffPrefs(com.google.gerrit.reviewdb.client.AccountDiffPreference dp) { diffPrefs = dp; }
public com.google.gerrit.server.IdentifiedUser create(java.net.SocketAddress remotePeer, com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, com.google.inject.util.Providers.of(remotePeer), null, id, null); }
private void setIgnoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace v) { java.lang.String name = (v != null) ? v.name() : com.google.gerrit.client.diff.IGNORE_NONE.name(); for (int i = 0; i < (ignoreWhitespace.getItemCount()); i++) { if (ignoreWhitespace.getValue(i).equals(name)) { ignoreWhitespace.setSelectedIndex(i); return; } } ignoreWhitespace.setSelectedIndex(0); }
@com.google.gerrit.common.audit.Audit void patchSetDetail2(com.google.gerrit.reviewdb.client.PatchSet.Id baseId, com.google.gerrit.reviewdb.client.PatchSet.Id key, com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs, com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.PatchSetDetail> callback);
com.google.gerrit.httpd.rpc.changedetail.PatchSetDetailFactory create(@com.google.inject.assistedinject.Assisted("psIdBase") @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet.Id psIdBase, @com.google.inject.assistedinject.Assisted("psIdNew") com.google.gerrit.reviewdb.client.PatchSet.Id psIdNew, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs);

@java.lang.Override public void patchScript(final com.google.gerrit.reviewdb.client.Patch.Key patchKey, final com.google.gerrit.reviewdb.client.PatchSet.Id psa, final com.google.gerrit.reviewdb.client.PatchSet.Id psb, final com.google.gerrit.reviewdb.client.AccountDiffPreference dp, final com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.PatchScript> callback) { if (psb == null) { callback.onFailure(new com.google.gerrit.common.errors.NoSuchEntityException()); return; } new com.google.gerrit.httpd.rpc.Handler<com.google.gerrit.common.data.PatchScript>() { @java.lang.Override public com.google.gerrit.common.data.PatchScript call() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change.Id changeId = patchKey.getParentKey().getParentKey(); com.google.gerrit.server.project.ChangeControl control = changeControlFactory.validateFor(changeId); return patchScriptFactoryFactory.create(control, patchKey.getFileName(), psa, psb, dp).call(); } }.to(callback); }
public com.google.gerrit.reviewdb.client.AccountDiffPreference getValue() { return listenablePrefs.get(); }
private void setIgnoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace s) { for (int i = 0; i < (ignoreWhitespace.getItemCount()); i++) { if (ignoreWhitespace.getValue(i).equals(s.name())) { ignoreWhitespace.setSelectedIndex(i); return; } } ignoreWhitespace.setSelectedIndex(0); }
public void setValue(final com.google.gerrit.reviewdb.client.AccountDiffPreference dp) { listenablePrefs.set(dp); display(); }
private com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace getIgnoreWhitespace() { final int sel = ignoreWhitespace.getSelectedIndex(); if (0 <= sel) { return com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.valueOf(ignoreWhitespace.getValue(sel)); } return getValue().getIgnoreWhitespace(); }
private void persistDiffPreferences() { setEnabled(false); listenablePrefs.save(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gwtjsonrpc.common.VoidResult result) { setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { setEnabled(true); } }); }
com.google.gerrit.server.patch.PatchScriptFactory create(com.google.gerrit.server.project.ChangeControl control, java.lang.String fileName, @com.google.inject.assistedinject.Assisted("patchSetA") com.google.gerrit.reviewdb.client.PatchSet.Id patchSetA, @com.google.inject.assistedinject.Assisted("patchSetB") com.google.gerrit.reviewdb.client.PatchSet.Id patchSetB, com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs);
private void initContext(com.google.gwt.user.client.ui.ListBox context) { for (final short v : com.google.gerrit.reviewdb.client.AccountDiffPreference.CONTEXT_CHOICES) { final java.lang.String label; if (v == (com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT)) { label = Util.C.contextWholeFile(); } else { label = Util.M.lines(v); } context.addItem(label, java.lang.String.valueOf(v)); } }
private void update() { if ((colWidth.getIntValue()) <= 0) { new com.google.gerrit.client.ErrorDialog(PatchUtil.C.illegalNumberOfColumns()).center(); return; } com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(getValue()); dp.setIgnoreWhitespace(getIgnoreWhitespace()); dp.setContext(getContext()); dp.setTabSize(tabWidth.getIntValue()); dp.setLineLength(colWidth.getIntValue()); dp.setSyntaxHighlighting(syntaxHighlighting.getValue()); dp.setIntralineDifference(intralineDifference.getValue()); dp.setShowWhitespaceErrors(whitespaceErrors.getValue()); dp.setShowLineEndings(showLineEndings.getValue()); dp.setShowTabs(showTabs.getValue()); dp.setSkipDeleted(skipDeleted.getValue()); dp.setSkipUncommented(skipUncommented.getValue()); dp.setExpandAllComments(expandAllComments.getValue()); dp.setRetainHeader(retainHeader.getValue()); dp.setManualReview(manualReview.getValue()); listenablePrefs.set(dp); }
@org.junit.Test public void getDiffPreferences() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get((("/accounts/" + (admin.email)) + "/preferences.diff")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo diffPreferences = newGson().fromJson(r.getReader(), com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo.class); com.google.gerrit.acceptance.rest.account.GetDiffPreferencesIT.assertDiffPreferences(new com.google.gerrit.reviewdb.client.AccountDiffPreference(admin.id), diffPreferences); }
private static boolean toBoolean(java.lang.Boolean b) { if (b == null) { return false; } return b.booleanValue(); }
@com.google.gerrit.common.audit.Audit @com.google.gerrit.common.auth.SignInRequired void changeDiffPreferences(com.google.gerrit.reviewdb.client.AccountDiffPreference diffPref, com.google.gwtjsonrpc.common.AsyncCallback<com.google.gwtjsonrpc.common.VoidResult> callback);
private static org.eclipse.jgit.diff.RawTextComparator comparatorFor(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace ws) { switch (ws) { case IGNORE_ALL_SPACE : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_ALL; case IGNORE_SPACE_AT_EOL : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_TRAILING; case IGNORE_SPACE_CHANGE : return org.eclipse.jgit.diff.RawTextComparator.WS_IGNORE_CHANGE; case IGNORE_NONE : default : return org.eclipse.jgit.diff.RawTextComparator.DEFAULT; } }
@java.lang.Override public com.google.gerrit.server.patch.PatchList createValue(com.googlecode.prolog_cafe.lang.Prolog engine) { com.google.gerrit.rules.PrologEnvironment env = ((com.google.gerrit.rules.PrologEnvironment) (engine.control)); com.google.gerrit.reviewdb.client.PatchSetInfo psInfo = com.google.gerrit.rules.StoredValues.PATCH_SET_INFO.get(engine); com.google.gerrit.server.patch.PatchListCache plCache = env.getArgs().getPatchListCache(); com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.rules.StoredValues.getChange(engine); com.google.gerrit.reviewdb.client.Project.NameKey projectKey = change.getProject(); org.eclipse.jgit.lib.ObjectId a = null; org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(psInfo.getRevId()); com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace ws = com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE; com.google.gerrit.server.patch.PatchListKey plKey = new com.google.gerrit.server.patch.PatchListKey(projectKey, a, b, ws); com.google.gerrit.server.patch.PatchList patchList; try { patchList = plCache.get(plKey); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { throw new com.googlecode.prolog_cafe.lang.SystemException(("Cannot create " + plKey)); } return patchList; }
protected void display() { final com.google.gerrit.reviewdb.client.AccountDiffPreference dp = getValue(); setIgnoreWhitespace(dp.getIgnoreWhitespace()); if (enableSmallFileFeatures) { syntaxHighlighting.setValue(dp.isSyntaxHighlighting()); } else { syntaxHighlighting.setValue(false); } setContext(dp.getContext()); tabWidth.setIntValue(dp.getTabSize()); colWidth.setIntValue(dp.getLineLength()); intralineDifference.setValue(dp.isIntralineDifference()); whitespaceErrors.setValue(dp.isShowWhitespaceErrors()); showLineEndings.setValue(dp.isShowLineEndings()); showTabs.setValue(dp.isShowTabs()); skipDeleted.setValue(dp.isSkipDeleted()); skipUncommented.setValue(dp.isSkipUncommented()); expandAllComments.setValue(dp.isExpandAllComments()); retainHeader.setValue(dp.isRetainHeader()); manualReview.setValue(dp.isManualReview()); }
private com.google.gerrit.server.patch.PatchListKey keyFor(final com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace whitespace) { return new com.google.gerrit.server.patch.PatchListKey(projectKey, aId, bId, whitespace); }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder(final com.google.gerrit.server.patch.PatchList list, org.eclipse.jgit.lib.Repository git) { final com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(diffPrefs); final com.google.gerrit.server.patch.PatchScriptBuilder b = builderFactory.get(); b.setRepository(git, projectKey); b.setChange(change); b.setDiffPrefs(dp); b.setTrees(list.isAgainstParent(), list.getOldId(), list.getNewId()); return b; }
public void reset() { if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((com.google.gerrit.client.Gerrit.getAccountDiffPreference()) != null)) { set(com.google.gerrit.client.Gerrit.getAccountDiffPreference()); } else { set(com.google.gerrit.reviewdb.client.AccountDiffPreference.createDefault(null)); } }
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.patch.PatchListNotAvailableException { final com.google.gerrit.reviewdb.client.Project.NameKey projectKey = change.getProject(); final org.eclipse.jgit.lib.ObjectId a = null; if ((patchSet.getRevision()) == null) { throw new com.google.gerrit.server.patch.PatchListNotAvailableException(("revision is null for " + (patchSet.getId()))); } final org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); final com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace ws = com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE; return get(new com.google.gerrit.server.patch.PatchListKey(projectKey, a, b, ws)); }


public final void copyTo(com.google.gerrit.reviewdb.client.AccountDiffPreference p) { p.setIgnoreWhitespace(ignoreWhitespace()); p.setTabSize(tabSize()); p.setLineLength(lineLength()); p.setContext(((short) (context()))); p.setIntralineDifference(intralineDifference()); p.setShowLineEndings(showLineEndings()); p.setShowTabs(showTabs()); p.setShowWhitespaceErrors(showWhitespaceErrors()); p.setSyntaxHighlighting(syntaxHighlighting()); p.setHideTopMenu(hideTopMenu()); p.setAutoHideDiffTableHeader(autoHideDiffTableHeader()); p.setHideLineNumbers(hideLineNumbers()); p.setExpandAllComments(expandAllComments()); p.setManualReview(manualReview()); p.setRenderEntireFile(renderEntireFile()); p.setTheme(theme()); p.setHideEmptyPane(hideEmptyPane()); }
public final void ignoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace i) { setIgnoreWhitespaceRaw(i.toString()); }
private com.google.gerrit.server.patch.PatchListKey keyFor(final com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace whitespace) { return new com.google.gerrit.server.patch.PatchListKey(projectKey, oldId, newId, whitespace); }
public static com.google.gerrit.reviewdb.client.AccountDiffPreference getAccountDiffPreference() { return com.google.gerrit.client.Gerrit.myAccountDiffPref; }
public static void setAccountDiffPreference(com.google.gerrit.reviewdb.client.AccountDiffPreference accountDiffPref) { com.google.gerrit.client.Gerrit.myAccountDiffPref = accountDiffPref; }
@com.google.gerrit.common.audit.Audit void patchScript(com.google.gerrit.reviewdb.client.Patch.Key key, com.google.gerrit.reviewdb.client.PatchSet.Id a, com.google.gerrit.reviewdb.client.PatchSet.Id b, com.google.gerrit.reviewdb.client.AccountDiffPreference diffPrefs, com.google.gwtjsonrpc.common.AsyncCallback<com.google.gerrit.common.data.PatchScript> callback);
@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String value = params.getParameter(0); short context; if ("all".equalsIgnoreCase(value)) { context = com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT; } else { try { context = java.lang.Short.parseShort(value, 10); if (context < 0) { throw new java.lang.NumberFormatException(); } } catch (java.lang.NumberFormatException e) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format("\"%s\" is not a valid value for \"%s\"", value, ((org.kohsuke.args4j.NamedOptionDef) (option)).name())); } } setter.addValue(context); return 1; }
protected com.google.gerrit.prettify.client.SparseHtmlFile getSparseHtmlFileB(com.google.gerrit.common.data.PatchScript s) { com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(s.getDiffPrefs()); com.google.gerrit.prettify.common.SparseFileContent b = s.getB(); com.google.gerrit.prettify.client.PrettyFormatter f = ClientSideFormatter.FACTORY.get(); f.setDiffPrefs(dp); f.setFileName(b.getPath()); f.setEditFilter(PrettyFormatter.B); f.setEditList(s.getEdits()); if ((s.getA().isWholeFile()) && (!(b.isWholeFile()))) { b = b.apply(s.getA(), s.getEdits()); } f.format(b); return f; }
protected com.google.gerrit.prettify.client.SparseHtmlFile getSparseHtmlFileA(com.google.gerrit.common.data.PatchScript s) { com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference(s.getDiffPrefs()); dp.setShowWhitespaceErrors(false); com.google.gerrit.prettify.client.PrettyFormatter f = ClientSideFormatter.FACTORY.get(); f.setDiffPrefs(dp); f.setFileName(s.getA().getPath()); f.setEditFilter(PrettyFormatter.A); f.setEditList(s.getEdits()); f.format(s.getA()); return f; }
@java.lang.Override public com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account.Id userId = rsrc.getUser().getAccountId(); com.google.gerrit.reviewdb.client.AccountDiffPreference a = db.get().accountDiffPreferences().get(userId); if (a == null) { a = new com.google.gerrit.reviewdb.client.AccountDiffPreference(userId); } return com.google.gerrit.server.account.GetDiffPreferences.DiffPreferencesInfo.parse(a); }
void setDiffPrefs(final com.google.gerrit.reviewdb.client.AccountDiffPreference dp) { diffPrefs = dp; context = diffPrefs.getContext(); if ((context) == (com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT)) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT; } else if ((context) > (com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT)) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT; } }
public com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace getWhitespace() { return whitespace; }
public com.google.gerrit.client.diff.DiffApi ignoreWhitespace(com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace w) { switch (w) { default : case IGNORE_NONE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.NONE); case IGNORE_SPACE_AT_EOL : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.TRAILING); case IGNORE_SPACE_CHANGE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.CHANGED); case IGNORE_ALL_SPACE : return ignoreWhitespace(com.google.gerrit.client.diff.DiffApi.IgnoreWhitespace.ALL); } }

public boolean hasMissingDependencies(final com.google.gerrit.server.git.MergeSorter mergeSorter, final com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { try { return !(mergeSorter.sort(java.util.Collections.singleton(toMerge)).contains(toMerge)); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Branch head sorting failed", e); } }
protected abstract com.google.gerrit.server.git.MergeTip _run(com.google.gerrit.server.git.CodeReviewCommit currentTip, java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException;
@java.lang.Override public boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { return args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge); }
@java.lang.Override protected com.google.gerrit.server.git.MergeTip _run(com.google.gerrit.server.git.CodeReviewCommit branchTip, java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); com.google.gerrit.server.git.MergeTip mergeTip; if (branchTip == null) { mergeTip = new com.google.gerrit.server.git.MergeTip(sorted.get(0), toMerge); branchTip = sorted.remove(0); } else { mergeTip = new com.google.gerrit.server.git.MergeTip(branchTip, toMerge); branchTip = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted); } mergeTip.moveTipTo(branchTip, branchTip); while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit mergedFrom = sorted.remove(0); org.eclipse.jgit.lib.PersonIdent serverIdent = args.serverIdent.get(); org.eclipse.jgit.lib.PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()); branchTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, branchTip, mergedFrom); mergeTip.moveTipTo(branchTip, mergedFrom); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, branchTip, args.alreadyAccepted); setRefLogIdent(); return mergeTip; }
@java.lang.Override public boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { return (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge)) || (args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge)); }
private java.util.Set<org.eclipse.jgit.revwalk.RevCommit> getAlreadyAccepted(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.git.CodeReviewCommit tip) throws com.google.gerrit.server.git.MergeException { java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted = com.google.common.collect.Sets.newHashSet(); if (tip != null) { alreadyAccepted.add(tip); } try { for (org.eclipse.jgit.lib.ObjectId id : changeDataCache.getAlreadyAccepted(repo)) { try { alreadyAccepted.add(rw.parseCommit(id)); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException iote) { } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Failed to determine already accepted commits.", e); } return alreadyAccepted; }
public void markCleanMerges(final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.revwalk.RevFlag canMergeFlag, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted) throws com.google.gerrit.server.git.MergeException { if (mergeTip == null) { return; } try { rw.resetRetain(canMergeFlag); rw.sort(RevSort.TOPO); rw.sort(RevSort.REVERSE, true); rw.markStart(mergeTip); for (org.eclipse.jgit.revwalk.RevCommit c : alreadyAccepted) { rw.markUninteresting(c); } com.google.gerrit.server.git.CodeReviewCommit c; while ((c = ((com.google.gerrit.server.git.CodeReviewCommit) (rw.next()))) != null) { if ((c.getPatchsetId()) != null) { c.setStatusCode(CommitMergeStatus.CLEAN_MERGE); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot mark clean merges", e); } }
public com.google.gerrit.server.git.CodeReviewCommit mergeOneCommit(org.eclipse.jgit.lib.PersonIdent author, org.eclipse.jgit.lib.PersonIdent committer, org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.revwalk.RevFlag canMergeFlag, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit n) throws com.google.gerrit.server.git.MergeException { final org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, inserter); try { if (m.merge(new org.eclipse.jgit.lib.AnyObjectId[]{ mergeTip, n })) { return writeMergeCommit(author, committer, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n); } else { com.google.gerrit.server.git.MergeUtil.failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT); } } catch (org.eclipse.jgit.errors.NoMergeBaseException e) { try { com.google.gerrit.server.git.MergeUtil.failed(rw, canMergeFlag, mergeTip, n, com.google.gerrit.server.git.MergeUtil.getCommitMergeStatus(e.getReason())); } catch (java.io.IOException e2) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (n.name())), e); } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (n.name())), e); } return mergeTip; }
public boolean canMerge(final com.google.gerrit.server.git.MergeSorter mergeSorter, final org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { if (hasMissingDependencies(mergeSorter, toMerge)) { return false; } org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, com.google.gerrit.server.git.MergeUtil.createDryRunInserter(repo)); try { return m.merge(new org.eclipse.jgit.lib.AnyObjectId[]{ mergeTip, toMerge }); } catch (org.eclipse.jgit.errors.LargeObjectException e) { com.google.gerrit.server.git.MergeUtil.log.warn(("Cannot merge due to LargeObjectException: " + (toMerge.name()))); return false; } catch (org.eclipse.jgit.errors.NoMergeBaseException e) { return false; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (toMerge.name())), e); } }
@java.lang.Override protected com.google.gerrit.server.git.MergeTip _run(com.google.gerrit.server.git.CodeReviewCommit branchTip, java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); com.google.gerrit.server.git.MergeTip mergeTip; if (branchTip == null) { mergeTip = new com.google.gerrit.server.git.MergeTip(sorted.get(0), toMerge); sorted.remove(0); } else { mergeTip = new com.google.gerrit.server.git.MergeTip(branchTip, toMerge); } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit mergedFrom = sorted.remove(0); org.eclipse.jgit.lib.PersonIdent serverIdent = args.serverIdent.get(); org.eclipse.jgit.lib.PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()); com.google.gerrit.server.git.CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), mergedFrom); mergeTip.moveTipTo(newTip, mergedFrom); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); setRefLogIdent(); return mergeTip; }
public boolean canCherryPick(com.google.gerrit.server.git.MergeSorter mergeSorter, org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { if (mergeTip == null) { return true; } if ((toMerge.getParentCount()) == 0) { return false; } if ((toMerge.getParentCount()) == 1) { try { org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, com.google.gerrit.server.git.MergeUtil.createDryRunInserter(repo)); m.setBase(toMerge.getParent(0)); return m.merge(mergeTip, toMerge); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException(("Cannot merge " + (toMerge.name())), e); } } return (canFastForward(mergeSorter, mergeTip, rw, toMerge)) || (canMerge(mergeSorter, repo, mergeTip, toMerge)); }
public com.google.gerrit.server.git.CodeReviewCommit getFirstFastForward(final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final org.eclipse.jgit.revwalk.RevWalk rw, final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { for (final java.util.Iterator<com.google.gerrit.server.git.CodeReviewCommit> i = toMerge.iterator(); i.hasNext();) { try { final com.google.gerrit.server.git.CodeReviewCommit n = i.next(); if ((mergeTip == null) || (rw.isMergedInto(mergeTip, n))) { i.remove(); return n; } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot fast-forward test during merge", e); } } return mergeTip; }
public boolean canFastForward(com.google.gerrit.server.git.MergeSorter mergeSorter, com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { if (hasMissingDependencies(mergeSorter, toMerge)) { return false; } try { return (mergeTip == null) || (rw.isMergedInto(mergeTip, toMerge)); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot fast-forward test during merge", e); } }
public final com.google.gerrit.server.git.MergeTip run(final com.google.gerrit.server.git.CodeReviewCommit currentTip, final java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { refLogIdent = null; checkState(((args.caller) != null)); return _run(currentTip, toMerge); }
public abstract boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException;
@java.lang.Override public boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { return args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge); }
@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.MergeException, java.io.IOException { if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) { return; } if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) { mergeTip.moveTipTo(toMerge, toMerge); } else { org.eclipse.jgit.lib.PersonIdent myIdent = new org.eclipse.jgit.lib.PersonIdent(args.serverIdent.get(), ctx.getWhen()); com.google.gerrit.server.git.CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), toMerge); mergeTip.moveTipTo(result, toMerge); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); setRefLogIdent(); }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (key.into.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return true; } org.eclipse.jgit.lib.RefDatabase refDatabase = repo.getRefDatabase(); java.lang.Iterable<org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values()); try (com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo)) { org.eclipse.jgit.revwalk.RevFlag canMerge = rw.newFlag("CAN_MERGE"); com.google.gerrit.server.git.CodeReviewCommit rev = rw.parseCommit(key.commit); rev.add(canMerge); com.google.gerrit.server.git.CodeReviewCommit tip = rw.parseCommit(key.into); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> accepted = alreadyAccepted(rw, refs); accepted.add(tip); accepted.addAll(java.util.Arrays.asList(rev.getParents())); return submitStrategyFactory.create(key.submitType, db, repo, rw, null, canMerge, accepted, dest, null).dryRun(tip, rev); } }
public java.util.List<com.google.gerrit.server.git.CodeReviewCommit> reduceToMinimalMerge(com.google.gerrit.server.git.MergeSorter mergeSorter, java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toSort) throws com.google.gerrit.server.git.MergeException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> result = new java.util.ArrayList<>(); try { result.addAll(mergeSorter.sort(toSort)); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Branch head sorting failed", e); } java.util.Collections.sort(result, CodeReviewCommit.ORDER); return result; }
@java.lang.Override protected com.google.gerrit.server.git.MergeTip _run(final com.google.gerrit.server.git.CodeReviewCommit branchTip, final java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.MergeException { com.google.gerrit.server.git.MergeTip mergeTip = new com.google.gerrit.server.git.MergeTip(branchTip, toMerge); java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); final com.google.gerrit.server.git.CodeReviewCommit newMergeTipCommit = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted); mergeTip.moveTipTo(newMergeTipCommit, newMergeTipCommit); while (!(sorted.isEmpty())) { final com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); n.setStatusCode(CommitMergeStatus.NOT_FAST_FORWARD); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, newMergeTipCommit, args.alreadyAccepted); setRefLogIdent(); return mergeTip; }
@java.lang.Override public boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { return args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge); }
private org.eclipse.jgit.lib.RefUpdate getPendingRefUpdate(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch) throws com.google.gerrit.server.git.MergeException { if (pendingRefUpdates.containsKey(destBranch)) { logDebug("Access cached open branch {}: {}", destBranch.get(), openBranches.get(destBranch)); return pendingRefUpdates.get(destBranch); } try { org.eclipse.jgit.lib.RefUpdate branchUpdate = repo.updateRef(destBranch.get()); com.google.gerrit.server.git.CodeReviewCommit branchTip; if ((branchUpdate.getOldObjectId()) != null) { branchTip = rw.parseCommit(branchUpdate.getOldObjectId()); } else if (java.util.Objects.equals(repo.getFullBranch(), destBranch.get())) { branchTip = null; branchUpdate.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); } else { throw new com.google.gerrit.server.git.MergeException((("The destination branch " + (destBranch.get())) + " does not exist anymore.")); } logDebug("Opened branch {}: {}", destBranch.get(), branchTip); pendingRefUpdates.put(destBranch, branchUpdate); openBranches.put(destBranch, branchTip); return branchUpdate; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Cannot open branch", e); } }
private com.google.gerrit.server.git.CodeReviewCommit getBranchTip(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch) throws com.google.gerrit.server.git.MergeException { if (openBranches.containsKey(destBranch)) { return openBranches.get(destBranch); } else { getPendingRefUpdate(destBranch); return openBranches.get(destBranch); } }
private void openRepository(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { try { repo = repoManager.openRepository(name); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notFound) { throw new com.google.gerrit.server.project.NoSuchProjectException(name, notFound); } catch (java.io.IOException err) { java.lang.String m = ("Error opening repository \"" + (name.get())) + '"'; throw new com.google.gerrit.server.git.MergeException(m, err); } rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo); rw.sort(RevSort.TOPO); rw.sort(RevSort.COMMIT_TIME_DESC, true); rw.setRetainBody(false); canMergeFlag = rw.newFlag("CAN_MERGE"); inserter = repo.newObjectInserter(); }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { updateSubmissionId(change); this.db = db; logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } try { integrateIntoHistory(cs, caller); } catch (com.google.gerrit.server.git.MergeException e) { logError("Merge Conflict", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Merge Conflict", e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private java.util.Set<org.eclipse.jgit.revwalk.RevCommit> getAlreadyAccepted(com.google.gerrit.server.git.CodeReviewCommit branchTip) throws com.google.gerrit.server.git.MergeException { java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted = new java.util.HashSet<>(); if (branchTip != null) { alreadyAccepted.add(branchTip); } try { for (org.eclipse.jgit.lib.Ref r : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) { try { alreadyAccepted.add(rw.parseCommit(r.getObjectId())); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException iote) { } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Failed to determine already accepted commits.", e); } logDebug("Found {} existing heads", alreadyAccepted.size()); return alreadyAccepted; }
private com.google.gerrit.server.git.strategy.SubmitStrategy createStrategy(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.server.git.CodeReviewCommit branchTip, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.MergeException, com.google.gerrit.server.project.NoSuchProjectException { return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller); }
private void setDestProject(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch) throws com.google.gerrit.server.git.MergeException { destProject = projectCache.get(destBranch.getParentKey()); if ((destProject) == null) { throw new com.google.gerrit.server.git.MergeException(("No such project: " + (destBranch.getParentKey()))); } }
private java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sort(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toSort) throws com.google.gerrit.server.git.MergeException { try { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> result = new com.google.gerrit.server.git.RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort); java.util.Collections.sort(result, CodeReviewCommit.ORDER); return result; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.MergeException("Commit sorting failed", e); } }
private com.google.gerrit.server.git.MergeTip preMerge(com.google.gerrit.server.git.strategy.SubmitStrategy strategy, java.util.List<com.google.gerrit.server.query.change.ChangeData> submitted, com.google.gerrit.server.git.CodeReviewCommit branchTip) throws com.google.gerrit.server.git.MergeException, com.google.gwtorm.server.OrmException { logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted); java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge = new java.util.ArrayList(submitted.size()); for (com.google.gerrit.server.query.change.ChangeData cd : submitted) { com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(cd.change().getId()); checkState((commit != null), "commit for %s not found by validateChangeList", cd.change().getId()); toMerge.add(commit); } com.google.gerrit.server.git.MergeTip mergeTip = strategy.run(branchTip, toMerge); refLogIdent = strategy.getRefLogIdent(); logDebug("Produced {} new commits", strategy.getNewCommits().size()); commits.putAll(strategy.getNewCommits()); return mergeTip; }
@java.lang.Override public boolean dryRun(com.google.gerrit.server.git.CodeReviewCommit mergeTip, com.google.gerrit.server.git.CodeReviewCommit toMerge) throws com.google.gerrit.server.git.MergeException { return (!(args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge))) && (args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge)); }
@org.junit.Test(expected = com.google.gerrit.extensions.restapi.ResourceConflictException.class) public void rebase() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).rebase(); }
@java.lang.Override public final int parseArguments(final org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String n = params.getParameter(0); final com.google.gerrit.common.data.GroupReference group = com.google.gerrit.server.account.GroupBackends.findBestSuggestion(groupBackend, n); if (group == null) { throw new org.kohsuke.args4j.CmdLineException(owner, (("Group \"" + n) + "\" does not exist")); } setter.addValue(group.getUUID()); return 1; }


@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName.get())) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId()); p.load(git); com.google.gerrit.extensions.client.DiffPreferencesInfo prefs = new com.google.gerrit.extensions.client.DiffPreferencesInfo(); loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults()); if ((prefs.migrated) == null) { com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); com.google.gerrit.reviewdb.client.AccountDiffPreference a = db.get().accountDiffPreferences().get(id); com.google.gerrit.server.account.GetDiffPreferences.initFromDb(prefs, a); prefs.migrated = true; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName.get()); storeSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults()); p.commit(md); } prefs.migrated = null; return prefs; } }
public static com.google.gerrit.client.account.DiffPreferences create(com.google.gerrit.extensions.client.DiffPreferencesInfo in) { com.google.gerrit.client.account.DiffPreferences p = createObject().cast(); p.ignoreWhitespace(in.ignoreWhitespace); p.tabSize(in.tabSize); p.lineLength(in.lineLength); p.cursorBlinkRate(in.cursorBlinkRate); p.context(in.context); p.intralineDifference(in.intralineDifference); p.showLineEndings(in.showLineEndings); p.showTabs(in.showTabs); p.showWhitespaceErrors(in.showWhitespaceErrors); p.syntaxHighlighting(in.syntaxHighlighting); p.hideTopMenu(in.hideTopMenu); p.autoHideDiffTableHeader(in.autoHideDiffTableHeader); p.hideLineNumbers(in.hideLineNumbers); p.expandAllComments(in.expandAllComments); p.manualReview(in.manualReview); p.renderEntireFile(in.renderEntireFile); p.theme(in.theme); p.hideEmptyPane(in.hideEmptyPane); return p; }
public final void copyTo(com.google.gerrit.extensions.client.DiffPreferencesInfo p) { p.context = context(); p.tabSize = tabSize(); p.lineLength = lineLength(); p.cursorBlinkRate = cursorBlinkRate(); p.expandAllComments = expandAllComments(); p.intralineDifference = intralineDifference(); p.manualReview = manualReview(); p.showLineEndings = showLineEndings(); p.showTabs = showTabs(); p.showWhitespaceErrors = showWhitespaceErrors(); p.syntaxHighlighting = syntaxHighlighting(); p.hideTopMenu = hideTopMenu(); p.autoHideDiffTableHeader = autoHideDiffTableHeader(); p.hideLineNumbers = hideLineNumbers(); p.renderEntireFile = renderEntireFile(); p.hideEmptyPane = hideEmptyPane(); p.theme = theme(); p.ignoreWhitespace = ignoreWhitespace(); }
@com.google.gwtexpui.clippy.client.Source("clippy.css") com.google.gwtexpui.clippy.client.ClippyCss css();

@com.google.gwtexpui.clippy.client.Source("clippy.swf") @com.google.gwt.resources.client.DataResource.DoNotEmbed com.google.gwt.resources.client.DataResource swf();







private java.util.concurrent.Callable<com.google.gerrit.httpd.raw.ResourceServlet.Resource> newLoader(final java.lang.String name, final java.nio.file.Path p) { return new java.util.concurrent.Callable<com.google.gerrit.httpd.raw.ResourceServlet.Resource>() { @java.lang.Override public com.google.gerrit.httpd.raw.ResourceServlet.Resource call() throws java.io.IOException { return new com.google.gerrit.httpd.raw.ResourceServlet.Resource(java.nio.file.Files.getLastModifiedTime(p), com.google.gerrit.httpd.raw.ResourceServlet.contentType(name), java.nio.file.Files.readAllBytes(p)); } }; }
private java.util.concurrent.Callable<com.google.gerrit.httpd.raw.ResourceServlet.Resource> newLoader(final java.nio.file.Path p) { return new java.util.concurrent.Callable<com.google.gerrit.httpd.raw.ResourceServlet.Resource>() { @java.lang.Override public com.google.gerrit.httpd.raw.ResourceServlet.Resource call() throws java.io.IOException { return new com.google.gerrit.httpd.raw.ResourceServlet.Resource(java.nio.file.Files.getLastModifiedTime(p), com.google.gerrit.httpd.raw.ResourceServlet.contentType(p.toString()), java.nio.file.Files.readAllBytes(p)); } }; }

@java.lang.Override public com.google.gerrit.httpd.raw.ResourceServlet.Resource call() throws java.io.IOException { return new com.google.gerrit.httpd.raw.ResourceServlet.Resource(java.nio.file.Files.getLastModifiedTime(p), com.google.gerrit.httpd.raw.ResourceServlet.contentType(p.toString()), java.nio.file.Files.readAllBytes(p)); }
boolean isStale(java.nio.file.Path p) { try { return !(lastModified.equals(java.nio.file.Files.getLastModifiedTime(p))); } catch (java.io.IOException e) { return true; } }

private void stream(java.nio.file.Path p, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { long lastModified = com.google.gerrit.common.FileUtil.lastModified(p); if ((req.getDateHeader(com.google.gerrit.httpd.raw.IF_MODIFIED_SINCE)) >= lastModified) { rsp.setStatus(com.google.gerrit.httpd.raw.SC_NOT_MODIFIED); return; } if (lastModified > 0) { rsp.setDateHeader(com.google.gerrit.httpd.raw.LAST_MODIFIED, lastModified); } if (!(com.google.gwtexpui.server.CacheHeaders.hasCacheHeader(rsp))) { com.google.gwtexpui.server.CacheHeaders.setCacheable(req, rsp, 15, java.util.concurrent.TimeUnit.MINUTES, refresh); } rsp.setContentType(com.google.gerrit.httpd.raw.ResourceServlet.contentType(p.toString())); java.io.OutputStream out = rsp.getOutputStream(); if (com.google.gwtjsonrpc.server.RPCServletUtils.acceptsGzipEncoding(req)) { rsp.setHeader(com.google.gerrit.httpd.raw.CONTENT_ENCODING, "gzip"); out = new java.util.zip.GZIPOutputStream(out); } java.nio.file.Files.copy(p, out); }

@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.RevertInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ChangeControl control = req.getControl(); com.google.gerrit.reviewdb.client.Change change = req.getChange(); if (!(control.canAddPatchSet())) { throw new com.google.gerrit.extensions.restapi.AuthException("revert not permitted"); } else if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.change.Revert.status(change)))); } com.google.gerrit.reviewdb.client.Change.Id revertedChangeId; try { revertedChangeId = changeUtil.revert(control, change.currentPatchSetId(), com.google.common.base.Strings.emptyToNull(input.message), new org.eclipse.jgit.lib.PersonIdent(myIdent, com.google.gerrit.common.TimeUtil.nowTs())); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } return json.create(ChangeJson.NO_OPTIONS).format(revertedChangeId); }
public boolean canAbandon() { return ((((isOwner()) || (getRefControl().isOwner())) || (getProjectControl().isOwner())) || (getUser().getCapabilities().canAdministrateServer())) || (getRefControl().canAbandon()); }

@org.junit.Before public void setUpInjector() throws java.lang.Exception { lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); com.google.inject.Injector injector = createInjector(); lifecycle.add(injector); injector.injectMembers(this); lifecycle.start(); db = schemaFactory.open(); schemaCreator.create(db); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); com.google.gerrit.reviewdb.client.Account userAccount = db.accounts().get(userId); userAccount.setPreferredEmail("user@example.com"); db.accounts().update(com.google.common.collect.ImmutableList.of(userAccount)); user = userFactory.create(com.google.inject.util.Providers.of(db), userId); requestContext.setContext(newRequestContext(userAccount.getId())); }

@org.junit.Test public void testCopy() { final com.google.gerrit.server.query.TestPredicate a = f("author", "alice"); final com.google.gerrit.server.query.TestPredicate b = f("author", "bob"); final com.google.gerrit.server.query.TestPredicate c = f("author", "charlie"); final java.util.List<com.google.gerrit.server.query.TestPredicate> s2 = of(a, b); final java.util.List<com.google.gerrit.server.query.TestPredicate> s3 = of(a, b, c); final com.google.gerrit.server.query.Predicate<java.lang.String> n2 = com.google.gerrit.server.query.Predicate.and(a, b); assertNotSame(n2, n2.copy(s2)); assertEquals(s2, n2.copy(s2).getChildren()); assertEquals(s3, n2.copy(s3).getChildren()); try { n2.copy(java.util.Collections.<com.google.gerrit.server.query.Predicate<java.lang.String>>emptyList()); } catch (java.lang.IllegalArgumentException e) { assertEquals("Need at least two predicates", e.getMessage()); } }
@org.junit.Test public void testCopy() { final com.google.gerrit.server.query.TestPredicate a = f("author", "alice"); final com.google.gerrit.server.query.TestPredicate b = f("author", "bob"); final com.google.gerrit.server.query.TestPredicate c = f("author", "charlie"); final java.util.List<com.google.gerrit.server.query.TestPredicate> s2 = of(a, b); final java.util.List<com.google.gerrit.server.query.TestPredicate> s3 = of(a, b, c); final com.google.gerrit.server.query.Predicate<java.lang.String> n2 = com.google.gerrit.server.query.Predicate.or(a, b); assertNotSame(n2, n2.copy(s2)); assertEquals(s2, n2.copy(s2).getChildren()); assertEquals(s3, n2.copy(s3).getChildren()); try { n2.copy(java.util.Collections.<com.google.gerrit.server.query.Predicate<java.lang.String>>emptyList()); } catch (java.lang.IllegalArgumentException e) { assertEquals("Need at least two predicates", e.getMessage()); } }
private void assertChildNotFound(com.google.gerrit.reviewdb.client.Project.NameKey parent, java.lang.String child) throws java.lang.Exception { try { gApi.projects().name(parent.get()).child(child); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { assertThat(e.getMessage()).contains(child); } }

@org.junit.Test public void listTagsOfNonExistingProjectWithApi() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name("does-not-exist").tags(); exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name("does-not-exist").tag("tag").get(); }
@org.junit.Test public void listTagsOfNonVisibleProjectWithApi() throws java.lang.Exception { blockRead(project, "refs/*"); exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name(project.get()).tags(); exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name(project.get()).tag("tag").get(); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return com.google.gerrit.server.PatchLineCommentsUtil.sort(db.patchComments().draftByAuthor(author).toList()); } java.util.Set<java.lang.String> refNames = getRefNamesAllUsers(RefNames.REFS_DRAFT_COMMENTS); java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); for (java.lang.String refName : refNames) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.fromRefPart(refName); if (!(author.equals(id))) { continue; } com.google.gerrit.reviewdb.client.Change.Id changeId = Change.Id.parse(refName); comments.addAll(draftFactory.create(changeId, author).load().getComments().values()); } return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
private void serveGwtUi() { serve("/gerrit_ui/*").with(com.google.inject.Key.get(javax.servlet.http.HttpServlet.class, com.google.inject.name.Names.named(com.google.gerrit.httpd.raw.StaticModule.GWT_UI_SERVLET))); if ((warFs) == null) { filter("/").through(new com.google.gerrit.httpd.raw.RecompileGwtUiFilter(buckOut, unpackedWar)); } }
void onAuthFail(final com.google.gerrit.sshd.SshSession sd) { final org.apache.log4j.spi.LoggingEvent event = new org.apache.log4j.spi.LoggingEvent(org.apache.log4j.Logger.class.getName(), com.google.gerrit.sshd.SshLog.log, com.google.gerrit.common.TimeUtil.nowMs(), org.apache.log4j.Level.INFO, ("AUTH FAILURE FROM " + (sd.getRemoteAddressAsString())), "SSHD", null, null, null, null); event.setProperty(com.google.gerrit.sshd.SshLog.P_SESSION, com.google.gerrit.sshd.SshLog.id(sd.getSessionId())); event.setProperty(com.google.gerrit.sshd.SshLog.P_USER_NAME, sd.getUsername()); final java.lang.String error = sd.getAuthenticationError(); if (error != null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, error); } if ((async) != null) { async.append(event); } audit(null, "FAIL", "AUTH"); }








public com.codahale.metrics.Metric getMetric(java.lang.String name) { return registry.getMetrics().get(name); }
@java.lang.Override public synchronized com.google.gerrit.metrics.Timer newTimer(final java.lang.String name, com.google.gerrit.metrics.Description desc) { checkArgument((!(desc.isGauge())), "timer must not be a gauge"); checkArgument((!(desc.isRate())), "timer must not be a rate"); checkArgument(desc.isCumulative(), "timer must be cumulative"); checkArgument(((desc.getTimeUnit()) != null), "timer must have a unit"); checkNotDefined(name); descriptions.put(name, desc.getAnnotations()); final com.codahale.metrics.Timer metric = registry.timer(name); return new com.google.gerrit.metrics.Timer() { @java.lang.Override public void record(long value, java.util.concurrent.TimeUnit unit) { checkArgument((value >= 0), "timer delta must be >= 0"); metric.update(value, unit); } @java.lang.Override public void remove() { descriptions.remove(name); registry.remove(name); } }; }
@java.lang.Override public synchronized com.google.gerrit.extensions.registration.RegistrationHandle newTrigger(java.util.Set<com.google.gerrit.metrics.CallbackMetric<?>> metrics, java.lang.Runnable trigger) { for (com.google.gerrit.metrics.CallbackMetric<?> m : metrics) { checkNotDefined(((com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CallbackMetricImpl<?>) (m)).name); } final java.util.List<java.lang.String> names = new java.util.ArrayList(metrics.size()); for (com.google.gerrit.metrics.CallbackMetric<?> m : metrics) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CallbackMetricImpl<?> metric = ((com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CallbackMetricImpl<?>) (m)); registry.register(metric.name, metric.gauge(trigger)); names.add(metric.name); } return new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { for (java.lang.String name : names) { descriptions.remove(name); registry.remove(name); } } }; }

@java.lang.Override public synchronized com.google.gerrit.metrics.Counter newCounter(java.lang.String name, com.google.gerrit.metrics.Description desc) { checkArgument((!(desc.isGauge())), "counters must not be gauge"); checkNotDefined(name); descriptions.put(name, desc.getAnnotations()); if (desc.isRate()) { final com.codahale.metrics.Meter metric = registry.meter(name); return new com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CounterImpl(name) { @java.lang.Override public void incrementBy(long delta) { checkArgument((delta >= 0), "counter delta must be >= 0"); metric.mark(delta); } }; } else { final com.codahale.metrics.Counter metric = registry.counter(name); return new com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CounterImpl(name) { @java.lang.Override public void incrementBy(long delta) { checkArgument((delta >= 0), "counter delta must be >= 0"); metric.inc(delta); } }; } }
@java.lang.SuppressWarnings("unused") @java.lang.Override public <V> com.google.gerrit.metrics.CallbackMetric<V> newCallbackMetric(java.lang.String name, java.lang.Class<V> valueClass, com.google.gerrit.metrics.Description desc) { checkNotDefined(name); descriptions.put(name, desc.getAnnotations()); return new com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.CallbackMetricImpl<V>(name, valueClass); }








@java.lang.Override protected org.apache.sshd.common.session.AbstractSession createSession(final org.apache.sshd.common.io.IoSession io) throws java.lang.Exception { connected.incrementAndGet(); sesssionsCreated.increment(); if (io instanceof org.apache.sshd.common.io.mina.MinaSession) { if ((((org.apache.sshd.common.io.mina.MinaSession) (io)).getSession().getConfig()) instanceof org.apache.mina.transport.socket.SocketSessionConfig) { ((org.apache.mina.transport.socket.SocketSessionConfig) (((org.apache.sshd.common.io.mina.MinaSession) (io)).getSession().getConfig())).setKeepAlive(keepAlive); } } com.google.gerrit.sshd.GerritServerSession s = ((com.google.gerrit.sshd.GerritServerSession) (super.createSession(io))); int id = idGenerator.next(); java.net.SocketAddress peer = io.getRemoteAddress(); final com.google.gerrit.sshd.SshSession sd = new com.google.gerrit.sshd.SshSession(id, peer); s.setAttribute(SshSession.KEY, sd); s.addCloseSessionListener(new org.apache.sshd.common.future.SshFutureListener<org.apache.sshd.common.future.CloseFuture>() { @java.lang.Override public void operationComplete(org.apache.sshd.common.future.CloseFuture future) { connected.decrementAndGet(); if (sd.isAuthenticationError()) { sshLog.onAuthFail(sd); } } }); return s; }
@java.lang.Override public void operationComplete(org.apache.sshd.common.future.CloseFuture future) { connected.decrementAndGet(); if (sd.isAuthenticationError()) { sshLog.onAuthFail(sd); } }
public static void replyError(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, int statusCode, java.lang.String msg, com.google.gerrit.extensions.restapi.CacheControl c, @com.google.gerrit.common.Nullable java.lang.Throwable err) throws java.io.IOException { if (err != null) { com.google.gerrit.util.http.RequestUtil.setErrorTraceAttribute(req, err); } com.google.gerrit.httpd.restapi.RestApiServlet.configureCaching(req, res, null, null, c); res.setStatus(statusCode); com.google.gerrit.httpd.restapi.RestApiServlet.replyText(req, res, msg); }
@java.lang.Override public void doFilter(final javax.servlet.ServletRequest request, final javax.servlet.ServletResponse response, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.util.RequestContext old = local.setContext(requestContext.get()); try { try { chain.doFilter(request, response); } finally { cleanup.get().run(); } } finally { local.setContext(old); } }
@org.junit.Test public void addReviewer() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = user.email; gApi.changes().id(r.getChangeId()).addReviewer(in); assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(com.google.common.collect.ImmutableSet.of(user.id)); }


private void update(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.account.AuthRequest who, com.google.gerrit.reviewdb.client.AccountExternalId extId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = userFactory.create(extId.getAccountId()); com.google.gerrit.reviewdb.client.Account toUpdate = null; java.lang.String newEmail = who.getEmailAddress(); java.lang.String oldEmail = extId.getEmailAddress(); if ((newEmail != null) && (!(newEmail.equals(oldEmail)))) { if ((oldEmail != null) && (oldEmail.equals(user.getAccount().getPreferredEmail()))) { toUpdate = load(toUpdate, user.getAccountId(), db); toUpdate.setPreferredEmail(newEmail); } extId.setEmailAddress(newEmail); db.accountExternalIds().update(java.util.Collections.singleton(extId)); } if ((!(realm.allowsEdit(Account.FieldName.FULL_NAME))) && (!(com.google.gerrit.server.account.AccountManager.eq(user.getAccount().getFullName(), who.getDisplayName())))) { toUpdate = load(toUpdate, user.getAccountId(), db); toUpdate.setFullName(who.getDisplayName()); } if ((!(realm.allowsEdit(Account.FieldName.USER_NAME))) && (!(com.google.gerrit.server.account.AccountManager.eq(user.getUserName(), who.getUserName())))) { changeUserNameFactory.create(db, user, who.getUserName()); } if (toUpdate != null) { db.accounts().update(java.util.Collections.singleton(toUpdate)); } if ((newEmail != null) && (!(newEmail.equals(oldEmail)))) { byEmailCache.evict(oldEmail); byEmailCache.evict(newEmail); } if (toUpdate != null) { byIdCache.evict(toUpdate.getId()); } }
private void initPageHeader() { parseToken(); com.google.gwt.user.client.ui.HorizontalPanel hp = new com.google.gwt.user.client.ui.HorizontalPanel(); hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel()); com.google.gwt.user.client.ui.Label filterLabel = new com.google.gwt.user.client.ui.Label(Util.C.projectFilter()); filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel()); hp.add(filterLabel); filterTxt = new com.google.gwtexpui.globalkey.client.NpTextBox(); filterTxt.setValue(match); filterTxt.addKeyUpHandler(new com.google.gwt.event.dom.client.KeyUpHandler() { @java.lang.Override public void onKeyUp(com.google.gwt.event.dom.client.KeyUpEvent event) { com.google.gerrit.client.admin.ProjectBranchesScreen.Query q = new com.google.gerrit.client.admin.ProjectBranchesScreen.Query(filterTxt.getValue()); if (match.equals(q.qMatch)) { q.start(start); } else if ((query) == null) { q.run(); query = q; } } }); hp.add(filterTxt); add(hp); }
@java.lang.Override public void onKeyUp(com.google.gwt.event.dom.client.KeyUpEvent event) { com.google.gerrit.client.admin.ProjectBranchesScreen.Query q = new com.google.gerrit.client.admin.ProjectBranchesScreen.Query(filterTxt.getValue()); if (match.equals(q.qMatch)) { q.start(start); } else if ((query) == null) { q.run(); query = q; } }

@java.lang.Override protected void configureServlets() { serve("/static/*").with(com.google.gerrit.httpd.raw.SiteStaticDirectoryServlet.class); serveGwtUi(); install(new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.httpd.raw.StaticModule.CACHE, java.nio.file.Path.class, com.google.gerrit.httpd.raw.ResourceServlet.Resource.class).maximumWeight((1 << 20)).weigher(ResourceServlet.Weigher.class); } }); }

@java.lang.Override public void run() { if (reload()) { trigger.run(); } }



com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, userFactory, com.google.inject.util.Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts, index); }
@java.lang.SuppressWarnings("unchecked") private com.google.gerrit.server.query.Predicate<T> operator(final java.lang.String name, final java.lang.String value) throws com.google.gerrit.server.query.QueryParseException { @java.lang.SuppressWarnings("rawtypes") com.google.gerrit.server.query.QueryBuilder.OperatorFactory f = opFactories.get(name); if (f == null) { throw com.google.gerrit.server.query.QueryBuilder.error(((("Unsupported operator " + name) + ":") + value)); } return f.create(this, value); }
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.server.query.Predicate<T> create(Q builder, java.lang.String value) throws com.google.gerrit.server.query.QueryParseException { try { return ((com.google.gerrit.server.query.Predicate<T>) (method.invoke(builder, value))); } catch (java.lang.RuntimeException | java.lang.IllegalAccessException e) { throw com.google.gerrit.server.query.QueryBuilder.error(((("Error in operator " + (name)) + ":") + value), e); } catch (java.lang.reflect.InvocationTargetException e) { throw com.google.gerrit.server.query.QueryBuilder.error(((("Error in operator " + (name)) + ":") + value), e.getCause()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (refControl.getUser().isIdentifiedUser()) { com.google.gerrit.server.IdentifiedUser user = refControl.getUser().asIdentifiedUser(); java.lang.String refname = receiveEvent.refName; org.eclipse.jgit.lib.ObjectId old = receiveEvent.commit.getParent(0); if (receiveEvent.command.getRefName().startsWith(com.google.gerrit.server.git.validators.REFS_CHANGES)) { refname = refname.replace(com.google.gerrit.server.git.validators.R_HEADS, "refs/for/refs/heads/"); old = org.eclipse.jgit.lib.ObjectId.zeroId(); } com.google.gerrit.common.ChangeHookRunner.HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit); if ((result != null) && ((result.getExitValue()) != 0)) { throw new com.google.gerrit.server.git.validators.CommitValidationException(result.toString().trim()); } } return java.util.Collections.emptyList(); }
private java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> toAccountInfo(java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accounts) { return com.google.common.collect.FluentIterable.from(accounts).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo>() { @java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.reviewdb.client.Account.Id id) { return accountLoader.get(id); } }).toSortedList(new java.util.Comparator<com.google.gerrit.extensions.common.AccountInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.common.AccountInfo a, com.google.gerrit.extensions.common.AccountInfo b) { return com.google.common.collect.ComparisonChain.start().compare(a.name, b.name, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.email, b.email, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a._accountId, b._accountId, com.google.common.collect.Ordering.natural().nullsFirst()).result(); } }); }
public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId) throws com.google.gwtorm.server.OrmException { final java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> members = getMembers(groupId, new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>()); final java.util.List<com.google.gerrit.extensions.common.AccountInfo> memberInfos = com.google.common.collect.Lists.newArrayList(members.values()); java.util.Collections.sort(memberInfos, new java.util.Comparator<com.google.gerrit.extensions.common.AccountInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.common.AccountInfo a, com.google.gerrit.extensions.common.AccountInfo b) { return com.google.common.collect.ComparisonChain.start().compare(a.name, b.name, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a.email, b.email, com.google.common.collect.Ordering.natural().nullsFirst()).compare(a._accountId, b._accountId, com.google.common.collect.Ordering.natural().nullsFirst()).result(); } }); return memberInfos; }
@java.lang.Override public void onGitReferenceUpdated(final com.googlesource.gerrit.plugins.refprotection.Event event) { if (isRelevantRef(event)) { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); try { com.google.gerrit.server.project.ProjectResource project = new com.google.gerrit.server.project.ProjectResource(projectControl.controlFor(nameKey, user)); if ((isRefDeleted(event)) || (isNonFastForwardUpdate(event, project))) { backupBranch.createBackup(event, project); } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.googlesource.gerrit.plugins.refprotection.RefUpdateListener.log.error(e.getMessage(), e); } } }



private boolean isNonFastForwardUpdate(com.googlesource.gerrit.plugins.refprotection.Event event, com.google.gerrit.server.project.ProjectResource project) throws java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project.getNameKey())) { try (org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit oldCommit = walk.parseCommit(repo.resolve(event.getOldObjectId())); org.eclipse.jgit.revwalk.RevCommit newCommit = walk.parseCommit(repo.resolve(event.getNewObjectId())); return !(walk.isMergedInto(oldCommit, newCommit)); } } }
@java.lang.Override public void onGitReferenceUpdated(final com.googlesource.gerrit.plugins.refprotection.Event event) { if (isRelevantRef(event)) { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(event.getProjectName()); try { com.google.gerrit.server.project.ProjectResource project = new com.google.gerrit.server.project.ProjectResource(projectControl.controlFor(nameKey, user)); boolean protectDeleted = cfg.getFromGerritConfig(RefProtectionModule.NAME).getBoolean("protectDeleted", true); boolean protectFastForward = cfg.getFromGerritConfig(RefProtectionModule.NAME).getBoolean("protectFastForward", true); if ((protectDeleted && (isRefDeleted(event))) || (protectFastForward && (isNonFastForwardUpdate(event, project)))) { backupBranch.createBackup(event, project); } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.googlesource.gerrit.plugins.refprotection.RefUpdateListener.log.error(e.getMessage(), e); } } }
public void createBackup(com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Event event, com.google.gerrit.server.project.ProjectResource project) { java.lang.String branchName = event.getRefName(); java.lang.String backupRef = get(project, branchName); if (backupRef.equals(branchName)) { return; } com.google.gerrit.server.project.CreateBranch.Input input = new com.google.gerrit.server.project.CreateBranch.Input(); input.ref = backupRef; input.revision = event.getOldObjectId(); try { createBranchFactory.create(backupRef).apply(project, input); } catch (com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.extensions.restapi.ResourceConflictException | java.io.IOException e) { com.googlesource.gerrit.plugins.refprotection.BackupBranch.log.error(e.getMessage(), e); } }
public void createBackup(com.google.gerrit.extensions.events.GitReferenceUpdatedListener.Event event, com.google.gerrit.server.project.ProjectResource project) { java.lang.String branchName = event.getRefName(); java.lang.String backupRef = get(branchName); if (backupRef.equals(branchName)) { return; } com.google.gerrit.server.project.CreateBranch.Input input = new com.google.gerrit.server.project.CreateBranch.Input(); input.ref = backupRef; input.revision = event.getOldObjectId(); try { createBranchFactory.create(backupRef).apply(project, input); } catch (com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.extensions.restapi.ResourceConflictException | java.io.IOException e) { com.googlesource.gerrit.plugins.refprotection.BackupBranch.log.error(e.getMessage(), e); } }


private java.lang.String get(java.lang.String branchName) { if ((branchName.startsWith(com.googlesource.gerrit.plugins.refprotection.R_HEADS)) || (branchName.startsWith(com.googlesource.gerrit.plugins.refprotection.R_TAGS))) { return java.lang.String.format("%s-%s", ((com.googlesource.gerrit.plugins.refprotection.BackupBranch.R_BACKUPS) + (branchName.replaceFirst(com.googlesource.gerrit.plugins.refprotection.R_REFS, ""))), new java.text.SimpleDateFormat("YYYYMMdd-HHmmss").format(new java.util.Date())); } return branchName; }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); }
@java.lang.Override protected void onLoad() { commentsPanel.setVisible(false); post.setEnabled(false); com.google.gerrit.client.changes.ChangeApi.drafts(psId.getParentKey().get()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { displayComments(result); post.setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { post.setEnabled(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { java.lang.String t = message.getText(); if (t != null) { message.setCursorPos(t.length()); } return false; } }, 0); }
private void postReview() { in.message(message.getText().trim()); in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS); in.prePost(); com.google.gerrit.client.changes.ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(psId.getParentKey(), java.lang.String.valueOf(psId.get()))); } }); hide(); }

@java.lang.Override public void onFailure(java.lang.Throwable e) { enableEdit(true); pendingGroup = null; super.onFailure(e); }
@java.lang.Override public void onFailure(final java.lang.Throwable caught) { text.setReadOnly(false); text.setFocus(true); save.setEnabled(true); cancel.setEnabled(true); discard.setEnabled(true); super.onFailure(caught); onSave.onFailure(caught); }
void setEdit(boolean edit) { com.google.gwt.user.client.ui.UIObject.setVisible(summary, false); com.google.gwt.user.client.ui.UIObject.setVisible(p_view, (!edit)); com.google.gwt.user.client.ui.UIObject.setVisible(p_edit, edit); setRangeHighlight(edit); if (edit) { java.lang.String msg = ((comment.message()) != null) ? comment.message().trim() : ""; editArea.setValue(msg); cancel.setVisible((!(isNew()))); expandText(); editAreaHeight = editArea.getOffsetHeight(); final int len = msg.length(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { editArea.setFocus(true); if (len > 0) { editArea.setCursorPos(len); } } }); } else { expandTimer.cancel(); resizeTimer.cancel(); } getCommentManager().setUnsaved(this, edit); getCommentGroup().resize(); }



@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Change> load(com.google.gerrit.reviewdb.client.Project.NameKey key) throws java.lang.Exception { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(key); try (com.google.gerrit.server.util.ManualRequestContext ctx = requestContext.open()) { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getReviewDbProvider().get(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES); java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> ids = new java.util.LinkedHashSet<>(); for (org.eclipse.jgit.lib.Ref r : refs.values()) { com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.fromRef(r.getName()); if (id != null) { ids.add(id); } } java.util.List<com.google.gerrit.reviewdb.client.Change> changes = new java.util.ArrayList(ids.size()); for (java.util.List<com.google.gerrit.reviewdb.client.Change.Id> batch : com.google.common.collect.Iterables.partition(ids, 30)) { com.google.common.collect.Iterables.addAll(changes, db.changes().get(batch)); } return changes; } finally { repo.close(); } }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.GWT_UI_SERVLET) javax.servlet.http.HttpServlet getGwtUiServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) throws java.io.IOException { if ((warFs) != null) { return new com.google.gerrit.httpd.raw.WarGwtUiServlet(cache, warFs); } else { return new com.google.gerrit.httpd.raw.DeveloperGwtUiServlet(cache, unpackedWar); } }
public void doClaSignupHook(com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.common.data.ContributorAgreement cla);
private java.nio.file.Path polyGerritBasePath() { return (warFs) != null ? warFs.getPath("/polygerrit_ui") : buckOut.getParent().resolve("polygerrit-ui").resolve("app"); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse res, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { java.lang.String pkg = "gerrit-gwtui"; java.lang.String target = "ui_" + (rule.select(((javax.servlet.http.HttpServletRequest) (request)))); if ((gwtuiRecompile) || (!(uaInitialized.contains(target)))) { java.lang.String rule = (("//" + pkg) + ":") + target; java.lang.String child = java.lang.String.format("%s/__gwt_binary_%s__", pkg, target); java.io.File zip = gen.resolve(child).resolve((target + ".zip")).toFile(); synchronized(this) { try { com.google.gerrit.httpd.raw.RecompileGwtUiFilter.build(root, gen, rule); } catch (com.google.gerrit.httpd.raw.RecompileGwtUiFilter.BuildFailureException e) { displayFailure(rule, e.why, ((javax.servlet.http.HttpServletResponse) (res))); return; } if ((!(target.equals(lastTarget))) || ((lastTime) != (zip.lastModified()))) { lastTarget = target; lastTime = zip.lastModified(); com.google.gerrit.httpd.raw.RecompileGwtUiFilter.unpack(zip, unpackedWar.toFile()); } } uaInitialized.add(target); } chain.doFilter(request, res); }





void set(com.google.gerrit.client.changes.ChangeInfo info) { java.util.List<java.lang.String> names = new java.util.ArrayList(info.labels()); java.util.Collections.sort(names); resize(names.size(), 2); for (int row = 0; row < (names.size()); row++) { java.lang.String name = names.get(row); com.google.gerrit.client.changes.ChangeInfo.LabelInfo label = info.label(name); setText(row, 0, name); if ((label.all()) != null) { setWidget(row, 1, renderUsers(label)); } getCellFormatter().setStyleName(row, 0, style.labelName()); getCellFormatter().addStyleName(row, 0, getStyleForLabel(label)); } }

private static void onRemove(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); if (user != null) { final com.google.gerrit.client.change.ChangeScreen2 screen = com.google.gerrit.client.change.ChangeScreen2.get(event); com.google.gerrit.client.changes.ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } } }); } }

@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.changes.ChangeList.query(query, ChangeTable.OPTIONS, loadCallback(), start, pageSize); }
public java.util.List<com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult> doQuery(java.lang.String q) throws com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException { if (((parser) == null) || ((searcher) == null)) { throw new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException("Documentation search not available"); } try { org.apache.lucene.search.Query query = parser.parse(q); org.apache.lucene.search.TopDocs results = searcher.search(query, java.lang.Integer.MAX_VALUE); org.apache.lucene.search.ScoreDoc[] hits = results.scoreDocs; int totalHits = results.totalHits; java.util.List<com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult> out = com.google.common.collect.Lists.newArrayListWithCapacity(totalHits); for (int i = 0; i < totalHits; i++) { com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult result = new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult(); org.apache.lucene.document.Document doc = searcher.doc(hits[i].doc); result.url = doc.get(Constants.URL_FIELD); result.title = doc.get(Constants.TITLE_FIELD); out.add(result); } return out; } catch (java.io.IOException | org.apache.lucene.queryparser.classic.ParseException e) { throw new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException(e); } }

@org.junit.Test public void byLabelGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user1")).getAccountId(); com.google.gerrit.reviewdb.client.Account.Id user2 = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user2")).getAccountId(); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.server.query.change.InMemoryRepository> repo = createProject("repo"); com.google.gerrit.reviewdb.client.AccountGroup.Id adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).getId(); createGroup("group1", adminGroup, user1); createGroup("group2", adminGroup, user2); com.google.gerrit.server.change.ChangeInserter ins = newChange(repo, null, null, user1.get(), null); com.google.gerrit.reviewdb.client.Change change1 = ins.insert(); requestContext.setContext(newRequestContext(user1)); com.google.gerrit.extensions.api.changes.ReviewInput input = new com.google.gerrit.extensions.api.changes.ReviewInput(); input.labels = com.google.common.collect.ImmutableMap.<java.lang.String, java.lang.Short>of("Code-Review", ((short) (1))); postReview.apply(new com.google.gerrit.server.query.change.RevisionResource(changes.parse(change1.getId()), ins.getPatchSet()), input); requestContext.setContext(newRequestContext(userId)); assertResultEquals(change1, queryOne("label:Code-Review=+1,group1")); assertResultEquals(change1, queryOne("label:Code-Review=+1,group=group1")); assertResultEquals(change1, queryOne("label:Code-Review=+1,user=user1")); assertThat(query("label:Code-Review=+1,user=user2")).isEmpty(); assertThat(query("label:Code-Review=+1,group=group2")).isEmpty(); }


private java.nio.file.Path getDeveloperBuckOut() { try { return com.google.gerrit.launcher.GerritLauncher.getDeveloperBuckOut(); } catch (java.io.FileNotFoundException e) { return null; } }
public static java.nio.file.Path getDeveloperBuckOut() throws java.io.FileNotFoundException { java.lang.Class<com.google.gerrit.launcher.GerritLauncher> self = com.google.gerrit.launcher.GerritLauncher.class; java.net.URL u = self.getResource(((self.getSimpleName()) + ".class")); if (u == null) { throw new java.io.FileNotFoundException(("Cannot find class " + (self.getName()))); } else if ("jar".equals(u.getProtocol())) { java.lang.String p = u.getPath(); try { u = new java.net.URL(p.substring(0, p.indexOf('!'))); } catch (java.net.MalformedURLException e) { java.io.FileNotFoundException fnfe = new java.io.FileNotFoundException(("Not a valid jar file: " + u)); fnfe.initCause(e); throw fnfe; } } if (!("file".equals(u.getProtocol()))) { throw new java.io.FileNotFoundException(("Cannot find extract path from " + u)); } java.nio.file.Path dir = java.nio.file.Paths.get(u.getPath()); while (!(com.google.gerrit.launcher.GerritLauncher.name(dir).equals("buck-out"))) { java.nio.file.Path parent = dir.getParent(); if ((parent == null) || (parent.equals(dir))) { throw new java.io.FileNotFoundException(("Cannot find buck-out from " + u)); } dir = parent; } return dir; }
public com.google.gerrit.server.IdentifiedUser runAs(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.server.CurrentUser caller) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, realm, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, remotePeerProvider, dbProvider, id, caller); }
public void asyncStarredChanges() { if (((starredChanges) == null) && ((dbProvider) != null)) { try { starredQuery = starredQuery(); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.IdentifiedUser.log.warn("Cannot query starred by user changes", e); starredQuery = null; starredChanges = java.util.Collections.emptySet(); } } }
public com.google.gerrit.server.CurrentUser runAs(java.net.SocketAddress remotePeer, com.google.gerrit.reviewdb.client.Account.Id id, @com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, realm, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, com.google.inject.util.Providers.of(remotePeer), null, id, caller); }
public com.google.gerrit.server.IdentifiedUser create(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db, com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, realm, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, null, db, id, null); }
public com.google.gerrit.server.IdentifiedUser create(java.net.SocketAddress remotePeer, com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, realm, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, com.google.inject.util.Providers.of(remotePeer), null, id, null); }


public com.google.gerrit.server.IdentifiedUser create(com.google.gerrit.reviewdb.client.Account.Id id) { return new com.google.gerrit.server.IdentifiedUser(capabilityControlFactory, authConfig, realm, anonymousCowardName, canonicalUrl, accountCache, groupBackend, disableReverseDnsLookup, remotePeerProvider, dbProvider, id, null); }









public void abortStarredChanges() { if ((starredQuery) != null) { try { starredQuery.close(); } finally { starredQuery = null; } } }

public static java.lang.StringBuilder buildRefsDraftCommentsPrefix(com.google.gerrit.reviewdb.client.Account.Id accountId) { java.lang.StringBuilder r = new java.lang.StringBuilder(); r.append(com.google.gerrit.reviewdb.client.RefNames.REFS_DRAFT_COMMENTS); int n = (accountId.get()) % 100; if (n < 10) { r.append('0'); } r.append(n); r.append('/'); r.append(accountId.get()); r.append('-'); return r; }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> getStarredChanges() { if ((starredChanges) == null) { checkRequestScope(); try { starredChanges = com.google.gerrit.server.IdentifiedUser.starredChangeIds(((starredQuery) != null ? starredQuery : starredQuery())); } catch (com.google.gwtorm.server.OrmException | java.lang.RuntimeException e) { com.google.gerrit.server.IdentifiedUser.log.warn("Cannot query starred changes", e); starredChanges = java.util.Collections.emptySet(); } finally { starredQuery = null; } } return starredChanges; }
public static java.lang.String refsDraftCommentsPrefix(com.google.gerrit.reviewdb.client.Account.Id accountId) { return com.google.gerrit.reviewdb.client.RefNames.buildRefsDraftCommentsPrefix(accountId).toString(); }
public static java.lang.String refsDraftComments(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Change.Id changeId) { java.lang.StringBuilder r = com.google.gerrit.reviewdb.client.RefNames.buildRefsDraftCommentsPrefix(accountId); r.append(changeId.get()); return r.toString(); }
protected void bccStarredBy() { try { for (com.google.gerrit.reviewdb.client.StarredChange w : args.db.get().starredChanges().byChange(change.getId())) { super.add(RecipientType.BCC, w.getAccountId()); } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot BCC users that starred updated change", err); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.StarredChange rsrc, com.google.gerrit.server.account.StarredChanges.EmptyInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if ((self.get()) != (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed remove starred change"); } dbProvider.get().starredChanges().delete(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(rsrc.getUser().getAccountId(), rsrc.getChange().getId())))); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.reviewdb.client.StarredChange parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); try { user.asyncStarredChanges(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); if (user.getStarredChanges().contains(change.getChange().getId())) { return new com.google.gerrit.server.account.AccountResource.StarredChange(user, change); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } finally { user.abortStarredChanges(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.StarredChanges.EmptyInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if ((self.get()) != (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add starred change"); } try { dbProvider.get().starredChanges().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(rsrc.getUser().getAccountId(), change.getChange().getId())))); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { return com.google.gerrit.extensions.restapi.Response.none(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.FileInfo> files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); int index = 0; for (int i = 0; i < (files.length()); i++) { if (path.equals(files.get(i).path())) { index = i; break; } } com.google.gerrit.client.info.FileInfo nextInfo = (index == ((files.length()) - 1)) ? null : files.get((index + 1)); com.google.gwtexpui.globalkey.client.KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), (index == 0 ? null : files.get((index - 1)))); com.google.gwtexpui.globalkey.client.KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo); if ((p != null) && (n != null)) { keys.pair(p, n); } nextPath = (nextInfo != null) ? nextInfo.path() : null; }


private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); copySelfOnEmails.setEnabled(on); reversePatchSetOrder.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); sizeBarInChangeTable.setEnabled(on); legacycidInChangeTable.setEnabled(on); reviewCategoryStrategy.setEnabled(on); commentVisibilityStrategy.setEnabled(on); changeScreen.setEnabled(on); diffView.setEnabled(on); }
java.lang.String copySelfOnEmails();
public void setCopySelfOnEmails(boolean includeSelfOnEmail) { copySelfOnEmail = includeSelfOnEmail; }
private void display(com.google.gerrit.client.account.Preferences p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); copySelfOnEmails.setValue(p.copySelfOnEmail()); reversePatchSetOrder.setValue(p.reversePatchSetOrder()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.commentVisibilityStrategy()); setListBox(changeScreen, null, p.changeScreen()); setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView()); display(p.my()); }
public boolean isCopySelfOnEmails() { return copySelfOnEmail; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.account.SetPreferences.Input i) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((((((((((((((((i.changesPerPage) != null) || ((i.showSiteHeader) != null)) || ((i.useFlashClipboard) != null)) || ((i.downloadScheme) != null)) || ((i.downloadCommand) != null)) || ((i.copySelfOnEmail) != null)) || ((i.dateFormat) != null)) || ((i.timeFormat) != null)) || ((i.reversePatchSetOrder) != null)) || ((i.relativeDateInChangeTable) != null)) || ((i.sizeBarInChangeTable) != null)) || ((i.legacycidInChangeTable) != null)) || ((i.reviewCategoryStrategy) != null)) || ((i.commentVisibilityStrategy) != null)) || ((i.diffView) != null)) || ((i.changeScreen) != null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported option"); } com.google.gerrit.server.account.VersionedAccountPreferences p; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName); try { p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); p.commit(md); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, md.getRepository()); } finally { md.close(); } }
public void resetToDefaults() { maximumPageSize = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DEFAULT_PAGESIZE; showSiteHeader = true; useFlashClipboard = true; copySelfOnEmail = false; reversePatchSetOrder = false; reviewCategoryStrategy = null; downloadUrl = null; downloadCommand = null; dateFormat = null; timeFormat = null; relativeDateInChangeTable = false; commentVisibilityStrategy = null; diffView = null; changeScreen = null; sizeBarInChangeTable = true; legacycidInChangeTable = false; }
@org.junit.Test public void updatedOrderWithMinuteResolution() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(2, java.util.concurrent.TimeUnit.MINUTES); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = insert(ins1); com.google.gerrit.reviewdb.client.Change change2 = insert(newChange(repo, null, null, null, null)); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isLessThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertQuery("status:new", change2, change1); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput()); change1 = db.changes().get(change1.getId()); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isGreaterThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertThat(((com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)) - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)))).isGreaterThan(java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.MINUTES)); assertQuery("status:new", change1, change2); }
@org.junit.Test public void byBefore() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, null, null)); com.google.gerrit.reviewdb.client.Change change2 = insert(newChange(repo, null, null, null, null)); clockStepMs = 0; assertQuery("before:2009-09-29"); assertQuery("before:2009-09-30"); assertQuery("before:\"2009-09-30 16:59:00 -0400\""); assertQuery("before:\"2009-09-30 20:59:00 -0000\""); assertQuery("before:\"2009-09-30 20:59:00\""); assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1); assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1); assertQuery("before:\"2009-10-01 21:02:00\"", change1); assertQuery("before:2009-10-01", change1); assertQuery("before:2009-10-03", change2, change1); }
@org.junit.Before public void setTimeForTesting() { systemTimeZone = java.lang.System.setProperty("user.timezone", "US/Eastern"); clockStepMs = 1; final java.util.concurrent.atomic.AtomicLong clockMs = new java.util.concurrent.atomic.AtomicLong(new org.joda.time.DateTime(2009, 9, 30, 17, 0, 0).getMillis()); org.joda.time.DateTimeUtils.setCurrentMillisProvider(new org.joda.time.DateTimeUtils.MillisProvider() { @java.lang.Override public long getMillis() { return clockMs.getAndAdd(clockStepMs); } }); }
@org.junit.Test public void byAfter() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, null, null)); com.google.gerrit.reviewdb.client.Change change2 = insert(newChange(repo, null, null, null, null)); clockStepMs = 0; assertQuery("after:2009-10-03"); assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2); assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2); assertQuery("after:2009-10-01", change2); assertQuery("after:2009-09-30", change2, change1); }
@org.junit.Test public void byAge() throws java.lang.Exception { long thirtyHours = java.util.concurrent.TimeUnit.MILLISECONDS.convert(30, java.util.concurrent.TimeUnit.HOURS); clockStepMs = thirtyHours; org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, null, null)); com.google.gerrit.reviewdb.client.Change change2 = insert(newChange(repo, null, null, null, null)); clockStepMs = 0; long now = com.google.gerrit.common.TimeUtil.nowMs(); assertThat(((com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)) - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)))).isEqualTo(thirtyHours); assertThat((now - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)))).isEqualTo(thirtyHours); assertThat(com.google.gerrit.common.TimeUtil.nowMs()).isEqualTo(now); assertQuery("-age:1d"); assertQuery((("-age:" + ((30 * 60) - 1)) + "m")); assertQuery("-age:2d", change2); assertQuery("-age:3d", change2, change1); assertQuery("age:3d"); assertQuery("age:2d", change1); assertQuery("age:1d", change2, change1); }

@org.junit.Test public void updateOrder() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(2, java.util.concurrent.TimeUnit.MINUTES); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); java.util.List<com.google.gerrit.server.change.ChangeInserter> inserters = com.google.common.collect.Lists.newArrayList(); java.util.List<com.google.gerrit.reviewdb.client.Change> changes = com.google.common.collect.Lists.newArrayList(); for (int i = 0; i < 5; i++) { inserters.add(newChange(repo, null, null, null, null)); changes.add(insert(inserters.get(i))); } for (int i : com.google.common.collect.ImmutableList.of(2, 0, 1, 4, 3)) { gApi.changes().id(changes.get(i).getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput().message(("modifying " + i))); } assertQuery("status:new", changes.get(3), changes.get(4), changes.get(1), changes.get(0), changes.get(2)); }
@org.junit.Before public void setTimeForTesting() { systemTimeZone = java.lang.System.setProperty("user.timezone", "US/Eastern"); clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.SECONDS); final java.util.concurrent.atomic.AtomicLong clockMs = new java.util.concurrent.atomic.AtomicLong(new org.joda.time.DateTime(2009, 9, 30, 17, 0, 0).getMillis()); org.joda.time.DateTimeUtils.setCurrentMillisProvider(new org.joda.time.DateTimeUtils.MillisProvider() { @java.lang.Override public long getMillis() { return clockMs.getAndAdd(clockStepMs); } }); }

private void setTimeForTesting() { systemTimeZone = java.lang.System.setProperty("user.timezone", "US/Eastern"); clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.SECONDS); final java.util.concurrent.atomic.AtomicLong clockMs = new java.util.concurrent.atomic.AtomicLong(new org.joda.time.DateTime(2009, 9, 30, 17, 0, 0).getMillis()); org.joda.time.DateTimeUtils.setCurrentMillisProvider(new org.joda.time.DateTimeUtils.MillisProvider() { @java.lang.Override public long getMillis() { return clockMs.getAndAdd(clockStepMs); } }); }
@org.junit.Test public void isReviewed() throws java.lang.Exception { clockStepMs = java.util.concurrent.TimeUnit.MILLISECONDS.convert(2, java.util.concurrent.TimeUnit.MINUTES); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, null, null)); com.google.gerrit.reviewdb.client.Change change2 = insert(newChange(repo, null, null, null, null)); com.google.gerrit.reviewdb.client.Change change3 = insert(newChange(repo, null, null, null, null)); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput().message("comment")); com.google.gerrit.reviewdb.client.Account.Id user2 = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("anotheruser")).getAccountId(); requestContext.setContext(newRequestContext(user2)); gApi.changes().id(change2.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); com.google.gerrit.reviewdb.client.PatchSet.Id ps3_1 = change3.currentPatchSetId(); change3 = newPatchSet(repo, change3); assertThat(change3.currentPatchSetId()).isNotEqualTo(ps3_1); gApi.changes().id(change3.getId().get()).revision(ps3_1.get()).review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); assertQuery("is:reviewed", change2); assertQuery("-is:reviewed", change3, change1); }
void setEdit(boolean edit) { com.google.gwt.user.client.ui.UIObject.setVisible(summary, false); com.google.gwt.user.client.ui.UIObject.setVisible(p_view, (!edit)); com.google.gwt.user.client.ui.UIObject.setVisible(p_edit, edit); setRangeHighlight(edit); if (edit) { java.lang.String msg = ((comment.message()) != null) ? comment.message().trim() : ""; editArea.setValue(msg); cancel.setVisible((!(isNew()))); expandText(); editAreaHeight = editArea.getOffsetHeight(); final int len = msg.length(); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { editArea.setFocus(true); if (len > 0) { editArea.setCursorPos(len); } } }); } else { expandTimer.cancel(); resizeTimer.cancel(); } getCommentManager().setUnsaved(this, edit); getCommentGroup().resize(); }


@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = getRevision(); if (rev == null) { loadDefaults(); return; } try (org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(reader);com.google.gerrit.server.notedb.ChangeNotesParser parser = new com.google.gerrit.server.notedb.ChangeNotesParser(change, rev, walk, repoManager)) { parser.parseAll(); if ((parser.status) != null) { change.setStatus(parser.status); } approvals = parser.buildApprovals(); changeMessages = parser.buildMessages(); comments = com.google.common.collect.ImmutableListMultimap.copyOf(parser.comments); noteMap = parser.commentNoteMap; if ((parser.hashtags) != null) { hashtags = com.google.common.collect.ImmutableSet.copyOf(parser.hashtags); } else { hashtags = com.google.common.collect.ImmutableSet.of(); } ImmutableSetMultimap.Builder<com.google.gerrit.server.notedb.ReviewerState, com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.ImmutableSetMultimap.builder(); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.notedb.ReviewerState> e : parser.reviewers.entrySet()) { reviewers.put(e.getValue(), e.getKey()); } this.reviewers = reviewers.build(); this.allPastReviewers = com.google.common.collect.ImmutableList.copyOf(parser.allPastReviewers); submitRecords = com.google.common.collect.ImmutableList.copyOf(parser.submitRecords); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.server.change.DeleteVote.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.server.project.ChangeControl ctl = r.getControl(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(r.getReviewerUser().getAccountId(), rsrc.getLabel())); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }





private static boolean isUnreasonableName(java.lang.String name) { return ((((((name.length()) < 1) || (name.contains("\\"))) || (name.startsWith("../"))) || (name.contains("/../"))) || (name.contains("/./"))) || (name.contains("//")); }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.access.ListAccess.ProjectAccessInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.server.access.ListAccess.ProjectAccessInfo> access = com.google.common.collect.Maps.newTreeMap(); for (java.lang.String p : projects) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = new com.google.gerrit.reviewdb.client.Project.NameKey(p); com.google.gerrit.server.project.ProjectControl pc = open(projectName); com.google.gerrit.server.git.ProjectConfig config; try { com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName); try { config = com.google.gerrit.server.git.ProjectConfig.read(md); if (config.updateGroupNames(groupBackend)) { md.setMessage("Update group names\n"); config.commit(md); projectCache.evict(config.getProject()); pc = open(projectName); } else if (((config.getRevision()) != null) && (!(config.getRevision().equals(pc.getProjectState().getConfig().getRevision())))) { projectCache.evict(config.getProject()); pc = open(projectName); } } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } finally { md.close(); } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(p); } access.put(p, new com.google.gerrit.server.access.ListAccess.ProjectAccessInfo(pc, config)); } return access; }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.server.change.TestSubmitRule.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.server.change.TestSubmitRule.Input(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.server.change.TestSubmitRule.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule(), rec)); } return rec.type; }








@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change otherChange = object.change(); if (otherChange == null) { return false; } if (!(otherChange.getDest().equals(c.getDest()))) { return false; } com.google.gerrit.extensions.client.SubmitType submitType = getSubmitType(object); if (submitType == null) { return false; } org.eclipse.jgit.lib.ObjectId other = org.eclipse.jgit.lib.ObjectId.fromString(object.currentPatchSet().getRevision().get()); com.google.gerrit.server.query.change.ConflictKey conflictsKey = new com.google.gerrit.server.query.change.ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge()); java.lang.Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey); if (conflicts != null) { return conflicts; } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(otherChange.getProject());com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo)) { org.eclipse.jgit.revwalk.RevFlag canMergeFlag = rw.newFlag("CAN_MERGE"); com.google.gerrit.server.git.CodeReviewCommit commit = rw.parseCommit(changeDataCache.getTestAgainst()); com.google.gerrit.server.git.strategy.SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest(), null); com.google.gerrit.server.git.CodeReviewCommit otherCommit = rw.parseCommit(other); otherCommit.add(canMergeFlag); conflicts = !(strategy.dryRun(commit, otherCommit)); args.conflictsCache.put(conflictsKey, conflicts); return conflicts; } catch (com.google.gerrit.server.git.IntegrationException | com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new java.lang.IllegalStateException(e); } }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.git.IntegrationException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (key.into.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return true; } org.eclipse.jgit.lib.RefDatabase refDatabase = repo.getRefDatabase(); java.lang.Iterable<org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values()); try (com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo)) { org.eclipse.jgit.revwalk.RevFlag canMerge = rw.newFlag("CAN_MERGE"); com.google.gerrit.server.git.CodeReviewCommit rev = rw.parseCommit(key.commit); rev.add(canMerge); com.google.gerrit.server.git.CodeReviewCommit tip = rw.parseCommit(key.into); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> accepted = alreadyAccepted(rw, refs); accepted.add(tip); accepted.addAll(java.util.Arrays.asList(rev.getParents())); return submitStrategyFactory.create(key.submitType, db, repo, rw, null, canMerge, accepted, dest, null).dryRun(tip, rev); } }
private void checkSubmitRulesAndState(com.google.gerrit.server.git.ChangeSet cs) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { java.lang.StringBuilder msgbuf = new java.lang.StringBuilder(); java.util.List<com.google.gerrit.reviewdb.client.Change.Id> problemChanges = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.Change.Id id : cs.ids()) { try { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db, id); if ((cd.change().getStatus()) != (Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((("Change " + (cd.change().getChangeId())) + " is in state ") + (cd.change().getStatus()))); } else { records.put(cd.change().getId(), com.google.gerrit.server.git.MergeOp.checkSubmitRule(cd)); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { msgbuf.append(((e.getMessage()) + "\n")); problemChanges.add(id); } } java.lang.String reason = msgbuf.toString(); if (!(reason.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((((("The change could not be " + "submitted because it depends on change(s) ") + (problemChanges.toString())) + ", which could not be submitted ") + "because:\n") + reason)); } }

@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); com.google.gerrit.server.project.ChangeControl ctl = ctx.getChangeControl(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getChangeUpdate(); if ((patchSet.getGroups()) == null) { patchSet.setGroups(com.google.gerrit.server.git.GroupCollector.getDefaultGroups(patchSet)); } db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); update.setTopic(change.getTopic()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals); if ((message) != null) { changeMessage = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId()); changeMessage.setMessage(message); cmUtil.addChangeMessage(db, update, changeMessage); } }

public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(c.getProject())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.server.project.SubmitRuleEvaluator(this).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Error in mergeability check: " + (rec.errorMessage))); } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo, db); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet ps) { try { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db, ctl); com.google.gerrit.common.data.SubmitTypeRecord r = new com.google.gerrit.server.project.SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType(); if ((r.status) != (SubmitTypeRecord.Status.OK)) { logError(("Failed to get submit type for " + (ctl.getChange().getKey()))); return null; } return r.type; } catch (com.google.gwtorm.server.OrmException e) { logError(("Failed to get submit type for " + (ctl.getChange().getKey())), e); return null; } }

@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> has(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException { if ("star".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(args); } if ("draft".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.HasDraftByPredicate(args, self()); } if ("edit".equalsIgnoreCase(value)) { return new com.google.gerrit.server.query.change.EditByPredicate(self()); } throw new java.lang.IllegalArgumentException(); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> draftby(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = parseAccount(who); java.util.List<com.google.gerrit.server.query.change.HasDraftByPredicate> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { p.add(new com.google.gerrit.server.query.change.HasDraftByPredicate(args, id)); } return com.google.gerrit.server.query.Predicate.or(p); }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { return !(args.plcUtil.draftByChangeAuthor(args.db.get(), object.notes(), accountId).isEmpty()); }
@java.lang.Override public void doDraftPublishedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.DraftPublishedEvent event = new com.google.gerrit.server.events.DraftPublishedEvent(); com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), draftPublishedHook, args); }
@java.lang.Override public void doProjectCreatedHook(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String headName) { com.google.gerrit.server.events.ProjectCreatedEvent event = new com.google.gerrit.server.events.ProjectCreatedEvent(); event.projectName = project.get(); event.headName = headName; fireEvent(project, event); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--project", project.get()); addArg(args, "--head", headName); runHook(project, projectCreatedHook, args); }
@java.lang.Override public void doMergeFailedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.String reason, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.MergeFailedEvent event = new com.google.gerrit.server.events.MergeFailedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.reason = reason; fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), mergeFailedHook, args); }
@java.lang.Override public void doChangeRestoredHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.String reason, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.ChangeRestoredEvent event = new com.google.gerrit.server.events.ChangeRestoredEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.restorer = eventFactory.asAccountAttribute(account); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.reason = reason; fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--restorer", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeRestoredHook, args); }
@java.lang.Override public void doRefUpdatedHook(com.google.gerrit.reviewdb.client.Branch.NameKey refName, org.eclipse.jgit.lib.ObjectId oldId, org.eclipse.jgit.lib.ObjectId newId, com.google.gerrit.reviewdb.client.Account account) { com.google.gerrit.server.events.RefUpdatedEvent event = new com.google.gerrit.server.events.RefUpdatedEvent(); if (account != null) { event.submitter = eventFactory.asAccountAttribute(account); } event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName); fireEvent(refName, event); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--oldrev", event.refUpdate.oldRev); addArg(args, "--newrev", event.refUpdate.newRev); addArg(args, "--refname", event.refUpdate.refName); addArg(args, "--project", event.refUpdate.project); if (account != null) { addArg(args, "--submitter", getDisplayName(account)); } runHook(refName.getParentKey(), refUpdatedHook, args); }
@java.lang.Override public void doChangeMergedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db, java.lang.String mergeResultRev) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.ChangeMergedEvent event = new com.google.gerrit.server.events.ChangeMergedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.submitter = eventFactory.asAccountAttribute(account); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.newRev = mergeResultRev; fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--submitter", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--newrev", mergeResultRev); runHook(change.getProject(), changeMergedHook, args); }
@java.lang.Override public void doPatchsetCreatedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.PatchSetCreatedEvent event = new com.google.gerrit.server.events.PatchSetCreatedEvent(); com.google.gerrit.server.account.AccountState uploader = accountCache.get(patchSet.getUploader()); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--is-draft", java.lang.String.valueOf(patchSet.isDraft())); addArg(args, "--kind", java.lang.String.valueOf(event.patchSet.kind)); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--uploader", getDisplayName(uploader.getAccount())); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--patchset", event.patchSet.number); runHook(change.getProject(), patchsetCreatedHook, args); }
@java.lang.Override public void doReviewerAddedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.ReviewerAddedEvent event = new com.google.gerrit.server.events.ReviewerAddedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.reviewer = eventFactory.asAccountAttribute(account); fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--reviewer", getDisplayName(account)); runHook(change.getProject(), reviewerAddedHook, args); }
@java.lang.Override public void doTopicChangedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.lang.String oldTopic, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.TopicChangedEvent event = new com.google.gerrit.server.events.TopicChangedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.changer = eventFactory.asAccountAttribute(account); event.oldTopic = oldTopic; fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--changer", getDisplayName(account)); addArg(args, "--old-topic", oldTopic); addArg(args, "--new-topic", event.change.topic); runHook(change.getProject(), topicChangedHook, args); }
@java.lang.Override public void doHashtagsChangedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.util.Set<java.lang.String> added, java.util.Set<java.lang.String> removed, java.util.Set<java.lang.String> hashtags, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.HashtagsChangedEvent event = new com.google.gerrit.server.events.HashtagsChangedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.editor = eventFactory.asAccountAttribute(account); event.hashtags = hashtagArray(hashtags); event.added = hashtagArray(added); event.removed = hashtagArray(removed); fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--editor", getDisplayName(account)); if (hashtags != null) { for (java.lang.String hashtag : hashtags) { addArg(args, "--hashtag", hashtag); } } if (added != null) { for (java.lang.String hashtag : added) { addArg(args, "--added", hashtag); } } if (removed != null) { for (java.lang.String hashtag : removed) { addArg(args, "--removed", hashtag); } } runHook(change.getProject(), hashtagsChangedHook, args); }
@java.lang.Override public void doChangeAbandonedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.String reason, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.events.ChangeAbandonedEvent event = new com.google.gerrit.server.events.ChangeAbandonedEvent(); com.google.gerrit.server.account.AccountState owner = accountCache.get(change.getOwner()); event.change = eventFactory.asChangeAttribute(db, change); event.abandoner = eventFactory.asAccountAttribute(account); event.patchSet = asPatchSetAttribute(change, patchSet, db); event.reason = reason; fireEvent(change, event, db); java.util.List<java.lang.String> args = new java.util.ArrayList<>(); addArg(args, "--change", event.change.id); addArg(args, "--change-url", event.change.url); addArg(args, "--change-owner", getDisplayName(owner.getAccount())); addArg(args, "--project", event.change.project); addArg(args, "--branch", event.change.branch); addArg(args, "--topic", event.change.topic); addArg(args, "--abandoner", getDisplayName(account)); addArg(args, "--commit", event.patchSet.revision); addArg(args, "--reason", (reason == null ? "" : reason)); runHook(change.getProject(), changeAbandonedHook, args); }






private void watchCanonicalManifest(com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest manifest, java.lang.String store, java.lang.String branchPath) { java.lang.String defaultBranch; com.amd.gerrit.plugins.manifestsubscription.ProjectBranchKey pbKey; if (((manifest.getDefault()) != null) && ((manifest.getDefault().getRevision()) != null)) { defaultBranch = manifest.getDefault().getRevision(); } else { defaultBranch = ""; } for (com.amd.gerrit.plugins.manifestsubscription.manifest.Project project : manifest.getProject()) { if (stores.contains(project.getName())) { continue; } java.lang.String branch = ((project.getRevision()) == null) ? defaultBranch : (project.getUpstream()) != null ? project.getUpstream() : project.getRevision(); pbKey = new com.amd.gerrit.plugins.manifestsubscription.ProjectBranchKey(project.getName(), org.eclipse.jgit.lib.Repository.shortenRefName(branch)); if (!(subscribedRepos.contains(pbKey, store))) { subscribedRepos.put(pbKey, store, com.google.common.collect.Sets.<java.lang.String>newHashSet()); } subscribedRepos.get(pbKey, store).add(branchPath); } }
private void processManifestChange(com.amd.gerrit.plugins.manifestsubscription.Event event, java.lang.String projectName, java.lang.String branchName) { com.amd.gerrit.plugins.manifestsubscription.VersionedManifests versionedManifests; try { versionedManifests = parseManifests(event); if (versionedManifests != null) { com.amd.gerrit.plugins.manifestsubscription.CanonicalManifest cManifest = new com.amd.gerrit.plugins.manifestsubscription.CanonicalManifest(versionedManifests); java.util.Map<java.lang.String, com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest> manifests = versionedManifests.getManifests(); com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest manifest; java.lang.String store = enabledManifestRepos.get(projectName).getStore(); com.google.common.collect.Table<java.lang.String, java.lang.String, java.lang.String> lookup = com.google.common.collect.HashBasedTable.create(); for (java.lang.String path : manifests.keySet()) { java.lang.String bp = (branchName + "/") + path; try { manifest = cManifest.getCanonicalManifest(path); watchCanonicalManifest(manifest, store, bp); com.amd.gerrit.plugins.manifestsubscription.VersionedManifests.affixManifest(gitRepoManager, manifest, lookup); updateManifest(store, ((com.amd.gerrit.plugins.manifestsubscription.ManifestSubscription.STORE_BRANCH_PREFIX) + bp), manifest); } catch (com.amd.gerrit.plugins.manifestsubscription.ManifestReadException e) { e.printStackTrace(); } } } } catch (javax.xml.bind.JAXBException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { e.printStackTrace(); } }


private void loadStoreFromProjectConfig(java.lang.String projectName, com.google.gerrit.server.git.ProjectConfig config) { java.lang.String newStore = config.getPluginConfig(pluginName).getString(com.amd.gerrit.plugins.manifestsubscription.ManifestSubscription.KEY_STORE); if (newStore != null) { newStore = newStore.trim(); if (!(newStore.isEmpty())) { java.util.Set<java.lang.String> branches = com.google.common.collect.Sets.newHashSet(config.getPluginConfig(pluginName).getStringList(com.amd.gerrit.plugins.manifestsubscription.ManifestSubscription.KEY_BRANCH)); if ((branches.size()) > 0) { enabledManifestRepos.put(projectName, new com.amd.gerrit.plugins.manifestsubscription.PluginProjectConfig(newStore, branches)); stores.add(newStore); } } } }

@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException, javax.servlet.ServletException { com.google.gitiles.FormatType format; try { format = com.google.gitiles.FormatType.getFormatType(req); } catch (java.lang.IllegalArgumentException err) { res.sendError(com.google.gitiles.SC_BAD_REQUEST); return; } if (format == (com.google.gitiles.FormatType.DEFAULT)) { format = getDefaultFormat(req); } switch (format) { case com.google.gitiles.FormatType.HTML : doGetHtml(req, res); break; case com.google.gitiles.FormatType.TEXT : doGetText(req, res); break; case com.google.gitiles.FormatType.JSON : doGetJson(req, res); break; default : res.sendError(com.google.gitiles.SC_BAD_REQUEST); break; } }


private void assertTag(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch, com.google.gerrit.acceptance.PushOneCommit.Tag tag) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref tagRef = repo.getRef(tag.name); assertThat(tagRef).isNotNull(); org.eclipse.jgit.lib.ObjectId taggedCommit = null; if (tag instanceof com.google.gerrit.acceptance.PushOneCommit.AnnotatedTag) { com.google.gerrit.acceptance.PushOneCommit.AnnotatedTag annotatedTag = ((com.google.gerrit.acceptance.PushOneCommit.AnnotatedTag) (tag)); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(tagRef.getObjectId()); assertThat(object).isInstanceOf(org.eclipse.jgit.revwalk.RevTag.class); org.eclipse.jgit.revwalk.RevTag tagObject = ((org.eclipse.jgit.revwalk.RevTag) (object)); assertThat(tagObject.getFullMessage()).isEqualTo(annotatedTag.message); assertThat(tagObject.getTaggerIdent()).isEqualTo(annotatedTag.tagger); taggedCommit = tagObject.getObject(); } } else { taggedCommit = tagRef.getObjectId(); } org.eclipse.jgit.lib.ObjectId headCommit = repo.getRef(branch).getObjectId(); assertThat(taggedCommit).isNotNull(); assertThat(taggedCommit).isEqualTo(headCommit); } }
private java.util.List<org.eclipse.jgit.lib.Ref> getBranchRefs(com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.project.ProjectControl projectControl) { org.eclipse.jgit.lib.Ref[] result = new org.eclipse.jgit.lib.Ref[showBranch.size()]; try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName)) { for (int i = 0; i < (showBranch.size()); i++) { org.eclipse.jgit.lib.Ref ref = git.getRef(showBranch.get(i)); if ((((ref != null) && ((ref.getObjectId()) != null)) && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible())) || ((all) && (projectControl.isOwner()))) { result[i] = ref; } } } catch (java.io.IOException ioe) { } return java.util.Arrays.asList(result); }
private com.google.gerrit.reviewdb.client.PatchSet rebase(com.google.gerrit.server.git.CodeReviewCommit n, com.google.gerrit.server.git.MergeTip mergeTip) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.change.RebaseChangeOp op = rebaseFactory.create(n.getControl(), args.db.patchSets().get(n.getPatchsetId()), mergeTip.getCurrentTip().name()).setCommitterIdent(args.serverIdent.get()).setRunHooks(false).setValidatePolicy(CommitValidators.Policy.NONE); try (com.google.gerrit.server.git.BatchUpdate bu = args.newBatchUpdate(com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(n.change().getId(), op); bu.execute(); } return op.getPatchSet(); }
public com.google.gerrit.server.data.PatchSetAttribute asPatchSetAttribute(org.eclipse.jgit.revwalk.RevWalk revWalk, com.google.gerrit.reviewdb.client.PatchSet patchSet) { return asPatchSetAttribute(revWalk, patchSet); }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); com.google.gerrit.server.project.ChangeControl ctl = ctx.getChangeControl(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getChangeUpdate(); if ((patchSet.getGroups()) == null) { patchSet.setGroups(com.google.gerrit.server.git.GroupCollector.getDefaultGroups(patchSet)); } db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); update.setTopic(change.getTopic()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals); if ((message) != null) { changeMessage = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId()); changeMessage.setMessage(message); cmUtil.addChangeMessage(db, update, changeMessage); } }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.ChangeMergedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.submitter, "submitter")); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.ChangeRestoredEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.restorer, "restorer")); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); common.add(propertyFactory.create("reason", event.reason)); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.PatchSetCreatedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); common.addAll(propertyAttributeExtractor.extractFrom(event.uploader, "uploader")); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.DraftPublishedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); common.addAll(propertyAttributeExtractor.extractFrom(event.uploader, "uploader")); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.ChangeAbandonedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.abandoner, "abandoner")); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); common.add(propertyFactory.create("reason", event.reason)); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.CommentAddedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.change)); common.addAll(propertyAttributeExtractor.extractFrom(event.patchSet)); common.addAll(propertyAttributeExtractor.extractFrom(event.author, "commenter")); if ((event.approvals) != null) { for (com.google.gerrit.server.data.ApprovalAttribute approvalAttribute : event.approvals) { common.addAll(propertyAttributeExtractor.extractFrom(approvalAttribute)); } } common.add(propertyFactory.create("comment", event.comment)); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = newPatchSetId(event.change.number, event.patchSet.number); return issueExtractor.getIssueIds(event.change.project, event.patchSet.revision, patchSetId); }
private java.util.Map<java.lang.String, java.util.Set<java.lang.String>> extractFrom(com.google.gerrit.server.events.RefUpdatedEvent event, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> common) { common.add(propertyFactory.create("event-type", event.type)); common.addAll(propertyAttributeExtractor.extractFrom(event.submitter, "submitter")); common.addAll(propertyAttributeExtractor.extractFrom(event.refUpdate)); return issueExtractor.getIssueIds(event.refUpdate.project, event.refUpdate.newRev); }
@com.google.gwtexpui.clippy.client.Source("clipboard-16.png") com.google.gwt.resources.client.ImageResource clipboard();
@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.IntegrationException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) { toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE); mergeTip.moveTipTo(toMerge, toMerge); acceptMergeTip(mergeTip); return; } rebaseOp = rebaseFactory.create(toMerge.getControl(), args.db.patchSets().get(toMerge.getPatchsetId()), mergeTip.getCurrentTip().name()).setCommitterIdent(args.serverIdent.get()).setRunHooks(false).setValidatePolicy(CommitValidators.Policy.NONE); try { rebaseOp.updateRepo(ctx); } catch (com.google.gerrit.extensions.restapi.MergeConflictException e) { toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT); throw new com.google.gerrit.server.git.IntegrationException(((("Cannot rebase " + (toMerge.name())) + ": ") + (e.getMessage())), e); } }
@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) { mergeTip.moveTipTo(toMerge, toMerge); acceptMergeTip(mergeTip); } else { org.eclipse.jgit.lib.PersonIdent myIdent = args.serverIdent.get(); com.google.gerrit.server.git.CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), toMerge); mergeTip.moveTipTo(newTip, toMerge); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); acceptMergeTip(mergeTip); }
private java.lang.String getCanonicalProject(java.lang.String project) { java.lang.String canonicalProject = java.lang.String.format("https://%s/%s", serverName, project); try { java.net.URL url = new java.net.URL(canonicalProject); canonicalProject = (url.getHost()) + (url.getPath()); } catch (java.net.MalformedURLException e) { com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandlerImpl.log.warn(("Could not parse project as URL: " + canonicalProject)); } return canonicalProject; }
@java.lang.Override public void run() { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> branches = null; com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(project); try { com.google.gerrit.server.project.ProjectResource project = new com.google.gerrit.server.project.ProjectResource(projectControl.controlFor(nameKey, user)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project.getNameKey())) { branches = repo.getRefDatabase().getRefs(Constants.R_HEADS); } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.googlesource.gerrit.plugins.repositoryuse.ScanTaskImpl.log.error(e.getMessage(), e); } if ((branch) == null) { for (java.lang.String currentBranch : branches.keySet()) { com.googlesource.gerrit.plugins.repositoryuse.RefUpdate rescan = new com.googlesource.gerrit.plugins.repositoryuse.RefUpdate(project, branches.get(currentBranch).getName(), org.eclipse.jgit.lib.ObjectId.zeroId().getName(), branches.get(currentBranch).getObjectId().name()); try { refUpdateHandlerFactory.create(rescan).run(); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.repositoryuse.ScanTaskImpl.log.error(java.lang.String.format("Error updating %s branch %s: %s", project, branch, e.getMessage()), e); } } } else { if (branch.startsWith(Constants.R_HEADS)) { branch = branch.substring(Constants.R_HEADS.length()); } if (branches.containsKey(branch)) { com.googlesource.gerrit.plugins.repositoryuse.RefUpdate rescan = new com.googlesource.gerrit.plugins.repositoryuse.RefUpdate(project, branches.get(branch).getName(), org.eclipse.jgit.lib.ObjectId.zeroId().getName(), branches.get(branch).getObjectId().name()); try { refUpdateHandlerFactory.create(rescan).run(); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.repositoryuse.ScanTaskImpl.log.error(java.lang.String.format("Error updating %s branch %s: %s", project, branch, e.getMessage()), e); } } else { com.googlesource.gerrit.plugins.repositoryuse.ScanTaskImpl.log.warn(java.lang.String.format("Branch %s does not exist; skipping", branch)); } } }




@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class).to(com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandler.class); requestStaticInjection(com.googlesource.gerrit.plugins.repositoryuse.Config.class); requestStaticInjection(Ref.Table.class); requestStaticInjection(Usage.Table.class); }


@java.lang.Override public java.util.List<com.google.gerrit.server.account.GetEmails.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if ((((self.get()) != (rsrc.getUser())) && ((self.get().getUserName()) != (rsrc.getUser().getUserName()))) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to list email addresses"); } java.util.List<com.google.gerrit.server.account.GetEmails.EmailInfo> emails = com.google.common.collect.Lists.newArrayList(); for (java.lang.String email : rsrc.getUser().getEmailAddresses()) { if (email != null) { com.google.gerrit.server.account.GetEmails.EmailInfo e = new com.google.gerrit.server.account.GetEmails.EmailInfo(); e.email = email; e.preferred(rsrc.getUser().getAccount().getPreferredEmail()); emails.add(e); } } java.util.Collections.sort(emails, new java.util.Comparator<com.google.gerrit.server.account.GetEmails.EmailInfo>() { @java.lang.Override public int compare(com.google.gerrit.server.account.GetEmails.EmailInfo a, com.google.gerrit.server.account.GetEmails.EmailInfo b) { return a.email.compareTo(b.email); } }); return emails; }
private org.eclipse.jgit.lib.BatchRefUpdate getBatchRefUpdate() throws java.io.IOException { initRepository(); if ((batchRefUpdate) == null) { batchRefUpdate = repo.getRefDatabase().newBatchUpdate(); } return batchRefUpdate; }
private void executeRefUpdates() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, java.io.IOException { try { com.google.gerrit.server.git.BatchUpdate.RepoContext ctx = new com.google.gerrit.server.git.BatchUpdate.RepoContext(); for (com.google.gerrit.server.git.BatchUpdate.Op op : ops.values()) { op.updateRepo(ctx); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.git.UpdateException(e); } if ((((repo) == null) || ((batchRefUpdate) == null)) || (batchRefUpdate.getCommands().isEmpty())) { return; } inserter.flush(); batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE); boolean ok = true; for (org.eclipse.jgit.transport.ReceiveCommand cmd : batchRefUpdate.getCommands()) { if ((cmd.getResult()) != (ReceiveCommand.Result.OK)) { ok = false; break; } } if (!ok) { throw new com.google.gerrit.server.git.UpdateException(("BatchRefUpdate failed: " + (batchRefUpdate))); } }
private void executeRefUpdates() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, java.io.IOException { try { com.google.gerrit.server.git.BatchUpdate.RepoContext ctx = new com.google.gerrit.server.git.BatchUpdate.RepoContext(); for (com.google.gerrit.server.git.BatchUpdate.Op op : ops.values()) { op.updateRepo(ctx); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.git.UpdateException(e); } if (commands.isEmpty()) { return; } initRepository(); inserter.flush(); batchRefUpdate = repo.getRefDatabase().newBatchUpdate(); commands.addTo(batchRefUpdate); batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE); boolean ok = true; for (org.eclipse.jgit.transport.ReceiveCommand cmd : batchRefUpdate.getCommands()) { if ((cmd.getResult()) != (ReceiveCommand.Result.OK)) { ok = false; break; } } if (!ok) { throw new com.google.gerrit.server.git.UpdateException(("BatchRefUpdate failed: " + (batchRefUpdate))); } }


private void reindexChanges() throws java.io.IOException { com.google.gerrit.server.index.ChangeIndexer.allAsList(indexFutures).checkedGet(); }
private com.google.gerrit.server.git.MergeOp.OpenRepo openRepo(com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.git.MergeOp.OpenRepo repo = openRepos.get(project); if (repo == null) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(project); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } try { repo = new com.google.gerrit.server.git.MergeOp.OpenRepo(repoManager.openRepository(project), projectState); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } openRepos.put(project, repo); } return repo; }
private void setApproval(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.sql.Timestamp timestamp = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.project.ChangeControl control = cd.changeControl(); com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.currentPatchSet().getId(); com.google.gerrit.reviewdb.client.PatchSet.Id psIdNewRev = commits.get(cd.change().getId()).change().currentPatchSetId(); logDebug(((("Add approval for " + cd) + " from user ") + user)); com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(control, timestamp); update.putReviewer(user.getAccountId(), com.google.gerrit.server.git.REVIEWER); com.google.common.base.Optional<com.google.gerrit.common.data.SubmitRecord> okRecord = com.google.gerrit.server.git.MergeOp.findOkRecord(cd.getSubmitRecords()); if (okRecord.isPresent()) { update.merge(com.google.common.collect.ImmutableList.of(okRecord.get())); } db.changes().beginTransaction(cd.change().getId()); try { com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch = approve(control, psId, user, update, timestamp); batch.write(update, new org.eclipse.jgit.lib.CommitBuilder()); if (!(psIdNewRev.equals(psId))) { update.setPatchSetId(psId); update.commit(); update = updateFactory.create(control, timestamp); batch = approve(control, psIdNewRev, user, update, timestamp); batch.write(update, new org.eclipse.jgit.lib.CommitBuilder()); } db.commit(); } finally { db.rollback(); } update.commit(); indexer.index(db, cd.change()); }

@java.lang.Override public com.google.gerrit.server.git.MergeTip run(com.google.gerrit.server.git.CodeReviewCommit branchTip, java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); com.google.gerrit.server.git.MergeTip mergeTip = new com.google.gerrit.server.git.MergeTip(branchTip, toMerge); try (com.google.gerrit.server.git.BatchUpdate u = args.newBatchUpdate(com.google.gerrit.common.TimeUtil.nowTs())) { if (branchTip == null) { com.google.gerrit.server.git.CodeReviewCommit first = sorted.remove(0); u.addOp(first.change().getId(), new com.google.gerrit.server.git.strategy.FastForwardOp(mergeTip, first)); } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); u.addOp(n.change().getId(), new com.google.gerrit.server.git.strategy.MergeOneOp(args, mergeTip, n)); } u.addOp(com.google.gerrit.server.git.strategy.MarkCleanMergesOp.anyChangeId(toMerge), new com.google.gerrit.server.git.strategy.MarkCleanMergesOp(args, mergeTip)); u.execute(); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.git.UpdateException e) { if ((e.getCause()) instanceof com.google.gerrit.server.git.IntegrationException) { throw new com.google.gerrit.server.git.IntegrationException(e.getCause().getMessage(), e); } throw new com.google.gerrit.server.git.IntegrationException(("Cannot merge into " + (args.destBranch))); } return mergeTip; }
private void updateHead(org.eclipse.jgit.transport.URIish replicateURI, java.lang.String newHead) { if (!(replicateURI.isRemote())) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.updateHeadLocally(replicateURI, newHead); } else if (com.googlesource.gerrit.plugins.replication.ReplicationQueue.isSSH(replicateURI)) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.updateHeadRemoteSsh(replicateURI, newHead); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(java.lang.String.format(("Cannot update HEAD of project on remote site %s." + (" Only local paths and SSH URLs are supported" + " for remote HEAD update.")), replicateURI)); } }

@java.lang.Override protected void display(com.googlesource.gerrit.plugins.imagare.client.ConfigInfo info) { com.google.gwt.user.client.ui.HorizontalPanel p = new com.google.gwt.user.client.ui.HorizontalPanel(); p.setStyleName("imagare-menu-panel"); com.google.gwt.user.client.ui.Anchor prefsAnchor = new com.google.gwt.user.client.ui.Anchor(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(ImagarePlugin.RESOURCES.image()), (("#/x/" + (com.google.gerrit.plugin.client.Plugin.get().getPluginName())) + "/upload")); prefsAnchor.setTitle("Upload Image"); p.add(prefsAnchor); add(p); super.display(info); }

@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { doSave(); }
@java.lang.Override public void onPluginLoad() { com.google.gerrit.plugin.client.Plugin.get().screen("upload", new com.googlesource.gerrit.plugins.imagare.client.ImageUploadScreen.Factory()); com.google.gerrit.plugin.client.Plugin.get().screen("settings", new com.googlesource.gerrit.plugins.imagare.client.ImagareAdminScreen.Factory()); com.google.gerrit.plugin.client.Plugin.get().settingsScreen("preferences", ((com.google.gerrit.plugin.client.Plugin.get().getName()) + " Preferences"), new com.googlesource.gerrit.plugins.imagare.client.ImagarePreferenceScreen.Factory()); }
private void doSave() { com.googlesource.gerrit.plugins.imagare.client.ConfigInfo in = com.googlesource.gerrit.plugins.imagare.client.ConfigInfo.create(); in.setDefaultProject(projectBox.getValue()); in.setLinkDecoration(linkDecorationBox.getValue(linkDecorationBox.getSelectedIndex())); in.setStage(stageBox.getValue()); restApi.put(in, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { saveButton.setEnabled(false); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
private void initCompression(boolean enableCompression) { java.util.List<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Compression>> compressionFactories = com.google.common.collect.Lists.newArrayList(); compressionFactories.add(new org.apache.sshd.common.compression.CompressionNone.Factory()); if (enableCompression) { compressionFactories.add(new org.apache.sshd.common.compression.CompressionZlib.Factory()); } setCompressionFactories(compressionFactories); }
private void initChannels() { setChannelFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Channel>>asList(new org.apache.sshd.server.channel.ChannelSession.Factory(), new org.apache.sshd.common.forward.TcpipServerChannel.DirectTcpipFactory())); }
private void initUserAuth(final org.apache.sshd.server.PublickeyAuthenticator pubkey, final org.apache.sshd.server.auth.gss.GSSAuthenticator kerberosAuthenticator, java.lang.String kerberosKeytab, java.lang.String kerberosPrincipal) { java.util.List<org.apache.sshd.common.NamedFactory<org.apache.sshd.server.UserAuth>> authFactories = com.google.common.collect.Lists.newArrayList(); if (kerberosKeytab != null) { authFactories.add(new org.apache.sshd.server.auth.gss.UserAuthGSS.Factory()); com.google.gerrit.sshd.SshDaemon.log.info(("Enabling kerberos with keytab " + kerberosKeytab)); if (!(new java.io.File(kerberosKeytab).canRead())) { com.google.gerrit.sshd.SshDaemon.log.error((("Keytab " + kerberosKeytab) + " does not exist or is not readable; further errors are possible")); } kerberosAuthenticator.setKeytabFile(kerberosKeytab); if (kerberosPrincipal == null) { try { kerberosPrincipal = "host/" + (java.net.InetAddress.getLocalHost().getCanonicalHostName()); } catch (java.net.UnknownHostException e) { kerberosPrincipal = "host/localhost"; } } com.google.gerrit.sshd.SshDaemon.log.info(("Using kerberos principal " + kerberosPrincipal)); if (!(kerberosPrincipal.startsWith("host/"))) { com.google.gerrit.sshd.SshDaemon.log.warn(("Host principal does not start with host/ " + "which most SSH clients will supply automatically")); } kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal); setGSSAuthenticator(kerberosAuthenticator); } authFactories.add(new org.apache.sshd.server.auth.UserAuthPublicKey.Factory()); setUserAuthFactories(authFactories); setPublickeyAuthenticator(pubkey); }
private java.util.List<com.jcraft.jsch.HostKey> computeHostKeys() { if (listen.isEmpty()) { return java.util.Collections.emptyList(); } final java.util.List<java.security.PublicKey> keys = myHostKeys(); final java.util.List<com.jcraft.jsch.HostKey> r = new java.util.ArrayList<>(); for (final java.security.PublicKey pub : keys) { final org.apache.sshd.common.util.Buffer buf = new org.apache.sshd.common.util.Buffer(); buf.putRawPublicKey(pub); final byte[] keyBin = buf.getCompactData(); for (final java.lang.String addr : advertised) { try { r.add(new com.jcraft.jsch.HostKey(addr, keyBin)); } catch (com.jcraft.jsch.JSchException e) { com.google.gerrit.sshd.SshDaemon.log.warn("Cannot format SSHD host key", e); } } } return java.util.Collections.unmodifiableList(r); }
private void initProviderBouncyCastle(org.eclipse.jgit.lib.Config cfg) { setKeyExchangeFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.KeyExchange>>asList(new org.apache.sshd.server.kex.DHG14.Factory(), new org.apache.sshd.server.kex.DHG1.Factory())); org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Random> factory; if (cfg.getBoolean("sshd", null, "testUseInsecureRandom", false)) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory(); } else { factory = new org.apache.sshd.common.random.BouncyCastleRandom.Factory(); } setRandomFactory(new org.apache.sshd.common.random.SingletonRandomFactory(factory)); }
private void initProviderJce() { setKeyExchangeFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.KeyExchange>>asList(new org.apache.sshd.server.kex.DHG1.Factory())); setRandomFactory(new org.apache.sshd.common.random.SingletonRandomFactory(new org.apache.sshd.common.random.JceRandom.Factory())); }
@java.lang.Override public org.apache.sshd.common.KeyPairProvider get() { java.nio.file.Path objKey = site.ssh_key; java.nio.file.Path rsaKey = site.ssh_rsa; java.nio.file.Path dsaKey = site.ssh_dsa; final java.util.List<java.lang.String> stdKeys = new java.util.ArrayList<>(2); if (java.nio.file.Files.exists(rsaKey)) { stdKeys.add(rsaKey.toAbsolutePath().toString()); } if (java.nio.file.Files.exists(dsaKey)) { stdKeys.add(dsaKey.toAbsolutePath().toString()); } if (java.nio.file.Files.exists(objKey)) { if (stdKeys.isEmpty()) { org.apache.sshd.server.keyprovider.SimpleGeneratorHostKeyProvider p = new org.apache.sshd.server.keyprovider.SimpleGeneratorHostKeyProvider(); p.setPath(objKey.toAbsolutePath().toString()); return p; } else { stdKeys.add(objKey.toAbsolutePath().toString()); throw new com.google.inject.ProvisionException(("Multiple host keys exist: " + stdKeys)); } } else { if (stdKeys.isEmpty()) { throw new com.google.inject.ProvisionException(("No SSH keys under " + (site.etc_dir))); } if (!(org.apache.sshd.common.util.SecurityUtils.isBouncyCastleRegistered())) { throw new com.google.inject.ProvisionException(((("Bouncy Castle Crypto not installed;" + " needed to read server host keys: ") + stdKeys) + "")); } return new org.apache.sshd.common.keyprovider.FileKeyPairProvider(stdKeys.toArray(new java.lang.String[stdKeys.size()])); } }
public static java.lang.String toOpenSshPublicKey(final java.lang.String keyStr) { try { final java.lang.StringBuilder strBuf = new java.lang.StringBuilder(); final java.io.BufferedReader br = new java.io.BufferedReader(new java.io.StringReader(keyStr)); java.lang.String line = br.readLine(); if ((line == null) || (!(line.equals("---- BEGIN SSH2 PUBLIC KEY ----")))) { return keyStr; } while ((line = br.readLine()) != null) { if ((line.indexOf(':')) == (-1)) { strBuf.append(line); break; } } while ((line = br.readLine()) != null) { if (line.startsWith("---- ")) { break; } strBuf.append(line); } final java.security.PublicKey key = new org.apache.sshd.common.util.Buffer(org.apache.commons.codec.binary.Base64.decodeBase64(org.eclipse.jgit.lib.Constants.encodeASCII(strBuf.toString()))).getRawPublicKey(); if (key instanceof java.security.interfaces.RSAPublicKey) { strBuf.insert(0, ((org.apache.sshd.common.KeyPairProvider.SSH_RSA) + " ")); } else if (key instanceof java.security.interfaces.DSAPublicKey) { strBuf.insert(0, ((org.apache.sshd.common.KeyPairProvider.SSH_DSS) + " ")); } else { return keyStr; } strBuf.append(' '); strBuf.append("converted-key"); return strBuf.toString(); } catch (java.io.IOException e) { return keyStr; } catch (java.lang.RuntimeException re) { return keyStr; } }
public static java.security.PublicKey parse(final com.google.gerrit.reviewdb.client.AccountSshKey key) throws java.security.NoSuchAlgorithmException, java.security.NoSuchProviderException, java.security.spec.InvalidKeySpecException { try { final java.lang.String s = key.getEncodedKey(); if (s == null) { throw new java.security.spec.InvalidKeySpecException("No key string"); } final byte[] bin = org.apache.commons.codec.binary.Base64.decodeBase64(org.eclipse.jgit.lib.Constants.encodeASCII(s)); return new org.apache.sshd.common.util.Buffer(bin).getRawPublicKey(); } catch (java.lang.RuntimeException | org.apache.sshd.common.SshException e) { throw new java.security.spec.InvalidKeySpecException("Cannot parse key", e); } }
private static java.util.Set<java.security.PublicKey> read(java.nio.file.Path path) { try (java.io.BufferedReader br = java.nio.file.Files.newBufferedReader(path, java.nio.charset.StandardCharsets.UTF_8)) { final java.util.Set<java.security.PublicKey> keys = new java.util.HashSet<>(); java.lang.String line; while ((line = br.readLine()) != null) { line = line.trim(); if ((line.startsWith("#")) || (line.isEmpty())) { continue; } try { byte[] bin = org.apache.commons.codec.binary.Base64.decodeBase64(line.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1)); keys.add(new org.apache.sshd.common.util.Buffer(bin).getRawPublicKey()); } catch (java.lang.RuntimeException | org.apache.sshd.common.SshException e) { com.google.gerrit.sshd.DatabasePubKeyAuth.PeerKeyCache.logBadKey(path, line, e); } } return java.util.Collections.unmodifiableSet(keys); } catch (java.nio.file.NoSuchFileException noFile) { return java.util.Collections.emptySet(); } catch (java.io.IOException err) { com.google.gerrit.sshd.DatabasePubKeyAuth.log.error(("Cannot read " + path), err); return java.util.Collections.emptySet(); } }
private void initSignatures() { setSignatureFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Signature>>asList(new org.apache.sshd.common.signature.SignatureDSA.Factory(), new org.apache.sshd.common.signature.SignatureRSA.Factory(), new org.apache.sshd.common.signature.SignatureECDSA.NISTP256Factory(), new org.apache.sshd.common.signature.SignatureECDSA.NISTP384Factory(), new org.apache.sshd.common.signature.SignatureECDSA.NISTP521Factory())); }
private Change.Id createNewChange(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, org.eclipse.jgit.lib.ObjectInserter oi, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.git.CodeReviewCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.IdentifiedUser identifiedUser, java.lang.String topic, com.google.gerrit.reviewdb.client.Branch.NameKey sourceBranch) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id(seq.nextChangeId()); com.google.gerrit.server.change.ChangeInserter ins = changeInserterFactory.create(refControl, changeId, cherryPickCommit).setValidatePolicy(CommitValidators.Policy.GERRIT).setTopic(topic); ins.setMessage(messageForDestinationChange(ins.getPatchSet().getId(), sourceBranch)); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), project, identifiedUser, com.google.gerrit.common.TimeUtil.nowTs())) { bu.setRepository(git, revWalk, oi); bu.insertChange(ins); bu.execute(); } return changeId; }
@java.lang.Override public com.google.gerrit.reviewdb.client.Change createChange(com.google.gerrit.server.git.BatchUpdate.Context ctx) { change = new com.google.gerrit.reviewdb.client.Change(com.google.gerrit.server.change.ChangeInserter.getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(refControl.getProjectControl().getProject().getNameKey(), refControl.getRefName()), ctx.getWhen()); change.setStatus(((status) != null ? status : Change.Status.NEW)); change.setTopic(topic); patchSet.setCreatedOn(ctx.getWhen()); patchSet.setUploader(ctx.getUser().getAccountId()); return change; }


public abstract com.google.gerrit.reviewdb.client.Change getChange();
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { change = ctx.getChange(); com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); com.google.gerrit.server.project.ChangeControl ctl = ctx.getControl(); patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId()); ctx.getChange().setCurrentPatchSet(patchSetInfo); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(patchSet.getId()); if ((patchSet.getGroups()) == null) { patchSet.setGroups(com.google.gerrit.server.git.GroupCollector.getDefaultGroups(patchSet)); } db.patchSets().insert(java.util.Collections.singleton(patchSet)); db.changes().insert(java.util.Collections.singleton(change)); update.setTopic(change.getTopic()); update.fixStatus(change.getStatus()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals); if ((message) != null) { changeMessage = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId()); changeMessage.setMessage(message); cmUtil.addChangeMessage(db, update, changeMessage); } }

private com.google.gerrit.reviewdb.client.Change createNewChange(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, org.eclipse.jgit.lib.ObjectInserter oi, com.google.gerrit.reviewdb.client.Change.Key changeKey, com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.Ref destRef, com.google.gerrit.server.git.CodeReviewCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.IdentifiedUser identifiedUser, java.lang.String topic, com.google.gerrit.reviewdb.client.Branch.NameKey sourceBranch) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = new com.google.gerrit.reviewdb.client.Change(changeKey, new com.google.gerrit.reviewdb.client.Change.Id(seq.nextChangeId()), identifiedUser.getAccountId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(project, destRef.getName()), com.google.gerrit.common.TimeUtil.nowTs()); change.setTopic(topic); com.google.gerrit.server.change.ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit).setValidatePolicy(CommitValidators.Policy.GERRIT); ins.setMessage(messageForDestinationChange(ins.getPatchSet().getId(), sourceBranch)); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), identifiedUser, com.google.gerrit.common.TimeUtil.nowTs())) { bu.setRepository(git, revWalk, oi); bu.insertChange(ins); bu.execute(); } return ins.getChange(); }
@org.junit.Test public void byStatusOpen() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.NEW); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.DRAFT); insert(ins2); com.google.gerrit.server.change.ChangeInserter ins3 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change3 = ins3.getChange(); change3.setStatus(Change.Status.MERGED); insert(ins3); com.google.gerrit.reviewdb.client.Change[] expected = new com.google.gerrit.reviewdb.client.Change[]{ change2, change1 }; assertQuery("status:open", expected); assertQuery("status:OPEN", expected); assertQuery("status:o", expected); assertQuery("status:op", expected); assertQuery("status:ope", expected); assertQuery("status:pending", expected); assertQuery("status:PENDING", expected); assertQuery("status:p", expected); assertQuery("status:pe", expected); assertQuery("status:pen", expected); assertQuery("is:open", expected); }
@org.junit.Test public void implicitVisibleTo() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, userId.get(), null)); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, userId.get(), null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.DRAFT); insert(ins2); java.lang.String q = "project:repo"; assertQuery(q, change2, change1); requestContext.setContext(newRequestContext(accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("anotheruser")).getAccountId())); assertQuery(q, change1); }
@org.junit.Test public void byTopic() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setTopic("feature1"); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setTopic("feature2"); insert(ins2); com.google.gerrit.server.change.ChangeInserter ins3 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change3 = ins3.getChange(); change3.setTopic("Cherrypick-feature2"); insert(ins3); com.google.gerrit.server.change.ChangeInserter ins4 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change4 = ins4.getChange(); change4.setTopic("feature2-fixup"); insert(ins4); com.google.gerrit.reviewdb.client.Change change5 = insert(newChange(repo, null, null, null, null)); assertQuery("intopic:foo"); assertQuery("intopic:feature1", change1); assertQuery("intopic:feature2", change4, change3, change2); assertQuery("topic:feature2", change2); assertQuery("intopic:feature2", change4, change3, change2); assertQuery("intopic:fixup", change4); assertQuery("topic:\"\"", change5); assertQuery("intopic:\"\"", change5); }
@org.junit.Test public void byStatus() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.NEW); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.MERGED); insert(ins2); assertQuery("status:new", change1); assertQuery("status:NEW", change1); assertQuery("is:new", change1); assertQuery("status:merged", change2); assertQuery("is:merged", change2); }
@org.junit.Test public void explicitVisibleTo() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(newChange(repo, null, null, userId.get(), null)); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, userId.get(), null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.DRAFT); insert(ins2); java.lang.String q = "project:repo"; assertQuery(q, change2, change1); com.google.gerrit.reviewdb.client.Account.Id user2 = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("anotheruser")).getAccountId(); assertQuery(((q + " visibleto:") + (user2.get())), change1); }
@org.junit.Test public void byStatusClosed() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.MERGED); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.ABANDONED); insert(ins2); com.google.gerrit.server.change.ChangeInserter ins3 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change3 = ins3.getChange(); change3.setStatus(Change.Status.NEW); insert(ins3); com.google.gerrit.reviewdb.client.Change[] expected = new com.google.gerrit.reviewdb.client.Change[]{ change2, change1 }; assertQuery("status:closed", expected); assertQuery("status:CLOSED", expected); assertQuery("status:c", expected); assertQuery("status:cl", expected); assertQuery("status:clo", expected); assertQuery("status:clos", expected); assertQuery("status:close", expected); assertQuery("status:closed", expected); assertQuery("is:closed", expected); }
@org.junit.Test public void byStatusPrefix() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.NEW); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.MERGED); insert(ins2); assertQuery("status:n", change1); assertQuery("status:ne", change1); assertQuery("status:new", change1); assertQuery("status:N", change1); assertQuery("status:nE", change1); assertQuery("status:neW", change1); assertBadQuery("status:nx"); assertBadQuery("status:newx"); }

@org.junit.Test public void byStatusDraft() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change1 = ins1.getChange(); change1.setStatus(Change.Status.NEW); insert(ins1); com.google.gerrit.server.change.ChangeInserter ins2 = newChange(repo, null, null, null, null); com.google.gerrit.reviewdb.client.Change change2 = ins2.getChange(); change2.setStatus(Change.Status.DRAFT); insert(ins2); com.google.gerrit.reviewdb.client.Change[] expected = new com.google.gerrit.reviewdb.client.Change[]{ change2 }; assertQuery("status:draft", expected); assertQuery("status:DRAFT", expected); assertQuery("status:d", expected); assertQuery("status:dr", expected); assertQuery("status:dra", expected); assertQuery("status:draf", expected); assertQuery("is:draft", expected); }
public com.google.gerrit.server.git.BatchUpdate insertChange(com.google.gerrit.server.git.BatchUpdate.InsertChangeOp op) { com.google.gerrit.reviewdb.client.Change c = op.getChange(); checkArgument((!(newChanges.containsKey(c.getId()))), "only one op allowed to create change %s", c.getId()); newChanges.put(c.getId(), c); ops.get(c.getId()).add(0, op); return this; }
@java.lang.Override public com.google.gerrit.reviewdb.client.Change createChange(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.io.IOException { change = new com.google.gerrit.reviewdb.client.Change(com.google.gerrit.server.change.ChangeInserter.getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getWhen()); change.setStatus(com.google.common.base.MoreObjects.firstNonNull(status, Change.Status.NEW)); change.setTopic(topic); patchSet.setCreatedOn(ctx.getWhen()); patchSet.setUploader(ctx.getUser().getAccountId()); return change; }
private void parse(org.eclipse.jgit.revwalk.RevCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { if ((status) == null) { status = parseStatus(commit); } com.google.gerrit.reviewdb.client.PatchSet.Id psId = parsePatchSetId(commit); com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent(commit); parseChangeMessage(psId, accountId, commit); if ((topic) == null) { topic = parseTopic(commit); } parseHashtags(commit); if (submitRecords.isEmpty()) { parseSubmitRecords(commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_SUBMITTED_WITH)); } for (java.lang.String line : commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_LABEL)) { parseApproval(psId, accountId, commit, line); } for (com.google.gerrit.server.notedb.ReviewerStateInternal state : com.google.gerrit.server.notedb.ReviewerStateInternal.values()) { for (java.lang.String line : commit.getFooterLines(state.getFooterKey())) { parseReviewer(state, line); } } }


public java.lang.String getMessage(com.google.gerrit.reviewdb.client.Change change) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { com.google.gerrit.reviewdb.client.Change.Id changeId = change.getId(); com.google.gerrit.reviewdb.client.PatchSet ps = db.get().patchSets().get(change.currentPatchSetId()); if (ps == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(change.getProject());org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(git)) { org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())); return commit.getFullMessage(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { if ((newCommit) == null) { return; } com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(psId); ps.setCreatedOn(ctx.getWhen()); ps.setUploader(args.caller.getAccountId()); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(newCommit.getId().getName())); com.google.gerrit.reviewdb.client.Change c = toMerge.change(); ps.setGroups(com.google.gerrit.server.git.GroupCollector.getCurrentGroups(args.db, c)); args.db.patchSets().insert(java.util.Collections.singleton(ps)); c.setCurrentPatchSet(patchSetInfo); ctx.saveChange(); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) { approvals.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(ps.getId(), a)); ctx.getUpdate(psId).putApproval(a.getLabel(), a.getValue()); } args.db.patchSetApprovals().insert(approvals); newCommit.copyFrom(toMerge); newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK); newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller)); mergeTip.moveTipTo(newCommit, newCommit); args.commits.put(newCommit); }
@java.lang.Override public com.google.gerrit.server.change.RevisionResource parse(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (id.equals("current")) { com.google.gerrit.reviewdb.client.PatchSet.Id p = change.getChange().currentPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet ps = (p != null) ? dbProvider.get().patchSets().get(p) : null; if ((ps != null) && (visible(change, ps))) { return new com.google.gerrit.server.change.RevisionResource(change, ps).doNotCache(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } java.util.List<com.google.gerrit.server.change.RevisionResource> match = com.google.common.collect.Lists.newArrayListWithExpectedSize(2); for (com.google.gerrit.server.change.RevisionResource rsrc : find(change, id.get())) { if (visible(change, rsrc.getPatchSet())) { match.add(rsrc); } } switch (match.size()) { case 0 : throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); case 1 : return match.get(0); default : throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(((("Multiple patch sets for \"" + (id.get())) + "\": ") + (com.google.common.base.Joiner.on("; ").join(match)))); } }
private Change.Id insertPatchSet(org.eclipse.jgit.lib.Repository git, org.eclipse.jgit.revwalk.RevWalk revWalk, org.eclipse.jgit.lib.ObjectInserter oi, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.git.CodeReviewCommit cherryPickCommit, com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.IdentifiedUser identifiedUser) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = com.google.gerrit.server.ChangeUtil.nextPatchSetId(git, change.currentPatchSetId()); com.google.gerrit.server.change.PatchSetInserter inserter = patchSetInserterFactory.create(refControl, psId, cherryPickCommit); com.google.gerrit.reviewdb.client.PatchSet.Id newPatchSetId = inserter.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet current = db.get().patchSets().get(change.currentPatchSetId()); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, com.google.gerrit.common.TimeUtil.nowTs())) { bu.setRepository(git, revWalk, oi); bu.addOp(change.getId(), inserter.setMessage((("Uploaded patch set " + (newPatchSetId.get())) + ".")).setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).setSendMail(false)); bu.execute(); } return change.getId(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.RebaseChangeEdit.Rebase.Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (!(edit.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("no edit exists for change %s", rsrc.getChange().getChangeId())); } com.google.gerrit.reviewdb.client.PatchSet current = db.get().patchSets().get(rsrc.getChange().currentPatchSetId()); if (current.getId().equals(edit.get().getBasePatchSet().getId())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("edit for change %s is already on latest patch set: %s", rsrc.getChange().getChangeId(), current.getId())); } editModifier.rebaseEdit(edit.get(), current); return com.google.gerrit.extensions.restapi.Response.none(); }

@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (!(edit.isPresent())) { editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId())); edit = editUtil.byChange(rsrc.getChange()); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.message))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("commit message must be provided"); } try { editModifier.modifyMessage(edit.get(), input.message); } catch (com.google.gerrit.server.edit.UnchangedCommitMessageException ucm) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(ucm.getMessage()); } return com.google.gerrit.extensions.restapi.Response.none(); }
private com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> createEdit(com.google.gerrit.reviewdb.client.Change change) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId())); return editUtil.byChange(change); }
private com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> createEdit() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { editModifier.createEdit(change, db.get().patchSets().get(change.currentPatchSetId())); return editUtil.byChange(change); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeEdits.DeleteFile.Input in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.base.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (edit.isPresent()) { editUtil.delete(edit.get()); } else { editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId())); edit = editUtil.byChange(rsrc.getChange()); editModifier.deleteFile(edit.get(), path); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { user = ctx.getUser().asIdentifiedUser(); change = ctx.getChange(); if (change.getLastUpdatedOn().before(ctx.getWhen())) { change.setLastUpdatedOn(ctx.getWhen()); } ps = ctx.getDb().patchSets().get(psId); boolean dirty = false; dirty |= insertComments(ctx); dirty |= updateLabels(ctx); dirty |= insertMessage(ctx); if (dirty) { ctx.saveChange(); } }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { this.caller = caller; updateSubmissionId(change); this.db = db; logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); com.google.gerrit.server.git.MergeOp.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); failFast(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Merge Conflict", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Merge Conflict", e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { patchSetInserter.updateChange(ctx); rebasedPatchSet = patchSetInserter.getPatchSet(); }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { if ((newCommit) == null) { return; } com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(psId); ps.setCreatedOn(ctx.getWhen()); ps.setUploader(args.caller.getAccountId()); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(newCommit.getId().getName())); com.google.gerrit.reviewdb.client.Change c = toMerge.change(); ps.setGroups(com.google.gerrit.server.git.GroupCollector.getCurrentGroups(args.db, c)); args.db.patchSets().insert(java.util.Collections.singleton(ps)); c.setCurrentPatchSet(patchSetInfo); ctx.saveChange(); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) { approvals.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(ps.getId(), a)); ctx.getUpdate(psId).putApproval(a.getLabel(), a.getValue()); } args.db.patchSetApprovals().insert(approvals); newCommit.copyFrom(toMerge); newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK); newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller)); mergeTip.moveTipTo(newCommit, newCommit); args.commits.put(newCommit); }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((rebaseOp) == null) { return; } rebaseOp.updateChange(ctx); com.google.gerrit.reviewdb.client.PatchSet newPatchSet = rebaseOp.getPatchSet(); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) { approvals.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(newPatchSet.getId(), a)); } args.db.patchSetApprovals().insert(approvals); com.google.gerrit.server.git.CodeReviewCommit newTip = args.rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(newPatchSet.getRevision().get())); mergeTip.moveTipTo(newTip, newTip); toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId())); mergeTip.getCurrentTip().copyFrom(toMerge); mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller)); mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId()); mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE); args.commits.put(mergeTip.getCurrentTip()); acceptMergeTip(mergeTip); }
@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.IntegrationException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) { toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE); mergeTip.moveTipTo(toMerge, toMerge); acceptMergeTip(mergeTip); return; } rebaseOp = args.rebaseFactory.create(toMerge.getControl(), args.db.patchSets().get(toMerge.getPatchsetId()), mergeTip.getCurrentTip().name()).setCommitterIdent(args.serverIdent).setRunHooks(false).setValidatePolicy(CommitValidators.Policy.NONE); try { rebaseOp.updateRepo(ctx); } catch (com.google.gerrit.extensions.restapi.MergeConflictException e) { toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT); throw new com.google.gerrit.server.git.IntegrationException(((("Cannot rebase " + (toMerge.name())) + ": ") + (e.getMessage())), e); } }














@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws java.io.IOException { args.rw.parseBody(toMerge); psId = com.google.gerrit.server.ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId()); java.lang.String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge); org.eclipse.jgit.lib.PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone()); try { newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw); ctx.addRefUpdate(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), newCommit, psId.toRefName())); patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId); } catch (com.google.gerrit.extensions.restapi.MergeConflictException mce) { toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT); } catch (com.google.gerrit.server.git.MergeIdenticalTreeException mie) { toMerge.setStatusCode(CommitMergeStatus.ALREADY_MERGED); } }
@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { if ((newCommit) == null) { return; } ctx.getChangeUpdate().setPatchSetId(psId); com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(psId); ps.setCreatedOn(ctx.getWhen()); ps.setUploader(args.caller.getAccountId()); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(newCommit.getId().getName())); com.google.gerrit.reviewdb.client.Change c = toMerge.change(); ps.setGroups(com.google.gerrit.server.git.GroupCollector.getCurrentGroups(args.db, c)); args.db.patchSets().insert(java.util.Collections.singleton(ps)); c.setCurrentPatchSet(patchSetInfo); args.db.changes().update(java.util.Collections.singletonList(c)); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) { approvals.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(ps.getId(), a)); ctx.getChangeUpdate().putApproval(a.getLabel(), a.getValue()); } args.db.patchSetApprovals().insert(approvals); newCommit.copyFrom(toMerge); newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK); newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller)); mergeTip.moveTipTo(newCommit, newCommit); args.commits.put(newCommit); }
private static com.google.common.base.Optional<com.google.gerrit.common.data.SubmitRecord> findOkRecord(java.util.Collection<com.google.gerrit.common.data.SubmitRecord> in) { if (in == null) { return com.google.common.base.Optional.absent(); } return com.google.common.collect.Iterables.tryFind(in, new com.google.common.base.Predicate<com.google.gerrit.common.data.SubmitRecord>() { @java.lang.Override public boolean apply(com.google.gerrit.common.data.SubmitRecord input) { return (input.status) == (SubmitRecord.Status.OK); } }); }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { this.caller = caller; updateSubmissionId(change); this.db = db; logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); com.google.gerrit.server.git.MergeOp.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); failFast(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Merge Conflict", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Merge Conflict", e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private com.google.gerrit.server.git.MergeTip preMerge(com.google.gerrit.server.git.strategy.SubmitStrategy strategy, java.util.List<com.google.gerrit.server.query.change.ChangeData> submitted, com.google.gerrit.server.git.CodeReviewCommit branchTip) throws com.google.gerrit.server.git.IntegrationException, com.google.gwtorm.server.OrmException { logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted); java.util.List<com.google.gerrit.server.git.CodeReviewCommit> toMerge = new java.util.ArrayList(submitted.size()); for (com.google.gerrit.server.query.change.ChangeData cd : submitted) { com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(cd.getId()); checkState((commit != null), "commit for %s not found by validateChangeList", cd.change().getId()); toMerge.add(commit); } return strategy.run(branchTip, toMerge); }

@java.lang.Override public void updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((rebaseOp) == null) { return; } rebaseOp.updateChange(ctx); com.google.gerrit.reviewdb.client.PatchSet newPatchSet = rebaseOp.getPatchSet(); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) { approvals.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(newPatchSet.getId(), a)); } args.db.patchSetApprovals().upsert(approvals); com.google.gerrit.server.git.CodeReviewCommit newTip = args.rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(newPatchSet.getRevision().get())); mergeTip.moveTipTo(newTip, newTip); toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId())); mergeTip.getCurrentTip().copyFrom(toMerge); mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller)); mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId()); mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE); args.commits.put(mergeTip.getCurrentTip()); acceptMergeTip(mergeTip); }

void storeEvent(com.google.gerrit.server.events.ProjectEvent event) throws java.sql.SQLException { storeEvent(event.getProjectNameKey().get(), new java.sql.Timestamp(java.util.concurrent.TimeUnit.SECONDS.toMillis(event.eventCreatedOn)), new com.google.gson.Gson().toJson(event)); }
@java.lang.Override protected java.nio.file.Path getResourcePath(java.lang.String pathInfo) throws java.io.IOException { return com.google.gerrit.launcher.GerritLauncher.getZipFileSystem(zip).getPath(("bower_components/" + pathInfo)); }
static java.nio.file.Path getZipPath(java.nio.file.Path buckOut) { if (buckOut == null) { return null; } return buckOut.resolve("gen").resolve("polygerrit-ui").resolve("polygerrit_components").resolve("polygerrit_components.bower_components.zip"); }


private void parse(org.eclipse.jgit.revwalk.RevCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { createdOn = com.google.gerrit.server.notedb.ChangeNotesParser.getCommitTime(commit); if ((lastUpdatedOn) == null) { lastUpdatedOn = com.google.gerrit.server.notedb.ChangeNotesParser.getCommitTime(commit); } if ((status) == null) { status = parseStatus(commit); } com.google.gerrit.reviewdb.client.PatchSet.Id psId = parsePatchSetId(commit); com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent(commit); ownerId = accountId; parseChangeMessage(psId, accountId, commit); if ((topic) == null) { topic = parseTopic(commit); } parseHashtags(commit); if (submitRecords.isEmpty()) { parseSubmitRecords(commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_SUBMITTED_WITH)); } for (java.lang.String line : commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_LABEL)) { parseApproval(psId, accountId, commit, line); } for (com.google.gerrit.server.notedb.ReviewerStateInternal state : com.google.gerrit.server.notedb.ReviewerStateInternal.values()) { for (java.lang.String line : commit.getFooterLines(state.getFooterKey())) { parseReviewer(state, line); } } }
@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.extensions.restapi.MergeConflictException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.RevId oldRev = originalPatchSet.getRevision(); org.eclipse.jgit.revwalk.RevWalk rw = ctx.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit original = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(oldRev.get())); rw.parseBody(original); org.eclipse.jgit.revwalk.RevCommit baseCommit; if ((baseCommitish) != null) { baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish)); } else { baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk())); } org.eclipse.jgit.lib.ObjectId newId = rebaseCommit(ctx, original, baseCommit); rebasedCommit = rw.parseCommit(newId); rebasedPatchSetId = com.google.gerrit.server.ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId()); patchSetInserter = patchSetInserterFactory.create(ctl.getRefControl(), rebasedPatchSetId, rebasedCommit).setDraft(originalPatchSet.isDraft()).setUploader(ctx.getUser().getAccountId()).setSendMail(false).setRunHooks(runHooks).setCopyApprovals(copyApprovals).setMessage((((("Patch Set " + (rebasedPatchSetId.get())) + ": Patch Set ") + (originalPatchSet.getId().get())) + " was rebased")); if ((validate) != null) { patchSetInserter.setValidatePolicy(validate); } patchSetInserter.updateRepo(ctx); }

private void parse(org.eclipse.jgit.revwalk.RevCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { createdOn = com.google.gerrit.server.notedb.ChangeNotesParser.getCommitTime(commit); if ((lastUpdatedOn) == null) { lastUpdatedOn = com.google.gerrit.server.notedb.ChangeNotesParser.getCommitTime(commit); } if ((branch) == null) { branch = parseBranch(commit); } if ((status) == null) { status = parseStatus(commit); } com.google.gerrit.reviewdb.client.PatchSet.Id psId = parsePatchSetId(commit); com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent(commit); ownerId = accountId; parseChangeMessage(psId, accountId, commit); if ((topic) == null) { topic = parseTopic(commit); } parseHashtags(commit); if (submitRecords.isEmpty()) { parseSubmitRecords(commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_SUBMITTED_WITH)); } for (java.lang.String line : commit.getFooterLines(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_LABEL)) { parseApproval(psId, accountId, commit, line); } for (com.google.gerrit.server.notedb.ReviewerStateInternal state : com.google.gerrit.server.notedb.ReviewerStateInternal.values()) { for (java.lang.String line : commit.getFooterLines(state.getFooterKey())) { parseReviewer(state, line); } } }
private boolean isEmpty() { return (((((((((approvals.isEmpty()) && ((changeMessage) == null)) && (comments.isEmpty())) && (reviewers.isEmpty())) && ((branch) == null)) && ((status) == null)) && ((subject) == null)) && ((submitRecords) == null)) && ((hashtags) == null)) && ((topic) == null); }
private org.eclipse.jgit.revwalk.RevCommit rebaseCommit(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx, org.eclipse.jgit.revwalk.RevCommit original, org.eclipse.jgit.lib.ObjectId base) throws com.google.gerrit.extensions.restapi.MergeConflictException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { org.eclipse.jgit.revwalk.RevCommit parentCommit = original.getParent(0); if (base.equals(parentCommit)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Change is already up to date."); } org.eclipse.jgit.merge.ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getRepository(), ctx.getInserter()); merger.setBase(parentCommit); merger.merge(original, base); if ((merger.getResultTreeId()) == null) { throw new com.google.gerrit.extensions.restapi.MergeConflictException("The change could not be rebased due to a conflict during merge."); } org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(merger.getResultTreeId()); cb.setParentId(base); cb.setAuthor(original.getAuthorIdent()); cb.setMessage(original.getFullMessage()); if ((committerIdent) != null) { cb.setCommitter(committerIdent); } else { cb.setCommitter(ctx.getUser().asIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone())); } org.eclipse.jgit.lib.ObjectId objectId = ctx.getInserter().insert(cb); ctx.getInserter().flush(); return ctx.getRevWalk().parseCommit(objectId); }
com.google.common.util.concurrent.CheckedFuture<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.extensions.restapi.RestApiException> insertPatchSet() throws java.io.IOException { rp.getRevWalk().parseBody(newCommit); final java.lang.Thread caller = java.lang.Thread.currentThread(); com.google.common.util.concurrent.ListenableFuture<com.google.gerrit.reviewdb.client.PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new java.util.concurrent.Callable<com.google.gerrit.reviewdb.client.PatchSet.Id>() { @java.lang.Override public PatchSet.Id call() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { try { if (((magicBranch) != null) && (magicBranch.edit)) { return upsertEdit(); } else if (caller == (java.lang.Thread.currentThread())) { return insertPatchSet(db); } else { try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { return insertPatchSet(db); } } } finally { com.google.gerrit.server.git.ReceiveCommits.synchronizedIncrement(replaceProgress); } } })); return com.google.common.util.concurrent.Futures.makeChecked(future, com.google.gerrit.server.git.ReceiveCommits.INSERT_EXCEPTION); }

@java.lang.Override public PatchSet.Id call() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { try { if (((magicBranch) != null) && (magicBranch.edit)) { return upsertEdit(); } else if (caller == (java.lang.Thread.currentThread())) { return insertPatchSet(db); } else { try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { return insertPatchSet(db); } } } finally { com.google.gerrit.server.git.ReceiveCommits.synchronizedIncrement(replaceProgress); } }
private java.util.List<com.google.gerrit.server.change.RevisionResource> find(com.google.gerrit.server.change.ChangeResource change, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { if (id.equals("0")) { return loadEdit(change, null); } else if (((id.length()) < 6) && (id.matches("^[1-9][0-9]{0,4}$"))) { return byLegacyPatchSetId(change, id); } else if (((id.length()) < 4) || ((id.length()) > (com.google.gerrit.reviewdb.client.RevId.LEN))) { return java.util.Collections.emptyList(); } else { java.util.List<com.google.gerrit.server.change.RevisionResource> out = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.PatchSet ps : dbProvider.get().patchSets().byChange(change.getId())) { if (((ps.getRevision()) != null) && (ps.getRevision().get().startsWith(id))) { out.add(new com.google.gerrit.server.change.RevisionResource(change, ps)); } } return out; } }
private org.eclipse.jgit.lib.ObjectId toObjectId(com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.project.NoSuchChangeException, java.io.IOException { if (((ps == null) || ((ps.getRevision()) == null)) || ((ps.getRevision().get()) == null)) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } if ((ps.getId().get()) == 0) { return getEditRev(); } try { return org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.patch.PatchScriptFactory.log.error((("Patch set " + (ps.getId())) + " has invalid revision")); throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
private static void onRemoveVote(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); java.lang.String vote = com.google.gerrit.client.change.Labels.getVoteId(event); if ((user != null) && (vote != null)) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); com.google.gerrit.client.changes.ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } } }); } }
private static void onRemoveReviewer(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); if (user != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); com.google.gerrit.client.changes.ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } } }); } }
private static void onRemove(com.google.gwt.dom.client.NativeEvent event) { java.lang.String hashtags = com.google.gerrit.client.change.Hashtags.getDataId(event); if (hashtags != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); com.google.gerrit.client.changes.ChangeApi.hashtags(screen.getChangeId().get()).post(com.google.gerrit.client.change.Hashtags.PostInput.create(null, hashtags), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } } }); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getChangeId())); } }
private static java.lang.String getReviewCategoryDisplayInfo(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ReviewCategoryStrategy reviewCategoryStrategy, com.google.gerrit.client.info.AccountInfo accountInfo) { switch (reviewCategoryStrategy) { case NAME : return accountInfo.name(); case EMAIL : return accountInfo.email(); case USERNAME : return accountInfo.username(); case ABBREV : return com.google.gerrit.client.changes.ChangeTable.getAbbreviation(accountInfo.name(), " "); default : return null; } }


public final com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView diffView() { java.lang.String s = diffViewRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView.valueOf(s) : null; }
public static com.google.gerrit.client.info.AccountPreferencesInfo createDefault() { com.google.gerrit.reviewdb.client.AccountGeneralPreferences defaultPrefs = com.google.gerrit.reviewdb.client.AccountGeneralPreferences.createDefault(); com.google.gerrit.client.info.AccountPreferencesInfo p = createObject().cast(); p.changesPerPage(defaultPrefs.getMaximumPageSize()); p.showSiteHeader(defaultPrefs.isShowSiteHeader()); p.useFlashClipboard(defaultPrefs.isUseFlashClipboard()); p.downloadScheme(defaultPrefs.getDownloadUrl()); p.downloadCommand(defaultPrefs.getDownloadCommand()); p.copySelfOnEmail(defaultPrefs.isCopySelfOnEmails()); p.dateFormat(defaultPrefs.getDateFormat()); p.timeFormat(defaultPrefs.getTimeFormat()); p.relativeDateInChangeTable(defaultPrefs.isRelativeDateInChangeTable()); p.sizeBarInChangeTable(defaultPrefs.isSizeBarInChangeTable()); p.legacycidInChangeTable(defaultPrefs.isLegacycidInChangeTable()); p.muteCommonPathPrefixes(defaultPrefs.isMuteCommonPathPrefixes()); p.reviewCategoryStrategy(defaultPrefs.getReviewCategoryStrategy()); p.diffView(defaultPrefs.getDiffView()); return p; }
@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account a = db.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId()); p.load(git); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(a.getGeneralPreferences(), p, git); } }

public final com.google.gerrit.reviewdb.client.AccountGeneralPreferences.TimeFormat timeFormat() { java.lang.String s = timeFormatRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountGeneralPreferences.TimeFormat.valueOf(s) : null; }
@java.lang.Override public GetPreferences.PreferenceInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.SetPreferences.Input i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to members of Modify Accounts"); } if (i == null) { i = new com.google.gerrit.server.account.SetPreferences.Input(); } com.google.gerrit.reviewdb.client.Account.Id accountId = rsrc.getUser().getAccountId(); com.google.gerrit.reviewdb.client.AccountGeneralPreferences p; com.google.gerrit.server.account.VersionedAccountPreferences versionedPrefs; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName); db.get().accounts().beginTransaction(accountId); try { com.google.gerrit.reviewdb.client.Account a = db.get().accounts().get(accountId); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } versionedPrefs = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(accountId); versionedPrefs.load(md); p = a.getGeneralPreferences(); if (p == null) { p = new com.google.gerrit.reviewdb.client.AccountGeneralPreferences(); a.setGeneralPreferences(p); } if ((i.changesPerPage) != null) { p.setMaximumPageSize(i.changesPerPage); } if ((i.showSiteHeader) != null) { p.setShowSiteHeader(i.showSiteHeader); } if ((i.useFlashClipboard) != null) { p.setUseFlashClipboard(i.useFlashClipboard); } if ((i.downloadScheme) != null) { setDownloadScheme(p, i.downloadScheme); } if ((i.downloadCommand) != null) { p.setDownloadCommand(i.downloadCommand); } if ((i.copySelfOnEmail) != null) { p.setCopySelfOnEmails(i.copySelfOnEmail); } if ((i.dateFormat) != null) { p.setDateFormat(i.dateFormat); } if ((i.timeFormat) != null) { p.setTimeFormat(i.timeFormat); } if ((i.relativeDateInChangeTable) != null) { p.setRelativeDateInChangeTable(i.relativeDateInChangeTable); } if ((i.sizeBarInChangeTable) != null) { p.setSizeBarInChangeTable(i.sizeBarInChangeTable); } if ((i.legacycidInChangeTable) != null) { p.setLegacycidInChangeTable(i.legacycidInChangeTable); } if ((i.muteCommonPathPrefixes) != null) { p.setMuteCommonPathPrefixes(i.muteCommonPathPrefixes); } if ((i.reviewCategoryStrategy) != null) { p.setReviewCategoryStrategy(i.reviewCategoryStrategy); } if ((i.diffView) != null) { p.setDiffView(i.diffView); } db.get().accounts().update(java.util.Collections.singleton(a)); db.get().commit(); com.google.gerrit.server.account.SetPreferences.storeMyMenus(versionedPrefs, i.my); com.google.gerrit.server.account.SetPreferences.storeUrlAliases(versionedPrefs, i.urlAliases); versionedPrefs.commit(md); cache.evict(accountId); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository()); } finally { md.close(); db.get().rollback(); } }
public final short changesPerPage() { short changesPerPage = get("changes_per_page", AccountGeneralPreferences.DEFAULT_PAGESIZE); return 0 < changesPerPage ? changesPerPage : com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DEFAULT_PAGESIZE; }


private void setDownloadScheme(com.google.gerrit.reviewdb.client.AccountGeneralPreferences p, java.lang.String scheme) throws com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.extensions.registration.DynamicMap.Entry<com.google.gerrit.extensions.config.DownloadScheme> e : downloadSchemes) { if ((e.getExportName().equals(scheme)) && (e.getProvider().get().isEnabled())) { p.setDownloadUrl(scheme); return; } } throw new com.google.gerrit.extensions.restapi.BadRequestException(("Unsupported download scheme: " + scheme)); }

@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(git); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, git); } }
private void display(com.google.gerrit.client.info.AccountPreferencesInfo p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); copySelfOnEmails.setValue(p.copySelfOnEmail()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes()); setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView()); display(p.my()); }
public com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadCommand> getDownloadCommands() { return downloadCommands; }
public final com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DateFormat dateFormat() { java.lang.String s = dateFormatRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DateFormat.valueOf(s) : null; }
public final com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ReviewCategoryStrategy reviewCategoryStrategy() { java.lang.String s = reviewCategeoryStrategyRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ReviewCategoryStrategy.valueOf(s) : com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ReviewCategoryStrategy.NONE; }

public final void diffView(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView d) { diffViewRaw((d != null ? d.toString() : null)); }
public final void reviewCategoryStrategy(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ReviewCategoryStrategy s) { reviewCategoryStrategyRaw((s != null ? s.toString() : null)); }
public final void timeFormat(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.TimeFormat f) { timeFormatRaw((f != null ? f.toString() : null)); }
public final void dateFormat(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DateFormat f) { dateFormatRaw((f != null ? f.toString() : null)); }
public final void downloadCommand(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadCommand d) { downloadCommandRaw((d != null ? d.toString() : null)); }
private void loadFromAllUsers(com.google.gerrit.server.account.VersionedAccountPreferences v, org.eclipse.jgit.lib.Repository allUsers) { my = my(v); if ((my.isEmpty()) && (!(v.isDefaults()))) { try { com.google.gerrit.server.account.VersionedAccountPreferences d = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); d.load(allUsers); my = my(d); } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { com.google.gerrit.server.account.GetPreferences.log.warn("cannot read default preferences", e); } } if (my.isEmpty()) { my.add(new com.google.gerrit.extensions.client.MenuItem("Changes", "#/dashboard/self", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Drafts", "#/q/owner:self+is:draft", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Draft Comments", "#/q/has:draft", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Edits", "#/q/has:edit", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Watched Changes", "#/q/is:watched+is:open", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Starred Changes", "#/q/is:starred", null)); my.add(new com.google.gerrit.extensions.client.MenuItem("Groups", "#/groups/self", null)); } urlAliases = com.google.gerrit.server.account.GetPreferences.PreferenceInfo.urlAliases(v); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.account.SetPreferences.Input i) throws com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((((((((((((((i.changesPerPage) != null) || ((i.showSiteHeader) != null)) || ((i.useFlashClipboard) != null)) || ((i.downloadScheme) != null)) || ((i.downloadCommand) != null)) || ((i.copySelfOnEmail) != null)) || ((i.dateFormat) != null)) || ((i.timeFormat) != null)) || ((i.relativeDateInChangeTable) != null)) || ((i.sizeBarInChangeTable) != null)) || ((i.legacycidInChangeTable) != null)) || ((i.muteCommonPathPrefixes) != null)) || ((i.reviewCategoryStrategy) != null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported option"); } com.google.gerrit.server.account.VersionedAccountPreferences p; com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName); try { p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); p.commit(md); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(null, p, md.getRepository()); } finally { md.close(); } }
private final java.util.List<com.google.gerrit.client.info.WebLinkInfo> filterWebLinks(com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView diffView) { java.util.List<com.google.gerrit.client.info.WebLinkInfo> filteredDiffWebLinks = new java.util.LinkedList<>(); java.util.List<com.google.gerrit.client.DiffWebLinkInfo> allDiffWebLinks = com.google.gerrit.client.rpc.Natives.asList(webLinks()); if (allDiffWebLinks != null) { for (com.google.gerrit.client.DiffWebLinkInfo webLink : allDiffWebLinks) { if ((diffView == (com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView.SIDE_BY_SIDE)) && (webLink.showOnSideBySideDiffView())) { filteredDiffWebLinks.add(webLink); } if ((diffView == (com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DiffView.UNIFIED_DIFF)) && (webLink.showOnUnifiedDiffView())) { filteredDiffWebLinks.add(webLink); } } } return filteredDiffWebLinks; }

public final com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadCommand downloadCommand() { java.lang.String s = downloadCommandRaw(); return s != null ? com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadCommand.valueOf(s) : null; }

public void setCommit(org.eclipse.jgit.lib.ObjectId commit) { checkArgument((commit != null)); this.commit = commit; }

private void updateGroups(com.google.gerrit.server.git.ReceiveCommits.RequestState state) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = state.db; com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().atomicUpdate(psId, new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.PatchSet>() { @java.lang.Override public com.google.gerrit.reviewdb.client.PatchSet update(com.google.gerrit.reviewdb.client.PatchSet ps) { java.util.List<java.lang.String> oldGroups = ps.getGroups(); if (oldGroups == null) { if ((groups) == null) { return null; } } else if (com.google.common.collect.Sets.newHashSet(oldGroups).equals(groups)) { return null; } ps.setGroups(groups); return ps; } }); if (ps != null) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(psId.getParentKey()); if (change != null) { indexer.index(db, change); } } }
@java.lang.Override public com.google.gerrit.reviewdb.client.PatchSet update(com.google.gerrit.reviewdb.client.PatchSet ps) { java.util.List<java.lang.String> oldGroups = ps.getGroups(); if (oldGroups == null) { if ((groups) == null) { return null; } } else if (com.google.common.collect.Sets.newHashSet(oldGroups).equals(groups)) { return null; } ps.setGroups(groups); return ps; }





public void setCurrentPatchSet(final com.google.gerrit.reviewdb.client.PatchSetInfo ps) { if (((originalSubject) == null) && ((subject) != null)) { originalSubject = subject; } currentPatchSetId = ps.getKey().get(); subject = ps.getSubject(); if ((originalSubject) == null) { originalSubject = subject; } }

@org.junit.Test public void patchSetChangeNotes() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertThat(notes.getCurrentPatchSet()).isNull(); org.eclipse.jgit.lib.ObjectId commit = org.eclipse.jgit.lib.ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); update = newUpdate(c, changeOwner); update.setCommit(commit); update.commit(); notes = newNotes(c); com.google.gerrit.reviewdb.client.PatchSet ps = notes.getCurrentPatchSet(); assertThat(ps.getId()).isEqualTo(new com.google.gerrit.reviewdb.client.PatchSet.Id(c.getId(), 1)); assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId()); assertThat(ps.getRevision().get()).isEqualTo(commit.name()); assertThat(ps.getUploader()).isEqualTo(changeOwner.getAccountId()); assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen()); incrementPatchSet(c); commit = org.eclipse.jgit.lib.ObjectId.fromString("badc0feebadc0feebadc0feebadc0feebadc0fee"); update = newUpdate(c, otherUser); update.setCommit(commit); update.commit(); notes = newNotes(c); ps = notes.getCurrentPatchSet(); assertThat(ps.getId()).isEqualTo(new com.google.gerrit.reviewdb.client.PatchSet.Id(c.getId(), 2)); assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId()); assertThat(ps.getRevision().get()).isEqualTo(commit.name()); assertThat(ps.getUploader()).isEqualTo(otherUser.getAccountId()); assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen()); }

@org.junit.Test public void commitChangeNotesUnique() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertThat(notes.getCurrentPatchSet()).isNull(); org.eclipse.jgit.lib.ObjectId commit = org.eclipse.jgit.lib.ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); update = newUpdate(c, changeOwner); update.setCommit(commit); update.commit(); notes = newNotes(c); assertThat(notes.getCurrentPatchSet().getRevision().get()).isEqualTo(commit.name()); commit = org.eclipse.jgit.lib.ObjectId.fromString("badc0feebadc0feebadc0feebadc0feebadc0fee"); update.setCommit(commit); update.commit(); exception.expect(com.google.gwtorm.server.OrmException.class); exception.expectMessage("Multiple revisions parsed for patch set"); notes = newNotes(c); }
protected com.google.gerrit.reviewdb.client.Change newChange() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId()); com.google.gerrit.server.notedb.ChangeUpdate u = newUpdate(c, changeOwner); u.setSubject(c.getSubject()); u.setBranch(c.getDest().get()); u.commit(); return c; }
@org.junit.Test public void changeWithRevision() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId(), 1); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeMessage("Foo"); update.setCommit(org.eclipse.jgit.lib.ObjectId.fromString("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef")); update.commit(); assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta"); assertBodyEquals(("Update patch set 1\n" + (((("\n" + "Foo\n") + "\n") + "Patch-set: 1\n") + "Commit: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef\n")), update.getRevision()); }
public void setSubject(java.lang.String subject) { this.subject = subject; }

private void savePatchSet(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if (!(patchSet.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Patch set is not a draft"); } patchSet.setDraft(false); if (!(wasDraftChange)) { ctx.saveChange(); } ctx.getDb().patchSets().update(java.util.Collections.singleton(patchSet)); }

private void checkMandatoryFooters() throws org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<org.eclipse.jgit.revwalk.FooterKey> missing = new java.util.ArrayList<>(); if ((branch) == null) { missing.add(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_BRANCH); } if (((originalSubject) == null) || ((subject) == null)) { missing.add(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_SUBJECT); } if (!(missing.isEmpty())) { throw parseException(("Missing footers: " + (com.google.common.base.Joiner.on(", ").join(com.google.common.collect.Lists.transform(missing, new com.google.common.base.Function<org.eclipse.jgit.revwalk.FooterKey, java.lang.String>() { @java.lang.Override public java.lang.String apply(org.eclipse.jgit.revwalk.FooterKey input) { return input.getName(); } }))))); } }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { updateSubmissionId(change); this.db = db; logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } try { integrateIntoHistory(cs, caller); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Merge Conflict", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Merge Conflict", e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }


@java.lang.Override protected void preUpdateSchema(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { renameColumn(db, "patch_sets", "push_certficate", "push_certificate"); try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement()) { stmt.execute("ALTER TABLE patch_sets MODIFY push_certificate clob"); } catch (java.sql.SQLException e) { } }

@java.lang.Override void apply(com.google.gerrit.server.notedb.ChangeUpdate update) throws com.google.gwtorm.server.OrmException { checkUpdate(update); update.setChangeMessage(message.getMessage()); setTopic(update); }



byte[] build(com.google.gerrit.server.notedb.CommentsInNotesUtil commentsUtil) { return commentsUtil.buildNote(com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER.sortedCopy(comments.values())); }

private org.eclipse.jgit.lib.ObjectId storeRevisionNotes() throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = ctl.getNotes().load(); org.eclipse.jgit.notes.NoteMap noteMap = notes.getNoteMap(); if (noteMap == null) { noteMap = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); } if (comments.isEmpty()) { return null; } java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNoteBuilder> builders = new java.util.HashMap<>(); for (com.google.gerrit.reviewdb.client.PatchLineComment c : comments) { com.google.gerrit.server.notedb.RevisionNoteBuilder b = builders.get(c.getRevId()); if (b == null) { b = new com.google.gerrit.server.notedb.RevisionNoteBuilder(notes.getRevisionNotes().get(c.getRevId())); builders.put(c.getRevId(), b); } b.addComment(c); } for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNoteBuilder> e : builders.entrySet()) { org.eclipse.jgit.lib.ObjectId data = inserter.insert(com.google.gerrit.server.notedb.OBJ_BLOB, e.getValue().build(commentsUtil)); noteMap.set(org.eclipse.jgit.lib.ObjectId.fromString(e.getKey().get()), data); } return noteMap.writeTree(inserter); }
private void parseComments() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { commentNoteMap = com.google.gerrit.server.notedb.CommentsInNotesUtil.parseCommentsFromNotes(repo, com.google.gerrit.server.notedb.ChangeNoteUtil.changeRefName(changeId), walk, changeId, comments, PatchLineComment.Status.PUBLISHED); }

@java.lang.Override void apply(com.google.gerrit.server.notedb.ChangeUpdate update) { checkUpdate(update); update.setSubject(change.getSubject()); if ((ps.getPatchSetId()) == 1) { update.setSubjectForCommit("Create change"); update.setBranch(change.getDest().get()); } else { update.setSubjectForCommit(("Create patch set " + (ps.getPatchSetId()))); } }
private boolean isEmpty() { return ((((((((((((((commitSubject) == null) && (approvals.isEmpty())) && ((changeMessage) == null)) && (comments.isEmpty())) && (reviewers.isEmpty())) && ((branch) == null)) && ((status) == null)) && ((submissionId) == null)) && ((submitRecords) == null)) && ((hashtags) == null)) && ((topic) == null)) && ((commit) == null)) && ((psState) == null)) && ((groups) == null); }





private static boolean isSecure(javax.servlet.http.HttpServletRequest req) { return (req.isSecure()) || ("https".equals(req.getScheme())); }
private static void setXsrfTokenCookie(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.google.gerrit.httpd.WebSession session) { java.lang.String v = (session != null) ? session.getXGerritAuth() : ""; javax.servlet.http.Cookie c = new javax.servlet.http.Cookie(com.google.gerrit.common.data.HostPageData.XSRF_COOKIE_NAME, v); c.setPath("/"); c.setSecure(com.google.gerrit.httpd.XsrfCookieFilter.isSecure(req)); c.setMaxAge((session != null ? -1 : 0)); rsp.addCookie(c); }
private java.lang.Iterable<java.lang.String> getDraftRefs(final com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { java.util.Set<java.lang.String> refNames = getRefNamesAllUsers(RefNames.REFS_DRAFT_COMMENTS); final java.lang.String suffix = "/" + (changeId.get()); return com.google.common.collect.Iterables.filter(refNames, new com.google.common.base.Predicate<java.lang.String>() { @java.lang.Override public boolean apply(java.lang.String input) { return input.endsWith(suffix); } }); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> byPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return com.google.gerrit.server.PatchLineCommentsUtil.sort(db.patchComments().byPatchSet(psId).toList()); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); comments.addAll(publishedByPatchSet(db, notes, psId)); java.lang.Iterable<java.lang.String> filtered = getDraftRefs(notes.getChangeId()); for (java.lang.String refName : filtered) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefPart(refName); if (account != null) { comments.addAll(draftByPatchSetAuthor(db, psId, account, notes)); } } return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }

@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.gwtorm.server.SchemaFactory<com.google.gerrit.reviewdb.server.ReviewDb>>() {}).to(new com.google.inject.TypeLiteral<com.google.gwtorm.jdbc.Database<com.google.gerrit.reviewdb.server.ReviewDb>>() {}).in(com.google.gerrit.server.schema.SINGLETON); bind(new com.google.inject.TypeLiteral<com.google.gwtorm.jdbc.Database<com.google.gerrit.reviewdb.server.ReviewDb>>() {}).toProvider(com.google.gerrit.server.schema.ReviewDbDatabaseProvider.class).in(com.google.gerrit.server.schema.SINGLETON); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChange(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return com.google.gerrit.server.PatchLineCommentsUtil.sort(com.google.gerrit.server.PatchLineCommentsUtil.byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT)); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = com.google.common.collect.Lists.newArrayList(); java.lang.Iterable<java.lang.String> filtered = getDraftRefs(notes.getChangeId()); for (java.lang.String refName : filtered) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefPart(refName); if (account != null) { comments.addAll(draftByChangeAuthor(db, notes, account)); } } return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
@org.junit.Test public void queryChangesOptions() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); ChangeInfo result = com.google.common.collect.Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(java.util.EnumSet.allOf(com.google.gerrit.extensions.client.ListChangesOption.class)).get()); assertThat(com.google.common.collect.Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review"); assertThat(result.messages).hasSize(1); assertThat(result.actions).isNotEmpty(); com.google.gerrit.extensions.common.RevisionInfo rev = com.google.common.collect.Iterables.getOnlyElement(result.revisions.values()); assertThat(rev._number).isEqualTo(r.getPatchSetId().get()); assertThat(rev.created).isNotNull(); assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get()); assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName()); assertThat(rev.actions).isNotEmpty(); }
private com.google.gerrit.extensions.common.ChangeMessageInfo getLastMessage(com.google.gerrit.acceptance.PushOneCommit.Result r) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.ChangeMessageInfo lastMessage = com.google.common.collect.Iterables.getLast(gApi.changes().id(r.getChange().getId().get()).get().messages, null); assertThat(lastMessage).isNotNull(); return lastMessage; }



public com.google.gerrit.reviewdb.client.PatchSet insert(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.PatchSet.Id psId, org.eclipse.jgit.lib.ObjectId commit, boolean draft, java.lang.Iterable<java.lang.String> groups, java.lang.String pushCertificate) throws com.google.gwtorm.server.OrmException, java.io.IOException { ensurePatchSetMatches(psId, update); com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(psId); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(commit.name())); ps.setUploader(update.getUser().getAccountId()); ps.setCreatedOn(new java.sql.Timestamp(update.getWhen().getTime())); ps.setDraft(draft); ps.setGroups(groups); ps.setPushCertificate(pushCertificate); db.patchSets().insert(java.util.Collections.singleton(ps)); update.setCommit(rw, commit, pushCertificate); if (draft) { update.setPatchSetState(com.google.gerrit.server.DRAFT); } return ps; }
private void submit(java.lang.String changeId, int expectedStatus, java.lang.String msg) throws java.lang.Exception { approve(changeId); com.google.gerrit.extensions.api.changes.SubmitInput subm = new com.google.gerrit.extensions.api.changes.SubmitInput(); com.google.gerrit.acceptance.RestResponse r = adminSession.post((("/changes/" + changeId) + "/submit"), subm); assertThat(r.getStatusCode()).named((("Status code [" + (r.getEntityContent())) + "]")).isEqualTo(expectedStatus); if (expectedStatus == (org.apache.http.HttpStatus.SC_OK)) { checkArgument((msg == null), "msg must be null for successful submits"); com.google.gerrit.extensions.common.ChangeInfo change = newGson().fromJson(r.getReader(), new com.google.gson.reflect.TypeToken<com.google.gerrit.extensions.common.ChangeInfo>() {}.getType()); assertThat(change.status).isEqualTo(ChangeStatus.MERGED); checkMergeResult(change); } else { checkArgument((!(com.google.common.base.Strings.isNullOrEmpty(msg))), ("msg must be a valid string " + "containing an error message for unsuccessful submits")); assertThat(r.getEntityContent()).isEqualTo(msg); } r.consume(); }
@java.lang.Override protected void setUpEnvironment(com.google.gerrit.rules.PrologEnvironment env) { com.google.gerrit.reviewdb.client.Change change = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Ibeef"), new com.google.gerrit.reviewdb.client.Change.Id(1), new com.google.gerrit.reviewdb.client.Account.Id(2), new com.google.gerrit.reviewdb.client.Branch.NameKey(localKey, "refs/heads/master"), com.google.gerrit.common.TimeUtil.nowTs()); env.set(StoredValues.CHANGE_CONTROL, util.user(local).controlFor(change)); }
@java.lang.Override public void run() { com.google.gerrit.server.util.RequestContext old = requestContext.setContext(this); try { com.google.gerrit.server.mail.CommentSender cm = commentSenderFactory.create(notify, change.getId()); cm.setFrom(authorId); cm.setPatchSet(patchSet, patchSetInfoFactory.get(change, patchSet)); cm.setChangeMessage(message); cm.setPatchLineComments(comments); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.EmailReviewComments.log.error(("Cannot email comments for " + (patchSet.getId())), e); } finally { requestContext.setContext(old); if ((db) != null) { db.close(); db = null; } } }

@java.lang.Override public final void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws java.lang.Exception { com.google.gerrit.server.git.CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip(); updateRepoImpl(ctx); com.google.gerrit.server.git.CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip(); if (java.util.Objects.equals(tipBefore, tipAfter)) { return; } else if (tipAfter == null) { logDebug("No merge tip, no update to perform"); return; } checkProjectConfig(ctx, tipAfter); command = new org.eclipse.jgit.transport.ReceiveCommand(firstNonNull(tipBefore, org.eclipse.jgit.lib.ObjectId.zeroId()), tipAfter, getDest().get()); ctx.addRefUpdate(command); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { if (!((repoManager) instanceof com.google.gerrit.server.git.LocalDiskRepositoryManager)) { return; } ui.message("listing all repositories ..."); java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> repoList = repoManager.list(); ui.message("done"); ui.message(java.lang.String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG)); for (com.google.gerrit.reviewdb.client.Project.NameKey project : repoList) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { java.io.File metaConfigLog = new java.io.File(repo.getDirectory(), ("logs/" + (com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG))); if (metaConfigLog.exists()) { continue; } if ((!(metaConfigLog.getParentFile().mkdirs())) || (!(metaConfigLog.createNewFile()))) { throw new java.io.IOException(java.lang.String.format("Failed to create reflog for %s in repository %s", RefNames.REFS_CONFIG, project)); } org.eclipse.jgit.lib.ObjectId metaConfigId = repo.resolve(RefNames.REFS_CONFIG); if (metaConfigId != null) { try (java.io.PrintWriter writer = new java.io.PrintWriter(metaConfigLog, java.nio.charset.StandardCharsets.UTF_8.name())) { writer.print(org.eclipse.jgit.lib.ObjectId.zeroId().name()); writer.print(" "); writer.print(metaConfigId.name()); writer.print(" "); writer.print(serverUser.toExternalString()); writer.print("\t"); writer.print("create reflog"); writer.println(); } } } catch (java.io.IOException e) { ui.message(java.lang.String.format(("ERROR: Failed to create reflog file for the" + " %s branch in repository %s"), RefNames.REFS_CONFIG, project.get())); } } ui.message("done"); }
protected com.google.gerrit.server.notedb.ChangeNotes newNotes(com.google.gerrit.reviewdb.client.Change c) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION, allUsers, c).load(); }
public static com.google.gerrit.server.project.ChangeControl stubChangeControl(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.notedb.NotesMigration migration, com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.config.AllUsersNameProvider allUsers, com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = org.easymock.EasyMock.createMock(com.google.gerrit.server.project.ChangeControl.class); expect(ctl.getChange()).andStubReturn(c); expect(ctl.getProject()).andStubReturn(new com.google.gerrit.reviewdb.client.Project(c.getProject())); expect(ctl.getUser()).andStubReturn(user); com.google.gerrit.server.notedb.ChangeNotes notes = new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, c).load(); expect(ctl.getNotes()).andStubReturn(notes); expect(ctl.getId()).andStubReturn(c.getId()); org.easymock.EasyMock.replay(ctl); return ctl; }
private com.google.gerrit.server.git.BatchUpdate.ChangeContext newChangeContext(com.google.gerrit.reviewdb.client.Change.Id id) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChanges.get(id); if (c == null) { c = db.changes().get(id); } com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.createForNew(c); com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx = new com.google.gerrit.server.git.BatchUpdate.ChangeContext(changeControlFactory.controlFor(notes, user), new com.google.gerrit.server.git.BatchUpdateReviewDb(db)); if (notesMigration.readChanges()) { ctx.getNotes().load(); } return ctx; }
public com.google.gerrit.server.notedb.ChangeNotes create(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsersProvider, change); }
public com.google.gerrit.server.notedb.ChangeNotes createForNew(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsersProvider, change); }




private static boolean canCopy(com.google.gerrit.server.project.ProjectState project, com.google.gerrit.reviewdb.client.PatchSetApproval psa, com.google.gerrit.reviewdb.client.PatchSet.Id psId, java.util.NavigableSet<java.lang.Integer> allPsIds, com.google.gerrit.server.change.ChangeKind kind) { int n = psa.getKey().getParentKey().get(); checkArgument((n != (psId.get()))); com.google.gerrit.common.data.LabelType type = project.getLabelTypes().byLabel(psa.getLabelId()); if (type == null) { return false; } else if ((java.util.Objects.equals(n, com.google.gerrit.server.ApprovalCopier.previous(allPsIds, psId.get()))) && (((type.isCopyMinScore()) && (type.isMaxNegative(psa))) || ((type.isCopyMaxScore()) && (type.isMaxPositive(psa))))) { return true; } return (((type.isCopyAllScoresOnTrivialRebase()) && (kind == (TRIVIAL_REBASE))) || ((type.isCopyAllScoresIfNoCodeChange()) && (kind == (NO_CODE_CHANGE)))) || ((type.isCopyAllScoresIfNoChange()) && (kind == (NO_CHANGE))); }


@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.fullTextSearch", value = "true") public void suggestReviewersFullTextSearch() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(changeId, "first", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "first1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "last", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "last1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "fi la", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "la fi", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "first1 la", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "fi last1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "first1 last2", 1); assertThat(reviewers).hasSize(0); reviewers = suggestReviewers(changeId, name("user"), 7); assertThat(reviewers).hasSize(6); reviewers = suggestReviewers(changeId, user1.username, 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "example.com", 6); assertThat(reviewers).hasSize(5); reviewers = suggestReviewers(changeId, user1.email, 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, ((user1.username) + " example"), 2); assertThat(reviewers).hasSize(1); }
@org.junit.Before public void setUp() throws java.lang.Exception { group1 = group("users1"); group2 = group("users2"); group3 = group("users3"); user1 = user("user1", "First1 Last1", group1); user2 = user("user2", "First2 Last2", group2); user3 = user("user3", "First3 Last3", group1, group2); }
public com.google.gerrit.server.project.ChangeControl controlFor(com.google.gerrit.server.notedb.ChangeNotes notes) { return changeControlFactory.create(controlForRef(notes.getChange().getDest()), notes); }
com.google.gerrit.server.project.ChangeControl create(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.notedb.ChangeNotes notes) { return new com.google.gerrit.server.project.ChangeControl(changeDataFactory, approvalsUtil, refControl, notes); }
com.google.gerrit.server.project.ChangeControl create(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.reviewdb.client.Change change) { return create(refControl, notesFactory.create(db, change)); }
public com.google.gerrit.server.project.ChangeControl controlFor(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.NoSuchChangeException { try { return projectControl.controlFor(notes.getProjectName(), user).controlFor(notes); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.project.NoSuchChangeException(notes.getChangeId(), e); } }
@java.lang.Override public com.google.gerrit.server.account.GetPreferences.PreferenceInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account a = db.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId()); p.load(git); return new com.google.gerrit.server.account.GetPreferences.PreferenceInfo(a.getGeneralPreferences(), p, git); } }
public T load() throws com.google.gwtorm.server.OrmException { if (loaded) { return self(); } if (!(migration.enabled())) { loadDefaults(); return self(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openMetadataRepository(getProjectName())) { load(repo); loaded = true; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } return self(); }
@org.junit.Test public void changeMessageCommitFormatSimple() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId(), 1); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeMessage(("Just a little code change.\n" + "How about a new line")); update.commit(); assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta"); assertBodyEquals((((((((("Update patch set 1\n" + ((((("\n" + "Just a little code change.\n") + "How about a new line\n") + "\n") + "Patch-set: 1\n") + "Change-id: ")) + (c.getKey().get())) + "\n") + "Subject: Change subject\n") + "Branch: refs/heads/master\n") + "Commit: ") + (update.getCommit().name())) + "\n"), update.getRevision()); }
public com.google.gerrit.server.notedb.ChangeNotes createForNew(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.ChangeNotes(db, repoManager, migration, allUsersProvider, change); }
public static com.google.gerrit.server.query.change.QueryOptions create(com.google.gerrit.server.index.IndexConfig config, int start, int limit, java.util.Set<java.lang.String> fields) { checkArgument((start >= 0), "start must be nonnegative: %s", start); checkArgument((limit > 0), "limit must be positive: %s", limit); return new com.google.gerrit.server.query.change.AutoValue_QueryOptions(config, start, limit, com.google.common.collect.ImmutableSet.copyOf(fields)); }
public com.google.gerrit.server.notedb.ChangeNotes create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.ChangeNotes(db, repoManager, migration, allUsersProvider, change); }
public com.google.gerrit.reviewdb.client.Change getChange() { return change; }
private com.google.gerrit.server.notedb.ChangeNotes newNotes(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { return notesFactory.create(db, change); }
public static com.google.gerrit.server.project.ChangeControl stubChangeControl(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.notedb.NotesMigration migration, com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.config.AllUsersNameProvider allUsers, com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = org.easymock.EasyMock.createMock(com.google.gerrit.server.project.ChangeControl.class); expect(ctl.getChange()).andStubReturn(c); expect(ctl.getProject()).andStubReturn(new com.google.gerrit.reviewdb.client.Project(c.getProject())); expect(ctl.getUser()).andStubReturn(user); com.google.gerrit.server.notedb.ChangeNotes notes = new com.google.gerrit.server.notedb.ChangeNotes(null, repoManager, migration, allUsers, c).load(); expect(ctl.getNotes()).andStubReturn(notes); expect(ctl.getId()).andStubReturn(c.getId()); org.easymock.EasyMock.replay(ctl); return ctl; }
protected abstract void loadDefaults();
@org.junit.Test public void changeWithRevision() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId(), 1); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeMessage("Foo"); org.eclipse.jgit.revwalk.RevCommit commit = tr.commit().message("Subject").create(); update.setCommit(rw, commit); update.commit(); assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta"); assertBodyEquals((((((((("Update patch set 1\n" + (((("\n" + "Foo\n") + "\n") + "Patch-set: 1\n") + "Change-id: ")) + (c.getKey().get())) + "\n") + "Subject: Subject\n") + "Branch: refs/heads/master\n") + "Commit: ") + (commit.name())) + "\n"), update.getRevision()); }
private com.google.gerrit.server.change.RevisionResource parseRevisionResource(com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSet.Id psId = r.getPatchSetId(); java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeUtil.findChanges(java.lang.Integer.toString(psId.getParentKey().get()), atrScope.get().getUser()); assertThat(ctls).hasSize(1); return revisions.parse(new com.google.gerrit.server.change.ChangeResource(ctls.get(0)), com.google.gerrit.extensions.restapi.IdString.fromDecoded(java.lang.Integer.toString(psId.get()))); }
protected com.google.gerrit.server.notedb.ChangeUpdate newUpdate(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.IdentifiedUser user) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeUpdate update = com.google.gerrit.testutil.TestChanges.newUpdate(injector, repoManager, com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION, c, allUsers, user); try (org.eclipse.jgit.lib.Repository repo = repoManager.openMetadataRepository(c.getProject())) { update.load(repo); } return update; }

public java.util.List<com.google.gerrit.server.project.ChangeControl> findChanges(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if ((!(id.isEmpty())) && ((id.charAt(0)) != '0')) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); try { if (n != null) { return com.google.common.collect.ImmutableList.of(changeControlFactory.controlFor(new com.google.gerrit.reviewdb.client.Change.Id(n), user)); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return java.util.Collections.emptyList(); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().setRequestedFields(com.google.common.collect.ImmutableSet.<java.lang.String>of()); if (!(id.contains("~"))) { return asChangeControls(query.byKeyPrefix(id)); } com.google.common.base.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id); if (triplet.isPresent()) { return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id())); } return java.util.Collections.emptyList(); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { try { com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(id, user.get()); if (!(ctl.isVisible(db.get()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return new com.google.gerrit.server.change.ChangeResource(ctl); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } }
public com.google.gerrit.reviewdb.client.Change reloadChange() throws com.google.gwtorm.server.OrmException { change = db.changes().get(legacyId); return change; }
@org.junit.Test public void subsetOfRefsVisibleWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); try { deny(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/master"); allow(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/branch"); com.google.gerrit.reviewdb.client.Change change1 = db.changes().get(c1); com.google.gerrit.reviewdb.client.PatchSet ps1 = getPatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(c1, 1)); setApiUser(admin); editModifier.createEdit(change1, ps1); setApiUser(user); editModifier.createEdit(change1, ps1); assertRefs(((r1) + "1"), ((r1) + "meta"), ((r2) + "1"), ((r2) + "meta"), "refs/heads/branch", "refs/tags/branch-tag", "refs/tags/master-tag", (("refs/users/00/1000000/edit-" + (c1.get())) + "/1"), (("refs/users/01/1000001/edit-" + (c1.get())) + "/1")); } finally { removeGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); } }


public com.google.gerrit.server.project.ChangeControl validateFor(com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = db.get().changes().get(changeId); if (change == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } return validateFor(change, user); }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeUtil.findChanges(id.encoded(), user.get()); if (ctls.isEmpty()) { java.lang.Integer changeId = com.google.common.primitives.Ints.tryParse(id.get()); if (changeId != null) { try { changeIndexer.delete(new com.google.gerrit.reviewdb.client.Change.Id(changeId)); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id.get(), e); } } } if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(ctl.isVisible(db.get()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.change.ChangeResource(ctl); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeUtil.findChanges(id, user.get()); if (ctls.isEmpty()) { try { changeIndexer.delete(id); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id).get(), e); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(ctl.isVisible(db.get()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return new com.google.gerrit.server.change.ChangeResource(ctl); }
public com.google.gerrit.server.notedb.ChangeNotes create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeNotes(db, repoManager, migration, allUsersProvider, change).load(); }
protected com.google.gerrit.reviewdb.client.Change newChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId()); com.google.gerrit.server.notedb.ChangeUpdate u = newUpdate(c, changeOwner); u.setChangeId(c.getKey().get()); u.setBranch(c.getDest().get()); u.commit(); return c; }
private void addChangeImpl(java.lang.String id) throws com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> matched = changeUtil.findChanges(id, userProvider.get()); java.util.List<com.google.gerrit.server.project.ChangeControl> toAdd = new java.util.ArrayList(changes.size()); for (com.google.gerrit.server.project.ChangeControl ctl : matched) { if (((!(changes.containsKey(ctl.getId()))) && (inProject(ctl.getProject()))) && (ctl.isVisible(db))) { toAdd.add(ctl); } } switch (toAdd.size()) { case 0 : throw com.google.gerrit.sshd.commands.SetReviewersCommand.error((("\"" + id) + "\" no such change")); case 1 : com.google.gerrit.server.project.ChangeControl ctl = toAdd.get(0); changes.put(ctl.getId(), changesCollection.parse(ctl)); break; default : throw com.google.gerrit.sshd.commands.SetReviewersCommand.error((("\"" + id) + "\" matches multiple changes")); } }
public com.google.gerrit.reviewdb.client.PatchSet getCurrentPatchSet() { com.google.gerrit.reviewdb.client.PatchSet.Id psId = change.currentPatchSetId(); return checkNotNull(patchSets.get(psId), "missing current patch set %s", psId.get()); }
@com.google.common.annotations.VisibleForTesting java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> byCommitsOnBranchNotMerged(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Branch.NameKey branch, java.util.List<java.lang.String> hashes, int indexLimit) throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((hashes.size()) > indexLimit) { return byCommitsOnBranchNotMergedFromDatabase(repo, db, branch, hashes); } else { return byCommitsOnBranchNotMergedFromIndex(branch, hashes); } }


private com.google.gerrit.server.change.ReviewerJson.PostResult putAccount(com.google.gerrit.server.change.ReviewerResource rsrc) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser().getAccount(); com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl(); com.google.gerrit.server.change.ReviewerJson.PostResult result = new com.google.gerrit.server.change.ReviewerJson.PostResult(); if (isValidReviewer(member, control)) { addReviewers(rsrc.getChangeResource(), result, com.google.common.collect.ImmutableMap.of(member.getId(), control)); } return result; }
private void addReviewers(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ReviewerJson.PostResult result, java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.project.ChangeControl> reviewers) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create(rsrc.getControl()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> added; db.changes().beginTransaction(rsrc.getId()); try { com.google.gerrit.server.ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getId(), db); added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet()); db.commit(); } finally { db.rollback(); } update.commit(); com.google.common.util.concurrent.CheckedFuture<?, java.io.IOException> indexFuture = indexer.indexAsync(rsrc.getId()); result.reviewers = com.google.common.collect.Lists.newArrayListWithCapacity(added.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { result.reviewers.add(json.format(new com.google.gerrit.server.change.ReviewerJson.ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), com.google.common.collect.ImmutableList.of(psa))); } accountLoaderFactory.create(true).fill(result.reviewers); indexFuture.checkedGet(); emailReviewers(rsrc.getChange(), added); if (!(added.isEmpty())) { com.google.gerrit.reviewdb.client.PatchSet patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(psa.getAccountId()).getAccount(); hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get()); } } }


@java.lang.Override protected java.lang.Void impl(com.google.gerrit.server.util.RequestContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getReviewDbProvider().get(); com.google.gerrit.reviewdb.client.Change c = db.changes().get(id); indexerFactory.create(executor, indexes).index(db, c); return null; }
public static org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> cloneProject(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String uri) throws java.lang.Exception { org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription desc = new org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription(("clone of " + (project.get()))); org.eclipse.jgit.internal.storage.dfs.InMemoryRepository dest = new org.eclipse.jgit.internal.storage.dfs.InMemoryRepository.Builder().setRepositoryDescription(desc).setFS(org.eclipse.jgit.util.FS.detect()).build(); org.eclipse.jgit.lib.Config cfg = dest.getConfig(); cfg.setString("remote", "origin", "url", uri); cfg.setString("remote", "origin", "fetch", "+refs/heads/*:refs/remotes/origin/*"); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> testRepo = com.google.gerrit.acceptance.GitUtil.newTestRepository(dest); org.eclipse.jgit.transport.FetchResult result = testRepo.git().fetch().setRemote("origin").call(); java.lang.String originMaster = "refs/remotes/origin/master"; if ((result.getTrackingRefUpdate(originMaster)) != null) { testRepo.reset(originMaster); } return testRepo; }
@java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser() { throw new com.google.inject.OutOfScopeException("No user on email thread"); }

private com.google.gerrit.server.query.change.ChangeData toChangeData(org.apache.lucene.document.Document doc, java.util.Set<java.lang.String> fields, java.lang.String idFieldName) { com.google.gerrit.server.query.change.ChangeData cd; org.apache.lucene.util.BytesRef cb = doc.getBinaryValue(com.google.gerrit.lucene.LuceneChangeIndex.CHANGE_FIELD); if (cb != null) { cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length)); } else { int id = doc.getField(idFieldName).numericValue().intValue(); com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(doc.getField(com.google.gerrit.lucene.PROJECT.getName()).stringValue()); cd = changeDataFactory.create(db.get(), project, new com.google.gerrit.reviewdb.client.Change.Id(id)); } if (fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.PATCH_SET_FIELD)) { decodePatchSets(doc, cd); } if (fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.APPROVAL_FIELD)) { decodeApprovals(doc, cd); } if ((fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.ADDED_FIELD)) && (fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.DELETED_FIELD))) { decodeChangedLines(doc, cd); } if (fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.MERGEABLE_FIELD)) { decodeMergeable(doc, cd); } if (fields.contains(com.google.gerrit.lucene.LuceneChangeIndex.REVIEWEDBY_FIELD)) { decodeReviewedBy(doc, cd); } return cd; }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.DOC_SERVLET) javax.servlet.http.HttpServlet getDocServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) { HEAD(685); com.google.gerrit.httpd.raw.b5b Merge; }
@java.lang.Override public void registerKeys() { super.registerKeys(); net.codemirror.lib.KeyMap localKeyMap = net.codemirror.lib.KeyMap.create(); localKeyMap.on("Ctrl-L", gotoLine()).on("Cmd-L", gotoLine()).on("Cmd-S", save()); if ((prefs.keyMapType()) != (com.google.gerrit.extensions.client.KeyMapType.EMACS)) { localKeyMap.on("Ctrl-S", save()); } cm.addKeyMap(localKeyMap); }
private com.google.gerrit.reviewdb.client.ChangeMessage message(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.git.strategy.CommitMergeStatus s) { java.lang.String txt = s.getMessage(); if (s == (CommitMergeStatus.CLEAN_MERGE)) { return message(ctx, commit.getPatchsetId(), (txt + (getByAccountName()))); } else if ((s == (CommitMergeStatus.CLEAN_REBASE)) || (s == (CommitMergeStatus.CLEAN_PICK))) { return message(ctx, commit.getPatchsetId(), (((txt + " as ") + (commit.name())) + (getByAccountName()))); } else if (s == (CommitMergeStatus.SKIPPED_IDENTICAL_TREE)) { return message(ctx, commit.getPatchsetId(), txt); } else if (s == (CommitMergeStatus.ALREADY_MERGED)) { switch (args.submitType) { case FAST_FORWARD_ONLY : case MERGE_ALWAYS : case MERGE_IF_NECESSARY : return message(ctx, commit, CommitMergeStatus.CLEAN_MERGE); case CHERRY_PICK : return message(ctx, commit, CommitMergeStatus.CLEAN_PICK); case REBASE_IF_NECESSARY : return message(ctx, commit, CommitMergeStatus.CLEAN_REBASE); default : return message(ctx, commit, null); } } else { throw new java.lang.IllegalStateException((((("unexpected status " + s) + " for change ") + (commit.change().getId())) + "; expected to previously fail fast")); } }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.reviewdb.client.PatchSet.Id psId = change.currentPatchSetId(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(psId); if (((change) == null) || (!(change.getStatus().isOpen()))) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.change.Abandon.status(change)))); } else if ((change.getStatus()) == (Change.Status.DRAFT)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("draft changes cannot be abandoned"); } patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); change.setStatus(Change.Status.ABANDONED); change.setLastUpdatedOn(ctx.getWhen()); ctx.saveChange(); update.setStatus(change.getStatus()); message = newMessage(ctx.getDb()); cmUtil.addChangeMessage(ctx.getDb(), update, message); return true; }
public com.google.gerrit.reviewdb.client.Change getChange() { return ctl.getChange(); }

private com.google.gerrit.server.patch.PatchListEntry newEntry(org.eclipse.jgit.revwalk.RevTree aTree, org.eclipse.jgit.patch.FileHeader fileHeader, long sizeDelta) { final org.eclipse.jgit.lib.FileMode oldMode = fileHeader.getOldMode(); final org.eclipse.jgit.lib.FileMode newMode = fileHeader.getNewMode(); if ((oldMode == (org.eclipse.jgit.lib.FileMode.GITLINK)) || (newMode == (org.eclipse.jgit.lib.FileMode.GITLINK))) { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList(), sizeDelta); } if (((aTree == null) || ((fileHeader.getPatchType()) != (org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED))) || (fileHeader.getHunks().isEmpty())) { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList(), sizeDelta); } java.util.List<org.eclipse.jgit.diff.Edit> edits = fileHeader.toEditList(); if (edits.isEmpty()) { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList(), sizeDelta); } else { return new com.google.gerrit.server.patch.PatchListEntry(fileHeader, edits, sizeDelta); } }

@org.junit.Test public void patchSetObjectAndRefMissingWithDeletingPatchSet() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = insertChange(); com.google.gerrit.reviewdb.client.PatchSet ps1 = insertPatchSet(c); incrementPatchSet(c); com.google.gerrit.reviewdb.client.PatchSet ps2 = insertMissingPatchSet(c, "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); com.google.gerrit.extensions.api.changes.FixInput fix = new com.google.gerrit.extensions.api.changes.FixInput(); fix.deletePatchSetIfCommitMissing = true; java.util.List<com.google.gerrit.extensions.common.ProblemInfo> problems = checker.check(c, fix).problems(); assertThat(problems).hasSize(2); com.google.gerrit.extensions.common.ProblemInfo p = problems.get(0); assertThat(p.message).isEqualTo(("Ref missing: " + (ps2.getId().toRefName()))); assertThat(p.status).isNull(); p = problems.get(1); assertThat(p.message).isEqualTo("Object missing: patch set 2: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); assertThat(p.status).isEqualTo(ProblemInfo.Status.FIXED); assertThat(p.outcome).isEqualTo("Deleted patch set"); c = notesFactory.create(db, project, c.getId()).getChange(); assertThat(c.currentPatchSetId().get()).isEqualTo(1); assertThat(getPatchSet(ps1.getId())).isNotNull(); assertThat(getPatchSet(ps2.getId())).isNull(); }
@org.junit.Test public void onlyPatchSetObjectMissingWithFix() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = insertChange(); com.google.gerrit.reviewdb.client.PatchSet ps1 = insertMissingPatchSet(c, "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); com.google.gerrit.extensions.api.changes.FixInput fix = new com.google.gerrit.extensions.api.changes.FixInput(); fix.deletePatchSetIfCommitMissing = true; java.util.List<com.google.gerrit.extensions.common.ProblemInfo> problems = checker.check(c, fix).problems(); assertThat(problems).hasSize(2); com.google.gerrit.extensions.common.ProblemInfo p = problems.get(0); assertThat(p.message).isEqualTo(("Ref missing: " + (ps1.getId().toRefName()))); assertThat(p.status).isNull(); p = problems.get(1); assertThat(p.message).isEqualTo("Object missing: patch set 1: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); assertThat(p.status).isEqualTo(ProblemInfo.Status.FIX_FAILED); assertThat(p.outcome).isEqualTo("Cannot delete patch set; no patch sets would remain"); c = notesFactory.create(db, project, c.getId()).getChange(); assertThat(c.currentPatchSetId().get()).isEqualTo(1); assertThat(getPatchSet(ps1.getId())).isNotNull(); }
@org.junit.Test public void subsetOfRefsVisibleWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); try { deny(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/master"); allow(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/branch"); com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create(db, project, c1); com.google.gerrit.reviewdb.client.PatchSet ps1 = getPatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(c1, 1)); setApiUser(admin); editModifier.createEdit(notes.getChange(), ps1); setApiUser(user); editModifier.createEdit(notes.getChange(), ps1); assertRefs(((r1) + "1"), ((r1) + "meta"), ((r2) + "1"), ((r2) + "meta"), "refs/heads/branch", "refs/tags/branch-tag", "refs/tags/master-tag", (("refs/users/00/1000000/edit-" + (c1.get())) + "/1"), (("refs/users/01/1000001/edit-" + (c1.get())) + "/1")); } finally { removeGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); } }
private com.google.gerrit.reviewdb.client.PatchSetApproval getSubmitter(com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create(db, project, patchSetId.getParentKey()).load(); return approvalsUtil.getSubmitter(db, notes, patchSetId); }
protected void assertSubmitter(java.lang.String changeId, int psId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change(); com.google.gerrit.server.notedb.ChangeNotes cn = notesFactory.create(db, c.getProject(), c.getId()); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new com.google.gerrit.reviewdb.client.PatchSet.Id(cn.getChangeId(), psId)); assertThat(submitter).isNotNull(); assertThat(submitter.isSubmit()).isTrue(); assertThat(submitter.getAccountId()).isEqualTo(admin.getId()); }
protected void assertNoSubmitter(java.lang.String changeId, int psId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change(); com.google.gerrit.server.notedb.ChangeNotes cn = notesFactory.create(db, c.getProject(), c.getId()); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new com.google.gerrit.reviewdb.client.PatchSet.Id(cn.getChangeId(), psId)); assertThat(submitter).isNull(); }
public com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes notes; try { notes = changeNotesFactory.create(db.get(), project, id); } catch (com.google.gwtorm.server.OrmException e) { if (!(has(com.google.gerrit.server.change.CHECK))) { throw e; } return checkOnly(changeDataFactory.create(db.get(), project, id)); } return format(changeDataFactory.create(db.get(), notes.getChange())); }
public com.google.gerrit.server.project.ChangeControl validateFor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = changeFinder.findOne(changeId, user); return validateFor(db, ctl.getChange(), user); }
private void assertReviewers(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.acceptance.TestAccount... expectedReviewers) throws com.google.gwtorm.server.OrmException { java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.create(db, c.getProject(), c.getId())).values(); assertThat(actualIds).containsExactlyElementsIn(com.google.common.collect.Sets.newHashSet(com.google.gerrit.acceptance.TestAccount.ids(expectedReviewers))); }
@org.junit.Test public void newChangeIsMergedWithFix() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = insertChange(); org.eclipse.jgit.revwalk.RevCommit commit = testRepo.branch(c.currentPatchSetId().toRefName()).commit().parent(tip).create(); com.google.gerrit.reviewdb.client.PatchSet ps = newPatchSet(c.currentPatchSetId(), commit, adminId); db.patchSets().insert(java.util.Collections.singleton(ps)); testRepo.branch(c.getDest().get()).update(commit); java.util.List<com.google.gerrit.extensions.common.ProblemInfo> problems = checker.check(c, new com.google.gerrit.extensions.api.changes.FixInput()).problems(); assertThat(problems).hasSize(1); com.google.gerrit.extensions.common.ProblemInfo p = problems.get(0); assertThat(p.message).isEqualTo(((((("Patch set 1 (" + (commit.name())) + ") is merged into destination ref") + " refs/heads/master (") + (commit.name())) + "), but change status is NEW")); assertThat(p.status).isEqualTo(ProblemInfo.Status.FIXED); assertThat(p.outcome).isEqualTo("Marked change as merged"); c = notesFactory.create(db, project, c.getId()).getChange(); assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED); assertProblems(c); }
@org.junit.Test public void subsetOfBranchesVisibleWithEdit() throws java.lang.Exception { allow(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/master"); deny(Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS, "refs/heads/branch"); com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create(db, project, c1); com.google.gerrit.reviewdb.client.PatchSet ps1 = getPatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(c1, 1)); setApiUser(admin); editModifier.createEdit(notes.getChange(), ps1); setApiUser(user); editModifier.createEdit(notes.getChange(), ps1); assertRefs("HEAD", ((r1) + "1"), ((r1) + "meta"), "refs/heads/master", "refs/tags/master-tag", (("refs/users/01/1000001/edit-" + (c1.get())) + "/1")); }
protected java.util.List<com.google.gerrit.extensions.common.ChangeInfo> assertQuery(com.google.gerrit.extensions.api.changes.Changes.QueryRequest query, com.google.gerrit.reviewdb.client.Change... changes) throws java.lang.Exception { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> result = query.get(); java.lang.Iterable<java.lang.Integer> ids = com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids(result); assertThat(ids).named(query.getQuery()).containsExactlyElementsIn(com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids(changes)).inOrder(); return result; }

private void export(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.List<com.google.gerrit.reviewdb.client.Change> changes) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project)) { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes crn = reviewNotesFactory.create(db, project, git); crn.createNotes(changes, monitor); crn.commitNotes(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { stderr.println(("Unable to open project: " + (project.get()))); } catch (org.eclipse.jgit.api.errors.ConcurrentRefUpdateException e) { stderr.println(e.getMessage()); } }
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Change> setValue(java.util.List<com.google.gerrit.reviewdb.client.Change> value) { throw new java.lang.UnsupportedOperationException(); }
void createNotes(java.util.List<com.google.gerrit.reviewdb.client.Change> changes, org.eclipse.jgit.lib.ProgressMonitor monitor) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(git)) { if (monitor == null) { monitor = org.eclipse.jgit.lib.NullProgressMonitor.INSTANCE; } for (com.google.gerrit.reviewdb.client.Change c : changes) { monitor.update(1); com.google.gerrit.reviewdb.client.PatchSet ps = reviewDb.patchSets().get(c.currentPatchSetId()); org.eclipse.jgit.lib.ObjectId commitId = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(commitId); getNotes().set(commitId, createNoteContent(ps)); getMessage().append("* ").append(commit.getShortMessage()).append("\n"); } } }
private java.util.List<com.google.gerrit.reviewdb.client.Change> allChanges() { try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { return db.changes().all().toList(); } catch (com.google.gwtorm.server.OrmException e) { stderr.println(("Cannot read changes from database " + (e.getMessage()))); return java.util.Collections.emptyList(); } }
@java.lang.Override public void run() { try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { for (; ;) { java.util.Map.Entry<com.google.gerrit.reviewdb.client.Project.NameKey, java.util.List<com.google.gerrit.reviewdb.client.Change>> next = next(); if (next != null) { try { export(db, next.getKey(), next.getValue()); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { stderr.println(e.getMessage()); } } else { break; } } } catch (com.google.gwtorm.server.OrmException e) { stderr.println(e.getMessage()); } finally { monitor.endWorker(); } }
private java.util.Map.Entry<com.google.gerrit.reviewdb.client.Project.NameKey, java.util.List<com.google.gerrit.reviewdb.client.Change>> next() { synchronized(changes) { if (changes.isEmpty()) { return null; } final com.google.gerrit.reviewdb.client.Project.NameKey name = changes.keySet().iterator().next(); final java.util.List<com.google.gerrit.reviewdb.client.Change> list = changes.remove(name); return new java.util.Map.Entry<com.google.gerrit.reviewdb.client.Project.NameKey, java.util.List<com.google.gerrit.reviewdb.client.Change>>() { @java.lang.Override public Project.NameKey getKey() { return name; } @java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Change> getValue() { return list; } @java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Change> setValue(java.util.List<com.google.gerrit.reviewdb.client.Change> value) { throw new java.lang.UnsupportedOperationException(); } }; } }
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Change> getValue() { return list; }
@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.reviewnotes.Failure, java.lang.InterruptedException { if ((threads) <= 0) { threads = 1; } java.util.List<com.google.gerrit.reviewdb.client.Change> allChangeList = allChanges(); monitor = new org.eclipse.jgit.lib.ThreadSafeProgressMonitor(new org.eclipse.jgit.lib.TextProgressMonitor(stdout)); monitor.beginTask("Scanning changes", allChangeList.size()); changes = cluster(allChangeList); allChangeList = null; monitor.startWorkers(threads); for (int tid = 0; tid < (threads); tid++) { new com.googlesource.gerrit.plugins.reviewnotes.ExportReviewNotes.Worker().start(); } monitor.waitForCompletion(); monitor.endTask(); }
public com.google.gerrit.server.git.CodeReviewCommit createCherryPickFromCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.revwalk.RevCommit mergeTip, org.eclipse.jgit.revwalk.RevCommit originalCommit, org.eclipse.jgit.lib.PersonIdent cherryPickCommitterIdent, java.lang.String commitMsg, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw) throws com.google.gerrit.extensions.restapi.MergeConflictException, com.google.gerrit.server.git.MergeIdenticalTreeException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { final org.eclipse.jgit.merge.ThreeWayMerger m = newThreeWayMerger(repo, inserter); m.setBase(originalCommit.getParent(0)); if (m.merge(mergeTip, originalCommit)) { org.eclipse.jgit.lib.ObjectId tree = m.getResultTreeId(); if (tree.equals(mergeTip.getTree())) { throw new com.google.gerrit.server.git.MergeIdenticalTreeException("identical tree"); } org.eclipse.jgit.lib.CommitBuilder mergeCommit = new org.eclipse.jgit.lib.CommitBuilder(); mergeCommit.setTreeId(tree); mergeCommit.setParentId(mergeTip); mergeCommit.setAuthor(originalCommit.getAuthorIdent()); mergeCommit.setCommitter(cherryPickCommitterIdent); mergeCommit.setMessage(commitMsg); return rw.parseCommit(commit(inserter, mergeCommit)); } else { throw new com.google.gerrit.extensions.restapi.MergeConflictException("merge conflict"); } }




private org.eclipse.jgit.lib.Ref findMergedInto(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, java.lang.String first, org.eclipse.jgit.revwalk.RevCommit commit) { try { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = ctx.getRepository().getRefDatabase().getRefs(com.google.gerrit.server.git.ALL); org.eclipse.jgit.lib.Ref firstRef = all.get(first); if ((firstRef != null) && (com.google.gerrit.server.git.ReplaceOp.isMergedInto(ctx.getRevWalk(), commit, firstRef))) { return firstRef; } for (org.eclipse.jgit.lib.Ref ref : all.values()) { if (com.google.gerrit.server.git.ReplaceOp.isBranch(ref)) { if (com.google.gerrit.server.git.ReplaceOp.isMergedInto(ctx.getRevWalk(), commit, ref)) { return ref; } } } return null; } catch (java.io.IOException e) { com.google.gerrit.server.git.ReplaceOp.log.warn("Can't check for already submitted change", e); return null; } }


@java.lang.Override public org.eclipse.jgit.lib.Config getConfig() throws java.io.IOException { return new org.eclipse.jgit.lib.Config(); }
private void abandonAllOpenChanges(com.google.gerrit.reviewdb.client.Project.NameKey destProject) { try { for (com.google.gerrit.server.query.change.ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) { abandonOneChange(cd.change()); } } catch (com.google.gerrit.server.project.NoSuchChangeException | java.io.IOException | com.google.gwtorm.server.OrmException e) { logWarn(("Cannot abandon changes for deleted project " + destProject), e); } }
@org.junit.Test public void setParent() throws java.lang.Exception { java.lang.String parent = "parent"; com.google.gerrit.acceptance.GitUtil.createProject(sshSession, parent, null, true); com.google.gerrit.acceptance.RestResponse r = adminSession.put((("/projects/" + (project.get())) + "/parent"), newParentInput(parent)); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); r.consume(); r = adminSession.get((("/projects/" + (project.get())) + "/parent")); assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK); java.lang.String newParent = newGson().fromJson(r.getReader(), java.lang.String.class); assertThat(newParent).isEqualTo(parent); r.consume(); }
@java.lang.Override public com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to administrator"); } com.google.gerrit.reviewdb.client.Account.Id accountId = rsrc.getUser().getAccountId(); return readFromGit ? com.google.gerrit.server.account.GetPreferences.readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId); }
@java.lang.Override public com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to members of Modify Accounts"); } checkDownloadScheme(i); com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo n = (readFromGit) ? com.google.gerrit.server.account.GetPreferences.readFromGit(id, gitMgr, allUsersName, i) : merge(com.google.gerrit.server.account.GetPreferences.initFromDb(db.get().accounts().get(id).getGeneralPreferences()), i); n.my = i.my; n.urlAliases = i.urlAliases; writeToGit(id, n); writeToDb(id, n); return com.google.gerrit.server.account.GetPreferences.readFromGit(id, gitMgr, allUsersName, null); }
private void display(com.google.gerrit.client.info.AccountPreferencesInfo p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); copySelfOnEmails.setValue(p.copySelfOnEmail()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, AccountGeneralPreferencesInfo.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, AccountGeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes()); setListBox(reviewCategoryStrategy, AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(diffView, AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView()); display(p.my()); }
private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); copySelfOnEmails.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); sizeBarInChangeTable.setEnabled(on); legacycidInChangeTable.setEnabled(on); muteCommonPathPrefixes.setEnabled(on); reviewCategoryStrategy.setEnabled(on); diffView.setEnabled(on); }
public static com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo defaults() { com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo p = new com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo(); p.changesPerPage = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.DEFAULT_PAGESIZE; p.showSiteHeader = true; p.useFlashClipboard = true; p.copySelfOnEmail = false; p.reviewCategoryStrategy = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NONE; p.downloadScheme = null; p.downloadCommand = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.DownloadCommand.CHECKOUT; p.dateFormat = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.DateFormat.STD; p.timeFormat = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.TimeFormat.HHMM_12; p.relativeDateInChangeTable = false; p.diffView = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE; p.sizeBarInChangeTable = true; p.legacycidInChangeTable = false; p.muteCommonPathPrefixes = true; return p; }
public static com.google.gerrit.client.info.AccountPreferencesInfo createDefault() { com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo d = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.defaults(); com.google.gerrit.client.info.AccountPreferencesInfo p = createObject().cast(); p.changesPerPage(d.changesPerPage); p.showSiteHeader(d.showSiteHeader); p.useFlashClipboard(d.useFlashClipboard); p.downloadScheme(d.downloadScheme); p.downloadCommand(d.downloadCommand); p.copySelfOnEmail(d.copySelfOnEmail); p.dateFormat(d.getDateFormat()); p.timeFormat(d.getTimeFormat()); p.relativeDateInChangeTable(d.relativeDateInChangeTable); p.sizeBarInChangeTable(d.sizeBarInChangeTable); p.legacycidInChangeTable(d.legacycidInChangeTable); p.muteCommonPathPrefixes(d.muteCommonPathPrefixes); p.reviewCategoryStrategy(d.getReviewCategoryStrategy()); p.diffView(d.getDiffView()); return p; }
@org.junit.Test public void getPreferences() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.get((("/accounts/" + (admin.email)) + "/preferences")); assertEquals(HttpStatus.SC_OK, r.getStatusCode()); com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo d = com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.defaults(); com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo o = newGson().fromJson(r.getReader(), com.google.gerrit.extensions.client.AccountGeneralPreferencesInfo.class); assertThat(o.changesPerPage).isEqualTo(d.changesPerPage); assertThat(o.showSiteHeader).isEqualTo(d.showSiteHeader); assertThat(o.useFlashClipboard).isEqualTo(d.useFlashClipboard); assertThat(o.downloadScheme).isNull(); assertThat(o.copySelfOnEmail).isNull(); assertThat(o.downloadCommand).isEqualTo(d.downloadCommand); assertThat(o.dateFormat).isEqualTo(d.getDateFormat()); assertThat(o.timeFormat).isEqualTo(d.getTimeFormat()); assertThat(o.relativeDateInChangeTable).isNull(); assertThat(o.sizeBarInChangeTable).isEqualTo(d.sizeBarInChangeTable); assertThat(o.legacycidInChangeTable).isNull(); assertThat(o.muteCommonPathPrefixes).isEqualTo(d.muteCommonPathPrefixes); assertThat(o.reviewCategoryStrategy).isEqualTo(d.getReviewCategoryStrategy()); assertThat(o.diffView).isEqualTo(d.getDiffView()); assertThat(o.my).hasSize(7); assertThat(o.urlAliases).hasSize(1); }

public java.util.List<com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult> doQuery(java.lang.String q) throws com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException { if (!(isAvailable())) { throw new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException("Documentation search not available"); } try { org.apache.lucene.search.Query query = parser.parse(q); org.apache.lucene.search.TopDocs results = searcher.search(query, java.lang.Integer.MAX_VALUE); org.apache.lucene.search.ScoreDoc[] hits = results.scoreDocs; int totalHits = results.totalHits; java.util.List<com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult> out = com.google.common.collect.Lists.newArrayListWithCapacity(totalHits); for (int i = 0; i < totalHits; i++) { com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult result = new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult(); org.apache.lucene.document.Document doc = searcher.doc(hits[i].doc); result.url = doc.get(Constants.URL_FIELD); result.title = doc.get(Constants.TITLE_FIELD); out.add(result); } return out; } catch (java.io.IOException | org.apache.lucene.queryparser.classic.ParseException e) { throw new com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException(e); } }
@org.junit.Test public void updatedOrderWithMinuteResolution() throws java.lang.Exception { com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(2, java.util.concurrent.TimeUnit.MINUTES); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, ins1); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isLessThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertQuery("status:new", change2, change1); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput()); change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange(); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isGreaterThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertThat(((com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)) - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)))).isGreaterThan(java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.MINUTES)); assertQuery("status:new", change1, change2); }
@org.junit.Before public void setTimeForTesting() { systemTimeZone = java.lang.System.setProperty("user.timezone", "US/Eastern"); com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.MILLISECONDS); }

@org.junit.Test public void updatedOrderWithSubMinuteResolution() throws java.lang.Exception { com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.server.change.ChangeInserter ins1 = newChange(repo); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, ins1); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isLessThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertQuery("status:new", change2, change1); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput()); change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange(); assertThat(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)).isGreaterThan(com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)); assertThat(((com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change1)) - (com.google.gerrit.server.query.change.AbstractQueryChangesTest.lastUpdatedMs(change2)))).isLessThan(java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.MINUTES)); assertQuery("status:new", change1, change2); }
private java.lang.String problemsForSubmittingChangeset(com.google.gerrit.server.git.ChangeSet cs, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser identifiedUser) { try { @java.lang.SuppressWarnings("resource") com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); for (com.google.gerrit.reviewdb.client.PatchSet.Id psId : cs.patchIds()) { com.google.gerrit.server.project.ChangeControl changeControl = changeControlFactory.controlFor(db, project, psId.getParentKey(), identifiedUser); com.google.gerrit.server.query.change.ChangeData c = changeDataFactory.create(db, changeControl); if (!(changeControl.isVisible(db))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_SUBMIT_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; } c.setMergeable(null); java.lang.Boolean mergeable = c.isMergeable(); if (mergeable == null) { com.google.gerrit.server.change.Submit.log.error("Ephemeral error checking if change is submittable"); return com.google.gerrit.server.change.Submit.CLICK_FAILURE_TOOLTIP; } if (!mergeable) { return com.google.gerrit.server.change.Submit.CLICK_FAILURE_OTHER_TOOLTIP; } com.google.gerrit.server.git.MergeOp.checkSubmitRule(c); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; } catch (com.google.gerrit.server.project.NoSuchChangeException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException("Could not determine problems for the change", e); } return null; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = change.currentPatchSetId(); com.google.gerrit.reviewdb.client.ChangeMessage changeMessage = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db.get())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId); java.lang.StringBuilder msgBuf = new java.lang.StringBuilder(); msgBuf.append("Patch Set ").append(patchSetId.get()).append(": Reverted"); msgBuf.append("\n\n"); msgBuf.append("This patchset was reverted in change: ").append("I").append(computedChangeId.name()); changeMessage.setMessage(msgBuf.toString()); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage); return true; }
@org.junit.Test public void revert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit(); ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get(); java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> sourceMessages = new java.util.ArrayList(gApi.changes().id(r.getChangeId()).get().messages); assertThat(sourceMessages).hasSize(4); java.lang.String expectedMessage = java.lang.String.format(("Patch Set 1: Reverted\n\n" + "This patchset was reverted in change: %s"), revertChange.changeId); assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage); assertThat(revertChange.messages).hasSize(1); assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1."); }

private void readChangesForReplace() throws com.google.gwtorm.server.OrmException { java.util.List<com.google.common.util.concurrent.CheckedFuture<com.google.gerrit.reviewdb.client.Change, com.google.gwtorm.server.OrmException>> futures = com.google.common.collect.Lists.newArrayListWithCapacity(replaceByChange.size()); for (com.google.gerrit.server.git.ReceiveCommits.ReplaceRequest request : replaceByChange.values()) { futures.add(db.changes().getAsync(request.ontoChange)); } for (com.google.common.util.concurrent.CheckedFuture<com.google.gerrit.reviewdb.client.Change, com.google.gwtorm.server.OrmException> f : futures) { com.google.gerrit.reviewdb.client.Change c = f.checkedGet(); if (c != null) { replaceByChange.get(c.getId()).change = c; } } }


@java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.Multimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.ArrayListMultimap.create(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.ALL); for (com.google.gerrit.server.notedb.ChangeNotes cn : com.google.gerrit.server.git.ScanningChangeCacheImpl.scan(notesMigration, notesFactory, repo, db, project)) { com.google.gerrit.reviewdb.client.Change c = cn.getChange(); org.eclipse.jgit.lib.Ref r = refs.get(c.currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, c)); } } new com.google.gerrit.server.index.SiteIndexer.ProjectIndexer(indexer, mergeStrategy, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.SiteIndexer.log.error(rnfe.getMessage()); } return null; }
@java.lang.Override public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> load(com.google.gerrit.reviewdb.client.Project.NameKey key) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(key);com.google.gerrit.server.util.ManualRequestContext ctx = requestContext.open()) { return com.google.gerrit.server.git.ScanningChangeCacheImpl.scan(notesMigration, notesFactory, repo, ctx.getReviewDbProvider().get(), key); } }
private com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Restored"); if (!(com.google.common.base.Strings.nullToEmpty(input.message).trim().isEmpty())) { msg.append("\n\n"); msg.append(input.message.trim()); } com.google.gerrit.reviewdb.client.ChangeMessage message = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), caller.getAccountId(), change.getLastUpdatedOn(), change.currentPatchSetId()); message.setMessage(msg.toString()); return message; }
private void parseReplaceCommand(final org.eclipse.jgit.transport.ReceiveCommand cmd, final com.google.gerrit.reviewdb.client.Change.Id changeId) { if ((cmd.getType()) != (ReceiveCommand.Type.CREATE)) { reject(cmd, "invalid usage"); return; } final org.eclipse.jgit.revwalk.RevCommit newCommit; try { newCommit = rp.getRevWalk().parseCommit(cmd.getNewId()); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.error((("Cannot parse " + (cmd.getNewId().name())) + " as commit"), e); reject(cmd, "invalid commit"); return; } final com.google.gerrit.reviewdb.client.Change changeEnt; try { changeEnt = notesFactory.create(db, project.getNameKey(), changeId).getChange(); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.ReceiveCommits.log.error(("Cannot lookup existing change " + changeId), e); reject(cmd, "database error"); return; } if (changeEnt == null) { reject(cmd, (("change " + changeId) + " not found")); return; } if (!(project.getNameKey().equals(changeEnt.getProject()))) { reject(cmd, ((("change " + changeId) + " does not belong to project ") + (project.getName()))); return; } requestReplace(cmd, true, changeEnt, newCommit); }
private <V, K> com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore<K, V> newSqlStore(java.lang.String name, com.google.inject.TypeLiteral<K> keyType, long maxSize, java.lang.Long expireAfterWrite) { java.lang.String url = "jdbc:h2:" + (cacheDir.resolve(name).toUri()); return new com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore(url, keyType, maxSize, (expireAfterWrite == null ? 0 : expireAfterWrite.longValue())); }
private void saveCookie() { if ((response) == null) { return; } final java.lang.String token; final int ageSeconds; if ((key) == null) { token = ""; ageSeconds = 0; } else { token = key.getToken(); ageSeconds = manager.getCookieAge(val); } java.lang.String path = authConfig.getCookiePath(); if ((path == null) || (path.isEmpty())) { path = request.getContextPath(); if ((path == null) || (path.isEmpty())) { path = "/"; } } if ((outCookie) != null) { throw new java.lang.IllegalStateException((("Cookie " + (com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE)) + " was set")); } outCookie = new javax.servlet.http.Cookie(com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE, token); outCookie.setSecure(com.google.gerrit.httpd.CacheBasedWebSession.isSecure(request)); outCookie.setPath(path); outCookie.setMaxAge(ageSeconds); outCookie.setSecure(authConfig.getCookieSecure()); response.addCookie(outCookie); }
@org.junit.Test public void multipleUpdatesInBatch() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update1 = newUpdate(c, changeOwner); update1.putApproval("Verified", ((short) (1))); com.google.gerrit.server.notedb.ChangeUpdate update2 = newUpdate(c, otherUser); update2.putApproval("Code-Review", ((short) (2))); com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch = update1.openUpdate(); try { update1.writeCommit(batch); update2.writeCommit(batch); batch.commit(); } finally { batch.close(); } com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertThat(psas).hasSize(2); assertThat(psas.get(0).getAccountId()).isEqualTo(changeOwner.getAccount().getId()); assertThat(psas.get(0).getLabel()).isEqualTo("Verified"); assertThat(psas.get(0).getValue()).isEqualTo(((short) (1))); assertThat(psas.get(1).getAccountId()).isEqualTo(otherUser.getAccount().getId()); assertThat(psas.get(1).getLabel()).isEqualTo("Code-Review"); assertThat(psas.get(1).getValue()).isEqualTo(((short) (2))); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (isEmpty()) { return false; } commit.setAuthor(newIdent(getUser().getAccount(), when)); commit.setCommitter(new org.eclipse.jgit.lib.PersonIdent(serverIdent, when)); commit.setMessage("Update draft comments"); return true; }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit commit(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException { throw new java.lang.UnsupportedOperationException("use commit()"); }
public void setInserter(org.eclipse.jgit.lib.ObjectInserter inserter) { this.inserter = inserter; }


@org.junit.Test public void multipleUpdatesAcrossRefs() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c1 = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update1 = newUpdate(c1, changeOwner); update1.putApproval("Verified", ((short) (1))); com.google.gerrit.reviewdb.client.Change c2 = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update2 = newUpdate(c2, otherUser); update2.putApproval("Code-Review", ((short) (2))); com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch1 = null; com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch2 = null; org.eclipse.jgit.lib.BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate(); try { batch1 = update1.openUpdateInBatch(bru); update1.writeCommit(batch1); batch1.commit(); assertThat(repo.exactRef(update1.getRefName())).isNotNull(); batch2 = update2.openUpdateInBatch(bru); update2.writeCommit(batch2); batch2.commit(); assertThat(repo.exactRef(update2.getRefName())).isNotNull(); } finally { if (batch1 != null) { batch1.close(); } if (batch2 != null) { batch2.close(); } } java.util.List<org.eclipse.jgit.transport.ReceiveCommand> cmds = bru.getCommands(); assertThat(cmds).hasSize(2); assertThat(cmds.get(0).getRefName()).isEqualTo(update1.getRefName()); assertThat(cmds.get(1).getRefName()).isEqualTo(update2.getRefName()); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { bru.execute(rw, NullProgressMonitor.INSTANCE); } assertThat(cmds.get(0).getResult()).isEqualTo(ReceiveCommand.Result.OK); assertThat(cmds.get(1).getResult()).isEqualTo(ReceiveCommand.Result.OK); assertThat(repo.exactRef(update1.getRefName())).isNotNull(); assertThat(repo.exactRef(update2.getRefName())).isNotNull(); }

private java.util.List<com.google.gerrit.server.notedb.ChangeRebuilder.HashtagsEvent> getHashtagsEvents(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.notedb.NoteDbUpdateManager manager) throws java.io.IOException { java.lang.String refName = com.google.gerrit.server.notedb.ChangeNoteUtil.changeRefName(change.getId()); org.eclipse.jgit.lib.ObjectId old = manager.getChangeCommands().getObjectId(manager.getChangeRepo(), refName); if (old == null) { return java.util.Collections.emptyList(); } org.eclipse.jgit.revwalk.RevWalk rw = manager.getChangeRevWalk(); java.util.List<com.google.gerrit.server.notedb.ChangeRebuilder.HashtagsEvent> events = new java.util.ArrayList<>(); rw.reset(); rw.markStart(rw.parseCommit(old)); for (org.eclipse.jgit.revwalk.RevCommit commit : rw) { com.google.gerrit.reviewdb.client.Account.Id authorId = com.google.gerrit.server.notedb.ChangeNoteUtil.parseIdent(commit.getAuthorIdent()); com.google.gerrit.reviewdb.client.PatchSet.Id psId = parsePatchSetId(change, commit); java.util.Set<java.lang.String> hashtags = parseHashtags(commit); if (((authorId == null) || (psId == null)) || (hashtags == null)) { continue; } java.sql.Timestamp commitTime = new java.sql.Timestamp(commit.getCommitterIdent().getWhen().getTime()); events.add(new com.google.gerrit.server.notedb.ChangeRebuilder.HashtagsEvent(psId, authorId, commitTime, hashtags)); } return events; }
org.eclipse.jgit.revwalk.RevWalk getChangeRevWalk() throws java.io.IOException { initChangeRepo(); return changeRepo.rw; }
private void initChangeRepo() throws java.io.IOException { if ((changeRepo) == null) { checkState((!(changeUpdates.isEmpty()))); changeRepo = openRepo(changeUpdates.values().iterator().next().getProjectName()); } }
org.eclipse.jgit.lib.Repository getChangeRepo() throws java.io.IOException { initChangeRepo(); return changeRepo.repo; }
com.google.gerrit.server.git.ChainedReceiveCommands getChangeCommands() throws java.io.IOException { initChangeRepo(); return changeRepo.cmds; }
public void execute() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return; } try { initChangeRepo(); if (!(draftUpdates.isEmpty())) { initAllUsersRepo(); } addCommands(); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(allUsersRepo); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(changeRepo); } finally { if ((allUsersRepo) != null) { allUsersRepo.close(); } if ((changeRepo) != null) { changeRepo.close(); } } }



public com.google.gerrit.server.notedb.ChangeNotes createForNew(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, change.getProject(), change).load(); }
private Account.Id parseIdent(org.eclipse.jgit.revwalk.RevCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { return parseIdent(commit.getAuthorIdent()); }
private static com.google.gerrit.server.project.ChangeControl stubChangeControl(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.notedb.NotesMigration migration, com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.config.AllUsersName allUsers, com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = org.easymock.EasyMock.createMock(com.google.gerrit.server.project.ChangeControl.class); expect(ctl.getChange()).andStubReturn(c); expect(ctl.getProject()).andStubReturn(new com.google.gerrit.reviewdb.client.Project(c.getProject())); expect(ctl.getUser()).andStubReturn(user); com.google.gerrit.server.notedb.ChangeNotes notes = new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, c.getProject(), c).load(); expect(ctl.getNotes()).andStubReturn(notes); expect(ctl.getId()).andStubReturn(c.getId()); org.easymock.EasyMock.replay(ctl); return ctl; }
public com.google.gerrit.server.notedb.ChangeNotes createFromIdOnlyWhenNotedbDisabled(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { checkState((!(migration.readChanges())), ("do not call" + " createFromIdOnlyWhenNotedbDisabled when notedb is enabled")); com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, change.getProject(), change).load(); }
public com.google.gerrit.server.notedb.ChangeNotes create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, project, change).load(); }
public com.google.gerrit.server.notedb.ChangeNotes createFromChangeOnlyWhenNotedbDisabled(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { checkState((!(migration.readChanges())), ("do not call" + " createFromChangeWhenNotedbDisabled when notedb is enabled")); return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, change.getProject(), change).load(); }
public com.google.gerrit.server.notedb.ChangeNotes createFromIndexedChange(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, migration, allUsers, change.getProject(), change); }

protected com.google.gerrit.server.notedb.ChangeNotes newNotes(com.google.gerrit.reviewdb.client.Change c) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeNotes(repoManager, com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION, allUsers, c.getProject(), c).load(); }
private com.google.gerrit.server.notedb.ChangeNotesParser newParser(org.eclipse.jgit.lib.ObjectId tip) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); return new com.google.gerrit.server.notedb.ChangeNotesParser(c.getProject(), c.getId(), tip, walk, repoManager); }
public org.eclipse.jgit.revwalk.RevCommit commit() throws java.io.IOException { com.google.gerrit.server.notedb.BatchMetaDataUpdate batch = openUpdate(); try { writeCommit(batch); org.eclipse.jgit.revwalk.RevCommit c = batch.commit(); return c; } catch (com.google.gwtorm.server.OrmException e) { throw new java.io.IOException(e); } finally { batch.close(); } }
private java.lang.String replaceInUrl(java.lang.String url, java.lang.String replacement) { if (((replacement == null) || (url == null)) || ((url.contains(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.USER_PLACEHOLDER)) == false)) { return url; } return url.replace(com.googlesource.gerrit.plugins.avatars.external.ExternalUrlAvatarProvider.USER_PLACEHOLDER, com.google.gerrit.extensions.restapi.Url.encode(replacement)); }
@java.lang.Override public void postEvent(final com.google.gerrit.reviewdb.client.Branch.NameKey branchName, final com.google.gerrit.server.events.Event event) { fireEvent(branchName, event); }
@java.lang.Override public void postEvent(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.server.events.Event event, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { fireEvent(change, event, db); }
private void fireEvent(com.google.gerrit.reviewdb.client.Branch.NameKey branchName, final com.google.gerrit.server.events.Event event) { dispatcher.fireEvent(branchName, event); }



public void postEvent(com.google.gerrit.reviewdb.client.Branch.NameKey branchName, com.google.gerrit.server.events.Event event);
@java.lang.Override public java.lang.String getChangeAvatarUrl(com.google.gerrit.server.IdentifiedUser forUser) { return "http://www.gravatar.com"; }
protected void changeStatus(com.google.gerrit.reviewdb.client.Change change, com.googlesource.gerrit.plugins.wip.BaseAction.Input input, final com.google.gerrit.reviewdb.client.Change.Status from, final com.google.gerrit.reviewdb.client.Change.Status to) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.reviewdb.client.Change.Id changeId = change.getId(); db.changes().beginTransaction(changeId); try { change = db.changes().atomicUpdate(changeId, new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if ((change.getStatus()) == from) { change.setStatus(to); com.google.gerrit.server.ChangeUtil.updated(change); return change; } return null; } }); if (change == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.googlesource.gerrit.plugins.wip.BaseAction.status(db.changes().get(changeId))))); } db.changeMessages().insert(java.util.Collections.singleton(newMessage(input, change))); db.commit(); } finally { db.rollback(); } indexer.index(db, change); }
@java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if ((change.getStatus()) == from) { change.setStatus(to); com.google.gerrit.server.ChangeUtil.updated(change); return change; } return null; }
@java.lang.Override protected void configure() { get(com.googlesource.gerrit.plugins.reviewers.PROJECT_KIND, "reviewers").to(com.googlesource.gerrit.plugins.reviewers.GetReviewers.class); put(com.googlesource.gerrit.plugins.reviewers.PROJECT_KIND, "reviewers").to(com.googlesource.gerrit.plugins.reviewers.PutReviewers.class); }
@java.lang.Override protected void configure() { if (ui) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.reviewers.ReviewersTopMenu.class); } com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.class); factory(DefaultReviewers.Factory.class); factory(ReviewersConfig.Factory.class); install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { get(com.googlesource.gerrit.plugins.reviewers.PROJECT_KIND, "reviewers").to(com.googlesource.gerrit.plugins.reviewers.GetReviewers.class); put(com.googlesource.gerrit.plugins.reviewers.PROJECT_KIND, "reviewers").to(com.googlesource.gerrit.plugins.reviewers.PutReviewers.class); } }); }
@org.junit.Test public void changeFields() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); gApi.changes().id(id.get()).topic(name("a-topic")); com.google.gerrit.reviewdb.client.Change old = db.changes().get(id); rebuild(id); com.google.gerrit.acceptance.server.notedb.ChangeRebuilderIT.assertChangeEqual(old, notesFactory.create(db, project, id).getChange()); }
public void checkChanges(java.lang.Iterable<com.google.gerrit.reviewdb.client.Change.Id> changeIds) throws java.lang.Exception { com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(); notesMigration.setReadChanges(false); java.util.List<com.google.gerrit.server.notedb.ChangeBundle> allExpected = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.Change.Id id : changeIds) { allExpected.add(com.google.gerrit.server.notedb.ChangeBundle.fromReviewDb(db, id)); } java.util.Collections.sort(allExpected, com.google.common.collect.Ordering.natural().onResultOf(new com.google.common.base.Function<com.google.gerrit.server.notedb.ChangeBundle, java.lang.Integer>() { @java.lang.Override public java.lang.Integer apply(com.google.gerrit.server.notedb.ChangeBundle in) { return in.getChange().getId().get(); } })); notesMigration.setWriteChanges(true); notesMigration.setReadChanges(true); for (com.google.gerrit.server.notedb.ChangeBundle expected : allExpected) { com.google.gerrit.reviewdb.client.Change c = expected.getChange(); changeRebuilder.rebuild(db, c.getId()); com.google.gerrit.server.notedb.ChangeBundle actual = com.google.gerrit.server.notedb.ChangeBundle.fromNotes(plcUtil, notesFactory.create(db, c.getProject(), c.getId())); java.util.List<java.lang.String> diff = expected.differencesFrom(actual); if (!(diff.isEmpty())) { throw new java.lang.AssertionError(((("Differences between ReviewDb and NoteDb for " + c) + ":\n") + (com.google.common.base.Joiner.on('\n').join(diff)))); } } }
@org.junit.Test public void patchSets() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); r = amendChange(r.getChangeId()); com.google.gerrit.reviewdb.client.PatchSet ps1 = db.patchSets().get(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, 1)); com.google.gerrit.reviewdb.client.PatchSet ps2 = db.patchSets().get(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, 2)); rebuild(id); com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create(db, project, id); java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> patchSets = notes.getPatchSets(); assertThat(patchSets.keySet()).containsExactly(ps1.getId(), ps2.getId()).inOrder(); com.google.gerrit.acceptance.server.notedb.ChangeRebuilderIT.assertPatchSetEqual(ps1, patchSets.get(ps1.getId())); com.google.gerrit.acceptance.server.notedb.ChangeRebuilderIT.assertPatchSetEqual(ps2, patchSets.get(ps2.getId())); }

private java.lang.String problemsForSubmittingChangeset(com.google.gerrit.server.git.ChangeSet cs, com.google.gerrit.server.IdentifiedUser identifiedUser) { try { @java.lang.SuppressWarnings("resource") com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); for (com.google.gerrit.server.query.change.ChangeData c : cs.changes()) { com.google.gerrit.server.project.ChangeControl changeControl = c.changeControl(identifiedUser); if (!(changeControl.isVisible(db))) { return com.google.gerrit.server.change.Submit.BLOCKED_HIDDEN_SUBMIT_TOOLTIP; } if (!(changeControl.canSubmit())) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; } com.google.gerrit.server.git.MergeOp.checkSubmitRule(c); } java.lang.Boolean csIsMergeable = isPatchSetMergeable(cs); if (csIsMergeable == null) { return com.google.gerrit.server.change.Submit.CLICK_FAILURE_TOOLTIP; } else if (!csIsMergeable) { return com.google.gerrit.server.change.Submit.CHANGES_NOT_MERGEABLE; } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return com.google.gerrit.server.change.Submit.BLOCKED_SUBMIT_TOOLTIP; HEAD(eb4f5d); (0.2016012118 - com.google.gerrit.server.change.r) - com.google.gerrit.server.change.g8efdaaf = com.google.gerrit.server.change.$missing$; } catch (com.google.gwtorm.server.OrmException e) { } catch (com.google.gerrit.server.project.NoSuchChangeException | com.google.gwtorm.server.OrmException | java.io.IOException e) { BRANCH(6); com.google.gerrit.server.change.b6bdb Merge; com.google.gerrit.server.change.changes I25afc720; com.google.gerrit.server.change.changes I30f2f8a8 = (stable) - 2.12; com.google.gerrit.server.change.Submit.log.error("Error checking if change is submittable", e); throw new com.google.gwtorm.server.OrmRuntimeException("Could not determine problems for the change", e); } return null; }
private void fireEvent(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.server.events.Event event, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.common.ChangeHookRunner.ChangeListenerHolder holder : listeners.values()) { if (isVisibleTo(change, holder.user, db)) { holder.listener.onEvent(event); } } fireEventForUnrestrictedListeners(event); }
private void fireEvent(com.google.gerrit.reviewdb.client.Branch.NameKey branchName, final com.google.gerrit.server.events.Event event) { for (com.google.gerrit.common.ChangeHookRunner.ChangeListenerHolder holder : listeners.values()) { if (isVisibleTo(branchName, holder.user)) { holder.listener.onEvent(event); } } fireEventForUnrestrictedListeners(event); }
@java.lang.Override protected void onExit(final int rc) { source.removeChangeListener(listener); synchronized(taskLock) { done = true; } super.onExit(rc); }
@java.lang.Override public void destroy() { source.removeChangeListener(listener); final boolean exit; synchronized(taskLock) { if ((task) != null) { task.cancel(true); exit = false; } else { exit = !(done); } done = true; } if (exit) { onExit(0); } }
private void postEvent(java.lang.String project, java.lang.String ref, com.google.gerrit.server.events.RefEvent event) { if (com.google.gerrit.reviewdb.client.PatchSet.isRef(ref)) { try { com.google.gerrit.reviewdb.server.ReviewDb db = schema.open(); try { com.google.gerrit.reviewdb.client.Change change = retrieveChange(ref, db); if (change != null) { dispatcher.postEvent(change, event, db); } } finally { db.close(); } } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.replication.PushResultProcessing.GitUpdateProcessing.log.error("Cannot post event", e); } } else { com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(Project.NameKey.parse(project), ref); dispatcher.postEvent(branch, event); } }
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.getBytes("UTF-8")); err.flush(); onExit(1); return; } stdout = toPrintWriter(out); source.addChangeListener(listener, currentUser); }
private void fireEvent(com.google.gerrit.reviewdb.client.Branch.NameKey branchName, final com.google.gerrit.server.events.RefEvent event) { dispatcher.fireEvent(branchName, event); }

private void fireEvent(final com.google.gerrit.reviewdb.client.Change change, final com.google.gerrit.server.events.ChangeEvent event, final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { dispatcher.fireEvent(change, event, db); }
private void writeEvents() { int processed = 0; while (processed < (com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE)) { if ((java.lang.Thread.interrupted()) || (stdout.checkError())) { source.removeChangeListener(listener); flush(); onExit(0); return; } if (dropped) { write(droppedOutputEvent); dropped = false; } final com.google.gerrit.server.events.Event event = poll(); if (event == null) { break; } write(event); processed++; } flush(); if ((com.google.gerrit.sshd.commands.StreamEvents.BATCH_SIZE) <= processed) { synchronized(taskLock) { task = pool.submit(writer); } } }
public static void submit(int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.SubmitInfo> cb) { com.google.gerrit.client.changes.ChangeApi.SubmitInput in = com.google.gerrit.client.changes.ChangeApi.SubmitInput.create(); in.waitForMerge(true); com.google.gerrit.client.changes.ChangeApi.call(id, commit, "submit").post(in, cb); }
private net.codemirror.lib.CodeMirror newCM(com.google.gerrit.client.diff.DiffInfo.FileMeta meta, java.lang.String contents, com.google.gwt.dom.client.Element parent) { return net.codemirror.lib.CodeMirror.create(parent, net.codemirror.lib.Configuration.create().set("readOnly", true).set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("lineNumbers", prefs.showLineNumbers()).set("tabSize", prefs.tabSize()).set("mode", ((fileSize) == (com.google.gerrit.client.diff.SideBySide.FileSize.SMALL) ? getContentType(meta) : null)).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("keyMap", "vim_ro").set("theme", prefs.theme().name().toLowerCase()).set("value", (meta != null ? contents : "")).set("viewportMargin", (renderEntireFile() ? java.lang.Double.POSITIVE_INFINITY : 10))); }

@org.junit.Test(expected = com.google.gerrit.extensions.restapi.AuthException.class) public void submitOnBehalfOf() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id((((project.get()) + "~master~") + (r.getChangeId()))).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); com.google.gerrit.extensions.api.changes.SubmitInput in = new com.google.gerrit.extensions.api.changes.SubmitInput(); in.onBehalfOf = admin2.email; gApi.changes().id((((project.get()) + "~master~") + (r.getChangeId()))).current().submit(in); }
@com.google.common.annotations.VisibleForTesting static com.google.gerrit.server.git.LabelNormalizer.Result create(java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> unchanged, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> updated, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> deleted) { return new com.google.gerrit.server.git.AutoValue_LabelNormalizer_Result(com.google.common.collect.ImmutableList.copyOf(unchanged), com.google.common.collect.ImmutableList.copyOf(updated), com.google.common.collect.ImmutableList.copyOf(deleted)); }
public com.google.gerrit.server.git.LabelNormalizer.Result normalize(com.google.gerrit.server.project.ChangeControl ctl, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> unchanged = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> updated = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> deleted = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getLabelTypes(); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { com.google.gerrit.reviewdb.client.Change.Id changeId = psa.getKey().getParentKey().getParentKey(); checkArgument(changeId.equals(ctl.getId()), "Approval %s does not match change %s", psa.getKey(), ctl.getChange().getKey()); if (psa.isSubmit()) { unchanged.add(psa); continue; } com.google.gerrit.common.data.LabelType label = labelTypes.byLabel(psa.getLabelId()); if (label == null) { deleted.add(psa); continue; } com.google.gerrit.reviewdb.client.PatchSetApproval copy = copy(psa); applyTypeFloor(label, copy); if (!(applyRightFloor(ctl, label, copy))) { deleted.add(psa); } else if ((copy.getValue()) != (psa.getValue())) { updated.add(copy); } else { unchanged.add(psa); } } return com.google.gerrit.server.git.LabelNormalizer.Result.create(unchanged, updated, deleted); }
private void saveApprovals(com.google.gerrit.server.git.LabelNormalizer.Result normalized, com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.notedb.ChangeUpdate update, boolean includeUnchanged) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = update.getPatchSetId(); ctx.getDb().patchSetApprovals().upsert(com.google.gerrit.server.git.strategy.SubmitStrategyOp.convertPatchSet(normalized.getNormalized(), psId)); ctx.getDb().patchSetApprovals().delete(com.google.gerrit.server.git.strategy.SubmitStrategyOp.convertPatchSet(normalized.deleted(), psId)); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : normalized.updated()) { update.putApprovalFor(psa.getAccountId(), psa.getLabel(), psa.getValue()); } for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : normalized.deleted()) { update.removeApprovalFor(psa.getAccountId(), psa.getLabel()); } for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : normalized.unchanged()) { if (includeUnchanged || (psa.isSubmit())) { logDebug(("Adding submit label " + psa)); update.putApprovalFor(psa.getAccountId(), psa.getLabel(), psa.getValue()); } } }





int shutdown() { int cnt = 0; if ((pool) != null) { cnt = pool.shutdownNow().size(); pool.unregisterWorkQueue(); pool = null; } return cnt; }

void start(com.google.gerrit.server.git.WorkQueue workQueue) { pool = workQueue.createQueue(poolThreads, poolName); }
private static org.eclipse.jgit.transport.RemoteSession connect(org.eclipse.jgit.transport.URIish uri) throws org.eclipse.jgit.errors.TransportException { return org.eclipse.jgit.transport.SshSessionFactory.getInstance().getSession(uri, null, FS.DETECTED, 0); }

private static void diffTimestamps(java.util.List<java.lang.String> diffs, java.lang.String desc, com.google.gerrit.server.notedb.ChangeBundle bundleA, java.lang.Object a, com.google.gerrit.server.notedb.ChangeBundle bundleB, java.lang.Object b, java.lang.String field) { checkArgument(((a.getClass()) == (b.getClass()))); java.lang.Class<?> clazz = a.getClass(); java.sql.Timestamp ta; java.sql.Timestamp tb; try { java.lang.reflect.Field f = clazz.getDeclaredField(field); checkArgument(((f.getAnnotation(com.google.gwtorm.client.Column.class)) != null)); f.setAccessible(true); ta = ((java.sql.Timestamp) (f.get(a))); tb = ((java.sql.Timestamp) (f.get(b))); } catch (java.lang.IllegalAccessException | java.lang.NoSuchFieldException | java.lang.SecurityException e) { throw new java.lang.IllegalArgumentException(e); } if (((bundleA.source) == (com.google.gerrit.server.notedb.ChangeBundle.Source.REVIEW_DB)) && ((bundleB.source) == (com.google.gerrit.server.notedb.ChangeBundle.Source.NOTE_DB))) { ta = roundToSecond(ta); checkArgument(tb.equals(roundToSecond(tb)), "%s from NoteDb has non-rounded %s timestamp: %s", desc, field, tb); } else if (((bundleA.source) == (com.google.gerrit.server.notedb.ChangeBundle.Source.NOTE_DB)) && ((bundleB.source) == (com.google.gerrit.server.notedb.ChangeBundle.Source.REVIEW_DB))) { tb = roundToSecond(tb); checkArgument(ta.equals(roundToSecond(ta)), "%s from NoteDb has non-rounded %s timestamp: %s", desc, field, ta); } com.google.gerrit.server.notedb.ChangeBundle.diffValues(diffs, desc, ta, tb, field); }
private org.eclipse.jgit.lib.ObjectId storeRevisionNotes(org.eclipse.jgit.revwalk.RevWalk rw, ObjectInserter inserter, org.eclipse.jgit.lib.ObjectId curr) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((comments.isEmpty()) && ((pushCert) == null)) { return null; } com.google.gerrit.server.notedb.RevisionNoteMap rnm = getRevisionNoteMap(rw, curr); com.google.gerrit.server.notedb.RevisionNoteBuilder.Cache cache = new com.google.gerrit.server.notedb.RevisionNoteBuilder.Cache(rnm); for (com.google.gerrit.reviewdb.client.PatchLineComment c : comments) { cache.get(c.getRevId()).putComment(c); } if ((pushCert) != null) { checkState(((commit) != null)); cache.get(new com.google.gerrit.reviewdb.client.RevId(commit.name())).setPushCertificate(pushCert); } java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNoteBuilder> builders = cache.getBuilders(); checkComments(rnm.revisionNotes, builders); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNoteBuilder> e : builders.entrySet()) { org.eclipse.jgit.lib.ObjectId data = inserter.insert(com.google.gerrit.server.notedb.OBJ_BLOB, e.getValue().build(commentsUtil)); rnm.noteMap.set(org.eclipse.jgit.lib.ObjectId.fromString(e.getKey().get()), data); } return rnm.noteMap.writeTree(inserter); }
private static java.lang.String times(int n) { return (n + " time") + (n != 1 ? "s" : ""); }
private void printRemote(com.googlesource.gerrit.plugins.replication.Destination d, boolean detail) { if (json) { com.google.gson.JsonObject obj = new com.google.gson.JsonObject(); obj.addProperty("Remote", d.getRemoteConfig().getName()); addProperty(obj, "Url", d.getUrls()); if (detail) { addProperty(obj, "AdminUrl", d.getAdminUrls()); addProperty(obj, "AuthGroup", d.getAuthGroupNames()); addProperty(obj, "Project", d.getProjects()); } stdout.print(((obj.toString()) + "\n")); } else { java.lang.StringBuilder out = new java.lang.StringBuilder(); out.append("Remote: ").append(d.getRemoteConfig().getName()).append("\n"); for (java.lang.String url : d.getUrls()) { out.append("Url: ").append(url).append("\n"); } if (detail) { for (java.lang.String adminUrl : d.getAdminUrls()) { out.append("AdminUrl: ").append(adminUrl).append("\n"); } for (java.lang.String authGroup : d.getAuthGroupNames()) { out.append("AuthGroup: ").append(authGroup).append("\n"); } for (java.lang.String project : d.getProjects()) { out.append("Project: ").append(project).append("\n"); } } stdout.print(((out.toString()) + "\n")); } }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return ((diffScreenType) == (com.google.gerrit.client.diff.DiffScreen.DiffScreenType.UNIFIED)) || (info.binary()) ? com.google.gerrit.client.Dispatcher.toUnified(base, patchSetId, info.path()) : com.google.gerrit.client.Dispatcher.toSideBySide(base, patchSetId, info.path()); }
void addReplyBox(boolean quote) { com.google.gerrit.client.changes.CommentInfo commentReply = com.google.gerrit.client.changes.CommentInfo.createReply(comment); if (quote) { commentReply.message(com.google.gerrit.client.change.ReplyBox.quote(comment.message())); } getCommentManager().addDraftBox(getCm().side(), commentReply).setEdit(true); }
@com.google.gwt.uibinder.client.UiHandler("done") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(getCommentManager().getDiffScreen().getToken()); } else if ((replyBox) == null) { done.setEnabled(false); com.google.gerrit.client.changes.CommentInfo input = com.google.gerrit.client.changes.CommentInfo.createReply(comment); input.message(PatchUtil.C.cannedReplyDone()); com.google.gerrit.client.changes.CommentApi.createDraft(psId, input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); getCommentManager().addDraftBox(getCm().side(), result); } }); } else { openReplyBox(); setOpen(false); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); getCommentManager().addDraftBox(getCm().side(), result); }
void diffChunkNavHelper(java.util.List<? extends com.google.gerrit.client.diff.DiffChunkInfo> chunks, net.codemirror.lib.CodeMirror cm, int res, com.google.gerrit.client.diff.Direction dir) { if (res < 0) { res = (-res) - (dir == (Direction.PREV) ? 1 : 2); } res = res + (dir == (Direction.PREV) ? -1 : 1); if ((res < 0) || ((chunks.size()) <= res)) { return; } com.google.gerrit.client.diff.DiffChunkInfo lookUp = chunks.get(res); if ((lookUp.isEdit()) && ((lookUp.getSide()) == (com.google.gerrit.client.diff.DisplaySide.A))) { res = res + (dir == (Direction.PREV) ? -1 : 1); if ((res < 0) || ((chunks.size()) <= res)) { return; } } com.google.gerrit.client.diff.DiffChunkInfo target = chunks.get(res); cm.setCursor(net.codemirror.lib.Pos.create(getCmLine(target.getStart(), target.getSide()))); cm.focus(); cm.scrollToY(((cm.heightAtLine(target.getStart(), "local")) - (0.5 * (cm.scrollbarV().getClientHeight())))); }
@java.lang.Override void renderPublished(com.google.gerrit.client.diff.DisplaySide forSide, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> in) { for (com.google.gerrit.client.changes.CommentInfo info : com.google.gerrit.client.rpc.Natives.asList(in)) { com.google.gerrit.client.diff.DisplaySide side = displaySide(info, forSide); if (side != null) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.UnifiedCommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), info, isOpen()); group.add(box); box.setAnnotation(getDiffScreen().getDiffTable().scrollbar.comment(host.getCm(), cmLinePlusOne)); getPublished().put(info.id(), box); } } }
@java.lang.Override java.lang.Runnable diffChunkNav(final net.codemirror.lib.CodeMirror cm, final com.google.gerrit.client.diff.Direction dir) { return new java.lang.Runnable() { @java.lang.Override public void run() { int line = (cm.extras().hasActiveLine()) ? cm.getLineNumber(cm.extras().activeLine()) : 0; int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.DiffChunkInfo(cm.side(), line, 0, false), getDiffChunkComparator()); diffChunkNavHelper(chunks, cm, res, dir); } }; }
@java.lang.Override public void run() { int line = (cm.extras().hasActiveLine()) ? cm.getLineNumber(cm.extras().activeLine()) : 0; int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.DiffChunkInfo(cm.side(), line, 0, false), getDiffChunkComparator()); diffChunkNavHelper(chunks, cm, res, dir); }
@java.lang.Override void renderPublished(com.google.gerrit.client.diff.DisplaySide forSide, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> in) { for (com.google.gerrit.client.changes.CommentInfo info : com.google.gerrit.client.rpc.Natives.asList(in)) { com.google.gerrit.client.diff.DisplaySide side = displaySide(info, forSide); if (side != null) { com.google.gerrit.client.diff.SideBySideCommentGroup group = group(side, info.line()); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(group, getCommentLinkProcessor(), getPatchSetIdFromSide(side), info, isOpen()); group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.comment(host.getCmFromSide(side), java.lang.Math.max(0, ((info.line()) - 1)))); getPublished().put(info.id(), box); } } }
@java.lang.Override java.lang.Runnable diffChunkNav(final net.codemirror.lib.CodeMirror cm, final com.google.gerrit.client.diff.Direction dir) { return new java.lang.Runnable() { @java.lang.Override public void run() { int line = (cm.extras().hasActiveLine()) ? cm.getLineNumber(cm.extras().activeLine()) : 0; int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.UnifiedDiffChunkInfo(cm.side(), 0, 0, line, false), getDiffChunkComparatorCmLine()); diffChunkNavHelper(chunks, cm, res, dir); } }; }
@java.lang.Override public void run() { int line = (cm.extras().hasActiveLine()) ? cm.getLineNumber(cm.extras().activeLine()) : 0; int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.UnifiedDiffChunkInfo(cm.side(), 0, 0, line, false), getDiffChunkComparatorCmLine()); diffChunkNavHelper(chunks, cm, res, dir); }







private com.google.inject.Injector createSysInjector() { java.util.List<java.lang.Module> modules = com.google.common.collect.Lists.newArrayList(); java.lang.Module changeIndexModule; switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : changeIndexModule = new com.google.gerrit.lucene.LuceneIndexModule(version, threads); break; default : throw new java.lang.IllegalStateException("unsupported index.type"); } modules.add(changeIndexModule); modules.add(com.google.gerrit.server.git.ScanningChangeCacheImpl.module()); modules.add(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); return dbInjector.createChildInjector(modules); }
private java.lang.Module luceneIndexModule() { try { int version = cfg.getInt("index", "lucene", "testVersion", (-1)); checkState(ChangeSchemas.ALL.containsKey(version), "invalid index.lucene.testVersion %s", version); java.lang.Class<?> clazz = java.lang.Class.forName("com.google.gerrit.lucene.LuceneIndexModule"); java.lang.reflect.Constructor<?> c = clazz.getConstructor(java.lang.Integer.class, int.class); return ((java.lang.Module) (c.newInstance(version, 0))); } catch (java.lang.ClassNotFoundException | java.lang.SecurityException | java.lang.NoSuchMethodException | java.lang.IllegalArgumentException | java.lang.InstantiationException | java.lang.IllegalAccessException | java.lang.reflect.InvocationTargetException e) { com.google.inject.ProvisionException pe = new com.google.inject.ProvisionException(e.getMessage()); pe.initCause(e); throw pe; } }

@java.lang.Override public void run() throws java.io.IOException { ui.header("Index"); com.google.gerrit.server.index.IndexModule.IndexType type = index.select("Type", "type", IndexType.LUCENE); com.google.gerrit.lucene.AbstractLuceneIndex.setReady(site, com.google.gerrit.server.index.change.ChangeSchemas.getLatest().getVersion(), true); if (((site.isNew) || (isEmptySite())) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { } else { final java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }











public java.io.File getBasePath() { return basePath; }


@java.lang.Override protected void configure() { bind(com.google.gerrit.server.git.GitRepositoryManager.class).to(com.google.gerrit.server.git.LocalDiskRepositoryManager.class); listener().to(com.google.gerrit.server.git.LocalDiskRepositoryManager.Lifecycle.class); }
@java.lang.Override public org.eclipse.jgit.lib.Repository createRepository(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.git.RepositoryCaseMismatchException, org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository repo = createRepository(basePath, name); if ((noteDbPath) != null) { createRepository(noteDbPath, name); } return repo; }
@java.lang.Override public java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> list() { namesUpdateLock.lock(); try { java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> n = new java.util.TreeSet<>(); scanProjects(basePath, "", n); names = java.util.Collections.unmodifiableSortedSet(n); return n; } finally { namesUpdateLock.unlock(); } }
@java.lang.Override protected void configureServlets() { java.lang.Class<? extends javax.servlet.Filter> authFilter; if (authConfig.isTrustContainerAuth()) { authFilter = com.google.gerrit.httpd.ContainerAuthFilter.class; } else if (authConfig.isGitBasicAuth()) { authFilter = com.google.gerrit.httpd.ProjectBasicAuthFilter.class; } else { authFilter = com.google.gerrit.httpd.ProjectDigestFilter.class; } if (isHttpEnabled()) { java.lang.String git = GitOverHttpServlet.URL_REGEX; filterRegex(git).through(authFilter); serveRegex(git).with(com.google.gerrit.httpd.GitOverHttpServlet.class); } filter("/a/*").through(authFilter); }
private com.google.gerrit.server.data.ApprovalAttribute getApprovalAttribute(com.google.gerrit.common.data.LabelTypes labelTypes, java.util.Map.Entry<java.lang.String, java.lang.Short> approval) { com.google.gerrit.server.data.ApprovalAttribute a = new com.google.gerrit.server.data.ApprovalAttribute(); a.type = approval.getKey(); com.google.gerrit.common.data.LabelType lt = labelTypes.byLabel(approval.getKey()); if (lt != null) { a.description = lt.getName(); } a.value = java.lang.Short.toString(approval.getValue()); return a; }
@java.lang.Override public void doCommentAddedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, com.google.gerrit.reviewdb.server.ReviewDb db) { }
public com.google.gerrit.server.data.ApprovalAttribute asApprovalAttribute(com.google.gerrit.reviewdb.client.PatchSetApproval approval, com.google.gerrit.common.data.LabelTypes labelTypes) { com.google.gerrit.server.data.ApprovalAttribute a = new com.google.gerrit.server.data.ApprovalAttribute(); a.type = approval.getLabelId().get(); a.value = java.lang.Short.toString(approval.getValue()); a.by = asAccountAttribute(approval.getAccountId()); a.grantedOn = (approval.getGranted().getTime()) / 1000L; com.google.gerrit.common.data.LabelType lt = labelTypes.byLabel(approval.getLabelId()); if (lt != null) { a.description = lt.getName(); } return a; }
public void doCommentAddedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException;
@java.lang.Override public void start() { java.lang.String runReindex = ("No index versions ready; run java -jar " + (sitePaths.gerrit_war.toAbsolutePath())) + " reindex"; org.eclipse.jgit.storage.file.FileBasedConfig cfg; try { cfg = com.google.gerrit.lucene.LuceneVersionManager.loadGerritIndexConfig(sitePaths); } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { throw fail(e); } if (!(java.nio.file.Files.exists(sitePaths.index_dir))) { throw new com.google.inject.ProvisionException(runReindex); } else if (!(java.nio.file.Files.exists(sitePaths.index_dir))) { com.google.gerrit.lucene.LuceneVersionManager.log.warn("Not a directory: %s", sitePaths.index_dir.toAbsolutePath()); throw new com.google.inject.ProvisionException(runReindex); } java.util.TreeMap<java.lang.Integer, com.google.gerrit.lucene.LuceneVersionManager.Version> versions = scanVersions(cfg); com.google.gerrit.lucene.LuceneVersionManager.Version search = null; java.util.List<com.google.gerrit.lucene.LuceneVersionManager.Version> write = com.google.common.collect.Lists.newArrayListWithCapacity(2); for (com.google.gerrit.lucene.LuceneVersionManager.Version v : versions.descendingMap().values()) { if ((v.schema) == null) { continue; } if ((write.isEmpty()) && (onlineUpgrade)) { write.add(v); } if (v.ready) { search = v; if (!(write.contains(v))) { write.add(v); } break; } } if (search == null) { throw new com.google.inject.ProvisionException(runReindex); } markNotReady(cfg, versions.values(), write); com.google.gerrit.lucene.LuceneChangeIndex searchIndex = ((com.google.gerrit.lucene.LuceneChangeIndex) (indexFactory.create(search.schema))); indexes.setSearchIndex(searchIndex); for (com.google.gerrit.lucene.LuceneVersionManager.Version v : write) { if ((v.schema) != null) { if ((v.version) != (search.version)) { indexes.addWriteIndex(indexFactory.create(v.schema)); } else { indexes.addWriteIndex(searchIndex); } } } int latest = write.get(0).version; if ((onlineUpgrade) && (latest != (search.version))) { reindexer = new com.google.gerrit.server.index.OnlineReindexer(changeDef, latest); reindexer.start(); } }
@java.lang.Override int getCmLine(int line, com.google.gerrit.client.diff.DisplaySide side) { int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.UnifiedDiffChunkInfo(side, line, 0, 0, false), getDiffChunkComparator()); if (res >= 0) { return chunks.get(res).getCmLine(); } else { res = (-res) - 1; if (res > 0) { com.google.gerrit.client.diff.UnifiedDiffChunkInfo info = chunks.get((res - 1)); if ((side == (DisplaySide.A)) && (info.isEdit())) { info = chunks.get((res - 2)); } if ((info.getSide()) == side) { return ((info.getCmLine()) + line) - (info.getStart()); } else { return ((info.getCmLine()) + (getLineMapper().lineOnOther(side, line).getLine())) - (info.getStart()); } } else { return line; } } }
private static void setTreeFilter(org.eclipse.jgit.revwalk.RevWalk walk, com.google.gitiles.GitilesView view, com.google.gitiles.GitilesAccess access) throws java.io.IOException { if (com.google.common.base.Strings.isNullOrEmpty(view.getPathPart())) { return; } walk.setRewriteParents(false); java.lang.String path = view.getPathPart(); if (com.google.gitiles.LogServlet.isTrue(com.google.common.collect.Iterables.getFirst(view.getParameters().get(com.google.gitiles.LogServlet.FOLLOW_PARAM), null))) { walk.setTreeFilter(org.eclipse.jgit.revwalk.FollowFilter.create(path, access.getConfig().get(DiffConfig.KEY))); } else { walk.setTreeFilter(org.eclipse.jgit.treewalk.filter.AndTreeFilter.create(org.eclipse.jgit.treewalk.filter.PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF)); } }


@java.lang.Override protected void configure() { factory(AbandonedSender.Factory.class); factory(CommentSender.Factory.class); factory(RevertedSender.Factory.class); factory(RestoredSender.Factory.class); }





@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { ui.message("Generating Superproject subscriptions table to submodule ACLs"); try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery(("SELECT " + (((("key.super_project.project_name, " + "key.super_project.branch_name, ") + "submodule.project_name ") + "submodule.branch_name ") + "FROM submodule_subscriptions")))) { while (rs.next()) { com.google.gerrit.reviewdb.client.Project.NameKey superproject = new com.google.gerrit.reviewdb.client.Project.NameKey(rs.getString(1)); com.google.gerrit.reviewdb.client.Branch.NameKey superbranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(superproject, rs.getString(2)); com.google.gerrit.reviewdb.client.Project.NameKey submodule = new com.google.gerrit.reviewdb.client.Project.NameKey(rs.getString(4)); com.google.gerrit.reviewdb.client.Branch.NameKey subbranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(submodule, rs.getString(5)); allowSubmoduleSubscription(subbranch, superbranch); } } }

static int toMask(final com.google.gwt.event.dom.client.KeyPressEvent event) { int mask = event.getUnicodeCharCode(); if (mask == 0) { mask = event.getNativeEvent().getKeyCode(); } return mask; }
private static void checkConfig(org.eclipse.jgit.lib.Config cfg) { java.util.Set<java.lang.String> keys = new java.util.HashSet<>(); for (com.google.gerrit.server.notedb.ConfigNotesMigration.Table t : com.google.gerrit.server.notedb.ConfigNotesMigration.Table.values()) { keys.add(t.key()); } for (java.lang.String t : cfg.getSubsections(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB)) { checkArgument(keys.contains(t.toLowerCase()), "invalid notedb table: %s", t); for (java.lang.String key : cfg.getNames(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB, t)) { java.lang.String lk = key.toLowerCase(); checkArgument(((lk.equals(com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE)) || (lk.equals(com.google.gerrit.server.notedb.ConfigNotesMigration.READ))), "invalid notedb key: %s.%s", t, key); } boolean write = cfg.getBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB, t, com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE, false); boolean read = cfg.getBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB, t, com.google.gerrit.server.notedb.ConfigNotesMigration.READ, false); checkArgument((!(read && (!write))), "must have write enabled when read enabled: %s", t); } }
public static org.eclipse.jgit.lib.Config allEnabledConfig() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); for (com.google.gerrit.server.notedb.ConfigNotesMigration.Table t : com.google.gerrit.server.notedb.ConfigNotesMigration.Table.values()) { cfg.setBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB, t.key(), com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE, true); cfg.setBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB, t.key(), com.google.gerrit.server.notedb.ConfigNotesMigration.READ, true); } return cfg; }
public T load() throws com.google.gwtorm.server.OrmException { if (loaded) { return self(); } if ((!(args.migration.enabled())) || ((changeId) == null)) { loadDefaults(); return self(); } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openMetadataRepository(getProjectName());com.google.gerrit.server.notedb.AbstractChangeNotes.LoadHandle handle = openHandle(repo)) { revision = handle.id(); onLoad(handle); loaded = true; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } return self(); }


public void checkChanges(java.lang.Iterable<com.google.gerrit.reviewdb.client.Change.Id> changeIds) throws java.lang.Exception { com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(); notesMigration.setReadChanges(false); java.util.List<com.google.gerrit.reviewdb.client.Change.Id> sortedIds = com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering().sortedCopy(changeIds); java.util.List<com.google.gerrit.server.notedb.ChangeBundle> allExpected = new java.util.ArrayList(sortedIds.size()); for (com.google.gerrit.reviewdb.client.Change.Id id : sortedIds) { allExpected.add(com.google.gerrit.server.notedb.ChangeBundle.fromReviewDb(db, id)); } notesMigration.setWriteChanges(true); notesMigration.setReadChanges(true); java.util.List<java.lang.String> all = new java.util.ArrayList<>(); for (com.google.gerrit.server.notedb.ChangeBundle expected : allExpected) { com.google.gerrit.reviewdb.client.Change c = expected.getChange(); try { changeRebuilder.rebuild(db, c.getId()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { all.add(("Repository not found for change, cannot convert: " + c)); } } for (com.google.gerrit.server.notedb.ChangeBundle expected : allExpected) { com.google.gerrit.reviewdb.client.Change c = expected.getChange(); com.google.gerrit.server.notedb.ChangeBundle actual; try { actual = com.google.gerrit.server.notedb.ChangeBundle.fromNotes(plcUtil, notesFactory.create(db, c.getProject(), c.getId())); } catch (java.lang.Throwable t) { java.lang.String msg = "Error converting change: " + c; all.add(msg); com.google.gerrit.testutil.NoteDbChecker.log.error(msg, t); continue; } java.util.List<java.lang.String> diff = expected.differencesFrom(actual); if (!(diff.isEmpty())) { all.add((("Differences between ReviewDb and NoteDb for " + c) + ":")); all.addAll(diff); all.add(""); } else { java.lang.System.err.println((("NoteDb conversion of change " + (c.getId())) + " successful")); } } if (!(all.isEmpty())) { throw new java.lang.AssertionError(com.google.common.base.Joiner.on('\n').join(all)); } }


@org.junit.Test public void noWriteToNewRef() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); checker.assertNoChangeRef(project, id); notesMigration.setWriteChanges(true); gApi.changes().id(id.get()).topic(name("a-topic")); checker.assertNoChangeRef(project, id); checker.rebuildAndCheckChanges(id); gApi.changes().id(id.get()).topic(name("new-topic")); checker.checkChanges(id); }

protected com.google.gerrit.server.notedb.ChangeUpdate newUpdate(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.CurrentUser user) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeUpdate update = com.google.gerrit.testutil.TestChanges.newUpdate(injector, repoManager, com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION, c, allUsers, user); return update; }
private java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws com.google.gerrit.server.git.SubmoduleException { logDebug(("Calculating possible superprojects for " + branch)); java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> ret = new java.util.ArrayList<>(); com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.get(project).getConfig(); try { for (com.google.gerrit.common.data.SubscribeSection s : cfg.getSubscribeSections(branch)) { java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> branches = getDestinationBranches(branch, s); for (com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch : branches) { com.google.gerrit.server.git.GitModules m = gitmodulesFactory.create(targetBranch, updateId); m.load(); ret.addAll(m.subscribedTo(branch)); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException("Could not update superproject", e); } logDebug(((("Calculated superprojects for " + branch) + " are ") + ret)); return ret; }
public void assertCanDelete(com.google.gerrit.server.project.ProjectResource rsrc, com.googlesource.gerrit.plugins.deleteproject.DeleteProject.Input input) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { try { pcHandler.assertCanDelete(rsrc); dbHandler.assertCanDelete(rsrc.getControl().getProject()); fsHandler.assertCanDelete(rsrc, (input == null ? false : input.preserve)); } catch (com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }




public static void visitChangedEntries(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c, com.googlesource.gerrit.plugins.uploadvalidator.TreeWalkVisitor visitor) throws java.io.IOException { try (org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(repo)) { tw.setRecursive(true); tw.setFilter(TreeFilter.ANY_DIFF); tw.addTree(c.getTree()); if ((c.getParentCount()) > 0) { for (org.eclipse.jgit.revwalk.RevCommit p : c.getParents()) { tw.addTree(p.getTree()); } while (tw.next()) { if (com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.isDifferentToAllParents(c, tw)) { visitor.onVisit(tw); } } } else { while (tw.next()) { visitor.onVisit(tw); } } } }




@org.junit.Test public void getSetEditPreferences() throws java.lang.Exception { java.lang.String endPoint = ("/accounts/" + (admin.email)) + "/preferences.edit"; com.google.gerrit.acceptance.RestResponse r = adminSession.get(endPoint); r.assertOK(); com.google.gerrit.extensions.client.EditPreferencesInfo out = getEditPrefInfo(r); assertThat(out.lineLength).isEqualTo(100); assertThat(out.tabSize).isEqualTo(8); assertThat(out.cursorBlinkRate).isEqualTo(0); assertThat(out.hideTopMenu).isNull(); assertThat(out.showTabs).isTrue(); assertThat(out.showWhitespaceErrors).isNull(); assertThat(out.syntaxHighlighting).isTrue(); assertThat(out.hideLineNumbers).isNull(); assertThat(out.matchBrackets).isTrue(); assertThat(out.autoCloseBrackets).isNull(); assertThat(out.theme).isEqualTo(Theme.DEFAULT); assertThat(out.keyMapType).isEqualTo(KeyMapType.DEFAULT); out.lineLength = 80; out.tabSize = 4; out.cursorBlinkRate = 500; out.hideTopMenu = true; out.showTabs = false; out.showWhitespaceErrors = true; out.syntaxHighlighting = false; out.hideLineNumbers = true; out.matchBrackets = false; out.autoCloseBrackets = true; out.theme = com.google.gerrit.extensions.client.Theme.TWILIGHT; out.keyMapType = com.google.gerrit.extensions.client.KeyMapType.EMACS; adminSession.put(endPoint, out).assertNoContent(); r = adminSession.get(endPoint); r.assertOK(); com.google.gerrit.extensions.client.EditPreferencesInfo info = getEditPrefInfo(r); assertEditPreferences(info, out); com.google.gerrit.extensions.client.EditPreferencesInfo in = new com.google.gerrit.extensions.client.EditPreferencesInfo(); in.tabSize = 42; adminSession.put(endPoint, in).assertNoContent(); r = adminSession.get(endPoint); r.assertOK(); info = getEditPrefInfo(r); out.tabSize = in.tabSize; assertEditPreferences(info, out); }

protected void postExecute(com.google.reviewit.ReviewChangesFragment.ChangeListData changeListData) { super.postExecute(changeListData); if ((getActivity()) == null) { return; } getActivity().invalidateOptionsMenu(); setInvisible(progress); setGone(initialProgress, reloadButton); if ((changeListData.error) != null) { statusText.setText(changeListData.error); return; } if (!(changeListData.changeList.isEmpty())) { setGone(statusText); for (com.google.reviewit.app.Change change : changeListData.changeList) { com.google.reviewit.widget.ChangeEntry changeEntry = new com.google.reviewit.widget.ChangeEntry(getContext()); changeEntry.init(getApp(), change); changeList.addView(changeEntry); addSeparator(changeList); } } else { statusText.setText(getString(R.string.no_changes_match)); } }
@java.lang.Override public void onActivityCreated(android.os.Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); setHasOptionsMenu(true); com.google.reviewit.util.TaskObserver.enableProgressBar(getWindow()); init(); display(); }
private void addSshKeys(java.util.List<java.lang.String> sshKeys) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { for (final java.lang.String sshKey : sshKeys) { com.google.gerrit.server.account.AddSshKey.Input in = new com.google.gerrit.server.account.AddSshKey.Input(); in.raw = new com.google.gerrit.extensions.restapi.RawInput() { @java.lang.Override public java.io.InputStream getInputStream() throws java.io.IOException { return new java.io.ByteArrayInputStream(sshKey.getBytes(java.nio.charset.StandardCharsets.UTF_8)); } @java.lang.Override public java.lang.String getContentType() { return "plain/text"; } @java.lang.Override public long getContentLength() { return sshKey.length(); } }; addSshKey.apply(rsrc, in); } }

@java.lang.Override protected org.apache.sshd.common.session.AbstractSession doCreateSession(org.apache.sshd.common.io.IoSession ioSession) throws java.lang.Exception { return new com.google.gerrit.sshd.GerritServerSession(getServer(), ioSession); }
@java.lang.Override protected org.apache.sshd.common.session.AbstractSession createSession(final org.apache.sshd.common.io.IoSession io) throws java.lang.Exception { connected.incrementAndGet(); sessionsCreated.increment(); if (io instanceof org.apache.sshd.common.io.mina.MinaSession) { if ((((org.apache.sshd.common.io.mina.MinaSession) (io)).getSession().getConfig()) instanceof org.apache.mina.transport.socket.SocketSessionConfig) { ((org.apache.mina.transport.socket.SocketSessionConfig) (((org.apache.sshd.common.io.mina.MinaSession) (io)).getSession().getConfig())).setKeepAlive(keepAlive); } } com.google.gerrit.sshd.GerritServerSession s = ((com.google.gerrit.sshd.GerritServerSession) (super.createSession(io))); int id = idGenerator.next(); java.net.SocketAddress peer = io.getRemoteAddress(); final com.google.gerrit.sshd.SshSession sd = new com.google.gerrit.sshd.SshSession(id, peer); s.setAttribute(SshSession.KEY, sd); s.addCloseSessionListener(new org.apache.sshd.common.future.SshFutureListener<org.apache.sshd.common.future.CloseFuture>() { @java.lang.Override public void operationComplete(org.apache.sshd.common.future.CloseFuture future) { connected.decrementAndGet(); if (sd.isAuthenticationError()) { authFailures.increment(); sshLog.onAuthFail(sd); } } }); return s; }
private boolean isSubmittable(com.google.gerrit.client.info.ChangeInfo info) { boolean canSubmit = ((info.status().isOpen()) && (revision.equals(info.currentRevision()))) && (!(info.revision(revision).draft())); if (canSubmit && ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.NEW))) { for (java.lang.String name : info.labels()) { com.google.gerrit.client.info.ChangeInfo.LabelInfo label = info.label(name); switch (label.status()) { case NEED : statusText.setInnerText(("Needs " + name)); canSubmit = false; break; case REJECT : case IMPOSSIBLE : if (label.blocking()) { statusText.setInnerText(("Not " + name)); canSubmit = false; } break; case MAY : case OK : default : break; } } } return canSubmit; }









private static void execute(com.google.gerrit.server.notedb.NoteDbUpdateManager.OpenRepo or) throws java.io.IOException { if ((or == null) || (or.cmds.isEmpty())) { return; } or.ins.flush(); org.eclipse.jgit.lib.BatchRefUpdate bru = or.repo.getRefDatabase().newBatchUpdate(); or.cmds.addTo(bru); bru.setAllowNonFastForwards(true); bru.execute(or.rw, NullProgressMonitor.INSTANCE); for (org.eclipse.jgit.transport.ReceiveCommand cmd : bru.getCommands()) { if ((cmd.getResult()) != (ReceiveCommand.Result.OK)) { throw new java.io.IOException(("Update failed: " + bru)); } } }
public void execute() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return; } try { initChangeRepo(); if (!(draftUpdates.isEmpty())) { initAllUsersRepo(); } addCommands(); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(changeRepo); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(allUsersRepo); } finally { if ((allUsersRepo) != null) { allUsersRepo.close(); } if ((changeRepo) != null) { changeRepo.close(); } } }
public T load() throws com.google.gwtorm.server.OrmException { if (loaded) { return self(); } if ((!(args.migration.enabled())) || ((changeId) == null)) { loadDefaults(); return self(); } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openMetadataRepository(getProjectName());org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(getRefName()); org.eclipse.jgit.lib.ObjectId id = (ref != null) ? ref.getObjectId() : null; revision = (id != null) ? walk.parseCommit(id).copy() : null; onLoad(walk); loaded = true; } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } return self(); }

@org.junit.Before public void setUp() { assume().that(isNoteDbTestEnabled()).isFalse(); notesMigration.setAllEnabled(false); }

@java.lang.Override public void configure() { factory(ChangeUpdate.Factory.class); factory(ChangeDraftUpdate.Factory.class); factory(DraftCommentNotes.Factory.class); factory(NoteDbUpdateManager.Factory.class); }







public void execute() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return; } try (com.google.gerrit.metrics.Timer1.Context timer = metrics.updateLatency.start(com.google.gerrit.server.notedb.NoteDbTable.CHANGES)) { initChangeRepo(); if (!(draftUpdates.isEmpty())) { initAllUsersRepo(); } addCommands(); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(changeRepo); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(allUsersRepo); } finally { if ((allUsersRepo) != null) { allUsersRepo.close(); } if ((changeRepo) != null) { changeRepo.close(); } } }



private java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sort(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toSort) throws com.google.gerrit.server.git.IntegrationException { try { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> result = new com.google.gerrit.server.git.RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort); java.util.Collections.sort(result, CodeReviewCommit.ORDER); return result; } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException("Commit sorting failed", e); } }





boolean wouldPushRef(java.lang.String ref) { if ((!(replicatePermissions)) && (RefNames.REFS_CONFIG.equals(ref))) { return false; } for (org.eclipse.jgit.transport.RefSpec s : remote.getPushRefSpecs()) { if (s.matchSource(ref)) { return true; } } return false; }
boolean wouldPushProject(final com.google.gerrit.reviewdb.client.Project.NameKey project) { if (!(isVisible(project))) { return false; } if ((projects.length) < 1) { return true; } return new com.googlesource.gerrit.plugins.replication.ReplicationFilter(java.util.Arrays.asList(projects)).matches(project); }
java.util.List<org.eclipse.jgit.transport.URIish> getURIs(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String urlMatch) { java.util.List<org.eclipse.jgit.transport.URIish> r = com.google.common.collect.Lists.newArrayListWithCapacity(remote.getURIs().size()); for (org.eclipse.jgit.transport.URIish uri : remote.getURIs()) { if (com.googlesource.gerrit.plugins.replication.Destination.matches(uri, urlMatch)) { java.lang.String name = project.get(); if (com.googlesource.gerrit.plugins.replication.Destination.needsUrlEncoding(uri)) { name = com.googlesource.gerrit.plugins.replication.Destination.encode(name); } if (remoteNameStyle.equals("dash")) { name = name.replace("/", "-"); } else if (remoteNameStyle.equals("underscore")) { name = name.replace("/", "_"); } else if (remoteNameStyle.equals("basenameOnly")) { name = org.apache.commons.io.FilenameUtils.getBaseName(name); } else if (!(remoteNameStyle.equals("slash"))) { com.googlesource.gerrit.plugins.replication.Destination.repLog.debug(java.lang.String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle)); } java.lang.String replacedPath = com.googlesource.gerrit.plugins.replication.ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch()); if (replacedPath != null) { uri = uri.setPath(replacedPath); r.add(uri); } } } return r; }
void schedule(final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String ref, final org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState state) { com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduling replication {}:{} => {}", project, ref, uri); if (!(isVisible(project, state))) { return; } if (!(replicatePermissions)) { com.googlesource.gerrit.plugins.replication.PushOne e; synchronized(stateLock) { e = pending.get(uri); } if (e == null) { try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project)) { try { org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); if (((head != null) && (head.isSymbolic())) && (RefNames.REFS_CONFIG.equals(head.getLeaf().getName()))) { return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("cannot check type of project %s", project), err, state); return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, state); return; } } } synchronized(stateLock) { com.googlesource.gerrit.plugins.replication.PushOne e = pending.get(uri); if (e == null) { e = opFactory.create(project, uri); pool.schedule(e, delay, java.util.concurrent.TimeUnit.SECONDS); pending.put(uri, e); } e.addRef(ref); state.increasePushTaskCount(project.get(), ref); e.addState(ref, state); com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay); } }
public void start(com.google.gerrit.server.git.WorkQueue workQueue) { pool = workQueue.createQueue(poolThreads, poolName); }
com.google.gerrit.server.CurrentUser getUser() { com.google.gerrit.reviewdb.client.Account.Id id = get(0).who; for (int i = 1; i < (size()); i++) { checkState(java.util.Objects.equals(id, get(i).who), "mismatched users in EventList: %s != %s", id, get(i).who); } if (id == null) { return internalUserFactory.create(); } return userFactory.create(com.google.inject.util.Providers.of(((com.google.gerrit.reviewdb.server.ReviewDb) (null))), id); }
public java.lang.String[] getOwnerGroups(com.google.gerrit.reviewdb.client.Project.NameKey project) { return cfg.getStringList(com.google.gerrit.server.config.RepositoryConfig.SECTION_NAME, findSubSection(project.get()), com.google.gerrit.server.config.RepositoryConfig.OWNER_GROUP_NAME); }
@org.junit.Test public void testOwnerGroupsForStarFilter() { java.lang.String[] ownerGroups = new java.lang.String[]{ "group1", "group2" }; configureOwnerGroups("*", com.google.common.collect.Lists.newArrayList(ownerGroups)); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("someProject"))).isEqualTo(ownerGroups); }
@org.junit.Test public void testOwnerGroupsForStartWithFilter() { java.lang.String[] ownerGroups1 = new java.lang.String[]{ "group1" }; java.lang.String[] ownerGroups2 = new java.lang.String[]{ "group2" }; java.lang.String[] ownerGroups3 = new java.lang.String[]{ "group3" }; configureOwnerGroups("*", com.google.common.collect.Lists.newArrayList(ownerGroups1)); configureOwnerGroups("somePath/*", com.google.common.collect.Lists.newArrayList(ownerGroups2)); configureOwnerGroups("somePath/somePath/*", com.google.common.collect.Lists.newArrayList(ownerGroups3)); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("someProject"))).isEqualTo(ownerGroups1); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("somePath/someProject"))).isEqualTo(ownerGroups2); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("somePath/somePath/someProject"))).isEqualTo(ownerGroups3); }
@org.junit.Test public void testOwnerGroupsForSpecificFilter() { java.lang.String[] ownerGroups = new java.lang.String[]{ "group1", "group2" }; configureOwnerGroups("someProject", com.google.common.collect.Lists.newArrayList(ownerGroups)); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("someOtherProject"))).isEqualTo(new java.lang.String[]{ }); assertThat(repoCfg.getOwnerGroups(new com.google.gerrit.reviewdb.client.Project.NameKey("someProject"))).isEqualTo(ownerGroups); }


final org.eclipse.jgit.lib.ObjectId apply(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.lib.ObjectId curr) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return null; } org.eclipse.jgit.lib.ObjectId z = org.eclipse.jgit.lib.ObjectId.zeroId(); org.eclipse.jgit.lib.CommitBuilder cb = applyImpl(rw, ins, curr); if (cb == null) { result = z; return z; } cb.setAuthor(authorIdent); cb.setCommitter(new org.eclipse.jgit.lib.PersonIdent(serverIdent, when)); if (!(curr.equals(z))) { cb.setParentId(curr); } else { cb.setParentIds(); } if ((cb.getTreeId()) == null) { if (curr.equals(z)) { cb.setTreeId(com.google.gerrit.server.notedb.AbstractChangeUpdate.emptyTree(ins)); } else { org.eclipse.jgit.revwalk.RevCommit p = rw.parseCommit(curr); cb.setTreeId(p.getTree()); } } result = ins.insert(cb); return result; }
private void removeUser(com.google.gerrit.reviewdb.client.Account user) { java.lang.String fromEmail = user.getPreferredEmail(); for (java.util.Iterator<com.google.gerrit.server.mail.Address> j = smtpRcptTo.iterator(); j.hasNext();) { if (j.next().email.equals(fromEmail)) { j.remove(); } } for (com.google.gerrit.server.mail.EmailHeader hdr : headers.values()) { if (hdr instanceof com.google.gerrit.server.mail.EmailHeader.AddressList) { ((com.google.gerrit.server.mail.EmailHeader.AddressList) (hdr)).remove(fromEmail); } } }
@org.junit.Test public void testWithSubmodule() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSubmodule(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation(repo, c); assertEquals(1, m.size()); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("submodules are not allowed: " + "modules/library"), true)); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }
@org.junit.Test public void testKeywords() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidatorTest.getPatterns().values()); assertEquals(2, m.size()); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("blocked keyword(s) found in file: " + "foo.txt (Line: 1) (found: myp4ssw0rd, foobar)"), true)); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("blocked keyword(s) found in file: " + "bar.txt (Line: 5) (found: $Id: bla bla bla$)"), true)); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }
@org.junit.Test public void test() throws java.lang.Exception { java.lang.String[] invalidFilenamePattern = new java.lang.String[]{ "[@:]", "[#%*]" }; org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); for (java.lang.String filenames : getInvalidFilenames()) { expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("invalid characters found in filename: " + filenames), true)); } assertEquals(5, m.size()); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }
@org.junit.Test public void testCarriageReturnWithBinaries() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithPseudoBinaries(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.performValidation(repo, c, com.google.common.collect.Sets.newHashSet(new java.lang.String[]{ "" })); assertEquals(2, m.size()); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("found carriage return (CR) " + ("character in file: " + "foo.jpeg")), true)); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("found carriage return (CR) " + ("character in file: " + "foo.iso")), true)); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }
@org.junit.Test public void testCarriageReturn() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.performValidation(repo, c, com.google.common.collect.Sets.newHashSet(new java.lang.String[]{ "" })); assertEquals(1, m.size()); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("found carriage return (CR) " + ("character in file: " + "foo.txt")), true)); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }
public static boolean compareCommitValidationMessage(java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m1, java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m2) { for (com.google.gerrit.server.git.validators.CommitValidationMessage cvm1 : m1) { boolean found = false; for (com.google.gerrit.server.git.validators.CommitValidationMessage cvm2 : m2) { if (com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(cvm1, cvm2)) { found = true; } } if (!found) { return false; } } return true; }

@org.junit.Test public void testWithSymlink() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSymlink(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.performValidation(repo, c); assertEquals(2, m.size()); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("Symbolic links are not allowed: " + "foo.txt"), true)); expected.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("Symbolic links are not allowed: " + "symbolicFolder"), true)); assertTrue(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.compareCommitValidationMessage(m, expected)); }



@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); if ((cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.KEY_CHECK_BLOCKED_KEYWORD_PATTERN).length) == 0) { return java.util.Collections.emptyList(); } com.google.common.collect.ImmutableMap<java.lang.String, java.util.regex.Pattern> blockedKeywordPatterns = patternCache.getAll(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.KEY_CHECK_BLOCKED_KEYWORD_PATTERN))); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values()); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("includes files containing blocked keywords", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException | java.util.concurrent.ExecutionException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on blocked keywords", e); } return java.util.Collections.emptyList(); }

@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); boolean rejectSubmodule = cfg.getBoolean(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.KEY_CHECK_SUBMODULE, false); if (!rejectSubmodule) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation(repo, receiveEvent.commit); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains submodules", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on submodules", e); } return java.util.Collections.emptyList(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); java.lang.String[] patterns = cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.KEY_INVALID_FILENAME_PATTERN); if ((patterns.length) == 0) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.performValidation(repo, receiveEvent.commit, patterns); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains files with an invalid filename", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on invalid file names", e); } return java.util.Collections.emptyList(); }




@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); boolean lineEndingCheck = cfg.getBoolean(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.KEY_CHECK_REJECT_WINDOWS_LINE_ENDINGS, false); if (!lineEndingCheck) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.performValidation(repo, receiveEvent.commit, com.google.common.collect.Sets.newHashSet(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.KEY_IGNORE_FILES))); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains files with a Windows line ending", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on Windows line endings", e); } return java.util.Collections.emptyList(); }


@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); boolean rejectSymlink = cfg.getBoolean(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.KEY_CHECK_SYMLINK, false); if (!rejectSymlink) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.performValidation(repo, receiveEvent.commit); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains symbolic links", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on symbolic links", e); } return java.util.Collections.emptyList(); }

private void forceCallerAsReviewer(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.PatchSetApproval> current, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> ups, java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> del) { if ((current.isEmpty()) && (ups.isEmpty())) { if (del.isEmpty()) { com.google.gerrit.reviewdb.client.PatchSetApproval c = new com.google.gerrit.reviewdb.client.PatchSetApproval(new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), ((short) (0)), ctx.getWhen()); c.setGranted(ctx.getWhen()); ups.add(c); } else { java.util.Iterator<com.google.gerrit.reviewdb.client.PatchSetApproval> i = del.iterator(); com.google.gerrit.reviewdb.client.PatchSetApproval c = i.next(); c.setValue(((short) (0))); c.setGranted(ctx.getWhen()); i.remove(); ups.add(c); } } ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), com.google.gerrit.server.change.REVIEWER); }
private boolean insertMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.String msg = com.google.common.base.Strings.nullToEmpty(in.message).trim(); java.lang.StringBuilder buf = new java.lang.StringBuilder(); for (java.lang.String d : labelDelta) { buf.append(" ").append(d); } if ((comments.size()) == 1) { buf.append("\n\n(1 comment)"); } else if ((comments.size()) > 1) { buf.append(java.lang.String.format("\n\n(%d comments)", comments.size())); } if (!(msg.isEmpty())) { buf.append("\n\n").append(msg); } if ((buf.length()) == 0) { return false; } message = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(psId.getParentKey(), com.google.gerrit.server.ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId); message.setMessage(java.lang.String.format("Patch Set %d:%s", psId.get(), buf.toString())); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message); return true; }
@java.lang.Override public java.lang.String toString() { return (((((((((("ChangeMessage{" + "key=") + (key)) + ", author=") + (author)) + ", writtenOn=") + (writtenOn)) + ", patchset=") + (patchset)) + ", message=[") + (message)) + "]}"; }
private org.eclipse.jgit.revwalk.RevTree aFor(org.eclipse.jgit.revwalk.RevCommit b, org.eclipse.jgit.revwalk.RevWalk walk) throws java.io.IOException { switch (b.getParentCount()) { case 0 : return walk.parseTree(emptyTree()); case 1 : org.eclipse.jgit.revwalk.RevCommit a = b.getParent(0); walk.parseBody(a); return walk.parseTree(a.getTree()); case 2 : return com.google.gerrit.server.patch.PatchListLoader.automerge(repo, walk, b, mergeStrategy); default : return null; } }


@java.lang.Override protected boolean beforeInit(com.google.gerrit.pgm.SiteInit init) throws java.lang.Exception { com.google.gerrit.pgm.util.ErrorLogFile.errorOnlyConsole(); if (!(skipPlugins)) { final java.util.List<com.google.gerrit.common.PluginData> plugins = com.google.gerrit.pgm.init.InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution); com.google.gerrit.pgm.init.api.ConsoleUI ui = com.google.gerrit.pgm.init.api.ConsoleUI.getInstance(false); verifyInstallPluginList(ui, plugins); if (listPlugins) { if (!(plugins.isEmpty())) { ui.message("Available plugins:\n"); for (com.google.gerrit.common.PluginData plugin : plugins) { ui.message(" * %s version %s\n", plugin.name, plugin.version); } } else { ui.message("No plugins found.\n"); } return true; } } return false; }
com.google.gerrit.server.git.EmailMerge create(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.reviewdb.client.Account.Id submitter);
@java.lang.Override public void run() { com.google.gerrit.server.util.RequestContext old = requestContext.setContext(this); try { com.google.gerrit.server.mail.MergedSender cm = mergedSenderFactory.create(project, changeId); if ((submitter) != null) { cm.setFrom(submitter); } cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.EmailMerge.log.error(("Cannot email merged notification for " + (changeId)), e); } finally { requestContext.setContext(old); if ((db) != null) { db.close(); db = null; } } }
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create(com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.git.MergeOp.CommitStatus commits, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.IdentifiedUser caller, com.google.gerrit.server.git.MergeTip mergeTip, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevFlag canMergeFlag, com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted, java.lang.String submissionId);
@java.lang.Override public final void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { postUpdateImpl(ctx); if ((command) != null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription()); } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId()).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot email merged notification for " + (getId())), e); } if ((mergeResultRev) != null) { try { args.hooks.doChangeMergedHook(updatedChange, args.accountCache.get(submitter.getAccountId()).getAccount(), mergedPatchSet, ctx.getDb(), mergeResultRev.name()); } catch (com.google.gwtorm.server.OrmException ex) { logError(("Cannot run hook for submitted patch set " + (getId())), ex); } } }
private com.google.gerrit.server.git.strategy.SubmitStrategy createStrategy(com.google.gerrit.server.git.MergeOp.OpenRepo or, com.google.gerrit.server.git.MergeTip mergeTip, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.server.git.CodeReviewCommit branchTip) throws com.google.gerrit.server.git.IntegrationException { return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId); }

@java.lang.Override protected void onLoad() { com.google.gerrit.client.diff.DiffApi.list(patchSetId, base, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.FileInfo> files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); fileNumber.setInnerText(java.lang.Integer.toString(((com.google.gerrit.client.rpc.Natives.asList(files).indexOf(result.get(path))) + 1))); fileCount.setInnerText(java.lang.Integer.toString(files.length())); int index = 0; for (int i = 0; i < (files.length()); i++) { if (path.equals(files.get(i).path())) { index = i; break; } } com.google.gerrit.client.info.FileInfo nextInfo = (index == ((files.length()) - 1)) ? null : files.get((index + 1)); com.google.gwtexpui.globalkey.client.KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), (index == 0 ? null : files.get((index - 1)))); com.google.gwtexpui.globalkey.client.KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo); if ((p != null) && (n != null)) { keys.pair(p, n); } nextPath = (nextInfo != null) ? nextInfo.path() : null; } }); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(patchSetId).view("files").addParameterTrue("reviewed").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { boolean b = com.google.gerrit.client.rpc.Natives.asList(result).contains(path); reviewed.setValue(b, false); if ((!b) && ((reviewedState) == (com.google.gerrit.client.diff.Header.ReviewedState.AUTO_REVIEW))) { postAutoReviewed(); } reviewedState = com.google.gerrit.client.diff.Header.ReviewedState.LOADED; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.FileInfo> files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); fileNumber.setInnerText(java.lang.Integer.toString(((com.google.gerrit.client.rpc.Natives.asList(files).indexOf(result.get(path))) + 1))); fileCount.setInnerText(java.lang.Integer.toString(files.length())); int index = 0; for (int i = 0; i < (files.length()); i++) { if (path.equals(files.get(i).path())) { index = i; break; } } com.google.gerrit.client.info.FileInfo nextInfo = (index == ((files.length()) - 1)) ? null : files.get((index + 1)); com.google.gwtexpui.globalkey.client.KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), (index == 0 ? null : files.get((index - 1)))); com.google.gwtexpui.globalkey.client.KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo); if ((p != null) && (n != null)) { keys.pair(p, n); } nextPath = (nextInfo != null) ? nextInfo.path() : null; }
void setupPrevNextFiles() { com.google.gerrit.client.info.FileInfo prevInfo = null; com.google.gerrit.client.info.FileInfo nextInfo = null; for (int i = (currIndex) - 1; i >= 0; i--) { com.google.gerrit.client.info.FileInfo curr = files.get(i); if ((prefs.skipDeleted()) && (curr.status().equals("D"))) { continue; } else { prevInfo = curr; break; } } for (int i = (currIndex) + 1; i < (files.length()); i++) { com.google.gerrit.client.info.FileInfo curr = files.get(i); if ((prefs.skipDeleted()) && (curr.status().equals("D"))) { continue; } else { nextInfo = curr; break; } } com.google.gwtexpui.globalkey.client.KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo); com.google.gwtexpui.globalkey.client.KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo); if ((p != null) && (n != null)) { keys.pair(p, n); } nextPath = (nextInfo != null) ? nextInfo.path() : null; }

void setupPrevNextFiles() { com.google.gerrit.client.info.FileInfo prevInfo = null; com.google.gerrit.client.info.FileInfo nextInfo = null; for (int i = (currIndex) - 1; i >= 0; i--) { com.google.gerrit.client.info.FileInfo curr = files.get(i); if (((prefs.skipDeleted()) && (curr.status().equals("D"))) || ((prefs.skipUncommented()) && (!(hasComments)))) { continue; } else { prevInfo = curr; break; } } for (int i = (currIndex) + 1; i < (files.length()); i++) { com.google.gerrit.client.info.FileInfo curr = files.get(i); if (((prefs.skipDeleted()) && (curr.status().equals("D"))) || ((prefs.skipUncommented()) && (!(hasComments)))) { continue; } else { nextInfo = curr; break; } } com.google.gwtexpui.globalkey.client.KeyCommand p = setupNav(prev, '[', PatchUtil.C.previousFileHelp(), prevInfo); com.google.gwtexpui.globalkey.client.KeyCommand n = setupNav(next, ']', PatchUtil.C.nextFileHelp(), nextInfo); if ((p != null) && (n != null)) { keys.pair(p, n); } nextPath = (nextInfo != null) ? nextInfo.path() : null; }


@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); java.lang.String[] blockedFileExtensions = cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.KEY_BLOCKED_FILE_EXTENSION); if ((blockedFileExtensions.length) > 0) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.LinkedList<>(); for (java.lang.String file : com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.getChangedPaths(repo, receiveEvent.commit)) { java.lang.String ext = com.google.common.io.Files.getFileExtension(file); for (int i = 0; i < (blockedFileExtensions.length); i++) { if (ext.equalsIgnoreCase(blockedFileExtensions[i])) { messages.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("blocked file: " + file), true)); break; } } } if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains files with blocked file extensions", messages); } } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on file extensions", e); } return java.util.Collections.emptyList(); }

@org.junit.Test public void test() throws java.lang.Exception { java.lang.String[] invalidFilenamePattern = new java.lang.String[]{ "[@:]", "[#%*]" }; org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern); java.util.Set<java.lang.String> expected = new java.util.HashSet<>(); for (java.lang.String filenames : getInvalidFilenames()) { expected.add(("ERROR: invalid characters found in filename: " + filenames)); } assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@org.junit.Test public void newChangeWithVote() throws java.lang.Exception { saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput().label(label.getName(), ((short) (-1))); revision(r).review(reviewInput); java.lang.String newVote = lastCommentAddedEvent.approvals.get()[0].value; java.lang.String oldVote = lastCommentAddedEvent.approvals.get()[0].oldValue; assertThat(oldVote).isEqualTo("0"); assertThat(newVote).isEqualTo("-1"); assertThat(lastCommentAddedEvent.comment).isEqualTo(java.lang.String.format("Patch Set 1: %s-1", label.getName())); }

@org.junit.Test public void newPatchSetWithVote() throws java.lang.Exception { saveLabelConfig(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput().message(label.getName()); revision(r).review(reviewInput); com.google.gerrit.extensions.common.ChangeInfo c = get(r.getChangeId()); r = amendChange(c.changeId); reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput().label(label.getName(), ((short) (1))); revision(r).review(reviewInput); java.lang.String newVote = lastCommentAddedEvent.approvals.get()[0].value; java.lang.String oldVote = lastCommentAddedEvent.approvals.get()[0].oldValue; assertThat(oldVote).isEqualTo("0"); assertThat(newVote).isEqualTo("1"); assertThat(lastCommentAddedEvent.comment).isEqualTo(java.lang.String.format("Patch Set 2: %s+1", label.getName())); }
@java.lang.Override protected void configure() { install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FooterValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.module()); }
@org.junit.Test public void testLoader() throws java.lang.Exception { com.google.common.cache.LoadingCache<java.lang.String, java.util.regex.Pattern> patternCache = com.google.common.cache.CacheBuilder.newBuilder().build(new com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.Loader()); for (java.lang.String pattern : BlockedKeywordValidatorTest.getPatterns().keySet()) { assertEquals(BlockedKeywordValidatorTest.getPatterns().get(pattern).pattern(), patternCache.get(pattern).pattern()); } }

public java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> byChange(final com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { if (!(migration.readAccounts())) { return com.google.common.collect.FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.StarredChange, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(com.google.gerrit.reviewdb.client.StarredChange in) { return in.getAccountId(); } }); } return com.google.common.collect.FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new com.google.common.base.Predicate<java.lang.String>() { @java.lang.Override public boolean apply(java.lang.String refPart) { return refPart.endsWith(("/" + (changeId.get()))); } }).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(java.lang.String refPart) { return Account.Id.fromRefPart(refPart); } }); }
public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.Change.Id> query(com.google.gerrit.reviewdb.client.Account.Id accountId) { try { if (!(readFromGit)) { return new com.google.gerrit.server.StarredChangesUtil.ChangeIdResultSet(dbProvider.get().starredChanges().byAccount(accountId)); } return new com.google.gwtorm.server.ListResultSet(com.google.common.collect.FluentIterable.from(getRefNames(com.google.gerrit.reviewdb.client.RefNames.refsStarredChangesPrefix(accountId))).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public Change.Id apply(java.lang.String changeId) { return Change.Id.parse(changeId); } }).toList()); } catch (com.google.gwtorm.server.OrmException | java.lang.RuntimeException e) { com.google.gerrit.server.StarredChangesUtil.log.warn(java.lang.String.format("Cannot query starred changes for account %d", accountId.get()), e); java.util.List<com.google.gerrit.reviewdb.client.Change.Id> empty = java.util.Collections.emptyList(); return new com.google.gwtorm.server.ListResultSet(empty); } }
public java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> byChange(final com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { if (!(readFromGit)) { return com.google.common.collect.FluentIterable.from(dbProvider.get().starredChanges().byChange(changeId)).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.StarredChange, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(com.google.gerrit.reviewdb.client.StarredChange in) { return in.getAccountId(); } }); } return com.google.common.collect.FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new com.google.common.base.Predicate<java.lang.String>() { @java.lang.Override public boolean apply(java.lang.String refPart) { return refPart.endsWith(("/" + (changeId.get()))); } }).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(java.lang.String refPart) { return Account.Id.fromRefPart(refPart); } }); }
public void unstarAll(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { dbProvider.get().starredChanges().delete(dbProvider.get().starredChanges().byChange(changeId)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.BatchRefUpdate batchUpdate = repo.getRefDatabase().newBatchUpdate(); batchUpdate.setAllowNonFastForwards(true); batchUpdate.setRefLogIdent(serverIdent); batchUpdate.setRefLogMessage(("Unstar change " + (changeId.get())), true); for (com.google.gerrit.reviewdb.client.Account.Id accountId : byChangeFromIndex(changeId)) { java.lang.String refName = com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(accountId, changeId); org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().getRef(refName); batchUpdate.addCommand(new org.eclipse.jgit.transport.ReceiveCommand(ref.getObjectId(), org.eclipse.jgit.lib.ObjectId.zeroId(), refName)); } batchUpdate.execute(rw, NullProgressMonitor.INSTANCE); for (org.eclipse.jgit.transport.ReceiveCommand command : batchUpdate.getCommands()) { if ((command.getResult()) != (ReceiveCommand.Result.OK)) { throw new java.io.IOException(java.lang.String.format("Unstar change %d failed, ref %s could not be deleted: %s", changeId.get(), command.getRefName(), command.getResult())); } } indexer.index(dbProvider.get(), project, changeId); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Unstar change %d failed", changeId.get()), e); } }
public void unstar(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { dbProvider.get().starredChanges().delete(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(accountId, changeId)))); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(accountId, changeId)); u.setForceUpdate(true); u.setRefLogIdent(serverIdent); u.setRefLogMessage(("Unstar change " + (changeId.get())), true); org.eclipse.jgit.lib.RefUpdate.Result result = u.delete(); switch (result) { case FORCED : indexer.index(dbProvider.get(), project, changeId); return; case FAST_FORWARD : case IO_FAILURE : case LOCK_FAILURE : case NEW : case NOT_ATTEMPTED : case NO_CHANGE : case REJECTED : case REJECTED_CURRENT_BRANCH : case RENAMED : default : throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name())); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e); } }
public void star(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { dbProvider.get().starredChanges().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(accountId, changeId)))); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { java.lang.String refName = com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(accountId, changeId); org.eclipse.jgit.lib.ObjectId oldObjectId = com.google.gerrit.server.StarredChangesUtil.getObjectId(repo, refName); java.util.SortedSet<java.lang.String> labels = com.google.gerrit.server.StarredChangesUtil.readLabels(repo, oldObjectId); labels.add(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL); updateLabels(repo, refName, oldObjectId, labels); indexer.index(dbProvider.get(), project, changeId); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e); } }
private void deleteOrUpdateDraftChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = ctx.getChange(); if (deletedOnlyPatchSet()) { deleteChangeOp = deleteChangeOpProvider.get(); deleteChangeOp.updateChange(ctx); return; } if (c.currentPatchSetId().equals(psId)) { c.setCurrentPatchSet(previousPatchSetInfo(ctx)); } ctx.saveChange(); }
public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.Change.Id> query(com.google.gerrit.reviewdb.client.Account.Id accountId) { try { if (!(migration.readAccounts())) { return new com.google.gerrit.server.StarredChangesUtil.ChangeIdResultSet(dbProvider.get().starredChanges().byAccount(accountId)); } return new com.google.gwtorm.server.ListResultSet(com.google.common.collect.FluentIterable.from(getRefNames(com.google.gerrit.reviewdb.client.RefNames.refsStarredChangesPrefix(accountId))).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public Change.Id apply(java.lang.String changeId) { return Change.Id.parse(changeId); } }).toList()); } catch (com.google.gwtorm.server.OrmException | java.lang.RuntimeException e) { com.google.gerrit.server.StarredChangesUtil.log.warn(java.lang.String.format("Cannot query starred changes for account %d", accountId.get()), e); java.util.List<com.google.gerrit.reviewdb.client.Change.Id> empty = java.util.Collections.emptyList(); return new com.google.gwtorm.server.ListResultSet(empty); } }
@java.lang.Override public boolean match(final com.google.gerrit.server.query.change.ChangeData object) { return user.getStarredChanges().contains(object.getId()); }

public void star(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException, java.io.IOException { dbProvider.get().starredChanges().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.StarredChange(new com.google.gerrit.reviewdb.client.StarredChange.Key(accountId, changeId)))); if (!(migration.writeAccounts())) { indexer.index(dbProvider.get(), project, changeId); return; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(accountId, changeId)); u.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); u.setNewObjectId(com.google.gerrit.server.StarredChangesUtil.emptyTree(repo)); u.setRefLogIdent(serverIdent); u.setRefLogMessage(("Star change " + (changeId.get())), false); org.eclipse.jgit.lib.RefUpdate.Result result = u.update(rw); switch (result) { case NEW : indexer.index(dbProvider.get(), project, changeId); return; case FAST_FORWARD : case FORCED : case IO_FAILURE : case LOCK_FAILURE : case NOT_ATTEMPTED : case NO_CHANGE : case REJECTED : case REJECTED_CURRENT_BRANCH : case RENAMED : default : throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Star change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name())); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e); } }


private final void deleteChanges(java.util.List<com.google.gerrit.server.query.change.ChangeData> changeData) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.server.query.change.ChangeData cd : changeData) { com.google.gerrit.reviewdb.client.Change.Id id = cd.getId(); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> patchSets = null; patchSets = db.patchSets().byChange(id); if (patchSets != null) { deleteFromPatchSets(patchSets); } db.patchComments().delete(db.patchComments().byChange(id)); db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id)); db.changeMessages().delete(db.changeMessages().byChange(id)); db.starredChanges().delete(db.starredChanges().byChange(id)); db.changes().delete(java.util.Collections.singleton(cd.change())); } }
private com.google.inject.Injector createWebInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); modules.add(com.google.gerrit.httpd.RequestContextFilter.module()); modules.add(com.google.gerrit.httpd.AllRequestFilter.module()); modules.add(com.google.gerrit.httpd.RequestMetricsFilter.module()); modules.add(sysInjector.getInstance(com.google.gerrit.httpd.GitOverHttpModule.class)); modules.add(sysInjector.getInstance(com.google.gerrit.httpd.WebModule.class)); modules.add(sysInjector.getInstance(com.google.gerrit.httpd.raw.StaticModule.class)); modules.add(sysInjector.getInstance(com.google.inject.Module.class)); if ((sshInjector) != null) { modules.add(sshInjector.getInstance(com.google.gerrit.httpd.WebSshGlueModule.class)); } else { modules.add(new com.google.gerrit.server.ssh.NoSshModule()); } modules.add(com.google.gerrit.httpd.H2CacheBasedWebSession.module()); modules.add(new com.google.gerrit.httpd.plugins.HttpPluginModule()); com.google.gerrit.server.config.AuthConfig authConfig = cfgInjector.getInstance(com.google.gerrit.server.config.AuthConfig.class); if ((authConfig.getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.OPENID)) { modules.add(new com.google.gerrit.httpd.auth.openid.OpenIdModule()); } else if ((authConfig.getAuthType()) == (com.google.gerrit.reviewdb.client.AuthType.OAUTH)) { modules.add(new com.google.gerrit.httpd.auth.oauth.OAuthModule()); } modules.add(sysInjector.getInstance(com.google.inject.Module.class)); return sysInjector.createChildInjector(modules); }
@java.lang.Override public java.lang.String get(com.google.gerrit.server.account.AccountState input, com.google.gerrit.server.index.account.FillArgs args) { return input.getUserName().toLowerCase(); }
@java.lang.Override protected void loadDefaults() { approvals = com.google.common.collect.ImmutableListMultimap.of(); reviewers = com.google.common.collect.ImmutableSetMultimap.of(); submitRecords = com.google.common.collect.ImmutableList.of(); allChangeMessages = com.google.common.collect.ImmutableList.of(); changeMessagesByPatchSet = com.google.common.collect.ImmutableListMultimap.of(); comments = com.google.common.collect.ImmutableListMultimap.of(); hashtags = com.google.common.collect.ImmutableSet.of(); }
private void initPatchSet() throws com.google.gwtorm.server.OrmException { if ((patchSet) == null) { patchSet = cd.currentPatchSet(); } }

static java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> performValidation(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c, java.util.Set<java.lang.String> ignoreFiles) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.LinkedList<>(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.ObjectId> content = com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.getChangedContent(repo, c); for (java.lang.String path : content.keySet()) { if (ignoreFiles.contains(org.apache.commons.io.FilenameUtils.getExtension(path))) { continue; } org.eclipse.jgit.lib.ObjectLoader ol = repo.open(content.get(path)); try (java.io.InputStreamReader isr = new java.io.InputStreamReader(ol.openStream(), java.nio.charset.StandardCharsets.UTF_8)) { if (com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.doesInputStreanContainCR(isr)) { messages.add(new com.google.gerrit.server.git.validators.CommitValidationMessage(("found carriage return (CR) character in file: " + path), true)); } } } return messages; }
static java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> performValidation(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c, com.google.common.collect.ImmutableCollection<java.util.regex.Pattern> blockedKeywordPartterns) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.LinkedList<>(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.ObjectId> content = com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.getChangedContent(repo, c); for (java.lang.String path : content.keySet()) { org.eclipse.jgit.lib.ObjectLoader ol = repo.open(content.get(path)); com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol); } return messages; }
@org.junit.Test public void testKeywords() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidatorTest.getPatterns().values()); assertThat(m).hasSize(2); java.util.List<com.googlesource.gerrit.plugins.uploadvalidator.ComparableCommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.googlesource.gerrit.plugins.uploadvalidator.ComparableCommitValidationMessage(("blocked keyword(s) found in file: foo.txt (Line: 1) " + "(found: myp4ssw0rd, foobar)"), true)); expected.add(new com.googlesource.gerrit.plugins.uploadvalidator.ComparableCommitValidationMessage(("blocked keyword(s) found in file: bar.txt (Line: 5) " + "(found: $Id: bla bla bla$)"), true)); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsAllIn(expected); }
@org.junit.Test public void testCarriageReturn() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.performValidation(repo, c, com.google.common.collect.Sets.newHashSet(new java.lang.String[]{ "" })); assertThat(m).hasSize(1); java.util.List<com.googlesource.gerrit.plugins.uploadvalidator.ComparableCommitValidationMessage> expected = new java.util.ArrayList<>(); expected.add(new com.googlesource.gerrit.plugins.uploadvalidator.ComparableCommitValidationMessage("found carriage return (CR) character in file: foo.txt", true)); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsAllIn(expected); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); if (!(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.doCheckInvalidLineEndings(cfg))) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.performValidation(repo, receiveEvent.commit, com.google.common.collect.Sets.newHashSet(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.KEY_IGNORE_FILES))); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains files with a Windows line ending", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on Windows line endings", e); } return java.util.Collections.emptyList(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); if (!(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.doCheckBlockedKeywords(cfg))) { return java.util.Collections.emptyList(); } com.google.common.collect.ImmutableMap<java.lang.String, java.util.regex.Pattern> blockedKeywordPatterns = patternCache.getAll(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.KEY_CHECK_BLOCKED_KEYWORD_PATTERN))); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values()); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("includes files containing blocked keywords", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException | java.util.concurrent.ExecutionException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on blocked keywords", e); } return java.util.Collections.emptyList(); }






private void initCreateTxt() { project = new com.google.gwtexpui.globalkey.client.NpTextBox() { @java.lang.Override public void onBrowserEvent(com.google.gwt.user.client.Event event) { super.onBrowserEvent(event); if ((event.getTypeInt()) == (com.google.gwt.user.client.Event.ONPASTE)) { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { if ((project.getValue().trim().length()) != 0) { create.setEnabled(true); } } }); } } }; project.sinkEvents(Event.ONPASTE); project.setVisibleLength(50); project.addKeyPressHandler(new com.google.gwt.event.dom.client.KeyPressHandler() { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doCreateProject(); } } }); new com.google.gerrit.client.ui.OnEditEnabler(create, project); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doCreateProject(); } }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { confirmSetUserName(); } }
@java.lang.Override public void onKeyPress(final com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { if (!(suggestionDisplay.isSuggestionSelected)) { doSearch(); } } }
private void init() { addKeyDownHandler(new com.google.gwt.event.dom.client.KeyDownHandler() { @java.lang.Override public void onKeyDown(com.google.gwt.event.dom.client.KeyDownEvent event) { int code = event.getNativeKeyCode(); onKey(event, code, code); } }); addKeyPressHandler(new com.google.gwt.event.dom.client.KeyPressHandler() { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { int charCode = event.getCharCode(); int keyCode = event.getNativeEvent().getKeyCode(); onKey(event, charCode, keyCode); } }); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSaveKeyPress(com.google.gwt.event.dom.client.KeyPressEvent e) { if ((e.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { e.stopPropagation(); } }
static int toMask(final com.google.gwt.event.dom.client.KeyPressEvent event) { int mask = event.getUnicodeCharCode(); if (mask == 0) { mask = event.getNativeEvent().getKeyCode(); } if (event.isControlKeyDown()) { mask |= KeyCommand.M_CTRL; } if (event.isMetaKeyDown()) { mask |= KeyCommand.M_META; } return mask; }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { widget.setEnabled(true); add(); } }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doAddNew(); } }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { int charCode = event.getCharCode(); int keyCode = event.getNativeEvent().getKeyCode(); onKey(event, charCode, keyCode); }
private void addCreateGroupPanel() { com.google.gwt.user.client.ui.VerticalPanel addPanel = new com.google.gwt.user.client.ui.VerticalPanel(); addPanel.setStyleName(Gerrit.RESOURCES.css().addSshKeyPanel()); addPanel.add(new com.google.gerrit.client.ui.SmallHeading(Util.C.headingCreateGroup())); addTxt = new com.google.gwtexpui.globalkey.client.NpTextBox() { @java.lang.Override public void onBrowserEvent(com.google.gwt.user.client.Event event) { super.onBrowserEvent(event); if ((event.getTypeInt()) == (com.google.gwt.user.client.Event.ONPASTE)) { com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { if ((addTxt.getValue().trim().length()) != 0) { addNew.setEnabled(true); } } }); } } }; addTxt.sinkEvents(Event.ONPASTE); addTxt.setVisibleLength(60); addTxt.addKeyPressHandler(new com.google.gwt.event.dom.client.KeyPressHandler() { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doCreateGroup(); } } }); addPanel.add(addTxt); addNew = new com.google.gwt.user.client.ui.Button(Util.C.buttonCreateGroup()); addNew.setEnabled(false); addNew.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { doCreateGroup(); } }); addPanel.add(addNew); add(addPanel); new com.google.gerrit.client.ui.OnEditEnabler(addNew, addTxt); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { if ((event.getNativeEvent().getKeyCode()) == (com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER)) { doCreateGroup(); } }
@java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cm.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); }
@java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); }
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { final com.google.gerrit.client.diff.DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); cm = newCm(((diff.metaA()) == null ? diff.metaB() : diff.metaA()), diff.textUnified(), diffTable.cm); setShowTabs(prefs.showTabs()); chunkManager = new com.google.gerrit.client.diff.UnifiedChunkManager(this, cm, diffTable.scrollbar); skipManager = new com.google.gerrit.client.diff.UnifiedSkipManager(this, commentManager); operation(new java.lang.Runnable() { @java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cm.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); } }); registerCmEvents(cm); setPrefsAction(new com.google.gerrit.client.diff.PreferencesAction(this, prefs)); header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks()); setAutoHideDiffHeader(prefs.autoHideDiffTableHeader()); setupSyntaxHighlighting(); }
abstract void render(int context, com.google.gerrit.client.diff.DiffInfo diff);
abstract com.google.gerrit.client.diff.SkipManager getSkipManager();
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { final com.google.gerrit.client.diff.DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(SideBySideTable.style.showLineNumbers()); } cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA); cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB); cmA.extras().side(DisplaySide.A); cmB.extras().side(DisplaySide.B); setShowTabs(prefs.showTabs()); chunkManager = new com.google.gerrit.client.diff.SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar); skipManager = new com.google.gerrit.client.diff.SideBySideSkipManager(this, commentManager); operation(new java.lang.Runnable() { @java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); } }); registerCmEvents(cmA); registerCmEvents(cmB); scrollSynchronizer = new com.google.gerrit.client.diff.ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper()); setPrefsAction(new com.google.gerrit.client.diff.PreferencesAction(this, prefs)); header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks()); scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader()); setupSyntaxHighlighting(); }
com.google.gerrit.client.diff.DisplaySide getSide() { return side; }
com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo getLineRegionInfoFromCmLine(int cmLine) { int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.UnifiedDiffChunkInfo(DisplaySide.A, 0, 0, 0, cmLine, false), getDiffChunkComparatorCmLine()); if (res >= 0) { com.google.gerrit.client.diff.UnifiedDiffChunkInfo info = chunks.get(res); return new com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo(info.start, com.google.gerrit.client.diff.UnifiedChunkManager.displaySideToRegionType(info.side)); } else { res = (-res) - 1; if (res > 0) { com.google.gerrit.client.diff.UnifiedDiffChunkInfo info = chunks.get((res - 1)); int lineOnInfoSide = ((info.start) + cmLine) - (info.cmLine); if (lineOnInfoSide > (info.end)) { if ((info.side) == (DisplaySide.A)) { return new com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo(getLineMapper().lineOnOther(DisplaySide.A, lineOnInfoSide).getLine(), com.google.gerrit.client.diff.UnifiedChunkManager.RegionType.COMMON); } else { return new com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo(lineOnInfoSide, com.google.gerrit.client.diff.UnifiedChunkManager.RegionType.COMMON); } } else { return new com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo(lineOnInfoSide, com.google.gerrit.client.diff.UnifiedChunkManager.displaySideToRegionType(info.side)); } } else { return new com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo(cmLine, com.google.gerrit.client.diff.UnifiedChunkManager.RegionType.COMMON); } } }
private int render(com.google.gerrit.client.diff.DiffInfo.Region region, int cmLine, boolean useIntralineBg) { com.google.gerrit.client.diff.LineMapper mapper = getLineMapper(); int startA = mapper.getLineA(); int startB = mapper.getLineB(); com.google.gwt.core.client.JsArrayString a = region.a(); com.google.gwt.core.client.JsArrayString b = region.b(); int aLen = (a != null) ? a.length() : 0; int bLen = (b != null) ? b.length() : 0; boolean insertOrDelete = (a == null) || (b == null); colorLines(cm, (insertOrDelete && (!useIntralineBg) ? UnifiedTable.style.diffDelete() : UnifiedTable.style.intralineDelete()), cmLine, aLen); colorLines(cm, (insertOrDelete && (!useIntralineBg) ? UnifiedTable.style.diffInsert() : UnifiedTable.style.intralineInsert()), (cmLine + aLen), bLen); markEdit(DisplaySide.A, cmLine, a, region.editA()); markEdit(DisplaySide.B, (cmLine + aLen), b, region.editB()); addGutterTag(region, cmLine); mapper.appendReplace(aLen, bLen); int endA = (mapper.getLineA()) - 1; int endB = (mapper.getLineB()) - 1; if (aLen > 0) { addDiffChunk(DisplaySide.A, endA, endB, aLen, cmLine, (bLen > 0)); for (int j = 0; j < aLen; j++) { host.setLineNumber(DisplaySide.A, (cmLine + j), ((startA + j) + 1)); } } if (bLen > 0) { addDiffChunk(DisplaySide.B, endB, endA, bLen, (cmLine + aLen), (aLen > 0)); for (int j = 0; j < bLen; j++) { host.setLineNumber(DisplaySide.B, ((cmLine + aLen) + j), ((startB + j) + 1)); } } return aLen + bLen; }
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { final com.google.gerrit.client.diff.DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(SideBySideTable.style.showLineNumbers()); } cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA); cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB); cmA.extras().side(DisplaySide.A); cmB.extras().side(DisplaySide.B); setShowTabs(prefs.showTabs()); chunkManager = new com.google.gerrit.client.diff.SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar); operation(new java.lang.Runnable() { @java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); } }); registerCmEvents(cmA); registerCmEvents(cmB); scrollSynchronizer = new com.google.gerrit.client.diff.ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper()); setPrefsAction(new com.google.gerrit.client.diff.PreferencesAction(this, prefs)); header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks()); scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader()); setupSyntaxHighlighting(); }
@java.lang.Override void render(com.google.gerrit.client.diff.DiffInfo diff) { super.render(); com.google.gerrit.client.diff.LineMapper mapper = getLineMapper(); chunks = new java.util.ArrayList(); int cmLine = 0; boolean useIntralineBg = ((diff.metaA()) == null) || ((diff.metaB()) == null); for (com.google.gerrit.client.diff.DiffInfo.Region current : com.google.gerrit.client.rpc.Natives.asList(diff.content())) { int origLineA = mapper.getLineA(); int origLineB = mapper.getLineB(); if ((current.ab()) != null) { int length = current.ab().length(); mapper.appendCommon(length); for (int i = 0; i < length; i++) { host.setLineNumber(DisplaySide.A, (cmLine + i), ((origLineA + i) + 1)); host.setLineNumber(DisplaySide.B, (cmLine + i), ((origLineB + i) + 1)); } cmLine += length; } else if ((current.skip()) > 0) { mapper.appendCommon(current.skip()); cmLine += current.skip(); } else if (current.common()) { mapper.appendCommon(current.b().length()); cmLine += current.b().length(); } else { cmLine += render(current, cmLine, useIntralineBg); } } }
private void render(com.google.gerrit.client.diff.DiffInfo.Region region, java.lang.String diffColor) { com.google.gerrit.client.diff.LineMapper mapper = getLineMapper(); int startA = mapper.getLineA(); int startB = mapper.getLineB(); com.google.gwt.core.client.JsArrayString a = region.a(); com.google.gwt.core.client.JsArrayString b = region.b(); int aLen = (a != null) ? a.length() : 0; int bLen = (b != null) ? b.length() : 0; java.lang.String color = ((a == null) || (b == null)) ? diffColor : SideBySideTable.style.intralineBg(); colorLines(cmA, color, startA, aLen); colorLines(cmB, color, startB, bLen); markEdit(cmA, startA, a, region.editA()); markEdit(cmB, startB, b, region.editB()); addPadding(cmA, ((startA + aLen) - 1), (bLen - aLen)); addPadding(cmB, ((startB + bLen) - 1), (aLen - bLen)); addGutterTag(region, startA, startB); mapper.appendReplace(aLen, bLen); int endA = (mapper.getLineA()) - 1; int endB = (mapper.getLineB()) - 1; if (aLen > 0) { addDiffChunk(cmB, endB, endA, aLen, (bLen > 0)); } if (bLen > 0) { addDiffChunk(cmA, endA, endB, bLen, (aLen > 0)); } }
@java.lang.Override void render(com.google.gerrit.client.diff.DiffInfo diff) { super.render(); com.google.gerrit.client.diff.LineMapper mapper = getLineMapper(); chunks = new java.util.ArrayList(); padding = new java.util.ArrayList(); paddingDivs = new java.util.ArrayList(); java.lang.String diffColor = (((diff.metaA()) == null) || ((diff.metaB()) == null)) ? SideBySideTable.style.intralineBg() : SideBySideTable.style.diff(); for (com.google.gerrit.client.diff.DiffInfo.Region current : com.google.gerrit.client.rpc.Natives.asList(diff.content())) { if ((current.ab()) != null) { mapper.appendCommon(current.ab().length()); } else if ((current.skip()) > 0) { mapper.appendCommon(current.skip()); } else if (current.common()) { mapper.appendCommon(current.b().length()); } else { render(current, diffColor); } } if (paddingDivs.isEmpty()) { paddingDivs = null; } }
@java.lang.Override int getCmLine(int line, com.google.gerrit.client.diff.DisplaySide side) { int res = java.util.Collections.binarySearch(chunks, new com.google.gerrit.client.diff.UnifiedDiffChunkInfo(side, line, 0, 0, 0, false)); if (res >= 0) { return chunks.get(res).cmLine; } else { res = (-res) - 1; if (res > 0) { com.google.gerrit.client.diff.UnifiedDiffChunkInfo info = chunks.get((res - 1)); if (((side == (DisplaySide.A)) && (info.edit)) && ((info.side) == (DisplaySide.B))) { com.google.gerrit.client.diff.UnifiedDiffChunkInfo delete = chunks.get((res - 2)); if (line <= (delete.end)) { return ((delete.cmLine) + line) - (delete.start); } else { return (((((delete.cmLine) + line) - (delete.start)) + (info.end)) - (info.start)) + 1; } } else if (side == (info.side)) { return ((info.cmLine) + line) - (info.start); } else { return ((info.cmLine) + (getLineMapper().lineOnOther(side, line).getLine())) - (info.start); } } else { return line; } } }
com.google.gerrit.client.diff.LineMapper.LineOnOtherInfo lineOnOther(com.google.gerrit.client.diff.DisplaySide side, int line) { return getChunkManager().getLineMapper().lineOnOther(side, line); }
@org.junit.Test public void testGcWithoutCapability_Error() throws java.lang.Exception { com.google.gerrit.acceptance.SshSession s = new com.google.gerrit.acceptance.SshSession(server, user); s.exec("gerrit gc --all"); assertError(("One of the following capabilities is required to access this" + " resource: [runGC, maintainServer]"), s.getError()); s.close(); }


@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.access.ListAccess.ProjectAccessInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.server.access.ListAccess.ProjectAccessInfo> access = com.google.common.collect.Maps.newTreeMap(); for (java.lang.String p : projects) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = new com.google.gerrit.reviewdb.client.Project.NameKey(p); try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) { com.google.gerrit.server.project.ProjectControl pc = open(projectName); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); if (config.updateGroupNames(groupBackend)) { md.setMessage("Update group names\n"); config.commit(md); projectCache.evict(config.getProject()); pc = open(projectName); } else if (((config.getRevision()) != null) && (!(config.getRevision().equals(pc.getProjectState().getConfig().getRevision())))) { projectCache.evict(config.getProject()); pc = open(projectName); } access.put(p, new com.google.gerrit.server.access.ListAccess.ProjectAccessInfo(pc, config)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(p); } } return access; }





@java.lang.Override void setShowLineNumbers(boolean b) { cmA.setOption("lineNumbers", b); cmB.setOption("lineNumbers", b); if (b) { diffTable.addStyleName(SideBySideTable.style.showLineNumbers()); } else { diffTable.removeStyleName(SideBySideTable.style.showLineNumbers()); } }
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { final com.google.gerrit.client.diff.DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); cm = newCm(((diff.metaA()) == null ? diff.metaB() : diff.metaA()), diff.textUnified(), diffTable.cm); setShowTabs(prefs.showTabs()); chunkManager = new com.google.gerrit.client.diff.UnifiedChunkManager(this, cm, diffTable.scrollbar); skipManager = new com.google.gerrit.client.diff.UnifiedSkipManager(this, commentManager); operation(new java.lang.Runnable() { @java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cm.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); } }); registerCmEvents(cm); setPrefsAction(new com.google.gerrit.client.diff.PreferencesAction(this, prefs)); header.init(getPrefsAction(), getSideBySideDiffLink(), diff.unifiedWebLinks()); setAutoHideDiffHeader(prefs.autoHideDiffTableHeader()); setupSyntaxHighlighting(); }

@java.lang.Override void render(com.google.gerrit.client.diff.DiffInfo diff) { super.render(); com.google.gerrit.client.diff.LineMapper mapper = getLineMapper(); chunks = new java.util.ArrayList(); int cmLine = 0; boolean useIntralineBg = ((diff.metaA()) == null) || ((diff.metaB()) == null); for (com.google.gerrit.client.diff.DiffInfo.Region current : com.google.gerrit.client.rpc.Natives.asList(diff.content())) { int origLineA = mapper.getLineA(); int origLineB = mapper.getLineB(); if ((current.ab()) != null) { int length = current.ab().length(); mapper.appendCommon(length); for (int i = 0; i < length; i++) { host.setLineNumber(DisplaySide.A, (cmLine + i), ((origLineA + i) + 1)); host.setLineNumber(DisplaySide.B, (cmLine + i), ((origLineB + i) + 1)); } cmLine += length; } else if ((current.skip()) > 0) { mapper.appendCommon(current.skip()); cmLine += current.skip(); } else if (current.common()) { mapper.appendCommon(current.b().length()); cmLine += current.b().length(); } else { cmLine += render(current, cmLine, useIntralineBg); } } }
@java.lang.Override public void handle(net.codemirror.lib.CodeMirror instance, final int line, final java.lang.String gutterClass, com.google.gwt.dom.client.NativeEvent clickEvent) { if ((((((clickEvent.getButton()) == (com.google.gwt.dom.client.NativeEvent.BUTTON_LEFT)) && (!(clickEvent.getMetaKey()))) && (!(clickEvent.getAltKey()))) && (!(clickEvent.getCtrlKey()))) && (!(clickEvent.getShiftKey()))) { cm.setCursor(net.codemirror.lib.Pos.create(line)); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { getCommentManager().newDraftOnGutterClick(cm, gutterClass, (line + 1)); } }); } }
private void display(final com.google.gerrit.client.diff.CommentsCollections comments) { final com.google.gerrit.client.diff.DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(SideBySideTable.style.showLineNumbers()); } cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA); cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB); cmA.extras().side(DisplaySide.A); cmB.extras().side(DisplaySide.B); setShowTabs(prefs.showTabs()); chunkManager = new com.google.gerrit.client.diff.SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar); skipManager = new com.google.gerrit.client.diff.SideBySideSkipManager(this, commentManager); operation(new java.lang.Runnable() { @java.lang.Override public void run() { int height = (com.google.gwt.user.client.Window.getClientHeight()) - ((com.google.gerrit.client.Gerrit.getHeaderFooterHeight()) + 18); cmA.setHeight(height); cmB.setHeight(height); render(diff); commentManager.render(comments, prefs.expandAllComments()); skipManager.render(prefs.context(), diff); } }); registerCmEvents(cmA); registerCmEvents(cmB); scrollSynchronizer = new com.google.gerrit.client.diff.ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper()); setPrefsAction(new com.google.gerrit.client.diff.PreferencesAction(this, prefs)); header.init(getPrefsAction(), getUnifiedDiffLink(), diff.sideBySideWebLinks()); scrollSynchronizer.setAutoHideDiffTableHeader(prefs.autoHideDiffTableHeader()); setupSyntaxHighlighting(); }
@java.lang.Override void setShowLineNumbers(boolean b) { }
private net.codemirror.lib.CodeMirror.GutterClickHandler onGutterClick(final net.codemirror.lib.CodeMirror cm) { return new net.codemirror.lib.CodeMirror.GutterClickHandler() { @java.lang.Override public void handle(net.codemirror.lib.CodeMirror instance, final int line, final java.lang.String gutterClass, com.google.gwt.dom.client.NativeEvent clickEvent) { if ((((((clickEvent.getButton()) == (com.google.gwt.dom.client.NativeEvent.BUTTON_LEFT)) && (!(clickEvent.getMetaKey()))) && (!(clickEvent.getAltKey()))) && (!(clickEvent.getCtrlKey()))) && (!(clickEvent.getShiftKey()))) { cm.setCursor(net.codemirror.lib.Pos.create(line)); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { getCommentManager().newDraftOnGutterClick(cm, gutterClass, (line + 1)); } }); } } }; }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent e) { e.stopPropagation(); if ((((e.getCharCode()) == '\n') || ((e.getCharCode()) == (KEY_ENTER))) && (e.isControlKeyDown())) { e.preventDefault(); if (post.isEnabled()) { onPost(null); } } }
public com.google.gerrit.reviewdb.client.PatchSet currentPatchSet() throws com.google.gwtorm.server.OrmException { if ((currentPatchSet) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } for (com.google.gerrit.reviewdb.client.PatchSet p : patches()) { if (p.getId().equals(c.currentPatchSetId())) { currentPatchSet = p; return p; } } } return currentPatchSet; }

@java.lang.Override public java.util.Map<java.lang.String, com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo> apply(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo> out = com.google.common.collect.Maps.newHashMap(); try (com.googlesource.gerrit.plugins.verifystatus.server.CiDb db = schemaFactory.open()) { for (com.googlesource.gerrit.plugins.verifystatus.server.PatchSetVerification v : db.patchSetVerifications().byPatchSet(rsrc.getPatchSet().getId())) { com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo info = new com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo(); info.value = v.getValue(); info.url = v.getUrl(); info.verifier = v.getVerifier(); info.comment = v.getComment(); info.granted = com.googlesource.gerrit.plugins.verifystatus.server.GetVerifications.DATE_FORMAT.format(v.getGranted()); out.put(v.getLabelId().get(), info); } } return out; }
private void parseWithEquals(java.lang.String text) { com.googlesource.gerrit.plugins.verifystatus.commands.SaveCommand.log.debug(("processing verification: " + text)); checkArgument((!(com.google.common.base.Strings.isNullOrEmpty(text))), "Empty verification data"); java.util.Map<java.lang.String, java.lang.String> params = null; try { params = com.google.common.base.Splitter.on("|").withKeyValueSeparator("=").split(text); } catch (java.lang.IllegalArgumentException e) { throw new java.lang.IllegalArgumentException(java.lang.String.valueOf("Invalid verification parameters")); } java.lang.String category = params.get("category"); checkArgument((category != null), "Verification is missing a category"); java.lang.String value = params.get("value"); checkArgument((value != null), "Verification is missing a value"); com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo data = new com.googlesource.gerrit.plugins.verifystatus.common.VerificationInfo(); data.value = java.lang.Short.parseShort(value); data.url = params.get("url"); data.verifier = params.get("verifier"); data.comment = params.get("comment"); jobResult.put(category, data); }
public java.lang.String getVerifier() { return verifier; }
public void setVerifier(java.lang.String reporter) { this.verifier = reporter; }


private com.google.gerrit.client.diff.UnifiedCommentGroup group(com.google.gerrit.client.diff.DisplaySide side, int cmLinePlusOne) { com.google.gerrit.client.diff.UnifiedCommentGroup w = map(side).get(cmLinePlusOne); if (w != null) { return w; } com.google.gerrit.client.diff.UnifiedCommentGroup g = new com.google.gerrit.client.diff.UnifiedCommentGroup(this, host.getCm(), side, cmLinePlusOne); if (side == (DisplaySide.A)) { sideA.put(cmLinePlusOne, g); } else { sideB.put(cmLinePlusOne, g); } if (isAttached()) { g.init(getDiffScreen().getDiffTable()); g.handleRedraw(); } return g; }
@java.lang.Override void clearLine(com.google.gerrit.client.diff.DisplaySide side, int cmLinePlusOne, com.google.gerrit.client.diff.CommentGroup group) { java.util.SortedMap<java.lang.Integer, com.google.gerrit.client.diff.UnifiedCommentGroup> map = map(side); if ((map.get(cmLinePlusOne)) == group) { map.remove(cmLinePlusOne); } }
@java.lang.Override void clearLine(com.google.gerrit.client.diff.DisplaySide side, int line, com.google.gerrit.client.diff.CommentGroup group) { java.util.SortedMap<java.lang.Integer, com.google.gerrit.client.diff.SideBySideCommentGroup> map = map(side); if ((map.get(line)) == group) { map.remove(line); } }
@java.lang.Override void insertNewDraft(com.google.gerrit.client.diff.DisplaySide side, int line) { if (line == 0) { host.skipManager.ensureFirstLineIsVisible(); } com.google.gerrit.client.diff.SideBySideCommentGroup group = group(side, line); if (0 < (group.getBoxCount())) { com.google.gerrit.client.diff.CommentBox last = group.getCommentBox(((group.getBoxCount()) - 1)); if (last instanceof com.google.gerrit.client.diff.DraftBox) { ((com.google.gerrit.client.diff.DraftBox) (last)).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (last)).doReply(); } } else { addDraftBox(side, com.google.gerrit.client.changes.CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), line, null)).setEdit(true); } }
private com.google.gerrit.client.diff.SideBySideCommentGroup group(com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.client.diff.SideBySideCommentGroup existing = map(side).get(line); if (existing != null) { return existing; } com.google.gerrit.client.diff.SideBySideCommentGroup newGroup = newGroup(side, line); java.util.Map<java.lang.Integer, com.google.gerrit.client.diff.SideBySideCommentGroup> map = (side == (DisplaySide.A)) ? sideA : sideB; java.util.Map<java.lang.Integer, com.google.gerrit.client.diff.SideBySideCommentGroup> otherMap = (side == (DisplaySide.A)) ? sideB : sideA; map.put(line, newGroup); int otherLine = (host.lineOnOther(side, (line - 1)).getLine()) + 1; existing = map(side.otherSide()).get(otherLine); com.google.gerrit.client.diff.SideBySideCommentGroup otherGroup; if (existing != null) { otherGroup = existing; } else { otherGroup = newGroup(side.otherSide(), otherLine); otherMap.put(otherLine, otherGroup); } com.google.gerrit.client.diff.SideBySideCommentGroup.pair(newGroup, otherGroup); if (isAttached()) { newGroup.init(host.getDiffTable()); otherGroup.handleRedraw(); } return newGroup; }

abstract java.lang.Runnable toggleOpenBox(final net.codemirror.lib.CodeMirror cm);

abstract java.lang.Runnable newDraftCallback(final net.codemirror.lib.CodeMirror cm);
abstract void insertNewDraft(com.google.gerrit.client.diff.DisplaySide side, int line);

abstract java.lang.Runnable openCloseAll(final net.codemirror.lib.CodeMirror cm);
@java.lang.Override void insertNewDraft(com.google.gerrit.client.diff.DisplaySide side, int cmLinePlusOne) { if (cmLinePlusOne == 0) { getDiffScreen().skipManager.ensureFirstLineIsVisible(); } com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); if (0 < (group.getBoxCount())) { com.google.gerrit.client.diff.CommentBox last = group.getCommentBox(((group.getBoxCount()) - 1)); if (last instanceof com.google.gerrit.client.diff.DraftBox) { ((com.google.gerrit.client.diff.DraftBox) (last)).setEdit(true); } else { ((com.google.gerrit.client.diff.PublishedBox) (last)).doReply(); } } else { com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo info = host.getLineRegionInfoFromCmLine((cmLinePlusOne - 1)); int line = info.line; if ((info.getSide()) != side) { line = host.lineOnOther(info.getSide(), line).getLine(); } addDraftBox(side, com.google.gerrit.client.changes.CommentInfo.create(getPath(), getStoredSideFromDisplaySide(side), (line + 1), null)).setEdit(true); } }
@java.lang.Override public com.google.gerrit.extensions.api.access.ProjectAccessInfo access() throws com.google.gerrit.extensions.restapi.RestApiException { return accessApi.create(checkExists()).get(); }
public com.google.gerrit.server.change.PostReview.Output apply(com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input, java.sql.Timestamp ts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { ts = com.google.common.collect.Ordering.natural().max(ts, revision.getChange().getCreatedOn()); if (revision.getEdit().isPresent()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot post review on edit"); } if ((input.onBehalfOf) != null) { revision = onBehalfOf(revision, input); } if ((input.labels) != null) { checkLabels(revision, input.strictLabels, input.labels); } if ((input.comments) != null) { checkComments(revision, input.comments); } if ((input.notify) == null) { com.google.gerrit.server.change.PostReview.log.warn("notify = null; assuming notify = NONE"); input.notify = com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.NONE; } try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) { bu.addOp(revision.getChange().getId(), new com.google.gerrit.server.change.PostReview.Op(revision.getPatchSet().getId(), input)); bu.execute(); } com.google.gerrit.server.change.PostReview.Output output = new com.google.gerrit.server.change.PostReview.Output(); output.labels = input.labels; return output; }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { walk = new org.eclipse.jgit.revwalk.RevWalk(repo); try { for (org.eclipse.jgit.lib.Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) { org.eclipse.jgit.revwalk.RevObject o = walk.parseAny(ref.getObjectId()); if (o instanceof org.eclipse.jgit.revwalk.RevCommit) { walk.markStart(((org.eclipse.jgit.revwalk.RevCommit) (o))); } } org.eclipse.jgit.revwalk.RevCommit bCommit; while (((bCommit = walk.next()) != null) && (!(byId.isEmpty()))) { if (byId.containsKey(bCommit)) { getPathsAndIndex(bCommit); byId.removeAll(bCommit); } } for (org.eclipse.jgit.lib.ObjectId id : byId.keySet()) { getPathsAndIndex(id); } } finally { walk.close(); } return null; }
private org.eclipse.jgit.revwalk.RevTree aFor(org.eclipse.jgit.revwalk.RevCommit b, org.eclipse.jgit.revwalk.RevWalk walk) throws java.io.IOException { switch (b.getParentCount()) { case 0 : return walk.parseTree(emptyTree()); case 1 : org.eclipse.jgit.revwalk.RevCommit a = b.getParent(0); walk.parseBody(a); return walk.parseTree(a.getTree()); case 2 : org.eclipse.jgit.revwalk.RevCommit am = autoMerger.merge(repo, walk, b, mergeStrategy); return am == null ? null : am.getTree(); default : return null; } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> visiblePatches() throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(patches()).filter(new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.PatchSet>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.PatchSet input) { try { return changeControl().isPatchVisible(input, db); } catch (com.google.gwtorm.server.OrmException e) { return false; } } }).toList(); }


private boolean isVisible(final com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.project.NoSuchProjectException { return controlFor(project).isVisible(); } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, states); } catch (java.lang.Exception e) { throw com.google.common.base.Throwables.propagate(e); } return false; }


private java.util.List<com.google.gerrit.server.data.ChangeAttribute> executeSuccessfulQuery(java.lang.String params, com.google.gerrit.acceptance.SshSession session) throws java.lang.Exception { java.lang.String rawResponse = session.exec(("gerrit query --format=JSON " + params)); assert_().withFailureMessage(session.getError()).that(session.hasError()).isFalse(); return com.google.gerrit.acceptance.ssh.QueryIT.getChanges(rawResponse); }
void setLineLength(int length) { cm.extras().lineLength((Patch.COMMIT_MSG.equals(path) ? 72 : length)); }
void setShowLineNumbers(boolean show) { cm.setOption("lineNumbers", show); }
@java.lang.Override public void registerKeys() { super.registerKeys(); net.codemirror.lib.KeyMap localKeyMap = net.codemirror.lib.KeyMap.create(); localKeyMap.on("Ctrl-L", gotoLine()).on("Cmd-L", gotoLine()).on("Cmd-S", save()); if ((prefs.keyMapType()) != (com.google.gerrit.extensions.client.KeyMapType.EMACS)) { localKeyMap.on("Ctrl-S", save()); } cm.addKeyMap(localKeyMap); }

void setShowTabs(boolean show) { cm.extras().showTabs(show); }
@java.lang.Override public void onSuccess(java.lang.Void result) { cm.setOption("mode", mode); }
void setSyntaxHighlighting(boolean b) { net.codemirror.mode.ModeInfo modeInfo = net.codemirror.mode.ModeInfo.findMode(content.getContentType(), path); final java.lang.String mode = (modeInfo != null) ? modeInfo.mode() : null; if ((b && (mode != null)) && (!(mode.isEmpty()))) { injectMode(mode, new com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { cm.setOption("mode", mode); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { prefs.syntaxHighlighting(false); } }); } else { cm.setOption("mode", ((java.lang.String) (null))); } }
private java.lang.Runnable gotoLine() { return new java.lang.Runnable() { @java.lang.Override public void run() { java.lang.String n = com.google.gwt.user.client.Window.prompt(EditConstants.I.gotoLineNumber(), ""); if (n != null) { try { int line = java.lang.Integer.parseInt(n); line--; if (line >= 0) { cm.scrollToLine(line); } } catch (java.lang.NumberFormatException e) { } } } }; }
void resizeCodeMirror() { cm.adjustHeight(header.getOffsetHeight()); }
private void initEditor(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> file) { net.codemirror.mode.ModeInfo mode = null; java.lang.String content = ""; if ((file != null) && ((file.getResult()) != null)) { content = file.getResult().asString(); if (prefs.syntaxHighlighting()) { mode = net.codemirror.mode.ModeInfo.findMode(file.getContentType(), path); } } cm = net.codemirror.lib.CodeMirror.create(editor, net.codemirror.lib.Configuration.create().set("value", content).set("readOnly", false).set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("lineNumbers", prefs.hideLineNumbers()).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("matchBrackets", prefs.matchBrackets()).set("autoCloseBrackets", prefs.autoCloseBrackets()).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("keyMap", prefs.keyMapType().name().toLowerCase()).set("theme", prefs.theme().name().toLowerCase()).set("mode", (mode != null ? mode.mode() : null))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeEditResource rsrc) throws java.io.IOException { try { return com.google.gerrit.extensions.restapi.Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getChangeEdit().getRevision().get()), rsrc.getPath())); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException rnfe) { return com.google.gerrit.extensions.restapi.Response.none(); } }
@java.lang.Override protected void onUnload() { super.onUnload(); if ((cm) != null) { cm.getWrapperElement().removeFromParent(); } if ((resizeHandler) != null) { resizeHandler.removeHandler(); } if ((closeHandler) != null) { closeHandler.removeHandler(); } com.google.gwt.user.client.Window.enableScrolling(true); com.google.gerrit.client.Gerrit.setHeaderVisible(true); com.google.gerrit.client.JumpKeys.enable(true); }




void setShowWhitespaceErrors(final boolean show) { cm.operation(new java.lang.Runnable() { @java.lang.Override public void run() { cm.setOption("showTrailingSpace", show); } }); }
@java.lang.Override public void run() { java.lang.String n = com.google.gwt.user.client.Window.prompt(EditConstants.I.gotoLineNumber(), ""); if (n != null) { try { int line = java.lang.Integer.parseInt(n); line--; if (line >= 0) { cm.scrollToLine(line); } } catch (java.lang.NumberFormatException e) { } } }
@java.lang.Override public void onSuccess(java.lang.Void result) { net.codemirror.theme.ThemeLoader.loadTheme(prefs.theme(), themeCallback); group2.done(); group3.done(); }


java.lang.Runnable maybeNextVimSearch(final net.codemirror.lib.CodeMirror cm) { return new java.lang.Runnable() { @java.lang.Override public void run() { if (cm.vim().hasSearchHighlight()) { cm.vim().handleKey("n"); } else { getChunkManager().diffChunkNav(cm, Direction.NEXT).run(); } } }; }
@java.lang.Override public void run() { if (cm.vim().hasSearchHighlight()) { cm.vim().handleKey("n"); } else { getChunkManager().diffChunkNav(cm, Direction.NEXT).run(); } }

void load() throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); logDebug("Loading .gitmodules of {} for project {}", branch, project); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId id = repo.resolve(branch.get()); if (id == null) { throw new java.io.IOException(("Cannot open branch " + (branch.get()))); } org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(id); org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, com.google.gerrit.server.git.GitModules.GIT_MODULES, commit.getTree()); if ((tw == null) || (((tw.getRawMode(0)) & (org.eclipse.jgit.lib.FileMode.TYPE_MASK)) != (org.eclipse.jgit.lib.FileMode.TYPE_FILE))) { return; } org.eclipse.jgit.lib.BlobBasedConfig bbc = new org.eclipse.jgit.lib.BlobBasedConfig(null, repo, commit, com.google.gerrit.server.git.GitModules.GIT_MODULES); subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections(); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(("Could not read .gitmodule file of super project: " + (branch.getParentKey())), e); } }
public java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> getDestinationBranches(com.google.gerrit.reviewdb.client.Branch.NameKey src, com.google.gerrit.common.data.SubscribeSection s) throws java.io.IOException { java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> ret = new java.util.ArrayList<>(); logDebug(("Inspecting SubscribeSection " + s)); for (org.eclipse.jgit.transport.RefSpec r : s.getRefSpecs()) { logDebug(("Inspecting ref " + r)); if (r.matchSource(src.get())) { if ((r.getDestination()) == null) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(s.getProject())) { for (org.eclipse.jgit.lib.Ref ref : repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) { ret.add(new com.google.gerrit.reviewdb.client.Branch.NameKey(s.getProject(), ref.getName())); } } } else if (r.isWildcard()) { ret.add(new com.google.gerrit.reviewdb.client.Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination())); } else { ret.add(new com.google.gerrit.reviewdb.client.Branch.NameKey(s.getProject(), r.getDestination())); } } } logDebug(((("Returning possible branches: " + ret) + "for project ") + (s.getProject()))); return ret; }
private void openRepos(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.git.IntegrationException { for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { try { openRepo(project); } catch (com.google.gerrit.server.project.NoSuchProjectException noProject) { logWarn(((("Project " + (noProject.project())) + " no longer exists, ") + "abandoning open changes")); abandonAllOpenChangeForDeletedProject(noProject.project()); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException(("Error opening project " + project), e); } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws java.io.IOException { logDebug(("Calculating possible superprojects for " + branch)); java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> ret = new java.util.ArrayList<>(); com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.get(project).getConfig(); for (com.google.gerrit.common.data.SubscribeSection s : cfg.getSubscribeSections(branch)) { java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> branches = getDestinationBranches(branch, s); for (com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch : branches) { com.google.gerrit.server.git.GitModules m = gitmodulesFactory.create(targetBranch, updateId); m.load(); ret.addAll(m.subscribedTo(branch)); } } logDebug(((("Calculated superprojects for " + branch) + " are ") + ret)); return ret; }
protected void updateSuperProjects(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> updatedBranches, java.lang.String updateId) throws com.google.gerrit.server.git.SubmoduleException { if (!(enableSuperProjectSubscriptions)) { logDebug("Updating superprojects disabled"); return; } this.updateId = updateId; logDebug("Updating superprojects"); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Branch.NameKey, com.google.gerrit.reviewdb.client.SubmoduleSubscription> targets = com.google.common.collect.HashMultimap.create(); try { for (com.google.gerrit.reviewdb.client.Branch.NameKey updatedBranch : updatedBranches) { for (com.google.gerrit.reviewdb.client.SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) { targets.put(sub.getSuperProject(), sub); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException("Could not calculate all superprojects"); } updatedSubscribers.addAll(updatedBranches); for (com.google.gerrit.reviewdb.client.Branch.NameKey dest : targets.keySet()) { try { if (!(updatedSubscribers.add(dest))) { com.google.gerrit.server.git.SubmoduleOp.log.error(("Possible circular subscription involving " + dest)); } else { updateGitlinks(db, dest, targets.get(dest)); } } catch (com.google.gerrit.server.git.SubmoduleException e) { com.google.gerrit.server.git.SubmoduleOp.log.warn(("Cannot update gitlinks for " + dest), e); } } }
public com.google.gerrit.acceptance.TestAccount admin2() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create("admin2", "admin2@example.com", "Administrator2", "Administrators"); }
private void markInvalid(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.AccountSshKey k) { try { com.google.gerrit.sshd.SshKeyCacheImpl.log.info((("Flagging SSH key " + (k.getKey())) + " invalid")); k.setInvalid(); db.accountSshKeys().update(java.util.Collections.singleton(k)); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.sshd.SshKeyCacheImpl.log.error((("Failed to mark SSH key" + (k.getKey())) + " invalid"), e); } }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, username); final com.google.gerrit.reviewdb.client.AccountExternalId user = db.accountExternalIds().get(key); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } final java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : db.accountSshKeys().byAccount(user.getAccountId())) { if (k.isValid()) { add(db, kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
public com.google.gerrit.acceptance.TestAccount user2() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create("user2", "user2@example.com", "User2"); }
public com.google.gerrit.acceptance.TestAccount admin() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create("admin", "admin@example.com", "Administrator", "Administrators"); }
public com.google.gerrit.acceptance.TestAccount create(java.lang.String username, java.lang.String group) throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create(username, null, username, group); }
public com.google.gerrit.acceptance.TestAccount create(java.lang.String username) throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create(username, null, username, ((java.lang.String[]) (null))); }
public com.google.gerrit.acceptance.TestAccount user() throws com.google.gwtorm.server.OrmException, com.jcraft.jsch.JSchException, java.io.UnsupportedEncodingException { return create("user", "user@example.com", "User"); }
public java.util.List<com.google.gerrit.extensions.common.SshKeyInfo> apply(com.google.gerrit.server.IdentifiedUser user) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.extensions.common.SshKeyInfo> sshKeys = com.google.common.collect.Lists.newArrayList(); for (com.google.gerrit.reviewdb.client.AccountSshKey sshKey : dbProvider.get().accountSshKeys().byAccount(user.getAccountId()).toList()) { sshKeys.add(com.google.gerrit.server.account.GetSshKeys.newSshKeyInfo(sshKey)); } return sshKeys; }





public AccountResource.SshKey parse(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { try { int seq = java.lang.Integer.parseInt(id.get(), 10); com.google.gerrit.reviewdb.client.AccountSshKey sshKey = dbProvider.get().accountSshKeys().get(new com.google.gerrit.reviewdb.client.AccountSshKey.Id(user.getAccountId(), seq)); if (sshKey == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.account.AccountResource.SshKey(user, sshKey); } catch (java.lang.NumberFormatException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }


@org.junit.Test public void sshKeys() throws java.lang.Exception { java.util.List<com.google.gerrit.extensions.common.SshKeyInfo> info = gApi.accounts().self().listSshKeys(); assertThat(info).hasSize(1); com.google.gerrit.extensions.common.SshKeyInfo key = info.get(0); java.lang.String inital = com.google.gerrit.acceptance.AccountCreator.publicKey(admin.sshKey, admin.email); assertThat(key.sshPublicKey).isEqualTo(inital); java.lang.String newKey = com.google.gerrit.acceptance.AccountCreator.publicKey(com.google.gerrit.acceptance.AccountCreator.genSshKey(), admin.email); gApi.accounts().self().addSshKey(newKey); info = gApi.accounts().self().listSshKeys(); assertThat(info).hasSize(2); gApi.accounts().self().addSshKey(inital); info = gApi.accounts().self().listSshKeys(); assertThat(info).hasSize(3); }
public com.google.gerrit.reviewdb.client.AccountSshKey addKey(java.lang.String pub) { checkState(((keys) != null), "SSH keys not loaded yet"); int seq = (keys.isEmpty()) ? 1 : (keys.lastKey()) + 1; com.google.gerrit.reviewdb.client.AccountSshKey key = new com.google.gerrit.reviewdb.client.AccountSshKey(new com.google.gerrit.reviewdb.client.AccountSshKey.Id(accountId, seq), pub); keys.put(seq, com.google.common.base.Optional.of(key)); return key; }



@java.lang.Override public void removePublisher(final com.googlesource.gerrit.plugins.rabbitmq.message.Publisher publisher) { source.removeEventListener(publisher); }
@java.lang.Override protected void doGetJson(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);com.google.gitiles.PathServlet.WalkResult wr = com.google.gitiles.PathServlet.WalkResult.forPath(rw, view)) { if (wr == null) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); return; } switch (wr.type) { case TREE : renderJson(req, res, com.google.gitiles.TreeJsonData.toJsonData(wr.id, wr.tw), TreeJsonData.Tree.class); break; default : res.setStatus(com.google.gitiles.SC_NOT_FOUND); break; } } catch (org.eclipse.jgit.errors.LargeObjectException e) { res.setStatus(com.google.gitiles.SC_INTERNAL_SERVER_ERROR); } }







private void savePatchSet(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if (!(patchSet.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Patch set is not a draft"); } psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet); if (!(wasDraftChange)) { ctx.saveChange(); } }
private java.lang.String getToken(com.googlesource.gerrit.plugins.its.jira.JiraSession token) { return token == null ? null : token.getToken(); }
public void addComment(com.googlesource.gerrit.plugins.its.jira.JiraSession token, java.lang.String issueKey, com.atlassian.jira.rpc.soap.client.RemoteComment comment) throws java.rmi.RemoteException { service.addComment(getToken(token), issueKey, comment); }
public com.atlassian.jira.rpc.soap.client.RemoteNamedObject[] getAvailableActions(com.googlesource.gerrit.plugins.its.jira.JiraSession token, java.lang.String issueKey) throws java.rmi.RemoteException { return service.getAvailableActions(getToken(token), issueKey); }
public com.atlassian.jira.rpc.soap.client.RemoteIssue getIssue(com.googlesource.gerrit.plugins.its.jira.JiraSession token, java.lang.String issueKey) throws java.rmi.RemoteException { return service.getIssue(getToken(token), issueKey); }
private boolean isJiraConnectSuccessful() { ui.message("Checking Jira connectivity ... "); try { com.googlesource.gerrit.plugins.its.jira.JiraClient jiraClient = new com.googlesource.gerrit.plugins.its.jira.JiraClient(jiraUrl); com.googlesource.gerrit.plugins.its.jira.JiraSession jiraToken = jiraClient.login(jiraUsername, jiraPassword); jiraClient.logout(jiraToken); ui.message("[OK]\n"); return true; } catch (java.rmi.RemoteException e) { ui.message("*FAILED* (%s)\n", e.toString()); return false; } }
public com.atlassian.jira.rpc.soap.client.RemoteServerInfo getServerInfo(com.googlesource.gerrit.plugins.its.jira.JiraSession token) throws java.rmi.RemoteException { return service.getServerInfo(getToken(token)); }
public com.googlesource.gerrit.plugins.its.jira.JiraSession login(final java.lang.String username, final java.lang.String password) throws java.rmi.RemoteException { java.lang.String token = service.login(username, password); return new com.googlesource.gerrit.plugins.its.jira.JiraSession(username, token); }
public com.atlassian.jira.rpc.soap.client.RemoteIssue performAction(com.googlesource.gerrit.plugins.its.jira.JiraSession token, java.lang.String issueKey, java.lang.String actionId, com.atlassian.jira.rpc.soap.client.RemoteFieldValue... params) throws java.rmi.RemoteException { return service.progressWorkflowAction(getToken(token), issueKey, actionId, params); }
private void doPerformAction(final java.lang.String issueKey, final java.lang.String actionName) throws java.io.IOException, java.rmi.RemoteException { java.lang.String actionId = null; com.atlassian.jira.rpc.soap.client.RemoteNamedObject[] actions = client().getAvailableActions(token, issueKey); for (com.atlassian.jira.rpc.soap.client.RemoteNamedObject action : actions) { if (action.getName().equalsIgnoreCase(actionName)) { actionId = action.getId(); } } if (actionId != null) { log.debug(((("Executing action " + actionName) + " on issue ") + issueKey)); client().performAction(token, issueKey, actionId); } else { java.lang.StringBuilder sb = new java.lang.StringBuilder(); for (com.atlassian.jira.rpc.soap.client.RemoteNamedObject action : actions) { if ((sb.length()) > 0) sb.append(','); sb.append('\''); sb.append(action.getName()); sb.append('\''); } log.error(((("Action " + actionName) + " not found within available actions: ") + sb)); throw new com.googlesource.gerrit.plugins.its.base.its.InvalidTransitionException(((("Action " + actionName) + " not executable on issue ") + issueKey)); } }
@java.lang.Override public boolean exists(final java.lang.String issueKey) throws java.io.IOException { return execute(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws java.lang.Exception { return (client().getIssue(token, issueKey)) != null; } }); }
@java.lang.Override public java.lang.String healthCheck(final com.googlesource.gerrit.plugins.its.jira.Check check) throws java.io.IOException { return execute(new java.util.concurrent.Callable<java.lang.String>() { @java.lang.Override public java.lang.String call() throws java.lang.Exception { if (check.equals(Check.ACCESS)) return healthCheckAccess(); else return healthCheckSysinfo(); } }); }
@java.lang.Override public void addComment(final java.lang.String issueKey, final java.lang.String comment) throws java.io.IOException { execute(new java.util.concurrent.Callable<java.lang.String>() { @java.lang.Override public java.lang.String call() throws java.lang.Exception { log.debug(((("Adding comment " + comment) + " to issue ") + issueKey)); com.atlassian.jira.rpc.soap.client.RemoteComment remoteComment = new com.atlassian.jira.rpc.soap.client.RemoteComment(); remoteComment.setBody(comment); client().addComment(token, issueKey, remoteComment); log.debug(((("Added comment " + comment) + " to issue ") + issueKey)); return issueKey; } }); }
@java.lang.Override public void performAction(final java.lang.String issueKey, final java.lang.String actionName) throws java.io.IOException { execute(new java.util.concurrent.Callable<java.lang.String>() { @java.lang.Override public java.lang.String call() throws java.lang.Exception { doPerformAction(issueKey, actionName); return issueKey; } }); }
private com.googlesource.gerrit.plugins.its.jira.JiraClient client() throws java.io.IOException { if ((client) == null) { try { log.debug(("Connecting to jira at URL " + (getUrl()))); client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(getUrl()); log.debug(("Autenthicating as user " + (getUsername()))); } catch (java.lang.Exception ex) { log.info(((("Unable to connect to Connected to " + (getUrl())) + " as ") + (getUsername()))); throw new java.io.IOException(ex); } login(); } return client; }
private java.lang.String healthCheckSysinfo() throws java.io.IOException, java.rmi.RemoteException { final com.atlassian.jira.rpc.soap.client.RemoteServerInfo res = client().getServerInfo(token); final java.lang.String result = ((((("{\"status\"=\"ok\",\"system\"=\"Jira\",\"version\"=\"" + (res.getVersion())) + "\",\"url\"=\"") + (getUrl())) + "\",\"build\"=\"") + (res.getBuildNumber())) + "\"}"; log.debug("Healtheck on sysinfo result: {}", result); return result; }
private java.lang.String healthCheckAccess() throws java.rmi.RemoteException { com.googlesource.gerrit.plugins.its.jira.JiraClient client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(getUrl()); com.googlesource.gerrit.plugins.its.jira.JiraSession token = client.login(getUsername(), getPassword()); client.logout(token); final java.lang.String result = ("{\"status\"=\"ok\",\"username\"=\"" + (getUsername())) + "\"}"; log.debug("Healtheck on access result: {}", result); return result; }
private java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getDraftRefs(org.eclipse.jgit.lib.Repository repo, final com.google.gerrit.reviewdb.client.Change.Id changeId) throws java.io.IOException { final java.lang.String suffix = "/" + (changeId.get()); return com.google.common.collect.Maps.filterKeys(repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS), new com.google.common.base.Predicate<java.lang.String>() { @java.lang.Override public boolean apply(java.lang.String input) { return input.endsWith(suffix); } }); }
@java.lang.Override public void apply(org.eclipse.jgit.dircache.DirCacheEntry ent) { if ((ent.getRawMode()) == 0) { ent.setFileMode(FileMode.REGULAR_FILE); } ent.setObjectId(content); }



public java.lang.String getEncodedKey() { final java.lang.String s = getSshPublicKey(); if ((s == null) || ((s.length()) == 0)) { return null; } final java.lang.String[] parts = s.split(" "); if ((parts.length) < 2) { return null; } return parts[1]; }
public java.lang.String getComment() { final java.lang.String s = getSshPublicKey(); if ((s == null) || ((s.length()) == 0)) { return ""; } final java.lang.String[] parts = s.split(" ", 3); if ((parts.length) < 3) { return ""; } return parts[2]; }

public java.lang.String getAlgorithm() { final java.lang.String s = getSshPublicKey(); if ((s == null) || ((s.length()) == 0)) { return "none"; } final java.lang.String[] parts = s.split(" "); if ((parts.length) < 1) { return "none"; } return parts[0]; }
@java.lang.Override protected void configureServlets() { bind(com.googlesource.gerrit.plugins.manager.AvailablePluginsCollection.class); bind(com.googlesource.gerrit.plugins.manager.repository.PluginsRepository.class).to(com.googlesource.gerrit.plugins.manager.repository.JenkinsCiPluginsRepository.class); serve("/available*").with(com.googlesource.gerrit.plugins.manager.PluginManagerRestApiServlet.class); filterRegex(".*\\.js").through(com.googlesource.gerrit.plugins.manager.XAuthFilter.class); }
public com.google.gson.JsonElement display() { java.util.Map<java.lang.String, com.googlesource.gerrit.plugins.manager.repository.PluginInfo> output = com.google.common.collect.Maps.newTreeMap(); java.util.List<com.googlesource.gerrit.plugins.manager.repository.PluginInfo> plugins; try { plugins = loader.availablePlugins(); } catch (java.io.IOException e) { e.printStackTrace(); return null; } java.util.Collections.sort(plugins, new java.util.Comparator<com.googlesource.gerrit.plugins.manager.repository.PluginInfo>() { @java.lang.Override public int compare(com.googlesource.gerrit.plugins.manager.repository.PluginInfo a, com.googlesource.gerrit.plugins.manager.repository.PluginInfo b) { return a.name.compareTo(b.name); } }); for (com.googlesource.gerrit.plugins.manager.repository.PluginInfo p : plugins) { output.put(p.name, p); } return OutputFormat.JSON.newGson().toJsonTree(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
public java.util.List<com.googlesource.gerrit.plugins.manager.repository.PluginInfo> availablePlugins() throws java.io.IOException { return repository.list(com.google.gerrit.common.Version.getVersion()); }
@java.lang.Override protected void configureServlets() { bind(com.googlesource.gerrit.plugins.manager.AvailablePluginsCollection.class); bind(com.googlesource.gerrit.plugins.manager.repository.PluginsRepository.class).to(com.googlesource.gerrit.plugins.manager.repository.JenkinsCiPluginsRepository.class); serve("/available*").with(com.googlesource.gerrit.plugins.manager.PluginManagerRestApiServlet.class); filterRegex(".*\\.js").through(com.googlesource.gerrit.plugins.manager.XAuthFilter.class); }





public java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> starredBy() throws com.google.gwtorm.server.OrmException { if ((starredByUser) == null) { starredByUser = starredChangesUtil.byChange(legacyId); } return starredByUser; }

public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.Change.Id> query(com.google.gerrit.reviewdb.client.Account.Id accountId) { try { return new com.google.gwtorm.server.ListResultSet(com.google.common.collect.FluentIterable.from(getRefNames(com.google.gerrit.reviewdb.client.RefNames.refsStarredChangesPrefix(accountId))).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public Change.Id apply(java.lang.String changeId) { return Change.Id.parse(changeId); } }).toList()); } catch (com.google.gwtorm.server.OrmException | java.lang.RuntimeException e) { com.google.gerrit.server.StarredChangesUtil.log.warn(java.lang.String.format("Cannot query starred changes for account %d", accountId.get()), e); java.util.List<com.google.gerrit.reviewdb.client.Change.Id> empty = java.util.Collections.emptyList(); return new com.google.gwtorm.server.ListResultSet(empty); } }
public void unstar(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(accountId, changeId)); u.setForceUpdate(true); u.setRefLogIdent(serverIdent); u.setRefLogMessage(("Unstar change " + (changeId.get())), true); org.eclipse.jgit.lib.RefUpdate.Result result = u.delete(); switch (result) { case FORCED : indexer.index(dbProvider.get(), project, changeId); return; case FAST_FORWARD : case IO_FAILURE : case LOCK_FAILURE : case NEW : case NOT_ATTEMPTED : case NO_CHANGE : case REJECTED : case REJECTED_CURRENT_BRANCH : case RENAMED : default : throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Unstar change %d for account %d failed: %s", changeId.get(), accountId.get(), result.name())); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Unstar change %d for account %d failed", changeId.get(), accountId.get()), e); } }
public java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> byChange(final com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(getRefNames(RefNames.REFS_STARRED_CHANGES)).filter(new com.google.common.base.Predicate<java.lang.String>() { @java.lang.Override public boolean apply(java.lang.String refPart) { return refPart.endsWith(("/" + (changeId.get()))); } }).transform(new com.google.common.base.Function<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(java.lang.String refPart) { return Account.Id.fromRefPart(refPart); } }); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor(INTERACTIVE) com.google.common.util.concurrent.ListeningExecutorService getInteractiveIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { if ((interactiveExecutor) != null) { return interactiveExecutor; } int threads = this.threads; if (threads <= 0) { threads = config.getInt("index", null, "threads", 0); } if (threads <= 0) { return com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "Index-Interactive")); }
@java.lang.Override protected void configure() { switch (loginType) { case HTTP_LDAP : case LDAP : case LDAP_BIND : case CLIENT_SSL_CERT_LDAP : install(new com.google.gerrit.server.auth.ldap.LdapModule()); break; case OAUTH : bind(com.google.gerrit.server.account.Realm.class).to(com.google.gerrit.server.auth.oauth.OAuthRealm.class); break; case CUSTOM_EXTENSION : break; default : bind(com.google.gerrit.server.account.Realm.class).to(com.google.gerrit.server.account.DefaultRealm.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.auth.AuthBackend.class).to(com.google.gerrit.server.auth.InternalAuthBackend.class); break; } }


boolean login(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, com.google.gerrit.extensions.auth.oauth.OAuthServiceProvider oauth) throws java.io.IOException { com.google.gerrit.httpd.auth.oauth.OAuthSession.log.debug(("Login " + (this))); if (isOAuthFinal(request)) { if (!(checkState(request))) { response.sendError(HttpServletResponse.SC_NOT_FOUND); return false; } com.google.gerrit.httpd.auth.oauth.OAuthSession.log.debug(("Login-Retrieve-User " + (this))); token = oauth.getAccessToken(new com.google.gerrit.extensions.auth.oauth.OAuthVerifier(request.getParameter("code"))); user = oauth.getUserInfo(token); if (isLoggedIn()) { com.google.gerrit.httpd.auth.oauth.OAuthSession.log.debug(("Login-SUCCESS " + (this))); authenticateAndRedirect(request, response); return true; } else { response.sendError(com.google.gerrit.httpd.auth.oauth.SC_UNAUTHORIZED); return false; } } else { com.google.gerrit.httpd.auth.oauth.OAuthSession.log.debug(("Login-PHASE1 " + (this))); redirectToken = request.getRequestURI(); redirectToken = redirectToken.substring(request.getContextPath().length()); response.sendRedirect((((oauth.getAuthorizationUrl()) + "&state=") + (state))); return false; } }



private void fill(com.google.gerrit.extensions.common.AccountInfo info, com.google.gerrit.reviewdb.client.Account account, java.util.Set<com.google.gerrit.server.account.FillOptions> options) { if (options.contains(FillOptions.ID)) { info._accountId = account.getId().get(); } else { info._accountId = null; } if (options.contains(FillOptions.NAME)) { info.name = com.google.common.base.Strings.emptyToNull(account.getFullName()); if ((info.name) == null) { info.name = account.getUserName(); } } if (options.contains(FillOptions.EMAIL)) { info.email = account.getPreferredEmail(); } if (options.contains(FillOptions.USERNAME)) { info.username = account.getUserName(); } if (options.contains(FillOptions.AVATARS)) { com.google.gerrit.server.avatar.AvatarProvider ap = avatar.get(); if (ap != null) { info.avatars = com.google.common.collect.Lists.newArrayListWithCapacity(1); java.lang.String u = ap.getUrl(userFactory.create(account.getId()), AvatarInfo.DEFAULT_SIZE); if (u != null) { com.google.gerrit.extensions.common.AvatarInfo a = new com.google.gerrit.extensions.common.AvatarInfo(); a.url = u; a.height = com.google.gerrit.extensions.common.AvatarInfo.DEFAULT_SIZE; info.avatars.add(a); } } } }






public void execute() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try { executeRefUpdates(); executeChangeOps(); reindexChanges(); if ((batchRefUpdate) != null) { gitRefUpdated.fire(project, batchRefUpdate); } executePostOps(); } catch (com.google.gerrit.server.git.UpdateException | com.google.gerrit.extensions.restapi.RestApiException e) { throw e; } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e); throw new com.google.gerrit.server.git.UpdateException(e); } }
public void setAuthor(com.google.gerrit.server.IdentifiedUser user) { getCommitBuilder().setAuthor(user.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone())); }
void fireGitRefUpdatedEvent(org.eclipse.jgit.lib.RefUpdate ru) { gitRefUpdated.fire(projectName, ru); }
private void fireRefUpdated(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, org.eclipse.jgit.lib.RefUpdate branchUpdate) { logDebug("Firing ref updated hooks for {}", branchUpdate.getName()); gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate); hooks.doRefUpdatedHook(destBranch, branchUpdate, getAccount(mergeTips.get(destBranch).getCurrentTip())); }


static com.google.gerrit.extensions.client.DiffPreferencesInfo readFromGit(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.server.git.GitRepositoryManager gitMgr, com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.extensions.client.DiffPreferencesInfo in) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (org.eclipse.jgit.lib.Repository git = gitMgr.openRepository(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forUser(id); p.load(git); com.google.gerrit.extensions.client.DiffPreferencesInfo prefs = new com.google.gerrit.extensions.client.DiffPreferencesInfo(); loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults(), in); return prefs; } }


public java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch, com.google.gerrit.server.git.MergeOpRepoManager orm) throws java.io.IOException { logDebug(("Calculating possible superprojects for " + branch)); java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> ret = new java.util.ArrayList<>(); com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.get(project).getConfig(); for (com.google.gerrit.common.data.SubscribeSection s : cfg.getSubscribeSections(branch)) { java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> branches = getDestinationBranches(branch, s, orm); for (com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch : branches) { com.google.gerrit.server.git.GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm); m.load(); ret.addAll(m.subscribedTo(branch)); } } logDebug(((("Calculated superprojects for " + branch) + " are ") + ret)); return ret; }
private void updateProjectConfig(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.server.git.MetaDataUpdate md, org.eclipse.jgit.lib.ObjectId base) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = config.commit(md); gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId()); projectCache.evict(config.getProject()); hooks.doRefUpdatedHook(new com.google.gerrit.reviewdb.client.Branch.NameKey(config.getProject().getNameKey(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), base, commit.getId(), user.asIdentifiedUser().getAccount()); }
private com.google.gerrit.client.diff.SideBySideCommentGroup group(com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.client.diff.SideBySideCommentGroup w = map(side).get(line); if (w != null) { return w; } int lineA; int lineB; if (line == 0) { lineA = lineB = 0; } else if (side == (DisplaySide.A)) { lineA = line; lineB = (host.lineOnOther(side, (line - 1)).getLine()) + 1; } else { lineA = (host.lineOnOther(side, (line - 1)).getLine()) + 1; lineB = line; } com.google.gerrit.client.diff.SideBySideCommentGroup a = newGroup(DisplaySide.A, lineA); com.google.gerrit.client.diff.SideBySideCommentGroup b = newGroup(DisplaySide.B, lineB); com.google.gerrit.client.diff.SideBySideCommentGroup.pair(a, b); sideA.put(lineA, a); sideB.put(lineB, b); if (isAttached()) { a.init(host.getDiffTable()); b.handleRedraw(); } return side == (DisplaySide.A) ? a : b; }
@java.lang.Override public void visit(com.google.gitiles.doc.IframeNode node) { if ((((com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(node.src)) && (com.google.gitiles.doc.html.HtmlBuilder.isValidCssDimension(node.height))) && (com.google.gitiles.doc.html.HtmlBuilder.isValidCssDimension(node.width))) && (canRender(node))) { html.open("iframe").attribute("src", node.src).attribute("height", node.height).attribute("width", node.width); if (!(node.border)) { html.attribute("class", "noborder"); } html.close("iframe"); } }
@java.lang.Override public void visit(org.pegdown.ast.CodeNode node) { wrapText("code", node); }


@java.lang.Override public void visit(org.pegdown.ast.AutoLinkNode node) { java.lang.String url = node.getText(); html.open("a").attribute("href", href(url)).appendAndEscape(url).close("a"); }

@java.lang.Override public void visit(org.pegdown.ast.TableNode node) { table = new com.google.gitiles.doc.TableState(node); wrapChildren("table", node); table = null; }



@java.lang.Override public void visit(org.pegdown.ast.DefinitionNode node) { wrapChildren("dd", node); }
@java.lang.Override public void visit(com.google.gitiles.doc.ColsNode.Column node) { if ((1 <= (node.span)) && ((node.span) <= (ColsNode.GRID_WIDTH))) { html.open("div").attribute("class", ("col-" + (node.span))); visitChildren(node); html.close("div"); } }
@java.lang.Override public void visit(org.pegdown.ast.TableCellNode node) { mustBeInsideTable(node); java.lang.String tag = (table.inHeader) ? "th" : "td"; html.open(tag).attribute("align", table.getAlign()); if ((node.getColSpan()) > 1) { html.attribute("colspan", java.lang.Integer.toString(node.getColSpan())); } visitChildren(node); html.close(tag); table.done(node); }
@java.lang.Override public void visit(com.google.gitiles.doc.NamedAnchorNode node) { if (outputNamedAnchor) { html.open("a").attribute("name", node.name).close("a"); } }

@java.lang.Override public void visit(org.pegdown.ast.TableHeaderNode node) { mustBeInsideTable(node); table.inHeader = true; wrapChildren("thead", node); table.inHeader = false; }
@java.lang.Override public void visit(org.pegdown.ast.MailLinkNode node) { java.lang.String addr = node.getText(); html.open("a").attribute("href", ("mailto:" + addr)).appendAndEscape(addr).close("a"); }
@java.lang.Override public void visit(org.pegdown.ast.TableBodyNode node) { wrapChildren("tbody", node); }
@java.lang.Override public void visit(org.pegdown.ast.TableRowNode node) { mustBeInsideTable(node); table.startRow(); wrapChildren("tr", node); }
@java.lang.Override public void visit(com.google.gitiles.doc.ColsNode node) { html.open("div").attribute("class", "cols"); visitChildren(node); html.close("div"); }
@java.lang.Override public void visit(com.google.gitiles.doc.DivNode node) { html.open("div").attribute("class", node.getStyleName()); visitChildren(node); html.close("div"); }
@java.lang.Override public void visit(com.google.gitiles.doc.TocNode node) { toc.format(); }
@java.lang.Override public void visit(org.pegdown.ast.VerbatimNode node) { java.lang.String lang = node.getType(); java.lang.String text = node.getText(); html.open("pre").attribute("class", "code"); text = printLeadingBlankLines(text); java.util.List<syntaxhighlight.ParseResult> parsed = parse(lang, text); if (parsed != null) { int last = 0; for (syntaxhighlight.ParseResult r : parsed) { span(null, text, last, r.getOffset()); last = (r.getOffset()) + (r.getLength()); span(r.getStyleKeysString(), text, r.getOffset(), last); } if (last < (text.length())) { span(null, text, last, text.length()); } } else { html.appendAndEscape(text); } html.close("pre"); }

private java.lang.String getLatestDiff(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId oldTreeId, org.eclipse.jgit.lib.ObjectId newTreeId) throws java.io.IOException { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); try (org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(out)) { fmt.setRepository(repo); fmt.format(oldTreeId, newTreeId); fmt.flush(); return out.toString(); } }
protected void submit(java.lang.String changeId) throws java.lang.Exception { submit(changeId, HttpStatus.SC_OK, null); }
protected void assertRebase(org.eclipse.jgit.junit.TestRepository<?> testRepo, boolean contentMerge) throws java.io.IOException { org.eclipse.jgit.lib.Repository repo = testRepo.getRepository(); org.eclipse.jgit.revwalk.RevCommit localHead = getHead(repo); org.eclipse.jgit.revwalk.RevCommit remoteHead = getRemoteHead(); assert_().withFailureMessage(java.lang.String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId()); assertThat(remoteHead.getParentCount()).isEqualTo(1); if (!contentMerge) { assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo)); } assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage()); }
protected void assertCurrentRevision(java.lang.String changeId, int expectedNum, ObjectId expectedId) throws java.lang.Exception { ChangeInfo c = get(changeId, com.google.gerrit.acceptance.rest.change.CURRENT_REVISION); assertThat(c.currentRevision).isEqualTo(expectedId.name()); assertThat(c.revisions.get(expectedId.name())._number).isEqualTo(expectedNum); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(new com.google.gerrit.reviewdb.client.Project.NameKey(c.project))) { java.lang.String refName = new com.google.gerrit.reviewdb.client.PatchSet.Id(new com.google.gerrit.reviewdb.client.Change.Id(c._number), expectedNum).toRefName(); org.eclipse.jgit.lib.Ref ref = repo.getRef(refName); assertThat(ref).named(refName).isNotNull(); assertThat(ref.getObjectId()).isEqualTo(expectedId); } }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (event instanceof com.google.gerrit.server.events.ChangeMergedEvent) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ((com.google.gerrit.server.events.ChangeMergedEvent) (event)); mergeResults.put(changeMergedEvent.change.number, changeMergedEvent.newRev); } }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead() throws java.io.IOException { return getRemoteHead(project, "master"); }
protected java.util.List<org.eclipse.jgit.revwalk.RevCommit> getRemoteLog(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { rw.markStart(rw.parseCommit(repo.getRef(("refs/heads/" + branch)).getObjectId())); return com.google.common.collect.Lists.newArrayList(rw); } }
private org.eclipse.jgit.revwalk.RevCommit getHead(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { return getHead(repo, "HEAD"); }
private org.eclipse.jgit.revwalk.RevCommit getHead(org.eclipse.jgit.lib.Repository repo, java.lang.String name) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { return rw.parseCommit(repo.getRef(name).getObjectId()); } }
protected void assertCherryPick(org.eclipse.jgit.junit.TestRepository<?> testRepo, boolean contentMerge) throws java.io.IOException { assertRebase(testRepo, contentMerge); org.eclipse.jgit.revwalk.RevCommit remoteHead = getRemoteHead(); assertThat(remoteHead.getFooterLines("Reviewed-On")).isNotEmpty(); assertThat(remoteHead.getFooterLines("Reviewed-By")).isNotEmpty(); }
protected void assertSubmitter(java.lang.String changeId, int psId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change()); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new com.google.gerrit.reviewdb.client.PatchSet.Id(cn.getChangeId(), psId)); assertThat(submitter.isSubmit()).isTrue(); assertThat(submitter.getAccountId()).isEqualTo(admin.getId()); }
protected void submitWithConflict(java.lang.String changeId, java.lang.String expectedError) throws java.lang.Exception { submit(changeId, HttpStatus.SC_CONFLICT, expectedError); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(createEmptyCommit = false) public void submitToEmptyRepo() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); assertThat(getRemoteHead().getId()).isEqualTo(change.getCommitId()); }
protected java.util.List<org.eclipse.jgit.revwalk.RevCommit> getRemoteLog() throws java.io.IOException { return getRemoteLog(project, "master"); }
@org.junit.After public void cleanup() { db.close(); }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { return getHead(repo, ("refs/heads/" + branch)); } }
private java.lang.String getLatestRemoteDiff() throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId oldTreeId = repo.resolve("refs/heads/master~1^{tree}"); org.eclipse.jgit.lib.ObjectId newTreeId = repo.resolve("refs/heads/master^{tree}"); return getLatestDiff(repo, oldTreeId, newTreeId); } }
private void assertSubmitter(com.google.gerrit.acceptance.PushOneCommit.Result change) throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo info = get(change.getChangeId(), ListChangesOption.MESSAGES); assertThat(info.messages).isNotNull(); assertThat(info.messages).hasSize(3); if ((getSubmitType()) == (com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK)) { assertThat(com.google.common.collect.Iterables.getLast(info.messages).message).startsWith("Change has been successfully cherry-picked as "); } else { assertThat(com.google.common.collect.Iterables.getLast(info.messages).message).isEqualTo("Change has been successfully merged by Administrator"); } }
protected void assertNoSubmitter(java.lang.String changeId, int psId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change()); com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new com.google.gerrit.reviewdb.client.PatchSet.Id(cn.getChangeId(), psId)); assertThat(submitter).isNull(); }
private java.lang.String getLatestDiff(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { org.eclipse.jgit.lib.ObjectId oldTreeId = repo.resolve("HEAD~1^{tree}"); org.eclipse.jgit.lib.ObjectId newTreeId = repo.resolve("HEAD^{tree}"); return getLatestDiff(repo, oldTreeId, newTreeId); }
com.google.template.soy.data.SanitizedContent render() { try { int inputLimit = cfg.getInt("markdown", "inputLimit", (5 << 20)); byte[] raw = reader.open(readmeId, Constants.OBJ_BLOB).getCachedBytes(inputLimit); java.lang.String md = org.eclipse.jgit.util.RawParseUtils.decode(raw); org.commonmark.node.Node root = com.google.gitiles.doc.GitilesMarkdown.parse(md); if (root == null) { return null; } int imageLimit = cfg.getInt("markdown", "imageLimit", (256 << 10)); com.google.gitiles.doc.ImageLoader img = null; if (imageLimit > 0) { img = new com.google.gitiles.doc.ImageLoader(reader, view, rootTree, readmePath, imageLimit); } return new com.google.gitiles.doc.MarkdownToHtml(view, cfg, readmePath).setImageLoader(img).toSoyHtml(root); } catch (org.eclipse.jgit.errors.LargeObjectException | java.io.IOException e) { com.google.gitiles.ReadmeHelper.log.error(java.lang.String.format("error rendering %s/%s", view.getRepositoryName(), readmePath), e); return null; } }
@java.lang.Override public void run() throws java.lang.Exception { try { java.util.List<com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q); for (com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocResult docResult : res) { stdout.println(java.lang.String.format("%s:\n%s%s\n", docResult.title, url, docResult.url)); } } catch (com.google.gerrit.server.documentation.QueryDocumentationExecutor.DocQueryException dqe) { throw new com.google.gerrit.sshd.commands.UnloggedFailure(1, ("fatal: " + (dqe.getMessage()))); } }
private Change.Id getIdFromRequest(java.lang.String path) { java.lang.String changeId = path.substring(((path.lastIndexOf('/')) + 1)); return Change.Id.parse(changeId); }

@org.junit.Test public void testWithSubProjectFound() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p1 = createProject("a/b"); com.google.gerrit.reviewdb.client.Project.NameKey p2 = createProject("b"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((((((((("\n" + (("[submodule \"a/b\"]\n" + "path = a/b\n") + "url = ssh://localhost/")) + (p1.get())) + "\n") + "branch = .\n") + "[submodule \"b\"]\n") + "path = b\n") + "url = http://localhost/") + (p2.get())) + "\n") + "branch = .\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p2, "master"), "b"), new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p1, "master"), "a/b")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithSectionToOtherServer() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p1 = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText((((("" + (("[submodule \"a\"]" + "path = a") + "url = ssh://non-localhost/")) + (p1.get())) + "\n") + "branch = .")); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); assertThat(res).isEmpty(); }
@org.junit.Test public void testWithAnotherURI() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = a\n") + "url = http://localhost:80/")) + (p.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p, "master"), "a")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithSlashesInPath() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = a/b/c/d/e\n") + "url = http://localhost:80/")) + (p.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p, "master"), "a/b/c/d/e")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithSlashesInProjectName() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("project/with/slashes/a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"project/with/slashes/a\"]\n" + "path = a\n") + "url = http://localhost:80/")) + (p.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p, "master"), "a")); assertThat(res).containsExactlyElementsIn(expected); }
void load(com.google.gerrit.server.project.ProjectCache cache) throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); logDebug("Loading .gitmodules of {} for project {}", branch, project); try { orm.openRepo(project, false); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new java.io.IOException(e); } OpenRepo or = orm.getRepo(project); ObjectId id = or.repo.resolve(branch.get()); if (id == null) { throw new java.io.IOException(("Cannot open branch " + (branch.get()))); } org.eclipse.jgit.revwalk.RevCommit commit = or.rw.parseCommit(id); org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(or.repo, com.google.gerrit.server.git.GitModules.GIT_MODULES, commit.getTree()); if ((tw == null) || (((tw.getRawMode(0)) & (org.eclipse.jgit.lib.FileMode.TYPE_MASK)) != (org.eclipse.jgit.lib.FileMode.TYPE_FILE))) { return; } try { org.eclipse.jgit.lib.BlobBasedConfig bbc = new org.eclipse.jgit.lib.BlobBasedConfig(null, or.repo, commit, com.google.gerrit.server.git.GitModules.GIT_MODULES); subscriptions = new com.google.gerrit.server.util.SubmoduleSectionParser(cache, bbc, thisServer, branch).parseAllSections(); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(("Could not read .gitmodule file of super project: " + (branch.getParentKey())), e); } }
@org.junit.Test public void testWithDeepRelativeURI() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p1 = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = a\n") + "url = ../../")) + (p1.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("nested/project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p1, "master"), "a")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testFollowMasterBranch() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = localpath-to-a\n") + "url = ssh://localhost/")) + (p.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p, "master"), "localpath-to-a")); assertThat(res).containsExactlyElementsIn(expected); }
public java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch, com.google.gerrit.server.git.MergeOpRepoManager orm) throws java.io.IOException { logDebug(("Calculating possible superprojects for " + branch)); java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> ret = new java.util.ArrayList<>(); com.google.gerrit.reviewdb.client.Project.NameKey project = branch.getParentKey(); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.get(project).getConfig(); for (com.google.gerrit.common.data.SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) { java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> branches = getDestinationBranches(branch, s, orm); for (com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch : branches) { com.google.gerrit.server.git.GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm); m.load(); for (com.google.gerrit.reviewdb.client.SubmoduleSubscription ss : m.subscribedTo(branch)) { if ((projectCache.get(ss.getSubmodule().getParentKey())) != null) { ret.add(ss); } } } } logDebug(((("Calculated superprojects for " + branch) + " are ") + ret)); return ret; }
@org.junit.Test public void testFollowAnotherBranch() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = a\n") + "url = ssh://localhost/")) + (p.get())) + "\n") + "branch = anotherbranch\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p, "anotherbranch"), "a")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithMoreSections() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p1 = createProject("a"); com.google.gerrit.reviewdb.client.Project.NameKey p2 = createProject("b"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((((((((("" + (("[submodule \"a\"]\n" + "path = a\n") + "url = ssh://localhost/")) + (p1.get())) + "\n") + "branch = .\n") + "[submodule \"b\"]\n") + " path = b\n") + " url = http://localhost:80/") + (p2.get())) + "\n") + " branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p1, "master"), "a"), new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p2, "master"), "b")); assertThat(res).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithSectionOfNonexistingProject() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(("\n" + ((("[submodule \"a\"]\n" + "path = a\n") + "url = ssh://non-localhost/a\n") + "branch = .\\n"))); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); assertThat(res).isEmpty(); }
@org.junit.Test public void testWithRelativeURI() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p1 = createProject("a"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); java.lang.String gitmodules = ((("" + (("[submodule \"a\"]\n" + "path = a\n") + "url = ../")) + (p1.get())) + "\n") + "branch = master\n"; cfg.fromText(gitmodules); java.lang.String thisServer = com.google.gerrit.acceptance.git.SubmoduleSectionParserIT.THIS_SERVER; com.google.gerrit.reviewdb.client.Branch.NameKey targetBranch = new com.google.gerrit.reviewdb.client.Branch.NameKey(new com.google.gerrit.reviewdb.client.Project.NameKey("project"), "master"); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> res = new com.google.gerrit.server.util.SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections(); java.util.Set<com.google.gerrit.reviewdb.client.SubmoduleSubscription> expected = com.google.common.collect.Sets.newHashSet(new com.google.gerrit.reviewdb.client.SubmoduleSubscription(targetBranch, new com.google.gerrit.reviewdb.client.Branch.NameKey(p1, "master"), "a")); assertThat(res).containsExactlyElementsIn(expected); }
void createNotes(java.lang.String branch, org.eclipse.jgit.lib.ObjectId oldObjectId, org.eclipse.jgit.lib.ObjectId newObjectId, org.eclipse.jgit.lib.ProgressMonitor monitor) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (org.eclipse.jgit.lib.ObjectId.zeroId().equals(newObjectId)) { return; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(git)) { try { org.eclipse.jgit.revwalk.RevCommit n = rw.parseCommit(newObjectId); rw.markStart(n); if (((n.getParentCount()) == 1) && (n.getParent(0).equals(oldObjectId))) { rw.markUninteresting(rw.parseCommit(oldObjectId)); } else { markUninteresting(git, branch, rw, oldObjectId); } } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.reviewnotes.CreateReviewNotes.log.error(e.getMessage(), e); return; } if (monitor == null) { monitor = org.eclipse.jgit.lib.NullProgressMonitor.INSTANCE; } for (org.eclipse.jgit.revwalk.RevCommit c : rw) { com.google.gerrit.reviewdb.client.PatchSet ps = loadPatchSet(c, branch); com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create(reviewDb, project, ps.getId().getParentKey()); org.eclipse.jgit.lib.ObjectId content = createNoteContent(notes, ps); if (content != null) { monitor.update(1); getNotes().set(c, content); getMessage().append("* ").append(c.getShortMessage()).append("\n"); } } } }
@java.lang.Override public com.google.gerrit.server.CurrentUser getUser() { if ((user) == null) { if (isSignedIn()) { user = identified.create(val.getAccountId()); } else { user = anonymousProvider.get(); } } return user; }
private static boolean isSingleQuery(java.lang.String query) { if (query.matches("^[1-9][0-9]*$")) { return true; } if (query.matches("^[iI][0-9a-f]{4,}$")) { return true; } if (query.matches((("^([0-9a-fA-F]{4," + (com.google.gerrit.reviewdb.client.RevId.LEN)) + "})$"))) { return true; } return false; }
private static java.util.List<java.util.Map<java.lang.String, java.lang.Object>> getRefsSoyData(org.eclipse.jgit.lib.RefDatabase refdb, com.google.gitiles.GitilesView view, java.lang.String prefix, com.google.common.collect.Ordering<org.eclipse.jgit.lib.Ref> ordering, @javax.annotation.Nullable org.eclipse.jgit.lib.Ref headLeaf, int limit) throws java.io.IOException { java.util.Collection<org.eclipse.jgit.lib.Ref> refs = refdb.getRefs(prefix).values(); refs = ordering.leastOf(refs, (limit > 0 ? com.google.common.primitives.Ints.saturatedCast((limit + 1L)) : refs.size())); java.util.List<java.util.Map<java.lang.String, java.lang.Object>> result = com.google.common.collect.Lists.newArrayListWithCapacity(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { java.lang.String name = ref.getName().substring(prefix.length()); org.eclipse.jgit.lib.Ref refForName = refdb.getRef(name); if (refForName != null) { boolean needPrefix = !(ref.getName().equals(refForName.getName())); java.util.Map<java.lang.String, java.lang.Object> value = com.google.common.collect.Maps.newHashMapWithExpectedSize(3); value.put("url", com.google.gitiles.GitilesView.revision().copyFrom(view).setRevision(com.google.gitiles.Revision.unpeeled((needPrefix ? ref.getName() : name), ref.getObjectId())).toUrl()); value.put("name", name); if (headLeaf != null) { value.put("isHead", headLeaf.equals(ref)); } result.add(value); } } return result; }


protected void bccStarredBy() { if (!(NotifyHandling.ALL.equals(notify))) { return; } try { for (com.google.gerrit.reviewdb.client.Account.Id accountId : args.starredChangesUtil.byChangeFromIndex(change.getId(), StarredChangesUtil.DEFAULT_LABEL)) { super.add(RecipientType.BCC, accountId); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchChangeException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot BCC users that starred updated change", err); } }


public void display(final java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo> result) { while (2 < (table.getRowCount())) { table.removeRow(((table.getRowCount()) - 1)); } for (final com.google.gerrit.common.data.AccountProjectWatchInfo k : result) { final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); populate(row, k); } }
protected java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.Key> getCheckedIds() { final java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.Key> ids = new java.util.HashSet<>(); for (int row = 1; row < (table.getRowCount()); row++) { final com.google.gerrit.common.data.AccountProjectWatchInfo k = getRowItem(row); if ((k != null) && (((com.google.gwt.user.client.ui.CheckBox) (table.getWidget(row, 1))).getValue())) { ids.add(k.getWatch().getKey()); } } return ids; }
protected void doAddNew() { final java.lang.String projectName = nameBox.getText().trim(); if ("".equals(projectName)) { return; } java.lang.String filter = filterTxt.getText(); if (((filter == null) || (filter.isEmpty())) || (filter.equals(Util.C.defaultFilter()))) { filter = null; } addNew.setEnabled(false); nameBox.setEnabled(false); filterTxt.setEnabled(false); Util.ACCOUNT_SVC.addProjectWatch(projectName, filter, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.AccountProjectWatchInfo>() { @java.lang.Override public void onSuccess(final com.google.gerrit.common.data.AccountProjectWatchInfo result) { addNew.setEnabled(true); nameBox.setEnabled(true); filterTxt.setEnabled(true); nameBox.setText(""); watchesTab.insertWatch(result); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { addNew.setEnabled(true); nameBox.setEnabled(true); filterTxt.setEnabled(true); super.onFailure(caught); } }); }

public void deleteChecked() { final java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.Key> ids = getCheckedIds(); if (!(ids.isEmpty())) { Util.ACCOUNT_SVC.deleteProjectWatches(ids, new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { remove(ids); } }); } }
@java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { final boolean oldVal = info.getWatch().isNotify(type); info.getWatch().setNotify(type, cbox.getValue()); cbox.setEnabled(false); Util.ACCOUNT_SVC.updateProjectWatch(info.getWatch(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { cbox.setEnabled(true); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { cbox.setEnabled(true); info.getWatch().setNotify(type, oldVal); cbox.setValue(oldVal); super.onFailure(caught); } }); }
protected void populateWatches() { Util.ACCOUNT_SVC.myProjectWatch(new com.google.gerrit.client.rpc.ScreenLoadCallback<java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo>>(this) { @java.lang.Override public void preDisplay(final java.util.List<com.google.gerrit.common.data.AccountProjectWatchInfo> result) { watchesTab.display(result); } }); }
@java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { remove(ids); }
@java.lang.Override public void onFailure(final java.lang.Throwable caught) { addNew.setEnabled(true); nameBox.setEnabled(true); filterTxt.setEnabled(true); super.onFailure(caught); }
@java.lang.Override public void onFailure(final java.lang.Throwable caught) { cbox.setEnabled(true); info.getWatch().setNotify(type, oldVal); cbox.setValue(oldVal); super.onFailure(caught); }
protected void addNotifyButton(final com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type, final com.google.gerrit.common.data.AccountProjectWatchInfo info, final int row, final int col) { final com.google.gwt.user.client.ui.CheckBox cbox = new com.google.gwt.user.client.ui.CheckBox(); cbox.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { final boolean oldVal = info.getWatch().isNotify(type); info.getWatch().setNotify(type, cbox.getValue()); cbox.setEnabled(false); Util.ACCOUNT_SVC.updateProjectWatch(info.getWatch(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { cbox.setEnabled(true); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { cbox.setEnabled(true); info.getWatch().setNotify(type, oldVal); cbox.setValue(oldVal); super.onFailure(caught); } }); } }); cbox.setValue(info.getWatch().isNotify(type)); table.setWidget(row, col, cbox); }
protected void remove(java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.Key> ids) { for (int row = 1; row < (table.getRowCount());) { final com.google.gerrit.common.data.AccountProjectWatchInfo k = getRowItem(row); if ((k != null) && (ids.contains(k.getWatch().getKey()))) { table.removeRow(row); } else { row++; } } }









private static java.util.Map<java.lang.String, java.lang.Object> renderReadme(org.eclipse.jgit.revwalk.RevWalk walk, com.google.gitiles.GitilesView view, org.eclipse.jgit.lib.Config cfg, org.eclipse.jgit.revwalk.RevObject head) throws java.io.IOException { org.eclipse.jgit.revwalk.RevTree rootTree; try { rootTree = walk.parseTree(head); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException notTreeish) { return null; } com.google.gitiles.ReadmeHelper readme = new com.google.gitiles.ReadmeHelper(com.google.gitiles.GitilesView.path().copyFrom(view).setRevision(Revision.HEAD).setPathPart("/").build(), com.google.gitiles.doc.MarkdownConfig.get(cfg), walk.getObjectReader(), rootTree); readme.scanTree(rootTree); if (readme.isPresent()) { com.google.template.soy.data.SanitizedContent html = readme.render(); if (html != null) { return com.google.common.collect.ImmutableMap.<java.lang.String, java.lang.Object>of("readmeHtml", html); } } return null; }



public com.google.gitiles.doc.MarkdownToHtml setImageLoader(com.google.gitiles.doc.ImageLoader img) { imageLoader = img; return this; }
private static java.util.Map<java.lang.String, java.lang.Object> renderReadme(org.eclipse.jgit.revwalk.RevWalk walk, com.google.gitiles.GitilesView view, org.eclipse.jgit.lib.Config cfg, org.eclipse.jgit.revwalk.RevObject head) throws java.io.IOException { org.eclipse.jgit.revwalk.RevTree rootTree; try { rootTree = walk.parseTree(head); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException notTreeish) { return null; } com.google.gitiles.ReadmeHelper readme = new com.google.gitiles.ReadmeHelper(walk.getObjectReader(), com.google.gitiles.GitilesView.path().copyFrom(view).setRevision(Revision.HEAD).setPathPart("/").build(), cfg, rootTree); readme.scanTree(rootTree); if (readme.isPresent()) { com.google.template.soy.data.SanitizedContent html = readme.render(); if (html != null) { return com.google.common.collect.ImmutableMap.<java.lang.String, java.lang.Object>of("readmeHtml", html); } } return null; }
public java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> subscribedTo(com.google.gerrit.reviewdb.client.Branch.NameKey src) { logDebug(("Checking for a subscription of " + src)); java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> ret = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.SubmoduleSubscription s : subscriptions) { if (s.getSubmodule().equals(src)) { logDebug(("Found " + s)); ret.add(s); } } return ret; }

@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) { org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(preUploadHooks))); up.setPostUploadHook(uploadMetrics); return up; }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { if (!(projectControl.canRunUploadPack())) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); if (!(projectControl.allRefsAreVisible())) { up.setAdvertiseRefsHook(new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, projectControl, db, true)); } up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(uploadMetrics); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
private java.lang.Iterable<java.lang.String> getUsernames(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { java.util.Set<java.lang.String> emails = user.asIdentifiedUser().getEmailAddresses(); if ((user.getUserName()) == null) { return emails; } else if (emails.isEmpty()) { return com.google.common.collect.ImmutableSet.of(user.getUserName()); } com.google.common.collect.Iterables.concat(emails, com.google.common.collect.ImmutableSet.of(user.getUserName())); } if ((user.getUserName()) != null) { return com.google.common.collect.ImmutableSet.of(user.getUserName()); } return com.google.common.collect.ImmutableSet.of(); }
@org.junit.Test public void revisionActionsTwoChangesInTopic_conflicting() throws java.lang.Exception { java.lang.String changeId = createChangeWithTopic().getChangeId(); approve(changeId); java.lang.String changeId2 = createChangeWithTopic(testRepo, "foo2", "touching b", "b.txt", "real content").getChangeId(); approve(changeId2); testRepo.reset("HEAD~2"); java.lang.String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId(); gApi.changes().id(collidingChange).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(collidingChange).current().submit(); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> actions = getActions(changeId); commonActionsAssertions(actions); if (isSubmitWholeTopicEnabled()) { com.google.gerrit.extensions.common.ActionInfo info = actions.get("submit"); assertThat(info.enabled).isNull(); assertThat(info.label).isEqualTo("Submit whole topic"); assertThat(info.method).isEqualTo("POST"); assertThat(info.title).isEqualTo("See the \"Submitted Together\" tab for problems, specifically see: 2"); } else { noSubmitWholeTopicAssertions(actions, 1); } }



@org.junit.Test public void GetDiffPreferences() throws java.lang.Exception { com.google.gerrit.extensions.client.DiffPreferencesInfo result = get(); assertPrefsEqual(result, com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults()); }
@org.junit.Test public void SetDiffPreferences() throws java.lang.Exception { int newLineLength = (com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults().lineLength) + 10; com.google.gerrit.extensions.client.DiffPreferencesInfo update = new com.google.gerrit.extensions.client.DiffPreferencesInfo(); update.lineLength = newLineLength; com.google.gerrit.extensions.client.DiffPreferencesInfo result = put(update); assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength); result = get(); com.google.gerrit.extensions.client.DiffPreferencesInfo expected = com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults(); expected.lineLength = newLineLength; assertPrefsEqual(result, expected); }
private com.google.gerrit.server.notedb.LoadHandle rebuildAndOpen(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId oldId) throws java.io.IOException { try { com.google.gerrit.server.notedb.NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId()); if (newState == null) { return super.openHandle(repo, oldId); } repo.scanForRepoChanges(); return com.google.gerrit.server.notedb.LoadHandle.create(com.google.gerrit.server.notedb.ChangeNotesCommit.newRevWalk(repo), newState.getChangeMetaId()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return super.openHandle(repo, oldId); } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } }




private com.google.gerrit.server.notedb.RevisionNoteMap getRevisionNoteMap(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId curr) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (curr.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return com.google.gerrit.server.notedb.RevisionNoteMap.emptyMap(); } if (migration.readChanges()) { com.google.gerrit.server.notedb.ChangeNotes notes = getNotes(); if (notes != null) { org.eclipse.jgit.lib.ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), org.eclipse.jgit.lib.ObjectId.zeroId()); if (idFromNotes.equals(curr)) { return checkNotNull(getNotes().revisionNoteMap); } } } org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr)); return com.google.gerrit.server.notedb.RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, false); }

@java.lang.Override protected void onLoad(com.google.gerrit.server.notedb.LoadHandle handle) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = handle.id(); if (rev == null) { loadDefaults(); return; } com.google.gerrit.server.notedb.ChangeNotesParser parser = new com.google.gerrit.server.notedb.ChangeNotesParser(change.getId(), rev, handle.walk(), args.noteUtil, args.metrics); state = parser.parseAll(); state.copyColumnsTo(change); revisionNoteMap = parser.getRevisionNoteMap(); }
private void assertRefs(java.lang.String... expectedWithMeta) throws java.lang.Exception { java.util.List<java.lang.String> expected = new java.util.ArrayList<>(expectedWithMeta.length); for (java.lang.String r : expectedWithMeta) { if ((notesMigration.writeChanges()) || (!(r.endsWith(RefNames.META_SUFFIX)))) { expected.add(r); } } com.google.gerrit.acceptance.AcceptanceTestRequestScope.Context ctx = disableDb(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.controlFor(project, identifiedUserFactory.create(user.getId())); com.google.gerrit.server.git.VisibleRefFilter filter = new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeCache, repo, ctl, new com.google.gerrit.testutil.DisabledReviewDb(), true); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = repo.getAllRefs(); assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected); } finally { enableDb(ctx); } }
private java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> visibleChanges() { if (!(showMetadata)) { return java.util.Collections.emptySet(); } final com.google.gerrit.reviewdb.client.Project project = projectCtl.getProject(); try { final java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> visibleChanges = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Change change : changeCache.get(project.getNameKey())) { if (projectCtl.controlForIndexedChange(change).isVisible(reviewDb)) { visibleChanges.add(change.getId()); } } return visibleChanges; } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error((("Cannot load changes for project " + (project.getName())) + ", assuming no changes are visible"), e); return java.util.Collections.emptySet(); } }
@com.google.common.annotations.VisibleForTesting java.lang.String href(java.lang.String target) { if ((target.startsWith("#")) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(target))) { return target; } java.lang.String anchor = ""; int hash = target.indexOf('#'); if (hash >= 0) { anchor = target.substring(hash); target = target.substring(0, hash); } java.lang.String dest = com.google.gitiles.doc.PathResolver.resolve(filePath, target); if ((dest == null) || ((view) == null)) { return FilterNormalizeUri.INSTANCE.getInnocuousOutput(); } com.google.gitiles.GitilesView.Builder b; if ((view.getType()) == (GitilesView.Type.ROOTED_DOC)) { b = com.google.gitiles.GitilesView.rootedDoc(); } else { b = com.google.gitiles.GitilesView.path(); } dest = b.copyFrom(view).setPathPart(dest).build().toUrl(); return (com.google.gitiles.doc.PathResolver.relative(requestUri, dest)) + anchor; }

public void index(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) throws java.io.IOException { index(changeDataFactory.create(db, change)); }
@java.lang.Override public com.google.gerrit.server.index.change.Result indexAll(com.google.gerrit.server.index.change.ChangeIndex index) { org.eclipse.jgit.lib.ProgressMonitor pm = new org.eclipse.jgit.lib.TextProgressMonitor(); pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN); java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> projects = com.google.common.collect.Sets.newTreeSet(); int changeCount = 0; com.google.common.base.Stopwatch sw = com.google.common.base.Stopwatch.createStarted(); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projectCache.all()) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { changeCount += ChangeNotes.Factory.scan(repo).size(); } catch (java.io.IOException e) { com.google.gerrit.server.index.change.AllChangesIndexer.log.error("Error collecting projects", e); return new com.google.gerrit.server.index.change.Result(sw, false, 0, 0); } projects.add(project); pm.update(1); } pm.endTask(); setTotalWork(changeCount); return indexAll(index, projects); }

public void assertCanDelete(com.google.gerrit.reviewdb.client.Project project) throws com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException { com.google.gerrit.server.git.SubmoduleOp sub = subOpProvider.get(); com.google.gerrit.reviewdb.client.Project.NameKey proj = project.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(proj);com.google.gerrit.server.git.MergeOpRepoManager orm = ormProvider.get()) { for (org.eclipse.jgit.lib.Ref ref : repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) { com.google.gerrit.reviewdb.client.Branch.NameKey b = new com.google.gerrit.reviewdb.client.Branch.NameKey(proj, ref.getName()); if (!(sub.superProjectSubscriptionsForSubmoduleBranch(b, orm).isEmpty())) { throw new com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException("Project is subscribed by other projects."); } } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { } catch (java.io.IOException e) { throw new com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException("Project is subscribed by other projects."); } }
private void setUpWebLinks() { if (!(value.isConfigVisible())) { history.getStyle().setDisplay(Display.NONE); } else { com.google.gerrit.client.info.GitwebInfo c = com.google.gerrit.client.Gerrit.info().gitweb(); java.util.List<com.google.gerrit.common.data.WebLinkInfoCommon> links = value.getFileHistoryLinks(); if ((c == null) && (links == null)) { history.getStyle().setDisplay(Display.NONE); } if (c != null) { webLinkPanel.add(toAnchor(c.toFileHistory(new com.google.gerrit.reviewdb.client.Branch.NameKey(value.getProjectName(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), "project.config"), c.getLinkName())); } if (links != null) { for (com.google.gerrit.common.data.WebLinkInfoCommon link : links) { webLinkPanel.add(com.google.gerrit.client.admin.ProjectAccessEditor.toAnchor(link)); } } } }

@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); approve(change2.getChangeId()); approve(change3.getChangeId()); submit(change4.getChangeId()); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); assertThat(log.get(0).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); assertThat(log.get(1).getId()).isEqualTo(initialHead.getId()); assertNew(change2.getChangeId()); assertNew(change3.getChangeId()); }
private com.google.gerrit.server.git.ChangeSet completeChangeSetIncludingTopics(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.git.ChangeSet changes, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { java.util.Set<java.lang.String> topicsTraversed = new java.util.HashSet<>(); boolean done = false; com.google.gerrit.server.git.ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user); while (!done) { java.util.List<com.google.gerrit.server.query.change.ChangeData> chgs = new java.util.ArrayList<>(); done = true; for (com.google.gerrit.server.query.change.ChangeData cd : newCs.changes()) { chgs.add(cd); java.lang.String topic = cd.change().getTopic(); if ((!(com.google.common.base.Strings.isNullOrEmpty(topic))) && (!(topicsTraversed.contains(topic)))) { chgs.addAll(query().byTopicOpen(topic)); done = false; topicsTraversed.add(topic); } } changes = new com.google.gerrit.server.git.ChangeSet(chgs); newCs = completeChangeSetWithoutTopic(db, changes, user); } return newCs; }





@org.junit.Test public void mergeOnPushToBranch() throws java.lang.Exception { grant(Permission.PUSH, project, "refs/heads/master"); com.google.gerrit.acceptance.PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content"); r.assertOkStatus(); git().push().setRefSpecs(new org.eclipse.jgit.transport.RefSpec(((r.getCommit().name()) + ":refs/heads/master"))).call(); assertCommit(project, "refs/heads/master"); assertSubmitApproval(r.getPatchSetId()); com.google.gerrit.extensions.common.ChangeInfo c = gApi.changes().id(r.getPatchSetId().getParentKey().get()).get(); assertThat(c.status).isEqualTo(ChangeStatus.MERGED); }
@org.junit.Test public void submitSubsetOfDependentChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 5", "e", "e"); approve(change3.getChangeId()); submit(change4.getChangeId()); assertNew(change2.getChangeId()); assertNew(change3.getChangeId()); }
@org.junit.Test public void submitOutOfOrder_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); createChange("Change 2", "b.txt", "other content"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content"); submitWithConflict(change3.getChangeId(), ((((("Failed to submit 1 change due to the following problems:\n" + "Change ") + (change3.getChange().getId())) + ": Change could not be ") + "merged due to a path conflict. Please rebase the change locally and ") + "upload the rebased commit for review.")); assertThat(getRemoteHead()).isEqualTo(oldHead); assertCurrentRevision(change3.getChangeId(), 1, change3.getCommit()); assertNoSubmitter(change3.getChangeId(), 1); }
public com.google.gerrit.server.events.RefUpdatedEvent getOneRefUpdate(java.lang.String project, java.lang.String refName) { java.lang.String key = com.google.gerrit.acceptance.EventRecorder.key(RefUpdatedEvent.TYPE, project, refName); assertThat(recordedEvents).containsKey(key); java.util.Collection<com.google.gerrit.server.events.RefEvent> events = recordedEvents.get(key); assertThat(events).hasSize(1); com.google.gerrit.server.events.Event e = events.iterator().next(); assertThat(e).isInstanceOf(com.google.gerrit.server.events.RefUpdatedEvent.class); return ((com.google.gerrit.server.events.RefUpdatedEvent) (e)); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "aaa\nbbb\nccc\n"); submit(change.getChangeId()); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "aaa\nbbb\nccc\nddd\n"); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(change.getCommit()); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "a.txt", "bbb\nccc\n"); submit(change3.getChangeId()); assertRebase(testRepo, true); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getParent(0)).isEqualTo(oldHead); assertApproved(change3.getChangeId()); assertCurrentRevision(change3.getChangeId(), 2, head); assertSubmitter(change3.getChangeId(), 1); assertSubmitter(change3.getChangeId(), 2); }
@org.junit.Test public void submitAfterReorderOfCommits() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c1 = commitBuilder().add("a.txt", "1").message("subject: 1").create(); org.eclipse.jgit.revwalk.RevCommit c2 = commitBuilder().add("b.txt", "2").message("subject: 2").create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master", false); java.lang.String id1 = com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c1).get(); java.lang.String id2 = com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c2).get(); testRepo.reset("HEAD~2"); testRepo.cherryPick(c2); testRepo.cherryPick(c1); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master", false); approve(id1); approve(id2); submit(id1); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change.getCommit()); assertThat(head.getParent(0)).isEqualTo(oldHead); assertApproved(change.getChangeId()); assertCurrentRevision(change.getChangeId(), 1, head); assertSubmitter(change.getChangeId(), 1); assertPersonEquals(admin.getIdent(), head.getAuthorIdent()); assertPersonEquals(admin.getIdent(), head.getCommitterIdent()); }
@org.junit.Test public void submitWithCherryPick() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); submit(change2.getChangeId()); assertCherryPick(testRepo, false); org.eclipse.jgit.revwalk.RevCommit newHead = getRemoteHead(); assertThat(newHead.getParentCount()).isEqualTo(1); assertThat(newHead.getParent(0)).isEqualTo(oldHead); assertCurrentRevision(change2.getChangeId(), 2, newHead); assertSubmitter(change2.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 2); assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent()); assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent()); }
@org.junit.Test public void submitSameCommitsAsInExperimentalBranch() throws java.lang.Exception { grant(Permission.CREATE, project, "refs/heads/*"); grant(Permission.PUSH, project, "refs/heads/experimental"); org.eclipse.jgit.revwalk.RevCommit c1 = commitBuilder().add("b.txt", "1").message("commit at tip").create(); java.lang.String id1 = com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c1).get(); org.eclipse.jgit.transport.PushResult r1 = com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master", false); assertThat(r1.getRemoteUpdate("refs/for/master").getNewObjectId()).isEqualTo(c1.getId()); org.eclipse.jgit.transport.PushResult r2 = com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/heads/experimental", false); assertThat(r2.getRemoteUpdate("refs/heads/experimental").getNewObjectId()).isEqualTo(c1.getId()); submit(id1); assertThat(getRemoteHead().getId()).isEqualTo(c1.getId()); assertSubmitter(id1, 1); }

@org.junit.Test public void submitFastForwardNotPossible_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); approve(change2.getChangeId()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> actions = getActions(change2.getChangeId()); assertThat(actions).containsKey("submit"); com.google.gerrit.extensions.common.ActionInfo info = actions.get("submit"); assertThat(info.enabled).isNull(); submitWithConflict(change2.getChangeId(), ((((("Failed to submit 1 change due to the following problems:\n" + "Change ") + (change2.getChange().getId())) + ": Project policy requires ") + "all submissions to be a fast-forward. Please rebase the change ") + "locally and upload again for review.")); assertThat(getRemoteHead()).isEqualTo(oldHead); assertSubmitter(change.getChangeId(), 1); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterFirstSubmit = getRemoteLog().get(0); assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage()); assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId()); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); approve(change3.getChangeId()); submit(change4.getChangeId()); assertMerged(change3.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterSecondSubmit = getRemoteLog().get(0); assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage()); assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId()); assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent()); assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent()); java.util.List<com.google.gerrit.server.events.RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2); com.google.gerrit.server.data.RefUpdateAttribute refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(initialHead.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name()); refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name()); }
@org.junit.Test public void submitChangesAfterBranchOnSecond() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); approve(change.getChangeId()); com.google.gerrit.acceptance.PushOneCommit.Result change2nd = createChange(); approve(change2nd.getChangeId()); com.google.gerrit.reviewdb.client.Project.NameKey project = change2nd.getChange().change().getProject(); com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, "branch"); createBranchWithRevision(branch, change2nd.getCommit().getName()); gApi.changes().id(change2nd.getChangeId()).current().submit(); assertMerged(change2nd.getChangeId()); assertMerged(change.getChangeId()); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content"); submitWithConflict(change2.getChangeId(), (("Cannot rebase " + (change2.getCommit().name())) + ": The change could not be rebased due to a conflict during merge.")); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head).isEqualTo(oldHead); assertCurrentRevision(change2.getChangeId(), 1, change2.getCommit()); assertNoSubmitter(change2.getChangeId(), 1); }
@org.junit.Test public void submitDependentNonConflictingChangesOutOfOrder() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit()); submit(change3.getChangeId()); submit(change2.getChangeId()); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); assertThat(log.get(0).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); assertThat(log.get(0).getParent(0)).isEqualTo(log.get(1)); assertThat(log.get(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); assertThat(log.get(1).getParent(0)).isEqualTo(log.get(2)); assertThat(log.get(2).getId()).isEqualTo(initialHead.getId()); }
@org.junit.Test public void submitOutOfOrder() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); createChange("Change 2", "b.txt", "other content"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "different content"); submit(change3.getChangeId()); assertCherryPick(testRepo, false); org.eclipse.jgit.revwalk.RevCommit newHead = getRemoteHead(); assertThat(newHead.getParent(0)).isEqualTo(oldHead); assertApproved(change3.getChangeId()); assertCurrentRevision(change3.getChangeId(), 2, newHead); assertSubmitter(change3.getChangeId(), 1); assertSubmitter(change3.getChangeId(), 2); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge_Conflict() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content"); submitWithConflict(change2.getChangeId(), ((((("Failed to submit 1 change due to the following problems:\n" + "Change ") + (change2.getChange().getId())) + ": Change could not be ") + "merged due to a path conflict. Please rebase the change locally and ") + "upload the rebased commit for review.")); assertThat(getRemoteHead()).isEqualTo(oldHead); assertCurrentRevision(change2.getChangeId(), 1, change2.getCommit()); assertNoSubmitter(change2.getChangeId(), 1); }
@org.junit.Test public void submitWithMergeIfFastForwardPossible() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getParentCount()).isEqualTo(2); assertThat(head.getParent(0)).isEqualTo(oldHead); assertThat(head.getParent(1)).isEqualTo(change.getCommit()); assertSubmitter(change.getChangeId(), 1); assertPersonEquals(admin.getIdent(), head.getAuthorIdent()); assertPersonEquals(serverIdent.get(), head.getCommitterIdent()); }
@org.junit.Test public void submitTwoChangesWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit originalHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); java.lang.String id1 = change.getChangeId(); java.lang.String id2 = change2.getChangeId(); approve(id1); submit(id2); org.eclipse.jgit.revwalk.RevCommit updatedHead = getRemoteHead(); assertThat(updatedHead.getId()).isEqualTo(change2.getCommit()); assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit()); assertSubmitter(change.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 1); assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent()); assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent()); assertSubmittedTogether(id1, id2, id1); assertSubmittedTogether(id2, id2, id1); RefUpdatedEvent refUpdate = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master"); assertThat(refUpdate.refUpdate.get().oldRev).isEqualTo(originalHead.name()); assertThat(refUpdate.refUpdate.get().newRev).isEqualTo(updatedHead.name()); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithRebase() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterFirstSubmit = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content"); submit(change2.getChangeId()); assertRebase(testRepo, false); org.eclipse.jgit.revwalk.RevCommit headAfterSecondSubmit = getRemoteHead(); assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit); assertApproved(change2.getChangeId()); assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit); assertSubmitter(change2.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 2); assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent()); assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent()); com.google.common.collect.ImmutableList<com.google.gerrit.server.events.RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2); com.google.gerrit.server.data.RefUpdateAttribute refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(initialHead.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name()); refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name()); }
@org.junit.Test public void submitWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change.getCommit()); assertThat(head.getParent(0)).isEqualTo(oldHead); assertSubmitter(change.getChangeId(), 1); }
@org.junit.Test public void submitWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(change.getCommit()); assertThat(head.getParent(0)).isEqualTo(oldHead); assertSubmitter(change.getChangeId(), 1); assertPersonEquals(admin.getIdent(), head.getAuthorIdent()); assertPersonEquals(admin.getIdent(), head.getCommitterIdent()); }

@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitIdenticalTree() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "a"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "a"); submit(change1.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); assertThat(oldHead.getShortMessage()).isEqualTo("Change 1"); submit(change2.getChangeId(), new com.google.gerrit.extensions.api.changes.SubmitInput(), null, null, false); assertThat(getRemoteHead()).isEqualTo(oldHead); com.google.gerrit.extensions.common.ChangeInfo info2 = get(change2.getChangeId()); assertThat(info2.status).isEqualTo(ChangeStatus.MERGED); assertThat(com.google.common.collect.Iterables.getLast(info2.messages).message).isEqualTo(CommitMergeStatus.SKIPPED_IDENTICAL_TREE.getMessage()); }

public com.google.gerrit.server.events.ChangeMergedEvent getOneChangeMerged(java.lang.String project, java.lang.String branch, final java.lang.String changeNumber) throws java.lang.Exception { java.lang.String key = com.google.gerrit.acceptance.EventRecorder.key(ChangeMergedEvent.TYPE, project, (branch.startsWith(com.google.gerrit.acceptance.R_HEADS) ? branch : (R_HEADS) + branch)); assertThat(recordedEvents).containsKey(key); java.util.List<com.google.gerrit.server.events.RefEvent> events = com.google.common.collect.FluentIterable.from(recordedEvents.get(key)).filter(new com.google.common.base.Predicate<com.google.gerrit.server.events.RefEvent>() { @java.lang.Override public boolean apply(com.google.gerrit.server.events.RefEvent input) { assertThat(input).isInstanceOf(com.google.gerrit.server.events.ChangeMergedEvent.class); com.google.gerrit.server.events.ChangeMergedEvent e = ((com.google.gerrit.server.events.ChangeMergedEvent) (input)); return e.change.get().number.equals(changeNumber); } }).toList(); assertThat(events).hasSize(1); return ((com.google.gerrit.server.events.ChangeMergedEvent) (events.get(0))); }
@org.junit.Test public void submitTwoChangesWithFastForward_missingDependency() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); com.google.gerrit.reviewdb.client.Change.Id id1 = change1.getPatchSetId().getParentKey(); submitWithConflict(change2.getChangeId(), ((("Failed to submit 2 changes due to the following problems:\n" + "Change ") + id1) + ": needs Code-Review")); org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead(); assertThat(head.getId()).isEqualTo(oldHead.getId()); }
public com.google.common.collect.ImmutableList<com.google.gerrit.server.events.RefEvent> getRefUpdates(java.lang.String project, java.lang.String refName, int expectedSize) { java.lang.String key = com.google.gerrit.acceptance.EventRecorder.key(RefUpdatedEvent.TYPE, project, refName); assertThat(recordedEvents).containsKey(key); java.util.Collection<com.google.gerrit.server.events.RefEvent> events = recordedEvents.get(key); assertThat(events).hasSize(expectedSize); return com.google.common.collect.ImmutableList.copyOf(events); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(createEmptyCommit = false) public void mergeWithMissingChange() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result draftResult = createDraftChange(); com.google.gerrit.acceptance.PushOneCommit.Result changeResult = createChange(); gApi.changes().id(draftResult.getChangeId()).delete(); submit(changeResult.getChangeId(), new com.google.gerrit.extensions.api.changes.SubmitInput(), com.google.gerrit.extensions.restapi.ResourceConflictException.class, "nothing to merge", false); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitWithContentMerge() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "aaa\nbbb\nccc\n"); submit(change.getChangeId()); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "aaa\nbbb\nccc\nddd\n"); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit oldHead = getRemoteHead(); testRepo.reset(change.getCommit()); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "a.txt", "bbb\nccc\n"); submit(change3.getChangeId()); assertCherryPick(testRepo, true); org.eclipse.jgit.revwalk.RevCommit newHead = getRemoteHead(); assertThat(newHead.getParent(0)).isEqualTo(oldHead); assertApproved(change3.getChangeId()); assertCurrentRevision(change3.getChangeId(), 2, newHead); assertSubmitter(change2.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 2); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); com.google.gerrit.acceptance.PushOneCommit.Result change5 = createChange("Change 5", "d", "d"); approve(change2.getChangeId()); submit(change3.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterFirstSubmit = getRemoteLog().get(0); assertThat(headAfterFirstSubmit.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId()); assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getAuthorIdent()); assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getCommitterIdent()); approve(change4.getChangeId()); submit(change5.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterSecondSubmit = getRemoteLog().get(0); assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change5.getCommit().getShortMessage()); assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent()); assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent()); assertNew(change2.getChangeId()); java.util.List<com.google.gerrit.server.events.RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2); com.google.gerrit.server.data.RefUpdateAttribute refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(initialHead.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name()); refUpdate = ((com.google.gerrit.server.events.RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name()); assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name()); }
@org.junit.Test public void openChangeForTargetBranchPreventsMerge() throws java.lang.Exception { gApi.projects().name(project.get()).branch("stable").create(new com.google.gerrit.extensions.api.projects.BranchInput()); com.google.gerrit.acceptance.PushOneCommit change2 = pushFactory.create(db, user.getIdent(), testRepo, "small fix", "a.txt", "2"); com.google.gerrit.acceptance.PushOneCommit.Result change2result = change2.to("refs/for/master"); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "stable"; in.message = "it goes to stable branch"; com.google.gerrit.extensions.api.changes.ChangeApi orig = gApi.changes().id(change2result.getChangeId()); com.google.gerrit.extensions.api.changes.ChangeApi cherry = orig.current().cherryPick(in); cherry.current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); cherry.current().submit(); testRepo.git().fetch().setRefSpecs(new org.eclipse.jgit.transport.RefSpec("refs/heads/stable")).call(); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange(testRepo, "stable", "test", "a.txt", "3", ""); submitWithConflict(change3.getChangeId(), ((("Failed to submit 1 change due to the following problems:\n" + "Change ") + (change3.getPatchSetId().getParentKey().get())) + ": depends on change that was not submitted")); }
@org.junit.Test public void submitWithMergedAncestorsOnOtherBranch() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange(testRepo, "master", "base commit", "a.txt", "1", ""); submit(change1.getChangeId()); gApi.projects().name(project.get()).branch("branch").create(new com.google.gerrit.extensions.api.projects.BranchInput()); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(testRepo, "master", "We want to commit this to master first", "a.txt", "2", ""); submit(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit tip1 = getRemoteLog(project, "master").get(0); assertThat(tip1.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); org.eclipse.jgit.revwalk.RevCommit tip2 = getRemoteLog(project, "branch").get(0); assertThat(tip2.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage()); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange(testRepo, "branch", ("This commit is based on master, which includes change2, " + "but is targeted at branch, which doesn't include it."), "a.txt", "3", ""); submit(change3.getChangeId()); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log3 = getRemoteLog(project, "branch"); assertThat(log3.get(0).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); assertThat(log3.get(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage()); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c", "c"); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change4 = createChange("Change 4", "d", "d"); approve(change2.getChangeId()); approve(change3.getChangeId()); submit(change4.getChangeId()); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); assertThat(log.get(0).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage()); assertThat(log.get(1).getId()).isEqualTo(initialHead.getId()); assertNew(change2.getChangeId()); assertNew(change3.getChangeId()); RefUpdatedEvent event = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master"); com.google.gerrit.server.data.RefUpdateAttribute refUpdate = event.refUpdate.get(); assertThat(refUpdate.oldRev).isEqualTo(initialHead.name()); assertThat(refUpdate.newRev).isEqualTo(log.get(0).name()); }
@org.junit.Test public void submitDependentConflictingChangesOutOfOrder() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); testRepo.reset(initialHead); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b", "b1"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "b", "b2"); assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit()); submitWithConflict(change3.getChangeId(), ((((("Failed to submit 1 change due to the following problems:\n" + "Change ") + (change3.getChange().getId())) + ": Change could not be ") + "merged due to a path conflict. Please rebase the change locally and ") + "upload the rebased commit for review.")); com.google.gerrit.extensions.common.ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES); assertThat(info3.status).isEqualTo(ChangeStatus.NEW); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); assertThat(log.get(0)).isEqualTo(initialHead.getId()); assertNoSubmitter(change3.getChangeId(), 1); }
@org.junit.Test public void submitWithCherryPickIfFastForwardPossible() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); submit(change.getChangeId()); assertCherryPick(testRepo, false); assertThat(getRemoteHead().getParent(0)).isEqualTo(change.getCommit().getParent(0)); }
@java.lang.Override public void close() { java.util.List<com.google.common.util.concurrent.ListenableFuture<?>> closeFutures = com.google.common.collect.Lists.newArrayListWithCapacity(2); closeFutures.add(executor.submit(new java.lang.Runnable() { @java.lang.Override public void run() { openIndex.close(); } })); closeFutures.add(executor.submit(new java.lang.Runnable() { @java.lang.Override public void run() { closedIndex.close(); } })); com.google.common.util.concurrent.Futures.getUnchecked(com.google.common.util.concurrent.Futures.allAsList(closeFutures)); }

@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } emailReviewers(ctx.getProject(), currChange, del, changeMessage); try { hooks.doReviewerDeletedHook(currChange, reviewer, currPs, changeMessage.getMessage(), newApprovals, oldApprovals, dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.DeleteReviewer.log.warn("ChangeHook.doCommentAddedHook delivery failed", e); } }
private java.util.List<com.google.gerrit.server.notedb.ChangeNotes> scanNoteDb(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> ids = com.google.gerrit.server.notedb.ChangeNotes.Factory.scan(repo); java.util.List<com.google.gerrit.server.notedb.ChangeNotes> changeNotes = new java.util.ArrayList(ids.size()); for (com.google.gerrit.reviewdb.client.Change.Id id : ids) { changeNotes.add(create(db, project, id)); } return changeNotes; }
@org.junit.Test public void submitTwoChangesWithFastForward() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); java.lang.String id1 = change.getChangeId(); java.lang.String id2 = change2.getChangeId(); approve(id1); submit(id2); org.eclipse.jgit.revwalk.RevCommit updatedHead = getRemoteHead(); assertThat(updatedHead.getId()).isEqualTo(change2.getCommit()); assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit()); assertSubmitter(change.getChangeId(), 1); assertSubmitter(change2.getChangeId(), 1); assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent()); assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent()); assertSubmittedTogether(id1, id2, id1); assertSubmittedTogether(id2, id2, id1); assertRefUpdatedEvents(initialHead, updatedHead); assertChangeMergedEvents(change2.getChangeId(), updatedHead.name(), change.getChangeId(), updatedHead.name()); }
@org.junit.Test public void submitMultipleChanges() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "b", "b"); submit(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterFirstSubmit = getRemoteLog().get(0); assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change.getCommit().getShortMessage()); assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage()); assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId()); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "c", "c"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "d", "d"); approve(change2.getChangeId()); submit(change3.getChangeId()); assertMerged(change2.getChangeId()); org.eclipse.jgit.revwalk.RevCommit headAfterSecondSubmit = getRemoteLog().get(0); assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage()); assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage()); assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId()); assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent()); assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent()); assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit); assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name()); }
@java.lang.Override protected void doGetJson(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gitiles.GitilesView view = com.google.gitiles.ViewFilter.getView(req); org.eclipse.jgit.lib.Repository repo = org.eclipse.jgit.http.server.ServletUtils.getRepository(req); java.lang.String longStr = req.getParameter("long"); boolean includeSizes = (longStr != null) && ((longStr.isEmpty()) || (java.lang.Boolean.TRUE.equals(org.eclipse.jgit.util.StringUtils.toBooleanOrNull(longStr)))); java.lang.String recursiveStr = req.getParameter("recursive"); boolean recursive = (recursiveStr != null) && ((recursiveStr.isEmpty()) || (java.lang.Boolean.TRUE.equals(org.eclipse.jgit.util.StringUtils.toBooleanOrNull(recursiveStr)))); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);com.google.gitiles.PathServlet.WalkResult wr = com.google.gitiles.PathServlet.WalkResult.forPath(rw, view, recursive)) { if (wr == null) { res.setStatus(com.google.gitiles.SC_NOT_FOUND); return; } switch (wr.type) { case TREE : renderJson(req, res, com.google.gitiles.TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class); break; default : res.setStatus(com.google.gitiles.SC_NOT_FOUND); break; } } catch (org.eclipse.jgit.errors.LargeObjectException e) { res.setStatus(com.google.gitiles.SC_INTERNAL_SERVER_ERROR); } }
public java.lang.String getRevisionRange() { if ((oldRevision) == (Revision.NULL)) { switch (type) { case LOG : case DIFF : return (revision.getName()) + "^!"; default : return null; } } else if (((type) == (com.google.gitiles.GitilesView.Type.DIFF)) && (com.google.gitiles.GitilesView.isFirstParent(revision, oldRevision))) { return (revision.getName()) + "^!"; } else { return ((oldRevision.getName()) + "..") + (revision.getName()); } }
public com.google.gitiles.GitilesView.Builder setOldRevision(com.google.gitiles.Revision revision) { switch (type) { case DIFF : case LOG : break; default : revision = firstNonNull(revision, Revision.NULL); checkState((revision == (Revision.NULL)), "cannot set old revision on %s view", type); break; } this.oldRevision = revision; return this; }
public com.google.gitiles.GitilesView.Builder setRepositoryPrefix(java.lang.String prefix) { switch (type) { case HOST_INDEX : this.repositoryPrefix = (prefix != null) ? com.google.common.base.Strings.emptyToNull(com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash(prefix)) : null; return this; default : throw new java.lang.IllegalStateException(java.lang.String.format("cannot set repository prefix on %s view", type)); } }
private static com.google.gitiles.Paginator newPaginator(org.eclipse.jgit.lib.Repository repo, com.google.gitiles.GitilesView view, com.google.gitiles.GitilesAccess access) throws java.io.IOException { if (view == null) { return null; } org.eclipse.jgit.revwalk.RevWalk walk = null; try { walk = com.google.gitiles.LogServlet.newWalk(repo, view, access); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException e) { return null; } com.google.common.base.Optional<org.eclipse.jgit.lib.ObjectId> start; try { start = com.google.gitiles.LogServlet.getStart(view.getParameters(), walk.getObjectReader()); } catch (java.io.IOException e) { walk.close(); throw e; } if (start == null) { return null; } return new com.google.gitiles.Paginator(walk, com.google.gitiles.LogServlet.getLimit(view), start.orNull()); }
@java.lang.Override public void postUpdate(final com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { if ((changeKind) != (com.google.gerrit.server.change.ChangeKind.TRIVIAL_REBASE)) { java.lang.Runnable sender = new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId()); cm.setFrom(ctx.getUser().getAccountId()); cm.setPatchSet(newPatchSet, info); cm.setChangeMessage(msg); if (((magicBranch) != null) && ((magicBranch.notify) != null)) { cm.setNotify(magicBranch.notify); } cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReplaceOp.log.error(("Cannot send email for new patch set " + (newPatchSet.getId())), e); } if ((mergedIntoRef) != null) { sendMergedEmail(ctx); } } @java.lang.Override public java.lang.String toString() { return "send-email newpatchset"; } }; if ((requestScopePropagator) != null) { sendEmailExecutor.submit(requestScopePropagator.wrap(sender)); } else { sender.run(); } } com.google.gerrit.reviewdb.client.Account account = ctx.getUser().asIdentifiedUser().getAccount(); hooks.doPatchsetCreatedHook(change, newPatchSet, ctx.getDb()); if ((mergedIntoRef) != null) { hooks.doChangeMergedHook(change, account, newPatchSet, ctx.getDb(), commit.getName()); } try { runHook(ctx); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReplaceOp.log.warn("ChangeHook.doCommentAddedHook delivery failed", e); } }

private com.google.gerrit.server.notedb.NoteDbChangeState execute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.server.notedb.NoteDbUpdateManager manager) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.NoteDbChangeState newState; db.changes().beginTransaction(changeId); try { com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); if (change == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } newState = com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(change, manager.stage().get(changeId)); db.changes().update(java.util.Collections.singleton(change)); db.commit(); } finally { db.rollback(); } manager.execute(); return newState; }

private com.google.gerrit.server.notedb.LoadHandle rebuildAndOpen(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { try { com.google.gerrit.server.notedb.NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId()); if (newState == null) { return super.openHandle(repo); } org.eclipse.jgit.lib.ObjectId draftsId = newState.getDraftIds().get(author); repo.scanForRepoChanges(); return com.google.gerrit.server.notedb.LoadHandle.create(com.google.gerrit.server.notedb.ChangeNotesCommit.newRevWalk(repo), draftsId); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return super.openHandle(repo); } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } }
private com.google.gerrit.server.notedb.LoadHandle rebuildAndOpen(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId oldId) throws java.io.IOException { try { com.google.gerrit.server.notedb.NoteDbChangeState newState; try { newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId()).newState(); repo.scanForRepoChanges(); } catch (java.io.IOException e) { newState = recheckUpToDate(repo, e); } if (newState == null) { return super.openHandle(repo, oldId); } return com.google.gerrit.server.notedb.LoadHandle.create(com.google.gerrit.server.notedb.ChangeNotesCommit.newRevWalk(repo), newState.getChangeMetaId()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return super.openHandle(repo, oldId); } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } }
private com.google.gerrit.server.notedb.LoadHandle rebuildAndOpen(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId oldId) throws java.io.IOException { try { com.google.gerrit.server.notedb.NoteDbChangeState newState; try { newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId()); repo.scanForRepoChanges(); } catch (java.io.IOException e) { newState = recheckUpToDate(repo, e); } if (newState == null) { return super.openHandle(repo, oldId); } return com.google.gerrit.server.notedb.LoadHandle.create(com.google.gerrit.server.notedb.ChangeNotesCommit.newRevWalk(repo), newState.getChangeMetaId()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return super.openHandle(repo, oldId); } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules, com.google.gerrit.extensions.api.changes.SubmitInput submitInput) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { this.submitInput = submitInput; this.caller = caller; updateSubmissionId(change); this.db = db; orm.setContext(db, ts, caller, submissionId); logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller); checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs); this.commits = new com.google.gerrit.server.git.MergeOp.CommitStatus(cs); com.google.gerrit.server.git.MergeSuperSet.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); failFast(cs); } else { logDebug("Bypassing submit rules"); bypassSubmitRules(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Error from integrateIntoHistory", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private java.util.List<com.google.gerrit.server.query.change.ChangeData> getForOpenChange(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user); return cs.changes().asList(); }
private void initTopicLink(com.google.gerrit.client.info.ChangeInfo info) { if (((info.topic()) != null) && (!(info.topic().isEmpty()))) { text.setText(info.topic()); text.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toChangeQuery(com.google.gerrit.common.PageLinks.op("topic", info.topic()))); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> submittedTogether() throws com.google.gerrit.extensions.restapi.RestApiException { try { return ((java.util.List<com.google.gerrit.extensions.common.ChangeInfo>) (submittedTogether.apply(change))); } catch (java.lang.Exception e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot query submittedTogether", e); } }

@java.lang.Override public com.google.gerrit.server.config.GetServerInfo.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.server.config.GetServerInfo.ServerInfo info = new com.google.gerrit.server.config.GetServerInfo.ServerInfo(); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.plugin = getPluginInfo(); info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
public static boolean isInternalGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return uuid.get().matches("^[0-9a-f]{40}$"); }
@org.junit.Test public void hiddenDraftInTopic() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); org.eclipse.jgit.revwalk.RevCommit a = commitBuilder().add("a", "1").message("change 1").create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, ("refs/for/master/" + (name("topic"))), false); java.lang.String id1 = getChangeId(a); testRepo.reset(initialHead); org.eclipse.jgit.revwalk.RevCommit b = commitBuilder().add("b", "2").message("invisible change").create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, ("refs/drafts/master/" + (name("topic"))), false); setApiUser(user); if (isSubmitWholeTopicEnabled()) { try { gApi.changes().id(id1).submittedTogether(); fail("Expected AuthException"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertThat(e.getCause()).isInstanceOf(com.google.gerrit.extensions.restapi.AuthException.class); assertThat(e.getCause()).hasMessage("change would be submitted with a change that you cannot see"); } } else { assertSubmittedTogether(id1); } }



@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> submittedTogether() throws com.google.gerrit.extensions.restapi.RestApiException { try { return submittedTogether.apply(change); } catch (java.lang.Exception e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot query submittedTogether", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, java.lang.Exception { try { com.google.gerrit.reviewdb.client.Change c = resource.getChange(); java.util.List<com.google.gerrit.server.query.change.ChangeData> cds; if (c.getStatus().isOpen()) { cds = getForOpenChange(c, resource.getControl().getUser()); } else if ((c.getStatus().asChangeStatus()) == (com.google.gerrit.extensions.client.ChangeStatus.MERGED)) { cds = getForMergedChange(c); } else { cds = getForAbandonedChange(); } if ((cds.size()) <= 1) { cds = java.util.Collections.emptyList(); } else { cds = sort(cds); } return json.create(java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { com.google.gerrit.server.change.SubmittedTogether.log.error("Error on getting a ChangeSet", e); throw e; } }

@java.lang.Override public boolean cancel(boolean mayInterruptIfRunning) { if (task.cancel(mayInterruptIfRunning)) { if (((runnable) instanceof com.google.gerrit.server.git.WorkQueue.CancelableRunnable) && (running.compareAndSet(false, true))) { ((com.google.gerrit.server.git.WorkQueue.CancelableRunnable) (runnable)).cancel(); } executor.remove(this); executor.purge(); return true; } else { return false; } }



void cancel() { canceled = true; }
@org.junit.Test public void addAccessSection() throws java.lang.Exception { ProjectAccessInput accessInput = newProjectAccessInput(); AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo(); accessInput.add.put(REFS_HEADS, accessSectionInfo); pApi.access(accessInput); assertThat(pApi.access().local).isEqualTo(accessInput.add); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } com.google.gerrit.server.IdentifiedUser user = ctx.getUser().asIdentifiedUser(); try { com.google.gerrit.server.mail.ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId()); cm.setFrom(user.getAccountId()); cm.setChangeMessage(changeMessage); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.DeleteVote.log.error(("Cannot email update for change " + (change.getId())), e); } try { hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.DeleteVote.log.warn("ChangeHook.doCommentAddedHook delivery failed", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, com.google.gerrit.server.project.DeleteBranches.Input input) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { input = com.google.gerrit.server.project.DeleteBranches.Input.init(input); try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project.getNameKey())) { org.eclipse.jgit.lib.BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate(); for (java.lang.String branch : input.branches) { batchUpdate.addCommand(createDeleteCommand(project, r, branch)); } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { batchUpdate.execute(rw, NullProgressMonitor.INSTANCE); } java.lang.StringBuilder errorMessages = new java.lang.StringBuilder(); for (org.eclipse.jgit.transport.ReceiveCommand command : batchUpdate.getCommands()) { if ((command.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.OK)) { postDeletion(project, command); } else { appendAndLogErrorMessage(errorMessages, command); } } if ((errorMessages.length()) > 0) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(errorMessages.toString()); } } return com.google.gerrit.extensions.restapi.Response.none(); }





@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } emailReviewers(ctx.getProject(), currChange, del, changeMessage); try { hooks.doReviewerDeletedHook(currChange, reviewer, currPs, changeMessage.getMessage(), newApprovals, oldApprovals, dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.DeleteReviewer.log.warn("ChangeHook.doReviewerDeletedHook invocation failed", e); } }








@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { if (sendMail) { try { com.google.gerrit.server.mail.ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId()); cm.setFrom(ctx.getUser().getAccountId()); cm.setPatchSet(patchSet, patchSetInfo); cm.setChangeMessage(changeMessage); cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER)); cm.addExtraCC(oldReviewers.get(ReviewerState.CC)); cm.send(); } catch (java.lang.Exception err) { com.google.gerrit.server.change.PatchSetInserter.log.error(("Cannot send email for new patch set on change " + (change.getId())), err); } } if (runHooks) { revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId()); hooks.doPatchsetCreatedHook(change, patchSet, ctx.getDb()); } }










private void setMerged(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.ChangeMessage msg, org.eclipse.jgit.lib.ObjectId mergeResultRev) throws com.google.gwtorm.server.OrmException, java.io.IOException { logDebug("Setting change {} merged", c.getId()); com.google.gerrit.server.notedb.ChangeUpdate update = null; final com.google.gerrit.reviewdb.client.PatchSetApproval submitter; com.google.gerrit.reviewdb.client.PatchSet merged; try { db.changes().beginTransaction(c.getId()); com.google.gerrit.server.git.CodeReviewCommit commit = commits.get(c.getId()); com.google.gerrit.reviewdb.client.PatchSet.Id mergedId = commit.change().currentPatchSetId(); merged = db.patchSets().get(mergedId); c = setMergedPatchSet(c.getId(), mergedId); submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId); com.google.gerrit.server.project.ChangeControl control = commit.getControl(); update = updateFactory.create(control, c.getLastUpdatedOn()); if (msg != null) { cmUtil.addChangeMessage(db, update, msg); } db.commit(); } finally { db.rollback(); } update.commit(); indexer.index(db, c); try { mergedSenderFactory.create(c.getId(), (submitter != null ? submitter.getAccountId() : null)).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.MergeOp.log.error(("Cannot email merged notification for " + (c.getId())), e); } if ((submitter != null) && (mergeResultRev != null)) { try { changeMerged.fire(c, merged, accountCache.get(submitter.getAccountId()).getAccount(), mergeResultRev.name()); hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name()); } catch (com.google.gwtorm.server.OrmException ex) { logError(("Cannot run hook for submitted patch set " + (c.getId())), ex); } } }





@java.lang.Override public void doReviewerAddedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { ReviewerAddedEvent event = new ReviewerAddedEvent(change); com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> owner = getAccountSupplier(change.getOwner()); event.change = changeAttributeSupplier(change); event.patchSet = patchSetAttributeSupplier(change, patchSet); event.reviewer = accountAttributeSupplier(account); dispatcher.get().postEvent(change, event, db); if (!(reviewerAddedHook.isPresent())) { return; } java.util.List<java.lang.String> args = new java.util.ArrayList<>(); com.google.gerrit.server.data.ChangeAttribute c = event.change.get(); addArg(args, "--change", c.id); addArg(args, "--change-url", c.url); addArg(args, "--change-owner", getDisplayName(owner.get().getAccount())); addArg(args, "--project", c.project); addArg(args, "--branch", c.branch); addArg(args, "--reviewer", getDisplayName(account)); runHook(change.getProject(), reviewerAddedHook, args); }

@java.lang.Override protected com.google.gerrit.common.data.ProjectAccess updateProjectConfig(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.server.git.ProjectConfig config, com.google.gerrit.server.git.MetaDataUpdate md, boolean parentProjectUpdate) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.revwalk.RevCommit commit = config.commit(md); hooks.doRefUpdatedHook(new com.google.gerrit.reviewdb.client.Branch.NameKey(config.getProject().getNameKey(), com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG), base, commit.getId(), user.getAccount()); projectCache.evict(config.getProject()); return projectAccessFactory.create(projectName).call(); }
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gwtorm.server.OrmException { referenceUpdated.fire(project.getNameKey(), cmd); com.google.gerrit.reviewdb.client.Branch.NameKey branchKey = new com.google.gerrit.reviewdb.client.Branch.NameKey(project.getNameKey(), cmd.getRefName()); hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount()); com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey); dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } com.google.gerrit.server.IdentifiedUser user = ctx.getUser().asIdentifiedUser(); try { com.google.gerrit.server.mail.ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId()); cm.setFrom(user.getAccountId()); cm.setChangeMessage(changeMessage); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.DeleteVote.log.error(("Cannot email update for change " + (change.getId())), e); } try { hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.DeleteVote.log.warn("ChangeHook.doCommentAddedHook invocation failed", e); } }
@java.lang.Override public void postUpdate(final com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { if (!(correctBranch)) { return; } sendEmailExecutor.submit(requestScopePropagator.wrap(new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.MergedSender cm = mergedSenderFactory.create(ctx.getProject(), psId.getParentKey()); cm.setFrom(ctx.getUser().getAccountId()); cm.setPatchSet(patchSet, info); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.MergedByPushOp.log.error(("Cannot send email for submitted patch set " + (psId)), e); } } @java.lang.Override public java.lang.String toString() { return "send-email merged"; } })); com.google.gerrit.reviewdb.client.Account account = ctx.getUser().asIdentifiedUser().getAccount(); hooks.doChangeMergedHook(change, account, patchSet, ctx.getDb(), patchSet.getRevision().get()); changeMerged.fire(change, patchSet, account, patchSet.getRevision().get()); }





@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { if ((change) != null) { topicEdited.fire(change, caller.getAccount(), oldTopicName); hooks.doTopicChangedHook(change, caller.getAccount(), oldTopicName, ctx.getDb()); } }

@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { try { com.google.gerrit.server.mail.ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId()); if ((account) != null) { cm.setFrom(account.getId()); } cm.setChangeMessage(message); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.Abandon.log.error(("Cannot email update for change " + (change.getId())), e); } hooks.doChangeAbandonedHook(change, account, patchSet, com.google.common.base.Strings.emptyToNull(msgTxt), ctx.getDb()); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((message) == null) { return; } if ((in.notify.compareTo(NotifyHandling.NONE)) > 0) { email.create(in.notify, change, ps, user.getAccountId(), message, comments).sendAsync(); } try { commentAdded.fire(change, ps, user.getAccount(), message.getMessage(), categories, ctx.getWhen()); hooks.doCommentAddedHook(change, user.getAccount(), ps, message.getMessage(), categories, ctx.getDb()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.PostReview.log.warn("ChangeHook.doCommentAddedHook delivery failed", e); } }




private void fireRefUpdated(com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, org.eclipse.jgit.lib.RefUpdate branchUpdate) { logDebug("Firing ref updated hooks for {}", branchUpdate.getName()); gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate); hooks.doRefUpdatedHook(destBranch, branchUpdate, getAccount(mergeTips.get(destBranch).getCurrentTip())); }

@java.lang.Override public void doDraftPublishedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { DraftPublishedEvent event = new DraftPublishedEvent(change); com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> uploader = getAccountSupplier(patchSet.getUploader()); com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> owner = getAccountSupplier(change.getOwner()); event.change = changeAttributeSupplier(change); event.patchSet = patchSetAttributeSupplier(change, patchSet); event.uploader = accountAttributeSupplier(uploader); dispatcher.get().postEvent(change, event, db); if (!(draftPublishedHook.isPresent())) { return; } java.util.List<java.lang.String> args = new java.util.ArrayList<>(); com.google.gerrit.server.data.ChangeAttribute c = event.change.get(); com.google.gerrit.server.data.PatchSetAttribute ps = event.patchSet.get(); addArg(args, "--change", c.id); addArg(args, "--change-url", c.url); addArg(args, "--change-owner", getDisplayName(owner.get().getAccount())); addArg(args, "--project", c.project); addArg(args, "--branch", c.branch); addArg(args, "--topic", c.topic); addArg(args, "--uploader", getDisplayName(uploader.get().getAccount())); addArg(args, "--commit", ps.revision); addArg(args, "--patchset", ps.number); runHook(change.getProject(), draftPublishedHook, args); }
@java.lang.Override public void doPatchsetCreatedHook(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { PatchSetCreatedEvent event = new PatchSetCreatedEvent(change); com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> uploader = getAccountSupplier(patchSet.getUploader()); com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> owner = getAccountSupplier(change.getOwner()); event.change = changeAttributeSupplier(change); event.patchSet = patchSetAttributeSupplier(change, patchSet); event.uploader = accountAttributeSupplier(uploader); dispatcher.get().postEvent(change, event, db); if (!(patchsetCreatedHook.isPresent())) { return; } java.util.List<java.lang.String> args = new java.util.ArrayList<>(); com.google.gerrit.server.data.ChangeAttribute c = event.change.get(); com.google.gerrit.server.data.PatchSetAttribute ps = event.patchSet.get(); addArg(args, "--change", c.id); addArg(args, "--is-draft", java.lang.String.valueOf(patchSet.isDraft())); addArg(args, "--kind", java.lang.String.valueOf(ps.kind)); addArg(args, "--change-url", c.url); addArg(args, "--change-owner", getDisplayName(owner.get().getAccount())); addArg(args, "--project", c.project); addArg(args, "--branch", c.branch); addArg(args, "--topic", c.topic); addArg(args, "--uploader", getDisplayName(uploader.get().getAccount())); addArg(args, "--commit", ps.revision); addArg(args, "--patchset", ps.number); runHook(change.getProject(), patchsetCreatedHook, args); }






private int getEffectiveLimit(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(4); possibleLimits.add(getBackendSupportedLimit()); possibleLimits.add(getPermittedLimit()); if ((limitFromCaller) > 0) { possibleLimits.add(limitFromCaller); } java.lang.Integer limitFromPredicate = com.google.gerrit.server.query.change.LimitPredicate.getLimit(p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } return com.google.common.collect.Ordering.natural().min(possibleLimits); }

@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.change.IndexRewriter.class); bind(com.google.gerrit.server.index.change.ChangeIndexCollection.class); listener().to(com.google.gerrit.server.index.change.ChangeIndexCollection.class); factory(ChangeIndexer.Factory.class); }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); globalConfig = dbInjector.getInstance(com.google.inject.Key.get(org.eclipse.jgit.lib.Config.class, com.google.gerrit.server.config.GerritServerConfig.class)); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); checkNotSlaveMode(); disableLuceneAutomaticCommit(); disableChangeCache(); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); sysInjector.injectMembers(this); try { boolean ok = true; for (com.google.gerrit.server.index.IndexDefinition<?, ?, ?> def : indexDefs) { ok &= reindex(def); } return ok ? 0 : 1; } catch (java.lang.Exception e) { throw die(e.getMessage(), e); } finally { sysManager.stop(); dbManager.stop(); } }
@java.lang.Override public void evict(com.google.gerrit.reviewdb.client.Account.Id accountId) { if (accountId != null) { byId.invalidate(accountId); } }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); globalConfig = dbInjector.getInstance(com.google.inject.Key.get(org.eclipse.jgit.lib.Config.class, com.google.gerrit.server.config.GerritServerConfig.class)); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); checkNotSlaveMode(); disableLuceneAutomaticCommit(); disableChangeCache(); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); sysInjector.injectMembers(this); try { boolean ok = true; for (com.google.gerrit.server.index.IndexDefinition<?, ?, ?> def : indexDefs) { if (listIndices) { java.lang.System.out.format("%s\n", def.getName()); } else { ok &= reindex(def); } } return ok ? 0 : 1; } catch (java.lang.Exception e) { throw die(e.getMessage(), e); } finally { sysManager.stop(); dbManager.stop(); } }
@org.junit.Test public void annotatedTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit.AnnotatedTag tag = new com.google.gerrit.acceptance.PushOneCommit.AnnotatedTag("v2.0", "annotation", admin.getIdent()); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); push.setTag(tag); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/for/master%submit"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInfo tagInfo = getTag(tag.name); assertThat(tagInfo.ref).isEqualTo(((R_TAGS) + (tag.name))); assertThat(tagInfo.object).isEqualTo(r.getCommit().getName()); assertThat(tagInfo.message).isEqualTo(tag.message); assertThat(tagInfo.tagger.name).isEqualTo(tag.tagger.getName()); assertThat(tagInfo.tagger.email).isEqualTo(tag.tagger.getEmailAddress()); java.lang.String tag2ref = (R_TAGS) + "v2.0.1"; org.eclipse.jgit.api.PushCommand pushCmd = testRepo.git().push(); pushCmd.setRefSpecs(new org.eclipse.jgit.transport.RefSpec((((tag.name) + ":") + tag2ref))); java.lang.Iterable<org.eclipse.jgit.transport.PushResult> result = pushCmd.call(); assertThat(com.google.common.collect.Iterables.getOnlyElement(result).getRemoteUpdate(tag2ref).getStatus()).isEqualTo(Status.OK); tagInfo = getTag(tag2ref); assertThat(tagInfo.ref).isEqualTo(tag2ref); assertThat(tagInfo.object).isEqualTo(r.getCommit().getName()); assertThat(tagInfo.message).isEqualTo(tag.message); assertThat(tagInfo.tagger.name).isEqualTo(tag.tagger.getName()); assertThat(tagInfo.tagger.email).isEqualTo(tag.tagger.getEmailAddress()); }

@org.junit.Test public void lightweightTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit.Tag tag = new com.google.gerrit.acceptance.PushOneCommit.Tag("v1.0"); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); push.setTag(tag); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/for/master%submit"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInfo tagInfo = getTag(tag.name); assertThat(tagInfo.ref).isEqualTo(((R_TAGS) + (tag.name))); assertThat(tagInfo.revision).isEqualTo(r.getCommit().getName()); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.account.AccountIndexRewriter.class); bind(com.google.gerrit.server.index.account.AccountIndexCollection.class); listener().to(com.google.gerrit.server.index.account.AccountIndexCollection.class); factory(AccountIndexer.Factory.class); bind(com.google.gerrit.server.index.change.ChangeIndexRewriter.class); bind(com.google.gerrit.server.index.change.ChangeIndexCollection.class); listener().to(com.google.gerrit.server.index.change.ChangeIndexCollection.class); factory(ChangeIndexer.Factory.class); }
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { return fileCache.get(key, fileLoaderFactory.create(key, project)); } catch (java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e.getCause()); } }

















@com.google.common.annotations.VisibleForTesting static com.google.gerrit.server.index.QueryOptions convertOptions(com.google.gerrit.server.index.QueryOptions opts) { int backendLimit = opts.config().maxLimit(); int limit = com.google.common.primitives.Ints.saturatedCast((((long) (opts.limit())) + (opts.start()))); limit = java.lang.Math.min(limit, backendLimit); return com.google.gerrit.server.index.change.IndexedChangeQuery.createOptions(opts.config(), 0, limit, opts.fields()); }
public com.google.gerrit.server.query.change.ChangeQueryProcessor enforceVisibility(boolean enforce) { enforceVisibility = enforce; return this; }
@java.lang.Override public com.google.gerrit.server.notedb.NoteDbUpdateManager.Result execute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.server.notedb.NoteDbUpdateManager manager) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { db = unwrapDb(db); com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); if (change == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } final java.lang.String oldNoteDbState = change.getNoteDbState(); com.google.gerrit.server.notedb.NoteDbUpdateManager.Result r = manager.stageAndApplyDelta(change); final java.lang.String newNoteDbState = change.getNoteDbState(); try { db.changes().atomicUpdate(changeId, new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { if (!(java.util.Objects.equals(oldNoteDbState, change.getNoteDbState()))) { throw new com.google.gerrit.server.notedb.ChangeRebuilderImpl.AbortUpdateException(); } change.setNoteDbState(newNoteDbState); return change; } }); manager.execute(); } catch (com.google.gerrit.server.notedb.ChangeRebuilderImpl.AbortUpdateException e) { } return r; }
public static org.eclipse.jgit.lib.Config allEnabledConfig() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); for (com.google.gerrit.server.notedb.NoteDbTable t : com.google.gerrit.server.notedb.NoteDbTable.values()) { cfg.setBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t.key(), com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE, true); cfg.setBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t.key(), com.google.gerrit.server.notedb.ConfigNotesMigration.READ, true); } return cfg; }
public void execute() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return; } try (com.google.gerrit.metrics.Timer1.Context timer = metrics.updateLatency.start(com.google.gerrit.server.notedb.NoteDbTable.CHANGES)) { stage(); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(changeRepo); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(allUsersRepo); } finally { if ((allUsersRepo) != null) { allUsersRepo.close(); } if ((changeRepo) != null) { changeRepo.close(); } } }
private static void checkConfig(org.eclipse.jgit.lib.Config cfg) { java.util.Set<java.lang.String> keys = new java.util.HashSet<>(); for (com.google.gerrit.server.notedb.NoteDbTable t : com.google.gerrit.server.notedb.NoteDbTable.values()) { keys.add(t.key()); } for (java.lang.String t : cfg.getSubsections(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB)) { checkArgument(keys.contains(t.toLowerCase()), "invalid NoteDb table: %s", t); for (java.lang.String key : cfg.getNames(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t)) { java.lang.String lk = key.toLowerCase(); checkArgument(((lk.equals(com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE)) || (lk.equals(com.google.gerrit.server.notedb.ConfigNotesMigration.READ))), "invalid NoteDb key: %s.%s", t, key); } boolean write = cfg.getBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t, com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE, false); boolean read = cfg.getBoolean(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t, com.google.gerrit.server.notedb.ConfigNotesMigration.READ, false); checkArgument((!(read && (!write))), "must have write enabled when read enabled: %s", t); } }

private static void inline(org.commonmark.node.HtmlInline curr) { java.lang.String html = curr.getLiteral(); java.util.regex.Matcher m = com.google.gitiles.doc.GitilesHtmlExtension.BREAK.matcher(html); if (m.matches()) { switch (m.group(1).toLowerCase()) { case "br" : curr.insertAfter(new org.commonmark.node.HardLineBreak()); curr.unlink(); return; case "hr" : curr.insertAfter(new org.commonmark.node.ThematicBreak()); curr.unlink(); return; } } m = com.google.gitiles.doc.GitilesHtmlExtension.ANCHOR_OPEN.matcher(html); if (m.matches()) { java.lang.String name = m.group(2); org.commonmark.node.Node next = curr.getNext(); if (com.google.gitiles.doc.GitilesHtmlExtension.isAnchorClose(next)) { next.unlink(); next = curr.getNext(); com.google.gitiles.doc.NamedAnchor anchor = new com.google.gitiles.doc.NamedAnchor(); anchor.setName(name); curr.insertAfter(anchor); curr.unlink(); com.google.gitiles.doc.MarkdownUtil.trimPreviousWhitespace(anchor); return; } } curr.unlink(); }
private void fireChangeIndexedEvent(com.google.gerrit.server.query.change.ChangeData change) { for (com.google.gerrit.server.extensions.events.ChangeIndexedListener listener : indexedListener) { listener.onChangeIndexed(change); } }
private void fireChangeDeletedFromIndexEvent(com.google.gerrit.reviewdb.client.Change.Id id) { for (com.google.gerrit.server.extensions.events.ChangeIndexedListener listener : indexedListener) { listener.onChangeDeleted(id); } }
public abstract int getCost();
public abstract boolean match(T object) throws com.google.gwtorm.server.OrmException;

@java.lang.Override public boolean match(final T object) throws com.google.gwtorm.server.OrmException { return !(that.match(object)); }
@java.lang.Override public boolean match(final T object) throws com.google.gwtorm.server.OrmException { for (final com.google.gerrit.server.query.Predicate<T> c : children) { if (c.match(object)) { return true; } } return false; }

@java.lang.Override public boolean match(final T object) throws com.google.gwtorm.server.OrmException { for (final com.google.gerrit.server.query.Predicate<T> c : children) { if (!(c.match(object))) { return false; } } return true; }
public void update(final com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.reviewdb.server.ReviewDb db = com.google.gerrit.server.schema.SchemaUpdater.unwrap(schema.open())) { final com.google.gerrit.server.schema.SchemaVersion u = updater.get(); final com.google.gerrit.reviewdb.client.CurrentSchemaVersion version = getSchemaVersion(db); if (version == null) { try { creator.create(db); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Cannot initialize schema", e); } } else { try { u.check(ui, version, db); } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException("Cannot upgrade schema", e); } updateSystemConfig(db); } } }

@java.lang.Override public java.lang.Boolean call() { try (com.google.gerrit.reviewdb.server.ReviewDb db = com.google.gerrit.pgm.RebuildNoteDb.unwrap(schemaFactory.open())) { return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo); } catch (java.lang.Exception e) { com.google.gerrit.pgm.RebuildNoteDb.log.error(("Error rebuilding project " + project), e); return false; } }
@java.lang.Override public Iterable<java.lang.String> get(com.google.gerrit.server.account.AccountState input, com.google.gerrit.server.index.account.FillArgs args) { java.lang.String fullName = input.getAccount().getFullName(); Set<java.lang.String> parts = com.google.gerrit.server.index.SchemaUtil.getPersonParts(fullName, com.google.common.collect.Iterables.transform(input.getExternalIds(), new Function<com.google.gerrit.reviewdb.client.AccountExternalId, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.reviewdb.client.AccountExternalId in) { return in.getEmailAddress(); } })); if (fullName != null) { parts.add(fullName); } return parts; }




public com.google.gerrit.server.query.change.ChangeData.ChangedLines changedLines() throws com.google.gwtorm.server.OrmException { if ((changedLines) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return null; } com.google.gerrit.server.patch.PatchList p; try { p = patchListCache.get(c, ps); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { return null; } changedLines = new com.google.gerrit.server.query.change.ChangeData.ChangedLines(p.getInsertions(), p.getDeletions()); } return changedLines; }
public void remove(com.google.gerrit.common.data.AccessSection section) { if (section != null) { accessSections.remove(section.getName()); } }
@java.lang.Override public com.google.gerrit.server.api.accounts.SuggestAccountsRequest suggestAccounts() throws com.google.gerrit.extensions.restapi.RestApiException { return new com.google.gerrit.server.api.accounts.SuggestAccountsRequest() { @java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> get() throws com.google.gerrit.extensions.restapi.RestApiException { return com.google.gerrit.server.api.accounts.AccountsImpl.this.suggestAccounts(this); } }; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } if ((suggest) && ((!(suggestConfig)) || ((query.length()) < (suggestFrom)))) { return java.util.Collections.emptyList(); } com.google.gerrit.server.index.account.AccountIndex searchIndex = indexes.getSearchIndex(); if ((!(suggest)) && (searchIndex == null)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> matches = (searchIndex != null) ? queryFromIndex() : queryFromDb(); return AccountInfoComparator.ORDER_NULLS_LAST.sortedCopy(matches); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } if ((!(suggest)) || ((query.length()) < (suggestFrom))) { return java.util.Collections.emptyList(); } java.lang.String a = query; java.lang.String b = a + (com.google.gerrit.server.account.SuggestAccounts.MAX_SUFFIX); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> matches = new java.util.LinkedHashMap<>(); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, java.lang.String> queryEmail = new java.util.HashMap<>(); for (com.google.gerrit.reviewdb.client.Account p : db.accounts().suggestByFullName(a, b, limit)) { addSuggestion(matches, p); } if ((matches.size()) < (limit)) { for (com.google.gerrit.reviewdb.client.Account p : db.accounts().suggestByPreferredEmail(a, b, ((limit) - (matches.size())))) { addSuggestion(matches, p); } } if ((matches.size()) < (limit)) { for (com.google.gerrit.reviewdb.client.AccountExternalId e : db.accountExternalIds().suggestByEmailAddress(a, b, ((limit) - (matches.size())))) { if (addSuggestion(matches, e.getAccountId())) { queryEmail.put(e.getAccountId(), e.getEmailAddress()); } } } accountLoader.fill(); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.lang.String> p : queryEmail.entrySet()) { com.google.gerrit.extensions.common.AccountInfo info = matches.get(p.getKey()); if (info != null) { info.email = p.getValue(); } } java.util.List<com.google.gerrit.extensions.common.AccountInfo> m = new java.util.ArrayList(matches.values()); java.util.Collections.sort(m, AccountInfoComparator.ORDER_NULLS_LAST); return m; }
@java.lang.Override public com.google.gerrit.server.api.accounts.SuggestAccountsRequest suggestAccounts(java.lang.String query) throws com.google.gerrit.extensions.restapi.RestApiException { return suggestAccounts().withQuery(query); }
private java.util.List<com.google.gerrit.extensions.common.AccountInfo> suggestAccounts(com.google.gerrit.server.api.accounts.SuggestAccountsRequest r) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.account.QueryAccounts myQueryAccounts = queryAccountsProvider.get(); myQueryAccounts.setQuery(r.getQuery()); myQueryAccounts.setLimit(r.getLimit()); return myQueryAccounts.apply(TopLevelResource.INSTANCE); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot retrieve suggested accounts", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } com.google.gerrit.server.index.account.AccountIndex searchIndex = indexes.getSearchIndex(); if ((!(suggest)) && (searchIndex == null)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } if ((searchIndex == null) && ((start) != null)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("option start not allowed"); } if ((suggest) && ((!(suggestConfig)) || ((query.length()) < (suggestFrom)))) { return java.util.Collections.emptyList(); } java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> matches = (searchIndex != null) ? queryFromIndex() : queryFromDb(); return AccountInfoComparator.ORDER_NULLS_LAST.sortedCopy(matches); }
public java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> queryFromIndex() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (queryProcessor.isDisabled()) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("query disabled"); } if ((start) != null) { queryProcessor.setStart(start); } java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.extensions.common.AccountInfo> matches = new java.util.LinkedHashMap<>(); try { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.account.AccountState> queryPred; if (suggest) { queryPred = queryBuilder.defaultField(query); queryProcessor.setLimit(suggestLimit); } else { queryPred = queryBuilder.parse(query); } com.google.gerrit.server.query.QueryResult<com.google.gerrit.server.account.AccountState> result = queryProcessor.query(queryPred); for (com.google.gerrit.server.account.AccountState accountState : result.entities()) { com.google.gerrit.reviewdb.client.Account.Id id = accountState.getAccount().getId(); matches.put(id, accountLoader.get(id)); } } catch (com.google.gerrit.server.query.QueryParseException e) { if (suggest) { return com.google.common.collect.ImmutableSet.of(); } throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } accountLoader.fill(); return matches.values(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } if ((!(suggest)) || ((query.length()) < (suggestFrom))) { return java.util.Collections.emptyList(); } java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> matches = ((indexes.getSearchIndex()) != null) ? queryFromIndex() : queryFromDb(); return AccountInfoComparator.ORDER_NULLS_LAST.sortedCopy(matches); }
@java.lang.Override public com.google.gerrit.extensions.api.accounts.Accounts.SuggestAccountsRequest suggestAccounts() throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
@java.lang.Override public com.google.gerrit.extensions.api.accounts.Accounts.SuggestAccountsRequest suggestAccounts(java.lang.String query) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
com.google.gerrit.extensions.api.accounts.Accounts.SuggestAccountsRequest suggestAccounts() throws com.google.gerrit.extensions.restapi.RestApiException;
com.google.gerrit.extensions.api.accounts.Accounts.SuggestAccountsRequest suggestAccounts(java.lang.String query) throws com.google.gerrit.extensions.restapi.RestApiException;

private static com.google.gerrit.extensions.client.ChangeKind getChangeKindInternal(com.google.gerrit.server.change.ChangeKindCache cache, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patch, com.google.gerrit.server.query.change.ChangeData.Factory changeDataFactory, com.google.gerrit.server.project.ProjectCache projectCache, com.google.gerrit.server.git.GitRepositoryManager repoManager) { com.google.gerrit.extensions.client.ChangeKind kind = com.google.gerrit.extensions.client.ChangeKind.REWORK; if ((patch.getId().get()) > 1) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(change.getProject())) { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(change.getProject()); com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db, change); java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> patchSetCollection = cd.patchSets(); com.google.gerrit.reviewdb.client.PatchSet priorPs = patch; for (com.google.gerrit.reviewdb.client.PatchSet ps : patchSetCollection) { if (((ps.getId().get()) < (patch.getId().get())) && (((ps.getId().get()) > (priorPs.getId().get())) || (priorPs == patch))) { priorPs = ps; } } if (priorPs != patch) { kind = cache.getChangeKind(projectState, repo, org.eclipse.jgit.lib.ObjectId.fromString(priorPs.getRevision().get()), org.eclipse.jgit.lib.ObjectId.fromString(patch.getRevision().get())); } } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.ChangeKindCacheImpl.log.warn(((("Unable to get change kind for patchSet " + (patch.getPatchSetId())) + "of change ") + (change.getChangeId())), e); } } return kind; }

public void remove(com.google.gerrit.common.data.AccessSection section) { if (section != null) { com.google.gerrit.common.data.AccessSection a = accessSections.get(section.getName()); if (sectionsWithUnknownPermissions.contains(a)) { accessSections.remove(a); } else { a.setPermissions(new java.util.ArrayList<com.google.gerrit.common.data.Permission>()); } } }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } if ((suggest) && ((!(suggestConfig)) || ((query.length()) < (suggestFrom)))) { return java.util.Collections.emptyList(); } accountLoader = accountLoaderFactory.create(((suggest) || (options.contains(ListAccountsOption.DETAILS)))); com.google.gerrit.server.index.account.AccountIndex searchIndex = indexes.getSearchIndex(); if (searchIndex != null) { return queryFromIndex(); } if (!(suggest)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } if ((start) != null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("option start not allowed"); } return queryFromDb(); }

@org.junit.Test public void bySelf() throws java.lang.Exception { assertQuery("self", currentUserInfo); }

@org.junit.Test public void byId() throws java.lang.Exception { com.google.gerrit.extensions.common.AccountInfo user = newAccount("user"); assertQuery("9999999"); assertQuery(currentUserInfo._accountId, currentUserInfo); assertQuery(user._accountId, user); }
private void call(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw) throws java.lang.Exception { try { com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx; com.google.gerrit.server.notedb.NoteDbUpdateManager updateManager = null; db.changes().beginTransaction(id); try { ctx = newChangeContext(db, repo, rw, id); for (com.google.gerrit.server.git.BatchUpdate.Op op : changeOps) { dirty |= op.updateChange(ctx); } if (!(dirty)) { return; } deleted = ctx.deleted; if (notesMigration.commitChangeWrites()) { updateManager = stageNoteDbUpdate(ctx, deleted); } java.lang.Iterable<com.google.gerrit.reviewdb.client.Change> cs = com.google.gerrit.server.git.BatchUpdate.changesToUpdate(ctx); if (newChanges.containsKey(id)) { db.changes().insert(cs); } else if (deleted) { db.changes().delete(cs); } else { db.changes().update(cs); } db.commit(); } finally { db.rollback(); } if (notesMigration.commitChangeWrites()) { try { noteDbResult = updateManager.stage().get(id); } catch (java.io.IOException ex) { com.google.gerrit.server.git.BatchUpdate.log.debug("Ignoring NoteDb update error after ReviewDb write", ex); } } } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.git.UpdateException(e); } }
public final com.google.gerrit.server.mail.ProjectWatch.Watchers getWatchers(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.mail.ProjectWatch.Watchers matching = new com.google.gerrit.server.mail.ProjectWatch.Watchers(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> projectWatchers = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) { if (add(matching, w, type)) { projectWatchers.add(w.getAccountId()); } } for (com.google.gerrit.reviewdb.client.AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) { if (!(projectWatchers.contains(w.getAccountId()))) { add(matching, w, type); } } for (com.google.gerrit.server.project.ProjectState state : projectState.tree()) { for (com.google.gerrit.server.git.NotifyConfig nc : state.getConfig().getNotifyConfigs()) { if (nc.isNotify(type)) { try { add(matching, nc); } catch (com.google.gerrit.server.query.QueryParseException e) { com.google.gerrit.server.mail.ProjectWatch.log.warn("Project {} has invalid notify {} filter \"{}\": {}", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()); } } } } return matching; }


public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules, com.google.gerrit.extensions.api.changes.SubmitInput submitInput) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { this.submitInput = submitInput; this.caller = caller; updateSubmissionId(change); this.db = db; orm.setContext(db, ts, caller, submissionId); logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller); checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs); this.commits = new com.google.gerrit.server.git.MergeOp.CommitStatus(cs); com.google.gerrit.server.git.MergeSuperSet.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); failFast(cs); } else { logDebug("Bypassing submit rules"); bypassSubmitRules(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Error from integrateIntoHistory", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private void checkSubmitRulesAndState(com.google.gerrit.server.git.ChangeSet cs) { for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { try { if ((cd.change().getStatus()) != (Change.Status.NEW)) { commits.problem(cd.getId(), ((("Change " + (cd.getId())) + " is ") + (cd.change().getStatus().toString().toLowerCase()))); } else { com.google.gerrit.server.git.MergeOp.checkSubmitRule(cd); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { commits.problem(cd.getId(), e.getMessage()); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = "Error checking submit rules for change"; com.google.gerrit.server.git.MergeOp.log.warn(((msg + " ") + (cd.getId())), e); commits.problem(cd.getId(), msg); } } }
public java.lang.String getData(final java.lang.String url) throws java.io.IOException { org.apache.http.impl.client.CloseableHttpClient client = org.apache.http.impl.client.HttpClients.createDefault(); java.lang.String responseJson = null; try { org.apache.http.client.methods.HttpGet httpget = new org.apache.http.client.methods.HttpGet(url); com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.debug(("Making request for " + (httpget.getRequestLine()))); org.apache.http.client.methods.CloseableHttpResponse response = client.execute(httpget); try { org.apache.http.StatusLine sl = response.getStatusLine(); int responseCode = sl.getStatusCode(); if (responseCode == (java.net.HttpURLConnection.HTTP_OK)) { com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.debug(("Retreiving data from response " + (httpget.getRequestLine()))); java.io.InputStream inputStream = response.getEntity().getContent(); java.io.Reader reader = new java.io.InputStreamReader(inputStream); int contentLength = ((int) (response.getEntity().getContentLength())); char[] charArray = new char[contentLength]; reader.read(charArray); responseJson = new java.lang.String(charArray); com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.debug(("Data retreived: " + responseJson)); } else { com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.error(((("Failed request: " + (httpget.getRequestLine())) + " with response: ") + responseCode)); } } finally { response.close(); } } finally { client.close(); } return responseJson; }
@java.lang.Override public void performAction(final java.lang.String issueId, final java.lang.String actionString) { }
@java.lang.Override public java.lang.String getUrl() { java.lang.String database = cfg.getString("database", null, "database"); if ((database == null) || (database.isEmpty())) { database = "db/ReviewDB"; } return "jdbc:h2:" + (site.resolve(database).toUri().toString()); }
@org.junit.Test public void canReadCommitWhenAllRefsVisible() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/*"); org.eclipse.jgit.lib.ObjectId id = repo.branch("master").commit().create(); com.google.gerrit.server.project.ProjectControl pc = newProjectControl(); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id))); }
@org.junit.Test public void canReadCommitIfRefVisible() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/heads/branch1"); com.google.gerrit.server.project.Util.deny(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/heads/branch2"); org.eclipse.jgit.lib.ObjectId id1 = repo.branch("branch1").commit().create(); org.eclipse.jgit.lib.ObjectId id2 = repo.branch("branch2").commit().create(); com.google.gerrit.server.project.ProjectControl pc = newProjectControl(); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1))); assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id2))); }
@org.junit.Test public void cannotReadAfterRollbackWithRestrictedRead() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/heads/branch1"); org.eclipse.jgit.revwalk.RevCommit parent1 = repo.commit().create(); org.eclipse.jgit.lib.ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create(); com.google.gerrit.server.project.ProjectControl pc = newProjectControl(); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1))); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1))); repo.branch("branch1").update(parent1); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1))); assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1))); }
@org.junit.Test public void canReadCommitIfReachableFromVisibleRef() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/heads/branch1"); com.google.gerrit.server.project.Util.deny(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/heads/branch2"); org.eclipse.jgit.revwalk.RevCommit parent1 = repo.commit().create(); repo.branch("branch1").commit().parent(parent1).create(); org.eclipse.jgit.revwalk.RevCommit parent2 = repo.commit().create(); repo.branch("branch2").commit().parent(parent2).create(); com.google.gerrit.server.project.ProjectControl pc = newProjectControl(); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1))); assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(parent2))); }
@org.junit.Test public void canReadAfterRollbackWithAllRefsVisible() throws java.lang.Exception { com.google.gerrit.server.project.Util.allow(project, com.google.gerrit.server.project.READ, com.google.gerrit.server.project.REGISTERED_USERS, "refs/*"); org.eclipse.jgit.revwalk.RevCommit parent1 = repo.commit().create(); org.eclipse.jgit.lib.ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create(); com.google.gerrit.server.project.ProjectControl pc = newProjectControl(); org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk(); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1))); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1))); repo.branch("branch1").update(parent1); assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1))); assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1))); }
private void install(com.google.gerrit.server.plugins.Plugin plugin) { if (!(plugin.getName().equals(pluginName))) { return; } filter = load(plugin); plugin.add(new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { filter = null; } }); }
private com.google.inject.servlet.GuiceFilter load(com.google.gerrit.server.plugins.Plugin plugin) { if ((plugin.getHttpInjector()) != null) { final java.lang.String name = plugin.getName(); final com.google.inject.servlet.GuiceFilter guiceFilter; try { guiceFilter = plugin.getHttpInjector().getInstance(com.google.inject.servlet.GuiceFilter.class); } catch (java.lang.RuntimeException e) { com.google.gerrit.httpd.plugins.LfsPluginServlet.log.warn(java.lang.String.format("Plugin %s cannot load GuiceFilter", name), e); return null; } try { javax.servlet.ServletContext ctx = com.google.gerrit.httpd.plugins.PluginServletContext.create(plugin, "/"); guiceFilter.init(new com.google.gerrit.httpd.plugins.WrappedFilterConfig(ctx)); } catch (javax.servlet.ServletException e) { com.google.gerrit.httpd.plugins.LfsPluginServlet.log.warn(java.lang.String.format("Plugin %s failed to initialize HTTP", name), e); return null; } plugin.add(new com.google.gerrit.extensions.registration.RegistrationHandle() { @java.lang.Override public void remove() { guiceFilter.destroy(); } }); return guiceFilter; } return null; }
@java.lang.Override public void remove() { guiceFilter.destroy(); }

public void fire(com.google.gerrit.extensions.common.ChangeInfo change, com.google.gerrit.extensions.common.RevisionInfo revision, com.google.gerrit.extensions.common.AccountInfo reviewer, java.lang.String message, java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ApprovalInfo> newApprovals, java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ApprovalInfo> oldApprovals) { if (!(listeners.iterator().hasNext())) { return; } com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(change, revision, reviewer, message, newApprovals, oldApprovals); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.warn("Error in event listener", e); } } }


@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { emailReviewers(rsrc.getChange(), added); if (!(added.isEmpty())) { for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(psa.getAccountId()).getAccount(); reviewerAdded.fire(rsrc.getChange(), patchSet, account); } } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account account) { if (!(listeners.iterator().hasNext())) { return; } try { fire(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(account)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.extensions.common.ChangeInfo change, com.google.gerrit.extensions.common.RevisionInfo revision, com.google.gerrit.extensions.common.AccountInfo reviewer) { if (!(listeners.iterator().hasNext())) { return; } com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(change, revision, reviewer); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewerAdded(event); } catch (java.lang.Exception e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.warn("Error in event listener, e"); } } }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { if ((args.projectCache) != null) { projectState = args.projectCache.get(change.getProject()); } else { projectState = null; } if ((patchSet) == null) { try { patchSet = changeData.currentPatchSet(); } catch (com.google.gwtorm.server.OrmException err) { patchSet = null; } } if (((patchSet) != null) && ((patchSetInfo) == null)) { try { patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId()); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException | com.google.gwtorm.server.OrmException err) { patchSetInfo = null; } } authors = getAuthors(); super.init(); if (((changeMessage) != null) && ((changeMessage.getWrittenOn()) != null)) { setHeader("Date", new java.util.Date(changeMessage.getWrittenOn().getTime())); } setChangeSubjectHeader(); setHeader("X-Gerrit-Change-Id", ("" + (change.getKey().get()))); setChangeUrlHeader(); setCommitIdHeader(); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp ts) { if (!(listeners.iterator().hasNext())) { return; } try { fire(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), message, util.approvals(reviewer, newApprovals, ts), util.approvals(reviewer, oldApprovals, ts)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error("Couldn't fire event", e); } }
public void setChangeMessage(final com.google.gerrit.reviewdb.client.ChangeMessage cm) { changeMessage = cm; }

@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); if ((notify.compareTo(NotifyHandling.OWNER_REVIEWERS)) >= 0) { ccAllApprovals(); } if ((notify.compareTo(NotifyHandling.ALL)) >= 0) { bccStarredBy(); includeWatchers(NotifyType.ALL_COMMENTS); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { if (input == null) { input = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); } if (((input.label) != null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("label must match URL"); } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input)); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public void send() throws com.google.gerrit.common.errors.EmailException { if (NotifyHandling.NONE.equals(notify)) { return; } if (!(args.emailSender.isEnabled())) { return; } init(); format(); appendText(velocifyFile("Footer.vm")); if (shouldSendMessage()) { if ((fromId) != null) { final com.google.gerrit.reviewdb.client.Account fromUser = args.accountCache.get(fromId).getAccount(); com.google.gerrit.extensions.client.GeneralPreferencesInfo senderPrefs = fromUser.getGeneralPreferencesInfo(); if ((senderPrefs != null) && ((senderPrefs.getEmailStrategy()) == (CC_ON_OWN_COMMENTS))) { add(RecipientType.CC, fromId); } else if (rcptTo.remove(fromId)) { removeUser(fromUser); } for (com.google.gerrit.reviewdb.client.Account.Id id : rcptTo) { com.google.gerrit.reviewdb.client.Account thisUser = args.accountCache.get(id).getAccount(); com.google.gerrit.extensions.client.GeneralPreferencesInfo prefs = thisUser.getGeneralPreferencesInfo(); if ((prefs == null) || ((prefs.getEmailStrategy()) == (DISABLED))) { removeUser(thisUser); } if (smtpRcptTo.isEmpty()) { return; } } } com.google.gerrit.server.validators.OutgoingEmailValidationListener.Args va = new com.google.gerrit.server.validators.OutgoingEmailValidationListener.Args(); va.messageClass = messageClass; va.smtpFromAddress = smtpFromAddress; va.smtpRcptTo = smtpRcptTo; va.headers = headers; va.body = body.toString(); for (com.google.gerrit.server.validators.OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) { try { validator.validateOutgoingEmail(va); } catch (com.google.gerrit.server.validators.ValidationException e) { return; } } args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body); } }
protected void ccAllApprovals() { if ((!(NotifyHandling.ALL.equals(notify))) && (!(NotifyHandling.OWNER_REVIEWERS.equals(notify)))) { return; } try { for (com.google.gerrit.reviewdb.client.Account.Id id : changeData.reviewers().all()) { add(RecipientType.CC, id); } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot CC users that reviewed updated change", err); } }
public com.google.gerrit.server.change.PostReview.Output apply(com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input, java.sql.Timestamp ts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { ts = com.google.common.collect.Ordering.natural().max(ts, revision.getChange().getCreatedOn()); if (revision.getEdit().isPresent()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot post review on edit"); } if ((input.onBehalfOf) != null) { revision = onBehalfOf(revision, input); } if ((input.labels) != null) { checkLabels(revision, input.strictLabels, input.labels); } if ((input.comments) != null) { checkComments(revision, input.comments); } if ((input.notify) == null) { com.google.gerrit.server.change.PostReview.log.warn("notify = null; assuming notify = NONE"); input.notify = com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.NONE; } try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) { bu.addOp(revision.getChange().getId(), new com.google.gerrit.server.change.PostReview.Op(revision.getPatchSet().getId(), input)); bu.execute(); } com.google.gerrit.server.change.PostReview.Output output = new com.google.gerrit.server.change.PostReview.Output(); output.labels = input.labels; return output; }
@org.junit.Test public void testPushForMasterWithNotify() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount user2 = accounts.user2(); java.lang.String pushSpec = ((("refs/for/master" + "%reviewer=") + (user.email)) + ",cc=") + (user2.email); sender.clear(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo(((pushSpec + ",notify=") + (com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.NONE))); r.assertOkStatus(); assertThat(sender.getMessages()).hasSize(0); sender.clear(); r = pushTo(((pushSpec + ",notify=") + (com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.OWNER))); r.assertOkStatus(); assertThat(sender.getMessages()).hasSize(0); sender.clear(); r = pushTo(((pushSpec + ",notify=") + (com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.OWNER_REVIEWERS))); r.assertOkStatus(); assertThat(sender.getMessages()).hasSize(1); com.google.gerrit.testutil.FakeEmailSender.Message m = sender.getMessages().get(0); assertThat(m.rcpt()).containsExactly(user.emailAddress); sender.clear(); r = pushTo(((pushSpec + ",notify=") + (com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.ALL))); r.assertOkStatus(); assertThat(sender.getMessages()).hasSize(1); m = sender.getMessages().get(0); assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress); }
public void setNotify(com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling notify) { this.notify = notify; }
com.google.gerrit.server.change.EmailReviewComments create(com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling notify, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.ChangeMessage message, java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments);
protected void bccStarredBy() { if (!(NotifyHandling.ALL.equals(notify))) { return; } try { com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Account.Id, java.lang.String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId()); for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.util.Collection<java.lang.String>> e : stars.asMap().entrySet()) { if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) { super.add(RecipientType.BCC, e.getKey()); } if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) { com.google.gerrit.server.account.AccountState accountState = args.accountCache.get(e.getKey()); if (accountState != null) { removeUser(accountState.getAccount()); } } } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchChangeException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot BCC users that starred updated change", err); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((message) == null) { return; } if ((in.notify.compareTo(NotifyHandling.NONE)) > 0) { email.create(in.notify, notes, ps, user, message, comments).sendAsync(); } commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen()); }
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create(com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.git.MergeOp.CommitStatus commits, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.IdentifiedUser caller, com.google.gerrit.server.git.MergeTip mergeTip, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevFlag canMergeFlag, com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted, java.lang.String submissionId, com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling notifyHandling);
public com.google.gerrit.server.change.ChangeInserter setNotify(com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling notify) { this.notify = notify; return this; }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } com.google.gerrit.server.IdentifiedUser user = ctx.getUser().asIdentifiedUser(); if ((input.notify.compareTo(NotifyHandling.NONE)) > 0) { try { com.google.gerrit.server.mail.ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId()); cm.setFrom(user.getAccountId()); cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen()); cm.setNotify(input.notify); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.DeleteVote.log.error(("Cannot email update for change " + (change.getId())), e); } } commentAdded.fire(change, ps, user.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getWhen()); }
protected void ccExistingReviewers() { if ((!(NotifyHandling.ALL.equals(notify))) && (!(NotifyHandling.OWNER_REVIEWERS.equals(notify)))) { return; } try { for (com.google.gerrit.reviewdb.client.Account.Id id : changeData.reviewers().byState(com.google.gerrit.server.mail.REVIEWER)) { add(RecipientType.CC, id); } } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.ChangeEmail.log.warn("Cannot CC users that commented on updated change", err); } }
com.google.gerrit.server.git.EmailMerge create(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.reviewdb.client.Account.Id submitter, com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling notifyHandling);
@java.lang.Override protected final com.google.gerrit.server.mail.ProjectWatch.Watchers getWatchers(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { if (!(NotifyHandling.ALL.equals(notify))) { return new com.google.gerrit.server.mail.ProjectWatch.Watchers(); } com.google.gerrit.server.mail.ProjectWatch watch = new com.google.gerrit.server.mail.ProjectWatch(args, branch.getParentKey(), projectState, changeData); return watch.getWatchers(type); }
@org.junit.Test public void deleteVoteNotifyNone() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); setApiUser(user); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); setApiUser(admin); sender.clear(); com.google.gerrit.extensions.api.changes.DeleteVoteInput in = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); in.label = "Code-Review"; in.notify = com.google.gerrit.extensions.api.changes.ReviewInput.NotifyHandling.NONE; gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in); assertThat(sender.getMessages()).hasSize(0); }
@java.lang.Override public void addReviewer(java.lang.String in) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
void addReviewer(com.google.gerrit.extensions.api.changes.AddReviewerInput in) throws com.google.gerrit.extensions.restapi.RestApiException;
@java.lang.Override public void addReviewer(com.google.gerrit.extensions.api.changes.AddReviewerInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { postReviewers.apply(change, in); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.git.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add change reviewer", e); } }
@java.lang.Override public void addReviewer(com.google.gerrit.extensions.api.changes.AddReviewerInput in) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
void addReviewer(java.lang.String in) throws com.google.gerrit.extensions.restapi.RestApiException;
@java.lang.Override public void addReviewer(java.lang.String reviewer) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = reviewer; addReviewer(in); }

public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo); accountLoader.fill(); return rev; } }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey()); com.google.gerrit.server.project.ChangeControl ctl = cd.changeControl(); return changeJson.getRevisionInfo(ctl, ps); }
@java.lang.Override public void storeEvent(com.google.gerrit.server.events.ProjectEvent event) { com.google.gerrit.reviewdb.client.Project.NameKey projectName = event.getProjectNameKey(); if (projectName == null) { return; } int failedConnections = 0; boolean done = false; while (!done) { done = true; try { getEventsDb().storeEvent(event); } catch (java.sql.SQLException e) { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.warn(("Cannot store ChangeEvent for: " + (projectName.get())), e); if (((e.getCause()) instanceof java.net.ConnectException) || (e.getMessage().contains("terminating connection"))) { done = false; retryIfAllowed(failedConnections); failedConnections++; } } } }
private void assertVotes(ChangeInfo c, com.google.gerrit.acceptance.TestAccount user, java.lang.String label, int expectedVote, com.google.gerrit.extensions.client.ChangeKind changeKind) { java.lang.Integer vote = null; for (com.google.gerrit.extensions.common.ApprovalInfo approval : c.labels.get(label).all) { if ((approval._accountId) == (user.id.get())) { vote = approval.value; break; } } assertThat(vote).named(((("label = " + label) + "; changeKind = ") + (changeKind.name()))).isEqualTo(expectedVote); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { changeRestored.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), com.google.common.base.Strings.emptyToNull(input.message), ctx.getWhen()); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } voteDeleted.fire(change, ps, newApprovals, oldApprovals, input.notify, changeMessage.getMessage(), ctx.getUser().asIdentifiedUser().getAccount(), ctx.getWhen()); }
@org.junit.Test public void addReviewerToIgnoredChange() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); setApiUser(user); gApi.accounts().self().setStars(r.getChangeId(), new com.google.gerrit.extensions.api.changes.StarsInput(com.google.common.collect.ImmutableSet.of(com.google.gerrit.acceptance.api.accounts.IGNORE_LABEL))); sender.clear(); setApiUser(admin); com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = user.email; gApi.changes().id(r.getChangeId()).addReviewer(in); java.util.List<com.google.gerrit.testutil.FakeEmailSender.Message> messages = sender.getMessages(); assertThat(messages).hasSize(1); assertThat(messages.get(0).rcpt()).containsExactly(user.emailAddress); }
public static com.google.gerrit.server.notedb.AbstractChangeNotes.LoadHandle create(com.google.gerrit.server.notedb.ChangeNotesCommit.ChangeNotesRevWalk walk, org.eclipse.jgit.lib.ObjectId id) { return new com.google.gerrit.server.notedb.AutoValue_AbstractChangeNotes_LoadHandle(checkNotNull(walk), (id != null ? id.copy() : null)); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } com.google.gerrit.server.IdentifiedUser user = ctx.getUser().asIdentifiedUser(); if ((input.notify.compareTo(NotifyHandling.NONE)) > 0) { try { com.google.gerrit.server.mail.ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId()); cm.setFrom(user.getAccountId()); cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen()); cm.setNotify(input.notify); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.DeleteVote.log.error(("Cannot email update for change " + (change.getId())), e); } } commentAdded.fire(change, ps, user.getAccount(), changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getWhen()); }



@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { maxCommandWidth = (wide) ? java.lang.Integer.MAX_VALUE : (((((columns) - 8) - 12) - 12) - 4) - 4; stdout.print(java.lang.String.format("%-8s %-12s %-12s %-4s %s\n", "Task", "State", "StartTime", "", "Command")); stdout.print(("----------------------------------------------" + "--------------------------------\n")); try { java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo> tasks = listTasks.apply(new com.google.gerrit.server.config.ConfigResource()); long now = com.google.gerrit.common.TimeUtil.nowMs(); boolean viewAll = currentUser.getCapabilities().canViewQueue(); for (com.google.gerrit.server.config.ListTasks.TaskInfo task : tasks) { java.lang.String start; switch (task.state) { case DONE : case CANCELLED : case RUNNING : case READY : start = com.google.gerrit.sshd.commands.ShowQueue.format(task.state); break; case OTHER : case SLEEPING : default : start = com.google.gerrit.sshd.commands.ShowQueue.time(now, task.delay); break; } if (viewAll || ((task.projectName) == null)) { java.lang.String command = ((task.command.length()) < (maxCommandWidth)) ? task.command : task.command.substring(0, maxCommandWidth); stdout.print(java.lang.String.format("%8s %-12s %-12s %-4s %s\n", task.id, start, com.google.gerrit.sshd.commands.ShowQueue.startTime(task.startTime), "", command)); } else { java.lang.String remoteName = ((task.remoteName) != null) ? ((task.remoteName) + "/") + (task.projectName) : task.projectName; stdout.print(java.lang.String.format("%8s %-12s %-4s %s\n", task.id, start, com.google.gerrit.sshd.commands.ShowQueue.startTime(task.startTime), com.google.common.base.MoreObjects.firstNonNull(remoteName, "n/a"))); } } stdout.print(("----------------------------------------------" + "--------------------------------\n")); stdout.print(((" " + (tasks.size())) + " tasks\n")); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw die(e); } }


@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException, javax.servlet.ServletException { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); try { com.ericsson.gerrit.plugins.syncevents.Context.setForwardedEvent(); com.google.gerrit.server.events.Event event = getEventFromRequest(req); dispatcher.postEvent(event); rsp.setStatus(com.ericsson.gerrit.plugins.syncevents.SC_NO_CONTENT); } catch (com.google.gwtorm.server.OrmException e) { com.ericsson.gerrit.plugins.syncevents.SyncEventsRestApiServlet.logger.debug("Error trying to find a change ", e); com.ericsson.gerrit.plugins.syncevents.SyncEventsRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.syncevents.SC_NOT_FOUND, "Change not found\n"); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.syncevents.SyncEventsRestApiServlet.logger.error("Unable to re-trigger event", e); com.ericsson.gerrit.plugins.syncevents.SyncEventsRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.syncevents.SC_BAD_REQUEST, e.getMessage()); } finally { com.ericsson.gerrit.plugins.syncevents.Context.unsetForwardedEvent(); } }


private com.google.gerrit.extensions.api.changes.AddReviewerResult putAccount(java.lang.String reviewer, com.google.gerrit.server.change.ReviewerResource rsrc, boolean cc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser().getAccount(); com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl(); com.google.gerrit.extensions.api.changes.AddReviewerResult result = new com.google.gerrit.extensions.api.changes.AddReviewerResult(reviewer); if (isValidReviewer(member, control)) { addReviewers(rsrc.getChangeResource(), result, com.google.common.collect.ImmutableMap.of(member.getId(), control), cc); } return result; }




@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { emailReviewers(rsrc.getChange(), added); if (!(added.isEmpty())) { for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(psa.getAccountId()).getAccount(); reviewerAdded.fire(rsrc.getChange(), patchSet, account); } } }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet()); if (added.isEmpty()) { return false; } patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); return true; }




@java.lang.Override public com.google.gerrit.extensions.api.changes.AddReviewerResult apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((input.reviewer) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing reviewer field"); } try { com.google.gerrit.reviewdb.client.Account.Id accountId = accounts.parse(input.reviewer).getAccountId(); return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.cc()); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { try { return putGroup(rsrc, input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e2) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFound, input.reviewer)); } } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.AddReviewerResult apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((input.reviewer) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing reviewer field"); } try { com.google.gerrit.reviewdb.client.Account.Id accountId = accounts.parse(input.reviewer).getAccountId(); return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId)); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { try { return putGroup(rsrc, input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e2) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFound, input.reviewer)); } } }

private com.google.gerrit.extensions.api.changes.AddReviewerResult putAccount(java.lang.String reviewer, com.google.gerrit.server.change.ReviewerResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser().getAccount(); com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl(); com.google.gerrit.extensions.api.changes.AddReviewerResult result = new com.google.gerrit.extensions.api.changes.AddReviewerResult(reviewer); if (isValidReviewer(member, control)) { addReviewers(rsrc.getChangeResource(), result, com.google.common.collect.ImmutableMap.of(member.getId(), control)); } return result; }


protected void updateSuperProjects(java.util.Collection<com.google.gerrit.reviewdb.client.Branch.NameKey> updatedBranches) throws com.google.gerrit.server.git.SubmoduleException { if (!(enableSuperProjectSubscriptions)) { logDebug("Updating superprojects disabled"); return; } logDebug("Updating superprojects"); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Branch.NameKey, com.google.gerrit.reviewdb.client.SubmoduleSubscription> targets = com.google.common.collect.HashMultimap.create(); for (com.google.gerrit.reviewdb.client.Branch.NameKey updatedBranch : updatedBranches) { logDebug(("Now processing " + updatedBranch)); java.util.Set<com.google.gerrit.reviewdb.client.Branch.NameKey> checkedTargets = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.reviewdb.client.Branch.NameKey> targetsToProcess = new java.util.HashSet<>(); targetsToProcess.add(updatedBranch); while (!(targetsToProcess.isEmpty())) { java.util.Set<com.google.gerrit.reviewdb.client.Branch.NameKey> newTargets = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Branch.NameKey b : targetsToProcess) { try { java.util.Collection<com.google.gerrit.reviewdb.client.SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b); for (com.google.gerrit.reviewdb.client.SubmoduleSubscription sub : subs) { com.google.gerrit.reviewdb.client.Branch.NameKey dst = sub.getSuperProject(); targets.put(dst, sub); newTargets.add(dst); } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException(("Cannot find superprojects for " + b), e); } } logDebug(("adding to done " + targetsToProcess)); checkedTargets.addAll(targetsToProcess); logDebug(("completely done with " + checkedTargets)); java.util.Set<com.google.gerrit.reviewdb.client.Branch.NameKey> intersection = new java.util.HashSet(checkedTargets); intersection.retainAll(newTargets); if (!(intersection.isEmpty())) { throw new com.google.gerrit.server.git.SubmoduleException(("Possible circular subscription involving " + updatedBranch)); } targetsToProcess = newTargets; } } for (com.google.gerrit.reviewdb.client.Branch.NameKey dst : targets.keySet()) { try { updateGitlinks(dst, targets.get(dst)); } catch (com.google.gerrit.server.git.SubmoduleException e) { throw new com.google.gerrit.server.git.SubmoduleException(("Cannot update gitlinks for " + dst), e); } } }
@java.lang.Override protected void configureServlets() { com.googlesource.gerrit.plugins.lfs.LfsBackend backend = config.getEnum("backend", LfsBackend.FS); switch (backend) { case FS : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository.class); serve("/*").with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsContentServlet.class); break; case S3 : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.s3.LfsS3ApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.s3.S3LargeFileRepository.class); break; default : throw new java.lang.RuntimeException(("Unsupported backend: " + backend)); } }
private static org.eclipse.jgit.lfs.server.s3.S3Config getS3Config(com.google.gerrit.server.config.PluginConfigFactory configFactory, java.lang.String pluginName) { com.google.gerrit.server.config.PluginConfig cfg = configFactory.getFromGerritConfig(pluginName); java.lang.String region = cfg.getString("region", null); java.lang.String bucket = cfg.getString("bucket", null); java.lang.String storageClass = cfg.getString("storageClass", "REDUCED_REDUNDANCY"); java.lang.String accessKey = cfg.getString("accessKey", null); java.lang.String secretKey = cfg.getString("secretKey", null); int expirationSeconds = cfg.getInt("expirationSeconds", 60); boolean disableSslVerify = cfg.getBoolean("disableSslVerify", false); return new org.eclipse.jgit.lfs.server.s3.S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify); }
@java.lang.Override protected void configureServlets() { com.googlesource.gerrit.plugins.lfs.LfsBackend backend = config.getEnum("backend", LfsBackend.FS); switch (backend) { case FS : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository.class); serve((("/" + (CONTENT_PATH)) + "/*")).with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsContentServlet.class); break; case S3 : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.s3.LfsS3ApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.s3.S3LargeFileRepository.class); break; default : throw new java.lang.RuntimeException(("Unsupported backend: " + backend)); } }
private static java.nio.file.Path getOrCreateDataDir(com.google.gerrit.server.config.PluginConfigFactory cfgFactory, java.lang.String pluginName, java.nio.file.Path defaultDataDir) throws java.io.IOException { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromGerritConfig(pluginName); java.lang.String dataDir = cfg.getString("directory", null); if (com.google.common.base.Strings.isNullOrEmpty(dataDir)) { return defaultDataDir; } java.nio.file.Path ensured = java.nio.file.Files.createDirectories(java.nio.file.Paths.get(dataDir)); if (!(java.nio.file.Files.isReadable(ensured))) { throw new java.io.IOException((("Path '" + (ensured.toAbsolutePath())) + "' cannot be accessed")); } return ensured; }
@java.lang.Override public com.google.common.base.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { final com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME, username); final com.google.gerrit.reviewdb.client.AccountExternalId id = db.accountExternalIds().get(key); if (id != null) { return com.google.common.base.Optional.of(id.getAccountId()); } return com.google.common.base.Optional.absent(); } }





private static com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = java.util.Collections.emptySet(); java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch> projectWatches = java.util.Collections.emptySet(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> anon = com.google.common.collect.ImmutableSet.of(); return new com.google.gerrit.server.account.AccountState(account, anon, ids, projectWatches); }
private boolean add(com.google.gerrit.server.mail.ProjectWatch.Watchers matching, com.google.gerrit.reviewdb.client.AccountProjectWatch w, com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = args.identifiedUserFactory.create(w.getAccountId()); try { if (filterMatch(user, w.getFilter())) { if (w.isNotify(type)) { matching.bcc.accounts.add(w.getAccountId()); } return true; } } catch (com.google.gerrit.server.query.QueryParseException e) { } return false; }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.client.AccountExternalId>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.client.AccountProjectWatch>emptySet()); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>of(), com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountExternalId>of(), com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountProjectWatch>of()); }





@org.junit.Test public void deleteNonExistingProject() throws java.lang.Exception { java.lang.String projectName = project.get(); setApiUser(admin); java.util.List<com.google.gerrit.extensions.client.ProjectWatchInfo> projectsToWatch = new java.util.LinkedList<>(); com.google.gerrit.extensions.client.ProjectWatchInfo pwi = new com.google.gerrit.extensions.client.ProjectWatchInfo(); pwi.project = projectName; pwi.notifyAbandonedChanges = true; pwi.notifyNewChanges = true; pwi.notifyAllComments = true; projectsToWatch.add(pwi); gApi.accounts().self().setWatchedProjects(projectsToWatch); java.util.List<com.google.gerrit.extensions.client.ProjectWatchInfo> d = com.google.common.collect.Lists.newArrayList(pwi); gApi.accounts().self().deleteWatchedProjects(d); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); gApi.accounts().self().deleteWatchedProjects(d); }
public java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch> getProjectWatches() { return projectWatches; }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { args.mergeTip.moveTipTo(toMerge, toMerge); }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { org.eclipse.jgit.lib.PersonIdent caller = ctx.getUser().asIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()); if ((args.mergeTip.getCurrentTip()) == null) { throw new java.lang.IllegalStateException(((("cannot merge commit " + (toMerge.name())) + " onto a null tip; expected at least one fast-forward prior to") + " this operation")); } com.google.gerrit.server.git.CodeReviewCommit merged = args.mergeUtil.mergeOneCommit(caller, args.serverIdent, ctx.getRepository(), args.rw, ctx.getInserter(), args.destBranch, args.mergeTip.getCurrentTip(), toMerge); args.mergeTip.moveTipTo(merged, toMerge); }

public void updateSuperProjects() throws com.google.gerrit.server.git.SubmoduleException { com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Branch.NameKey> dst = branchesByProject(); java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> projects = dst.keySet(); try { for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { orm.openRepo(project, false); orm.getRepo(project).resetUpdate(); for (com.google.gerrit.reviewdb.client.Branch.NameKey branch : dst.get(project)) { com.google.gerrit.server.git.SubmoduleOp.RepoOnlyOp op = new com.google.gerrit.server.git.SubmoduleOp.RepoOnlyOp(this, branch); orm.getRepo(project).getUpdate().addRepoOnlyOp(op); } } com.google.gerrit.server.git.BatchUpdate.execute(orm.batchUpdates(projects), new com.google.gerrit.server.git.BatchUpdate.Listener()); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.git.UpdateException | java.io.IOException | com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.server.git.SubmoduleException("Cannot update gitlinks", e); } }
@java.lang.Override public RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); next = start; } else { oldId = ref.getObjectId(); next = parse(oldId); } return store(oldId, ((next) + (batchSize))); }

private void display(java.util.Map<java.lang.String, com.googlesource.gerrit.plugins.verifystatus.client.VerificationInfo> jobs) { int row = 0; int column = 1; com.google.gwt.user.client.ui.Grid grid = new com.google.gwt.user.client.ui.Grid(row, column); for (java.util.Map.Entry<java.lang.String, com.googlesource.gerrit.plugins.verifystatus.client.VerificationInfo> job : jobs.entrySet()) { grid.insertRow(row); com.google.gwt.user.client.ui.HorizontalPanel p = new com.google.gwt.user.client.ui.HorizontalPanel(); short vote = job.getValue().value(); if (vote > 0) { p.add(new com.google.gwt.user.client.ui.Image(VerifyStatusPlugin.RESOURCES.greenCheck())); } else if (vote < 0) { p.add(new com.google.gwt.user.client.ui.Image(VerifyStatusPlugin.RESOURCES.redNot())); } else if (vote == 0) { p.add(new com.google.gwt.user.client.ui.Image(VerifyStatusPlugin.RESOURCES.warning())); } p.add(new com.google.gwt.user.client.ui.InlineHyperlink(job.getKey(), job.getValue().url())); p.add(new com.google.gwt.user.client.ui.InlineLabel(((" (" + (job.getValue().duration())) + ")"))); if (job.getValue().abstain()) { p.add(new com.google.gwt.user.client.ui.Image(VerifyStatusPlugin.RESOURCES.info())); } grid.setWidget(row, 0, p); row++; } add(grid); }


public synchronized org.eclipse.jgit.lib.Config getGlobalPluginConfig(java.lang.String pluginName) { if (pluginConfigs.containsKey(pluginName)) { return pluginConfigs.get(pluginName); } java.nio.file.Path pluginConfigFile = site.etc_dir.resolve((pluginName + ".config")); org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(pluginConfigFile.toFile(), org.eclipse.jgit.util.FS.DETECTED); pluginConfigs.put(pluginName, cfg); if (!(cfg.getFile().exists())) { com.google.gerrit.server.config.PluginConfigFactory.log.info((("No " + (pluginConfigFile.toAbsolutePath())) + "; assuming defaults")); return cfg; } try { cfg.load(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.config.PluginConfigFactory.log.warn(("Failed to load " + (pluginConfigFile.toAbsolutePath())), e); } return cfg; }
@java.lang.Override public void close() { reopenThread.close(); try { searcherManager.maybeRefreshBlocking(); } catch (java.io.IOException e) { com.google.gerrit.lucene.AbstractLuceneIndex.log.warn("error finishing pending Lucene writes", e); } try { writer.getIndexWriter().close(); } catch (org.apache.lucene.store.AlreadyClosedException e) { } catch (java.io.IOException e) { com.google.gerrit.lucene.AbstractLuceneIndex.log.warn("error closing Lucene writer", e); } try { dir.close(); } catch (java.io.IOException e) { com.google.gerrit.lucene.AbstractLuceneIndex.log.warn("error closing Lucene directory", e); } }


@java.lang.Override public java.util.List<com.google.gerrit.server.query.change.ChangeData> toList() { return r; }

private void decodeChangedLines(org.apache.lucene.document.Document doc, com.google.gerrit.server.query.change.ChangeData cd) { org.apache.lucene.index.IndexableField added = doc.getField(com.google.gerrit.lucene.LuceneChangeIndex.ADDED_FIELD); org.apache.lucene.index.IndexableField deleted = doc.getField(com.google.gerrit.lucene.LuceneChangeIndex.DELETED_FIELD); if ((added != null) && (deleted != null)) { cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue()); } }
public com.google.gerrit.server.git.CodeReviewCommit composeGitlinksCommit(final com.google.gerrit.reviewdb.client.Branch.NameKey subscriber, com.google.gerrit.server.git.CodeReviewCommit currentCommit) throws com.google.gerrit.server.git.SubmoduleException, java.io.IOException { OpenRepo or; try { or = orm.openRepo(subscriber.getParentKey(), false); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException("Cannot access superproject", e); } java.lang.StringBuilder msgbuf = new java.lang.StringBuilder(""); org.eclipse.jgit.dircache.DirCache dc = com.google.gerrit.server.git.SubmoduleOp.readTree(or.rw, currentCommit); org.eclipse.jgit.dircache.DirCacheEditor ed = dc.editor(); for (com.google.gerrit.reviewdb.client.SubmoduleSubscription s : targets.get(subscriber)) { updateSubmodule(dc, ed, msgbuf, s); } ed.finish(); ObjectId newTreeId = dc.writeTree(or.ins); if (newTreeId.equals(currentCommit.getTree())) { return currentCommit; } or.rw.parseBody(currentCommit); CommitBuilder commit = new CommitBuilder(); commit.setTreeId(newTreeId); commit.setParentIds(currentCommit.getParents()); if (verboseSuperProject) { commit.setMessage((((currentCommit.getFullMessage()) + "\n\n*submodules:\n") + (msgbuf.toString()))); } else { commit.setMessage(currentCommit.getFullMessage()); } commit.setAuthor(currentCommit.getAuthorIdent()); commit.setCommitter(myIdent); ObjectId id = or.ins.insert(commit); return or.rw.parseCommit(id); }
private void createSubmoduleCommitMsg(java.lang.StringBuilder msgbuf, com.google.gerrit.reviewdb.client.SubmoduleSubscription s, com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo subOr, org.eclipse.jgit.revwalk.RevCommit newCommit, org.eclipse.jgit.revwalk.RevCommit oldCommit) throws com.google.gerrit.server.git.SubmoduleException { msgbuf.append(("* Update " + (s.getPath()))); msgbuf.append(((" from branch '" + (s.getSubmodule().getShortName())) + "'")); if (oldCommit == null) { return; } try { subOr.rw.resetRetain(subOr.canMergeFlag); subOr.rw.markStart(newCommit); subOr.rw.markUninteresting(oldCommit); for (org.eclipse.jgit.revwalk.RevCommit c : subOr.rw) { subOr.rw.parseBody(c); msgbuf.append(("\n - " + (c.getFullMessage().replace("\n", "\n ")))); } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException(("Could not perform a revwalk to " + "create superproject commit message"), e); } }
@org.junit.Test public void testSubmoduleCommitMessage() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<?> superRepo = createProjectWithPush("super-project"); org.eclipse.jgit.junit.TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project"); allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master"); pushChangeTo(subRepo, "master"); createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master"); org.eclipse.jgit.lib.ObjectId subHEAD = pushChangeTo(subRepo, "master"); org.eclipse.jgit.revwalk.RevWalk rw = subRepo.getRevWalk(); expectToHaveCommitMessage(superRepo, "master", ((("Update git submodules\n\n" + "* Update ") + (name("subscribed-to-project"))) + " from branch 'master'")); subHEAD = pushChangeTo(subRepo, "master"); org.eclipse.jgit.revwalk.RevCommit subCommitMsg = rw.parseCommit(subHEAD); expectToHaveCommitMessage(superRepo, "master", ((((("Update git submodules\n\n" + "* Update ") + (name("subscribed-to-project"))) + " from branch 'master'") + "\n - ") + (subCommitMsg.getFullMessage().replace("\n", "\n ")))); }

@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.verifystatus.commands.Failure { try { checkPermission(); final com.googlesource.gerrit.plugins.verifystatus.commands.VerifyStatusQueryShell shell = factory.create(in, out); shell.setOutputFormat(format); if ((query) != null) { shell.execute(query); } else { shell.run(); } } catch (com.google.gerrit.common.errors.PermissionDeniedException err) { throw new com.googlesource.gerrit.plugins.verifystatus.commands.UnloggedFailure(("fatal: " + (err.getMessage()))); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { try { com.google.gerrit.server.mail.ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId()); if ((account) != null) { cm.setFrom(account.getId()); } cm.setChangeMessage(message.getMessage(), ctx.getWhen()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.change.Abandon.log.error(("Cannot email update for change " + (change.getId())), e); } changeAbandoned.fire(change, patchSet, account, msgTxt, ctx.getWhen()); }






@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { manifests = com.google.common.collect.Maps.newHashMap(); java.lang.String path; com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest manifest; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader); if ((getRevision()) == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(refName); } org.eclipse.jgit.revwalk.RevCommit r = rw.parseCommit(getRevision()); org.eclipse.jgit.treewalk.TreeWalk treewalk = new org.eclipse.jgit.treewalk.TreeWalk(reader); treewalk.addTree(r.getTree()); treewalk.setRecursive(false); treewalk.setFilter(org.eclipse.jgit.treewalk.filter.PathSuffixFilter.create(".xml")); while (treewalk.next()) { if (treewalk.isSubtree()) { treewalk.enterSubtree(); } else { path = treewalk.getPathString(); try { java.io.ByteArrayInputStream input = new java.io.ByteArrayInputStream(readFile(path)); manifest = ((com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest) (manifestUnmarshaller.unmarshal(input))); manifests.put(path, manifest); } catch (javax.xml.bind.JAXBException e) { e.printStackTrace(); } } } treewalk.release(); }



public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> addReviewers(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.common.data.LabelTypes labelTypes, com.google.gerrit.reviewdb.client.Change change, java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> wantReviewers) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = change.currentPatchSetId(); java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> existingReviewers; if (migration.readChanges()) { existingReviewers = notes.load().getReviewers().byState(com.google.gerrit.server.REVIEWER); } else { existingReviewers = getReviewers(db, notes).all(); } return addReviewers(db, update, labelTypes, change, psId, false, null, null, wantReviewers, existingReviewers); }
private java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> addCcs(com.google.gerrit.server.notedb.ChangeUpdate update, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> wantCCs, com.google.gerrit.server.ReviewerSet existingReviewers) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> need = new java.util.LinkedHashSet(wantCCs); need.removeAll(existingReviewers.all()); for (com.google.gerrit.reviewdb.client.Account.Id account : need) { update.putReviewer(account, com.google.gerrit.server.CC); } return need; }
public void addRefSpec(java.lang.String spec) { refSpecs.add(new org.eclipse.jgit.transport.RefSpec(spec)); }
@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitUploadPackGroups.class).toProvider(com.google.gerrit.server.config.GitUploadPackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); bind(new com.google.inject.TypeLiteral<java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).annotatedWith(com.google.gerrit.server.config.GitReceivePackGroups.class).toProvider(com.google.gerrit.server.config.GitReceivePackGroupsProvider.class).in(com.google.gerrit.server.project.SINGLETON); bind(ChangeControl.Factory.class); factory(ProjectControl.AssistedFactory.class); }



@java.lang.Override public void run() throws java.io.IOException { ui.header("Index"); com.google.gerrit.server.index.IndexModule.IndexType type = index.select("Type", "type", IndexType.LUCENE); for (com.google.gerrit.server.index.SchemaDefinitions<?> def : com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS) { com.google.gerrit.lucene.AbstractLuceneIndex.setReady(site, def.getName(), def.getLatest().getVersion(), true); } if (((site.isNew) || (isEmptySite())) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { } else { final java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }
public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules, com.google.gerrit.extensions.api.changes.SubmitInput submitInput) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { this.submitInput = submitInput; this.caller = caller; updateSubmissionId(change); this.db = db; orm.setContext(db, ts, caller, submissionId); logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller); checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs); if (cs.furtherHiddenChanges()) { throw new com.google.gerrit.extensions.restapi.AuthException((("A change to be submitted with " + (change.getId())) + " is not visible")); } this.commits = new com.google.gerrit.server.git.MergeOp.CommitStatus(cs); com.google.gerrit.server.git.MergeSuperSet.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } else { logDebug("Bypassing submit rules"); bypassSubmitRules(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Error from integrateIntoHistory", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }

@org.junit.Test public void submitRecords() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setSubjectForCommit("Submit patch set 1"); update.merge("1-1453387607626-96fabc25", com.google.common.collect.ImmutableList.of(submitRecord("NOT_READY", null, submitLabel("Verified", "OK", changeOwner.getAccountId()), submitLabel("Code-Review", "NEED", null)), submitRecord("NOT_READY", null, submitLabel("Verified", "OK", changeOwner.getAccountId()), submitLabel("Alternative-Code-Review", "NEED", null)))); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); java.util.List<com.google.gerrit.common.data.SubmitRecord> recs = notes.getSubmitRecords(); assertThat(recs).hasSize(2); assertThat(recs.get(0)).isEqualTo(submitRecord("NOT_READY", null, submitLabel("Verified", "OK", changeOwner.getAccountId()), submitLabel("Code-Review", "NEED", null))); assertThat(recs.get(1)).isEqualTo(submitRecord("NOT_READY", null, submitLabel("Verified", "OK", changeOwner.getAccountId()), submitLabel("Alternative-Code-Review", "NEED", null))); assertThat(notes.getChange().getSubmissionId()).isEqualTo("1-1453387607626-96fabc25"); }
@org.junit.Test public void listApprovalsOnDraftChange() throws java.lang.Exception { assume().that(isAllowDrafts()).isTrue(); com.google.gerrit.acceptance.PushOneCommit.Result result = createDraftChange(); result.assertOkStatus(); java.lang.String changeId = result.getChangeId(); java.lang.String triplet = ((project.get()) + "~master~") + changeId; gApi.changes().id(triplet).addReviewer(user.fullName); ChangeInfo info = get(triplet); LabelInfo label = info.labels.get("Code-Review"); assertThat(label.all).hasSize(1); assertThat(label.all.get(0)._accountId).isEqualTo(user.id.get()); assertThat(label.all.get(0).value).isEqualTo(0); ReviewerState rs = (com.google.gerrit.testutil.NoteDbMode.readWrite()) ? ReviewerState.REVIEWER : ReviewerState.CC; java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> ccs = info.reviewers.get(rs); assertThat(ccs).hasSize(1); assertThat(ccs.iterator().next()._accountId).isEqualTo(user.id.get()); setApiUser(user); gApi.changes().id(triplet).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); setApiUser(admin); label = get(triplet).labels.get("Code-Review"); assertThat(label.all).hasSize(1); assertThat(label.all.get(0)._accountId).isEqualTo(user.id.get()); assertThat(label.all.get(0).value).isEqualTo(1); }
@java.lang.Override public java.lang.String format(java.lang.String projectName, java.lang.String path, java.lang.String revision, java.lang.String abbrRev, com.googlesource.gerrit.plugins.xdocs.ConfigSection globalCfg, java.lang.String raw) throws java.io.IOException { if (!(globalCfg.getBoolean(com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig.KEY_ALLOW_HTML, false))) { raw = suppressHtml(raw); } com.googlesource.gerrit.plugins.xdocs.ConfigSection projectCfg = formatters.getFormatterConfig(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.NAME, projectName); java.io.File tmpFile = new java.io.File(baseDir, (("tmp/asciidoctor-" + (com.google.gerrit.common.TimeUtil.nowTs().getNanos())) + ".tmp")); try { Asciidoctor.Factory.create(com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.class.getClassLoader()).render(raw, createOptions(projectCfg, abbrRev, tmpFile)); try (java.io.FileInputStream input = new java.io.FileInputStream(tmpFile)) { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream(); com.google.common.io.ByteStreams.copy(input, out); java.lang.String html = out.toString(java.nio.charset.StandardCharsets.UTF_8.name()); return util.applyCss(html, com.googlesource.gerrit.plugins.xdocs.formatter.AsciidoctorFormatter.NAME, projectName); } } finally { if (!(tmpFile.delete())) { tmpFile.deleteOnExit(); } } }
public static org.eclipse.jgit.revwalk.RevCommit resolveCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, java.lang.String str) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try { return rw.parseCommit(repo.resolve(str)); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException | org.eclipse.jgit.errors.RevisionSyntaxException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } catch (org.eclipse.jgit.errors.MissingObjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } }
@org.junit.Test public void dryRunMerge_Conflicts() throws java.lang.Exception { changeInTwoBranches("a.txt", "a.txt"); com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/projects/" + (project.get())) + "/branches/master/mergeable?source=branchA")); com.google.gerrit.extensions.common.MergeableInfo m = newGson().fromJson(r.getReader(), com.google.gerrit.extensions.common.MergeableInfo.class); assertThat(m.mergeable).isFalse(); assertThat(m.conflicts).containsExactly("a.txt"); }
@org.junit.Test public void dryRunMerge() throws java.lang.Exception { changeInTwoBranches("a.txt", "b.txt"); com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/projects/" + (project.get())) + "/branches/master/mergeable?source=branchA")); com.google.gerrit.extensions.common.MergeableInfo m = newGson().fromJson(r.getReader(), com.google.gerrit.extensions.common.MergeableInfo.class); assertThat(m.mergeable).isTrue(); }

public static org.eclipse.jgit.lib.ObjectId createMergeCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.revwalk.RevCommit mergeTip, org.eclipse.jgit.revwalk.RevCommit originalCommit, java.lang.String mergeStrategy, org.eclipse.jgit.lib.PersonIdent committerIndent, java.lang.String commitMsg, org.eclipse.jgit.revwalk.RevWalk rw) throws com.google.gerrit.extensions.restapi.MergeConflictException, com.google.gerrit.server.git.MergeIdenticalTreeException, java.io.IOException { if (rw.isMergedInto(originalCommit, mergeTip)) { throw new com.google.gerrit.server.git.MergeIdenticalTreeException("merge identical tree: change(s) has been already merged!"); } org.eclipse.jgit.merge.Merger m = com.google.gerrit.server.git.MergeUtil.newMerger(repo, inserter, mergeStrategy); if (m.merge(false, mergeTip, originalCommit)) { org.eclipse.jgit.lib.ObjectId tree = m.getResultTreeId(); org.eclipse.jgit.lib.CommitBuilder mergeCommit = new org.eclipse.jgit.lib.CommitBuilder(); mergeCommit.setTreeId(tree); mergeCommit.setParentIds(mergeTip, originalCommit); mergeCommit.setAuthor(committerIndent); mergeCommit.setCommitter(committerIndent); mergeCommit.setMessage(commitMsg); return inserter.insert(mergeCommit); } java.util.List<java.lang.String> conflicts = com.google.common.collect.ImmutableList.of(); if (m instanceof org.eclipse.jgit.merge.ResolveMerger) { conflicts = ((org.eclipse.jgit.merge.ResolveMerger) (m)).getUnmergedPaths(); } throw new com.google.gerrit.extensions.restapi.MergeConflictException(com.google.gerrit.server.git.MergeUtil.createConflictMessage(conflicts)); }






@com.google.inject.Provides @com.google.inject.Singleton @com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.POLYGERRIT_INDEX_SERVLET) javax.servlet.http.HttpServlet getPolyGerritUiIndexServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) { return new com.google.gerrit.httpd.raw.SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev()); }
private void validateReviewer(java.lang.String reviewer) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(reviewer); if (account == null) { try { groupsCollection.get().parse(reviewer); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException((("Account or group " + reviewer) + " not found")); } } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.PutReviewers.log.error(("Failed to resolve account " + reviewer)); } }
com.googlesource.gerrit.plugins.serviceuser.GetServiceUser.ServiceUserInfo getAsServiceUser(org.eclipse.jgit.lib.PersonIdent committerIdent) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder committer = new java.lang.StringBuilder(); committer.append(committerIdent.getName()); committer.append(" <"); committer.append(committerIdent.getEmailAddress()); committer.append("> "); com.google.gerrit.reviewdb.client.Account account = resolver.find(committer.toString()); if (account == null) { return null; } try { return getServiceUser.get().apply(new com.googlesource.gerrit.plugins.serviceuser.ServiceUserResource(genericUserFactory.create(account.getId()))); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { return null; } }
@java.lang.Override public void start() { queue.getDefaultQueue().scheduleAtFixedRate(compresser, 1, 24, java.util.concurrent.TimeUnit.HOURS); }
@java.lang.Override protected org.eclipse.jgit.lfs.server.LargeFileRepository getLargeFileRepository(com.googlesource.gerrit.plugins.lfs.LfsRequest request, java.lang.String path) throws org.eclipse.jgit.lfs.errors.LfsException { java.lang.String pathInfo = (path.startsWith("/")) ? path : "/" + path; java.util.regex.Matcher matcher = com.googlesource.gerrit.plugins.lfs.LfsApiServlet.URL_PATTERN.matcher(pathInfo); if (!(matcher.matches())) { return null; } com.google.gerrit.reviewdb.client.Project.NameKey project = Project.NameKey.parse(com.google.gerrit.common.ProjectUtil.stripGitSuffix(matcher.group(1))); com.google.gerrit.server.project.ProjectState state = projectCache.get(project); if ((state == null) || ((state.getProject().getState()) == (HIDDEN))) { throw new org.eclipse.jgit.lfs.errors.LfsRepositoryNotFound(project.get()); } if ((request.getOperation().equals("upload")) && ((state.getProject().getState()) == (READ_ONLY))) { throw new org.eclipse.jgit.lfs.errors.LfsRepositoryReadOnly(project.get()); } org.eclipse.jgit.lib.Config config = pluginConfigFactory.getProjectPluginConfigWithInheritance(state, pluginName); return config.getBoolean("lfs", "enabled", false) ? getRepository() : null; }

@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((changeMessage) == null) { return; } emailReviewers(ctx.getProject(), currChange, del, changeMessage); try { hooks.doReviewerDeletedHook(currChange, reviewer, currPs, changeMessage.getMessage(), newApprovals, oldApprovals, dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.DeleteReviewer.log.warn("ChangeHook.doCommentAddedHook delivery failed", e); } }
@java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Account result) { registerNewEmail.setEnabled(true); onSaveSuccess(com.google.gerrit.client.FormatUtil.asInfo(result)); if (onSave != null) { onSave.onSuccess(result); } }
public void addApprovals(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.common.data.LabelTypes labelTypes, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.server.project.ChangeControl changeCtl, java.util.Map<java.lang.String, java.lang.Short> approvals) throws com.google.gwtorm.server.OrmException { if (!(approvals.isEmpty())) { com.google.gerrit.server.ApprovalsUtil.checkApprovals(approvals, changeCtl); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> cells = new java.util.ArrayList<>(approvals.size()); java.util.Date ts = update.getWhen(); for (java.util.Map.Entry<java.lang.String, java.lang.Short> vote : approvals.entrySet()) { com.google.gerrit.common.data.LabelType lt = labelTypes.byLabel(vote.getKey()); cells.add(new com.google.gerrit.reviewdb.client.PatchSetApproval(new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(ps.getId(), ps.getUploader(), lt.getLabelId()), vote.getValue(), ts)); update.putApproval(vote.getKey(), vote.getValue()); } db.patchSetApprovals().insert(cells); } }


java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> getForPatchSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get(db, ctl.getNotes(), psId); if (ps == null) { return java.util.Collections.emptyList(); } return getForPatchSet(db, ctl, ps); }

public void copy(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { db.patchSetApprovals().insert(getForPatchSet(db, ctl, ps)); }


@java.lang.Override public com.google.gerrit.server.mail.Address from(final com.google.gerrit.reviewdb.client.Account.Id fromId) { if (fromId != null) { com.google.gerrit.reviewdb.client.Account a = accountCache.get(fromId).getAccount(); java.lang.String userEmail = a.getPreferredEmail(); return new com.google.gerrit.server.mail.Address(a.getFullName(), (userEmail != null ? userEmail : srvAddr.getEmail())); } return srvAddr; }


@java.lang.Override public void onReviewerAdded(com.google.gerrit.extensions.events.ReviewerAddedListener.Event event) { com.googlesource.gerrit.plugins.hooks.HookArgs args = hookFactory.createArgs(); com.google.gerrit.extensions.common.ChangeInfo c = event.getChange(); args.add("--change", c.id); args.addUrl(c); args.add("--change-owner", c.owner); args.add("--project", c.project); args.add("--branch", c.branch); args.add("--reviewer", event.getReviewer()); hook.submit(c.project, args); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { fire(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(account), util.accountInfo(adder), when); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { emailReviewers(rsrc.getChange(), added); if (!(added.isEmpty())) { for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : added) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(psa.getAccountId()).getAccount(); reviewerAdded.fire(rsrc.getChange(), patchSet, account, ctx.getUser().asIdentifiedUser().getAccount(), ctx.getWhen()); } } }
private void doEnterAgreement() { Util.ACCOUNT_SEC.enterAgreement(current.getName(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwtjsonrpc.common.VoidResult>() { @java.lang.Override public void onSuccess(final com.google.gwtjsonrpc.common.VoidResult result) { com.google.gerrit.client.Gerrit.display(nextToken); } @java.lang.Override public void onFailure(final java.lang.Throwable caught) { yesIAgreeBox.setText(""); super.onFailure(caught); } }); }
@java.lang.Override public void onFailure(final java.lang.Throwable caught) { yesIAgreeBox.setText(""); super.onFailure(caught); }
@java.lang.Override public void preDisplay(final com.google.gerrit.common.data.AgreementInfo result) { agreements.display(result); }
@java.lang.Override public void onSuccess(com.google.gerrit.common.data.AgreementInfo result) { if (isAttached()) { mySigned = new java.util.HashSet(result.accepted); postRPC(); } }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myAgreements(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.common.data.AgreementInfo>(this) { @java.lang.Override public void preDisplay(final com.google.gerrit.common.data.AgreementInfo result) { agreements.display(result); } }); }
@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SVC.myAgreements(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.common.data.AgreementInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.common.data.AgreementInfo result) { if (isAttached()) { mySigned = new java.util.HashSet(result.accepted); postRPC(); } } }); Gerrit.SYSTEM_SVC.contributorAgreements(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.ContributorAgreement>>() { @java.lang.Override public void onSuccess(final java.util.List<com.google.gerrit.common.data.ContributorAgreement> result) { if (isAttached()) { available = result; postRPC(); } } }); }
void addOne(final AgreementInfo info, final java.lang.String k) { final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); final com.google.gerrit.common.data.ContributorAgreement cla = info.agreements.get(k); final java.lang.String statusName; if (cla == null) { statusName = Util.C.agreementStatus_EXPIRED(); } else { statusName = Util.C.agreementStatus_VERIFIED(); } table.setText(row, 1, statusName); if (cla == null) { table.setText(row, 2, ""); table.setText(row, 3, ""); } else { final java.lang.String url = cla.getAgreementUrl(); if ((url != null) && ((url.length()) > 0)) { final com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(cla.getName(), url); a.setTarget("_blank"); table.setWidget(row, 2, a); } else { table.setText(row, 2, cla.getName()); } table.setText(row, 3, cla.getDescription()); } final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); for (int c = 1; c < 4; c++) { fmt.addStyleName(row, c, Gerrit.RESOURCES.css().dataCell()); } setRowItem(row, cla); }
private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try { com.google.gerrit.server.git.BatchUpdate.RepoContext ctx = new com.google.gerrit.server.git.BatchUpdate.RepoContext(); for (com.google.gerrit.server.git.BatchUpdate.Op op : ops.values()) { op.updateRepo(ctx); } if ((inserter) != null) { inserter.flush(); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.git.UpdateException(e); } }


private void showCLA(final com.google.gerrit.common.data.ContributorAgreement cla) { current = cla; java.lang.String url = cla.getAgreementUrl(); if ((url != null) && ((url.length()) > 0)) { agreementGroup.setVisible(true); agreementHtml.setText(Gerrit.C.rpcStatusWorking()); if ((!(url.startsWith("http:"))) && (!(url.startsWith("https:")))) { url = (com.google.gwt.core.client.GWT.getHostPageBaseURL()) + url; } final com.google.gwt.http.client.RequestBuilder rb = new com.google.gwt.http.client.RequestBuilder(com.google.gwt.http.client.RequestBuilder.GET, url); rb.setCallback(new com.google.gwt.http.client.RequestCallback() { @java.lang.Override public void onError(com.google.gwt.http.client.Request request, java.lang.Throwable exception) { new com.google.gerrit.client.ErrorDialog(exception).center(); } @java.lang.Override public void onResponseReceived(com.google.gwt.http.client.Request request, com.google.gwt.http.client.Response response) { final java.lang.String ct = response.getHeader("Content-Type"); if ((((response.getStatusCode()) == 200) && (ct != null)) && ((ct.equals("text/html")) || (ct.startsWith("text/html;")))) { agreementHtml.setHTML(response.getText()); } else { new com.google.gerrit.client.ErrorDialog(response.getStatusText()).center(); } } }); try { rb.send(); } catch (com.google.gwt.http.client.RequestException e) { new com.google.gerrit.client.ErrorDialog(e).show(); } } else { agreementGroup.setVisible(false); } finalGroup.setVisible(((cla.getAutoVerify()) != null)); yesIAgreeBox.setText(""); submit.setEnabled(false); }
private void renderSelf() { current = null; agreementGroup.setVisible(false); finalGroup.setVisible(false); radios.clear(); final com.google.gerrit.client.ui.SmallHeading hdr = new com.google.gerrit.client.ui.SmallHeading(); if (available.isEmpty()) { hdr.setText(Util.C.newAgreementNoneAvailable()); } else { hdr.setText(Util.C.newAgreementSelectTypeHeading()); } radios.add(hdr); for (final com.google.gerrit.common.data.ContributorAgreement cla : available) { final com.google.gwt.user.client.ui.RadioButton r = new com.google.gwt.user.client.ui.RadioButton("cla_id", cla.getName()); r.addStyleName(Gerrit.RESOURCES.css().contributorAgreementButton()); radios.add(r); if (mySigned.contains(cla.getName())) { r.setEnabled(false); final com.google.gwt.user.client.ui.Label l = new com.google.gwt.user.client.ui.Label(Util.C.newAgreementAlreadySubmitted()); l.setStyleName(Gerrit.RESOURCES.css().contributorAgreementAlreadySubmitted()); radios.add(l); } else { r.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(final com.google.gwt.event.dom.client.ClickEvent event) { showCLA(cla); } }); } if (((cla.getDescription()) != null) && (!(cla.getDescription().equals("")))) { final com.google.gwt.user.client.ui.Label l = new com.google.gwt.user.client.ui.Label(cla.getDescription()); l.setStyleName(Gerrit.RESOURCES.css().contributorAgreementShortDescription()); radios.add(l); } } }

@java.lang.Override protected void onLoad() { super.onLoad(); com.google.gerrit.client.account.AccountApi.getAgreements("self", new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.account.AgreementInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.account.AgreementInfo> result) { if (isAttached()) { mySigned = new java.util.HashSet<>(); for (com.google.gerrit.client.account.AgreementInfo info : com.google.gerrit.client.rpc.Natives.asList(result)) { mySigned.add(info.name()); } postRPC(); } } }); Gerrit.SYSTEM_SVC.contributorAgreements(new com.google.gerrit.client.rpc.GerritCallback<java.util.List<com.google.gerrit.common.data.ContributorAgreement>>() { @java.lang.Override public void onSuccess(final java.util.List<com.google.gerrit.common.data.ContributorAgreement> result) { if (isAttached()) { available = result; postRPC(); } } }); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals() throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else { currentApprovals = com.google.common.collect.ImmutableList.copyOf(approvalsUtil.byPatchSet(db, changeControl(), c.currentPatchSetId())); } } return currentApprovals; }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
protected void setApiHeaders(javax.servlet.http.HttpServletResponse res, java.lang.String contentType) { if (!(com.google.common.base.Strings.isNullOrEmpty(contentType))) { res.setContentType(contentType); } res.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); res.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment"); res.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, "*"); setCacheHeaders(res); }
protected com.google.gitiles.FakeHttpServletResponse buildResponse(java.lang.String path, java.lang.String queryString, int expectedStatus) throws java.lang.Exception { com.google.gitiles.FakeHttpServletRequest req = com.google.gitiles.FakeHttpServletRequest.newRequest(); req.setPathInfo(path); if (queryString != null) { req.setQueryString(queryString); } com.google.gitiles.FakeHttpServletResponse res = new com.google.gitiles.FakeHttpServletResponse(); servlet.service(req, res); assertThat(res.getStatus()).isEqualTo(expectedStatus); return res; }
private void initProviderBouncyCastle(org.eclipse.jgit.lib.Config cfg) { setKeyExchangeFactories(java.util.Arrays.<org.apache.sshd.common.NamedFactory<org.apache.sshd.common.KeyExchange>>asList(new org.apache.sshd.server.kex.DHG14.Factory(), new org.apache.sshd.server.kex.DHG1.Factory())); org.apache.sshd.common.NamedFactory<org.apache.sshd.common.Random> factory; if (cfg.getBoolean("sshd", null, "testUseInsecureRandom", false)) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory(); } else { factory = new org.apache.sshd.common.random.BouncyCastleRandom.Factory(); } setRandomFactory(new org.apache.sshd.common.random.SingletonRandomFactory(factory)); }








@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.RevertInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.RefControl refControl = req.getControl().getRefControl(); com.google.gerrit.reviewdb.client.Change change = req.getChange(); if (!(refControl.canUpload())) { throw new com.google.gerrit.extensions.restapi.AuthException("revert not permitted"); } else if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.change.Revert.status(change)))); } com.google.gerrit.reviewdb.client.Change.Id revertedChangeId = revert(req.getControl(), com.google.common.base.Strings.emptyToNull(input.message)); return json.create(ChangeJson.NO_OPTIONS).format(req.getProject(), revertedChangeId); }




public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.project.ChangeControl control, java.lang.String msgTxt, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { com.google.gerrit.server.CurrentUser user = control.getUser(); com.google.gerrit.reviewdb.client.Account account = (user.isIdentifiedUser()) ? user.asIdentifiedUser().getAccount() : null; com.google.gerrit.server.change.Abandon.Op op = new com.google.gerrit.server.change.Abandon.Op(msgTxt, account, notifyHandling); try (com.google.gerrit.server.git.BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(control.getId(), op).execute(); } return op.change; }


@org.junit.Test public void createChangeWithoutCLA() throws java.lang.Exception { assume().that(isContributorAgreementsEnabled()).isTrue(); setUseContributorAgreements(InheritableBoolean.FALSE); gApi.changes().create(newChangeInput()); setUseContributorAgreements(InheritableBoolean.TRUE); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("A Contributor Agreement must be completed"); gApi.changes().create(newChangeInput()); }
private static com.google.gitiles.Paginator newPaginator(org.eclipse.jgit.lib.Repository repo, com.google.gitiles.GitilesView view, com.google.gitiles.GitilesAccess access) throws java.io.IOException { if (view == null) { return null; } try (org.eclipse.jgit.revwalk.RevWalk walk = com.google.gitiles.LogServlet.newWalk(repo, view, access)) { if (walk == null) { return null; } com.google.common.base.Optional<org.eclipse.jgit.lib.ObjectId> start = com.google.gitiles.LogServlet.getStart(view.getParameters(), walk.getObjectReader()); if (start == null) { return null; } return new com.google.gitiles.Paginator(walk, com.google.gitiles.LogServlet.getLimit(view), start.orNull()); } }
private static com.google.common.base.Optional<org.eclipse.jgit.lib.ObjectId> getStart(com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> params, org.eclipse.jgit.lib.ObjectReader reader) throws java.io.IOException { java.util.List<java.lang.String> values = params.get(com.google.gitiles.LogServlet.START_PARAM); switch (values.size()) { case 0 : return com.google.common.base.Optional.absent(); case 1 : java.lang.String id = values.get(0); if (!(org.eclipse.jgit.lib.AbbreviatedObjectId.isId(id))) { return null; } java.util.Collection<org.eclipse.jgit.lib.ObjectId> ids = reader.resolve(org.eclipse.jgit.lib.AbbreviatedObjectId.fromString(id)); if ((ids.size()) != 1) { return null; } return com.google.common.base.Optional.of(com.google.common.collect.Iterables.getOnlyElement(ids)); default : return null; } }




protected void setupSoyContext() { soyContext = new java.util.LinkedHashMap<>(); }


private void recursiveDeleteParent(java.io.File file, java.io.File until) { if (file.equals(until)) { return; } if ((file.listFiles().length) == 0) { java.io.File parent = file.getParentFile(); file.delete(); recursiveDeleteParent(parent, until); } }
private void updatePatchSet() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change.Status changeStatus = parentChange.getStatus(); switch (changeStatus) { case NEW : setPatchSetAsDraft(); updateChange(); break; default : sendUserInfo(("Unable to set patch set as draft, change is " + (getStatusName(changeStatus)))); break; } }
@java.lang.Override protected void formatChange() throws com.google.gerrit.common.errors.EmailException { appendText(velocifyFile("Reverted.vm")); }
@java.lang.Override protected void formatChange() throws com.google.gerrit.common.errors.EmailException { appendText(velocifyFile("Restored.vm")); }
private void loadConfigInfo(final com.google.gerrit.client.info.ChangeInfo info, java.lang.String base) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.info.ChangeInfo.RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); java.sql.Timestamp lastReply = com.google.gerrit.client.change.ChangeScreen.myLastReply(info); if (rev.isEdit()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo p = com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParentRevision(info.revisions().values()); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(p, group); loadFileList(b, rev, lastReply, group, comments, null); } else { loadDiff(b, rev, lastReply, group); } group.done(); group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); if (loaded) { group.done(); return; } com.google.gerrit.client.changes.RevisionInfoCache.add(changeId, rev); com.google.gerrit.client.projects.ConfigInfoCache.add(info); com.google.gerrit.client.projects.ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { loaded = true; commentLinkProcessor = result.getCommentLinkProcessor(); setTheme(result.getTheme()); renderChangeInfo(info); loadRevisionInfo(); } })); }

public void abandonInactiveOpenChanges() { if ((cfg.getAbandonAfter()) <= 0) { return; } try { java.lang.String query = ("status:new age:" + (java.util.concurrent.TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()))) + "m"; if (!(cfg.getAbandonIfMergeable())) { query += " -is:mergeable"; } java.util.List<com.google.gerrit.server.query.change.ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false).queryChanges(queryBuilder.parse(query)).changes(); int count = 0; for (com.google.gerrit.server.query.change.ChangeData cd : changesToAbandon) { try { abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null); count++; } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { } catch (java.lang.Throwable e) { com.google.gerrit.server.change.AbandonUtil.log.error(java.lang.String.format("Failed to auto-abandon inactive open change %d.", cd.getId().get()), e); } } com.google.gerrit.server.change.AbandonUtil.log.info(java.lang.String.format("Auto-Abandoned %d of %d changes.", count, changesToAbandon.size())); } catch (com.google.gerrit.server.query.QueryParseException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.AbandonUtil.log.error("Failed to query inactive open changes for auto-abandoning.", e); } }











@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (!(a.isActive())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("cannot deactivate own account"); } a.setActive(false); dbProvider.get().accounts().update(java.util.Collections.singleton(a)); byIdCache.evict(a.getId()); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId()); if (a == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (!(a.isActive())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } a.setActive(false); dbProvider.get().accounts().update(java.util.Collections.singleton(a)); byIdCache.evict(a.getId()); return com.google.gerrit.extensions.restapi.Response.none(); }


@org.junit.Test public void create() throws java.lang.Exception { for (com.google.gerrit.acceptance.rest.project.PushTagIT.TagType tagType : com.google.gerrit.acceptance.rest.project.PushTagIT.TagType.values()) { pushTagForExistingCommit(tagType, Status.REJECTED_OTHER_REASON); allowTagCreation(tagType); pushTagForExistingCommit(tagType, Status.OK); pushTagForNewCommit(tagType, Status.REJECTED_OTHER_REASON); } allowPushOfTagsForNewCommits(); for (com.google.gerrit.acceptance.rest.project.PushTagIT.TagType tagType : com.google.gerrit.acceptance.rest.project.PushTagIT.TagType.values()) { pushTagForNewCommit(tagType, Status.OK); } }


public boolean canCreate(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevObject object) { if (!(canWrite())) { return false; } boolean owner; boolean admin; switch (getUser().getAccessPath()) { case REST_API : case JSON_RPC : case UNKNOWN : owner = isOwner(); admin = getUser().getCapabilities().canAdministrateServer(); break; case GIT : case SSH_COMMAND : case WEB_BROWSER : default : owner = false; admin = false; } if (object instanceof org.eclipse.jgit.revwalk.RevCommit) { if (admin || (owner && (!(isBlocked(Permission.CREATE))))) { return true; } else if (!(canPerform(Permission.CREATE))) { return false; } return canCreateCommit(db, repo, ((org.eclipse.jgit.revwalk.RevCommit) (object)), admin, owner); } else if (object instanceof org.eclipse.jgit.revwalk.RevTag) { final org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { rw.parseBody(tag); } catch (java.io.IOException e) { return false; } final org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); if (tagger != null) { boolean valid; if (getUser().isIdentifiedUser()) { final java.lang.String addr = tagger.getEmailAddress(); valid = getUser().asIdentifiedUser().hasEmailAddress(addr); } else { valid = false; } if (((!valid) && (!owner)) && (!(canForgeCommitter()))) { return false; } } org.eclipse.jgit.revwalk.RevObject tagObject = tag.getObject(); if (tagObject instanceof org.eclipse.jgit.revwalk.RevCommit) { if (!(canCreateCommit(db, repo, ((org.eclipse.jgit.revwalk.RevCommit) (tagObject)), admin, owner))) { return false; } } else { if (!(canCreate(db, repo, tagObject))) { return false; } } if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) { return owner || (canPerform(Permission.CREATE_SIGNED_TAG)); } return owner || (canPerform(Permission.CREATE_TAG)); } else { return false; } }
@org.junit.Test public void delete() throws java.lang.Exception { for (com.google.gerrit.acceptance.rest.project.PushTagIT.TagType tagType : com.google.gerrit.acceptance.rest.project.PushTagIT.TagType.values()) { allowTagCreation(tagType); java.lang.String tagRef = pushTagForExistingCommit(tagType, Status.OK); pushTagDeletion(tagType, tagRef, Status.REJECTED_OTHER_REASON); allowFastForwardTagUpdate(); pushTagDeletion(tagType, tagRef, Status.REJECTED_OTHER_REASON); } allowTagDeletion(); for (com.google.gerrit.acceptance.rest.project.PushTagIT.TagType tagType : com.google.gerrit.acceptance.rest.project.PushTagIT.TagType.values()) { java.lang.String tagRef = pushTagForExistingCommit(tagType, Status.OK); pushTagDeletion(tagType, tagRef, Status.OK); } }

@java.lang.Override public void onLoad(com.google.gerrit.plugin.client.extension.Panel panel) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = panel.getObject(GerritUiExtensionPoint.Key.REVISION_INFO).cast(); if (rev.isEdit()) { return; } panel.setWidget(new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel(panel)); }

@java.lang.Override public void onPluginLoad() { new com.google.gerrit.plugin.client.rpc.RestApi("config").view("server").view(com.google.gerrit.plugin.client.Plugin.get().getPluginName(), "config").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo>() { @java.lang.Override public void onSuccess(com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info) { if (info.showJobsPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory()); } if (info.showJobsDropDownPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory()); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }

@java.lang.Override protected void configure() { get(com.googlesource.gerrit.plugins.verifystatus.CONFIG_KIND, "config").to(com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.class); put(com.googlesource.gerrit.plugins.verifystatus.CONFIG_KIND, "config").to(com.googlesource.gerrit.plugins.verifystatus.server.PutConfig.class); get(com.googlesource.gerrit.plugins.verifystatus.REVISION_KIND, "verifications").to(com.googlesource.gerrit.plugins.verifystatus.server.GetVerifications.class); post(com.googlesource.gerrit.plugins.verifystatus.REVISION_KIND, "verifications").to(com.googlesource.gerrit.plugins.verifystatus.PostVerification.class); }
@java.lang.Override public void onSuccess(com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info) { if (info.showJobsPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory()); } if (info.showJobsDropDownPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory()); } }


@org.junit.Test public void publish() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange("refs/drafts/master"); assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.DRAFT); gApi.changes().id(r.getChangeId()).publish(); assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW); }
@java.lang.Override public Account.Id apply(com.google.gerrit.extensions.common.AccountInfo account) { return new com.google.gerrit.reviewdb.client.Account.Id(account._accountId); }
private static java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id> getReviewers(java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> r) { return com.google.common.collect.Iterables.transform(r, new com.google.common.base.Function<com.google.gerrit.extensions.common.AccountInfo, com.google.gerrit.reviewdb.client.Account.Id>() { @java.lang.Override public Account.Id apply(com.google.gerrit.extensions.common.AccountInfo account) { return new com.google.gerrit.reviewdb.client.Account.Id(account._accountId); } }); }
public com.google.gerrit.common.data.Capable canPushToAtLeastOneRef() { if ((!(canPerformOnAnyRef(Permission.PUSH))) && (!(canPerformOnAnyRef(Permission.PUSH_TAG)))) { java.lang.String pName = state.getProject().getName(); return new com.google.gerrit.common.data.Capable((("Upload denied for project '" + pName) + "'")); } if (state.isUseContributorAgreements()) { return verifyActiveContributorAgreement(); } return com.google.gerrit.common.data.Capable.OK; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : repoManager.list()) { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, projectName, git)) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); boolean update = false; for (com.google.gerrit.common.data.AccessSection accessSection : config.getAccessSections()) { com.google.gerrit.common.data.Permission pushTagPermission = accessSection.getPermission(Permission.PUSH_TAG); if (pushTagPermission == null) { continue; } for (com.google.gerrit.common.data.PermissionRule rule : pushTagPermission.getRules()) { if (rule.getForce()) { rule.setForce(false); update = true; } } } if (!update) { continue; } md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); md.setMessage(com.google.gerrit.server.schema.Schema_130.COMMIT_MSG); config.commit(md); } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException ex) { throw new com.google.gwtorm.server.OrmException(ex); } } }



private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); relativeDateInChangeTable.setEnabled(on); sizeBarInChangeTable.setEnabled(on); legacycidInChangeTable.setEnabled(on); muteCommonPathPrefixes.setEnabled(on); signedOffBy.setEnabled(on); reviewCategoryStrategy.setEnabled(on); diffView.setEnabled(on); emailStrategy.setEnabled(on); }
public static com.google.gerrit.extensions.client.GeneralPreferencesInfo defaults() { com.google.gerrit.extensions.client.GeneralPreferencesInfo p = new com.google.gerrit.extensions.client.GeneralPreferencesInfo(); p.changesPerPage = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DEFAULT_PAGESIZE; p.showSiteHeader = true; p.useFlashClipboard = true; p.emailStrategy = com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED; p.reviewCategoryStrategy = com.google.gerrit.extensions.client.GeneralPreferencesInfo.ReviewCategoryStrategy.NONE; p.downloadScheme = null; p.downloadCommand = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DownloadCommand.CHECKOUT; p.dateFormat = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DateFormat.STD; p.timeFormat = com.google.gerrit.extensions.client.GeneralPreferencesInfo.TimeFormat.HHMM_12; p.relativeDateInChangeTable = false; p.diffView = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE; p.sizeBarInChangeTable = true; p.legacycidInChangeTable = false; p.muteCommonPathPrefixes = true; p.signedOffBy = false; return p; }

@java.lang.Override public void onSuccess(java.lang.Void result) { loadConfigInfo(info, base); }
public static com.google.gerrit.client.info.GeneralPreferences createDefault() { com.google.gerrit.extensions.client.GeneralPreferencesInfo d = com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(); com.google.gerrit.client.info.GeneralPreferences p = createObject().cast(); p.changesPerPage(d.changesPerPage); p.showSiteHeader(d.showSiteHeader); p.useFlashClipboard(d.useFlashClipboard); p.downloadScheme(d.downloadScheme); p.downloadCommand(d.downloadCommand); p.dateFormat(d.getDateFormat()); p.timeFormat(d.getTimeFormat()); p.relativeDateInChangeTable(d.relativeDateInChangeTable); p.sizeBarInChangeTable(d.sizeBarInChangeTable); p.legacycidInChangeTable(d.legacycidInChangeTable); p.muteCommonPathPrefixes(d.muteCommonPathPrefixes); p.signedOffBy(d.signedOffBy); p.reviewCategoryStrategy(d.getReviewCategoryStrategy()); p.diffView(d.getDiffView()); p.emailStrategy(d.emailStrategy); return p; }
@java.lang.Override public void onSuccess(final com.google.gerrit.client.info.ChangeInfo info) { info.init(); addExtensionPoints(info, initCurrentRevision(info)); com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { loadConfigInfo(info, base); } }); group.done(); }
private void display(com.google.gerrit.client.info.GeneralPreferences p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, GeneralPreferencesInfo.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, GeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes()); signedOffBy.setValue(p.signedOffBy()); setListBox(reviewCategoryStrategy, GeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView()); setListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, p.emailStrategy()); display(p.my()); }
@org.junit.Test public void getAndSetPreferences() throws java.lang.Exception { GeneralPreferencesInfo o = gApi.accounts().id(user42.id.toString()).getPreferences(); com.google.gerrit.acceptance.AssertUtil.assertPrefs(o, GeneralPreferencesInfo.defaults(), "my"); assertThat(o.my).hasSize(7); GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults(); i.changesPerPage *= -1; i.showSiteHeader ^= true; i.useFlashClipboard ^= true; i.downloadCommand = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DownloadCommand.REPO_DOWNLOAD; i.dateFormat = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DateFormat.US; i.timeFormat = com.google.gerrit.extensions.client.GeneralPreferencesInfo.TimeFormat.HHMM_24; i.emailStrategy = com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.DISABLED; i.relativeDateInChangeTable ^= true; i.sizeBarInChangeTable ^= true; i.legacycidInChangeTable ^= true; i.muteCommonPathPrefixes ^= true; i.signedOffBy ^= true; i.reviewCategoryStrategy = com.google.gerrit.extensions.client.GeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV; i.diffView = com.google.gerrit.extensions.client.GeneralPreferencesInfo.DiffView.UNIFIED_DIFF; i.my = new java.util.ArrayList(); i.my.add(new MenuItem("name", "url")); i.urlAliases = new java.util.HashMap(); i.urlAliases.put("foo", "bar"); o = gApi.accounts().id(user42.getId().toString()).setPreferences(i); com.google.gerrit.acceptance.AssertUtil.assertPrefs(o, i, "my"); assertThat(o.my).hasSize(1); }

private void setMissingHeader(final java.util.Map<java.lang.String, com.google.gerrit.server.mail.EmailHeader> hdrs, final java.lang.String name, final java.lang.String value) { if ((!(hdrs.containsKey(name))) || (hdrs.get(name).isEmpty())) { hdrs.put(name, new com.google.gerrit.server.mail.EmailHeader.String(value)); } }
void send(com.google.gerrit.server.mail.Address from, java.util.Collection<com.google.gerrit.server.mail.Address> rcpt, java.util.Map<java.lang.String, com.google.gerrit.server.mail.EmailHeader> headers, java.lang.String body) throws com.google.gerrit.common.errors.EmailException;


@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.server.query.change.ChangeData> read() throws com.google.gwtorm.server.OrmException { if (java.lang.Thread.interrupted()) { java.lang.Thread.currentThread().interrupt(); throw new com.google.gwtorm.server.OrmException("interupted"); } return new com.google.gerrit.lucene.LuceneChangeIndex.ChangeDataResults(executor.submit(new java.util.concurrent.Callable<java.util.List<org.apache.lucene.document.Document>>() { @java.lang.Override public java.util.List<org.apache.lucene.document.Document> call() throws com.google.gwtorm.server.OrmException { return doRead(); } })); }




private static com.google.common.collect.ImmutableListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.query.change.ChangeData> byProject(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { ImmutableListMultimap.Builder<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.query.change.ChangeData> builder = new com.google.common.collect.ImmutableListMultimap.Builder<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { builder.put(cd.change().getProject(), cd); } return builder.build(); }
public com.google.gerrit.server.git.ChangeSet completeChangeSet(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId()); cd.changeControl(user); com.google.gerrit.server.git.ChangeSet cs = new com.google.gerrit.server.git.ChangeSet(cd, cd.changeControl().isVisible(db, cd)); if (com.google.gerrit.server.change.Submit.wholeTopicEnabled(cfg)) { return completeChangeSetIncludingTopics(db, cs, user); } return completeChangeSetWithoutTopic(db, cs, user); }

public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationListener> validators = new java.util.LinkedList<>(); validators.add(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl)); validators.add(new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent)); validators.add(new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl)); validators.add(new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl)); if ((com.google.gerrit.server.util.MagicBranch.isMagicBranch(receiveEvent.command.getRefName())) || (ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches())) { validators.add(new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo)); } validators.add(new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers)); validators.add(new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(commitValidationListeners)); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.LinkedList<>(); try { for (com.google.gerrit.server.git.validators.CommitValidationListener commitValidator : validators) { messages.addAll(commitValidator.onCommitReceived(receiveEvent)); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { messages.addAll(e.getMessages()); throw new com.google.gerrit.server.git.validators.CommitValidationException(e.getMessage(), messages); } return messages; }



private boolean validCommit(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.RefControl ctl, org.eclipse.jgit.transport.ReceiveCommand cmd, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { if (validCommits.contains(id)) { return true; } org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(id); rw.parseBody(c); com.google.gerrit.server.events.CommitReceivedEvent receiveEvent = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user); com.google.gerrit.server.git.validators.CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo); try { messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits)); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { logDebug("Commit validation failed on {}", c.name()); messages.addAll(e.getMessages()); reject(cmd, e.getMessage()); return false; } validCommits.add(c.copy()); return true; }


public void merge(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.IdentifiedUser caller, boolean checkSubmitRules, com.google.gerrit.extensions.api.changes.SubmitInput submitInput) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { this.submitInput = submitInput; this.caller = caller; updateSubmissionId(change); this.db = db; orm.setContext(db, ts, caller, submissionId); logDebug("Beginning integration of {}", change); try { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller); checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs); if (cs.furtherHiddenChanges()) { throw new com.google.gerrit.extensions.restapi.AuthException((("A change to be submitted with " + (change.getId())) + " is not visible")); } this.commits = new com.google.gerrit.server.git.MergeOp.CommitStatus(cs); com.google.gerrit.server.git.MergeSuperSet.reloadChanges(cs); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } else { logDebug("Bypassing submit rules"); bypassSubmitRules(cs); } try { integrateIntoHistory(cs); } catch (com.google.gerrit.server.git.IntegrationException e) { logError("Error from integrateIntoHistory", e); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage(), e); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }


private static java.nio.file.Path getOrCreateDataDir(com.googlesource.gerrit.plugins.lfs.LfsConfig config, java.nio.file.Path defaultDataDir) throws java.io.IOException { java.lang.String dataDir = config.getConfig().getString(LfsBackend.FS.name(), null, "directory"); if (com.google.common.base.Strings.isNullOrEmpty(dataDir)) { return defaultDataDir; } java.nio.file.Path ensured = java.nio.file.Files.createDirectories(java.nio.file.Paths.get(dataDir)); if (!(java.nio.file.Files.isReadable(ensured))) { throw new java.io.IOException((("Path '" + (ensured.toAbsolutePath())) + "' cannot be accessed")); } return ensured; }
@java.lang.Override public com.googlesource.gerrit.plugins.lfs.LfsConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { com.googlesource.gerrit.plugins.lfs.LfsConfigInfo info = new com.googlesource.gerrit.plugins.lfs.LfsConfigInfo(); com.googlesource.gerrit.plugins.lfs.LfsConfigSection config = lfsConfig.getForProject(resource.getNameKey()); if (config != null) { info.enabled = config.isEnabled(); info.maxObjectSize = config.getMaxObjectSize(); } return info; }
@java.lang.Override public com.googlesource.gerrit.plugins.lfs.LfsSettingsInfo apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.IdentifiedUser user = self.get().asIdentifiedUser(); if (!((resource.getNameKey().equals(allProjectsName)) && (user.getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.googlesource.gerrit.plugins.lfs.LfsSettingsInfo info = new com.googlesource.gerrit.plugins.lfs.LfsSettingsInfo(); info.backend = lfsConfig.getBackend(); java.util.List<com.googlesource.gerrit.plugins.lfs.LfsConfigSection> configSections = lfsConfig.getConfigSections(); if (!(configSections.isEmpty())) { info.namespaces = new java.util.HashMap(configSections.size()); for (com.googlesource.gerrit.plugins.lfs.LfsConfigSection section : configSections) { com.googlesource.gerrit.plugins.lfs.LfsConfigInfo sectionInfo = new com.googlesource.gerrit.plugins.lfs.LfsConfigInfo(); sectionInfo.enabled = section.isEnabled(); sectionInfo.maxObjectSize = section.getMaxObjectSize(); info.namespaces.put(section.getNamespace(), sectionInfo); } } return info; }

@java.lang.Override protected java.nio.file.Path getResourcePath(java.lang.String pathInfo) { return ui.resolve(pathInfo); }

@java.lang.Override protected java.nio.file.Path getResourcePath(java.lang.String pathInfo) throws java.io.IOException { if ((bowerComponents) == null) { throw new java.io.IOException((("No polymer components found: " + (zip)) + ". Run `buck build //polygerrit-ui:polygerrit_components`?")); } return bowerComponents.resolve(pathInfo); }

@java.lang.Override public void configureServlets() { java.nio.file.Path buckOut = getPaths().buckOut; if (buckOut != null) { serve("/bower_components/*").with(com.google.gerrit.httpd.raw.BowerComponentsServlet.class); serve("/fonts/*").with(com.google.gerrit.httpd.raw.FontsServlet.class); } else { } com.google.inject.Key<javax.servlet.http.HttpServlet> indexKey = com.google.gerrit.httpd.raw.StaticModule.named(com.google.gerrit.httpd.raw.StaticModule.POLYGERRIT_INDEX_SERVLET); for (java.lang.String p : com.google.gerrit.httpd.raw.StaticModule.POLYGERRIT_INDEX_PATHS) { filter(p).through(com.google.gerrit.httpd.XsrfCookieFilter.class); serve(p).with(indexKey); } serve("/*").with(com.google.gerrit.httpd.raw.PolyGerritUiServlet.class); }
@java.lang.Override protected void configureServlets() { serveRegex("^/Documentation/(.+)$").with(com.google.gerrit.httpd.raw.StaticModule.named(com.google.gerrit.httpd.raw.StaticModule.DOC_SERVLET)); serve("/static/*").with(com.google.gerrit.httpd.raw.SiteStaticDirectoryServlet.class); install(new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.httpd.raw.StaticModule.CACHE, java.nio.file.Path.class, com.google.gerrit.httpd.raw.ResourceServlet.Resource.class).maximumWeight((1 << 20)).weigher(ResourceServlet.Weigher.class); } }); if (options.enablePolyGerrit()) { install(new com.google.gerrit.httpd.raw.StaticModule.CoreStaticModule()); install(new com.google.gerrit.httpd.raw.StaticModule.PolyGerritUiModule()); } else if (options.enableDefaultUi()) { install(new com.google.gerrit.httpd.raw.StaticModule.CoreStaticModule()); install(new com.google.gerrit.httpd.raw.StaticModule.GwtUiModule()); } }
@java.lang.Override protected java.nio.file.Path getResourcePath(java.lang.String pathInfo) throws java.io.IOException { if ((fonts) == null) { throw new java.io.IOException((("No fonts found: " + (zip)) + ". Run `buck build //polygerrit-ui:fonts`?")); } return fonts.resolve(pathInfo); }
private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.List<com.google.gerrit.server.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = json.create(options).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if (results.get(n).more()) { info.get(((info.size()) - 1))._moreChanges = true; } } return res; }


@java.lang.Override protected void configure() { get(com.googlesource.gerrit.plugins.lfs.PROJECT_KIND, "lfs:config").to(com.googlesource.gerrit.plugins.lfs.GetLfsConfig.class); get(com.googlesource.gerrit.plugins.lfs.PROJECT_KIND, "lfs:settings").to(com.googlesource.gerrit.plugins.lfs.GetLfsSettings.class); }
@java.lang.Override protected void configure() { install(new com.google.gerrit.extensions.restapi.RestApiModule() { @java.lang.Override protected void configure() { get(com.googlesource.gerrit.plugins.lfs.PROJECT_KIND, "lfs:config").to(com.googlesource.gerrit.plugins.lfs.GetLfsConfig.class); get(com.googlesource.gerrit.plugins.lfs.PROJECT_KIND, "lfs:settings").to(com.googlesource.gerrit.plugins.lfs.GetLfsSettings.class); } }); }
private com.google.gerrit.extensions.common.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllUsersName allUsersName) { com.google.gerrit.extensions.common.GerritInfo info = new com.google.gerrit.extensions.common.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugText"); info.docUrl = getDocUrl(cfg); info.docSearch = docSearcher.isAvailable(); info.editGpgKeys = com.google.gerrit.server.config.GetServerInfo.toBoolean(((enableSignedPush) && (cfg.getBoolean("gerrit", null, "editGpgKeys", true)))); return info; }


private static void populateBottomMenu(com.google.gwt.user.client.ui.RootPanel btmmenu, com.google.gerrit.common.data.HostPageData hpd) { java.lang.String vs = hpd.version; if ((vs == null) || (vs.isEmpty())) { vs = "dev"; } btmmenu.add(new com.google.gwt.user.client.ui.InlineHTML(Gerrit.M.poweredBy(vs))); java.lang.String reportBugUrl = Gerrit.info().gerrit().reportBugUrl(); if (reportBugUrl != null) { java.lang.String reportBugText = Gerrit.info().gerrit().reportBugText(); com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor((reportBugText == null ? Gerrit.C.reportBug() : reportBugText), reportBugUrl); a.setTarget("_blank"); a.setStyleName(""); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(a); } btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(Gerrit.C.keyHelp())); }
public boolean canEmailReviewers() { if ((canEmailReviewers) == null) { canEmailReviewers = (matchAny(capabilities.emailReviewers, com.google.gerrit.server.account.CapabilityControl.ALLOWED_RULE)) || (!(matchAny(capabilities.emailReviewers, com.google.common.base.Predicates.not(com.google.gerrit.server.account.CapabilityControl.ALLOWED_RULE)))); } return canEmailReviewers; }
@java.lang.Override public java.util.Map<java.lang.Object, com.codahale.metrics.Metric> getCells() { return com.google.common.collect.Maps.transformValues(cells, new com.google.common.base.Function<com.google.gerrit.metrics.dropwizard.BucketedCallback<V>.ValueGauge, com.codahale.metrics.Metric>() { @java.lang.Override public com.codahale.metrics.Metric apply(com.google.gerrit.metrics.dropwizard.BucketedCallback<V>.ValueGauge in) { return in; } }); }
private boolean matchAny(java.lang.Iterable<com.google.gerrit.common.data.PermissionRule> rules, com.google.common.base.Predicate<com.google.gerrit.common.data.PermissionRule> predicate) { java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.UUID> ids = com.google.common.collect.Iterables.transform(com.google.common.collect.Iterables.filter(rules, predicate), new com.google.common.base.Function<com.google.gerrit.common.data.PermissionRule, com.google.gerrit.reviewdb.client.AccountGroup.UUID>() { @java.lang.Override public AccountGroup.UUID apply(com.google.gerrit.common.data.PermissionRule rule) { return rule.getGroup().getUUID(); } }); return user.getEffectiveGroups().containsAnyOf(ids); }
com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.PatchLineComment> exportComments(final com.google.gerrit.reviewdb.client.PatchLineComment.Status status) { return com.google.common.collect.ImmutableList.copyOf(com.google.common.collect.Lists.transform(comments, new com.google.common.base.Function<com.google.gerrit.server.notedb.RevisionNoteData.Comment, com.google.gerrit.reviewdb.client.PatchLineComment>() { @java.lang.Override public com.google.gerrit.reviewdb.client.PatchLineComment apply(com.google.gerrit.server.notedb.RevisionNoteData.Comment c) { com.google.gerrit.reviewdb.client.PatchLineComment plc = c.export(); plc.setStatus(status); return plc; } })); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); com.google.gerrit.server.git.CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted); if ((firstFastForward != null) && (!(firstFastForward.equals(args.mergeTip.getInitialTip())))) { ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, firstFastForward)); } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.MergeOneOp(args, n)); } return ops; }
protected com.google.gerrit.server.git.CodeReviewCommit amendGitlink(com.google.gerrit.server.git.CodeReviewCommit commit) throws com.google.gerrit.server.git.IntegrationException { com.google.gerrit.server.git.CodeReviewCommit newCommit = commit; if (args.submoduleOp.hasSubscription(args.destBranch)) { try { newCommit = args.submoduleOp.composeGitlinksCommit(args.destBranch, commit); newCommit.copyFrom(commit); if (commit.equals(toMerge)) { newCommit.setPatchsetId(com.google.gerrit.server.ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId())); args.commits.put(newCommit); } } catch (com.google.gerrit.server.git.SubmoduleException | java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException(("cannot update gitlink for the commit at branch: " + (args.destBranch))); } } return newCommit; }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) { return; } com.google.gerrit.server.git.MergeTip mergeTip = args.mergeTip; if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) { mergeTip.moveTipTo(amendGitlink(toMerge), toMerge); } else { org.eclipse.jgit.lib.PersonIdent myIdent = new org.eclipse.jgit.lib.PersonIdent(args.serverIdent, ctx.getWhen()); com.google.gerrit.server.git.CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge); result = amendGitlink(result); mergeTip.moveTipTo(result, toMerge); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { com.google.gerrit.server.git.MergeTip mergeTip = args.mergeTip; if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) { mergeTip.moveTipTo(amendGitlink(toMerge), toMerge); acceptMergeTip(mergeTip); } else { com.google.gerrit.server.git.CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge); mergeTip.moveTipTo(amendGitlink(newTip), toMerge); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); acceptMergeTip(mergeTip); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); if (((args.mergeTip.getInitialTip()) == null) && (!(sorted.isEmpty()))) { com.google.gerrit.server.git.CodeReviewCommit first = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, first)); } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.MergeOneOp(args, n)); } return ops; }
com.google.gerrit.reviewdb.client.PatchLineComment export() { com.google.gerrit.reviewdb.client.PatchLineComment plc = new com.google.gerrit.reviewdb.client.PatchLineComment(key.export(), lineNbr, author.export(), parentUuid, writtenOn); plc.setSide(side); plc.setStatus(PatchLineComment.Status.forCode(status)); plc.setMessage(message); if ((range) != null) { plc.setRange(range.export()); } plc.setTag(tag); plc.setRevId(new com.google.gerrit.reviewdb.client.RevId(revId)); return plc; }
com.google.gerrit.reviewdb.client.PatchLineComment export() { com.google.gerrit.reviewdb.client.PatchLineComment plc = new com.google.gerrit.reviewdb.client.PatchLineComment(key.export(), lineNbr, author.export(), parentUuid, writtenOn); plc.setSide(side); plc.setMessage(message); if ((range) != null) { plc.setRange(range.export()); } plc.setTag(tag); plc.setRevId(new com.google.gerrit.reviewdb.client.RevId(revId)); return plc; }
com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.PatchLineComment> exportComments(final com.google.gerrit.reviewdb.client.PatchLineComment.Status status) { return com.google.common.collect.ImmutableList.copyOf(com.google.common.collect.Lists.transform(comments, new com.google.common.base.Function<com.google.gerrit.server.notedb.RevisionNoteData.Comment, com.google.gerrit.reviewdb.client.PatchLineComment>() { @java.lang.Override public com.google.gerrit.reviewdb.client.PatchLineComment apply(com.google.gerrit.server.notedb.RevisionNoteData.Comment c) { com.google.gerrit.reviewdb.client.PatchLineComment plc = c.export(); plc.setStatus(status); return plc; } })); }

private void columnPath(com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb, com.google.gerrit.client.info.FileInfo info) { sb.openTd().setStyleName(com.google.gerrit.client.change.FileTable.R.css().pathColumn()).openAnchor(); java.lang.String path = info.path(); if (((mode) == (com.google.gerrit.client.change.FileTable.Mode.EDIT)) && (!(isEditable(info)))) { sb.setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.RESTORE) + "(event,") + (info._row())) + ")")); } else { sb.setAttribute("href", ("#" + (url(info)))).setAttribute("onclick", ((((com.google.gerrit.client.change.FileTable.OPEN) + "(event,") + (info._row())) + ")")); } if (Patch.COMMIT_MSG.equals(path)) { sb.append(Util.C.commitMessage()); } else if (com.google.gerrit.client.Gerrit.getUserPreferences().muteCommonPathPrefixes()) { int commonPrefixLen = commonPrefix(path); if (commonPrefixLen > 0) { sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan(); } sb.append(path.substring(commonPrefixLen)); lastPath = path; } else { sb.append(path); } sb.closeAnchor(); if ((info.oldPath()) != null) { sb.br(); sb.openSpan().setStyleName(com.google.gerrit.client.change.FileTable.R.css().renameCopySource()).append(info.oldPath()).closeSpan(); } sb.closeTd(); }


@java.lang.Deprecated public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return com.google.gerrit.server.PatchLineCommentsUtil.sort(db.patchComments().draftByAuthor(author).toList()); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = new java.util.ArrayList<>(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { for (java.lang.String refName : repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS).keySet()) { com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRefSuffix(refName); com.google.gerrit.reviewdb.client.Change.Id changeId = Change.Id.fromRefPart(refName); if ((accountId == null) || (changeId == null)) { continue; } com.google.gerrit.server.notedb.DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author); comments.addAll(notes.load().getComments().values()); } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
@org.kohsuke.args4j.Option(name = "-o", usage = "Output options") void addOption(com.google.gerrit.extensions.api.changes.SubmittedTogetherOption o) { options.add(o); }
public com.google.gerrit.extensions.api.changes.SubmittedTogetherInfo apply(com.google.gerrit.server.change.ChangeResource resource, java.util.EnumSet<com.google.gerrit.extensions.api.changes.SubmittedTogetherOption> options) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change c = resource.getChange(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> cds; int hidden; if (c.getStatus().isOpen()) { com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.get().completeChangeSet(dbProvider.get(), c, resource.getControl().getUser()); cds = cs.changes().asList(); hidden = cs.nonVisibleChanges().size(); } else if ((c.getStatus().asChangeStatus()) == (com.google.gerrit.extensions.client.ChangeStatus.MERGED)) { cds = queryProvider.get().bySubmissionId(c.getSubmissionId()); hidden = 0; } else { cds = java.util.Collections.emptyList(); hidden = 0; } if ((hidden != 0) && (!(options.contains(SubmittedTogetherOption.NON_VISIBLE_CHANGES)))) { throw new com.google.gerrit.extensions.restapi.AuthException("change would be submitted with a change that you cannot see"); } if (((cds.size()) <= 1) && (hidden == 0)) { cds = java.util.Collections.emptyList(); } else { cds = sort(cds); } com.google.gerrit.extensions.api.changes.SubmittedTogetherInfo info = new com.google.gerrit.extensions.api.changes.SubmittedTogetherInfo(); info.changes = json.create(java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).includeSubmittable(true).formatChangeDatas(cds); info.nonVisibleChanges = hidden; return info; } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { com.google.gerrit.server.change.SubmittedTogether.log.error("Error on getting a ChangeSet", e); throw e; } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo info) { info.init(); addExtensionPoints(info, initCurrentRevision(info)); loadConfigInfo(info, base); }
@com.google.gwt.uibinder.client.UiHandler("showBotComments") void onShowBotComments(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { int n = history.getWidgetCount(); showBotComments.setVisible(false); hideBotComments.setVisible(true); }
@com.google.gwt.uibinder.client.UiHandler("hideBotComments") void onHideBotComments(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { int n = history.getWidgetCount(); hideBotComments.setVisible(false); showBotComments.setVisible(true); }
private com.google.gerrit.acceptance.TestAccount user(java.lang.String name, java.lang.String fullName, java.lang.String emailName, com.google.gerrit.reviewdb.client.AccountGroup... groups) throws java.lang.Exception { java.lang.String[] groupNames = com.google.common.collect.FluentIterable.from(java.util.Arrays.asList(groups)).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.AccountGroup, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.reviewdb.client.AccountGroup in) { return in.getName(); } }).toArray(java.lang.String.class); return accounts.create(name(name), ((name(emailName)) + "@example.com"), fullName, groupNames); }

@java.lang.Override void apply(com.google.gerrit.server.notedb.ChangeUpdate update) throws com.google.gwtorm.server.OrmException { checkUpdate(update); if ((c.getRevId()) == null) { com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId(c, cache, change, ps); } update.putComment(c); }
public java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> draftByChangeAuthor(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Account.Id author) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { final com.google.gerrit.reviewdb.client.Change.Id matchId = notes.getChangeId(); return java.util.stream.StreamSupport.stream(db.patchComments().draftByAuthor(author).spliterator(), false).filter(( c) -> c.getPatchSetId().getParentKey().equals(matchId)).sorted(com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER).collect(java.util.stream.Collectors.toList()); } java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> comments = new java.util.ArrayList<>(); comments.addAll(notes.getDraftComments(author).values()); return com.google.gerrit.server.PatchLineCommentsUtil.sort(comments); }
private static java.util.List<com.google.gerrit.reviewdb.client.PatchLineComment> getPatchLineComments(com.google.gerrit.server.notedb.ChangeBundle bundle, final com.google.gerrit.reviewdb.client.PatchSet ps) { return bundle.getPatchLineComments().stream().filter(( c) -> c.getPatchSetId().equals(ps.getId())).sorted(PatchLineCommentsUtil.PLC_ORDER).collect(java.util.stream.Collectors.toList()); }





private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, assignee, hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments); }




static com.google.gerrit.server.notedb.ChangeNotesState empty(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.AutoValue_ChangeNotesState(change.getId(), null, null, com.google.common.collect.ImmutableSet.<java.lang.String>of(), com.google.common.collect.ImmutableSortedMap.<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet>of(), com.google.common.collect.ImmutableListMultimap.<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSetApproval>of(), com.google.gerrit.server.ReviewerSet.empty(), com.google.common.collect.ImmutableList.<com.google.gerrit.reviewdb.client.Account.Id>of(), com.google.common.collect.ImmutableList.<com.google.gerrit.server.ReviewerStatusUpdate>of(), com.google.common.collect.ImmutableList.<com.google.gerrit.common.data.SubmitRecord>of(), com.google.common.collect.ImmutableList.<com.google.gerrit.reviewdb.client.ChangeMessage>of(), com.google.common.collect.ImmutableListMultimap.<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.ChangeMessage>of(), com.google.common.collect.ImmutableListMultimap.<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.reviewdb.client.PatchLineComment>of()); }


java.lang.String getXGerritAuth();

@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersSameGroupVisibility() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(changeId, user2.username, 2); assertThat(reviewers).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name).isEqualTo(user2.fullName); setApiUser(user1); reviewers = suggestReviewers(changeId, user2.fullName, 2); assertThat(reviewers).isEmpty(); setApiUser(user2); reviewers = suggestReviewers(changeId, user2.username, 2); assertThat(reviewers).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name).isEqualTo(user2.fullName); setApiUser(user3); reviewers = suggestReviewers(changeId, user2.username, 2); assertThat(reviewers).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name).isEqualTo(user2.fullName); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfigs({ @com.google.gerrit.acceptance.GerritConfig(name = "suggest.from", value = "1"), @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "NONE") }) public void suggestReviewersNoResult2() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("u"), 6); assertThat(reviewers).isEmpty(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2") public void suggestReviewersMaxNbrSuggestions() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("user"), 5); assertThat(reviewers).hasSize(2); }
private com.google.gerrit.acceptance.TestAccount user(java.lang.String name, java.lang.String fullName, com.google.gerrit.reviewdb.client.AccountGroup... groups) throws java.lang.Exception { return user(name, fullName, name, groups); }
static com.google.gerrit.acceptance.GerritServer.Description forTestClass(org.junit.runner.Description testDesc, java.lang.String configName) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description(configName, true, (!(com.google.gerrit.acceptance.GerritServer.Description.hasNoHttpd(testDesc.getTestClass()))), null, null); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "NONE") public void suggestReviewersNoResult1() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("u"), 6); assertThat(reviewers).isEmpty(); }
private com.google.gerrit.acceptance.TestAccount user(java.lang.String name, java.lang.String fullName, java.lang.String emailName, com.google.gerrit.reviewdb.client.AccountGroup... groups) throws java.lang.Exception { java.lang.String[] groupNames = com.google.common.collect.FluentIterable.from(java.util.Arrays.asList(groups)).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.AccountGroup, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.reviewdb.client.AccountGroup in) { return in.getName(); } }).toArray(java.lang.String.class); return accounts.create(name(name), ((name(emailName)) + "@example.com"), fullName, groupNames); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfigs({ @com.google.gerrit.acceptance.GerritConfig(name = "addreviewer.maxAllowed", value = "2"), @com.google.gerrit.acceptance.GerritConfig(name = "addreviewer.maxWithoutConfirmation", value = "1") }) public void suggestReviewersGroupSizeConsiderations() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup largeGroup = group("large"); com.google.gerrit.reviewdb.client.AccountGroup mediumGroup = group("medium"); user("individual 0", "Test0 Last0", largeGroup, mediumGroup); user("individual 1", "Test1 Last1", largeGroup); java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; com.google.gerrit.extensions.common.SuggestedReviewerInfo reviewer; reviewers = suggestReviewers(changeId, "test", 10); assertThat(reviewers).hasSize(2); reviewer = reviewers.get(0); assertThat(reviewer.count).isEqualTo(1); assertThat(reviewer.confirm).isNull(); reviewers = suggestReviewers(changeId, largeGroup.getName(), 10); assertThat(reviewers).isEmpty(); reviewers = suggestReviewers(changeId, mediumGroup.getName(), 10); assertThat(reviewers).hasSize(1); reviewer = reviewers.get(0); assertThat(reviewer.group.name).isEqualTo(mediumGroup.getName()); assertThat(reviewer.count).isEqualTo(2); assertThat(reviewer.confirm).isTrue(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "suggest.from", value = "2") public void suggestReviewersNoResult3() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, name("").substring(0, 1), 6); assertThat(reviewers).isEmpty(); }
static com.google.gerrit.acceptance.GerritServer.Description forTestMethod(org.junit.runner.Description testDesc, java.lang.String configName) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description(configName, ((testDesc.getAnnotation(com.google.gerrit.acceptance.UseLocalDisk.class)) == null), (((testDesc.getAnnotation(com.google.gerrit.acceptance.NoHttpd.class)) == null) && (!(com.google.gerrit.acceptance.GerritServer.Description.hasNoHttpd(testDesc.getTestClass())))), testDesc.getAnnotation(com.google.gerrit.acceptance.GerritConfig.class), testDesc.getAnnotation(com.google.gerrit.acceptance.GerritConfigs.class)); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "accounts.visibility", value = "SAME_GROUP") public void suggestReviewersViewAllAccounts() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; setApiUser(user1); reviewers = suggestReviewers(changeId, user2.username, 2); assertThat(reviewers).isEmpty(); setApiUser(user1); allowGlobalCapabilities(group1.getGroupUUID(), GlobalCapability.VIEW_ALL_ACCOUNTS); reviewers = suggestReviewers(changeId, user2.username, 2); assertThat(reviewers).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(reviewers).account.name).isEqualTo(user2.fullName); }

private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.replyTooltip = (com.google.common.base.Optional.fromNullable(cfg.getString("change", null, "replyTooltip")).or("Reply and score")) + " (Shortcut: a)"; info.replyLabel = (com.google.common.base.Optional.fromNullable(cfg.getString("change", null, "replyLabel")).or("Reply")) + "\u2026"; info.updateDelay = ((int) (com.google.gerrit.server.config.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.change.Submit.wholeTopicEnabled(cfg); return info; }

@java.lang.SuppressWarnings("deprecation") private com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> starredby(com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gerrit.server.query.QueryParseException { if (args.getSchema().hasField(ChangeField.STAR)) { return new com.google.gerrit.server.query.change.StarPredicate(who, com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL); } if (args.getSchema().hasField(ChangeField.STARREDBY)) { return new com.google.gerrit.server.query.change.IsStarredByPredicate(who); } try { return new com.google.gerrit.server.query.change.IsStarredByLegacyPredicate(who, args.starredChangesUtil.byAccount(who, StarredChangesUtil.DEFAULT_LABEL)); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.query.QueryParseException("Failed to query starred changes.", e); } }




public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.patch.PatchListKey.class, com.google.gerrit.server.patch.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.patch.IntraLineDiffKey.class, com.google.gerrit.server.patch.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.patch.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); } }; }
@java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.patch.PatchListKey.class, com.google.gerrit.server.patch.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.patch.IntraLineDiffKey.class, com.google.gerrit.server.patch.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.patch.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); }



public java.util.List<java.lang.String> filePaths(com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { java.lang.Integer psId = ps.getPatchSetId(); java.util.List<java.lang.String> r = initFiles().get(psId); if (r == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } com.google.common.base.Optional<com.google.gerrit.server.patch.PatchList> p = getPatchList(c, ps); if (!(p.isPresent())) { java.util.List<java.lang.String> emptyFileList = java.util.Collections.emptyList(); if (lazyLoad) { files.put(ps.getPatchSetId(), emptyFileList); } return emptyFileList; } r = new java.util.ArrayList(p.get().getPatches().size()); for (com.google.gerrit.server.patch.PatchListEntry e : p.get().getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : case REWRITE : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; } } java.util.Collections.sort(r); r = java.util.Collections.unmodifiableList(r); files.put(psId, r); } return r; }




private void readObject(java.io.ObjectInputStream input) throws java.io.IOException { java.io.ByteArrayInputStream buf = new java.io.ByteArrayInputStream(readBytes(input)); try (java.util.zip.InflaterInputStream in = new java.util.zip.InflaterInputStream(buf)) { java.util.List<java.lang.String> l = com.google.common.base.Splitter.on('\n').splitToList(readString(in)); paths = l.toArray(new java.lang.String[l.size()]); } }
static com.google.gerrit.server.patch.FileList toFileList(com.google.gerrit.server.patch.PatchList patchList) { java.util.List<java.lang.String> r = new java.util.ArrayList(patchList.getPatches().size()); for (com.google.gerrit.server.patch.PatchListEntry e : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : case REWRITE : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; } } java.util.Collections.sort(r); return new com.google.gerrit.server.patch.FileList(r.toArray(new java.lang.String[r.size()])); }
@java.lang.Override public int weigh(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.server.patch.FileList value) { int size = (16 + (4 * 8)) + (2 * 36); for (java.lang.String p : value.getPaths()) { size += p.length(); } size += (value.getPaths().size()) - 1; return size; }
private java.util.Collection<java.lang.String> reviewed(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.reviewdb.client.Account.Id userId = user.getAccountId(); java.util.Collection<java.lang.String> r = accountPatchReviewStore.get().findReviewed(resource.getPatchSet().getId(), userId); if ((r.isEmpty()) && (1 < (resource.getPatchSet().getPatchSetId()))) { for (com.google.gerrit.reviewdb.client.PatchSet ps : reversePatchSets(resource)) { java.util.Collection<java.lang.String> o = accountPatchReviewStore.get().findReviewed(ps.getId(), userId); if (!(o.isEmpty())) { try { r = copy(com.google.common.collect.Sets.newHashSet(o), ps.getId(), resource, userId); } catch (java.io.IOException | com.google.gerrit.server.patch.PatchListNotAvailableException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn("Cannot copy patch review flags", e); } break; } } } return r; }

@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.server.query.change.ChangeData> read() throws com.google.gwtorm.server.OrmException { if (java.lang.Thread.interrupted()) { java.lang.Thread.currentThread().interrupt(); throw new com.google.gwtorm.server.OrmException("interrupted"); } final java.util.Set<java.lang.String> fields = com.google.gerrit.lucene.LuceneChangeIndex.fields(schema, opts); return new com.google.gerrit.lucene.LuceneChangeIndex.ChangeDataResults(executor.submit(new java.util.concurrent.Callable<java.util.List<org.apache.lucene.document.Document>>() { @java.lang.Override public java.util.List<org.apache.lucene.document.Document> call() throws java.io.IOException { return doRead(fields); } @java.lang.Override public java.lang.String toString() { return predicate.toString(); } }), fields); }
public void run() throws java.io.IOException { ui.header("Index"); com.google.gerrit.server.index.IndexModule.IndexType type = index.select("Type", "type", IndexType.LUCENE); if (type == (com.google.gerrit.server.index.IndexModule.IndexType.SOLR)) { index.string("Solr Index URL", "url", "localhost:9983"); } if ((site.isNew) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { com.google.gerrit.lucene.LuceneChangeIndex.setReady(site, com.google.gerrit.server.index.ChangeSchemas.getLatest().getVersion(), true); } else { final java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), (site.isNew ? "" : "re")); ui.message(message); initFlags.autoStart = false; } }
private com.google.inject.AbstractModule createIndexModule() { com.google.gerrit.server.index.IndexModule.IndexType indexType = com.google.gerrit.server.index.IndexModule.getIndexType(cfgInjector); switch (indexType) { case LUCENE : return (luceneModule) != null ? luceneModule : new com.google.gerrit.lucene.LuceneIndexModule(); case SOLR : return new com.google.gerrit.solr.SolrIndexModule(); default : throw new java.lang.IllegalStateException(("unsupported index.type = " + indexType)); } }








private void parseNotes() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectReader reader = walk.getObjectReader(); com.google.gerrit.server.notedb.ChangeNotesCommit tipCommit = walk.parseCommit(tip); revisionNoteMap = com.google.gerrit.server.notedb.RevisionNoteMap.parse(noteUtil, id, reader, org.eclipse.jgit.notes.NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED); java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNote> rns = revisionNoteMap.revisionNotes; for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNote> e : rns.entrySet()) { for (com.google.gerrit.reviewdb.client.Comment c : e.getValue().comments) { comments.put(e.getKey(), c); } } for (com.google.gerrit.reviewdb.client.PatchSet ps : patchSets.values()) { com.google.gerrit.server.notedb.RevisionNote rn = rns.get(ps.getRevision()); if ((rn != null) && ((rn.pushCert) != null)) { ps.setPushCertificate(rn.pushCert); } } }
@java.lang.Override protected void onLoad(com.google.gerrit.server.notedb.LoadHandle handle) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId rev = handle.id(); if (rev == null) { loadDefaults(); return; } org.eclipse.jgit.revwalk.RevCommit tipCommit = handle.walk().parseCommit(rev); org.eclipse.jgit.lib.ObjectReader reader = handle.walk().getObjectReader(); revisionNoteMap = com.google.gerrit.server.notedb.RevisionNoteMap.parse(args.noteUtil, getChangeId(), reader, org.eclipse.jgit.notes.NoteMap.read(reader, tipCommit), PatchLineComment.Status.DRAFT); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.reviewdb.client.Comment> cs = com.google.common.collect.ArrayListMultimap.create(); for (com.google.gerrit.server.notedb.RevisionNote rn : revisionNoteMap.revisionNotes.values()) { for (com.google.gerrit.reviewdb.client.Comment c : rn.comments) { cs.put(new com.google.gerrit.reviewdb.client.RevId(c.revId), c); } } comments = com.google.common.collect.ImmutableListMultimap.copyOf(cs); }
private com.google.gerrit.server.notedb.RevisionNoteData parseJson(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, int offset) throws java.io.IOException { com.google.gerrit.server.notedb.RevisionNoteData data; try (java.io.InputStream is = new java.io.ByteArrayInputStream(raw, offset, ((raw.length) - offset));java.io.Reader r = new java.io.InputStreamReader(is)) { data = noteUtil.getGson().fromJson(r, com.google.gerrit.server.notedb.RevisionNoteData.class); } return data; }
static com.google.gerrit.server.notedb.RevisionNoteMap parse(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, com.google.gerrit.reviewdb.client.Change.Id changeId, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.reviewdb.client.PatchLineComment.Status status) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNote> result = new java.util.HashMap<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.server.notedb.RevisionNote rn = new com.google.gerrit.server.notedb.RevisionNote(noteUtil, changeId, reader, note.getData(), status); result.put(new com.google.gerrit.reviewdb.client.RevId(note.name()), rn); } return new com.google.gerrit.server.notedb.RevisionNoteMap(noteMap, com.google.common.collect.ImmutableMap.copyOf(result)); }




public void putComment(com.google.gerrit.reviewdb.client.PatchLineComment.Status status, com.google.gerrit.reviewdb.client.Comment c) { verifyComment(c); createDraftUpdateIfNull(); if (status == (PatchLineComment.Status.DRAFT)) { draftUpdate.putComment(c); } else { comments.add(c); draftUpdate.deleteComment(c); } }
private static boolean isJson(byte[] raw, int offset) { return ((raw[offset]) == '{') || ((raw[offset]) == '['); }

public java.util.List<com.google.gerrit.extensions.common.CommentInfo> getComments(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().setFillAccounts(includeAuthorInfo()).formatAsList(listComments(rsrc)); }



private void checkComments(java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNote> existingNotes, java.util.Map<com.google.gerrit.reviewdb.client.RevId, com.google.gerrit.server.notedb.RevisionNoteBuilder> toUpdate) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Comment.Key> existing = new java.util.HashSet<>(); for (com.google.gerrit.server.notedb.RevisionNote rn : existingNotes.values()) { for (com.google.gerrit.reviewdb.client.Comment c : rn.comments) { existing.add(c.key); if ((draftUpdate) != null) { draftUpdate.deleteComment(c.revId, c.key); } } } for (com.google.gerrit.server.notedb.RevisionNoteBuilder b : toUpdate.values()) { for (com.google.gerrit.reviewdb.client.Comment c : b.put.values()) { if (existing.contains(c.key)) { throw new com.google.gwtorm.server.OrmException(("Cannot update existing published comment: " + c)); } } } }
private void loadConfigInfo(final com.google.gerrit.client.info.ChangeInfo info, java.lang.String base) { final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.info.ChangeInfo.RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); java.sql.Timestamp lastReply = com.google.gerrit.client.change.ChangeScreen.myLastReply(info); if (rev.isEdit()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo p = com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParentRevision(info.revisions().values()); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(p, group); loadFileList(b, rev, lastReply, group, comments, null); } else { loadDiff(b, rev, lastReply, group); } group.addListener(new com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { loadConfigInfo(info, rev); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { com.google.gerrit.client.change.ChangeScreen.logger.log(java.util.logging.Level.SEVERE, ("Loading file list and inline comments failed: " + (caught.getMessage()))); loadConfigInfo(info, rev); } }); group.done(); }
@java.lang.Override public void onSuccess(final com.google.gerrit.client.info.ChangeInfo info) { info.init(); addExtensionPoints(info, initCurrentRevision(info)); final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { if (((base) == null) && ((rev.commit().parents().length()) > 1)) { base = com.google.gerrit.client.Gerrit.getUserPreferences().defaultBaseForMerges().getBase(); } loadConfigInfo(info, base); } }); group.done(); }
@java.lang.Override public void onSuccess(java.lang.Void result) { if (((base) == null) && ((rev.commit().parents().length()) > 1)) { base = com.google.gerrit.client.Gerrit.getUserPreferences().defaultBaseForMerges().getBase(); } loadConfigInfo(info, base); }
private static java.lang.String toPatch(java.lang.String type, com.google.gerrit.reviewdb.client.PatchSet.Id diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(); p.append("/c/").append(c).append("/"); if (diffBase != null) { p.append(diffBase.get()).append(".."); } p.append(revision.getId()).append("/").append(com.google.gwtorm.client.KeyUtil.encode(fileName)); if (((type != null) && (!(type.isEmpty()))) && ((!("sidebyside".equals(type))) || (com.google.gerrit.client.Dispatcher.preferUnified()))) { p.append(",").append(type); } if ((side == (com.google.gerrit.client.diff.DisplaySide.A)) && (line > 0)) { p.append("@a").append(line); } else if (line > 0) { p.append("@").append(line); } return p.toString(); }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(baseId, id.getParentKey(), id.get(), side, line)); }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(baseId, id.getParentKey(), id.get(), side, line)); }
private static void codemirror(final java.lang.String token, final com.google.gerrit.reviewdb.client.PatchSet.Id baseId, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(baseId, id.getParentKey(), id.get(), side, line)); } }); }

@java.lang.Override public java.lang.String toString() { if ((psId) != null) { return psId.getId(); } return null; }

private void loadConfigInfo(final com.google.gerrit.client.info.ChangeInfo info, com.google.gerrit.client.DiffObject base) { final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); if ((base.isAutoMerge()) && (!(initCurrentRevision(info).isMerge()))) { com.google.gerrit.client.Gerrit.display(getToken(), new com.google.gerrit.client.NotFoundScreen()); } com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev = resolveRevisionOrPatchSetId(info, base.toString(), null); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); java.sql.Timestamp lastReply = com.google.gerrit.client.change.ChangeScreen.myLastReply(info); if (rev.isEdit()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo p = com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParentRevision(info.revisions().values()); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(p, group); loadFileList(base, baseRev, rev, lastReply, group, comments, null); } else { loadDiff(base, baseRev, rev, lastReply, group); } group.addListener(new com.google.gwt.user.client.rpc.AsyncCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { loadConfigInfo(info, rev); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { com.google.gerrit.client.change.ChangeScreen.logger.log(java.util.logging.Level.SEVERE, ("Loading file list and inline comments failed: " + (caught.getMessage()))); loadConfigInfo(info, rev); } }); group.done(); }
private java.lang.Runnable upToChange(final boolean openReplyBox) { return new java.lang.Runnable() { @java.lang.Override public void run() { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); getCommentManager().saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? java.lang.String.valueOf(base.get()) : null; java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen(changeId, b, rev, openReplyBox, FileTable.Mode.REVIEW)); } }); } }; }
@java.lang.Override public void run() { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); getCommentManager().saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? java.lang.String.valueOf(base.get()) : null; java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen(changeId, b, rev, openReplyBox, FileTable.Mode.REVIEW)); } }); }
private static void patch(java.lang.String token, com.google.gerrit.reviewdb.client.PatchSet.Id baseId, com.google.gerrit.reviewdb.client.Patch.Key id, com.google.gerrit.client.diff.DisplaySide side, int line, java.lang.String panelType) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = (0 <= c) ? token.substring((c + 1)) : ""; } if (("".equals(panel)) || ("cm".equals(panel))) { if (com.google.gerrit.client.Dispatcher.preferUnified()) { com.google.gerrit.client.Dispatcher.unified(token, baseId, id, side, line); } else { com.google.gerrit.client.Dispatcher.codemirror(token, baseId, id, side, line); } } else if ("sidebyside".equals(panel)) { com.google.gerrit.client.Dispatcher.codemirror(token, baseId, id, side, line); } else if ("unified".equals(panel)) { com.google.gerrit.client.Dispatcher.unified(token, baseId, id, side, line); } else if ("edit".equals(panel)) { com.google.gerrit.client.Dispatcher.codemirrorForEdit(token, id, line); } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } }
@java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String b = ((base) != null) ? java.lang.String.valueOf(base.get()) : null; java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeId, b, rev), new com.google.gerrit.client.change.ChangeScreen(changeId, b, rev, openReplyBox, FileTable.Mode.REVIEW)); }
private static java.lang.String toPatch(java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(); p.append("/c/").append(c).append("/"); if ((diffBase != null) && (!(diffBase.isBaseOrAutoMerge()))) { p.append(diffBase.toString()).append(".."); } p.append(revision.getId()).append("/").append(com.google.gwtorm.client.KeyUtil.encode(fileName)); if (((type != null) && (!(type.isEmpty()))) && ((!("sidebyside".equals(type))) || (com.google.gerrit.client.Dispatcher.preferUnified()))) { p.append(",").append(type); } if ((side == (com.google.gerrit.client.diff.DisplaySide.A)) && (line > 0)) { p.append("@a").append(line); } else if (line > 0) { p.append("@").append(line); } return p.toString(); }
private static void unified(final java.lang.String token, final com.google.gerrit.reviewdb.client.PatchSet.Id baseId, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(baseId, id.getParentKey(), id.get(), side, line)); } }); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.Set<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.extensions.restapi.Response.ok(java.util.Collections.emptySet()); } com.google.gerrit.server.account.AccountInfoCacheFactory accountInfoFactory = accountInfos.create(); return com.google.gerrit.extensions.restapi.Response.ok(pastAssignees.stream().map(accountInfoFactory::get).map(AccountJson::toAccountInfo).collect(java.util.stream.Collectors.toSet())); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AssigneeInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.SetAssigneeOp op = assigneeFactory.create(input); bu.addOp(rsrc.getId(), op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(com.google.gerrit.server.account.AccountJson.toAccountInfo(op.getNewAssignee())); } }

private static void formatLink(com.google.gerrit.client.info.ChangeInfo.GitPerson person, com.google.gwt.user.client.ui.FlowPanel p, com.google.gerrit.client.ui.InlineHyperlink name, com.google.gwt.dom.client.Element date, com.google.gerrit.client.info.ChangeInfo change) { if (change.owner().hasAvatarInfo()) { com.google.gerrit.client.AvatarImage avatar; if (change.owner().email().equals(person.email())) { avatar = new com.google.gerrit.client.AvatarImage(change.owner()); } else { avatar = new com.google.gerrit.client.AvatarImage(com.google.gerrit.client.info.AccountInfo.create(0, person.name(), person.email(), null)); } p.insert(avatar, 0); } name.setText(com.google.gerrit.client.change.CommitBox.renderName(person)); name.setTargetHistoryToken(com.google.gerrit.common.PageLinks.toAccountQuery(com.google.gerrit.client.change.CommitBox.owner(person), change.status())); date.setInnerText(com.google.gerrit.client.FormatUtil.mediumFormat(person.date())); }
@org.junit.Test public void generatesExpectedMessage() throws java.lang.Exception { mockEvent.change = mockChange; mockEvent.uploader = mockAccount; mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockChange.commitMessage = "This is a title\nAnd a the body."; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = "{\"text\": \"Unit Tester proposed\\n>>>" + ("testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"); java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
@org.junit.Test public void generatesExpectedMessage() throws java.lang.Exception { mockEvent.change = mockChange; mockEvent.submitter = mockAccount; mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockChange.commitMessage = "This is a title\nAnd a the body."; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = "{\"text\": \"Unit Tester merged\\n>>>" + ("testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"); java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
@org.junit.Test public void doesNotPublishWhenExpected() throws java.lang.Exception { mockEvent.change = mockChange; mockChange.commitMessage = "WIP-This is a title\nAnd a the body."; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesNotPublishWhenExpected() throws java.lang.Exception { mockEvent.change = mockChange; mockChange.commitMessage = "WIP:This is a title\nAnd a the body."; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void generatesExpectedMessage() throws java.lang.Exception { mockEvent.change = mockChange; mockEvent.author = mockAccount; mockEvent.comment = "This is the first line\nAnd the second line."; mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + (("testproject (master): This is the first line\n" + "And the second line. (https://change/)\",") + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"); java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
@org.junit.Test public void generatesExpectedMessageForLongComment() throws java.lang.Exception { mockEvent.change = mockChange; mockEvent.author = mockAccount; mockEvent.comment = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + (("Integer tristique ligula nec dapibus lobortis. Nulla venenatis, lacus quis vulputate volutpat, " + "sem neque ornare eros, vel sodales magna risus et diam. Maecenas ultricies justo dictum orci ") + "scelerisque consequat a vel purus."); mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = ((("{\"text\": \"Unit Tester commented\\n>>>" + "testproject (master): ") + (mockEvent.comment.substring(0, 197))) + "... (https://change/)\",") + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"; java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
private void editAssignee(final java.lang.String assignee) { if (currentAssignee.equals(assignee)) { return; } if (assignee.isEmpty()) { com.google.gerrit.client.changes.ChangeApi.deleteAssignee(changeId.get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); currentAssignee = ""; assigneeLink.setText(""); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } else { com.google.gerrit.client.changes.ChangeApi.setAssignee(changeId.get(), assignee, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); currentAssignee = result.name(); assigneeLink.setText(result.name()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } }

void set(com.google.gerrit.client.info.ChangeInfo info) { this.changeId = info.legacyId(); this.currentAssignee = ((info.assignee()) != null) ? info.assignee().name() : ""; assigneeLink.setText(currentAssignee); assigneeSuggestOracle.setChange(changeId); editAssigneeIcon.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); }

private java.lang.StringBuilder format() { java.lang.StringBuilder s = new java.lang.StringBuilder().append("\r").append(taskName).append(':'); if (!(tasks.isEmpty())) { boolean first = true; for (com.google.gerrit.server.git.MultiProgressMonitor.Task t : tasks) { int count = t.count; if (count == 0) { continue; } if (!first) { s.append(','); } else { first = false; } s.append(' '); if (!(com.google.common.base.Strings.isNullOrEmpty(t.name))) { s.append(t.name).append(": "); } if ((t.total) == (com.google.gerrit.server.git.MultiProgressMonitor.UNKNOWN)) { s.append(count); } else { s.append(java.lang.String.format("%d%% (%d/%d)", ((count * 100) / (t.total)), count, t.total)); } } } if ((spinnerState) != (com.google.gerrit.server.git.MultiProgressMonitor.NO_SPINNER)) { s.append(" (").append(spinnerState).append(')'); } return s; }
@java.lang.Override public void run() { try { java.nio.file.Files.walkFileTree(gitDir, new com.googlesource.gerrit.plugins.deleteproject.fs.DeleteTrashFolders.TrashFolderRemover()); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.deleteproject.fs.DeleteTrashFolders.log.warn("Exception occured while trying to delete trash folders", e); } }
@java.lang.Override public void start() { new java.lang.Thread(new java.lang.Runnable() { @java.lang.Override public void run() { try { java.nio.file.Files.walkFileTree(gitDir, new com.googlesource.gerrit.plugins.deleteproject.fs.DeleteTrashFolders.TrashFolderRemover()); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.deleteproject.fs.DeleteTrashFolders.log.warn("Exception occured while trying to delete trash folders", e); } } }, "DeleteTrashFolders").start(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.common.base.Strings.isNullOrEmpty(format)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("format is not specified"); } com.google.gerrit.server.change.ArchiveFormat f = allowedFormats.extensions.get(("." + (format))); if (f == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unknown archive format"); } com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(change.getStatus().isOpen())) { throw new com.google.gerrit.extensions.restapi.PreconditionFailedException(("change is " + (com.google.gerrit.server.change.Submit.status(change)))); } com.google.gerrit.server.project.ChangeControl control = rsrc.getControl(); if (!(control.getUser().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Anonymous users cannot submit"); } try (com.google.gerrit.extensions.restapi.BinaryResult b = getBundles(rsrc, f)) { b.disableGzip().setContentType(f.getMimeType()).setAttachmentName(((("submit-preview-" + (change.getChangeId())) + ".") + (format))); return b; } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Error generating submit preview"); } }

@java.lang.Override public int run() throws java.lang.Exception { final com.google.gerrit.pgm.init.BaseInit.SiteInit init = createSiteInit(); if (beforeInit(init)) { return 0; } init.flags.autoStart = (getAutoStart()) && (init.site.isNew); init.flags.dev = (isDev()) && (init.site.isNew); init.flags.skipPlugins = skipPlugins(); final com.google.gerrit.pgm.init.BaseInit.SiteRun run; try { init.initializer.run(); init.flags.deleteOnFailure = false; run = createSiteRun(init); run.upgradeSchema(); init.initializer.postRun(createSysInjector(init)); } catch (java.lang.Exception | java.lang.Error failure) { if (init.flags.deleteOnFailure) { com.google.gerrit.pgm.init.BaseInit.recursiveDelete(getSitePath()); } throw failure; } java.lang.System.err.println(("Initialized " + (getSitePath().toRealPath().normalize()))); afterInit(run); return 0; }

@java.lang.Override public void run() { ui.header("Cache"); java.lang.String path = cache.get("directory"); if ((path != null) && (path.isEmpty())) { return; } if (path == null) { path = "cache"; cache.set("directory", path); } java.nio.file.Path loc = site.resolve(path); com.google.gerrit.common.FileUtil.mkdirsOrDie(loc, "cannot create cache.directory"); java.util.List<java.nio.file.Path> cacheFiles = new java.util.ArrayList<>(); try (java.nio.file.DirectoryStream<java.nio.file.Path> stream = java.nio.file.Files.newDirectoryStream(loc, "*.{lock,h2,trace}.db")) { for (java.nio.file.Path entry : stream) { cacheFiles.add(entry); } } catch (java.io.IOException e) { ui.message("IO error during cache directory scan"); return; } if (!(cacheFiles.isEmpty())) { for (java.nio.file.Path entry : cacheFiles) { if (ui.yesno(false, "Delete cache file %s", entry)) { try { java.nio.file.Files.deleteIfExists(entry); } catch (java.io.IOException e) { ui.message(("Could not delete " + entry)); } } } } }
@java.lang.Override public void run() { java.lang.String path = cache.get("directory"); if ((path != null) && (path.isEmpty())) { return; } if (path == null) { path = "cache"; cache.set("directory", path); } java.nio.file.Path loc = site.resolve(path); com.google.gerrit.common.FileUtil.mkdirsOrDie(loc, "cannot create cache.directory"); }
private void renderInput(org.asciidoctor.Options options, java.io.File inputFile) { org.asciidoctor.Asciidoctor asciidoctor = org.asciidoctor.internal.JRubyAsciidoctor.create(); asciidoctor.renderFile(inputFile, options); }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "asciidoctor: FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } try (java.util.zip.ZipOutputStream zip = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream(zipFile))) { for (java.lang.String inputFile : inputFiles) { if (!(inputFile.endsWith(inExt))) { continue; } java.lang.String outName = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt); java.io.File out = new java.io.File(tmpdir, outName); out.getParentFile().mkdirs(); org.asciidoctor.Options options = createOptions(out); renderInput(options, new java.io.File(inputFile)); AsciiDoctor.zipFile(out, outName, zip); } java.io.File[] cssFiles = tmpdir.listFiles(new java.io.FilenameFilter() { @java.lang.Override public boolean accept(java.io.File dir, java.lang.String name) { return name.endsWith(".css"); } }); for (java.io.File css : cssFiles) { AsciiDoctor.zipFile(css, css.getName(), zip); } } }
private org.asciidoctor.Options createOptions(java.io.File outputFile) { org.asciidoctor.OptionsBuilder optionsBuilder = org.asciidoctor.OptionsBuilder.options(); optionsBuilder.backend(backend).docType(AsciiDoctor.DOCTYPE).eruby(AsciiDoctor.ERUBY).safe(SafeMode.UNSAFE).baseDir(basedir); optionsBuilder.toFile(outputFile); org.asciidoctor.AttributesBuilder attributesBuilder = org.asciidoctor.AttributesBuilder.attributes(); attributesBuilder.attributes(getAttributes()); optionsBuilder.attributes(attributesBuilder.get()); return optionsBuilder.get(); }

public void fire(com.google.gerrit.extensions.common.ChangeInfo change, com.google.gerrit.extensions.common.RevisionInfo revision, java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ApprovalInfo> approvals, java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ApprovalInfo> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.extensions.common.AccountInfo remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(change, revision, approvals, oldApprovals, notify, message, remover, when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(com.google.gerrit.server.extensions.events.VoteDeleted.log, e); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(result.name()); }
private void editAssignee(final java.lang.String assignee) { if (assignee.isEmpty()) { com.google.gerrit.client.changes.ChangeApi.deleteAssignee(changeId.get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(""); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } else { com.google.gerrit.client.changes.ChangeApi.setAssignee(changeId.get(), assignee, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(result.name()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } }

private void editAssignee(final java.lang.String assignee) { if (assignee.isEmpty()) { com.google.gerrit.client.changes.ChangeApi.deleteAssignee(changeId.get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(""); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } else { com.google.gerrit.client.changes.ChangeApi.setAssignee(changeId.get(), assignee, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.AccountInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(result.name()); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (isSigninFailure(err)) { new com.google.gerrit.client.NotSignedInDialog().center(); } else { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); } } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.AccountInfo result) { onCloseForm(); assigneeLink.setText(result.name()); }
@java.lang.Override public java.lang.String toString() { return new java.lang.StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(java.util.Objects.toString(message, "")).append(',').append("parentUuid=").append(java.util.Objects.toString(parentUuid, "")).append(',').append("range=").append(java.util.Objects.toString(range, "")).append(',').append("revId=").append(((revId) != null ? revId : "")).append(',').append("tag=").append(java.util.Objects.toString(tag, "")).append(',').append("url=").append(url).append('}').toString(); }
private void assertRobotComment(com.google.gerrit.extensions.common.RobotCommentInfo c, com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput expected, boolean expectPath) { assertThat(c.robotId).isEqualTo(expected.robotId); assertThat(c.robotRunId).isEqualTo(expected.robotRunId); assertThat(c.url).isEqualTo(expected.url); assertThat(c.line).isEqualTo(expected.line); assertThat(c.message).isEqualTo(expected.message); assertThat(c.author.email).isEqualTo(admin.email); if (expectPath) { assertThat(c.path).isEqualTo(expected.path); } else { assertThat(c.path).isNull(); } }
private com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Restored"); if (!(com.google.common.base.Strings.nullToEmpty(input.message).trim().isEmpty())) { msg.append("\n\n"); msg.append(input.message.trim()); } com.google.gerrit.reviewdb.client.ChangeMessage message = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), change.currentPatchSetId()); message.setMessage(msg.toString()); return message; }
private void sendReplacePatchSet(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gerrit.common.errors.EmailException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account.Id accountId = ctx.getAccountId(); com.google.gerrit.reviewdb.client.ChangeMessage msg = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(change.getId(), com.google.gerrit.server.ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId); msg.setMessage((("Uploaded patch set " + (psId.get())) + ".")); com.google.gerrit.server.mail.ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId()); cm.setFrom(accountId); cm.setPatchSet(patchSet, patchSetInfo); cm.setChangeMessage(msg.getMessage(), ctx.getWhen()); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); }
private boolean insertMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.String msg = com.google.common.base.Strings.nullToEmpty(in.message).trim(); java.lang.StringBuilder buf = new java.lang.StringBuilder(); for (java.lang.String d : labelDelta) { buf.append(" ").append(d); } if ((comments.size()) == 1) { buf.append("\n\n(1 comment)"); } else if ((comments.size()) > 1) { buf.append(java.lang.String.format("\n\n(%d comments)", comments.size())); } if (!(msg.isEmpty())) { buf.append("\n\n").append(msg); } if ((buf.length()) == 0) { return false; } message = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(psId.getParentKey(), com.google.gerrit.server.ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId); message.setTag(in.tag); message.setMessage(java.lang.String.format("Patch Set %d:%s", psId.get(), buf.toString())); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message); return true; }
public Account.Id getAccountId() { checkState(((accountId) != null), "author identity for %s is not from an IdentifiedUser: %s", getClass().getSimpleName(), authorIdent.toExternalString()); return accountId; }
protected void checkUpdate(com.google.gerrit.server.notedb.AbstractChangeUpdate update) { checkState(java.util.Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId); checkState((((when.getTime()) - (update.getWhen().getTime())) <= (com.google.gerrit.server.notedb.rebuild.ChangeRebuilderImpl.MAX_WINDOW_MS)), "event at %s outside update window starting at %s", when, update.getWhen()); checkState(java.util.Objects.equals(update.getNullableAccountId(), who), "cannot apply event by %s to update by %s", who, update.getNullableAccountId()); }

public static com.google.gerrit.reviewdb.client.PatchSetApproval newApproval(com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.server.CurrentUser user, com.google.gerrit.reviewdb.client.LabelId labelId, int value, java.util.Date when) { com.google.gerrit.reviewdb.client.PatchSetApproval psa = new com.google.gerrit.reviewdb.client.PatchSetApproval(new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(psId, user.getAccountId(), labelId), com.google.common.primitives.Shorts.checkedCast(value), when); return psa; }
Account.Id getAccountId() { com.google.gerrit.reviewdb.client.Account.Id id = get(0).who; for (int i = 1; i < (size()); i++) { checkState(java.util.Objects.equals(id, get(i).who), "mismatched users in EventList: %s != %s", id, get(i).who); } return id; }
@java.lang.Override public java.lang.String toString() { return com.google.common.base.MoreObjects.toStringHelper(this).add("psId", psId).add("who", who).add("when", when).toString(); }
private void checkExpectedState() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(checkExpectedState)) { return; } for (java.util.Collection<com.google.gerrit.server.notedb.ChangeUpdate> us : changeUpdates.asMap().values()) { com.google.gerrit.server.notedb.ChangeUpdate u = us.iterator().next(); com.google.gerrit.server.notedb.NoteDbChangeState expectedState = com.google.gerrit.server.notedb.NoteDbChangeState.parse(u.getChange()); if (expectedState == null) { continue; } if (!(expectedState.isChangeUpToDate(changeRepo.cmds.getRepoRefCache()))) { throw new com.google.gwtorm.server.OrmConcurrencyException(java.lang.String.format(("cannot apply NoteDb updates for change %s;" + " change meta ref does not match %s"), u.getId(), expectedState.getChangeMetaId().name())); } } for (java.util.Collection<com.google.gerrit.server.notedb.ChangeDraftUpdate> us : draftUpdates.asMap().values()) { com.google.gerrit.server.notedb.ChangeDraftUpdate u = us.iterator().next(); com.google.gerrit.server.notedb.NoteDbChangeState expectedState = com.google.gerrit.server.notedb.NoteDbChangeState.parse(u.getChange()); if (expectedState == null) { continue; } com.google.gerrit.reviewdb.client.Account.Id accountId = u.getAccountId(); if (!(expectedState.areDraftsUpToDate(allUsersRepo.cmds.getRepoRefCache(), accountId))) { throw new com.google.gwtorm.server.OrmConcurrencyException(java.lang.String.format(("cannot apply NoteDb updates for change %s;" + " draft ref for account %s does not match %s"), u.getId(), accountId, expectedState.getChangeMetaId().name())); } } }
public void putApproval(java.lang.String label, short value) { putApprovalFor(getAccountId(), label, value); }
private void sortAndFillEvents(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Change noteDbChange, java.util.List<com.google.gerrit.server.notedb.rebuild.Event> events, java.lang.Integer minPsNum) { new com.google.gerrit.server.notedb.rebuild.EventSorter(events).sort(); events.add(new com.google.gerrit.server.notedb.rebuild.FinalUpdatesEvent(change, noteDbChange)); com.google.gerrit.server.notedb.rebuild.Event first = events.get(0); if ((first instanceof com.google.gerrit.server.notedb.rebuild.PatchSetEvent) && (change.getOwner().equals(first.who))) { ((com.google.gerrit.server.notedb.rebuild.PatchSetEvent) (first)).createChange = true; } else { events.add(0, new com.google.gerrit.server.notedb.rebuild.CreateChangeEvent(change, minPsNum)); } int ps = firstNonNull(minPsNum, 1); for (int i = 0; i < (events.size()); i++) { com.google.gerrit.server.notedb.rebuild.Event e = events.get(i); if ((e.psId) == null) { e.psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), ps); } else { ps = java.lang.Math.max(ps, e.psId.get()); } if (i > 0) { com.google.gerrit.server.notedb.rebuild.Event p = events.get((i - 1)); if (e.when.before(p.when)) { e.when = p.when; } } } }
public void removeApproval(java.lang.String label) { removeApprovalFor(getAccountId(), label); }
@java.lang.Override protected java.lang.String getRefName() { return com.google.gerrit.reviewdb.client.RefNames.refsDraftComments(getId(), accountId); }
public void putRobotComment(com.google.gerrit.reviewdb.client.RobotComment c) { verifyComment(c); createRobotCommentUpdateIfNull(); robotCommentUpdate.putComment(c); }
public com.google.gerrit.reviewdb.client.PatchSet insert(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.PatchSet.Id psId, org.eclipse.jgit.lib.ObjectId commit, boolean draft, java.util.List<java.lang.String> groups, java.lang.String pushCertificate) throws com.google.gwtorm.server.OrmException, java.io.IOException { checkNotNull(groups, "groups may not be null"); ensurePatchSetMatches(psId, update); com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(psId); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(commit.name())); ps.setUploader(update.getAccountId()); ps.setCreatedOn(new java.sql.Timestamp(update.getWhen().getTime())); ps.setDraft(draft); ps.setGroups(groups); ps.setPushCertificate(pushCertificate); db.patchSets().insert(java.util.Collections.singleton(ps)); update.setCommit(rw, commit, pushCertificate); update.setGroups(groups); if (draft) { update.setPatchSetState(com.google.gerrit.server.DRAFT); } return ps; }
public void putComment(com.google.gerrit.reviewdb.client.PatchLineComment.Status status, com.google.gerrit.reviewdb.client.Comment c) { verifyComment(c); createDraftUpdateIfNull(); if (status == (PatchLineComment.Status.DRAFT)) { draftUpdate.putComment(c); } else { comments.add(c); draftUpdate.deleteComment(c); } }
@com.google.common.annotations.VisibleForTesting com.google.gerrit.server.notedb.RobotCommentUpdate createRobotCommentUpdateIfNull() { if ((robotCommentUpdate) == null) { com.google.gerrit.server.notedb.ChangeNotes notes = getNotes(); if (notes != null) { robotCommentUpdate = robotCommentUpdateFactory.create(notes, accountId, authorIdent, when); } else { robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), accountId, authorIdent, when); } } return robotCommentUpdate; }
public void deleteComment(com.google.gerrit.reviewdb.client.Comment c) { verifyComment(c); createDraftUpdateIfNull().deleteComment(c); }
public static com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.server.CurrentUser user, java.sql.Timestamp when, java.lang.String body) throws com.google.gwtorm.server.OrmException { checkNotNull(psId); com.google.gerrit.reviewdb.client.Account.Id accountId = (user.isInternalUser()) ? null : user.getAccountId(); com.google.gerrit.reviewdb.client.ChangeMessage m = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(psId.getParentKey(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), accountId, when, psId); m.setMessage(body); return m; }
boolean canAdd(E e) { if (isEmpty()) { return true; } if (e instanceof com.google.gerrit.server.notedb.rebuild.FinalUpdatesEvent) { return false; } com.google.gerrit.server.notedb.rebuild.Event last = getLast(); if (((!(java.util.Objects.equals(e.who, last.who))) || (!(e.psId.equals(last.psId)))) || (!(java.util.Objects.equals(e.tag, last.tag)))) { return false; } long t = e.when.getTime(); long tFirst = getFirstTime(); long tLast = getLastTime(); checkArgument((t >= tLast), "event %s is before previous event in list %s", e, last); if (((t - tLast) > (ChangeRebuilderImpl.MAX_DELTA_MS)) || ((t - tFirst) > (ChangeRebuilderImpl.MAX_WINDOW_MS))) { return false; } if (!(e.uniquePerUpdate())) { return true; } for (com.google.gerrit.server.notedb.rebuild.Event o : this) { if ((e.getClass()) == (o.getClass())) { return false; } } return true; }
@java.lang.Override public int compareTo(com.google.gerrit.server.notedb.rebuild.Event other) { return com.google.common.collect.ComparisonChain.start().compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.who, other.who, com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering().nullsLast()).result(); }
public Account.Id getNullableAccountId() { return accountId; }
@com.google.common.annotations.VisibleForTesting com.google.gerrit.server.notedb.ChangeDraftUpdate createDraftUpdateIfNull() { if ((draftUpdate) == null) { com.google.gerrit.server.notedb.ChangeNotes notes = getNotes(); if (notes != null) { draftUpdate = draftUpdateFactory.create(notes, accountId, authorIdent, when); } else { draftUpdate = draftUpdateFactory.create(getChange(), accountId, authorIdent, when); } } return draftUpdate; }





private void appendFileLine(java.lang.StringBuilder cmts, com.google.gerrit.server.patch.PatchFile fileData, short side, int line) { cmts.append(("Line " + line)); try { final java.lang.String lineStr = fileData.getLine(side, line); cmts.append(": "); cmts.append(lineStr); } catch (java.lang.Throwable e) { } cmts.append("\n"); }

public long getMaxObjectSize() { return cfg.getLong(com.googlesource.gerrit.plugins.lfs.LfsProjectConfigSection.LFS, namespace, com.googlesource.gerrit.plugins.lfs.LfsProjectConfigSection.KEY_MAX_OBJECT_SIZE, 0); }
public void logEventListenerError(org.slf4j.Logger log, java.lang.Exception error) { if (log.isDebugEnabled()) { log.debug("Error in event listener", error); } else { log.warn("Error in event listener: {}", error.getMessage()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AssigneeInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.SetAssigneeOp op = assigneeFactory.create(input); bu.addOp(rsrc.getId(), op); com.google.gerrit.server.change.PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee); bu.addOp(rsrc.getId(), reviewersAddition.op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(com.google.gerrit.server.account.AccountJson.toAccountInfo(op.getNewAssignee())); } }
private java.util.Set<org.eclipse.jgit.lib.ObjectId> advertiseOpenChanges() { int limit = 32; try { java.util.Set<org.eclipse.jgit.lib.ObjectId> r = com.google.common.collect.Sets.newHashSetWithExpectedSize(limit); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().enforceVisibility(true).setLimit(limit).byProjectOpen(projectName)) { com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { r.add(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())); } } return r; } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.git.ReceiveCommitsAdvertiseRefsHook.log.error(("Cannot list open changes of " + (projectName)), err); return java.util.Collections.emptySet(); } }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> oldRefs = rp.getAdvertisedRefs(); if (oldRefs == null) { try { oldRefs = rp.getRepository().getRefDatabase().getRefs(com.google.gerrit.server.git.ALL); } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { throw e; } catch (java.io.IOException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(); ex.initCause(e); throw ex; } } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> r = com.google.common.collect.Maps.newHashMapWithExpectedSize(oldRefs.size()); for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : oldRefs.entrySet()) { java.lang.String name = e.getKey(); if (!(com.google.gerrit.server.git.ReceiveCommitsAdvertiseRefsHook.skip(name))) { r.put(name, e.getValue()); } } rp.setAdvertisedRefs(r, advertiseOpenChanges()); }
public com.googlesource.gerrit.plugins.lfs.LfsBackend getBackend() { return cfg.getEnum("storage", null, "backend", LfsBackend.FS); }
@java.lang.Override public com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo info = new com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo(); com.googlesource.gerrit.plugins.lfs.LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig().getForProject(resource.getNameKey()); if (config != null) { info.enabled = config.isEnabled(); info.maxObjectSize = config.getMaxObjectSize(); } return info; }
private static java.nio.file.Path getOrCreateDataDir(com.googlesource.gerrit.plugins.lfs.LfsGlobalConfig config, java.nio.file.Path defaultDataDir) throws java.io.IOException { java.lang.String dataDir = config.getString(LfsBackend.FS.name(), null, "directory"); if (com.google.common.base.Strings.isNullOrEmpty(dataDir)) { return defaultDataDir; } java.nio.file.Path ensured = java.nio.file.Files.createDirectories(java.nio.file.Paths.get(dataDir)); if (!(java.nio.file.Files.isReadable(ensured))) { throw new java.io.IOException((("Path '" + (ensured.toAbsolutePath())) + "' cannot be accessed")); } return ensured; }


private static org.eclipse.jgit.lfs.server.s3.S3Config getS3Config(com.googlesource.gerrit.plugins.lfs.LfsGlobalConfig config) { java.lang.String section = LfsBackend.S3.name(); java.lang.String region = config.getString(section, null, "region"); java.lang.String bucket = config.getString(section, null, "bucket"); java.lang.String storageClass = com.google.common.base.MoreObjects.firstNonNull(config.getString(section, null, "storageClass"), "REDUCED_REDUNDANCY"); int expirationSeconds = config.getInt(section, null, "expirationSeconds", 60); boolean disableSslVerify = config.getBoolean(section, null, "disableSslVerify", false); java.lang.String accessKey = config.getString(section, null, "accessKey"); java.lang.String secretKey = config.getString(section, null, "secretKey"); return new org.eclipse.jgit.lfs.server.s3.S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify); }
private static java.lang.String getContentPath(java.lang.String url) { return (url + (url.endsWith("/") ? com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository.CONTENT_PATH : "/" + (com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository.CONTENT_PATH))) + "/"; }
@java.lang.Override protected void configureServlets() { switch (backend) { case FS : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository.class); serve((("/" + (CONTENT_PATH)) + "/*")).with(com.googlesource.gerrit.plugins.lfs.fs.LfsFsContentServlet.class); break; case S3 : serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.s3.LfsS3ApiServlet.class); bind(com.googlesource.gerrit.plugins.lfs.s3.S3LargeFileRepository.class); break; default : throw new java.lang.RuntimeException(("Unsupported backend: " + (backend))); } }

public com.googlesource.gerrit.plugins.lfs.LfsBackend getBackend() { return cfg.getEnum("storage", null, "backend", LfsBackend.FS); }



public org.eclipse.jgit.lfs.server.LargeFileRepository get(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String backendName) throws org.eclipse.jgit.lfs.errors.LfsRepositoryNotFound { com.googlesource.gerrit.plugins.lfs.LfsBackendConfig config = defaultBackend; if (!(com.google.common.base.Strings.isNullOrEmpty(backendName))) { config = backends.get(backendName); if (config == null) { throw new org.eclipse.jgit.lfs.errors.LfsRepositoryNotFound(project.get()); } } switch (config.type) { case FS : return fsRepoFactory.create(config); case S3 : return s3RepoFactory.create(config); default : throw new org.eclipse.jgit.lfs.errors.LfsRepositoryNotFound(project.get()); } }
@java.lang.Override protected void configureServlets() { serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.class); if (com.googlesource.gerrit.plugins.lfs.LfsBackend.FS.equals(defaultBackend.type)) { com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository defRepository = fsRepoFactory.create(defaultBackend); serve(defRepository.getServletRegexp()).with(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsContentServlet(defRepository)); } for (com.googlesource.gerrit.plugins.lfs.LfsBackendConfig backendCfg : backends.values()) { if (com.googlesource.gerrit.plugins.lfs.LfsBackend.FS.equals(backendCfg.type)) { com.googlesource.gerrit.plugins.lfs.fs.LocalLargeFileRepository repository = fsRepoFactory.create(backendCfg); serve(repository.getServletRegexp()).with(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsContentServlet(repository)); } } }
public static com.google.common.base.Optional<com.google.gitiles.FormatType> getFormatType(javax.servlet.http.HttpServletRequest req) { @java.lang.SuppressWarnings("unchecked") com.google.common.base.Optional<com.google.gitiles.FormatType> result = ((com.google.common.base.Optional<com.google.gitiles.FormatType>) (req.getAttribute(com.google.gitiles.FormatType.FORMAT_TYPE_ATTRIBUTE))); if (result != null) { return result; } java.lang.String fmt = req.getParameter("format"); if (!(com.google.common.base.Strings.isNullOrEmpty(fmt))) { return com.google.gitiles.FormatType.set(req, com.google.common.base.Enums.getIfPresent(com.google.gitiles.FormatType.class, fmt.toUpperCase())); } java.lang.String accept = req.getHeader(HttpHeaders.ACCEPT); if (com.google.common.base.Strings.isNullOrEmpty(accept)) { return com.google.gitiles.FormatType.set(req, com.google.common.base.Optional.of(com.google.gitiles.FormatType.DEFAULT)); } for (java.lang.String p : accept.split("[ ,;][ ,;]*")) { for (com.google.gitiles.FormatType type : com.google.gitiles.FormatType.values()) { if (p.equals(type.mimeType)) { return com.google.gitiles.FormatType.set(req, com.google.common.base.Optional.of((type != (com.google.gitiles.FormatType.HTML) ? type : com.google.gitiles.FormatType.DEFAULT))); } } } return com.google.gitiles.FormatType.set(req, com.google.common.base.Optional.of(com.google.gitiles.FormatType.DEFAULT)); }
public static com.google.gerrit.server.git.GroupList parse(java.lang.String text, com.google.gerrit.server.git.ValidationError.Sink errors) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.Row> rows = com.google.gerrit.server.git.GroupList.parse(text, com.google.gerrit.server.git.GroupList.FILE_NAME, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, errors); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.common.data.GroupReference> groupsByUUID = new java.util.HashMap(rows.size()); for (com.google.gerrit.server.git.Row row : rows) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(row.left); java.lang.String name = row.right; com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); } return new com.google.gerrit.server.git.GroupList(groupsByUUID); }
public com.google.gerrit.common.data.GroupReference resolve(com.google.gerrit.common.data.GroupReference group) { if (group != null) { com.google.gerrit.common.data.GroupReference ref = byUUID.get(group.getUUID()); if (ref != null) { return ref; } byUUID.put(group.getUUID(), group); } return group; }
@java.lang.Override public void connect() { if (isOpen()) { com.googlesource.gerrit.plugins.kafka.session.type.KafkaSession.LOGGER.debug("Already connected."); return; } com.googlesource.gerrit.plugins.kafka.session.type.KafkaSession.LOGGER.info("Connect to {}...", properties.getProperty("bootstrap.servers")); producer = new org.apache.kafka.clients.producer.KafkaProducer(properties); com.googlesource.gerrit.plugins.kafka.session.type.KafkaSession.LOGGER.info("Connection established."); }
private void fireChangeDeletedFromIndexEvent(int id) { for (com.google.gerrit.extensions.events.ChangeIndexedListener listener : indexedListener) { listener.onChangeDeleted(id); } }
private void fireChangeIndexedEvent(int id) { for (com.google.gerrit.extensions.events.ChangeIndexedListener listener : indexedListener) { listener.onChangeIndexed(id); } }

@java.lang.Override public void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws java.lang.Exception { changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), ctx.getRepository(), priorCommit, commit); if (checkMergedInto) { org.eclipse.jgit.lib.Ref mergedInto = findMergedInto(ctx, dest.get(), commit); if (mergedInto != null) { mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName()); } } }
private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try { logDebug("Executing updateRepo on {} ops", ops.size()); com.google.gerrit.server.git.BatchUpdate.RepoContext ctx = new com.google.gerrit.server.git.BatchUpdate.RepoContext(); for (com.google.gerrit.server.git.BatchUpdate.Op op : ops.values()) { op.updateRepo(ctx); } if (!(repoOnlyOps.isEmpty())) { logDebug("Executing updateRepo on {} RepoOnlyOps", ops.size()); for (com.google.gerrit.server.git.BatchUpdate.RepoOnlyOp op : repoOnlyOps) { op.updateRepo(ctx); } } if ((inserter) != null) { logDebug("Flushing inserter"); inserter.flush(); } else { logDebug("No objects to flush"); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.propagateIfPossible(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.git.UpdateException(e); } }


private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = new com.google.gerrit.server.project.SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate(); for (com.google.gerrit.common.data.SubmitRecord sr : records) { if ((sr.status) == (SubmitRecord.Status.OK)) { return true; } } return false; }
private void decodeReviewers(com.google.common.collect.Multimap<java.lang.String, org.apache.lucene.index.IndexableField> doc, com.google.gerrit.server.query.change.ChangeData cd) { cd.setReviewers(com.google.gerrit.server.index.change.ChangeField.parseReviewerFieldValues(com.google.common.collect.FluentIterable.from(doc.get(com.google.gerrit.lucene.LuceneChangeIndex.REVIEWER_FIELD)).transform(IndexableField::stringValue))); }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> out; try { out = query(); } catch (com.google.gerrit.server.query.QueryParseException e) { java.util.regex.Pattern p = java.util.regex.Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$"); java.util.regex.Matcher m = p.matcher(e.getMessage()); if (m.matches()) { java.lang.String op = m.group(1); throw new com.google.gerrit.extensions.restapi.AuthException(("Must be signed-in to use " + op)); } throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } return (out.size()) == 1 ? out.get(0) : out; }




public void remove(com.google.gerrit.extensions.auth.oauth.OAuthUserInfo user) { if (user != null) { cache.invalidate(user.getUserName()); } }
private void authenticateAndRedirect(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId()); com.google.gerrit.server.account.AuthResult arsp; try { java.lang.String claimedIdentifier = user.getClaimedIdentity(); if (!(com.google.common.base.Strings.isNullOrEmpty(claimedIdentifier))) { if (!(authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier))) { return; } } else if (linkMode) { if (!(authenticateWithLinkedIdentity(areq, rsp))) { return; } } areq.setUserName(user.getUserName()); areq.setEmailAddress(user.getEmailAddress()); areq.setDisplayName(user.getDisplayName()); arsp = accountManager.authenticate(areq); } catch (com.google.gerrit.server.account.AccountException e) { com.google.gerrit.httpd.auth.oauth.OAuthSession.log.error((("Unable to authenticate user \"" + (user)) + "\""), e); rsp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } webSession.get().login(arsp, true); java.lang.String suffix = redirectToken.substring(((OAuthWebFilter.GERRIT_LOGIN.length()) + 1)); java.lang.StringBuilder rdr = new java.lang.StringBuilder(urlProvider.get(req)); rdr.append(com.google.gerrit.extensions.restapi.Url.decode(suffix)); rsp.sendRedirect(rdr.toString()); }
void logout() { tokenCache.remove(user); user = null; redirectToken = null; serviceProvider = null; }
public com.google.gerrit.extensions.auth.oauth.OAuthToken get(com.google.gerrit.extensions.auth.oauth.OAuthUserInfo user) { return user != null ? get(user.getUserName()) : null; }
public void put(com.google.gerrit.extensions.auth.oauth.OAuthUserInfo user, com.google.gerrit.extensions.auth.oauth.OAuthToken accessToken) { cache.put(checkNotNull(user.getUserName()), encrypt(checkNotNull(accessToken))); }
@java.lang.Override public boolean allowsEdit(com.google.gerrit.reviewdb.client.Account.FieldName field) { return editableAccountFields.contains(field); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { checkState(((ctx.getOrder()) == (BatchUpdate.Order.DB_BEFORE_REPO)), "must use DeleteDraftChangeOp with DB_BEFORE_REPO"); checkState(((id) == null), "cannot reuse DeleteDraftChangeOp"); com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); id = change.getId(); com.google.gerrit.reviewdb.server.ReviewDb db = com.google.gerrit.server.change.DeleteDraftChangeOp.unwrap(ctx.getDb()); if ((change.getStatus()) != (Change.Status.DRAFT)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Change is not a draft: " + (id))); } if (!(allowDrafts)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Draft workflow is disabled"); } if (!(ctx.getControl().canDeleteDraft(ctx.getDb()))) { throw new com.google.gerrit.extensions.restapi.AuthException("Not permitted to delete this draft change"); } java.util.List<com.google.gerrit.reviewdb.client.PatchSet> patchSets = com.google.common.collect.ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes())); for (com.google.gerrit.reviewdb.client.PatchSet ps : patchSets) { if (!(ps.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((((("Cannot delete draft change " + (id)) + ": patch set ") + (ps.getPatchSetId())) + " is not a draft")); } accountPatchReviewStore.get().clearReviewed(ps.getId()); } db.patchComments().delete(db.patchComments().byChange(id)); db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id)); db.patchSets().delete(db.patchSets().byChange(id)); db.changeMessages().delete(db.changeMessages().byChange(id)); starredChangesUtil.unstarAll(change.getProject(), id); ctx.deleteChange(); return true; }


static java.util.Optional<com.google.gitiles.ArchiveFormat> byExtension(java.lang.String ext, org.eclipse.jgit.lib.Config cfg) { com.google.gitiles.ArchiveFormat format = com.google.gitiles.ArchiveFormat.BY_EXT.get(ext); if (format == null) { return java.util.Optional.empty(); } java.lang.String[] formats = cfg.getStringList("archive", null, "format"); if ((formats.length) == 0) { return java.util.Optional.of(format); } for (java.lang.String allowed : formats) { if (format.name().equals(allowed.toUpperCase())) { return java.util.Optional.of(format); } } return java.util.Optional.empty(); }
public static java.util.Optional<java.util.TimeZone> getTimeZone(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection, java.lang.String name) { java.lang.String id = config.getString(section, subsection, name); return id != null ? java.util.Optional.of(java.util.TimeZone.getTimeZone(id)) : java.util.Optional.empty(); }


private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.List<com.google.gerrit.server.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = json.create(options).lazyLoad(com.google.gerrit.server.query.change.QueryChanges.containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if (results.get(n).more()) { info.get(((info.size()) - 1))._moreChanges = true; } } return res; }
public java.util.List<com.google.gerrit.server.query.QueryResult<T>> query(java.util.List<com.google.gerrit.server.query.Predicate<T>> queries) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { try { return query(null, queries); } catch (com.google.gwtorm.server.OrmRuntimeException e) { throw new com.google.gwtorm.server.OrmException(e.getMessage(), e); } catch (com.google.gwtorm.server.OrmException e) { com.google.common.base.Throwables.propagateIfInstanceOf(e.getCause(), com.google.gerrit.server.query.QueryParseException.class); throw e; } }
private void acquire(int count) throws com.google.gwtorm.server.OrmException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectName);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.notedb.RepoSequence.TryAcquire attempt = new com.google.gerrit.server.notedb.RepoSequence.TryAcquire(repo, rw, count); checkResult(retryer.call(attempt)); counter = attempt.next; limit = (counter) + count; (acquireCount)++; } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { com.google.common.base.Throwables.propagateIfInstanceOf(e.getCause(), com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(e); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
@java.lang.Override public com.google.gwtorm.server.ResultSet<T> read() throws com.google.gwtorm.server.OrmException { try { return readImpl(); } catch (com.google.gwtorm.server.OrmRuntimeException err) { com.google.common.base.Throwables.propagateIfInstanceOf(err.getCause(), com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(err); } }


public boolean canDeleteDraft(final com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { return ((isOwner()) || (getRefControl().canDeleteDrafts())) && (isVisible(db)); }
@org.junit.Test public void delete() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange("refs/drafts/master"); assertThat(query(r.getChangeId())).hasSize(1); assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.DRAFT); gApi.changes().id(r.getChangeId()).delete(); assertThat(query(r.getChangeId())).isEmpty(); }



@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { checkState(((ctx.getOrder()) == (BatchUpdate.Order.DB_BEFORE_REPO)), "must use DeleteDraftChangeOp with DB_BEFORE_REPO"); checkState(((id) == null), "cannot reuse DeleteDraftChangeOp"); id = ctx.getChange().getId(); com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.PatchSet> patchSets = com.google.common.collect.ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes())); ensureDeletable(ctx, id, patchSets); deleteChangeElementsFromDb(ctx, id); cleanUpReferences(ctx, id, patchSets); ctx.deleteChange(); return true; }


private void ensureDeletable(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.reviewdb.client.Change.Id id, java.util.List<com.google.gerrit.reviewdb.client.PatchSet> patchSets) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { if ((ctx.getChange().getStatus()) != (Change.Status.DRAFT)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Change is not a draft: " + id)); } if (!(allowDrafts)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Draft workflow is disabled"); } if (!(ctx.getControl().canDeleteDraft(ctx.getDb()))) { throw new com.google.gerrit.extensions.restapi.AuthException("Not permitted to delete this draft change"); } for (com.google.gerrit.reviewdb.client.PatchSet ps : patchSets) { if (!(ps.isDraft())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((((("Cannot delete draft change " + id) + ": patch set ") + (ps.getPatchSetId())) + " is not a draft")); } } }



@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { try { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Delete").setTitle(("Delete draft change " + (rsrc.getId()))).setVisible((((allowDrafts) && ((rsrc.getChange().getStatus()) == (com.google.gerrit.reviewdb.client.Change.Status.DRAFT))) && (rsrc.getControl().canDeleteDraft(db.get())))); } catch (com.google.gwtorm.server.OrmException e) { throw new java.lang.IllegalStateException(e); } }
@org.junit.Test public void deleteChange() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result result = createChange(); result.assertOkStatus(); java.lang.String changeId = result.getChangeId(); java.lang.String triplet = ((project.get()) + "~master~") + changeId; com.google.gerrit.extensions.common.ChangeInfo c = get(triplet); assertThat(c.id).isEqualTo(triplet); assertThat(c.status).isEqualTo(ChangeStatus.NEW); com.google.gerrit.acceptance.RestResponse response = com.google.gerrit.acceptance.rest.change.DraftChangeIT.deleteChange(changeId, adminRestSession); assertThat(response.getEntityContent()).isEqualTo(("Change is not a draft: " + (c._number))); response.assertConflict(); }


private void processEvent(org.eclipse.jgit.lib.Repository repository, com.vmware.gerrit.owners.common.Event event) { if (event.getRefName().startsWith(com.vmware.gerrit.owners.common.GitRefListener.CHANGES_REF)) { com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.fromRef(event.getRefName()); try { com.google.gerrit.reviewdb.client.Change change = db.get().changes().get(id); com.google.gerrit.server.patch.PatchList patchList = getPatchList(event, change); if (patchList != null) { com.vmware.gerrit.owners.common.PathOwners owners = new com.vmware.gerrit.owners.common.PathOwners(accountResolver, repository, patchList); reviewerManager.addReviewers(change, owners.get().values()); } } catch (com.google.gwtorm.server.OrmException e) { com.vmware.gerrit.owners.common.GitRefListener.logger.warn("Could not open change: {}", id, e); } catch (com.vmware.gerrit.owners.common.ReviewerManagerException e) { com.vmware.gerrit.owners.common.GitRefListener.logger.warn("Could not add reviewers for change: {}", id, e); } } }
private com.google.gerrit.server.mail.ProjectWatch.Watchers getWatchersFromIndex(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.mail.ProjectWatch.Watchers matching = new com.google.gerrit.server.mail.ProjectWatch.Watchers(); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> projectWatchers = new java.util.HashSet<>(); for (com.google.gerrit.server.account.AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) { com.google.gerrit.reviewdb.client.Account.Id accountId = a.getAccount().getId(); for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> e : a.getProjectWatches().entrySet()) { if (add(matching, accountId, e.getKey(), e.getValue(), type)) { projectWatchers.add(accountId); } } } for (com.google.gerrit.server.account.AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) { for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> e : a.getProjectWatches().entrySet()) { com.google.gerrit.reviewdb.client.Account.Id accountId = a.getAccount().getId(); if (!(projectWatchers.contains(accountId))) { add(matching, accountId, e.getKey(), e.getValue(), type); } } } return matching; }


public void addReviewers(com.google.gerrit.reviewdb.client.Change change, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> reviewers) throws com.vmware.gerrit.owners.common.ReviewerManagerException { try { com.google.gerrit.extensions.api.changes.ChangeApi cApi = gApi.changes().id(change.getId().get()); for (com.google.gerrit.reviewdb.client.Account.Id account : reviewers) { cApi.addReviewer(account.toString()); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { com.vmware.gerrit.owners.common.ReviewerManager.log.error("Couldn't add reviewers to the change", e); throw new com.vmware.gerrit.owners.common.ReviewerManagerException(e); } }
@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class).to(com.vmware.gerrit.owners.common.GitRefListener.class); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { com.google.gerrit.server.IdentifiedUser user = receiveEvent.user; java.lang.String refname = receiveEvent.refName; org.eclipse.jgit.lib.ObjectId old = org.eclipse.jgit.lib.ObjectId.zeroId(); if ((receiveEvent.commit.getParentCount()) > 0) { old = receiveEvent.commit.getParent(0); } if (receiveEvent.command.getRefName().startsWith(com.googlesource.gerrit.plugins.hooks.REFS_CHANGES)) { refname = refname.replace(com.googlesource.gerrit.plugins.hooks.R_HEADS, "refs/for/refs/heads/"); old = org.eclipse.jgit.lib.ObjectId.zeroId(); } com.googlesource.gerrit.plugins.hooks.HookArgs args = hookFactory.createArgs(); args.add("--project", receiveEvent.project.getName()); args.add("--refname", refname); args.add("--uploader", user.getNameEmail()); args.add("--oldrev", old.name()); args.add("--newrev", receiveEvent.commit.name()); com.googlesource.gerrit.plugins.hooks.HookResult result = hook.run(args); if ((result != null) && ((result.getExitValue()) != 0)) { throw new com.google.gerrit.server.git.validators.CommitValidationException(result.toString().trim()); } return java.util.Collections.emptyList(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.Rebuild.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (!(migration.commitChangeWrites())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } try { rebuilder.rebuild(db.get(), rsrc.getId()); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.extensions.restapi.IdString.fromDecoded(rsrc.getId().toString())); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Branch.NameKey> branchesByProject() { com.google.common.collect.SetMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Branch.NameKey> ret = com.google.common.collect.HashMultimap.create(); for (com.google.gerrit.reviewdb.client.Branch.NameKey branch : targets.keySet()) { ret.put(branch.getParentKey(), branch); } return ret; }
@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); soyContext.put("changeId", change.getKey().get()); soyContext.put("coverLetter", getCoverLetter()); soyContext.put("fromName", getNameFor(fromId)); soyContextEmailData.put("unifiedDiff", getUnifiedDiff()); soyContextEmailData.put("changeDetail", getChangeDetail()); soyContextEmailData.put("changeUrl", getChangeUrl()); soyContextEmailData.put("includeDiff", getIncludeDiff()); java.util.Map<java.lang.String, java.lang.String> changeData = new java.util.HashMap<>(); changeData.put("subject", change.getSubject()); changeData.put("originalSubject", change.getOriginalSubject()); changeData.put("ownerEmail", getNameEmailFor(change.getOwner())); soyContext.put("change", changeData); java.lang.String subject = change.getSubject(); changeData.put("subject", subject); if ((subject.length()) < 64) { changeData.put("shortSubject", subject); } else { changeData.put("shortSubject", ((subject.substring(0, 60)) + "...")); } java.util.Map<java.lang.String, java.lang.Object> patchSetData = new java.util.HashMap<>(); patchSetData.put("patchSetId", patchSet.getPatchSetId()); patchSetData.put("refName", patchSet.getRefName()); soyContext.put("patchSet", patchSetData); }

@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException, java.io.IOException { change = ctx.getChange(); com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); com.google.gerrit.server.project.ChangeControl ctl = ctx.getControl(); patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId); ctx.getChange().setCurrentPatchSet(patchSetInfo); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(psId); update.setChangeId(change.getKey().get()); update.setSubjectForCommit("Create change"); update.setBranch(change.getDest().get()); update.setTopic(change.getTopic()); boolean draft = (status) == (Change.Status.DRAFT); java.util.List<java.lang.String> newGroups = groups; if (newGroups.isEmpty()) { newGroups = com.google.gerrit.server.git.GroupCollector.getDefaultGroups(commit); } patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert); update.fixStatus(change.getStatus()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes(); approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), java.util.Collections.<com.google.gerrit.reviewdb.client.Account.Id>emptySet()); approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals); if ((message) != null) { changeMessage = com.google.gerrit.server.ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message); cmUtil.addChangeMessage(db, update, changeMessage); } return true; }
public static com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, java.lang.String body) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body); }
public static com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.server.CurrentUser user, java.sql.Timestamp when, java.lang.String body) throws com.google.gwtorm.server.OrmException { checkNotNull(psId); com.google.gerrit.reviewdb.client.Account.Id accountId = (user.isInternalUser()) ? null : user.getAccountId(); com.google.gerrit.reviewdb.client.ChangeMessage m = new com.google.gerrit.reviewdb.client.ChangeMessage(new com.google.gerrit.reviewdb.client.ChangeMessage.Key(psId.getParentKey(), com.google.gerrit.server.ChangeUtil.messageUUID(db)), accountId, when, psId); m.setMessage(body); user.updateRealAccountId(m::setRealAuthor); return m; }
private com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Abandoned"); if (!(com.google.common.base.Strings.nullToEmpty(msgTxt).trim().isEmpty())) { msg.append("\n\n"); msg.append(msgTxt.trim()); } return com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, msg.toString()); }
private void abandonAllOpenChangeForDeletedProject(com.google.gerrit.reviewdb.client.Project.NameKey destProject) { try { for (com.google.gerrit.server.query.change.ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) { try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) { bu.setRequestId(submissionId); bu.addOp(cd.getId(), new com.google.gerrit.server.git.BatchUpdate.Op() { @java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); if (!(change.getStatus().isOpen())) { return false; } change.setStatus(Change.Status.ABANDONED); com.google.gerrit.reviewdb.client.ChangeMessage msg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), "Project was deleted."); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg); return true; } }); try { bu.execute(); } catch (com.google.gerrit.server.git.UpdateException | com.google.gerrit.extensions.restapi.RestApiException e) { logWarn(("Cannot abandon changes for deleted project " + destProject), e); } } } } catch (com.google.gwtorm.server.OrmException e) { logWarn(("Cannot abandon changes for deleted project " + destProject), e); } }
private void addMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.Account previousAssignee) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Assignee "); if (previousAssignee == null) { msg.append("added: "); msg.append(newAssignee.getName(anonymousCowardName)); } else { msg.append("changed from: "); msg.append(previousAssignee.getName(anonymousCowardName)); msg.append(" to: "); msg.append(newAssignee.getName(anonymousCowardName)); } com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, msg.toString()); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = change.currentPatchSetId(); com.google.gerrit.reviewdb.client.ChangeMessage changeMessage = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, ("Created a revert of this change as I" + (computedChangeId.name()))); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage); return true; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); newTopicName = com.google.common.base.Strings.nullToEmpty(input.topic); oldTopicName = com.google.common.base.Strings.nullToEmpty(change.getTopic()); if (oldTopicName.equals(newTopicName)) { return false; } java.lang.String summary; if (oldTopicName.isEmpty()) { summary = "Topic set to " + (newTopicName); } else if (newTopicName.isEmpty()) { summary = ("Topic " + (oldTopicName)) + " removed"; } else { summary = java.lang.String.format("Topic changed from %s to %s", oldTopicName, newTopicName); } change.setTopic(com.google.common.base.Strings.emptyToNull(newTopicName)); update.setTopic(change.getTopic()); com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, summary); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); return true; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder sb = new java.lang.StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name()); com.google.gerrit.reviewdb.client.ChangeMessage changeMessage = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString()); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage); return true; }
private void sendReplacePatchSet(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gerrit.common.errors.EmailException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.ChangeMessage msg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), (("Uploaded patch set " + (psId.get())) + ".")); com.google.gerrit.server.mail.ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId()); cm.setFrom(ctx.getAccountId()); cm.setPatchSet(patchSet, patchSetInfo); cm.setChangeMessage(msg.getMessage(), ctx.getWhen()); cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); }
private void addMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.notedb.ChangeUpdate update) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); appendHashtagMessage(msg, "added", toAdd); appendHashtagMessage(msg, "removed", toRemove); com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, msg.toString()); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); }
private com.google.gerrit.reviewdb.client.ChangeMessage message(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.reviewdb.client.PatchSet.Id psId, java.lang.String body) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = ctx.getChange(); if (!(change.getStatus().isOpen())) { return false; } change.setStatus(Change.Status.ABANDONED); com.google.gerrit.reviewdb.client.ChangeMessage msg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), "Project was deleted."); cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg); return true; }
private com.google.gerrit.reviewdb.client.ChangeMessage newMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Restored"); if (!(com.google.common.base.Strings.nullToEmpty(input.message).trim().isEmpty())) { msg.append("\n\n"); msg.append(input.message.trim()); } return com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, msg.toString()); }
private void addMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.Account deleted) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, ("Assignee deleted: " + (deleted.getName(anonymousCowardName)))); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); }
@java.lang.Override public boolean apply(com.amd.gerrit.plugins.manifestsubscription.manifest.Project project, java.lang.String hash, java.lang.String name, com.google.gerrit.server.git.GitRepositoryManager gitRepoManager) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.reviewdb.client.Project.NameKey p = new com.google.gerrit.reviewdb.client.Project.NameKey(project.getName()); try (org.eclipse.jgit.lib.Repository db = gitRepoManager.openRepository(p);org.eclipse.jgit.api.Git git = new org.eclipse.jgit.api.Git(db)) { git.branchCreate().setName(branch).setStartPoint(hash).call(); } return true; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { com.google.gerrit.server.IdentifiedUser user = receiveEvent.user; java.lang.String refname = receiveEvent.refName; org.eclipse.jgit.lib.ObjectId old = org.eclipse.jgit.lib.ObjectId.zeroId(); if ((receiveEvent.commit.getParentCount()) > 0) { old = receiveEvent.commit.getParent(0); } if (receiveEvent.command.getRefName().startsWith(com.googlesource.gerrit.plugins.hooks.REFS_CHANGES)) { refname = refname.replace(com.googlesource.gerrit.plugins.hooks.R_HEADS, "refs/for/refs/heads/"); old = org.eclipse.jgit.lib.ObjectId.zeroId(); } com.googlesource.gerrit.plugins.hooks.HookArgs args = hookFactory.createArgs(); args.add("--project", receiveEvent.project.getName()); args.add("--refname", refname); args.add("--uploader", user.getNameEmail()); args.add("--oldrev", old.name()); args.add("--newrev", receiveEvent.commit.name()); com.googlesource.gerrit.plugins.hooks.HookResult result = hook.run(args); if (result != null) { java.lang.String output = result.toString(); if ((result.getExitValue()) != 0) { throw new com.google.gerrit.server.git.validators.CommitValidationException(output); } if (!(output.isEmpty())) { return com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidationMessage(output, false)); } } return java.util.Collections.emptyList(); }



void play() throws java.io.IOException { if ((status) != 0) { com.google.gerrit.httpd.HttpServletResponseRecorder.log.debug("Replaying {} {}", status, statusMsg); if ((status) == (SC_MOVED_TEMPORARILY)) { super.sendRedirect(getHeader("Location")); } else { super.sendError(status, statusMsg); } } }
@java.lang.Override public java.lang.Void call() throws java.io.IOException { for (com.google.gerrit.server.index.change.ChangeIndex i : getWriteIndexes()) { i.delete(id); } fireChangeDeletedFromIndexEvent(id.get()); return null; }

@java.lang.Override public java.lang.String toString() { return refState.toString(); }
static java.util.Optional<com.google.gerrit.server.notedb.NoteDbChangeState.RefState> parse(com.google.gerrit.reviewdb.client.Change.Id changeId, java.lang.String str) { if (str == null) { return java.util.Optional.empty(); } java.util.List<java.lang.String> parts = com.google.common.base.Splitter.on(',').splitToList(str); checkArgument((!(parts.isEmpty())), "invalid state string for change %s: %s", changeId, str); org.eclipse.jgit.lib.ObjectId changeMetaId = org.eclipse.jgit.lib.ObjectId.fromString(parts.get(0)); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> draftIds = com.google.common.collect.Maps.newHashMapWithExpectedSize(((parts.size()) - 1)); com.google.common.base.Splitter s = com.google.common.base.Splitter.on('='); for (int i = 1; i < (parts.size()); i++) { java.lang.String p = parts.get(i); java.util.List<java.lang.String> draftParts = s.splitToList(p); checkArgument(((draftParts.size()) == 2), "invalid draft state part for change %s: %s", changeId, p); draftIds.put(Account.Id.parse(draftParts.get(0)), org.eclipse.jgit.lib.ObjectId.fromString(draftParts.get(1))); } return java.util.Optional.of(com.google.gerrit.server.notedb.NoteDbChangeState.RefState.create(changeMetaId, draftIds)); }
public static com.google.gerrit.server.notedb.NoteDbChangeState parse(com.google.gerrit.reviewdb.client.Change c) { return com.google.gerrit.server.notedb.NoteDbChangeState.parse(c.getId(), c.getNoteDbState()); }
@org.junit.Test public void byHashtagWithoutNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isFalse(); notesMigration.setWriteChanges(true); notesMigration.setReadChanges(true); db.close(); db = schemaFactory.open(); java.util.List<com.google.gerrit.reviewdb.client.Change> changes; try { changes = setUpHashtagChanges(); notesMigration.setWriteChanges(false); notesMigration.setReadChanges(false); } finally { db.close(); } db = schemaFactory.open(); for (com.google.gerrit.reviewdb.client.Change c : changes) { indexer.index(db, c); } assertQuery("hashtag:foo"); assertQuery("hashtag:bar"); assertQuery("hashtag:\" bar \""); assertQuery("hashtag:\"a tag\""); assertQuery("hashtag:\" a tag \""); assertQuery("hashtag:#foo"); assertQuery("hashtag:\"# #foo\""); }

@org.junit.Before public void setUp() throws java.lang.Exception { assume().that(com.google.gerrit.testutil.NoteDbMode.readWrite()).isFalse(); com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); setNotesMigration(false, false); }
private java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, final com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change.Id changeId = ctx.getNotes().getChangeId(); java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals; if (migration.readChanges()) { com.google.gerrit.reviewdb.server.ReviewDb db = ctx.getDb(); if (db instanceof com.google.gerrit.server.git.BatchUpdateReviewDb) { db = ((com.google.gerrit.server.git.BatchUpdateReviewDb) (db)).unsafeGetDelegate(); } db = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db); approvals = db.patchSetApprovals().byChange(changeId); } else { approvals = approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).values(); } return com.google.common.collect.Iterables.filter(approvals, new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.PatchSetApproval>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.PatchSetApproval input) { return accountId.equals(input.getAccountId()); } }); }
public com.google.gerrit.testutil.TestNotesMigration setFromEnv() { switch (com.google.gerrit.testutil.NoteDbMode.get()) { case READ_WRITE : setWriteChanges(true); setReadChanges(true); break; case WRITE : setWriteChanges(true); setReadChanges(false); break; case CHECK : case OFF : default : setWriteChanges(false); setReadChanges(false); break; } return this; }
private void deleteDraftPatchSet(com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { psUtil.delete(ctx.getDb(), ctx.getUpdate(patchSet.getId()), patchSet); accountPatchReviewStore.get().clearReviewed(psId); com.google.gerrit.reviewdb.server.ReviewDb db = com.google.gerrit.server.change.DeleteDraftChangeOp.unwrap(ctx.getDb()); db.changeMessages().delete(db.changeMessages().byPatchSet(psId)); db.patchComments().delete(db.patchComments().byPatchSet(psId)); db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId)); }

@java.lang.Override public java.lang.String toString() { return com.google.gerrit.server.notedb.NoteDbChangeState.toString(changeMetaId, draftIds); }
public static boolean readWrite() { return (com.google.gerrit.testutil.NoteDbMode.get()) == (com.google.gerrit.testutil.NoteDbMode.READ_WRITE); }

@com.google.common.annotations.VisibleForTesting com.google.common.collect.ImmutableMap<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> getDraftIds() { return draftIds; }
@com.google.common.annotations.VisibleForTesting public org.eclipse.jgit.lib.ObjectId getChangeMetaId() { return changeMetaId; }

public void delete(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { ensurePatchSetMatches(ps.getId(), update); checkArgument(ps.isDraft(), "cannot delete non-draft patch set %s", ps.getId()); update.setPatchSetState(PatchSetState.DELETED); db.patchSets().delete(java.util.Collections.singleton(ps)); }
@java.lang.Override public java.lang.String[] getList(java.lang.String section, java.lang.String subsection, java.lang.String name) { return sec.getStringList(section, subsection, name); }

@java.lang.Override public void setList(java.lang.String section, java.lang.String subsection, java.lang.String name, java.util.List<java.lang.String> values) { if (values != null) { sec.setStringList(section, subsection, name, values); } else { sec.unset(section, subsection, name); } save(); }
private void migrateData(java.util.List<com.google.gerrit.server.schema.SchemaVersion> pending, com.google.gerrit.server.schema.UpdateUI ui, com.google.gerrit.reviewdb.client.CurrentSchemaVersion curr, com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { for (com.google.gerrit.server.schema.SchemaVersion v : pending) { ui.message(java.lang.String.format("Migrating data to schema %d ...", v.getVersionNbr())); v.migrateData(db, ui); v.finish(curr, db); } }












public void markCleanMerges(final org.eclipse.jgit.revwalk.RevWalk rw, final org.eclipse.jgit.revwalk.RevFlag canMergeFlag, final com.google.gerrit.server.git.CodeReviewCommit mergeTip, final java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted) throws com.google.gerrit.server.git.IntegrationException { if (mergeTip == null) { return; } try { rw.resetRetain(canMergeFlag); rw.sort(RevSort.TOPO); rw.sort(RevSort.REVERSE, true); rw.markStart(mergeTip); for (org.eclipse.jgit.revwalk.RevCommit c : alreadyAccepted) { rw.markUninteresting(c); } com.google.gerrit.server.git.CodeReviewCommit c; while ((c = ((com.google.gerrit.server.git.CodeReviewCommit) (rw.next()))) != null) { if ((c.getPatchsetId()) != null) { c.setStatusCode(CommitMergeStatus.CLEAN_MERGE); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException("Cannot mark clean merges", e); } }
@org.junit.Test public void submitWholeTopic() throws java.lang.Exception { assume().that(isSubmitWholeTopicEnabled()).isTrue(); com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic"); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic"); approve(change1.getChangeId()); approve(change2.getChangeId()); approve(change3.getChangeId()); submit(change3.getChangeId()); change1.assertChange(Change.Status.MERGED, name("test-topic"), admin); change2.assertChange(Change.Status.MERGED, name("test-topic"), admin); change3.assertChange(Change.Status.MERGED, name("test-topic"), admin); assertSubmitter(change3); assertSubmitter(change1); assertSubmitter(change2); }

public java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sort(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> incoming) throws java.io.IOException { final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = new java.util.ArrayList<>(); final java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> sort = new java.util.HashSet(incoming); while (!(sort.isEmpty())) { final com.google.gerrit.server.git.CodeReviewCommit n = com.google.gerrit.server.git.RebaseSorter.removeOne(sort); rw.resetRetain(canMergeFlag); rw.markStart(n); if ((initialTip) != null) { rw.markUninteresting(initialTip); } com.google.gerrit.server.git.CodeReviewCommit c; final java.util.List<com.google.gerrit.server.git.CodeReviewCommit> contents = new java.util.ArrayList<>(); while ((c = rw.next()) != null) { if ((!(c.has(canMergeFlag))) || (!(incoming.contains(c)))) { if ((n.missing) == null) { n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY); n.missing = new java.util.ArrayList(); } n.missing.add(c); } else { contents.add(c); } } if ((n.getStatusCode()) == (com.google.gerrit.server.git.strategy.CommitMergeStatus.MISSING_DEPENDENCY)) { continue; } sort.removeAll(contents); java.util.Collections.reverse(contents); sorted.removeAll(contents); sorted.addAll(contents); } return sorted; }
private com.google.gerrit.server.git.BatchUpdate.ChangeContext newChangeContext(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Change.Id id) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChanges.get(id); if (c == null) { c = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db).changes().get(id); } com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c); com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(notes, user); return new com.google.gerrit.server.git.BatchUpdate.ChangeContext(ctl, new com.google.gerrit.server.git.BatchUpdateReviewDb(db), repo, rw); }

private java.lang.String getHttpHost(com.google.gerrit.extensions.config.DownloadScheme scheme, java.lang.String project) { java.lang.String host = scheme.getUrl(project); host = host.substring(0, host.lastIndexOf(project)); int auth = host.lastIndexOf("/a/"); if (auth > (-1)) { host = host.substring(0, (auth + 1)); } return host; }

@com.google.inject.Provides @com.google.inject.Singleton com.google.gerrit.httpd.raw.BowerComponentsServlet getBowerComponentsServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) throws java.io.IOException { return new com.google.gerrit.httpd.raw.BowerComponentsServlet(cache, getPaths().buckOut); }
@com.google.inject.Provides @com.google.inject.Singleton com.google.gerrit.httpd.raw.FontsServlet getFontsServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) throws java.io.IOException { return new com.google.gerrit.httpd.raw.FontsServlet(cache, getPaths().buckOut); }
static void displayFailure(java.lang.String rule, byte[] why, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); res.setContentType("text/html"); res.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); com.google.gwtexpui.server.CacheHeaders.setNotCacheable(res); com.google.common.escape.Escaper html = com.google.common.html.HtmlEscapers.htmlEscaper(); try (java.io.PrintWriter w = res.getWriter()) { w.write("<html><title>BUILD FAILED</title><body>"); w.format("<h1>%s FAILED</h1>", html.escape(rule)); w.write("<pre>"); w.write(html.escape(org.eclipse.jgit.util.RawParseUtils.decode(why))); w.write("</pre>"); w.write("</body></html>"); } }
static void build(java.nio.file.Path root, java.nio.file.Path gen, java.lang.String target) throws com.google.gerrit.httpd.raw.BuckUtils.BuildFailureException, java.io.IOException { com.google.gerrit.httpd.raw.BuckUtils.log.info(("buck build " + target)); java.util.Properties properties = com.google.gerrit.httpd.raw.BuckUtils.loadBuckProperties(gen); java.lang.String buck = firstNonNull(properties.getProperty("buck"), "buck"); java.lang.ProcessBuilder proc = new java.lang.ProcessBuilder(buck, "build", target).directory(root.toFile()).redirectErrorStream(true); if (properties.containsKey("PATH")) { proc.environment().put("PATH", properties.getProperty("PATH")); } long start = com.google.gerrit.common.TimeUtil.nowMs(); java.lang.Process rebuild = proc.start(); byte[] out; try (java.io.InputStream in = rebuild.getInputStream()) { out = com.google.common.io.ByteStreams.toByteArray(in); } finally { rebuild.getOutputStream().close(); } int status; try { status = rebuild.waitFor(); } catch (java.lang.InterruptedException e) { throw new java.io.InterruptedIOException(("interrupted waiting for " + buck)); } if (status != 0) { throw new com.google.gerrit.httpd.raw.BuckUtils.BuildFailureException(out); } long time = (com.google.gerrit.common.TimeUtil.nowMs()) - start; com.google.gerrit.httpd.raw.BuckUtils.log.info(java.lang.String.format("UPDATED %s in %.3fs", target, (time / 1000.0))); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse res, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { java.lang.String pkg = "gerrit-gwtui"; java.lang.String target = "ui_" + (rule.select(((javax.servlet.http.HttpServletRequest) (request)))); if ((gwtuiRecompile) || (!(uaInitialized.contains(target)))) { java.lang.String rule = (("//" + pkg) + ":") + target; java.lang.String child = java.lang.String.format("%s/__gwt_binary_%s__", pkg, target); java.io.File zip = gen.resolve(child).resolve((target + ".zip")).toFile(); synchronized(this) { try { com.google.gerrit.httpd.raw.BuckUtils.build(root, gen, rule); } catch (com.google.gerrit.httpd.raw.BuckUtils.BuildFailureException e) { com.google.gerrit.httpd.raw.BuckUtils.displayFailure(rule, e.why, ((javax.servlet.http.HttpServletResponse) (res))); return; } if ((!(target.equals(lastTarget))) || ((lastTime) != (zip.lastModified()))) { lastTarget = target; lastTime = zip.lastModified(); com.google.gerrit.httpd.raw.RecompileGwtUiFilter.unpack(zip, unpackedWar.toFile()); } } uaInitialized.add(target); } chain.doFilter(request, res); }

@org.junit.Test public void submitWholeTopic() throws java.lang.Exception { assume().that(isSubmitWholeTopicEnabled()).isTrue(); com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic"); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic"); com.google.gerrit.acceptance.PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic"); approve(change1.getChangeId()); approve(change2.getChangeId()); approve(change3.getChangeId()); submit(change3.getChangeId()); change1.assertChange(Change.Status.MERGED, "test-topic", admin); change2.assertChange(Change.Status.MERGED, "test-topic", admin); change3.assertChange(Change.Status.MERGED, "test-topic", admin); assertSubmitter(change3); assertSubmitter(change1); assertSubmitter(change2); java.util.List<org.eclipse.jgit.revwalk.RevCommit> log = getRemoteLog(); java.util.List<java.lang.String> commitsInRepo = com.google.common.collect.Lists.transform(log, new com.google.common.base.Function<org.eclipse.jgit.revwalk.RevCommit, java.lang.String>() { @java.lang.Override public java.lang.String apply(org.eclipse.jgit.revwalk.RevCommit input) { return input.getShortMessage(); } }); int expectedCommitCount = ((getSubmitType()) == (com.google.gerrit.extensions.client.SubmitType.MERGE_ALWAYS)) ? 5 : 4; assertThat(log).hasSize(expectedCommitCount); assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3"); if ((getSubmitType()) == (com.google.gerrit.extensions.client.SubmitType.MERGE_ALWAYS)) { assertThat(commitsInRepo).contains("Merge changes from topic 'test-topic'"); } }
@java.lang.Override public void build(com.google.gerrit.httpd.raw.Label label) throws com.google.gerrit.httpd.raw.BuildFailureException, java.io.IOException { com.google.gerrit.httpd.raw.BuckUtils.log.info(("buck build " + (label.fullName()))); java.util.Properties properties = com.google.gerrit.httpd.raw.BuckUtils.loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties")); java.lang.String buck = firstNonNull(properties.getProperty("buck"), "buck"); java.lang.ProcessBuilder proc = new java.lang.ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true); if (properties.containsKey("PATH")) { proc.environment().put("PATH", properties.getProperty("PATH")); } long start = com.google.gerrit.common.TimeUtil.nowMs(); java.lang.Process rebuild = proc.start(); byte[] out; try (java.io.InputStream in = rebuild.getInputStream()) { out = com.google.common.io.ByteStreams.toByteArray(in); } finally { rebuild.getOutputStream().close(); } int status; try { status = rebuild.waitFor(); } catch (java.lang.InterruptedException e) { throw new java.io.InterruptedIOException(("interrupted waiting for " + buck)); } if (status != 0) { throw new com.google.gerrit.httpd.raw.BuildFailureException(out); } long time = (com.google.gerrit.common.TimeUtil.nowMs()) - start; com.google.gerrit.httpd.raw.BuckUtils.log.info(java.lang.String.format("UPDATED %s in %.3fs", label.fullName(), (time / 1000.0))); }


@java.lang.Override public final void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws java.lang.Exception { postUpdateImpl(ctx); if ((command) != null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription()); } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot email merged notification for " + (getId())), e); } if (((mergeResultRev) != null) && (!(args.dryrun))) { args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen()); } }



@org.junit.Before public void setup() throws java.lang.Exception { org.powermock.api.mockito.PowerMockito.mockStatic(Project.NameKey.class); when(Project.NameKey.parse(com.cisco.gerrit.plugins.slack.config.ProjectConfigTest.PROJECT_NAME)).thenReturn(mockNameKey); com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.config.ProjectConfigTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("test-channel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("test-user"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); config = new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.config.ProjectConfigTest.PROJECT_NAME); }





@org.junit.Test public void doesNotPublishWhenExpected() throws java.lang.Exception { mockEvent.comment = "WIP:This is a title\nAnd a the body."; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { return config.isEnabled(); }
@java.lang.Override public boolean shouldPublish() { if (!(config.isEnabled())) return false; boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.regex.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result = !(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("The specified ignore pattern was invalid", e); } return result; }
@java.lang.Override public boolean shouldPublish() { return config.isEnabled(); }





private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> toActionMap(com.google.gerrit.server.change.RevisionResource rsrc) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> out = new java.util.LinkedHashMap<>(); if (rsrc.getControl().getUser().isIdentifiedUser()) { com.google.inject.Provider<com.google.gerrit.server.CurrentUser> userProvider = com.google.inject.util.Providers.of(rsrc.getControl().getUser()); for (com.google.gerrit.extensions.webui.UiAction.Description d : com.google.gerrit.server.extensions.webui.UiActions.from(revisions, rsrc, userProvider)) { out.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } } return out; }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> toActionMap(com.google.gerrit.server.project.ChangeControl ctl) { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.ActionInfo> out = new java.util.LinkedHashMap<>(); if (!(ctl.getUser().isIdentifiedUser())) { return out; } com.google.inject.Provider<com.google.gerrit.server.CurrentUser> userProvider = com.google.inject.util.Providers.of(ctl.getUser()); for (com.google.gerrit.extensions.webui.UiAction.Description d : com.google.gerrit.server.extensions.webui.UiActions.from(changeViews, changeResourceFactory.create(ctl), userProvider)) { out.put(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } if (ctl.getChange().getStatus().isOpen()) { com.google.gerrit.extensions.webui.UiAction.Description descr = new com.google.gerrit.extensions.webui.UiAction.Description(); com.google.gerrit.extensions.webui.PrivateInternals_UiActionDescription.setId(descr, "followup"); com.google.gerrit.extensions.webui.PrivateInternals_UiActionDescription.setMethod(descr, "POST"); descr.setTitle("Create follow-up change"); descr.setLabel("Follow-Up"); out.put(descr.getId(), new com.google.gerrit.extensions.common.ActionInfo(descr)); } return out; }
public static <R extends com.google.gerrit.extensions.restapi.RestResource> java.lang.Iterable<com.google.gerrit.extensions.webui.UiAction.Description> from(com.google.gerrit.extensions.restapi.RestCollection<?, R> collection, R resource, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> userProvider) { return com.google.gerrit.server.extensions.webui.UiActions.from(collection.views(), resource, userProvider); }



@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); soyContext.put("commentFiles", getCommentGroupsTemplateData()); }

@org.junit.Test public void generatesExpectedMessageForLongComment() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.author = com.google.common.base.Suppliers.ofInstance(mockAccount); mockEvent.comment = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + (("Integer tristique ligula nec dapibus lobortis. Nulla venenatis, lacus quis vulputate volutpat, " + "sem neque ornare eros, vel sodales magna risus et diam. Maecenas ultricies justo dictum orci ") + "scelerisque consequat a vel purus."); mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockChange.owner = mockOwner; mockOwner.name = "Owner"; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = ((("{\"text\": \"Unit Tester commented to Owner\\n>>>" + "testproject (master): ") + (mockEvent.comment.substring(0, 197))) + "... (https://change/)\",") + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"; java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
@org.junit.Test public void generatesExpectedMessage() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.author = com.google.common.base.Suppliers.ofInstance(mockAccount); mockEvent.comment = "This is the first line\nAnd the second line."; mockChange.project = "testproject"; mockChange.branch = "master"; mockChange.url = "https://change/"; mockChange.owner = mockOwner; mockOwner.name = "Owner"; mockAccount.name = "Unit Tester"; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); java.lang.String expectedResult; expectedResult = "{\"text\": \"Unit Tester commented to Owner\\n>>>" + (("testproject (master): This is the first line\n" + "And the second line. (https://change/)\",") + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n"); java.lang.String actualResult; actualResult = messageGenerator.generate(); assertThat(actualResult, is(equalTo(expectedResult))); }
@java.lang.Override public java.lang.String generate() { java.lang.String message; message = ""; try { java.lang.String template; template = com.cisco.gerrit.plugins.slack.util.ResourceHelper.loadNamedResourceAsString("basic-message-template.json"); java.lang.StringBuilder text; text = new java.lang.StringBuilder(); text.append(escape(event.author.get().name)); text.append(" commented to "); text.append(escape(event.change.get().owner.name)); text.append("\\n>>>"); text.append(escape(event.change.get().project)); text.append(" ("); text.append(escape(event.change.get().branch)); text.append("): "); text.append(escape(com.google.common.base.Ascii.truncate(event.comment, 200, "..."))); text.append(" ("); text.append(escape(event.change.get().url)); text.append(")"); message = java.lang.String.format(template, text, config.getChannel(), config.getUsername()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGenerator.LOGGER.error(("Error generating message: " + (e.getMessage())), e); } return message; }
public java.util.Set<java.lang.String> getProjectsInScope(java.lang.String fromBranch, java.lang.String toBranch) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { try { java.util.Set<java.lang.String> projectSet = new java.util.HashSet<java.lang.String>(); java.util.Set<java.lang.String> fromProjectSet = getManifestProjects(fromBranch); projectSet.addAll(fromProjectSet); java.util.Set<java.lang.String> toProjectSet = getManifestProjects(fromBranch, toBranch); if (projectSet.isEmpty()) { projectSet = toProjectSet; } else if (!(toProjectSet.isEmpty())) { projectSet.retainAll(toProjectSet); } applyConfig(projectSet, config.getGlobal()); applyConfig(projectSet, config.getMergeConfig(fromBranch)); applyConfig(projectSet, config.getMergeConfig(fromBranch, toBranch)); return projectSet; } catch (com.google.gerrit.extensions.restapi.RestApiException | java.io.IOException e) { com.googlesource.gerrit.plugins.automerger.ConfigLoader.log.error("Error reading manifest for {}!", fromBranch, e); throw e; } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.RevisionResource rev, com.googlesource.gerrit.plugins.automerger.AutomergeChangeAction.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.FailedMergeException { java.util.Map<java.lang.String, java.lang.Boolean> branchMap = input.branchMap; com.google.gerrit.reviewdb.client.Change change = rev.getChange(); java.lang.String revision = rev.getPatchSet().getRevision().get(); com.googlesource.gerrit.plugins.automerger.MultipleDownstreamMergeInput mdsMergeInput = new com.googlesource.gerrit.plugins.automerger.MultipleDownstreamMergeInput(); mdsMergeInput.dsBranchMap = branchMap; mdsMergeInput.sourceId = change.getKey().get(); mdsMergeInput.project = change.getProject().get(); mdsMergeInput.topic = change.getTopic(); mdsMergeInput.subject = change.getSubject(); mdsMergeInput.obsoleteRevision = revision; mdsMergeInput.currentRevision = revision; dsCreator.createMergesAndHandleConflicts(mdsMergeInput); return com.google.gerrit.extensions.restapi.Response.none(); }
private com.google.gerrit.server.git.BatchUpdate.ChangeContext newChangeContext(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = newChanges.get(id); HEAD(4807); com.google.gerrit.server.git.ac Merge = com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange(db, id); // Pass in preloaded change to controlFor, to avoid: // - reading from a db that does not belong to this update // - attempting to read a change that doesn't exist yet }
private java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sort(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toSort) throws com.google.gerrit.server.git.IntegrationException { try { return new com.google.gerrit.server.git.RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException("Commit sorting failed", e); } }

private java.util.List<com.google.gerrit.server.project.ChangeControl> changeFromNotesFactory(java.lang.String id, final com.google.gerrit.server.CurrentUser currentUser) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> changes = changeNotesFactory.create(db, java.util.Arrays.asList(Change.Id.parse(id))); return com.google.common.collect.FluentIterable.from(changes).transform(new com.google.common.base.Function<com.google.gerrit.server.notedb.ChangeNotes, com.google.gerrit.server.project.ChangeControl>() { @java.lang.Override public com.google.gerrit.server.project.ChangeControl apply(com.google.gerrit.server.notedb.ChangeNotes changeNote) { return controlForChange(changeNote, currentUser); } }).filter(com.google.common.base.Predicates.notNull()).toList(); }









private com.googlesource.gerrit.plugins.replication.ReplicationFileBasedConfig loadConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return new com.googlesource.gerrit.plugins.replication.ReplicationFileBasedConfig(injector, site, remoteSiteUserFactory, pluginUser, gitRepositoryManager, groupBackend, stateLog, groupIncludeCache); }


void schedule(final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String ref, final org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState state) { com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduling replication {}:{} => {}", project, ref, uri); if (!(isVisible(project, state))) { return; } if (!(config.replicatePermissions())) { com.googlesource.gerrit.plugins.replication.PushOne e; synchronized(stateLock) { e = pending.get(uri); } if (e == null) { try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project)) { try { org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); if (((head != null) && (head.isSymbolic())) && (RefNames.REFS_CONFIG.equals(head.getLeaf().getName()))) { return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("cannot check type of project %s", project), err, state); return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, state); return; } } } synchronized(stateLock) { com.googlesource.gerrit.plugins.replication.PushOne e = pending.get(uri); if (e == null) { e = opFactory.create(project, uri); pool.schedule(e, config.getDelay(), java.util.concurrent.TimeUnit.SECONDS); pending.put(uri, e); } e.addRef(ref); state.increasePushTaskCount(project.get(), ref); e.addState(ref, state); com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay()); } }
void reschedule(com.googlesource.gerrit.plugins.replication.PushOne pushOp, com.googlesource.gerrit.plugins.replication.Destination.RetryReason reason) { synchronized(stateLock) { org.eclipse.jgit.transport.URIish uri = pushOp.getURI(); com.googlesource.gerrit.plugins.replication.PushOne pendingPushOp = pending.get(uri); if (pendingPushOp != null) { if (pendingPushOp.isRetrying()) { pendingPushOp.addRefs(pushOp.getRefs()); pendingPushOp.addStates(pushOp.getStates()); pushOp.removeStates(); } else { pendingPushOp.cancel(); pending.remove(uri); pushOp.addRefs(pendingPushOp.getRefs()); pushOp.addStates(pendingPushOp.getStates()); pendingPushOp.removeStates(); } } if ((pendingPushOp == null) || (!(pendingPushOp.isRetrying()))) { pending.put(uri, pushOp); switch (reason) { case COLLISION : pool.schedule(pushOp, config.getDelay(), java.util.concurrent.TimeUnit.SECONDS); break; case TRANSPORT_ERROR : case REPOSITORY_MISSING : default : pushOp.setToRetry(); pool.schedule(pushOp, config.getRetryDelay(), java.util.concurrent.TimeUnit.MINUTES); break; } } } }



@java.lang.Override protected java.lang.String getMappings() { return ((("{\"mappings\" : " + (com.google.gerrit.elasticsearch.ElasticChangeIndex.getMappingProperties("open_changes"))) + ",") + (com.google.gerrit.elasticsearch.ElasticChangeIndex.getMappingProperties("closed_changes"))) + "}"; }

@org.junit.BeforeClass public static void startIndexService() throws java.lang.InterruptedException, java.util.concurrent.ExecutionException { if ((com.google.gerrit.elasticsearch.ElasticQueryChangesTest.node) != null) { return; } com.google.gerrit.elasticsearch.ElasticQueryChangesTest.elasticDir = com.google.common.io.Files.createTempDir(); java.nio.file.Path elasticDirPath = com.google.gerrit.elasticsearch.ElasticQueryChangesTest.elasticDir.toPath(); org.elasticsearch.common.settings.Settings settings = org.elasticsearch.common.settings.Settings.settingsBuilder().put("cluster.name", "gerrit").put("node.name", "Gerrit Elasticsearch Test Node").put("node.local", true).put("discovery.zen.ping.multicast.enabled", false).put("index.store.fs.memory.enabled", true).put("index.gateway.type", "none").put("index.max_result_window", java.lang.Integer.MAX_VALUE).put("gateway.type", "default").put("http.port", 0).put("discovery.zen.ping.unicast.hosts", "[\"localhost\"]").put("path.home", elasticDirPath.toAbsolutePath()).put("path.data", elasticDirPath.resolve("data").toAbsolutePath()).put("path.work", elasticDirPath.resolve("work").toAbsolutePath()).put("path.logs", elasticDirPath.resolve("logs").toAbsolutePath()).build(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.node = org.elasticsearch.node.NodeBuilder.nodeBuilder().settings(settings).node(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.node.client().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.createIndexes(); assertThat(com.google.gerrit.elasticsearch.ElasticQueryChangesTest.node.isClosed()).isFalse(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.port = com.google.gerrit.elasticsearch.ElasticQueryChangesTest.getHttpPort(); }

@org.junit.After public void cleanupIndex() { com.google.gerrit.elasticsearch.ElasticQueryChangesTest.node.client().admin().indices().prepareDelete("gerrit").execute(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.createIndexes(); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.server.account.AccountState> read() throws com.google.gwtorm.server.OrmException { org.apache.lucene.search.IndexSearcher searcher = null; try { searcher = acquire(); int realLimit = (opts.start()) + (opts.limit()); org.apache.lucene.search.TopFieldDocs docs = searcher.search(query, realLimit, sort); java.util.List<com.google.gerrit.server.account.AccountState> result = new java.util.ArrayList(docs.scoreDocs.length); for (int i = opts.start(); i < (docs.scoreDocs.length); i++) { org.apache.lucene.search.ScoreDoc sd = docs.scoreDocs[i]; org.apache.lucene.document.Document doc = searcher.doc(sd.doc, fields(opts)); result.add(toAccountState(doc)); } final java.util.List<com.google.gerrit.server.account.AccountState> r = java.util.Collections.unmodifiableList(result); return new com.google.gwtorm.server.ResultSet<com.google.gerrit.server.account.AccountState>() { @java.lang.Override public java.util.Iterator<com.google.gerrit.server.account.AccountState> iterator() { return r.iterator(); } @java.lang.Override public java.util.List<com.google.gerrit.server.account.AccountState> toList() { return r; } @java.lang.Override public void close() { } }; } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } finally { if (searcher != null) { try { release(searcher); } catch (java.io.IOException e) { com.google.gerrit.lucene.LuceneAccountIndex.log.warn("cannot release Lucene searcher", e); } } } }






@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.server.query.change.ChangeData> read() throws com.google.gwtorm.server.OrmException { if (java.lang.Thread.interrupted()) { java.lang.Thread.currentThread().interrupt(); throw new com.google.gwtorm.server.OrmException("interrupted"); } final java.util.Set<java.lang.String> fields = com.google.gerrit.index.IndexUtils.fields(schema, opts); return new com.google.gerrit.lucene.LuceneChangeIndex.ChangeDataResults(executor.submit(new java.util.concurrent.Callable<java.util.List<org.apache.lucene.document.Document>>() { @java.lang.Override public java.util.List<org.apache.lucene.document.Document> call() throws java.io.IOException { return doRead(fields); } @java.lang.Override public java.lang.String toString() { return predicate.toString(); } }), fields); }

public static java.util.Set<java.lang.String> fields(com.google.gerrit.server.index.Schema<com.google.gerrit.server.query.change.ChangeData> schema, com.google.gerrit.server.index.QueryOptions opts) { java.util.Set<java.lang.String> fs = opts.fields(); if (fs.contains(com.google.gerrit.index.CHANGE.getName())) { return fs; } if (!(schema.hasField(com.google.gerrit.index.PROJECT))) { if (fs.contains(com.google.gerrit.index.LEGACY_ID.getName())) { return fs; } return com.google.common.collect.Sets.union(fs, com.google.common.collect.ImmutableSet.of(com.google.gerrit.index.LEGACY_ID.getName())); } if ((fs.contains(com.google.gerrit.index.PROJECT.getName())) && (fs.contains(com.google.gerrit.index.LEGACY_ID.getName()))) { return fs; } return com.google.common.collect.Sets.union(fs, com.google.common.collect.ImmutableSet.of(com.google.gerrit.index.LEGACY_ID.getName(), com.google.gerrit.index.PROJECT.getName())); }



public void index(com.google.gerrit.server.query.change.ChangeData cd) throws java.io.IOException { for (com.google.gerrit.server.index.Index<?, com.google.gerrit.server.query.change.ChangeData> i : getWriteIndexes()) { i.replace(cd); } fireChangeIndexedEvent(cd.getId().get()); }
public void index(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gwtorm.server.OrmException, java.io.IOException { index(newChangeData(db, project, changeId)); }






public void index(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException, java.io.IOException { index(newChangeData(db, change)); }





private void givePlusTwo(com.google.gerrit.extensions.api.changes.ChangeApi downstreamChange) throws com.google.gerrit.extensions.restapi.RestApiException { com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.info("Giving +2 to {}", downstreamChange.id()); com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput(); com.google.gerrit.extensions.common.ChangeInfo newChange = downstreamChange.get(java.util.EnumSet.of(ListChangesOption.CURRENT_REVISION)); short codeReviewVote = 2; java.util.Map<java.lang.String, java.lang.Short> labels = new java.util.HashMap<java.lang.String, java.lang.Short>(); labels.put(config.getCodeReviewLabel(), codeReviewVote); reviewInput.labels = labels; gApi.changes().id(newChange.id).revision(newChange.currentRevision).review(reviewInput); }
public int getIssuePatternGroupIndex() { java.util.regex.Pattern pattern = getIssuePattern(); int groupCount = pattern.matcher("").groupCount(); int index = gerritConfig.getInt(pluginName, "commentlinkGroupIndex", 1); if ((index < 0) || (index > groupCount)) { index = (groupCount == 0) ? 0 : 1; } return index; }


public com.googlesource.gerrit.plugins.its.base.validation.ItsAssociationPolicy getItsAssociationPolicy() { return gerritConfig.getEnum("commentlink", getCommentLinkName(), "association", ItsAssociationPolicy.OPTIONAL); }


public java.lang.String getCommentLinkName() { java.lang.String ret; ret = gerritConfig.getString(pluginName, null, "commentlink"); if (ret == null) { ret = pluginName; } return ret; }
@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to index") void addChange(java.lang.String token) { try { changeArgumentParser.addChange(token, changes, null, false); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { throw new java.lang.IllegalArgumentException(e.getMessage(), e); } catch (com.google.gwtorm.server.OrmException e) { throw new java.lang.IllegalArgumentException("database is down", e); } }




private java.util.List<java.util.Map<java.lang.String, java.lang.Object>> formatComment(java.lang.String comment) { return com.google.gerrit.server.mail.send.CommentFormatter.parse(comment).stream().map(( b) -> { Map<java.lang.String, java.lang.Object> map = new com.google.gerrit.server.mail.send.HashMap<>(); switch (b.type) { case com.google.gerrit.server.mail.send.PARAGRAPH : map.put("type", "paragraph"); map.put("text", b.text); break; case com.google.gerrit.server.mail.send.PRE_FORMATTED : map.put("type", "pre"); map.put("text", b.text); break; case com.google.gerrit.server.mail.send.QUOTE : map.put("type", "quote"); map.put("text", b.text); break; case com.google.gerrit.server.mail.send.LIST : map.put("type", "list"); map.put("items", b.items); break; } return map; }).collect(java.util.stream.Collectors.toList()); }
private static com.google.gerrit.server.mail.send.CommentFormatter.Block makeQuote(java.lang.String p) { if (p.startsWith("> ")) { p = p.substring(2); } else if (p.startsWith(" > ")) { p = p.substring(3); } com.google.gerrit.server.mail.send.CommentFormatter.Block block = new com.google.gerrit.server.mail.send.CommentFormatter.Block(); block.type = com.google.gerrit.server.mail.send.CommentFormatter.BlockType.QUOTE; block.text = p.replaceAll("\n\\s?>\\s", "\n").trim(); return block; }
@org.junit.Test public void testQuote2() { java.lang.String comment = "See this said:\n\n > a quoted\n > string block\n\nOK?"; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(3); assertBlock(result, 0, BlockType.PARAGRAPH, "See this said:"); assertBlock(result, 1, BlockType.QUOTE, "a quoted\nstring block"); assertBlock(result, 2, BlockType.PARAGRAPH, "OK?"); }
@org.junit.Test public void testNestedQuotes1() { java.lang.String comment = " > > prior\n > \n > next\n"; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(1); assertBlock(result, 0, BlockType.QUOTE, "> prior\n\nnext"); }
@org.junit.Test public void testParseQuote() { java.lang.String comment = "> Quote text"; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(1); assertBlock(result, 0, BlockType.QUOTE, "Quote text"); }
@org.junit.Test public void testParseMultiLineQuote() { java.lang.String comment = "> Quote line 1\n> Quote line 2\n > Quote line 3\n"; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(1); assertBlock(result, 0, BlockType.QUOTE, "Quote line 1\nQuote line 2\nQuote line 3"); }
private void assertBlock(java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> list, int index, com.google.gerrit.server.mail.send.CommentFormatter.BlockType type, java.lang.String text) { com.google.gerrit.server.mail.send.CommentFormatter.Block block = list.get(index); assertThat(block.type).isEqualTo(type); assertThat(block.text).isEqualTo(text); assertThat(block.items).isNull(); }
@org.junit.Test public void testParseQuoteLeadSpace() { java.lang.String comment = " > Quote text"; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(1); assertBlock(result, 0, BlockType.QUOTE, "Quote text"); }
@org.junit.Test public void testParseMixedBlockTypes() { java.lang.String comment = "Paragraph\nacross\na\nfew\nlines." + ((((((((((("\n\n" + "> Quote\n> across\n> not many lines.") + "\n\n") + "Another paragraph") + "\n\n") + "* Series\n* of\n* list\n* items") + "\n\n") + "Yet another paragraph") + "\n\n") + "\tPreformatted text.") + "\n\n") + "Parting words."); java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(7); assertBlock(result, 0, BlockType.PARAGRAPH, "Paragraph\nacross\na\nfew\nlines."); assertBlock(result, 1, BlockType.QUOTE, "Quote\nacross\nnot many lines."); assertBlock(result, 2, BlockType.PARAGRAPH, "Another paragraph"); assertListBlock(result, 3, 0, "Series"); assertListBlock(result, 3, 1, "of"); assertListBlock(result, 3, 2, "list"); assertListBlock(result, 3, 3, "items"); assertBlock(result, 4, BlockType.PARAGRAPH, "Yet another paragraph"); assertBlock(result, 5, BlockType.PRE_FORMATTED, "\tPreformatted text."); assertBlock(result, 6, BlockType.PARAGRAPH, "Parting words."); }
private void assertListBlock(java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> list, int index, int itemIndex, java.lang.String text) { com.google.gerrit.server.mail.send.CommentFormatter.Block block = list.get(index); assertThat(block.type).isEqualTo(BlockType.LIST); assertThat(block.items.get(itemIndex)).isEqualTo(text); assertThat(block.text).isNull(); }
@org.junit.Test public void testQuote1() { java.lang.String comment = "> I\'m happy\n > with quotes!\n\nSee above."; java.util.List<com.google.gerrit.server.mail.send.CommentFormatter.Block> result = com.google.gerrit.server.mail.send.CommentFormatter.parse(comment); assertThat(result).hasSize(2); assertBlock(result, 0, BlockType.QUOTE, "I\'m happy\nwith quotes!"); assertBlock(result, 1, BlockType.PARAGRAPH, "See above."); }

@java.lang.Override public java.lang.String onSubmit(java.lang.String newCommitMessage, org.eclipse.jgit.revwalk.RevCommit original, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.reviewdb.client.Branch.NameKey destination) { java.util.List<java.lang.String> custom = mergeTip.getFooterLines("Custom"); if (!(custom.isEmpty())) { newCommitMessage += ("Custom-Parent: " + (custom.get(0))) + "\n"; } return (newCommitMessage + "Custom: ") + (destination.get()); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void changeMessageOnSubmit() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange(); com.google.gerrit.acceptance.PushOneCommit.Result change2 = createChange(); com.google.gerrit.extensions.registration.RegistrationHandle handle = changeMessageModifiers.add(new com.google.gerrit.server.git.ChangeMessageModifier() { @java.lang.Override public java.lang.String onSubmit(java.lang.String newCommitMessage, org.eclipse.jgit.revwalk.RevCommit original, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.reviewdb.client.Branch.NameKey destination) { java.util.List<java.lang.String> custom = mergeTip.getFooterLines("Custom"); if (!(custom.isEmpty())) { newCommitMessage += ("Custom-Parent: " + (custom.get(0))) + "\n"; } return (newCommitMessage + "Custom: ") + (destination.get()); } }); try { approve(change1.getChangeId()); submit(change2.getChangeId()); } finally { handle.remove(); } assertThat(getCurrentCommit(change1).getFooterLines("Custom")).containsExactly("refs/heads/master"); assertThat(getCurrentCommit(change2).getFooterLines("Custom")).containsExactly("refs/heads/master"); assertThat(getCurrentCommit(change2).getFooterLines("Custom-Parent")).containsExactly("refs/heads/master"); }
@org.junit.Test public void changeMessageOnSubmit() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.extensions.registration.RegistrationHandle handle = changeMessageModifiers.add(new com.google.gerrit.server.git.ChangeMessageModifier() { @java.lang.Override public java.lang.String onSubmit(java.lang.String newCommitMessage, org.eclipse.jgit.revwalk.RevCommit original, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.reviewdb.client.Branch.NameKey destination) { return (newCommitMessage + "Custom: ") + (destination.get()); } }); try { submit(change.getChangeId()); } finally { handle.remove(); } testRepo.git().fetch().setRemote("origin").call(); com.google.gerrit.extensions.common.ChangeInfo info = get(change.getChangeId()); org.eclipse.jgit.revwalk.RevCommit c = testRepo.getRevWalk().parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(info.currentRevision)); testRepo.getRevWalk().parseBody(c); assertThat(c.getFooterLines("Custom")).containsExactly("refs/heads/master"); assertThat(c.getFooterLines(FooterConstants.REVIEWED_ON)).hasSize(1); }
@org.junit.Test public void customCommitFooters() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); com.google.gerrit.extensions.registration.RegistrationHandle handle = changeMessageModifiers.add(new com.google.gerrit.server.git.ChangeMessageModifier() { @java.lang.Override public java.lang.String onSubmit(java.lang.String newCommitMessage, org.eclipse.jgit.revwalk.RevCommit original, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.reviewdb.client.Branch.NameKey destination) { return (newCommitMessage + "Custom: ") + (destination.get()); } }); ChangeInfo actual; try { java.util.EnumSet<com.google.gerrit.extensions.client.ListChangesOption> options = java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS); actual = gApi.changes().id(change.getChangeId()).get(options); } finally { handle.remove(); } java.util.List<java.lang.String> footers = new java.util.ArrayList(java.util.Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n"))); footers.remove(0); footers.remove(0); java.util.List<java.lang.String> expectedFooters = java.util.Arrays.asList(("Change-Id: " + (change.getChangeId())), (("Reviewed-on: " + (canonicalWebUrl.get())) + (change.getChange().getId())), "Custom: refs/heads/master"); assertThat(footers).containsExactlyElementsIn(expectedFooters); }

boolean isStale(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.index.change.ChangeIndex i = indexes.getSearchIndex(); if (i == null) { return false; } if ((!(i.getSchema().hasField(ChangeField.REF_STATE))) || (!(i.getSchema().hasField(ChangeField.REF_STATE_PATTERN)))) { return false; } java.util.Optional<com.google.gerrit.server.query.change.ChangeData> result = i.get(id, com.google.gerrit.server.index.change.IndexedChangeQuery.createOptions(indexConfig, 0, 1, com.google.gerrit.server.index.change.StalenessChecker.FIELDS)); if (!(result.isPresent())) { return true; } com.google.gerrit.server.query.change.ChangeData cd = result.get(); if (com.google.gerrit.server.index.change.StalenessChecker.reviewDbChangeIsStale(cd.change(), com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange(db.get(), cd.getId()))) { return true; } return com.google.gerrit.server.index.change.StalenessChecker.isStale(repoManager, id, parseStates(cd), parsePatterns(cd)); }

private static java.util.Map<java.lang.Integer, com.google.gerrit.client.change.VotableInfo> votable(com.google.gerrit.client.info.ChangeInfo change) { java.util.Map<java.lang.Integer, com.google.gerrit.client.change.VotableInfo> d = new java.util.HashMap<>(); for (java.lang.String name : change.labels()) { com.google.gerrit.client.info.ChangeInfo.LabelInfo label = change.label(name); if ((label.all()) != null) { for (com.google.gerrit.client.info.ChangeInfo.ApprovalInfo ai : com.google.gerrit.client.rpc.Natives.asList(label.all())) { int id = ai._accountId(); com.google.gerrit.client.change.VotableInfo ad = d.get(id); if (ad == null) { ad = new com.google.gerrit.client.change.VotableInfo(); d.put(id, ad); } if (ai.hasValue()) { ad.votable(name); } } } } return d; }

public static com.google.gerrit.extensions.common.ApprovalInfo getApprovalInfo(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.Integer value, java.lang.String tag, java.sql.Timestamp date) { com.google.gerrit.extensions.common.ApprovalInfo ai = new com.google.gerrit.extensions.common.ApprovalInfo(id.get()); ai.value = value; ai.date = date; ai.tag = tag; return ai; }
private com.google.gerrit.extensions.common.ApprovalInfo approvalInfo(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.Integer value, java.lang.String tag, java.sql.Timestamp date) { com.google.gerrit.extensions.common.ApprovalInfo ai = com.google.gerrit.server.change.ChangeJson.getApprovalInfo(id, value, tag, date); accountLoader.put(ai); return ai; }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to)); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.size()) > 1) || (!(filteredKeysByScheme.contains(key))))) { db.accountExternalIds().deleteKeys(filteredKeysByScheme); } byIdCache.evict(to); return link(to, who); } }
com.google.gerrit.extensions.common.CommitInfo toCommit(com.google.gerrit.server.project.ChangeControl ctl, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, boolean addLinks, boolean fillCommit) throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = ctl.getProject().getNameKey(); com.google.gerrit.extensions.common.CommitInfo info = new com.google.gerrit.extensions.common.CommitInfo(); if (fillCommit) { info.commit = commit.name(); } info.parents = new java.util.ArrayList(commit.getParentCount()); info.author = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getAuthorIdent()); info.committer = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getCommitterIdent()); info.subject = commit.getShortMessage(); info.message = commit.getFullMessage(); if (addLinks) { com.google.common.collect.FluentIterable<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name()); info.webLinks = (links.isEmpty()) ? null : links.toList(); } for (org.eclipse.jgit.revwalk.RevCommit parent : commit.getParents()) { rw.parseBody(parent); com.google.gerrit.extensions.common.CommitInfo i = new com.google.gerrit.extensions.common.CommitInfo(); i.commit = parent.name(); i.subject = parent.getShortMessage(); if (addLinks) { com.google.common.collect.FluentIterable<com.google.gerrit.extensions.common.WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name()); i.webLinks = (parentLinks.isEmpty()) ? null : parentLinks.toList(); } info.parents.add(i); } return info; }
public com.google.common.collect.FluentIterable<com.google.gerrit.extensions.common.WebLinkInfo> getFileHistoryLinks(java.lang.String project, java.lang.String revision, java.lang.String file) { return filterLinks(fileHistoryLinks, ( webLink) -> webLink.getFileHistoryWebLink(project, revision, file)); }
@org.junit.Test public void getFileContentRest() throws java.lang.Exception { com.google.gerrit.server.change.ChangeEdits.Put.Input in = new com.google.gerrit.server.change.ChangeEdits.Put.Input(); in.content = com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW); adminRestSession.putRaw(urlEditFile(), in.content).assertNoContent(); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(modifier.modifyFile(edit.get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); com.google.gerrit.acceptance.RestResponse r = adminRestSession.getJsonAccept(urlEditFile()); r.assertOK(); assertThat(readContentFromJson(r)).isEqualTo(org.apache.commons.codec.binary.StringUtils.newStringUtf8(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2)); r = adminRestSession.getJsonAccept(urlEditFile(true)); r.assertOK(); assertThat(readContentFromJson(r)).isEqualTo(org.apache.commons.codec.binary.StringUtils.newStringUtf8(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD)); }













@org.junit.Test public void testRetrieveSpecificRobotComment() throws java.lang.Exception { assume().that(notesMigration.enabled()).isTrue(); com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput robotCommentInput = createRobotCommentInput(); addRobotComment(changeId, robotCommentInput); java.util.List<com.google.gerrit.extensions.common.RobotCommentInfo> robotCommentInfos = gApi.changes().id(changeId).current().robotCommentsAsList(); com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo = com.google.common.collect.Iterables.getOnlyElement(robotCommentInfos); com.google.gerrit.extensions.common.RobotCommentInfo specificRobotCommentInfo = gApi.changes().id(changeId).current().robotComment(robotCommentInfo.id).get(); assertRobotComment(specificRobotCommentInfo, robotCommentInput); }





private com.google.gerrit.reviewdb.client.RobotComment createRobotComment(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, java.lang.String path, com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput robotCommentInput) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.RobotComment robotComment = commentsUtil.newRobotComment(ctx, path, psId, robotCommentInput.side(), robotCommentInput.message, robotCommentInput.robotId, robotCommentInput.robotRunId); robotComment.parentUuid = com.google.gerrit.extensions.restapi.Url.decode(robotCommentInput.inReplyTo); robotComment.url = robotCommentInput.url; robotComment.properties = robotCommentInput.properties; robotComment.setLineNbrAndRange(robotCommentInput.line, robotCommentInput.range); robotComment.tag = in.tag; com.google.gerrit.server.CommentsUtil.setCommentRevId(robotComment, patchListCache, ctx.getChange(), ps); return robotComment; }















@java.lang.Override public void writeTo(java.io.OutputStream out) throws java.io.IOException { org.apache.commons.compress.archivers.ArchiveOutputStream aos = f.createArchiveOutputStream(out); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projects) { com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo or = orm.getRepo(p); org.eclipse.jgit.transport.BundleWriter bw = new org.eclipse.jgit.transport.BundleWriter(or.getRepo()); bw.setObjectCountCallback(null); bw.setPackConfig(null); java.util.Collection<org.eclipse.jgit.transport.ReceiveCommand> refs = or.getUpdate().getRefUpdates(); for (org.eclipse.jgit.transport.ReceiveCommand r : refs) { bw.include(r.getRefName(), r.getNewId()); if (!(r.getOldId().equals(org.eclipse.jgit.lib.ObjectId.zeroId()))) { bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId())); } } aos.putArchiveEntry(f.prepareArchiveEntry(((p.get()) + ".git"))); bw.writeBundle(NullProgressMonitor.INSTANCE, aos); aos.closeArchiveEntry(); } aos.finish(); }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteBranchesInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.branches) == null)) || (input.branches.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("branches must be specified"); } try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project.getNameKey())) { org.eclipse.jgit.lib.BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate(); for (java.lang.String branch : input.branches) { batchUpdate.addCommand(createDeleteCommand(project, r, branch)); } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { batchUpdate.execute(rw, NullProgressMonitor.INSTANCE); } java.lang.StringBuilder errorMessages = new java.lang.StringBuilder(); for (org.eclipse.jgit.transport.ReceiveCommand command : batchUpdate.getCommands()) { if ((command.getResult()) == (org.eclipse.jgit.transport.ReceiveCommand.Result.OK)) { postDeletion(project, command); } else { appendAndLogErrorMessage(errorMessages, command); } } if ((errorMessages.length()) > 0) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(errorMessages.toString()); } } return com.google.gerrit.extensions.restapi.Response.none(); }



@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.server.project.DeleteBranch.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { if (!(rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete())) { throw new com.google.gerrit.extensions.restapi.AuthException("Cannot delete branch"); } if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("branch " + (rsrc.getBranchKey())) + " has open changes")); } try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.lib.RefUpdate.Result result; org.eclipse.jgit.lib.RefUpdate u = r.updateRef(rsrc.getRef()); u.setForceUpdate(true); refDeletionValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u); int remainingLockFailureCalls = com.google.gerrit.server.project.DeleteBranch.MAX_LOCK_FAILURE_CALLS; for (; ;) { try { result = u.delete(); } catch (org.eclipse.jgit.errors.LockFailedException e) { result = RefUpdate.Result.LOCK_FAILURE; } catch (java.io.IOException e) { com.google.gerrit.server.project.DeleteBranch.log.error(("Cannot delete " + (rsrc.getBranchKey())), e); throw e; } if ((result == (RefUpdate.Result.LOCK_FAILURE)) && ((--remainingLockFailureCalls) > 0)) { try { java.lang.Thread.sleep(com.google.gerrit.server.project.DeleteBranch.SLEEP_ON_LOCK_FAILURE_MS); } catch (java.lang.InterruptedException ie) { } } else { break; } } switch (result) { case NEW : case NO_CHANGE : case FAST_FORWARD : case FORCED : referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount()); break; case REJECTED_CURRENT_BRANCH : com.google.gerrit.server.project.DeleteBranch.log.error(((("Cannot delete " + (rsrc.getBranchKey())) + ": ") + (result.name()))); throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot delete current branch"); case IO_FAILURE : case LOCK_FAILURE : case NOT_ATTEMPTED : case REJECTED : case RENAMED : default : com.google.gerrit.server.project.DeleteBranch.log.error(((("Cannot delete " + (rsrc.getBranchKey())) + ": ") + (result.name()))); throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("cannot delete branch: " + (result.name()))); } } return com.google.gerrit.extensions.restapi.Response.none(); }

@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) { if ((message) == null) { return; } if ((in.notify.compareTo(NotifyHandling.NONE)) > 0) { email.create(in.notify, notes, ps, user, message, comments).sendAsync(); } commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen()); }
@org.junit.Test public void publishEdit() throws java.lang.Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); assertThat(modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED); editUtil.publish(editUtil.byChange(change).get(), NotifyHandling.NONE); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); assertThat(edit.isPresent()).isFalse(); assertChangeMessages(change, com.google.common.collect.ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2.")); }
@org.junit.Test public void editCommitMessageCopiesLabelScores() throws java.lang.Exception { java.lang.String cr = "Code-Review"; com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.common.data.LabelType codeReview = com.google.gerrit.server.project.Util.codeReview(); codeReview.setCopyAllScoresIfNoCodeChange(true); cfg.getLabelSections().put(cr, codeReview); saveProjectConfig(project, cfg); java.lang.String changeId = change.getKey().get(); com.google.gerrit.extensions.api.changes.ReviewInput r = new com.google.gerrit.extensions.api.changes.ReviewInput(); r.labels = com.google.common.collect.ImmutableMap.<java.lang.String, java.lang.Short>of(cr, ((short) (1))); gApi.changes().id(changeId).revision(change.currentPatchSetId().get()).review(r); assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); java.lang.String newSubj = "New commit message"; java.lang.String newMsg = ((newSubj + "\n\nChange-Id: ") + changeId) + "\n"; assertThat(modifier.modifyMessage(edit.get(), newMsg)).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); editUtil.publish(edit.get(), NotifyHandling.NONE); ChangeInfo info = get(changeId); assertThat(info.subject).isEqualTo(newSubj); java.util.List<com.google.gerrit.extensions.common.ApprovalInfo> approvals = info.labels.get(cr).all; assertThat(approvals).hasSize(1); assertThat(approvals.get(0).value).isEqualTo(1); }
@org.junit.Test public void updateMessage() throws java.lang.Exception { assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); java.lang.String msg = java.lang.String.format("New commit message\n\nChange-Id: %s\n", change.getKey()); assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED); edit = editUtil.byChange(change); assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg); editUtil.publish(edit.get(), NotifyHandling.NONE); assertThat(editUtil.byChange(change).isPresent()).isFalse(); ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION); assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg); assertChangeMessages(change, com.google.common.collect.ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Commit message was updated.")); }
@org.junit.Test public void testHasEditPredicate() throws java.lang.Exception { assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); assertThat(queryEdits()).hasSize(1); com.google.gerrit.reviewdb.client.PatchSet current = getCurrentPatchSet(changeId2); assertThat(modifier.createEdit(change2, current)).isEqualTo(RefUpdate.Result.NEW); assertThat(modifier.modifyFile(editUtil.byChange(change2).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED); assertThat(queryEdits()).hasSize(2); assertThat(modifier.modifyFile(editUtil.byChange(change).get(), com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME, com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED); editUtil.delete(editUtil.byChange(change).get()); assertThat(queryEdits()).hasSize(1); editUtil.publish(editUtil.byChange(change2).get(), NotifyHandling.NONE); assertThat(queryEdits()).hasSize(0); setApiUser(user); assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW); assertThat(queryEdits()).hasSize(1); setApiUser(admin); assertThat(queryEdits()).hasSize(0); }

com.google.gerrit.server.git.AbandonOp create(@com.google.inject.assistedinject.Assisted @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account, @com.google.inject.assistedinject.Assisted @com.google.gerrit.common.Nullable java.lang.String msgTxt, @com.google.inject.assistedinject.Assisted com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling);
protected void init() throws com.google.gerrit.common.errors.EmailException { setupVelocityContext(); setupSoyContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new com.google.gerrit.server.mail.send.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); setHeader("Message-ID", ""); if ((fromId) != null) { final com.google.gerrit.server.mail.Address a = toAddress(fromId); if ((a != null) && (!(smtpFromAddress.getEmail().equals(a.getEmail())))) { setHeader("Reply-To", a.getEmail()); } } setHeader("X-Gerrit-MessageType", messageClass); textBody = new java.lang.StringBuilder(); htmlBody = new java.lang.StringBuilder(); if (((fromId) != null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { appendText(getFromLine()); } }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.project.ChangeControl control, java.lang.String msgTxt) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { return abandon(control, msgTxt, NotifyHandling.ALL); }
public void batchAbandon(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.CurrentUser user, java.util.Collection<com.google.gerrit.server.project.ChangeControl> controls) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { batchAbandon(project, user, controls, "", NotifyHandling.ALL); }
public void batchAbandon(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.CurrentUser user, java.util.Collection<com.google.gerrit.server.project.ChangeControl> controls, java.lang.String msgTxt) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { batchAbandon(project, user, controls, msgTxt, NotifyHandling.ALL); }
com.google.gerrit.server.change.PostReviewers.Addition ccCurrentUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.change.RevisionResource revision) { return new com.google.gerrit.server.change.PostReviewers.Addition(user.getUserName(), revision.getChangeResource(), com.google.common.collect.ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, com.google.gerrit.extensions.api.changes.NotifyHandling.NONE); }

@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { if ((notify) != (com.google.gerrit.extensions.api.changes.NotifyHandling.NONE)) { try { com.google.gerrit.server.mail.send.ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId()); cm.setFrom(ctx.getAccountId()); cm.setPatchSet(patchSet, patchSetInfo); cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen()); cm.addReviewers(oldReviewers.byState(com.google.gerrit.server.change.REVIEWER)); cm.addExtraCC(oldReviewers.byState(com.google.gerrit.server.change.CC)); cm.setNotify(notify); cm.send(); } catch (java.lang.Exception err) { com.google.gerrit.server.change.PatchSetInserter.log.error(("Cannot send email for new patch set on change " + (change.getId())), err); } } if (fireRevisionCreated) { revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify); } }

public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.project.ChangeControl control) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { return abandon(control, "", NotifyHandling.ALL); }

com.google.gerrit.extensions.common.CommitInfo toCommit(com.google.gerrit.server.project.ChangeControl ctl, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, boolean addLinks, boolean fillCommit) throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = ctl.getProject().getNameKey(); com.google.gerrit.extensions.common.CommitInfo info = new com.google.gerrit.extensions.common.CommitInfo(); if (fillCommit) { info.commit = commit.name(); } info.parents = new java.util.ArrayList(commit.getParentCount()); info.author = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getAuthorIdent()); info.committer = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getCommitterIdent()); info.subject = commit.getShortMessage(); info.message = commit.getFullMessage(); if (addLinks) { com.google.common.collect.FluentIterable<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name()); info.webLinks = (links.isEmpty()) ? null : links.toList(); } for (org.eclipse.jgit.revwalk.RevCommit parent : commit.getParents()) { rw.parseBody(parent); com.google.gerrit.extensions.common.CommitInfo i = new com.google.gerrit.extensions.common.CommitInfo(); i.commit = parent.name(); i.subject = parent.getShortMessage(); info.parents.add(i); } return info; }
protected void setCacheHeaders(javax.servlet.http.HttpServletResponse res) { com.google.gitiles.BaseServlet.setNotCacheable(res); }
public void onImport(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Project.NameKey srcProject, com.google.gerrit.reviewdb.client.Project.NameKey targetProject, java.lang.String from, java.lang.Exception ex) { long ts = com.google.gerrit.common.TimeUtil.nowMs(); org.apache.log4j.spi.LoggingEvent event = new org.apache.log4j.spi.LoggingEvent(org.apache.log4j.Logger.class.getName(), com.googlesource.gerrit.plugins.importer.ImportLog.log, ts, (ex == null ? org.apache.log4j.Level.INFO : org.apache.log4j.Level.ERROR), (ex == null ? "OK" : "FAIL"), java.lang.Thread.currentThread().getName(), null, null, null, null); event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.ACCOUNT_ID, user.getAccountId().toString()); event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.USER_NAME, user.getUserName()); if (from != null) { event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.FROM, from); } else { event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.FROM, canonicalWebUrl); } event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.SRC_PROJECT_NAME, srcProject.get()); event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.TARGET_PROJECT_NAME, targetProject.get()); if (ex != null) { event.setProperty(com.googlesource.gerrit.plugins.importer.ImportLog.ERROR, ex.toString()); } com.googlesource.gerrit.plugins.importer.ImportLog.log.callAppenders(event); audit(user, ts, srcProject, from, ex); }
com.google.gerrit.extensions.common.CommitInfo toCommit(com.google.gerrit.server.project.ChangeControl ctl, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, boolean addLinks, boolean fillCommit) throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = ctl.getProject().getNameKey(); com.google.gerrit.extensions.common.CommitInfo info = new com.google.gerrit.extensions.common.CommitInfo(); if (fillCommit) { info.commit = commit.name(); } info.parents = new java.util.ArrayList(commit.getParentCount()); info.author = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getAuthorIdent()); info.committer = com.google.gerrit.server.CommonConverters.toGitPerson(commit.getCommitterIdent()); info.subject = commit.getShortMessage(); info.message = commit.getFullMessage(); if (addLinks) { com.google.common.collect.FluentIterable<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name()); info.webLinks = (links.isEmpty()) ? null : links.toList(); } for (org.eclipse.jgit.revwalk.RevCommit parent : commit.getParents()) { rw.parseBody(parent); com.google.gerrit.extensions.common.CommitInfo i = new com.google.gerrit.extensions.common.CommitInfo(); i.commit = parent.name(); i.subject = parent.getShortMessage(); info.parents.add(i); } return info; }


@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); boolean hasComments = false; try (org.eclipse.jgit.lib.Repository repo = getRepository()) { java.util.List<java.util.Map<java.lang.String, java.lang.Object>> files = getCommentGroupsTemplateData(repo); soyContext.put("commentFiles", files); hasComments = !(files.isEmpty()); } soyContext.put("commentTimestamp", getCommentTimestamp()); soyContext.put("coverLetterBlocks", commentBlocksToSoyData(com.google.gerrit.server.mail.send.CommentFormatter.parse(getCoverLetter()))); footers.add(("Gerrit-Comment-Date: " + (getCommentTimestamp()))); footers.add(("Gerrit-HasComments: " + (hasComments ? "Yes" : "No"))); }
@org.junit.BeforeClass public static void startIndexService() throws java.lang.InterruptedException, java.util.concurrent.ExecutionException { if ((com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.nodeInfo) != null) { return; } com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.nodeInfo = com.google.gerrit.elasticsearch.ElasticTestUtils.startElasticsearchNode(); com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.createIndexes(); }
static void deleteIndexes(org.elasticsearch.node.Node node, java.lang.String index) { node.client().admin().indices().prepareDelete(index).execute(); }
@org.junit.After public void cleanupIndex() { if ((com.google.gerrit.elasticsearch.ElasticQueryChangesTest.nodeInfo) != null) { com.google.gerrit.elasticsearch.ElasticTestUtils.deleteIndexes(com.google.gerrit.elasticsearch.ElasticQueryChangesTest.nodeInfo.node, com.google.gerrit.elasticsearch.ElasticQueryChangesTest.INDEX_NAME); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.createIndexes(); } }
@org.junit.BeforeClass public static void startIndexService() throws java.lang.InterruptedException, java.util.concurrent.ExecutionException { if ((com.google.gerrit.elasticsearch.ElasticQueryChangesTest.nodeInfo) != null) { return; } com.google.gerrit.elasticsearch.ElasticQueryChangesTest.nodeInfo = com.google.gerrit.elasticsearch.ElasticTestUtils.startElasticsearchNode(); com.google.gerrit.elasticsearch.ElasticQueryChangesTest.createIndexes(); }
@org.junit.After public void cleanupIndex() { if ((com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.nodeInfo) != null) { com.google.gerrit.elasticsearch.ElasticTestUtils.deleteIndexes(com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.nodeInfo.node, com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.INDEX_NAME); com.google.gerrit.elasticsearch.ElasticQueryAccountsTest.createIndexes(); } }
public void loadConfig() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { config = new com.googlesource.gerrit.plugins.automerger.LoadedConfig(gApi, configProject, configProjectBranch, configFilename, configOptionKeys); }


@org.junit.Before public void setUp() throws java.lang.Exception { group1 = group("users1"); group2 = group("users2"); group3 = group("users3"); user1 = user("user1", "First1 Last1", group1); user2 = user("user2", "First2 Last2", group2); user3 = user("user3", "First3 Last3", group1, group2); user4 = user("jdoe", "John Doe", "JDOE"); }

@org.junit.Test public void suggestReviewersFullTextSearch() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> reviewers; reviewers = suggestReviewers(changeId, "first", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "first1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "last", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "last1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "fi la", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "la fi", 4); assertThat(reviewers).hasSize(3); reviewers = suggestReviewers(changeId, "first1 la", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "fi last1", 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "first1 last2", 1); assertThat(reviewers).hasSize(0); reviewers = suggestReviewers(changeId, name("user"), 7); assertThat(reviewers).hasSize(6); reviewers = suggestReviewers(changeId, user1.username, 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, "example.com", 7); assertThat(reviewers).hasSize(6); reviewers = suggestReviewers(changeId, user1.email, 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, ((user1.username) + " example"), 2); assertThat(reviewers).hasSize(1); reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2); assertThat(reviewers).hasSize(1); assertThat(reviewers.get(0).account.email).isEqualTo(user4.email); }
protected void allow(java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, java.lang.String ref) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, permission, id, ref); saveProjectConfig(project, cfg); }

@org.junit.After public void tearDown() { plugin.stop(env); env.onStopPlugin(plugin); }

@org.junit.After public void restoreExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(getExternalIds(admin)); db.accountExternalIds().delete(getExternalIds(user)); db.accountExternalIds().insert(savedExternalIds); accountCache.evict(admin.getId()); accountCache.evict(user.getId()); }
@java.lang.Override public void start() { int cpus = java.lang.Runtime.getRuntime().availableProcessors(); if (config.getBoolean("cache", "projects", "loadOnStartup", false)) { final java.util.concurrent.ThreadPoolExecutor pool = new java.util.concurrent.ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build()); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("Loading project cache"); pool.execute(new java.lang.Runnable() { @java.lang.Override public void run() { for (final com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { pool.execute(new java.lang.Runnable() { @java.lang.Override public void run() { cache.get(name); } }); } pool.shutdown(); } }); } }
@java.lang.Override public void run() { for (final com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { pool.execute(new java.lang.Runnable() { @java.lang.Override public void run() { cache.get(name); } }); } pool.shutdown(); }
@org.junit.Test public void flushAll() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get("/config/server/caches/project_list"); com.google.gerrit.server.config.ListCaches.CacheInfo cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (0))); r = adminRestSession.post("/config/server/caches/", new com.google.gerrit.server.config.PostCaches.Input(FLUSH_ALL)); r.assertOK(); r.consume(); r = adminRestSession.get("/config/server/caches/project_list"); cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isNull(); }
@org.junit.Test public void flush() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get("/config/server/caches/project_list"); com.google.gerrit.server.config.ListCaches.CacheInfo cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (0))); r = adminRestSession.get("/config/server/caches/projects"); cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (1))); r = adminRestSession.post("/config/server/caches/", new com.google.gerrit.server.config.PostCaches.Input(FLUSH, java.util.Arrays.asList("accounts", "project_list"))); r.assertOK(); r.consume(); r = adminRestSession.get("/config/server/caches/project_list"); cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isNull(); r = adminRestSession.get("/config/server/caches/projects"); cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (1))); }
@org.junit.Test public void flush_UnprocessableEntity() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get("/config/server/caches/projects"); com.google.gerrit.server.config.ListCaches.CacheInfo cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (0))); r = adminRestSession.post("/config/server/caches/", new com.google.gerrit.server.config.PostCaches.Input(FLUSH, java.util.Arrays.asList("projects", "unprocessable"))); r.assertUnprocessableEntity(); r.consume(); r = adminRestSession.get("/config/server/caches/projects"); cacheInfo = newGson().fromJson(r.getReader(), com.google.gerrit.server.config.ListCaches.CacheInfo.class); assertThat(cacheInfo.entries.mem).isGreaterThan(((long) (0))); }


@java.lang.Override public void setList(java.lang.String section, java.lang.String subsection, java.lang.String name, java.util.List<java.lang.String> values) { if (values != null) { sec.setStringList(section, subsection, name, values.stream().map(codec::encode).collect(java.util.stream.Collectors.toList())); } else { sec.unset(section, subsection, name); } save(); }
@java.lang.Override public java.lang.String[] getList(java.lang.String section, java.lang.String subsection, java.lang.String name) { return java.util.Arrays.stream(sec.getStringList(section, subsection, name)).map(codec::decode).toArray(java.lang.String[]::new); }
@java.lang.Override public synchronized java.lang.String[] getListForPlugin(java.lang.String pluginName, java.lang.String section, java.lang.String subsection, java.lang.String name) { org.eclipse.jgit.storage.file.FileBasedConfig cfg = null; if (pluginSec.containsKey(pluginName)) { cfg = pluginSec.get(pluginName); } else { java.lang.String filename = pluginName + ".secure.config"; java.io.File pluginConfigFile = site.etc_dir.resolve(filename).toFile(); if (pluginConfigFile.exists()) { cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(pluginConfigFile, org.eclipse.jgit.util.FS.DETECTED); try { cfg.load(); pluginSec.put(pluginName, cfg); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(("Cannot load " + filename), e); } } } return cfg != null ? com.google.common.collect.FluentIterable.from(cfg.getStringList(section, subsection, name)).transform(codec::decode).toArray(java.lang.String.class) : null; }
private java.util.Collection<com.google.gerrit.extensions.common.AccountInfo> suggestAccounts(com.google.gerrit.server.change.SuggestReviewers suggestReviewers, com.google.gerrit.server.ReviewersUtil.VisibilityControl visibilityControl) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.index.account.AccountIndex searchIndex = indexes.getSearchIndex(); if (searchIndex != null) { return suggestAccountsFromIndex(suggestReviewers); } return suggestAccountsFromDb(suggestReviewers, visibilityControl); }
public void upsertProjectWatches(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> newProjectWatches) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.server.account.WatchConfig watchConfig = open(accountId)) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> projectWatches = watchConfig.getProjectWatches(); projectWatches.putAll(newProjectWatches); commit(watchConfig); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, java.util.List<com.google.gerrit.extensions.client.ProjectWatchInfo> input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException(("It is not allowed to edit project watches " + "of other users")); } if (input == null) { return com.google.gerrit.extensions.restapi.Response.none(); } com.google.gerrit.reviewdb.client.Account.Id accountId = rsrc.getUser().getAccountId(); deleteFromDb(accountId, input); deleteFromGit(accountId, input); accountCache.evict(accountId); return com.google.gerrit.extensions.restapi.Response.none(); }
public void deleteProjectWatches(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey> projectWatchKeys) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.server.account.WatchConfig watchConfig = open(accountId)) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> projectWatches = watchConfig.getProjectWatches(); for (com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key : projectWatchKeys) { projectWatches.remove(key); } commit(watchConfig); } }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if (((commit.getMessage()) == null) || ("".equals(commit.getMessage()))) { commit.setMessage("Updated watch configuration\n"); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.WatchConfig.WATCH_CONFIG); com.google.gerrit.server.account.WatchConfig.clearSection(cfg, com.google.gerrit.server.account.WatchConfig.PROJECT); for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> e : projectWatches.entrySet()) { if (e.getValue().isEmpty()) { cfg.setString(com.google.gerrit.server.account.WatchConfig.PROJECT, e.getKey().toString(), com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY, com.google.gerrit.server.account.WatchConfig.NOTIFY_NONE); } else { java.util.List<java.lang.String> notifyValues = com.google.common.collect.FluentIterable.from(e.getValue()).transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType notify) { return notify.name(); } }).toList(); cfg.setStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, e.getKey().toString(), com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY, notifyValues); } } saveConfig(com.google.gerrit.server.account.WatchConfig.WATCH_CONFIG, cfg); return true; }

public java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> getProjectWatches(com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);com.google.gerrit.server.account.WatchConfig watchConfig = new com.google.gerrit.server.account.WatchConfig(accountId)) { watchConfig.load(git); return watchConfig.getProjectWatches(); } }
java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Collection<com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType>> getProjectWatches() { checkLoaded(); return projectWatches; }
@org.junit.Before public void setUp() throws java.lang.Exception { executorMock = createStrictMock(WorkQueue.Executor.class); com.google.gerrit.server.git.WorkQueue workQueueMock = createNiceMock(com.google.gerrit.server.git.WorkQueue.class); expect(workQueueMock.createQueue(4, (("Evict cache [" + (pluginName)) + " plugin]"))).andReturn(executorMock); com.ericsson.gerrit.plugins.evictcache.Configuration configMock = createStrictMock(com.ericsson.gerrit.plugins.evictcache.Configuration.class); expect(configMock.getThreadPoolSize()).andReturn(4); replayAll(); evictCacheExecutorProvider = new com.ericsson.gerrit.plugins.evictcache.EvictCacheExecutorProvider(workQueueMock, pluginName, configMock); }
@org.junit.Before public void setUp() throws java.lang.Exception { cfg = createMock(com.ericsson.gerrit.plugins.evictcache.Configuration.class); expect(cfg.getUrl()).andReturn(Constants.URL).anyTimes(); expect(cfg.getUser()).andReturn("user"); expect(cfg.getPassword()).andReturn("pass"); expect(cfg.getMaxTries()).andReturn(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.MAX_TRIES).anyTimes(); expect(cfg.getConnectionTimeout()).andReturn(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.TIMEOUT).anyTimes(); expect(cfg.getSocketTimeout()).andReturn(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.TIMEOUT).anyTimes(); expect(cfg.getRetryInterval()).andReturn(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.RETRY_INTERVAL).anyTimes(); replayAll(); httpClient = new com.ericsson.gerrit.plugins.evictcache.HttpClientProvider(cfg).get(); httpSession = new com.ericsson.gerrit.plugins.evictcache.HttpSession(httpClient, Constants.URL); }
@org.junit.Test public void testNotFound() throws java.lang.Exception { java.lang.String expected = "not found"; stubFor(post(urlEqualTo(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.ENDPOINT)).willReturn(aResponse().withStatus(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.NOT_FOUND).withBody(expected))); com.ericsson.gerrit.plugins.evictcache.CacheResponseHandler.CacheResult result = httpSession.post(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.ENDPOINT, com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.EMPTYJSON); assertThat(result.isSuccessful()).isFalse(); assertThat(result.getMessage()).isEqualTo(expected); }
@org.junit.Test public void testNotAuthorized() throws java.lang.Exception { java.lang.String expected = "unauthorized"; stubFor(post(urlEqualTo(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.ENDPOINT)).willReturn(aResponse().withStatus(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.UNAUTHORIZED).withBody(expected))); com.ericsson.gerrit.plugins.evictcache.CacheResponseHandler.CacheResult result = httpSession.post(com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.ENDPOINT, com.ericsson.gerrit.plugins.evictcache.HttpSessionTest.EMPTYJSON); assertThat(result.isSuccessful()).isFalse(); assertThat(result.getMessage()).isEqualTo(expected); }
@org.junit.Test public void testRightEventAndNotForwarded() throws java.lang.Exception { setUpMocks(true, true); resetAll(); expect(restClient.send(event)).andReturn(true); replayAll(); eventHandler.onEvent(event); verifyAll(); }
@org.junit.Test public void testRightEventBitItIsForwarded() throws java.lang.Exception { setUpMocks(false, true); com.ericsson.gerrit.plugins.syncevents.Context.setForwardedEvent(); eventHandler.onEvent(event); com.ericsson.gerrit.plugins.syncevents.Context.unsetForwardedEvent(); verifyAll(); }
private void setUpMocks(boolean mockRestClient, boolean rightEvent) { pool = new com.ericsson.gerrit.plugins.syncevents.EventHandlerTest.PoolMock(1); if (mockRestClient) { restClient = createMock(com.ericsson.gerrit.plugins.syncevents.RestSession.class); } else { restClient = null; } if (rightEvent) { event = createNiceMock(com.google.gerrit.server.events.RefEvent.class); } else { event = createNiceMock(com.google.gerrit.server.events.Event.class); } replayAll(); eventHandler = new com.ericsson.gerrit.plugins.syncevents.EventHandler(restClient, pool, com.ericsson.gerrit.plugins.syncevents.EventHandlerTest.PLUGIN_NAME); }
@org.junit.Test public void testBadEventAndItIsForwarded() throws java.lang.Exception { setUpMocks(false, false); com.ericsson.gerrit.plugins.syncevents.Context.setForwardedEvent(); eventHandler.onEvent(event); com.ericsson.gerrit.plugins.syncevents.Context.unsetForwardedEvent(); verifyAll(); }
@org.junit.Test public void testBadEventAndNotForwarded() throws java.lang.Exception { setUpMocks(false, false); eventHandler.onEvent(event); verifyAll(); }
@org.junit.Before public void setUp() throws java.lang.Exception { cfg = createMock(com.ericsson.gerrit.plugins.syncevents.Configuration.class); expect(cfg.getUrl()).andReturn(com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.URL).anyTimes(); expect(cfg.getUser()).andReturn("user"); expect(cfg.getPassword()).andReturn("pass"); expect(cfg.getMaxTries()).andReturn(com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.MAX_TRIES).anyTimes(); expect(cfg.getConnectionTimeout()).andReturn(com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.TIMEOUT).anyTimes(); expect(cfg.getSocketTimeout()).andReturn(com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.TIMEOUT).anyTimes(); expect(cfg.getRetryInterval()).andReturn(com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.RETRY_INTERVAL).anyTimes(); replayAll(); httpClient = new com.ericsson.gerrit.plugins.syncevents.HttpClientProvider(cfg).get(); httpSession = new com.ericsson.gerrit.plugins.syncevents.HttpSession(httpClient, com.ericsson.gerrit.plugins.syncevents.HttpSessionTest.URL); }
@org.junit.Before public void setUp() { storeMock = easyMock.createMock(com.ericsson.gerrit.plugins.eventslog.EventStore.class); }
@java.lang.SuppressWarnings("unchecked") @org.junit.Before public void setUp() throws java.sql.SQLException { conn = java.sql.DriverManager.getConnection(path); stat = conn.createStatement(); results = new java.util.ArrayList(); poolMock = new com.ericsson.gerrit.plugins.eventslog.sql.SQLStoreTest.PoolMock(1); easyMock = new org.easymock.EasyMockSupport(); pcFactoryMock = easyMock.createNiceMock(ProjectControl.GenericFactory.class); userProviderMock = easyMock.createNiceMock(com.google.inject.Provider.class); cfgMock = easyMock.createNiceMock(com.ericsson.gerrit.plugins.eventslog.EventsLogConfig.class); expect(cfgMock.getMaxAge()).andReturn(5); expect(cfgMock.getLocalStorePath()).andReturn(testFolder.getRoot().toPath()).atLeastOnce(); }
public void atomicDelete(com.google.gerrit.reviewdb.client.Project project) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().byProject(project.getNameKey()); deleteChanges(changes); db.accountProjectWatches().delete(db.accountProjectWatches().byProject(project.getNameKey())); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { if (input == null) { input = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); } if (((input.label) != null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("label must match URL"); } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(r.getReviewerUser().getAccountId(), rsrc.getLabel(), input)); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }

private java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategy> getSubmitStrategies(java.util.Map<com.google.gerrit.reviewdb.client.Branch.NameKey, com.google.gerrit.server.git.MergeOp.BranchBatch> toSubmit, com.google.gerrit.server.git.SubmoduleOp submoduleOp) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategy> strategies = new java.util.ArrayList<>(); java.util.Set<com.google.gerrit.reviewdb.client.Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder(); if (allBranches == null) { allBranches = toSubmit.keySet(); } for (com.google.gerrit.reviewdb.client.Branch.NameKey branch : allBranches) { com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo or = orm.getRepo(branch.getParentKey()); if (toSubmit.containsKey(branch)) { com.google.gerrit.server.git.MergeOp.BranchBatch submitting = toSubmit.get(branch); com.google.gerrit.server.git.MergeOpRepoManager.OpenBranch ob = or.getBranch(branch); checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting); java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> commitsToSubmit = commits(submitting.changes()); ob.mergeTip = new com.google.gerrit.server.git.MergeTip(ob.oldTip, commitsToSubmit); com.google.gerrit.server.git.strategy.SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp); strategies.add(strategy); strategy.addOps(or.getUpdate(), commitsToSubmit); } else { submoduleOp.addOp(or.getUpdate(), branch); } } return strategies; }
public static java.lang.String messageUUID(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { int p; int s; synchronized(com.google.gerrit.server.ChangeUtil.uuidLock) { if ((com.google.gerrit.server.ChangeUtil.uuidSeq) == 0) { com.google.gerrit.server.ChangeUtil.uuidPrefix = db.nextChangeMessageId(); com.google.gerrit.server.ChangeUtil.uuidSeq = java.lang.Integer.MAX_VALUE; } p = com.google.gerrit.server.ChangeUtil.uuidPrefix; s = (com.google.gerrit.server.ChangeUtil.uuidSeq)--; } java.lang.String u = com.google.gerrit.server.util.IdGenerator.format(com.google.gerrit.server.util.IdGenerator.mix(com.google.gerrit.server.ChangeUtil.SEED, p)); java.lang.String l = com.google.gerrit.server.util.IdGenerator.format(com.google.gerrit.server.util.IdGenerator.mix(p, s)); return (u + '_') + l; }
public com.google.gerrit.reviewdb.client.Comment newComment(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, java.lang.String path, com.google.gerrit.reviewdb.client.PatchSet.Id psId, short side, java.lang.String message) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Comment c = new com.google.gerrit.reviewdb.client.Comment(new com.google.gerrit.reviewdb.client.Comment.Key(com.google.gerrit.server.ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, false); ctx.getUser().updateRealAccountId(c::setRealAuthor); return c; }
public java.util.Optional<com.googlesource.gerrit.plugins.manager.gson.SmartJson> getOptional(java.lang.String fieldName) { if (((jsonElem) != null) && ((jsonElem.getAsJsonObject().get(fieldName)) != null)) { return java.util.Optional.of(com.googlesource.gerrit.plugins.manager.gson.SmartJson.of(jsonElem.getAsJsonObject().get(fieldName))); } else { return java.util.Optional.empty(); } }
public com.google.common.base.Optional<com.googlesource.gerrit.plugins.manager.gson.SmartJson> getOptional(java.lang.String fieldName) { if (((jsonElem) != null) && ((jsonElem.getAsJsonObject().get(fieldName)) != null)) { return com.google.common.base.Optional.of(com.googlesource.gerrit.plugins.manager.gson.SmartJson.of(jsonElem.getAsJsonObject().get(fieldName))); } else { return com.google.common.base.Optional.absent(); } }
public java.lang.String generateToken(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { if (key.isPresent()) { try { byte[] initVector = new byte[com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.IV_LENGTH]; rndm.nextBytes(initVector); javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.ENCRYPT_MODE); return org.eclipse.jgit.util.Base64.encodeBytes(com.google.common.primitives.Bytes.concat(initVector, cipher.doFinal(java.lang.String.format("%s-%s-%s", operation, id.name(), timeout()).getBytes(java.nio.charset.StandardCharsets.UTF_8)))); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.log.error("Token generation failed with error", e); } } return "not:required"; }
private java.lang.String timeout() { org.joda.time.DateTime now = now(); return org.joda.time.format.ISODateTimeFormat.dateTime().print(now.plusSeconds(timeout)); }









@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.account.AccountIndexRewriter.class); bind(com.google.gerrit.server.index.account.AccountIndexCollection.class); listener().to(com.google.gerrit.server.index.account.AccountIndexCollection.class); factory(AccountIndexerImpl.Factory.class); bind(com.google.gerrit.server.index.change.ChangeIndexRewriter.class); bind(com.google.gerrit.server.index.change.ChangeIndexCollection.class); listener().to(com.google.gerrit.server.index.change.ChangeIndexCollection.class); factory(ChangeIndexer.Factory.class); }

public static java.util.Set<java.lang.String> getPersonParts(java.lang.String name, java.lang.Iterable<java.lang.String> emails) { com.google.common.base.Splitter at = com.google.common.base.Splitter.on('@'); com.google.common.base.Splitter s = com.google.common.base.Splitter.on(com.google.common.base.CharMatcher.anyOf("@.- ")).omitEmptyStrings(); java.util.HashSet<java.lang.String> parts = new java.util.HashSet<>(); for (java.lang.String email : emails) { if (email == null) { continue; } java.lang.String lowerEmail = email.toLowerCase(); parts.add(lowerEmail); com.google.common.collect.Iterables.addAll(parts, at.split(lowerEmail)); com.google.common.collect.Iterables.addAll(parts, s.split(lowerEmail)); } if (name != null) { com.google.common.collect.Iterables.addAll(parts, s.split(name.toLowerCase())); } return parts; }


@java.lang.Override public void evictAfterRename(final com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName, final com.google.gerrit.reviewdb.client.AccountGroup.NameKey newName) { if (oldName != null) { byName.invalidate(oldName.get()); } if (newName != null) { byName.invalidate(newName.get()); } }
@java.lang.Override public void evict(final com.google.gerrit.reviewdb.client.AccountGroup group) { if ((group.getId()) != null) { byId.invalidate(group.getId()); } if ((group.getNameKey()) != null) { byName.invalidate(group.getNameKey().get()); } if ((group.getGroupUUID()) != null) { byUUID.invalidate(group.getGroupUUID().get()); } }
private java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> list(com.google.gerrit.server.api.groups.ListRequest req) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.restapi.TopLevelResource tlr = com.google.gerrit.extensions.restapi.TopLevelResource.INSTANCE; com.google.gerrit.server.group.ListGroups list = listGroups.get(); list.setOptions(req.getOptions()); for (java.lang.String project : req.getProjects()) { try { list.addProject(projects.parse(tlr, com.google.gerrit.extensions.restapi.IdString.fromDecoded(project)).getControl()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException(("Error looking up project " + project), e); } } for (java.lang.String group : req.getGroups()) { list.addGroup(groups.parse(group).getGroupUUID()); } list.setVisibleToAll(req.getVisibleToAll()); if ((req.getUser()) != null) { try { list.setUser(accounts.parse(req.getUser()).getAccountId()); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException(("Error looking up user " + (req.getUser())), e); } } list.setOwned(req.getOwned()); list.setLimit(req.getLimit()); list.setStart(req.getStart()); list.setMatchSubstring(req.getSubstring()); list.setSuggest(req.getSuggest()); try { return list.apply(tlr); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot list groups", e); } }

void display(final java.io.PrintWriter out) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { final com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(out, '\t'); for (final com.google.gerrit.extensions.common.GroupInfo info : get()) { formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(info.name, "n/a")); if (verboseOutput) { com.google.gerrit.reviewdb.client.AccountGroup o = ((info.ownerId) != null) ? groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.extensions.restapi.Url.decode(info.ownerId))) : null; formatter.addColumn(com.google.gerrit.extensions.restapi.Url.decode(info.id)); formatter.addColumn(com.google.common.base.Strings.nullToEmpty(info.description)); formatter.addColumn((o != null ? o.getName() : "n/a")); formatter.addColumn((o != null ? o.getGroupUUID().get() : "")); formatter.addColumn(java.lang.Boolean.toString(com.google.common.base.MoreObjects.firstNonNull(info.options.visibleToAll, java.lang.Boolean.FALSE))); } formatter.nextLine(); } formatter.finish(); }

@java.lang.Override public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> output = new java.util.TreeMap<>(); for (com.google.gerrit.extensions.common.GroupInfo info : get()) { output.put(com.google.common.base.MoreObjects.firstNonNull(info.name, ("Group " + (com.google.gerrit.extensions.restapi.Url.decode(info.id)))), info); info.name = null; } return output; }










@org.junit.Test public void noExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(db.accountExternalIds().byAccount(user.getAccountId())); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, ("No identities found for user; check" + " http://test/#/settings/web-identities")); checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users"); db.accountExternalIds().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey())))); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user"); }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.AccountExternalId.Key> call() throws com.google.gwtorm.server.OrmException, java.io.IOException { final java.util.Map<com.google.gerrit.reviewdb.client.AccountExternalId.Key, com.google.gerrit.reviewdb.client.AccountExternalId> have = have(); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> toDelete = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId.Key k : keys) { final com.google.gerrit.reviewdb.client.AccountExternalId id = have.get(k); if ((id != null) && (id.canDelete())) { toDelete.add(id); } } if (!(toDelete.isEmpty())) { db.accountExternalIds().delete(toDelete); accountCache.evict(user.getAccountId()); for (com.google.gerrit.reviewdb.client.AccountExternalId e : toDelete) { byEmailCache.evict(e.getEmailAddress()); } } return toKeySet(toDelete); }

private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.AccountExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); db.accountExternalIds().delete(java.util.Collections.singleton(extId)); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to)); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.size()) > 1) || (!(filteredKeysByScheme.contains(key))))) { db.accountExternalIds().deleteKeys(filteredKeysByScheme); } byIdCache.evict(to); return link(to, who); } }
@org.junit.After public void restoreExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(getExternalIds(admin)); db.accountExternalIds().delete(getExternalIds(user)); db.accountExternalIds().insert(savedExternalIds); accountCache.evict(admin.getId()); accountCache.evict(user.getId()); }




public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId extId = getAccountExternalId(key); if (extId != null) { if (!(extId.getAccountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (key.get())) + "' in use by another account")); } db.accountExternalIds().delete(java.util.Collections.singleton(extId)); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (key.get())) + "' not found")); } return new com.google.gerrit.server.account.AuthResult(from, key, false); } }




public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username must be set"); } com.google.gerrit.reviewdb.client.AccountExternalId id = dbProvider.get().accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, user.getUserName())); if (id == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } id.setPassword(newPassword); dbProvider.get().accountExternalIds().update(java.util.Collections.singleton(id)); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }


public static com.google.gerrit.testutil.NoteDbMode get() { java.lang.String value = java.lang.System.getenv(com.google.gerrit.testutil.NoteDbMode.VAR); if (com.google.common.base.Strings.isNullOrEmpty(value)) { return com.google.gerrit.testutil.NoteDbMode.OFF; } value = value.toUpperCase().replace("-", "_"); com.google.gerrit.testutil.NoteDbMode mode = com.google.common.base.Enums.getIfPresent(com.google.gerrit.testutil.NoteDbMode.class, value).orNull(); checkArgument((mode != null), "Invalid value for %s: %s", com.google.gerrit.testutil.NoteDbMode.VAR, java.lang.System.getenv(com.google.gerrit.testutil.NoteDbMode.VAR)); return mode; }
public static com.google.gerrit.testutil.SshMode get() { java.lang.String value = java.lang.System.getenv(com.google.gerrit.testutil.SshMode.VAR); if (com.google.common.base.Strings.isNullOrEmpty(value)) { return com.google.gerrit.testutil.SshMode.YES; } value = value.toUpperCase(); com.google.gerrit.testutil.SshMode mode = com.google.common.base.Enums.getIfPresent(com.google.gerrit.testutil.SshMode.class, value).orNull(); checkArgument((mode != null), "Invalid value for %s: %s", com.google.gerrit.testutil.SshMode.VAR, java.lang.System.getenv(com.google.gerrit.testutil.SshMode.VAR)); return mode; }


@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { if ((self.get()) != (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get external IDs"); } java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = externalIdCache.byAccount(resource.getUser().getAccountId()); if (ids.isEmpty()) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(ids.size()); for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.getExternalId(); info.emailAddress = id.getEmailAddress(); info.trusted = authConfig.isIdentityTrustable(java.util.Collections.singleton(id)); if (id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME)) { info.canDelete = false; } else { com.google.gerrit.server.CurrentUser.PropertyKey<com.google.gerrit.reviewdb.client.AccountExternalId.Key> k = CurrentUser.PropertyKey.create(); com.google.gerrit.reviewdb.client.AccountExternalId.Key last = resource.getUser().get(k); info.canDelete = (last != null) && (!(last.get().equals(info.identity))); } result.add(info); } return result; }

public void execute() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (migration.failChangeWrites()) { throw new com.google.gwtorm.server.OrmException(com.google.gerrit.server.notedb.NoteDbUpdateManager.CHANGES_READ_ONLY); } if (isEmpty()) { return; } try (com.google.gerrit.metrics.Timer1.Context timer = metrics.updateLatency.start(com.google.gerrit.server.notedb.NoteDbTable.CHANGES)) { stage(); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(changeRepo); com.google.gerrit.server.notedb.NoteDbUpdateManager.execute(allUsersRepo); } finally { close(); } }

@java.lang.Override public com.google.gerrit.server.notedb.NoteDbUpdateManager.Result rebuild(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { db = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db); com.google.gerrit.reviewdb.client.Change change = db.changes().get(changeId); if (change == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try (com.google.gerrit.server.notedb.NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) { buildUpdates(manager, bundleReader.fromReviewDb(db, changeId)); return execute(db, changeId, manager); } }
public com.google.gerrit.server.notedb.NoteDbUpdateManager.Result stageAndApplyDelta(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.NoteDbUpdateManager.StagedResult sr = stage().get(change.getId()); com.google.gerrit.server.notedb.NoteDbChangeState newState = com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(change, (sr != null ? sr.delta() : null)); return com.google.gerrit.server.notedb.NoteDbUpdateManager.Result.create(sr, newState); }
@java.lang.Override public com.google.gerrit.server.notedb.NoteDbUpdateManager stage(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Id changeId) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { db = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db); com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.notedb.rebuild.ChangeRebuilderImpl.checkNoteDbState(com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange(db, changeId)); if (change == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } com.google.gerrit.server.notedb.NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject()); buildUpdates(manager, bundleReader.fromReviewDb(db, changeId)); manager.stage(); return manager; }

private com.google.gerrit.server.git.BatchUpdate.ChangeContext newChangeContext(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Change.Id id) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChanges.get(id); if (c == null) { c = com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange(db, id); } com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c); com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(notes, user); return new com.google.gerrit.server.git.BatchUpdate.ChangeContext(ctl, new com.google.gerrit.server.git.BatchUpdateReviewDb(db), repo, rw); }

@org.junit.Test public void approvalsMultiplePatchSets() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putApproval("Code-Review", ((short) (-1))); update.commit(); com.google.gerrit.reviewdb.client.PatchSet.Id ps1 = c.currentPatchSetId(); incrementPatchSet(c); update = newUpdate(c, changeOwner); update.putApproval("Code-Review", ((short) (1))); update.commit(); com.google.gerrit.reviewdb.client.PatchSet.Id ps2 = c.currentPatchSetId(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals(); assertThat(psas).hasSize(2); com.google.gerrit.reviewdb.client.PatchSetApproval psa1 = com.google.common.collect.Iterables.getOnlyElement(psas.get(ps1)); assertThat(psa1.getPatchSetId()).isEqualTo(ps1); assertThat(psa1.getAccountId().get()).isEqualTo(1); assertThat(psa1.getLabel()).isEqualTo("Code-Review"); assertThat(psa1.getValue()).isEqualTo(((short) (-1))); assertThat(psa1.getGranted()).isEqualTo(truncate(after(c, 2000))); com.google.gerrit.reviewdb.client.PatchSetApproval psa2 = com.google.common.collect.Iterables.getOnlyElement(psas.get(ps2)); assertThat(psa2.getPatchSetId()).isEqualTo(ps2); assertThat(psa2.getAccountId().get()).isEqualTo(1); assertThat(psa2.getLabel()).isEqualTo("Code-Review"); assertThat(psa2.getValue()).isEqualTo(((short) (+1))); assertThat(psa2.getGranted()).isEqualTo(truncate(after(c, 3000))); }

@org.junit.Test public void applyDeltaToMetaId() { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.server.notedb.NoteDbChangeStateTest.newChange(); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.metaId(SHA1), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noDrafts())); assertThat(c.getNoteDbState()).isEqualTo(SHA1.name()); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.metaId(SHA2), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noDrafts())); assertThat(c.getNoteDbState()).isEqualTo(SHA2.name()); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noMetaId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noDrafts())); assertThat(c.getNoteDbState()).isEqualTo(SHA2.name()); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.metaId(zeroId()), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noDrafts())); assertThat(c.getNoteDbState()).isNull(); }
@org.junit.Test public void applyDeltaToNoteDbPrimaryIsNoOp() { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.server.notedb.NoteDbChangeStateTest.newChange(); c.setNoteDbState("N"); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.metaId(SHA1), com.google.gerrit.server.notedb.NoteDbChangeStateTest.drafts(new com.google.gerrit.reviewdb.client.Account.Id(1001), SHA2))); assertThat(c.getNoteDbState()).isEqualTo("N"); }
@org.junit.Test public void approvalsMultipleUsers() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putApproval("Code-Review", ((short) (-1))); update.commit(); update = newUpdate(c, otherUser); update.putApproval("Code-Review", ((short) (1))); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertThat(notes.getApprovals().keySet()).containsExactly(c.currentPatchSetId()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertThat(psas).hasSize(2); assertThat(psas.get(0).getPatchSetId()).isEqualTo(c.currentPatchSetId()); assertThat(psas.get(0).getAccountId().get()).isEqualTo(1); assertThat(psas.get(0).getLabel()).isEqualTo("Code-Review"); assertThat(psas.get(0).getValue()).isEqualTo(((short) (-1))); assertThat(psas.get(0).getGranted()).isEqualTo(truncate(after(c, 2000))); assertThat(psas.get(1).getPatchSetId()).isEqualTo(c.currentPatchSetId()); assertThat(psas.get(1).getAccountId().get()).isEqualTo(2); assertThat(psas.get(1).getLabel()).isEqualTo("Code-Review"); assertThat(psas.get(1).getValue()).isEqualTo(((short) (1))); assertThat(psas.get(1).getGranted()).isEqualTo(truncate(after(c, 3000))); }
@org.junit.Test public void approvalsOnePatchSet() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.putApproval("Verified", ((short) (1))); update.putApproval("Code-Review", ((short) (-1))); update.commit(); com.google.gerrit.server.notedb.ChangeNotes notes = newNotes(c); assertThat(notes.getApprovals().keySet()).containsExactly(c.currentPatchSetId()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId()); assertThat(psas).hasSize(2); assertThat(psas.get(0).getPatchSetId()).isEqualTo(c.currentPatchSetId()); assertThat(psas.get(0).getAccountId().get()).isEqualTo(1); assertThat(psas.get(0).getLabel()).isEqualTo("Code-Review"); assertThat(psas.get(0).getValue()).isEqualTo(((short) (-1))); assertThat(psas.get(0).getGranted()).isEqualTo(truncate(after(c, 2000))); assertThat(psas.get(1).getPatchSetId()).isEqualTo(c.currentPatchSetId()); assertThat(psas.get(1).getAccountId().get()).isEqualTo(1); assertThat(psas.get(1).getLabel()).isEqualTo("Verified"); assertThat(psas.get(1).getValue()).isEqualTo(((short) (1))); assertThat(psas.get(1).getGranted()).isEqualTo(psas.get(0).getGranted()); }
@org.junit.Test public void applyDeltaToNullWithNoNewMetaId() { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.server.notedb.NoteDbChangeStateTest.newChange(); assertThat(c.getNoteDbState()).isNull(); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noMetaId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noDrafts())); assertThat(c.getNoteDbState()).isNull(); com.google.gerrit.server.notedb.NoteDbChangeState.applyDelta(c, com.google.gerrit.server.notedb.NoteDbChangeState.Delta.create(c.getId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.noMetaId(), com.google.gerrit.server.notedb.NoteDbChangeStateTest.drafts(new com.google.gerrit.reviewdb.client.Account.Id(1001), zeroId()))); assertThat(c.getNoteDbState()).isNull(); }

private com.google.gerrit.server.notedb.NoteDbUpdateManager stageNoteDbUpdate(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, boolean deleted) throws com.google.gwtorm.server.OrmException, java.io.IOException { logDebug("Staging NoteDb update"); com.google.gerrit.server.notedb.NoteDbUpdateManager updateManager = updateManagerFactory.create(ctx.getProject()).setChangeRepo(ctx.getRepository(), ctx.getRevWalk(), null, new com.google.gerrit.server.git.ChainedReceiveCommands(repo)); for (com.google.gerrit.server.notedb.ChangeUpdate u : ctx.updates.values()) { updateManager.add(u); } com.google.gerrit.reviewdb.client.Change c = ctx.getChange(); if (deleted) { updateManager.deleteChange(c.getId()); } try { updateManager.stageAndApplyDelta(c); } catch (com.google.gerrit.server.notedb.NoteDbUpdateManager.MismatchedStateException ex) { logDebug("Ignoring MismatchedStateException while staging"); } return updateManager; }


void setParams(com.google.common.collect.Multimap<java.lang.String, java.lang.String> params);
@java.lang.Override public void setParams(com.google.common.collect.Multimap<java.lang.String, java.lang.String> params) { this.hasQuery2 = params.containsKey("query2"); }
private com.google.common.collect.Multimap<java.lang.String, ?> extractParams(final com.google.gerrit.common.audit.Audit note, final com.google.gerrit.httpd.rpc.GerritJsonServlet.GerritCall call) { com.google.common.collect.Multimap<java.lang.String, java.lang.Object> args = com.google.common.collect.ArrayListMultimap.create(); java.lang.Object[] params = call.getParams(); for (int i = 0; i < (params.length); i++) { args.put(("$" + i), params[i]); } for (int idx : note.obfuscate()) { args.removeAll(("$" + idx)); args.put(("$" + idx), "*****"); } return args; }
@java.lang.Override public com.google.common.collect.Multimap<java.lang.String, java.lang.String> getIncludedIn(java.lang.String project, java.lang.String commit, java.util.Collection<java.lang.String> tags, java.util.Collection<java.lang.String> branches) { com.google.common.collect.Multimap<java.lang.String, java.lang.String> m = com.google.common.collect.ArrayListMultimap.create(); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.PROD, "A"); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.PROD, "B"); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.PROD, "C"); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.STAGING, "X"); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.STAGING, "Y"); m.put(com.googlesource.gerrit.plugins.cookbook.DeployedOnIncludedInExtension.STAGING, "Z"); return m; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.SuggestedReviewerInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups); }


@java.lang.Override public final void updateRepo(com.google.gerrit.server.git.BatchUpdate.RepoContext ctx) throws java.lang.Exception { logDebug("{}#updateRepo for change {}", getClass().getSimpleName(), toMerge.change().getId()); com.google.gerrit.server.git.CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip(); alreadyMerged = getAlreadyMergedCommit(ctx); if ((alreadyMerged) == null) { updateRepoImpl(ctx); } else { logDebug("Already merged as {}", alreadyMerged.name()); } com.google.gerrit.server.git.CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip(); if (java.util.Objects.equals(tipBefore, tipAfter)) { logDebug("Did not move tip", getClass().getSimpleName()); return; } else if (tipAfter == null) { logDebug("No merge tip, no update to perform"); return; } logDebug("Moved tip from {} to {}", tipBefore, tipAfter); checkProjectConfig(ctx, tipAfter); command = new org.eclipse.jgit.transport.ReceiveCommand(firstNonNull(tipBefore, org.eclipse.jgit.lib.ObjectId.zeroId()), tipAfter, getDest().get()); ctx.addRefUpdate(command); args.submoduleOp.addBranchTip(getDest(), tipAfter); }
private static void populateBottomMenu(com.google.gwt.user.client.ui.RootPanel btmmenu, com.google.gerrit.common.data.HostPageData hpd) { java.lang.String vs = hpd.version; if ((vs == null) || (vs.isEmpty())) { vs = "dev"; } btmmenu.add(new com.google.gwt.user.client.ui.InlineHTML(Gerrit.M.poweredBy(vs))); if (Gerrit.info().gerrit().webUis().contains(UiType.POLYGERRIT)) { btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor(Gerrit.C.polyGerrit(), ((com.google.gwt.core.client.GWT.getHostPageBaseURL()) + "?polygerrit=1")); a.setStyleName(""); btmmenu.add(a); } java.lang.String reportBugUrl = Gerrit.info().gerrit().reportBugUrl(); if (reportBugUrl != null) { java.lang.String reportBugText = Gerrit.info().gerrit().reportBugText(); com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor((reportBugText == null ? Gerrit.C.reportBug() : reportBugText), reportBugUrl); a.setTarget("_blank"); a.setStyleName(""); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(a); } btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(" | ")); btmmenu.add(new com.google.gwt.user.client.ui.InlineLabel(Gerrit.C.keyHelp())); }


@org.junit.Before public void setUp() throws java.lang.Exception { db = reviewDbProvider.open(); changeId = newChange(admin.getIdent()); ps = getCurrentPatchSet(changeId); amendChange(admin.getIdent(), changeId); change = getChange(changeId); assertThat(ps).isNotNull(); changeId2 = newChange2(admin.getIdent()); change2 = getChange(changeId2); assertThat(change2).isNotNull(); ps2 = getCurrentPatchSet(changeId2); assertThat(ps2).isNotNull(); }
























private static void checkConfig(org.eclipse.jgit.lib.Config cfg) { java.util.Set<java.lang.String> keys = new java.util.HashSet<>(); for (com.google.gerrit.server.notedb.NoteDbTable t : com.google.gerrit.server.notedb.NoteDbTable.values()) { keys.add(t.key()); } java.util.Set<java.lang.String> allowed = com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.notedb.ConfigNotesMigration.READ, com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE, com.google.gerrit.server.notedb.ConfigNotesMigration.SEQUENCE); for (java.lang.String t : cfg.getSubsections(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB)) { checkArgument(keys.contains(t.toLowerCase()), "invalid NoteDb table: %s", t); for (java.lang.String key : cfg.getNames(com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB, t)) { checkArgument(allowed.contains(key.toLowerCase()), "invalid NoteDb key: %s.%s", t, key); } } }

@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName); if (!(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.isActive(cfg))) { return java.util.Collections.emptyList(); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.performValidation(repo, receiveEvent.commit); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("contains symbolic links", messages); } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on symbolic links", e); } return java.util.Collections.emptyList(); }





@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource resource, com.google.gerrit.server.change.ChangeEdits.Put.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change); if (edit.isPresent()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("edit already exists for the change %s", resource.getId())); } edit = createEdit(resource); if (!(com.google.common.base.Strings.isNullOrEmpty(path))) { putEdit.apply(new com.google.gerrit.server.change.ChangeEditResource(resource, edit.get(), path), input); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (!(edit.isPresent())) { editModifier.createEdit(rsrc.getChange(), psUtil.current(db.get(), rsrc.getNotes())); edit = editUtil.byChange(rsrc.getChange()); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.message))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("commit message must be provided"); } try { editModifier.modifyMessage(edit.get(), input.message); } catch (com.google.gerrit.server.edit.UnchangedCommitMessageException ucm) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(ucm.getMessage()); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.message))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("commit message must be provided"); } com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getProject(); try (org.eclipse.jgit.lib.Repository repository = repositoryManager.openRepository(project)) { com.google.gerrit.server.project.ChangeControl changeControl = rsrc.getControl(); com.google.gerrit.server.edit.ChangeEdit edit = getOrCreateChangeEdit(repository, changeControl); editModifier.modifyMessage(repository, input.message, edit); } catch (com.google.gerrit.server.edit.UnchangedCommitMessageException | com.google.gerrit.server.project.InvalidChangeOperationException ucm) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(ucm.getMessage()); } return com.google.gerrit.extensions.restapi.Response.none(); }

@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource resource, com.google.gerrit.server.change.ChangeEdits.Post.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = resource.getProject(); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(resource.getChange()); if (!(edit.isPresent())) { edit = createEdit(resource); } if (input != null) { if (!(com.google.common.base.Strings.isNullOrEmpty(input.restorePath))) { try (org.eclipse.jgit.lib.Repository repository = repoManager.openRepository(project)) { editModifier.restoreFile(repository, edit.get(), input.restorePath); } } else if ((!(com.google.common.base.Strings.isNullOrEmpty(input.oldPath))) && (!(com.google.common.base.Strings.isNullOrEmpty(input.newPath)))) { try (org.eclipse.jgit.lib.Repository repository = repoManager.openRepository(project)) { editModifier.renameFile(repository, edit.get(), input.oldPath, input.newPath); } } } return com.google.gerrit.extensions.restapi.Response.none(); }





@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.uploadvalidator.PatternCacheModule()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FooterValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidator.module()); }
public boolean isEnabledForRef(com.google.gerrit.reviewdb.client.Project.NameKey projectName, java.lang.String refName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); if (projectState == null) { com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.log.error((((((("Failed to check if " + (pluginName)) + " is enabled for project ") + (projectName.get())) + ": Project ") + (projectName.get())) + " not found")); return false; } for (com.google.gerrit.server.project.ProjectState parentState : projectState.treeInOrder()) { if (isEnabledForRef(parentState, refName)) { return true; } } return isEnabledForRef(projectState, refName); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); if (((args.mergeTip.getInitialTip()) == null) && (!(sorted.isEmpty()))) { com.google.gerrit.server.git.CodeReviewCommit first = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, first)); } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.MergeOneOp(args, n)); } return ops; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = sort(toMerge, args.mergeTip.getCurrentTip()); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); boolean first = true; for (com.google.gerrit.server.git.CodeReviewCommit c : sorted) { if ((c.getParentCount()) > 1) { sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted); break; } } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); if (first && ((args.mergeTip.getInitialTip()) == null)) { ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, n)); } else if ((n.getParentCount()) == 0) { ops.add(new com.google.gerrit.server.git.strategy.RebaseSubmitStrategy.RebaseRootOp(n)); } else if ((n.getParentCount()) == 1) { ops.add(new com.google.gerrit.server.git.strategy.RebaseSubmitStrategy.RebaseOneOp(n)); } else { ops.add(new com.google.gerrit.server.git.strategy.RebaseSubmitStrategy.RebaseMultipleParentsOp(n)); } first = false; } return ops; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); com.google.gerrit.server.git.CodeReviewCommit newTipCommit = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted); if (!(newTipCommit.equals(args.mergeTip.getInitialTip()))) { ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, newTipCommit)); } while (!(sorted.isEmpty())) { ops.add(new com.google.gerrit.server.git.strategy.FastForwardOnly.NotFastForwardOp(sorted.remove(0))); } return ops; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge); java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = new java.util.ArrayList(sorted.size()); if (((args.mergeTip.getInitialTip()) == null) || (!(args.submoduleOp.hasSubscription(args.destBranch)))) { com.google.gerrit.server.git.CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted); if ((firstFastForward != null) && (!(firstFastForward.equals(args.mergeTip.getInitialTip())))) { ops.add(new com.google.gerrit.server.git.strategy.FastForwardOp(args, firstFastForward)); } } while (!(sorted.isEmpty())) { com.google.gerrit.server.git.CodeReviewCommit n = sorted.remove(0); ops.add(new com.google.gerrit.server.git.strategy.MergeOneOp(args, n)); } return ops; }
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create(com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.git.MergeOp.CommitStatus commitStatus, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.IdentifiedUser caller, com.google.gerrit.server.git.MergeTip mergeTip, org.eclipse.jgit.lib.ObjectInserter inserter, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevFlag canMergeFlag, com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted, com.google.gerrit.server.util.RequestId submissionId, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling, com.google.common.collect.Multimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify, com.google.gerrit.server.git.SubmoduleOp submoduleOp, boolean dryrun);

@java.lang.Override public com.google.gerrit.server.change.IncludedIn.IncludedInInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ChangeControl ctl = rsrc.getControl(); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), rsrc.getNotes()); com.google.gerrit.reviewdb.client.Project.NameKey project = ctl.getProject().getNameKey(); try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { rw.setRetainBody(false); org.eclipse.jgit.revwalk.RevCommit rev; try { rev = rw.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException err) { throw new com.google.gerrit.extensions.restapi.BadRequestException(err.getMessage()); } catch (org.eclipse.jgit.errors.MissingObjectException err) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(err.getMessage()); } com.google.gerrit.server.change.IncludedInResolver.Result d = com.google.gerrit.server.change.IncludedInResolver.resolve(r, rw, rev); com.google.common.collect.Multimap<java.lang.String, java.lang.String> external = com.google.common.collect.ArrayListMultimap.create(); for (com.google.gerrit.extensions.config.ExternalIncludedIn ext : includedIn) { external.putAll(ext.getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches())); } return new com.google.gerrit.server.change.IncludedIn.IncludedInInfo(d, (!(external.isEmpty()) ? external.asMap() : null)); } }


@java.lang.Override public void init(javax.servlet.FilterConfig cfg) throws javax.servlet.ServletException { servletContext = cfg.getServletContext(); contextInitialized(new javax.servlet.ServletContextEvent(servletContext)); init(); manager.start(); }
@com.google.common.annotations.VisibleForTesting public void start() throws java.io.IOException { if ((dbInjector) == null) { dbInjector = createDbInjector(true, com.google.gerrit.pgm.MULTI_USER); } cfgInjector = createCfgInjector(); config = cfgInjector.getInstance(com.google.inject.Key.get(org.eclipse.jgit.lib.Config.class, com.google.gerrit.server.config.GerritServerConfig.class)); if (!(slave)) { initIndexType(); } sysInjector = createSysInjector(); sysInjector.getInstance(com.google.gerrit.server.plugins.PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector); manager.add(dbInjector, cfgInjector, sysInjector); if (!(consoleLog)) { manager.add(com.google.gerrit.pgm.util.ErrorLogFile.start(getSitePath(), config)); } sshd &= !(sshdOff()); if (sshd) { initSshd(); } if (com.google.common.base.MoreObjects.firstNonNull(httpd, true)) { initHttpd(); } manager.start(); }


@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { if ((args.projectCache) != null) { projectState = args.projectCache.get(change.getProject()); } else { projectState = null; } if ((patchSet) == null) { try { patchSet = changeData.currentPatchSet(); } catch (com.google.gwtorm.server.OrmException err) { patchSet = null; } } if ((patchSet) != null) { setHeader("X-Gerrit-PatchSet", ((patchSet.getPatchSetId()) + "")); if ((patchSetInfo) == null) { try { patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId()); } catch (com.google.gerrit.server.patch.PatchSetInfoNotAvailableException | com.google.gwtorm.server.OrmException err) { patchSetInfo = null; } } } authors = getAuthors(); super.init(); if ((timestamp) != null) { setHeader("Date", new java.util.Date(timestamp.getTime())); } setChangeSubjectHeader(); setHeader("X-Gerrit-Change-Id", ("" + (change.getKey().get()))); setChangeUrlHeader(); setCommitIdHeader(); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", patchSetAttribute.number)); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeDeletions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("is-draft", java.lang.Boolean.toString(patchSetAttribute.isDraft))); properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "author")); return properties; }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(com.google.gerrit.server.data.ChangeAttribute changeAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("project", changeAttribute.project)); properties.add(propertyFactory.create("branch", changeAttribute.branch)); properties.add(propertyFactory.create("topic", changeAttribute.topic)); properties.add(propertyFactory.create("subject", changeAttribute.subject)); properties.add(propertyFactory.create("commit-message", changeAttribute.commitMessage)); properties.add(propertyFactory.create("change-id", changeAttribute.id)); properties.add(propertyFactory.create("change-number", changeAttribute.number)); properties.add(propertyFactory.create("change-url", changeAttribute.url)); java.lang.String status = null; if ((changeAttribute.status) != null) { status = changeAttribute.status.toString(); } properties.add(propertyFactory.create("status", status)); properties.addAll(extractFrom(changeAttribute.owner, "owner")); return properties; }
private boolean checkConnection() { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.info("Checking database connection..."); try { eventsDb.queryOne(); return true; } catch (java.sql.SQLException e) { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.debug("Problem checking database connection", e); return false; } }
@java.lang.Override public com.google.gerrit.common.data.GroupDetail call() throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { control = groupControl.validateFor(groupId); com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); com.google.gerrit.common.data.GroupDetail detail = new com.google.gerrit.common.data.GroupDetail(); detail.setGroup(group); com.google.gerrit.common.data.GroupDescription.Basic ownerGroup = groupBackend.get(group.getOwnerGroupUUID()); if (ownerGroup != null) { detail.setOwnerGroup(com.google.gerrit.common.data.GroupReference.forGroup(ownerGroup)); } detail.setMembers(loadMembers()); detail.setIncludes(loadIncludes()); detail.setCanModify(control.isOwner()); return detail; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.List<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.extensions.restapi.Response.ok(java.util.Collections.emptyList()); } com.google.gerrit.server.account.AccountInfoCacheFactory accountInfoFactory = accountInfos.create(); return com.google.gerrit.extensions.restapi.Response.ok(pastAssignees.stream().map(accountInfoFactory::get).map(AccountJson::toAccountInfo).collect(java.util.stream.Collectors.toList())); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> assignee = java.util.Optional.ofNullable(rsrc.getChange().getAssignee()); if (assignee.isPresent()) { com.google.gerrit.reviewdb.client.Account account = accountInfo.create().get(assignee.get()); return com.google.gerrit.extensions.restapi.Response.ok(com.google.gerrit.server.account.AccountJson.toAccountInfo(account)); } return com.google.gerrit.extensions.restapi.Response.none(); }
public boolean include(com.google.gerrit.reviewdb.client.Change.Id changeId, com.google.gerrit.reviewdb.client.Comment p) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, p.key.patchSetId); switch (p.side) { case 0 : if (((idA) == null) && (idB.equals(psId))) { a.add(p); return true; } break; case 1 : if (((idA) != null) && (idA.equals(psId))) { a.add(p); return true; } if (idB.equals(psId)) { b.add(p); return true; } break; } return false; }
@org.junit.Test public void pushForMasterWithMessage() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message"); r.assertOkStatus(); r.assertChange(Change.Status.NEW, null); com.google.gerrit.extensions.common.ChangeInfo ci = get(r.getChangeId()); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> changeMessages = ci.messages; assertThat(changeMessages).hasSize(1); for (com.google.gerrit.extensions.common.ChangeMessageInfo cm : changeMessages) { assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message"); } }

private static void extractFooters(java.lang.String[] lines, com.google.gerrit.server.mail.receive.MailMetadata metadata) { for (java.lang.String line : lines) { if (((metadata.changeId) == null) && (line.contains(MetadataName.CHANGE_ID))) { metadata.changeId = com.google.gerrit.server.mail.receive.MetadataParser.extractFooter(com.google.gerrit.server.mail.MetadataName.toFooterWithDelimiter(MetadataName.CHANGE_ID), line); } else if (((metadata.patchSet) == null) && (line.contains(MetadataName.PATCH_SET))) { metadata.patchSet = com.google.common.primitives.Ints.tryParse(com.google.gerrit.server.mail.receive.MetadataParser.extractFooter(com.google.gerrit.server.mail.MetadataName.toFooterWithDelimiter(MetadataName.PATCH_SET), line)); } else if (((metadata.timestamp) == null) && (line.contains(MetadataName.TIMESTAMP))) { java.lang.String ts = com.google.gerrit.server.mail.receive.MetadataParser.extractFooter(com.google.gerrit.server.mail.MetadataName.toFooterWithDelimiter(MetadataName.TIMESTAMP), line); metadata.timestamp = java.sql.Timestamp.from(MailUtil.rfcDateformatter.parse(ts, java.time.Instant::from)); } else if (((metadata.messageType) == null) && (line.contains(MetadataName.MESSAGE_TYPE))) { metadata.messageType = com.google.gerrit.server.mail.receive.MetadataParser.extractFooter(com.google.gerrit.server.mail.MetadataName.toFooterWithDelimiter(MetadataName.MESSAGE_TYPE), line); } } }
@com.google.gwt.uibinder.client.UiHandler("publish") void onPublish(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.DraftActions.publish(changeId, revision, publish, deleteRevision, deleteChange); }

@com.google.gwt.uibinder.client.UiHandler("deleteRevision") void onDeleteRevision(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteDraftRevision())) { com.google.gerrit.client.change.DraftActions.delete(changeId, revision, publish, deleteRevision, deleteChange); } }


@java.lang.Override protected void configureServlets() { rpc(com.google.gerrit.httpd.rpc.SystemInfoServiceImpl.class); install(new com.google.gerrit.httpd.rpc.account.AccountModule()); install(new com.google.gerrit.httpd.rpc.project.ProjectModule()); }

@java.lang.Override protected void onLoad() { super.onLoad(); Util.ACCOUNT_SEC.myExternalIds(new com.google.gerrit.client.rpc.ScreenLoadCallback<java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId>>(this) { @java.lang.Override public void preDisplay(final java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> result) { identites.display(result); } }); }
void addOneId(final com.google.gerrit.reviewdb.client.AccountExternalId k) { if (k.isScheme(AccountExternalId.SCHEME_USERNAME)) { return; } final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); final int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); if (k.canDelete()) { final com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); } else { table.setText(row, 1, ""); } if (k.isTrusted()) { table.setText(row, 2, ""); } else { table.setText(row, 2, Util.C.untrustedProvider()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().identityUntrustedExternalId()); } if (((k.getEmailAddress()) != null) && ((k.getEmailAddress().length()) > 0)) { table.setText(row, 3, k.getEmailAddress()); } else { table.setText(row, 3, ""); } table.setText(row, 4, describe(k)); fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell()); fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell()); fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell()); setRowItem(row, k); }
void display(final java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> result) { java.util.Collections.sort(result, new java.util.Comparator<com.google.gerrit.reviewdb.client.AccountExternalId>() { @java.lang.Override public int compare(com.google.gerrit.reviewdb.client.AccountExternalId a, com.google.gerrit.reviewdb.client.AccountExternalId b) { return emailOf(a).compareTo(emailOf(b)); } private java.lang.String emailOf(final com.google.gerrit.reviewdb.client.AccountExternalId a) { return (a.getEmailAddress()) != null ? a.getEmailAddress() : ""; } }); while (1 < (table.getRowCount())) { table.removeRow(((table.getRowCount()) - 1)); } for (final com.google.gerrit.reviewdb.client.AccountExternalId k : result) { addOneId(k); } updateDeleteButton(); }
@java.lang.Override public void preDisplay(final java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> result) { identites.display(result); }
public java.lang.String generateToken(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id, int expirationSeconds) { try { byte[] initVector = new byte[com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.IV_LENGTH]; rndm.nextBytes(initVector); javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.ENCRYPT_MODE); return org.eclipse.jgit.util.Base64.encodeBytes(com.google.common.primitives.Bytes.concat(initVector, cipher.doFinal(java.lang.String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(java.nio.charset.StandardCharsets.UTF_8)))); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.log.error("Token generation failed with error", e); throw new java.lang.RuntimeException(e); } }
public boolean verifyAgainstToken(java.lang.String token, java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { if (com.google.common.base.Strings.isNullOrEmpty(token)) { return false; } byte[] bytes = org.eclipse.jgit.util.Base64.decode(token); byte[] initVector = java.util.Arrays.copyOf(bytes, com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.IV_LENGTH); try { javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.DECRYPT_MODE); java.lang.String data = new java.lang.String(cipher.doFinal(java.util.Arrays.copyOfRange(bytes, com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.IV_LENGTH, bytes.length)), java.nio.charset.StandardCharsets.UTF_8); java.lang.String oid = id.name(); java.lang.String prefix = java.lang.String.format("%s-%s-", operation, oid); return (data.startsWith(prefix)) && (onTime(data.substring(prefix.length()), operation, oid)); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.log.error("Exception was thrown during token verification", e); } return false; }
void sendAsync() { sendEmailsExecutor.submit(this); }
protected void dispatchMailProcessor(java.util.List<com.google.gerrit.server.mail.receive.MailMessage> messages, boolean async) { for (com.google.gerrit.server.mail.receive.MailMessage m : messages) { if (async) { java.util.concurrent.Callable<?> task = () -> { try { mailProcessor.process(m); requestDeletion(m.id()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.mail.receive.MailReceiver.log.error((("Mail: Can't process message " + (m.id())) + " . Won't delete."), e); } return null; }; workQueue.getDefaultQueue().submit(task); } else { try { mailProcessor.process(m); requestDeletion(m.id()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.mail.receive.MailReceiver.log.error("Mail: Can't process messages. Won't delete.", e); } } } }
public void sendAsync() { sendEmailsExecutor.submit(this); }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.Multimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.ArrayListMultimap.create(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.change.ALL); for (com.google.gerrit.server.notedb.ChangeNotes cn : notesFactory.scan(repo, db, project)) { org.eclipse.jgit.lib.Ref r = refs.get(cn.getChange().currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, cn)); } } new com.google.gerrit.server.index.change.AllChangesIndexer.ProjectIndexer(indexer, mergeStrategy, autoMerger, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.change.AllChangesIndexer.log.error(rnfe.getMessage()); } return null; }
private void getPathsAndIndex(org.eclipse.jgit.revwalk.RevWalk walk, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.lib.ObjectId b) throws java.lang.Exception { java.util.List<com.google.gerrit.server.query.change.ChangeData> cds = com.google.common.collect.Lists.newArrayList(byId.get(b)); try (org.eclipse.jgit.diff.DiffFormatter df = new org.eclipse.jgit.diff.DiffFormatter(org.eclipse.jgit.util.io.DisabledOutputStream.INSTANCE)) { org.eclipse.jgit.revwalk.RevCommit bCommit = walk.parseCommit(b); org.eclipse.jgit.revwalk.RevTree bTree = bCommit.getTree(); org.eclipse.jgit.revwalk.RevTree aTree = aFor(bCommit, walk, ins); df.setRepository(repo); if (!(cds.isEmpty())) { java.util.List<java.lang.String> paths = (aTree != null) ? getPaths(df.scan(aTree, bTree)) : java.util.Collections.<java.lang.String>emptyList(); java.util.Iterator<com.google.gerrit.server.query.change.ChangeData> cdit = cds.iterator(); for (com.google.gerrit.server.query.change.ChangeData cd; cdit.hasNext(); cdit.remove()) { cd = cdit.next(); try { cd.setCurrentFilePaths(paths); indexer.index(cd); done.update(1); if ((verboseWriter) != null) { verboseWriter.println(("Reindexed change " + (cd.getId()))); } } catch (java.lang.Exception e) { fail(("Failed to index change " + (cd.getId())), true, e); } } } } catch (java.lang.Exception e) { fail(("Failed to index commit " + (b.name())), false, e); for (com.google.gerrit.server.query.change.ChangeData cd : cds) { fail(("Failed to index change " + (cd.getId())), true, null); } } }
@java.lang.Override public int weigh(com.google.gerrit.server.patch.DiffSummaryKey key, com.google.gerrit.server.patch.DiffSummary value) { int size = (16 + (4 * 8)) + (2 * 36); for (java.lang.String p : value.getPaths()) { size += p.length(); } size += (value.getPaths().size()) - 1; return size; }
private java.util.concurrent.Callable<java.lang.Void> reindexProject(final com.google.gerrit.server.index.change.ChangeIndexer indexer, final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.server.git.MultiProgressMonitor.Task done, final com.google.gerrit.server.git.MultiProgressMonitor.Task failed, final java.io.PrintWriter verboseWriter) { return new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.Multimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.ArrayListMultimap.create(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.change.ALL); for (com.google.gerrit.server.notedb.ChangeNotes cn : notesFactory.scan(repo, db, project)) { org.eclipse.jgit.lib.Ref r = refs.get(cn.getChange().currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, cn)); } } new com.google.gerrit.server.index.change.AllChangesIndexer.ProjectIndexer(indexer, mergeStrategy, autoMerger, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.change.AllChangesIndexer.log.error(rnfe.getMessage()); } return null; } @java.lang.Override public java.lang.String toString() { return "Index all changes of project " + (project.get()); } }; }
private void readObject(java.io.ObjectInputStream input) throws java.io.IOException { java.lang.String[] paths = new java.lang.String[readVarInt32(input)]; int i = 0; try (java.util.zip.InflaterInputStream in = new java.util.zip.InflaterInputStream(input)) { if (i >= (paths.length)) { throw new java.io.IOException(("too many paths, expected " + (paths.length))); } paths[(i++)] = readString(in); } if (i != (paths.length)) { throw new java.io.IOException(((("expected " + (paths.length)) + "paths, got ") + i)); } }
private com.google.common.base.Optional<com.google.gerrit.server.query.change.ChangeData.ChangedLines> computeChangedLines() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return com.google.common.base.Optional.absent(); } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return com.google.common.base.Optional.absent(); } com.google.common.base.Optional<com.google.gerrit.server.patch.PatchList> p = getPatchList(c, ps); if (!(p.isPresent())) { return com.google.common.base.Optional.absent(); } return com.google.common.base.Optional.of(new com.google.gerrit.server.query.change.ChangeData.ChangedLines(p.get().getInsertions(), p.get().getDeletions())); }
private void writeObject(java.io.ObjectOutputStream output) throws java.io.IOException { writeVarInt32(output, paths.length); try (java.util.zip.DeflaterOutputStream out = new java.util.zip.DeflaterOutputStream(output)) { for (java.lang.String p : paths) { writeString(out, p); } } }

@java.lang.Override public java.util.concurrent.atomic.AtomicLong load(com.google.gerrit.reviewdb.client.Project.NameKey project) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project)) { return new java.util.concurrent.atomic.AtomicLong(com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.Loader.getDiskUsage(git.getDirectory())); } }



private void addReviewers(java.util.Set<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Change change) { try { com.google.gerrit.extensions.api.changes.ChangeApi cApi = gApi.changes().id(change.getId().get()); for (com.google.gerrit.reviewdb.client.Account account : reviewers) { cApi.addReviewer(account.getId().toString()); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { com.googlesource.gerrit.plugins.reviewers.DefaultReviewers.log.error("Couldn't add reviewers to the change", e); } }
com.googlesource.gerrit.plugins.reviewers.DefaultReviewers create(com.google.gerrit.reviewdb.client.Change change, java.util.Set<com.google.gerrit.reviewdb.client.Account> reviewers);
@java.lang.Override public void run() { addReviewers(reviewers, change); }
java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> getOwnersFromEmails(java.util.Set<java.lang.String> emails) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> result = com.google.common.collect.Sets.newHashSet(); emails.stream().forEach(( email) -> { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> foundIds = resolver.findAll(db, email); result.addAll(foundIds); } catch (com.google.gwtorm.server.OrmException e) { com.vmware.gerrit.owners.common.ConfigurationParser.log.error("cannot resolve emails", e); } }); return result; }



@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { update(c, event.getRefName()); } catch (java.io.IOException | org.eclipse.jgit.api.errors.GitAPIException e) { com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.log.error((("update for " + (c.toString())) + " failed: "), e); } } }
public boolean isSkipMerge(java.lang.String fromBranch, java.lang.String toBranch, java.lang.String commitMessage) { if (alwaysBlankMergePattern.matches(commitMessage)) { return true; } if (blankMergePattern.matches(commitMessage)) { java.util.Map<java.lang.String, java.lang.Object> mergePairConfig = getMergeConfig(fromBranch, toBranch); if (mergePairConfig != null) { boolean isMergeAll = ((boolean) (mergePairConfig.getOrDefault("merge_all", false))); return !isMergeAll; } } return false; }

@java.lang.Override public void start() { graphiteReporter.start(1, java.util.concurrent.TimeUnit.MINUTES); }

@org.junit.Test public void pushSameCommitTwice() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet(project).getConfig(); config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE); saveProjectConfig(project, config); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content"); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/for/master"); r.assertOkStatus(); push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent"); r = push.to("refs/for/master"); r.assertOkStatus(); com.google.gerrit.acceptance.GitUtil.assertPushRejected(com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master", false), "refs/for/master", "commit(s) already exists (as current patchset)"); }


void start() { oracle.requestSuggestions(request, this); }

private boolean isAlreadyMerged(com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.reviewdb.client.Branch.NameKey dest) throws java.io.IOException { try (com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk mirw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(rw.getObjectReader())) { mirw.reset(); mirw.markStart(commit); for (org.eclipse.jgit.revwalk.RevCommit accepted : alreadyAccepted) { if (mirw.isMergedInto(mirw.parseCommit(accepted), mirw.parseCommit(commit))) { return true; } } java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = internalChangeQuery.byCommit(commit); for (com.google.gerrit.server.query.change.ChangeData change : changes) { if ((((change.change().getStatus()) == (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) && (change.change().getDest().equals(dest))) && (!(isRework(dest.getParentKey(), commit, change)))) { return true; } } return false; } catch (com.google.gwtorm.server.OrmException e) { return false; } }
@java.lang.Override protected void onRequestSuggestions(final com.google.gerrit.client.change.Request req, final com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.changes.ChangeApi.revision(changeId.get(), revision.name()).view("files").addParameter("q", req.getQuery()).background().get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { java.util.List<com.google.gerrit.client.change.Suggestion> r = new java.util.ArrayList<>(); for (java.lang.String path : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.PathSuggestOracle.PathSuggestion(path)); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { java.util.List<com.google.gerrit.client.change.Suggestion> none = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(none)); } }); }
@java.lang.Override protected void configureServlets() { java.lang.Class<? extends javax.servlet.Filter> authFilter; if (authConfig.isTrustContainerAuth()) { authFilter = com.google.gerrit.httpd.ContainerAuthFilter.class; } else if (authConfig.isGitBasicAuth()) { if ((authConfig.getAuthType()) == (OAUTH)) { authFilter = com.google.gerrit.httpd.ProjectOAuthFilter.class; } else { authFilter = com.google.gerrit.httpd.ProjectBasicAuthFilter.class; } } else { authFilter = com.google.gerrit.httpd.ProjectDigestFilter.class; } if (isHttpEnabled()) { java.lang.String git = GitOverHttpServlet.URL_REGEX; filterRegex(git).through(authFilter); serveRegex(git).with(com.google.gerrit.httpd.GitOverHttpServlet.class); } filter("/a/*").through(authFilter); }
private void checkRobotComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> in) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> e : in.entrySet()) { java.lang.String commentPath = e.getKey(); for (com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput c : e.getValue()) { ensureRobotIdIsSet(c.robotId, commentPath); ensureRobotRunIdIsSet(c.robotRunId, commentPath); ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath); } } checkComments(revision, in); }

private <T extends com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput> void checkComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<T>> commentsPerPath) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { cleanUpComments(commentsPerPath); ensureCommentsAreAddable(revision, commentsPerPath); }
private void ensureRangeIsValid(java.lang.String commentPath, com.google.gerrit.extensions.client.Comment.Range range) throws com.google.gerrit.extensions.restapi.BadRequestException { if (range == null) { return; } if (!(range.isValid())) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format(("Range (%s:%s - %s:%s) is not" + " valid for the replacement of the robot comment on %s"), range.startLine, range.startCharacter, range.endLine, range.endCharacter, commentPath)); } }
private int search(final java.lang.String fileName) { if (Patch.COMMIT_MSG.equals(fileName)) { return 0; } if ((isMerge) && (Patch.MERGE_LIST.equals(fileName))) { return 1; } int high = patches.length; int low = (isMerge) ? 2 : 1; while (low < high) { final int mid = (low + high) >>> 1; final int cmp = patches[mid].getNewName().compareTo(fileName); if (cmp < 0) { low = mid + 1; } else if (cmp == 0) { return mid; } else { high = mid; } } return -(low + 1); }
void addOps(com.google.gerrit.server.git.BatchUpdate bu, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.MultiProgressMonitor.Task progress) throws java.io.IOException { if ((cmd.getResult()) == (NOT_ATTEMPTED)) { cmd.execute(rp); } if (((magicBranch) != null) && (magicBranch.edit)) { return; } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit newCommit = rw.parseCommit(newCommitId); rw.parseBody(newCommit); org.eclipse.jgit.revwalk.RevCommit priorCommit = revisions.inverse().get(priorPatchSet); replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false); bu.addOp(notes.getChangeId(), replaceOp); if (progress != null) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.ChangeProgressOp(progress)); } }
private com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo openRepo(com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.git.IntegrationException { try { return orm.getRepo(project); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noProject) { logWarn(((("Project " + (project.get())) + " no longer exists, ") + "abandoning open changes.")); abandonAllOpenChangeForDeletedProject(project); } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.IntegrationException(("Error opening project " + project), e); } return null; }
public java.lang.Integer unresolvedCommentCount() throws com.google.gwtorm.server.OrmException { if ((unresolvedCommentCount) == null) { if (!(lazyLoad)) { return null; } java.lang.Long count = java.util.stream.Stream.concat(publishedComments().stream(), robotComments().stream()).filter(( c) -> c.unresolved == Boolean.TRUE).count(); unresolvedCommentCount = count.intValue(); } return unresolvedCommentCount; }

void displaySubset(java.util.List<com.google.gerrit.client.projects.TagInfo> tags, int fromIndex, int toIndex) { while (1 < (table.getRowCount())) { table.removeRow(((table.getRowCount()) - 1)); } for (com.google.gerrit.client.projects.TagInfo k : tags.subList(fromIndex, toIndex)) { int row = table.getRowCount(); table.insertRow(row); applyDataRowStyle(row); populate(row, k); } }

void populate(int row, com.google.gerrit.client.projects.TagInfo k) { table.setWidget(row, 1, new com.google.gwt.user.client.ui.InlineHTML(highlight(k.getShortName(), match))); if ((k.revision()) != null) { table.setText(row, 2, k.revision()); } else { table.setText(row, 2, ""); } com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); java.lang.String dataCellStyle = Gerrit.RESOURCES.css().dataCell(); fmt.addStyleName(row, 1, dataCellStyle); fmt.addStyleName(row, 2, dataCellStyle); setRowItem(row, k); }



private void initPageHeader() { parseToken(); com.google.gwt.user.client.ui.HorizontalPanel hp = new com.google.gwt.user.client.ui.HorizontalPanel(); hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel()); com.google.gwt.user.client.ui.Label filterLabel = new com.google.gwt.user.client.ui.Label(Util.C.projectFilter()); filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel()); hp.add(filterLabel); filterTxt = new com.google.gwtexpui.globalkey.client.NpTextBox(); filterTxt.setValue(match); filterTxt.addKeyUpHandler(new com.google.gwt.event.dom.client.KeyUpHandler() { @java.lang.Override public void onKeyUp(com.google.gwt.event.dom.client.KeyUpEvent event) { com.google.gerrit.client.admin.ProjectTagsScreen.Query q = new com.google.gerrit.client.admin.ProjectTagsScreen.Query(filterTxt.getValue()); if (match.equals(q.qMatch)) { q.start(start); } else if ((query) == null) { q.run(); query = q; } } }); hp.add(filterTxt); add(hp); }
com.google.gerrit.server.CurrentUser getUser(java.lang.String auth) { if (((!(com.google.common.base.Strings.isNullOrEmpty(auth))) && (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX))) && (authCfg.isGitBasicAuth())) { return user.get(); } return anonymous.get(); }




@java.lang.Override public java.lang.String authenticate(com.google.gerrit.server.CurrentUser user, java.util.List<java.lang.String> args) throws com.google.gerrit.sshd.BaseCommand.Failure, com.google.gerrit.sshd.BaseCommand.UnloggedFailure { try { java.net.URL url = new java.net.URL(canonicalWebUrl); java.lang.String href = ((((((url.getProtocol()) + "://") + (url.getAuthority())) + (url.getPath())) + "/") + (args.get(0))) + "/info/lfs"; org.eclipse.jgit.lfs.server.Response.Action response = new org.eclipse.jgit.lfs.server.Response.Action(); response.href = href; response.header = java.util.Collections.singletonMap(com.googlesource.gerrit.plugins.lfs.HDR_AUTHORIZATION, "not:required"); return gson.toJson(response); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, ((("Server configuration error: " + "forming Git LFS endpoint URL from canonicalWebUrl [") + (canonicalWebUrl)) + "] failed.")); } }

public com.google.gerrit.server.query.Predicate<T> parse(final java.lang.String query) throws com.google.gerrit.server.query.QueryParseException { return toPredicate(com.google.gerrit.server.query.QueryParser.parse(query)); }
private void authorizeUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.project.ProjectState state, java.lang.String operation) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { com.google.gerrit.server.project.ProjectControl control = state.controlFor(user); if (((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD)) && (!(control.isReadable()))) || ((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD)) && ((com.google.gerrit.common.data.Capable.OK) != (control.canPushToAtLeastOneRef())))) { throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(java.lang.String.format("User %s is not authorized to perform %s operation", (com.google.common.base.Strings.isNullOrEmpty(user.getUserName()) ? "anonymous" : user.getUserName()), operation.toLowerCase())); } }


public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId extId = getAccountExternalId(key); if (extId != null) { if (!(extId.getAccountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { extId = com.google.gerrit.server.account.AccountManager.createId(to, who); extId.setEmailAddress(who.getEmailAddress()); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); externalIdCache.onCreate(extId); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress()) != null) { byEmailCache.evict(who.getEmailAddress()); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, key, false); } }

public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId extId = getAccountExternalId(key); if (extId != null) { if (!(extId.getAccountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (key.get())) + "' in use by another account")); } db.accountExternalIds().delete(java.util.Collections.singleton(extId)); externalIdCache.remove(extId); if ((who.getEmailAddress()) != null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if (((a.getPreferredEmail()) != null) && (a.getPreferredEmail().equals(who.getEmailAddress()))) { a.setPreferredEmail(null); db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (key.get())) + "' not found")); } return new com.google.gerrit.server.account.AuthResult(from, key, false); } }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.server.account.GetEmails.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.server.account.GetEmails.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, e.email), new com.google.gerrit.server.account.DeleteEmail.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }



private java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountExternalId> getGpgExtIds(com.google.gerrit.server.account.AccountResource rsrc) { return com.google.gerrit.gpg.server.GpgKeys.getGpgExtIds(externalIdCache, rsrc.getUser().getAccountId()); }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_GERRIT, username))).map(AccountExternalId::getAccountId); } }












public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow deleting emails"); } com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_MAILTO, email); com.google.gerrit.reviewdb.client.AccountExternalId extId = dbProvider.get().accountExternalIds().get(key); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(email); } try { accountManager.unlink(user.getAccountId(), com.google.gerrit.server.account.AuthRequest.forEmail(email)); } catch (com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } return com.google.gerrit.extensions.restapi.Response.none(); }
private static java.lang.String findId(final java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { for (final com.google.gerrit.reviewdb.client.AccountExternalId i : ids) { if (i.isScheme(AccountExternalId.SCHEME_GERRIT)) { return i.getSchemeRest(); } } return null; }
private com.google.gerrit.reviewdb.client.AccountExternalId getAccountExternalId(com.google.gerrit.reviewdb.client.AccountExternalId.Key key) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get()); if (accountState != null) { for (com.google.gerrit.reviewdb.client.AccountExternalId extId : accountState.getExternalIds()) { if (extId.getKey().equals(key)) { return extId; } } } return null; }
private com.google.gerrit.server.account.AccountState load(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = db.accounts().get(who); if (account == null) { return com.google.gerrit.server.account.AccountCacheImpl.missing(who); } java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds = externalIdCache.byAccount(who); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> internalGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if ((group != null) && ((group.getGroupUUID()) != null)) { internalGroups.add(group.getGroupUUID()); } } internalGroups = java.util.Collections.unmodifiableSet(internalGroups); try { account.setGeneralPreferences(loader.load(who)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.AccountCacheImpl.log.warn((("Cannot load GeneralPreferences for " + who) + " (using default)"), e); account.setGeneralPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); } return new com.google.gerrit.server.account.AccountState(account, internalGroups, externalIds, watchConfig.get().getProjectWatches(who)); }
private java.util.Set<java.lang.String> getAllowedUserIds(com.google.gerrit.server.IdentifiedUser user) { java.util.Set<java.lang.String> result = new java.util.HashSet<>(); result.addAll(user.getEmailAddresses()); for (com.google.gerrit.reviewdb.client.AccountExternalId extId : user.state().getExternalIds()) { if (extId.isScheme(com.google.gerrit.gpg.SCHEME_GPGKEY)) { continue; } result.add(extId.getExternalId()); } return result; }

private void convertLocalUserToLowerCase(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.AccountExternalId extId) { if (extId.isScheme(AccountExternalId.SCHEME_GERRIT)) { final java.lang.String localUser = extId.getSchemeRest(); final java.lang.String localUserLowerCase = localUser.toLowerCase(java.util.Locale.US); if (!(localUser.equals(localUserLowerCase))) { final com.google.gerrit.reviewdb.client.AccountExternalId.Key extIdKeyLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GERRIT, localUserLowerCase); final com.google.gerrit.reviewdb.client.AccountExternalId extIdLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId(extId.getAccountId(), extIdKeyLowerCase); try { db.accountExternalIds().insert(java.util.Collections.singleton(extIdLowerCase)); db.accountExternalIds().delete(java.util.Collections.singleton(extId)); } catch (com.google.gwtorm.server.OrmException error) { java.lang.System.err.println(("ERR " + (error.getMessage()))); } } } }







@java.lang.Override public int run() throws java.lang.Exception { if ((threads) <= 0) { threads = 1; } dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); manager.add(dbInjector, dbInjector.createChildInjector(com.google.gerrit.server.schema.SchemaVersionCheck.module())); manager.start(); dbInjector.injectMembers(this); try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { todo = db.accountExternalIds().all().toList(); synchronized(monitor) { monitor.beginTask("Converting local usernames", todo.size()); } } final java.util.List<com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker> workers = new java.util.ArrayList<>(threads); for (int tid = 0; tid < (threads); tid++) { com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker t = new com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker(); t.start(); workers.add(t); } for (com.google.gerrit.pgm.LocalUsernamesToLowerCase.Worker t : workers) { t.join(); } synchronized(monitor) { monitor.endTask(); } manager.stop(); return 0; }



private boolean isTrusted(final com.google.gerrit.reviewdb.client.AccountExternalId id) { if (id.isScheme(AccountExternalId.SCHEME_MAILTO)) { return true; } if (id.isScheme(AccountExternalId.SCHEME_UUID)) { return true; } if (id.isScheme(AccountExternalId.SCHEME_USERNAME)) { return true; } for (final com.google.gerrit.server.auth.openid.OpenIdProviderPattern p : trustedOpenIDs) { if (p.matches(id)) { return true; } } return false; }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.reviewdb.client.AccountExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); db.accountExternalIds().delete(java.util.Collections.singleton(extId)); externalIdCache.remove(extId); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }


@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, username); com.google.gerrit.reviewdb.client.AccountExternalId user = db.accountExternalIds().get(key); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) { if (k.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
public static java.util.Set<java.lang.String> getEmails(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_MAILTO)) { emails.add(id.getSchemeRest()); } } return emails; }
@java.lang.Override public Iterable<java.lang.String> get(com.google.gerrit.server.account.AccountState input, com.google.gerrit.server.index.account.FillArgs args) { java.lang.String fullName = input.getAccount().getFullName(); Set<java.lang.String> parts = com.google.gerrit.server.index.SchemaUtil.getPersonParts(fullName, com.google.common.collect.Iterables.transform(input.getExternalIds(), com.google.gerrit.reviewdb.client.AccountExternalId::getEmailAddress)); if (fullName != null) { parts.add(fullName.toLowerCase()); } return parts; }
@java.lang.Override public Iterable<java.lang.String> get(com.google.gerrit.server.account.AccountState input, com.google.gerrit.server.index.account.FillArgs args) { return com.google.common.collect.Iterables.transform(input.getExternalIds(), ( id) -> id.getKey().get()); }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), externalIdCache.byAccount(to)); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.size()) > 1) || (!(filteredKeysByScheme.contains(key))))) { db.accountExternalIds().deleteKeys(filteredKeysByScheme); externalIdCache.remove(to, filteredKeysByScheme); } byIdCache.evict(to); return link(to, who); } }
public static java.lang.String getUserName(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME)) { return id.getSchemeRest(); } } return null; }
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.server.account.AccountState accountState : accountQueryProvider.get().byExternalId(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_MAILTO, email).get())) { r.add(accountState.getAccount().getId()); } return com.google.common.collect.ImmutableSet.copyOf(r); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = com.google.gerrit.server.account.AccountManager.id(who); com.google.gerrit.reviewdb.client.AccountExternalId id = getAccountExternalId(key); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.getAccountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.getAccountId(), key, false); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(), java.util.Collections.<com.google.gerrit.reviewdb.client.AccountExternalId>emptySet(), new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>of(), com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountExternalId>of(), new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private com.google.gerrit.reviewdb.client.Account getAccountByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(externalId); if (accountStates.isEmpty()) { return null; } if ((accountStates.size()) > 1) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("GPG key ").append(externalId).append(" associated with multiple accounts: "); com.google.common.base.Joiner.on(", ").appendTo(msg, com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); log.error(msg.toString()); throw new java.lang.IllegalStateException(msg.toString()); } return accountStates.get(0).getAccount(); }
public boolean matches(com.google.gerrit.reviewdb.client.AccountExternalId id) { return matches(id.getExternalId()); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username must be set"); } com.google.gerrit.reviewdb.client.AccountExternalId id = dbProvider.get().accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, user.getUserName())); if (id == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } id.setPassword(newPassword); dbProvider.get().accountExternalIds().update(java.util.Collections.singleton(id)); externalIdCache.update(id); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(newPassword); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.server.account.GetEmails.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.extensions.api.accounts.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid email address"); } if ((input.noConfirmation) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow adding emails"); } return apply(rsrc.getUser(), input); }






private void addExternalId(java.lang.String scheme, java.lang.String id, java.lang.String email) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(scheme, id)); if (email != null) { extId.setEmailAddress(email); } db.accountExternalIds().insert(java.util.Collections.singleton(extId)); externalIdCache.onCreate(extId); reloadUser(); }
public java.lang.String getPassword(java.lang.String username) { for (com.google.gerrit.reviewdb.client.AccountExternalId id : getExternalIds()) { if ((id.isScheme(AccountExternalId.SCHEME_USERNAME)) && (username.equals(id.getSchemeRest()))) { return id.getPassword(); } } return null; }

@org.junit.Test public void noExternalIds() throws java.lang.Exception { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> extIds = externalIdCache.byAccount(user.getAccountId()); db.accountExternalIds().delete(extIds); externalIdCache.remove(extIds); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, ("No identities found for user; check" + " http://test/#/settings/web-identities")); checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users"); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey())); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); externalIdCache.onCreate(extId); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user"); }
private com.google.inject.Injector createCfgInjector() { final java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); if ((sitePath) == null) { modules.add(new com.google.inject.AbstractModule() { @java.lang.Override protected void configure() { bind(java.nio.file.Path.class).annotatedWith(com.google.gerrit.server.config.SitePath.class).toProvider(com.google.gerrit.httpd.SitePathFromSystemConfigProvider.class).in(com.google.gerrit.httpd.SINGLETON); } }); modules.add(new com.google.gerrit.server.config.GerritServerConfigModule()); } modules.add(new com.google.gerrit.server.schema.SchemaModule()); modules.add(new com.google.gerrit.server.notedb.ConfigNotesMigration.Module()); modules.add(com.google.gerrit.server.schema.SchemaVersionCheck.module()); modules.add(new com.google.gerrit.server.config.AuthConfigModule()); return dbInjector.createChildInjector(modules); }
com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (!(com.google.common.base.Strings.isNullOrEmpty(auth))) { if ((auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) && (authCfg.isGitBasicAuth())) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { com.google.common.base.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc != null) { return userFactory.create(acc); } } } } return anonymous.get(); }


private com.google.gerrit.reviewdb.client.Change updateChange() throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.Change updatedChange = dbProvider.get().changes().atomicUpdate(parentChange.getId(), new com.google.gwtorm.server.AtomicUpdate<com.google.gerrit.reviewdb.client.Change>() { @java.lang.Override public com.google.gerrit.reviewdb.client.Change update(com.google.gerrit.reviewdb.client.Change change) { boolean shouldBeDraft; try { shouldBeDraft = isAllPatchSetsInChangeDrafts(parentChange.getId()); } catch (com.google.gwtorm.server.OrmException e) { sendUserInfo("Unable to check if every patch set in change is draft."); shouldBeDraft = false; } if (shouldBeDraft) { change.setStatus(Change.Status.DRAFT); sendUserInfo("Every patch set in change is draft, change set to draft."); } return change; } }); return updatedChange; }
public final boolean isHttpPasswordSettingsEnabled() { if ((isGitBasicAuth()) && ((gitBasicAuthPolicy()) == (com.google.gerrit.extensions.client.GitBasicAuthPolicy.LDAP))) { return false; } return true; }
@org.junit.Test public void parseAndPersistChangeMessage() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); java.lang.String ts = MailUtil.rfcDateformatter.format(java.time.ZonedDateTime.ofInstant(comments.get(0).updated.toInstant(), java.time.ZoneId.of("UTC"))); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields(); java.lang.String txt = com.google.gerrit.acceptance.server.mail.MailProcessorIT.newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), "Test Message", null, null, null); b.textContent((txt + (com.google.gerrit.acceptance.server.mail.MailProcessorIT.textFooterForChange(changeId, ts)))); mailProcessor.process(b.build()); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeId).get().messages; assertThat(messages).hasSize(3); assertThat(com.google.common.collect.Iterables.getLast(messages).message).isEqualTo("Patch Set 1:\nTest Message"); assertThat(com.google.common.collect.Iterables.getLast(messages).tag).isEqualTo("mailMessageId=some id"); }

@org.junit.Test public void parseAndPersistFileComment() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); java.lang.String ts = MailUtil.rfcDateformatter.format(java.time.ZonedDateTime.ofInstant(comments.get(0).updated.toInstant(), java.time.ZoneId.of("UTC"))); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields(); java.lang.String txt = com.google.gerrit.acceptance.server.mail.MailProcessorIT.newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), null, null, "Some Comment on File 1", null); b.textContent((txt + (com.google.gerrit.acceptance.server.mail.MailProcessorIT.textFooterForChange(changeId, ts)))); mailProcessor.process(b.build()); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeId).get().messages; assertThat(messages).hasSize(3); assertThat(com.google.common.collect.Iterables.getLast(messages).message).isEqualTo("Patch Set 1:\n(1 comment)"); assertThat(com.google.common.collect.Iterables.getLast(messages).tag).isEqualTo("mailMessageId=some id"); comments = gApi.changes().id(changeId).current().commentsAsList(); assertThat(comments).hasSize(3); assertThat(comments.get(0).message).isEqualTo("Some Comment on File 1"); assertThat(comments.get(0).inReplyTo).isNull(); assertThat(comments.get(0).tag).isEqualTo("mailMessageId=some id"); assertThat(comments.get(0).path).isEqualTo("gerrit-server/test.txt"); }




@org.junit.Test public void parseAndPersistInlineComment() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); java.lang.String ts = MailUtil.rfcDateformatter.format(java.time.ZonedDateTime.ofInstant(comments.get(0).updated.toInstant(), java.time.ZoneId.of("UTC"))); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields(); java.lang.String txt = com.google.gerrit.acceptance.server.mail.MailProcessorIT.newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), null, "Some Inline Comment", null, null); b.textContent((txt + (com.google.gerrit.acceptance.server.mail.MailProcessorIT.textFooterForChange(changeId, ts)))); mailProcessor.process(b.build()); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeId).get().messages; assertThat(messages).hasSize(3); assertThat(com.google.common.collect.Iterables.getLast(messages).message).isEqualTo("Patch Set 1:\n(1 comment)"); assertThat(com.google.common.collect.Iterables.getLast(messages).tag).isEqualTo("mailMessageId=some id"); comments = gApi.changes().id(changeId).current().commentsAsList(); assertThat(comments).hasSize(3); assertThat(comments.get(2).message).isEqualTo("Some Inline Comment"); assertThat(comments.get(2).tag).isEqualTo("mailMessageId=some id"); assertThat(comments.get(2).inReplyTo).isEqualTo(comments.get(1).id); }

private void display(com.google.gerrit.client.info.GeneralPreferences p) { showSiteHeader.setValue(p.showSiteHeader()); useFlashClipboard.setValue(p.useFlashClipboard()); setListBox(maximumPageSize, com.google.gerrit.client.account.DEFAULT_PAGESIZE, p.changesPerPage()); setListBox(dateFormat, GeneralPreferencesInfo.DateFormat.STD, p.dateFormat()); setListBox(timeFormat, GeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat()); highlightAssigneeInChangeTable.setValue(p.highlightAssigneeInChangeTable()); relativeDateInChangeTable.setValue(p.relativeDateInChangeTable()); sizeBarInChangeTable.setValue(p.sizeBarInChangeTable()); legacycidInChangeTable.setValue(p.legacycidInChangeTable()); muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes()); signedOffBy.setValue(p.signedOffBy()); setListBox(reviewCategoryStrategy, GeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy()); setListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView()); setListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, p.emailStrategy()); setListBox(defaultBaseForMerges, GeneralPreferencesInfo.DefaultBase.FIRST_PARENT, p.defaultBaseForMerges()); display(p.my()); }

public static com.google.gerrit.client.info.GeneralPreferences createDefault() { com.google.gerrit.extensions.client.GeneralPreferencesInfo d = com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(); com.google.gerrit.client.info.GeneralPreferences p = createObject().cast(); p.changesPerPage(d.changesPerPage); p.showSiteHeader(d.showSiteHeader); p.useFlashClipboard(d.useFlashClipboard); p.downloadScheme(d.downloadScheme); p.downloadCommand(d.downloadCommand); p.dateFormat(d.getDateFormat()); p.timeFormat(d.getTimeFormat()); p.highlightAssigneeInChangeTable(d.highlightAssigneeInChangeTable); p.relativeDateInChangeTable(d.relativeDateInChangeTable); p.sizeBarInChangeTable(d.sizeBarInChangeTable); p.legacycidInChangeTable(d.legacycidInChangeTable); p.muteCommonPathPrefixes(d.muteCommonPathPrefixes); p.signedOffBy(d.signedOffBy); p.reviewCategoryStrategy(d.getReviewCategoryStrategy()); p.diffView(d.getDiffView()); p.emailStrategy(d.emailStrategy); p.defaultBaseForMerges(d.defaultBaseForMerges); return p; }
private void enable(final boolean on) { showSiteHeader.setEnabled(on); useFlashClipboard.setEnabled(on); maximumPageSize.setEnabled(on); dateFormat.setEnabled(on); timeFormat.setEnabled(on); highlightAssigneeInChangeTable.setEnabled(com.google.gerrit.client.Gerrit.info().change().showAssignee()); relativeDateInChangeTable.setEnabled(on); sizeBarInChangeTable.setEnabled(on); legacycidInChangeTable.setEnabled(on); muteCommonPathPrefixes.setEnabled(on); signedOffBy.setEnabled(on); reviewCategoryStrategy.setEnabled(on); diffView.setEnabled(on); emailStrategy.setEnabled(on); defaultBaseForMerges.setEnabled(on); }
@java.lang.Override protected void configureServlets() { java.lang.Class<? extends javax.servlet.Filter> authFilter; if (authConfig.isTrustContainerAuth()) { authFilter = com.google.gerrit.httpd.ContainerAuthFilter.class; } else if ((authConfig.getAuthType()) == (OAUTH)) { authFilter = com.google.gerrit.httpd.ProjectOAuthFilter.class; } else { authFilter = com.google.gerrit.httpd.ProjectBasicAuthFilter.class; } if (isHttpEnabled()) { java.lang.String git = GitOverHttpServlet.URL_REGEX; filterRegex(git).through(authFilter); serveRegex(git).with(com.google.gerrit.httpd.GitOverHttpServlet.class); } filterRegex(com.google.gerrit.httpd.GitOverHttpModule.LFS_URL_REGEX).through(authFilter); filter("/a/*").through(authFilter); }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); if ((notify.compareTo(NotifyHandling.OWNER_REVIEWERS)) >= 0) { ccAllApprovals(); } if ((notify.compareTo(NotifyHandling.ALL)) >= 0) { bccStarredBy(); includeWatchers(NotifyType.ALL_COMMENTS); } setHeader("X-Gerrit-Comment-Date", timestamp); }
@org.junit.Test public void evictGroups() throws java.lang.Exception { configureMocksFor(Constants.GROUPS); verifyResponseIsOK(); }
@org.junit.Before public void setUp() throws java.lang.Exception { com.google.gerrit.server.git.WorkQueue workQueueMock = mock(com.google.gerrit.server.git.WorkQueue.class); when(workQueueMock.createQueue(4, (("Evict cache [" + (com.ericsson.gerrit.plugins.evictcache.EvictCacheExecutorProviderTest.PLUGIN_NAME)) + " plugin]"))).thenReturn(executorMock); com.ericsson.gerrit.plugins.evictcache.Configuration configMock = mock(com.ericsson.gerrit.plugins.evictcache.Configuration.class); when(configMock.getThreadPoolSize()).thenReturn(4); evictCacheExecutorProvider = new com.ericsson.gerrit.plugins.evictcache.EvictCacheExecutorProvider(workQueueMock, com.ericsson.gerrit.plugins.evictcache.EvictCacheExecutorProviderTest.PLUGIN_NAME, configMock); }
private static void sendError(javax.servlet.http.HttpServletResponse rsp, int statusCode, java.lang.String message) { try { rsp.sendError(statusCode, message); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.logger.error(("Failed to send error messsage: " + (e.getMessage())), e); } }

@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException, javax.servlet.ServletException { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); try { java.util.List<java.lang.String> params = com.google.common.base.Splitter.on('/').splitToList(req.getPathInfo()); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.CACHENAME_INDEX); java.lang.String json = req.getReader().readLine(); java.lang.Object key = com.ericsson.gerrit.plugins.evictcache.GsonParser.fromJson(cacheName, json); com.google.common.cache.Cache<?, ?> cache = cacheMap.get(com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.SOURCE_NAME, cacheName); com.ericsson.gerrit.plugins.evictcache.Context.setForwardedEvent(); evictCache(cache, cacheName, key); rsp.setStatus(com.ericsson.gerrit.plugins.evictcache.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.logger.error(("Failed to process eviction request: " + (e.getMessage())), e); com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.evictcache.SC_BAD_REQUEST, e.getMessage()); } finally { com.ericsson.gerrit.plugins.evictcache.Context.unsetForwardedEvent(); } }
private void evictCache(com.google.common.cache.Cache<?, ?> cache, java.lang.String cacheName, java.lang.Object key) { if (com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.PROJECT_LIST.equals(cacheName)) { cache.invalidateAll(); } else { cache.invalidate(key); } com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet.logger.debug(("Invalidated " + cacheName)); }
@org.junit.Test public void evictGroupsByInclude() throws java.lang.Exception { configureMocksFor(Constants.GROUPS_BYINCLUDE); verifyResponseIsOK(); }
@java.lang.Override protected void configureServlets() { serveRegex("/index/\\d+$").with(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexRestApiServlet.class); serve("/event").with(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.class); }
static java.lang.String toJson(java.lang.String cacheName, java.lang.Object key) { com.google.gson.Gson gson = new com.google.gson.GsonBuilder().create(); java.lang.String json; switch (cacheName) { case com.ericsson.gerrit.plugins.evictcache.GsonParser.ACCOUNTS : json = gson.toJson(key, Account.Id.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS : json = gson.toJson(key, AccountGroup.Id.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS_BYINCLUDE : case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS_MEMBERS : json = gson.toJson(key, AccountGroup.UUID.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.PROJECT_LIST : default : json = gson.toJson(key); } return json; }
@org.junit.Test public void evictAccounts() throws java.lang.Exception { configureMocksFor(Constants.ACCOUNTS); verifyResponseIsOK(); }
@org.junit.Test public void evictProjectList() throws java.lang.Exception { configureMocksFor(Constants.PROJECT_LIST); verifyResponseIsOK(); }
@org.junit.Before public void setUp() { servlet = new com.ericsson.gerrit.plugins.evictcache.EvictCacheRestApiServlet(cacheMap); }
@org.junit.Test public void evictGroupsMembers() throws java.lang.Exception { configureMocksFor(Constants.GROUPS_MEMBERS); servlet.doPost(request, response); }
@java.lang.SuppressWarnings("unchecked") private void configureMocksFor(java.lang.String cacheName) throws java.io.IOException { when(cacheMap.get("gerrit", cacheName)).thenReturn(mock(com.google.common.cache.Cache.class)); when(request.getPathInfo()).thenReturn(("/" + cacheName)); when(request.getReader()).thenReturn(reader); if (Constants.DEFAULT.equals(cacheName)) { when(reader.readLine()).thenReturn("abc"); } else if ((Constants.GROUPS_BYINCLUDE.equals(cacheName)) || (Constants.GROUPS_MEMBERS.equals(cacheName))) { when(reader.readLine()).thenReturn("{\"uuid\":\"abcd1234\"}"); } else { when(reader.readLine()).thenReturn("{}"); } }






@org.junit.Test public void AccountIDParse() { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); java.lang.String json = com.ericsson.gerrit.plugins.evictcache.GsonParser.toJson(Constants.ACCOUNTS, accountId); assertThat(accountId).isEqualTo(com.ericsson.gerrit.plugins.evictcache.GsonParser.fromJson(Constants.ACCOUNTS, json)); }
@org.junit.Test public void AccountGroupUUIDParse() { com.google.gerrit.reviewdb.client.AccountGroup.UUID accountGroupUuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID("abc123"); java.lang.String json = com.ericsson.gerrit.plugins.evictcache.GsonParser.toJson(Constants.GROUPS_BYINCLUDE, accountGroupUuid); assertThat(accountGroupUuid).isEqualTo(com.ericsson.gerrit.plugins.evictcache.GsonParser.fromJson(Constants.GROUPS_BYINCLUDE, json)); }
@org.junit.Test public void AccountGroupIDParse() { com.google.gerrit.reviewdb.client.AccountGroup.Id accountGroupId = new com.google.gerrit.reviewdb.client.AccountGroup.Id(1); java.lang.String json = com.ericsson.gerrit.plugins.evictcache.GsonParser.toJson(Constants.GROUPS, accountGroupId); assertThat(accountGroupId).isEqualTo(com.ericsson.gerrit.plugins.evictcache.GsonParser.fromJson(Constants.GROUPS, json)); }
@org.junit.Test public void NoKeyParse() { java.lang.Object object = new java.lang.Object(); java.lang.String json = com.ericsson.gerrit.plugins.evictcache.GsonParser.toJson(Constants.PROJECT_LIST, object); assertThat(json).isEqualTo(com.ericsson.gerrit.plugins.evictcache.GsonParserTest.EMPTY_JSON); }
@org.junit.Test public void StringParse() { java.lang.String key = "key"; java.lang.String json = com.ericsson.gerrit.plugins.evictcache.GsonParser.toJson(Constants.DEFAULT, key); assertThat(key).isEqualTo(com.ericsson.gerrit.plugins.evictcache.GsonParser.fromJson(Constants.DEFAULT, json)); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfigs({ @com.google.gerrit.acceptance.GerritConfig(name = "plugin.evict-cache.url", value = Constants.URL), @com.google.gerrit.acceptance.GerritConfig(name = "plugin.evict-cache.user", value = "admin") }) public void flushAndSendPost() throws java.lang.Exception { final java.lang.String flushRequest = (Constants.ENDPOINT_BASE) + (Constants.PROJECT_LIST); wireMockRule.addMockServiceRequestListener(new com.github.tomakehurst.wiremock.http.RequestListener() { @java.lang.Override public void requestReceived(com.github.tomakehurst.wiremock.http.Request request, com.github.tomakehurst.wiremock.http.Response response) { if (request.getAbsoluteUrl().contains(flushRequest)) { synchronized(flushRequest) { flushRequest.notify(); } } } }); givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_OK))); adminSshSession.exec(("gerrit flush-caches --cache " + (Constants.PROJECT_LIST))); synchronized(flushRequest) { flushRequest.wait(java.util.concurrent.TimeUnit.SECONDS.toMillis(2)); } verify(postRequestedFor(urlEqualTo(flushRequest))); }
@java.lang.Override public void onRemoval(java.lang.String pluginName, java.lang.String cacheName, com.google.common.cache.RemovalNotification<K, V> notification) { if (((!(com.ericsson.gerrit.plugins.evictcache.Context.isForwardedEvent())) && (!(notification.wasEvicted()))) && (isSynchronized(cacheName))) { executor.execute(new EvictCacheTask(pluginName, cacheName, notification.getKey())); } }
@org.junit.Test public void evictDefault() throws java.lang.Exception { configureMocksFor(Constants.DEFAULT); verifyResponseIsOK(); }

static java.lang.Object fromJson(java.lang.String cacheName, java.lang.String json) { com.google.gson.Gson gson = new com.google.gson.GsonBuilder().create(); java.lang.Object key; switch (cacheName) { case com.ericsson.gerrit.plugins.evictcache.GsonParser.ACCOUNTS : key = gson.fromJson(com.google.common.base.Strings.nullToEmpty(json).trim(), Account.Id.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS : key = gson.fromJson(com.google.common.base.Strings.nullToEmpty(json).trim(), AccountGroup.Id.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS_BYINCLUDE : case com.ericsson.gerrit.plugins.evictcache.GsonParser.GROUPS_MEMBERS : key = gson.fromJson(com.google.common.base.Strings.nullToEmpty(json).trim(), AccountGroup.UUID.class); break; case com.ericsson.gerrit.plugins.evictcache.GsonParser.PROJECT_LIST : key = gson.fromJson(com.google.common.base.Strings.nullToEmpty(json), java.lang.Object.class); break; default : key = gson.fromJson(com.google.common.base.Strings.nullToEmpty(json).trim(), java.lang.String.class); } return key; }
@java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.AccountExternalId externalId) { return (externalId.isScheme(AccountExternalId.SCHEME_EXTERNAL)) && (externalId.getSchemeRest().startsWith(OAuthWebFilter.GITHUB_EXT_ID)); }
private com.google.gerrit.reviewdb.client.AccountExternalId getGitHubExternalId(com.google.gerrit.server.CurrentUser user) { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> accountExtIds = accountCache.get(((com.google.gerrit.server.IdentifiedUser) (user)).getAccountId()).getExternalIds(); java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> gitHubExtId = com.google.common.collect.Collections2.filter(accountExtIds, new com.google.common.base.Predicate<com.google.gerrit.reviewdb.client.AccountExternalId>() { @java.lang.Override public boolean apply(com.google.gerrit.reviewdb.client.AccountExternalId externalId) { return (externalId.isScheme(AccountExternalId.SCHEME_EXTERNAL)) && (externalId.getSchemeRest().startsWith(OAuthWebFilter.GITHUB_EXT_ID)); } }); if (gitHubExtId.isEmpty()) { throw new java.lang.IllegalStateException((("Current Gerrit user " + (user.getUserName())) + " has no GitHub OAuth external ID")); } return gitHubExtId.iterator().next(); }

@org.junit.Test public void pushForMasterWithApprovals() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review"); r.assertOkStatus(); ChangeInfo ci = get(r.getChangeId()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value).isEqualTo(1); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1."); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to("refs/for/master/%l=Code-Review+2"); ci = get(r.getChangeId()); cr = ci.labels.get("Code-Review"); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2."); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value).isEqualTo(2); push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId()); r = push.to("refs/for/master/%l=Code-Review+2"); ci = get(r.getChangeId()); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3."); }
@org.junit.Test public void pushWithMultipleApprovals() throws java.lang.Exception { com.google.gerrit.common.data.LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value((-1), "Negative")); com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet(project).getConfig(); com.google.gerrit.reviewdb.client.AccountGroup.UUID anon = systemGroupBackend.getGroup(com.google.gerrit.acceptance.git.ANONYMOUS_USERS).getUUID(); java.lang.String heads = "refs/heads/*"; com.google.gerrit.server.project.Util.allow(config, com.google.gerrit.common.data.Permission.forLabel("Custom-Label"), (-1), 1, anon, heads); config.getLabelSections().put(Q.getName(), Q); saveProjectConfig(project, config); org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()); com.google.gerrit.extensions.common.LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); cr = ci.labels.get("Custom-Label"); assertThat(cr.all).hasSize(1); }
@org.junit.Test public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get()); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(2); int indexAdmin = (admin.fullName.equals(cr.all.get(0).name)) ? 0 : 1; int indexUser = (indexAdmin == 0) ? 1 : 0; assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName); assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1); assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName); assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1."); }

private org.apache.http.impl.client.BasicCredentialsProvider buildCredentials() { java.net.URI uri = java.net.URI.create(cfg.getUrl()); org.apache.http.impl.client.BasicCredentialsProvider creds = new org.apache.http.impl.client.BasicCredentialsProvider(); creds.setCredentials(new org.apache.http.auth.AuthScope(uri.getHost(), uri.getPort()), new org.apache.http.auth.UsernamePasswordCredentials(cfg.getUser(), cfg.getPassword())); return creds; }
@org.junit.Before public void setUp() throws java.lang.Exception { java.lang.String url = "http://localhost:" + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.port()); com.ericsson.gerrit.plugins.highavailability.Configuration cfg = mock(com.ericsson.gerrit.plugins.highavailability.Configuration.class); when(cfg.getUrl()).thenReturn(url); when(cfg.getUser()).thenReturn("user"); when(cfg.getPassword()).thenReturn("pass"); when(cfg.getMaxTries()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.MAX_TRIES); when(cfg.getConnectionTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.TIMEOUT); when(cfg.getSocketTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.TIMEOUT); when(cfg.getRetryInterval()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.RETRY_INTERVAL); httpSession = new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSession(new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProvider(cfg).get(), url); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.resetRequests(); }
@java.lang.Override protected void configure() { bind(com.ericsson.gerrit.plugins.highavailability.Configuration.class).toInstance(config); bind(org.apache.http.impl.client.CloseableHttpClient.class).toProvider(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProvider.class).in(Scopes.SINGLETON); }
@org.junit.Before public void setUp() throws java.lang.Exception { when(config.getUrl()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProviderTest.EMPTY); when(config.getUser()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProviderTest.EMPTY); when(config.getPassword()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProviderTest.EMPTY); when(config.getConnectionTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProviderTest.TIME_INTERVAL); when(config.getSocketTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProviderTest.TIME_INTERVAL); }
private void logRetry(java.lang.String cause) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProvider.log.debug(((("Retrying request to '" + (cfg.getUrl())) + "' Cause: ") + cause)); }









private org.eclipse.jgit.lib.Repository openRepository(java.lang.String name) throws java.io.IOException { if (repos.containsKey(name)) { return repos.get(name); } name = com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.urlToRepoKey(canonicalWebUrl, name); org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(new com.google.gerrit.reviewdb.client.Project.NameKey(name)); repos.put(name, repo); return repo; }
private void execute(com.google.gerrit.server.notedb.NoteDbUpdateManager.OpenRepo or) throws java.io.IOException { if ((or == null) || (or.cmds.isEmpty())) { return; } or.flush(); org.eclipse.jgit.lib.BatchRefUpdate bru = or.repo.getRefDatabase().newBatchUpdate(); bru.setRefLogMessage(firstNonNull(refLogMessage, "Update NoteDb refs"), false); bru.setRefLogIdent(((refLogIdent) != null ? refLogIdent : serverIdent.get())); or.cmds.addTo(bru); bru.setAllowNonFastForwards(true); bru.execute(or.rw, NullProgressMonitor.INSTANCE); for (org.eclipse.jgit.transport.ReceiveCommand cmd : bru.getCommands()) { if ((cmd.getResult()) != (ReceiveCommand.Result.OK)) { throw new java.io.IOException(("Update failed: " + bru)); } } }



@org.junit.Test public void testKeywords() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator(null, new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE), com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE, null, null, null); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidatorTest.getPatterns().values(), com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG); java.util.Set<java.lang.String> expected = com.google.common.collect.ImmutableSet.of(("ERROR: blocked keyword(s) found in file: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)"), ("ERROR: blocked keyword(s) found in file: bar.txt (Line: 5)" + " (found: $Id: foo bar$)")); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
private org.eclipse.jgit.revwalk.RevCommit makeCommit() throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.api.errors.NoFilepatternException { java.util.Map<java.io.File, byte[]> files = new java.util.HashMap<>(); java.lang.String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n"; files.put(new java.io.File(repo.getDirectory().getParent(), "foo.txt"), content.getBytes(java.nio.charset.StandardCharsets.UTF_8)); content = "$Id$\n" + ((("$Header$\n" + "$Author$\n") + "processXFile($File::Find::name, $Config{$type});\n") + "$Id: foo bar$\n"); files.put(new java.io.File(repo.getDirectory().getParent(), "bar.txt"), content.getBytes(java.nio.charset.StandardCharsets.UTF_8)); content = "Testline1\n" + (("Testline2\n" + "Testline3\n") + "Testline4"); files.put(new java.io.File(repo.getDirectory().getParent(), "foobar.txt"), content.getBytes(java.nio.charset.StandardCharsets.UTF_8)); return com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.makeCommit(repo, "Commit with test files.", files); }


public boolean isEnabledForRef(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Project.NameKey projectName, java.lang.String refName, java.lang.String validatorOp) { com.google.gerrit.server.config.PluginConfig conf = configFactory.get(projectName); return (((conf != null) && (isValidConfig(conf, projectName))) && (activeForRef(conf, refName))) && ((((!(hasCriteria(conf, "skipGroup"))) || (!(canSkipValidation(conf, validatorOp)))) || (!(canSkipRef(conf, refName)))) || (!(canSkipGroup(conf, user)))); }

private java.lang.String healthCheckSysinfo() throws java.io.IOException { com.atlassian.jira.rest.client.api.domain.ServerInfo info = client().sysInfo(); final java.lang.String result = ((((("{\"status\"=\"ok\",\"system\"=\"Jira\",\"version\"=\"" + (info.getVersion())) + "\",\"url\"=\"") + (getUrl())) + "\",\"build\"=\"") + (info.getBuildNumber())) + "\"}"; log.debug("Healtheck on sysinfo result: {}", result); return result; }
private void doPerformAction(final java.lang.String issueKey, final java.lang.String actionName) throws java.io.IOException { log.debug(((("Trying to perform action: " + actionName) + " on issue ") + issueKey)); boolean ret = client().doTransition(issueKey, actionName); if (ret) { log.debug(((("Action " + actionName) + " successful on Issue ") + issueKey)); } else { log.debug("Action {} on Issue {} not possible", actionName, issueKey); } }
public void addComment(java.lang.String issueKey, com.atlassian.jira.rest.client.api.domain.Comment comment) throws com.atlassian.jira.rest.client.api.RestClientException, java.net.URISyntaxException { com.googlesource.gerrit.plugins.its.jira.JiraClient.log.debug(("Trying to add comment for issue " + issueKey)); com.atlassian.jira.rest.client.api.domain.Issue issue = getIssue(issueKey); java.net.URI issueUri; issueUri = new java.net.URI(((issue.getSelf().toString()) + "/comment/")); com.atlassian.jira.rest.client.api.IssueRestClient issueClient = client.getIssueClient(); com.atlassian.util.concurrent.Promise<java.lang.Void> promise = issueClient.addComment(issueUri, comment); promise.claim(); com.googlesource.gerrit.plugins.its.jira.JiraClient.log.debug(("Comment added to issue " + issueKey)); }
private com.googlesource.gerrit.plugins.its.jira.JiraClient client() throws java.io.IOException { if ((client) == null) { try { log.debug("Connecting to jira at {}", getUrl()); client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(getUrl(), getUsername(), getPassword()); log.debug("Authenticating as User {}", getUsername()); } catch (java.lang.Exception e) { log.info(((("Unable to connect to " + (getUrl())) + " as ") + (getUsername()))); throw new java.io.IOException(e); } } return client; }
private com.atlassian.jira.rest.client.api.domain.Transition getTransitionByName(java.lang.Iterable<com.atlassian.jira.rest.client.api.domain.Transition> transitions, java.lang.String transition) { com.atlassian.jira.rest.client.api.domain.Transition ret = null; for (com.atlassian.jira.rest.client.api.domain.Transition t : transitions) { if (transition.equals(t.getName())) { ret = t; break; } } return ret; }

public boolean issueExists(java.lang.String issueKey) throws com.atlassian.jira.rest.client.api.RestClientException { boolean ret = true; try { getIssue(issueKey); } catch (com.atlassian.jira.rest.client.api.RestClientException e) { if ((e.getStatusCode().get()) == 404) { com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error((("Issue " + issueKey) + " not found ")); ret = false; } else { throw e; } } return ret; }
private boolean isJiraConnectSuccessful() { ui.message("Checking Jira connectivity ... "); try { new com.googlesource.gerrit.plugins.its.jira.JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion(); ui.message("[OK]\n"); return true; } catch (java.net.URISyntaxException e) { ui.message("*FAILED* (%s)\n", e.toString()); return false; } }
public com.atlassian.jira.rest.client.api.domain.ServerInfo sysInfo() throws com.atlassian.jira.rest.client.api.RestClientException { return client.getMetadataClient().getServerInfo().claim(); }
public boolean doTransition(java.lang.String issueKey, java.lang.String transition) throws com.atlassian.jira.rest.client.api.RestClientException, com.googlesource.gerrit.plugins.its.base.its.InvalidTransitionException { com.atlassian.jira.rest.client.api.domain.Transition t = getTransitionByName(getTransitions(issueKey), transition); if (t == null) { throw new com.googlesource.gerrit.plugins.its.base.its.InvalidTransitionException(((("Action " + transition) + " not executable on issue ") + issueKey)); } com.atlassian.jira.rest.client.api.domain.input.TransitionInput input; input = new com.atlassian.jira.rest.client.api.domain.input.TransitionInput(t.getId()); com.googlesource.gerrit.plugins.its.jira.JiraClient.log.debug(("Setting transition input to: " + (input.toString()))); client.getIssueClient().transition(getIssue(issueKey), input).claim(); return true; }
public java.lang.Iterable<com.atlassian.jira.rest.client.api.domain.Transition> getTransitions(java.lang.String issueKey) throws com.atlassian.jira.rest.client.api.RestClientException { return client.getIssueClient().getTransitions(getIssue(issueKey)).claim(); }
private java.lang.String healthCheckAccess() throws java.io.IOException { client().sysInfo(); final java.lang.String result = ("{\"status\"=\"ok\",\"username\"=\"" + (getUsername())) + "\"}"; log.debug("Healtheck on access result: {}", result); return result; }












@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((migration.readChanges()) && ((state) == (CC))) { addedCCs = approvalsUtil.addCcs(ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), reviewers.keySet()); if (addedCCs.isEmpty()) { return false; } } else { addedReviewers = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet()); if (addedReviewers.isEmpty()) { return false; } } patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); return true; }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if (((addedReviewers) != null) || ((addedCCs) != null)) { if ((addedReviewers) == null) { addedReviewers = new java.util.ArrayList(); } if ((addedCCs) == null) { addedCCs = new java.util.ArrayList(); } emailReviewers(rsrc.getChange(), com.google.common.collect.Lists.transform(addedReviewers, ( r) -> r.getAccountId()), addedCCs, notify, accountsToNotify); if (!(addedReviewers.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers = com.google.common.collect.Lists.transform(addedReviewers, ( psa) -> com.google.gerrit.server.change.accountCache.get(psa.getAccountId()).getAccount()); reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getAccount(), ctx.getWhen()); } } }







void gatherResults() throws com.google.gwtorm.server.OrmException { if ((migration.readChanges()) && ((op.state) == (CC))) { result.ccs = com.google.common.collect.Lists.newArrayListWithCapacity(op.addedCCs.size()); for (com.google.gerrit.reviewdb.client.Account.Id accountId : op.addedCCs) { result.ccs.add(json.format(new com.google.gerrit.extensions.api.changes.ReviewerInfo(accountId.get()), reviewers.get(accountId))); } accountLoaderFactory.create(true).fill(result.ccs); } else { result.reviewers = com.google.common.collect.Lists.newArrayListWithCapacity(op.addedReviewers.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : op.addedReviewers) { result.reviewers.add(json.format(new com.google.gerrit.extensions.api.changes.ReviewerInfo(psa.getAccountId().get()), reviewers.get(psa.getAccountId()), com.google.common.collect.ImmutableList.of(psa))); } accountLoaderFactory.create(true).fill(result.reviewers); } }
com.google.gerrit.server.notedb.ChangeNotesState parseAll() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { walk.reset(); walk.markStart(walk.parseCommit(tip)); try (com.google.gerrit.metrics.Timer1.Context timer = metrics.parseLatency.start(com.google.gerrit.server.notedb.NoteDbTable.CHANGES)) { com.google.gerrit.server.notedb.ChangeNotesCommit commit; while ((commit = walk.next()) != null) { parse(commit); } parseNotes(); allPastReviewers.addAll(reviewers.rowKeySet()); pruneReviewers(); updatePatchSetStates(); checkMandatoryFooters(); } return buildState(); }








static com.google.gerrit.server.notedb.ChangeNotesState empty(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.AutoValue_ChangeNotesState(null, change.getId(), null, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.gerrit.server.ReviewerSet.empty(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableListMultimap.of(), com.google.common.collect.ImmutableListMultimap.of(), null); }


@java.lang.Override public boolean isEmpty() { return ((((((((((((((((((((commitSubject) == null) && (approvals.isEmpty())) && ((changeMessage) == null)) && (comments.isEmpty())) && (reviewers.isEmpty())) && ((changeId) == null)) && ((branch) == null)) && ((status) == null)) && ((submissionId) == null)) && ((submitRecords) == null)) && ((assignee) == null)) && ((hashtags) == null)) && ((topic) == null)) && ((commit) == null)) && ((psState) == null)) && ((groups) == null)) && ((tag) == null)) && ((psDescription) == null)) && (!(currentPatchSet))) && ((readOnlyUntil) == null); }






private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(tip.copy(), id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, ((assignee) != null ? assignee.orElse(null) : null), status, com.google.common.collect.Sets.newLinkedHashSet(com.google.common.collect.Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil); }




@java.lang.Override public com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo apply(com.google.gerrit.server.config.ConfigResource resource) { com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo info = new com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo(); info.showJobsPanel = cfg.getBoolean("showJobsPanel", true); info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true); info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true); return info; }

@java.lang.Override public java.util.Set<com.google.gerrit.server.account.ExternalId> byAccount(com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException { try { return extIdsByAccount.get(externalIds.readRevision()).get(accountId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.ExternalIdCacheImpl.log.warn("Cannot list external ids", e); return java.util.Collections.emptySet(); } }

@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.server.account.AccountState accountState : accountQueryProvider.get().byEmailPrefix(email)) { if (accountState.getExternalIds().stream().filter(( e) -> email.equals(e.email())).findAny().isPresent()) { r.add(accountState.getAccount().getId()); } } return com.google.common.collect.ImmutableSet.copyOf(r); } }

private java.lang.String messageForDestinationChange(com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.reviewdb.client.Branch.NameKey sourceBranch) { return new java.lang.StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked from branch ").append(sourceBranch.getShortName()).append(".").toString(); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); com.google.gerrit.server.IdentifiedUser newAssigneeUser = accounts.parse(assignee); newAssignee = newAssigneeUser.getAccount(); com.google.gerrit.server.IdentifiedUser oldAssigneeUser = null; if ((change.getAssignee()) != null) { oldAssigneeUser = userFactory.create(change.getAssignee()); oldAssignee = oldAssigneeUser.getAccount(); if (newAssignee.equals(oldAssignee)) { return false; } } if (!(newAssignee.isActive())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Account of %s is not active", assignee)); } if (!(ctx.getControl().forUser(newAssigneeUser).isRefVisible())) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Change %s is not visible to %s.", change.getChangeId(), assignee)); } try { for (com.google.gerrit.server.validators.AssigneeValidationListener validator : validationListeners) { validator.validateAssignee(change, newAssignee); } } catch (com.google.gerrit.server.validators.ValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } update.setAssignee(newAssignee.getId()); change.setAssignee(newAssignee.getId()); addMessage(ctx, update, oldAssigneeUser, newAssigneeUser); return true; }
private void addMessage(com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.server.IdentifiedUser previousAssignee, com.google.gerrit.server.IdentifiedUser newAssignee) throws com.google.gwtorm.server.OrmException { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Assignee "); if (previousAssignee == null) { msg.append("added: "); msg.append(newAssignee.getNameEmail()); } else { msg.append("changed from: "); msg.append(previousAssignee.getNameEmail()); msg.append(" to: "); msg.append(newAssignee.getNameEmail()); } com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_ASSIGNEE); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.git.BatchUpdate.Context ctx) throws com.google.gwtorm.server.OrmException { try { com.google.gerrit.server.mail.send.SetAssigneeSender cm = setAssigneeSenderFactory.create(change.getProject(), change.getId(), newAssignee.getId()); cm.setFrom(user.get().getAccountId()); cm.send(); } catch (java.lang.Exception err) { com.google.gerrit.server.change.SetAssigneeOp.log.error(("Cannot send email to new assignee of change " + (change.getId())), err); } assigneeChanged.fire(change, ctx.getAccount(), oldAssignee, ctx.getWhen()); }
@java.lang.Override public synchronized void stop() { if ((daemonAcceptor) != null) { try { daemonAcceptor.close(true).await(); com.google.gerrit.sshd.SshDaemon.sshDaemonLog.info("Stopped Gerrit SSHD"); } catch (java.io.IOException e) { com.google.gerrit.sshd.SshDaemon.sshDaemonLog.warn("Exception caught while closing", e); } finally { daemonAcceptor = null; } } }
public static void load(java.util.List<java.lang.String> plugins, int loadTimeout, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> callback) { if ((plugins == null) || (plugins.isEmpty())) { callback.onSuccess(com.google.gerrit.client.VoidResult.create()); } else { com.google.gerrit.client.api.PluginLoader.self = new com.google.gerrit.client.api.PluginLoader(loadTimeout, callback); com.google.gerrit.client.api.PluginLoader.self.load(plugins); com.google.gerrit.client.api.PluginLoader.self.startTimers(); com.google.gerrit.client.api.PluginLoader.self.center(); } }
private static boolean isJsPlugin(java.lang.String name) { return com.google.gerrit.server.plugins.PluginLoader.isPlugin(name, "js"); }
public java.lang.String getGerritPluginName(java.nio.file.Path srcPath) { java.lang.String fileName = srcPath.getFileName().toString(); if (com.google.gerrit.server.plugins.PluginLoader.isJsPlugin(fileName)) { return fileName.substring(0, ((fileName.length()) - 3)); } if (serverPluginFactory.handles(srcPath)) { return serverPluginFactory.getPluginName(srcPath); } return null; }
private com.google.gerrit.extensions.common.PluginConfigInfo getPluginInfo() { com.google.gerrit.extensions.common.PluginConfigInfo info = new com.google.gerrit.extensions.common.PluginConfigInfo(); info.hasAvatars = com.google.gerrit.server.config.GetServerInfo.toBoolean(((avatar.get()) != null)); info.jsResourcePaths = new java.util.ArrayList(); for (com.google.gerrit.extensions.webui.WebUiPlugin u : plugins) { info.jsResourcePaths.add(java.lang.String.format("plugins/%s/%s", u.getPluginName(), u.getJavaScriptResourcePath())); } return info; }
@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.RestoreInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl ctl = req.getControl(); if (!(ctl.canRestore(dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("restore not permitted"); } com.google.gerrit.server.change.Restore.Op op = new com.google.gerrit.server.change.Restore.Op(input); try (com.google.gerrit.server.git.BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op).execute(); } return json.create(ChangeJson.NO_OPTIONS).format(op.change); }


@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes()); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } else if (!(rsrc.getControl().isPatchVisible(ps, dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("current revision not accessible"); } com.google.gerrit.server.change.Submit.Output out = submit.apply(new com.google.gerrit.server.change.RevisionResource(rsrc, ps), input); return json.create(ChangeJson.NO_OPTIONS).format(out.change); }
private com.google.gerrit.server.change.RevisionResource onBehalfOf(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl caller = rsrc.getControl(); if (!(caller.canSubmit())) { throw new com.google.gerrit.extensions.restapi.AuthException("submit not permitted"); } if (!(caller.canSubmitAs())) { throw new com.google.gerrit.extensions.restapi.AuthException("submit on behalf of not permitted"); } com.google.gerrit.server.project.ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf)); if (!(target.getRefControl().isVisible())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId())); } return new com.google.gerrit.server.change.RevisionResource(changes.parse(target), rsrc.getPatchSet()); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource resource) { boolean canRestore = false; try { canRestore = resource.getControl().canRestore(dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Restore.log.error("Cannot check canRestore status. Assuming false.", e); } return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Restore").setTitle("Restore the change").setVisible((((resource.getChange().getStatus()) == (com.google.gerrit.reviewdb.client.Change.Status.ABANDONED)) && canRestore)); }






private boolean can(com.google.gerrit.server.permissions.ChangePermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { try { switch (perm) { case READ : return isVisible(db(), cd); case ABANDON : return canAbandon(db()); case DELETE : return canDelete(db(), getChange().getStatus()); case ADD_PATCH_SET : return canAddPatchSet(db()); case EDIT_ASSIGNEE : return canEditAssignee(); case EDIT_DESCRIPTION : return canEditDescription(); case EDIT_HASHTAGS : return canEditHashtags(); case EDIT_TOPIC_NAME : return canEditTopicName(); case REBASE : return canRebase(db()); case REMOVE_REVIEWER : return getRefControl().canRemoveReviewer(); case RESTORE : return canRestore(db()); case SUBMIT : return canSubmit(); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.permissions.PermissionBackendException("unavailable", e); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }






@java.lang.Override public void setHashtags(com.google.gerrit.extensions.api.changes.HashtagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { postHashtags.apply(change, input); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.git.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot post hashtags", e); } }

@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.AbandonInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl(); if (!(control.canAbandon(dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("abandon not permitted"); } com.google.gerrit.reviewdb.client.Change change = abandon(control, input.message, input.notify, notifyUtil.resolveAccounts(input.notifyDetails)); return json.create(ChangeJson.NO_OPTIONS).format(change); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource resource) { boolean canAbandon = false; try { canAbandon = resource.getControl().canAbandon(dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Abandon.log.error("Cannot check canAbandon status. Assuming false.", e); } return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible((((resource.getChange().getStatus().isOpen()) && ((resource.getChange().getStatus()) != (Change.Status.DRAFT))) && canAbandon)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, AssigneeInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { if (!(rsrc.getControl().canEditAssignee())) { throw new com.google.gerrit.extensions.restapi.AuthException("Changing Assignee not permitted"); } if (((input.assignee) == null) || (input.assignee.trim().isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing assignee field"); } try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.SetAssigneeOp op = assigneeFactory.create(input.assignee); bu.addOp(rsrc.getId(), op); com.google.gerrit.server.change.PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee); bu.addOp(rsrc.getId(), reviewersAddition.op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(accountLoaderFactory.create(true).fillOne(op.getNewAssignee())); } }
@java.lang.Override public void topic(java.lang.String topic) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input(); in.topic = topic; try { putTopic.apply(change, in); } catch (com.google.gerrit.server.git.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set topic", e); } }










@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.common.collect.ImmutableSortedSet<java.lang.String>> apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.HashtagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try (com.google.gerrit.server.git.BatchUpdate bu = batchUpdateFactory.create(db.get(), req.getChange().getProject(), req.getControl().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.SetHashtagsOp op = hashtagsFactory.create(input); bu.addOp(req.getId(), op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.<com.google.common.collect.ImmutableSortedSet<java.lang.String>>ok(op.getUpdatedHashtags()); } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.RevisionResource resource) { com.google.gerrit.reviewdb.client.PatchSet patchSet = resource.getPatchSet(); com.google.gerrit.reviewdb.client.Branch.NameKey dest = resource.getChange().getDest(); boolean canRebase = false; try { canRebase = resource.getControl().canRebase(dbProvider.get()); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.change.Rebase.log.error("Cannot check canRebase status. Assuming false.", e); } boolean visible = ((resource.getChange().getStatus().isOpen()) && (resource.isCurrent())) && canRebase; boolean enabled = true; if (visible) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(dest.getParentKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { visible = hasOneParent(rw, resource.getPatchSet()); enabled = rebaseUtil.canRebase(patchSet, dest, repo, rw); } catch (java.io.IOException e) { com.google.gerrit.server.change.Rebase.log.error(("Failed to check if patch set can be rebased: " + (resource.getPatchSet())), e); visible = false; } } com.google.gerrit.extensions.webui.UiAction.Description descr = new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Rebase").setTitle("Rebase onto tip of branch or parent change").setVisible(visible).setEnabled(enabled); return descr; }
@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.RebaseInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet ps = rebase.dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId()); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } else if (!(rsrc.getControl().isPatchVisible(ps, rebase.dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("current revision not accessible"); } return rebase.apply(new com.google.gerrit.server.change.RevisionResource(rsrc, ps), input); }


public void modifyMessage(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.project.ChangeControl changeControl, java.lang.String newCommitMessage) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.edit.UnchangedCommitMessageException, com.google.gwtorm.server.OrmException, java.io.IOException { ensureAuthenticatedAndPermitted(changeControl); newCommitMessage = getWellFormedCommitMessage(newCommitMessage); java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> optionalChangeEdit = lookupChangeEdit(changeControl); com.google.gerrit.reviewdb.client.PatchSet basePatchSet = getBasePatchSet(optionalChangeEdit, changeControl); org.eclipse.jgit.revwalk.RevCommit basePatchSetCommit = com.google.gerrit.server.edit.ChangeEditModifier.lookupCommit(repository, basePatchSet); org.eclipse.jgit.revwalk.RevCommit baseCommit = optionalChangeEdit.map(ChangeEdit::getEditCommit).orElse(basePatchSetCommit); java.lang.String currentCommitMessage = baseCommit.getFullMessage(); if (newCommitMessage.equals(currentCommitMessage)) { throw new com.google.gerrit.server.edit.UnchangedCommitMessageException(); } org.eclipse.jgit.revwalk.RevTree baseTree = baseCommit.getTree(); java.sql.Timestamp nowTimestamp = com.google.gerrit.common.TimeUtil.nowTs(); org.eclipse.jgit.lib.ObjectId newEditCommit = createCommit(repository, basePatchSetCommit, baseTree, newCommitMessage, nowTimestamp); if (optionalChangeEdit.isPresent()) { updateEditReference(repository, optionalChangeEdit.get(), newEditCommit, nowTimestamp); } else { createEditReference(repository, changeControl, basePatchSet, newEditCommit, nowTimestamp); } }






@java.lang.Override public void onUpdate(org.eclipse.jgit.lib.ObjectId newNotesRev, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { com.google.common.collect.Collections2.transform(m.values(), ( e) -> e.key()).removeAll(updatedExtIds.stream().map(( e) -> e.key()).collect(toSet())); for (com.google.gerrit.server.account.externalids.ExternalId updatedExtId : updatedExtIds) { m.put(updatedExtId.accountId(), updatedExtId); } }); }
@java.lang.Override public void onReplaceByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toRemove, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { com.google.common.collect.Collections2.transform(m.values(), ( e) -> e.key()).removeAll(toRemove); for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { m.put(extId.accountId(), extId); } }); }
@java.lang.Override public void onReplaceByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toRemove, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws java.io.IOException { com.google.gerrit.server.account.externalids.ExternalIdsUpdate.checkSameAccount(toAdd, accountId); updateCache(newNotesRev, ( m) -> { com.google.common.collect.Collections2.transform(m.get(accountId), ( e) -> e.key()).removeAll(toRemove); for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { m.put(extId.accountId(), extId); } }); }
@java.lang.Override public void onReplaceByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId.Key> toRemove, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws java.io.IOException { com.google.gerrit.server.account.externalids.ExternalIdsUpdate.checkSameAccount(toAdd, accountId); updateCache(newNotesRev, ( m) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : m.get(accountId)) { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : toRemove) { if (extIdKey.equals(extId.key())) { m.remove(accountId, extId); } } } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { m.put(extId.accountId(), extId); } }); }
@java.lang.Override public void onRemoveByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : m.values()) { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { if (extIdKey.equals(extId.key())) { m.remove(extId.accountId(), extId); break; } } } }); }
@java.lang.Override public void onRemoveByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws java.io.IOException { updateCache(newNotesRev, ( m) -> com.google.common.collect.Collections2.transform(m.get(accountId), ( e) -> e.key()).removeAll(extIdKeys)); }
@java.lang.Override public void onRemoveByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws java.io.IOException { updateCache(newNotesRev, ( m) -> com.google.common.collect.Collections2.transform(m.values(), ( e) -> e.key()).removeAll(extIdKeys)); }
@java.lang.Override public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException { try { return extIdsByAccount.get(externalIdReader.readRevision()).values().stream().filter(( e) -> email.equals(e.email())).collect(java.util.stream.Collectors.toSet()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.externalids.ExternalIdCacheImpl.log.warn("Cannot list external ids by email", e); return java.util.Collections.emptySet(); } }
@java.lang.Override public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> byAccount(com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException { try { return extIdsByAccount.get(externalIdReader.readRevision()).get(accountId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.externalids.ExternalIdCacheImpl.log.warn("Cannot list external ids by account", e); return java.util.Collections.emptySet(); } }
@java.lang.Override public void onReplaceByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId.Key> toRemove, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : m.values()) { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : toRemove) { if (extIdKey.equals(extId.key())) { m.remove(extId.accountId(), extId); } } } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { m.put(extId.accountId(), extId); } }); }
@java.lang.Override public void onUpdate(org.eclipse.jgit.lib.ObjectId newNotesRev, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { for (com.google.gerrit.server.account.externalids.ExternalId updatedExtId : updatedExtIds) { for (com.google.gerrit.server.account.externalids.ExternalId extId : m.get(updatedExtId.accountId())) { if (updatedExtId.key().equals(extId.key())) { m.remove(updatedExtId.accountId(), extId); break; } } m.put(updatedExtId.accountId(), updatedExtId); } }); }
@java.lang.Override public void onRemoveByKeys(org.eclipse.jgit.lib.ObjectId newNotesRev, com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws java.io.IOException { updateCache(newNotesRev, ( m) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : m.get(accountId)) { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { if (extIdKey.equals(extId.key())) { m.remove(accountId, extId); break; } } } }); }
@java.lang.Override public com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo apply(com.google.gerrit.server.config.ConfigResource resource) { com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo info = new com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo(); info.showJobsPanel = cfg.getBoolean("showJobsPanel", true); info.showJobsDropDownPanel = cfg.getBoolean("showJobsDropDownPanel", true); info.showJobsSummaryPanel = cfg.getBoolean("showJobsSummaryPanel", true); info.sortJobsPanel = cfg.getEnum(com.googlesource.gerrit.plugins.verifystatus.server.JobsSorting.values(), "sortJobsPanel", JobsSorting.REPORTER); info.sortJobsDropDownPanel = cfg.getEnum(com.googlesource.gerrit.plugins.verifystatus.server.JobsSorting.values(), "sortJobsDropDownPanel", JobsSorting.REPORTER); return info; }

@java.lang.Override public void onPluginLoad() { com.google.gerrit.plugin.client.Plugin.get().screenRegex("jobs/(.*)", new com.googlesource.gerrit.plugins.verifystatus.client.JobsScreen.Factory()); new com.google.gerrit.plugin.client.rpc.RestApi("config").view("server").view(com.google.gerrit.plugin.client.Plugin.get().getPluginName(), "config").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo>() { @java.lang.Override public void onSuccess(com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info) { if (info.showJobsSummaryPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsSummaryPanel.Factory()); } if (info.showJobsPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory(info)); } if (info.showJobsDropDownPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory(info)); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }

@java.lang.Override public void onSuccess(com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info) { if (info.showJobsSummaryPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsSummaryPanel.Factory()); } if (info.showJobsPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory(info)); } if (info.showJobsDropDownPanel()) { com.google.gerrit.plugin.client.Plugin.get().panel(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory(info)); } }
@java.lang.Override protected final <T> java.util.concurrent.Callable<T> wrapImpl(final java.util.concurrent.Callable<T> callable) { final C ctx = continuingContext(requireContext()); return new java.util.concurrent.Callable<T>() { @java.lang.Override public T call() throws java.lang.Exception { C old = threadLocal.get(); threadLocal.set(ctx); try { return callable.call(); } finally { if (old != null) { threadLocal.set(old); } else { threadLocal.remove(); } } } }; }
com.google.common.util.concurrent.ListenableFuture<?> insert(final org.apache.lucene.document.Document doc) { return submit(new java.util.concurrent.Callable<java.lang.Long>() { @java.lang.Override public java.lang.Long call() throws java.io.IOException, java.lang.InterruptedException { return writer.addDocument(doc); } }); }
@java.lang.Override public com.google.gerrit.server.patch.IntraLineDiff call() throws java.lang.Exception { java.util.concurrent.Future<com.google.gerrit.server.patch.IntraLineDiff> result = diffExecutor.submit(new java.util.concurrent.Callable<com.google.gerrit.server.patch.IntraLineDiff>() { @java.lang.Override public com.google.gerrit.server.patch.IntraLineDiff call() throws java.lang.Exception { return com.google.gerrit.server.patch.IntraLineLoader.compute(args.aText(), args.bText(), args.edits()); } }); try { return result.get(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.InterruptedException | java.util.concurrent.TimeoutException e) { com.google.gerrit.server.patch.IntraLineLoader.log.warn(((((((((((((timeoutMillis) + " ms timeout reached for IntraLineDiff") + " in project ") + (args.project())) + " on commit ") + (args.commit().name())) + " for path ") + (args.path())) + " comparing ") + (key.getBlobA().name())) + "..") + (key.getBlobB().name()))); result.cancel(true); return new com.google.gerrit.server.patch.IntraLineDiff(IntraLineDiff.Status.TIMEOUT); } catch (java.util.concurrent.ExecutionException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.lang.Exception.class); throw new java.lang.Exception(e.getMessage(), e.getCause()); } }
public java.util.concurrent.Callable<java.lang.Void> reindexProject(final com.google.gerrit.server.index.change.ChangeIndexer indexer, final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.server.git.MultiProgressMonitor.Task done, final com.google.gerrit.server.git.MultiProgressMonitor.Task failed, final java.io.PrintWriter verboseWriter) { return new java.util.concurrent.Callable<java.lang.Void>() { @java.lang.Override public java.lang.Void call() throws java.lang.Exception { com.google.common.collect.ListMultimap<org.eclipse.jgit.lib.ObjectId, com.google.gerrit.server.query.change.ChangeData> byId = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getRefDatabase().getRefs(com.google.gerrit.server.index.change.ALL); for (com.google.gerrit.server.notedb.ChangeNotes cn : notesFactory.scan(repo, db, project)) { org.eclipse.jgit.lib.Ref r = refs.get(cn.getChange().currentPatchSetId().toRefName()); if (r != null) { byId.put(r.getObjectId(), changeDataFactory.create(db, cn)); } } new com.google.gerrit.server.index.change.AllChangesIndexer.ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.change.AllChangesIndexer.log.error(rnfe.getMessage()); } return null; } @java.lang.Override public java.lang.String toString() { return "Index all changes of project " + (project.get()); } }; }
com.google.common.util.concurrent.ListenableFuture<?> delete(final org.apache.lucene.index.Term term) { return submit(new java.util.concurrent.Callable<java.lang.Long>() { @java.lang.Override public java.lang.Long call() throws java.io.IOException, java.lang.InterruptedException { return writer.deleteDocuments(term); } }); }
com.google.common.util.concurrent.ListenableFuture<?> replace(final org.apache.lucene.index.Term term, final org.apache.lucene.document.Document doc) { return submit(new java.util.concurrent.Callable<java.lang.Long>() { @java.lang.Override public java.lang.Long call() throws java.io.IOException, java.lang.InterruptedException { return writer.updateDocument(term, doc); } }); }
@java.lang.SuppressWarnings("javadoc") public final <T> java.util.concurrent.Callable<T> wrap(final java.util.concurrent.Callable<T> callable) { final com.google.gerrit.server.util.RequestContext callerContext = checkNotNull(local.getContext()); final java.util.concurrent.Callable<T> wrapped = wrapImpl(context(callerContext, cleanup(callable))); return new java.util.concurrent.Callable<T>() { @java.lang.Override public T call() throws java.lang.Exception { if (callerContext == (local.getContext())) { return callable.call(); } return wrapped.call(); } @java.lang.Override public java.lang.String toString() { return callable.toString(); } }; }
private void ensureFixReplacementsAreAddable(java.lang.String commentPath, java.util.List<com.google.gerrit.extensions.common.FixReplacementInfo> fixReplacementInfos) throws com.google.gerrit.extensions.restapi.BadRequestException { ensureReplacementsArePresent(commentPath, fixReplacementInfos); for (com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo : fixReplacementInfos) { ensureReplacementPathIsSet(commentPath, fixReplacementInfo.path); ensureReplacementPathRefersToFileOfComment(commentPath, fixReplacementInfo.path); ensureRangeIsSet(commentPath, fixReplacementInfo.range); ensureRangeIsValid(commentPath, fixReplacementInfo.range); ensureReplacementStringIsSet(commentPath, fixReplacementInfo.replacement); } com.google.gerrit.server.change.PostReview.ensureRangesDoNotOverlap(commentPath, fixReplacementInfos); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.POLYGERRIT_INDEX_SERVLET) javax.servlet.http.HttpServlet getPolyGerritUiIndexServlet(@com.google.inject.name.Named(com.google.gerrit.httpd.raw.StaticModule.CACHE) com.google.common.cache.Cache<java.nio.file.Path, com.google.gerrit.httpd.raw.ResourceServlet.Resource> cache) { return new com.google.gerrit.httpd.raw.SingleFileServlet(cache, polyGerritBasePath().resolve("index.html"), getPaths().isDev(), false); }


private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((checkAddPatchSetPermission) && (!(origCtl.canAddPatchSet(ctx.getDb())))) { throw new com.google.gerrit.extensions.restapi.AuthException("cannot add patch set"); } if ((validatePolicy) == (CommitValidators.Policy.NONE)) { return; } java.lang.String refName = getPatchSetId().toRefName(); com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit.getId(), ((refName.substring(0, ((refName.lastIndexOf('/')) + 1))) + "new")), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getIdentifiedUser()); try { commitValidatorsFactory.create(validatePolicy, origCtl.getRefControl(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRepository()).validate(event); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if ((validatePolicy) == (CommitValidators.Policy.NONE)) { return; } try { com.google.gerrit.server.project.RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName); java.lang.String refName = psId.toRefName(); com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getIdentifiedUser()); commitValidatorsFactory.create(validatePolicy, refControl, new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRepository()).validate(event); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } }
@org.junit.Test public void testWithoutSubmodule() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithoutSubmodule(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation(repo, c); assertThat(m).isEmpty(); }
@org.junit.Test public void testWithSubmodule() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSubmodule(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation(repo, c); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactly("ERROR: submodules are not allowed: modules/library"); }
@org.junit.Test public void testKeywords() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator(null, new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE), com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE, null, null, null); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidatorTest.getPatterns().values(), com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG); java.util.Set<java.lang.String> expected = com.google.common.collect.ImmutableSet.of(("ERROR: blocked keyword(s) found in: foo.txt (Line: 1)" + " (found: myp4ssw0rd, foobar)"), ("ERROR: blocked keyword(s) found in: bar.txt (Line: 5)" + " (found: $Id: foo bar$)"), (("ERROR: blocked keyword(s) found in: " + (com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG)) + " (Line: 1) (found: foobar)")); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@org.junit.Test public void testBlocked() throws java.lang.Exception { java.lang.String[] patterns = new java.lang.String[]{ "application/pdf", "application/xml", "text/html" }; java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), patterns, false); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (application/pdf) in file: foo.pdf", "ERROR: found blocked content type (application/xml) in file: foo.xml", "ERROR: found blocked content type (text/html) in file: foo.html"); }
@org.junit.Test public void testWhitelist() throws java.lang.Exception { java.lang.String[] patterns = new java.lang.String[]{ "application/pdf", "application/xml" }; java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, makeCommit(), patterns, true); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactly("ERROR: found blocked content type (text/html) in file: foo.html"); }
@org.junit.Test public void test() throws java.lang.Exception { java.lang.String[] invalidFilenamePattern = new java.lang.String[]{ "\\[|\\]|\\*|#", "[%:@]" }; org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.performValidation(repo, c, invalidFilenamePattern); java.util.Set<java.lang.String> expected = new java.util.HashSet<>(); for (java.lang.String filenames : com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidatorTest.getInvalidFilenames()) { expected.add(("ERROR: invalid characters found in filename: " + filenames)); } assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@org.junit.Test public void testCheckRenaming() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.makeCommit(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.createEmptyDirCacheEntries(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidatorTest.INITIAL_PATHNAMES, testRepo), testRepo); org.eclipse.jgit.dircache.DirCacheEntry[] entries = new org.eclipse.jgit.dircache.DirCacheEntry[com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidatorTest.INITIAL_PATHNAMES.size()]; for (int x = 0; x < (com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidatorTest.INITIAL_PATHNAMES.size()); x++) { entries[x] = com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.createDirCacheEntry(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidatorTest.INITIAL_PATHNAMES.get(x).toUpperCase(), com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_CONTENT, testRepo); } org.eclipse.jgit.revwalk.RevCommit c1 = com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.makeCommit(entries, testRepo, c); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, c1); assertThat(m).isEmpty(); }
@org.junit.Test public void testCarriageReturn() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator(null, new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE), null, null, null); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = validator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactly("ERROR: found carriage return (CR) character in file: foo.txt"); }
@org.junit.Test public void testAddTooLongPath() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidatorTest.getMaxPathLength()); java.util.Set<java.lang.String> expected = com.google.common.collect.ImmutableSet.of(("ERROR: path too long: " + (com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidatorTest.TOO_LONG))); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
public static void visitChangedEntries(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c, com.googlesource.gerrit.plugins.uploadvalidator.TreeWalkVisitor visitor) throws java.io.IOException { try (org.eclipse.jgit.treewalk.TreeWalk tw = new org.eclipse.jgit.treewalk.TreeWalk(repo)) { tw.setRecursive(true); tw.setFilter(TreeFilter.ANY_DIFF); tw.addTree(c.getTree()); if ((c.getParentCount()) > 0) { @java.lang.SuppressWarnings("resource") org.eclipse.jgit.revwalk.RevWalk rw = null; try { for (org.eclipse.jgit.revwalk.RevCommit p : c.getParents()) { if ((p.getTree()) == null) { if (rw == null) { rw = new org.eclipse.jgit.revwalk.RevWalk(repo); } rw.parseHeaders(p); } tw.addTree(p.getTree()); } } finally { if (rw != null) { rw.close(); } } while (tw.next()) { if (com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.isDifferentToAllParents(c, tw)) { visitor.onVisit(tw); } } } else { while (tw.next()) { visitor.onVisit(tw); } } } }
@org.junit.Test public void testBlockedExtensionsCaseInsensitive() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC); java.util.List<java.lang.String> expected = new java.util.ArrayList<>(); for (java.lang.String extension : com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC) { expected.add(("ERROR: blocked file: foo." + extension)); } assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@org.junit.Test public void testBlockedExtensions() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC); java.util.List<java.lang.String> expected = new java.util.ArrayList<>(); for (java.lang.String extension : com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC) { expected.add(("ERROR: blocked file: foo." + extension)); } assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@com.google.common.annotations.VisibleForTesting java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> performValidation(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit c, com.google.common.collect.ImmutableCollection<java.util.regex.Pattern> blockedKeywordPartterns, com.google.gerrit.server.config.PluginConfig cfg) throws java.io.IOException, java.util.concurrent.ExecutionException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.LinkedList<>(); com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.checkCommitMessageForBlockedKeywords(blockedKeywordPartterns, messages, c.getFullMessage()); java.util.Map<java.lang.String, org.eclipse.jgit.lib.ObjectId> content = com.googlesource.gerrit.plugins.uploadvalidator.CommitUtils.getChangedContent(repo, c); for (java.lang.String path : content.keySet()) { org.eclipse.jgit.lib.ObjectLoader ol = repo.open(content.get(path)); if (contentTypeUtil.isBinary(ol, path, cfg)) { continue; } com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.checkFileForBlockedKeywords(blockedKeywordPartterns, messages, path, ol); } return messages; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { try { com.google.gerrit.server.config.PluginConfig cfg = cfgFactory.getFromProjectConfigWithInheritance(receiveEvent.project.getNameKey(), pluginName); if ((com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.isActive(cfg)) && (validatorConfig.isEnabledForRef(receiveEvent.user, receiveEvent.getProjectNameKey(), receiveEvent.getRefName(), com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.KEY_CHECK_BLOCKED_KEYWORD))) { com.google.common.collect.ImmutableMap<java.lang.String, java.util.regex.Pattern> blockedKeywordPatterns = patternCache.getAll(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.KEY_CHECK_BLOCKED_KEYWORD_PATTERN))); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg); if (!(messages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("includes files containing blocked keywords", messages); } } } } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException | java.util.concurrent.ExecutionException e) { throw new com.google.gerrit.server.git.validators.CommitValidationException("failed to check on blocked keywords", e); } return java.util.Collections.emptyList(); }
@org.junit.Test public void testWithSymlink() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSymlink(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.performValidation(repo, c); java.util.Set<java.lang.String> expected = com.google.common.collect.ImmutableSet.of("ERROR: Symbolic links are not allowed: foo.txt", "ERROR: Symbolic links are not allowed: symbolicFolder"); assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages(m)).containsExactlyElementsIn(expected); }
@org.junit.Test public void testWithoutSymlink() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithoutSymlink(); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.performValidation(repo, c); assertThat(m).isEmpty(); }
@org.junit.Test public void testDeleteTooLongPath() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit(); try (org.eclipse.jgit.api.Git git = new org.eclipse.jgit.api.Git(repo)) { java.util.Set<java.io.File> files = new java.util.HashSet<>(); files.add(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.createEmptyFile(com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidatorTest.TOO_LONG, repo)); com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.removeFiles(git, files); c = git.commit().setMessage("Delete file which is too long").call(); } java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> m = com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidator.performValidation(repo, c, com.googlesource.gerrit.plugins.uploadvalidator.MaxPathLengthValidatorTest.getMaxPathLength()); assertThat(m).isEmpty(); }

@com.google.gerrit.testutil.ConfigSuite.Config public static org.eclipse.jgit.lib.Config imapConfig() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "host", com.google.gerrit.acceptance.server.mail.MailIT.HOST); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "port", "3143"); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "username", com.google.gerrit.acceptance.server.mail.MailIT.USERNAME); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "password", com.google.gerrit.acceptance.server.mail.MailIT.PASSWORD); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "protocol", "IMAP"); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "fetchInterval", "99"); return cfg; }
@com.google.gerrit.testutil.ConfigSuite.Default public static org.eclipse.jgit.lib.Config pop3Config() { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "host", com.google.gerrit.acceptance.server.mail.MailIT.HOST); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "port", "3110"); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "username", com.google.gerrit.acceptance.server.mail.MailIT.USERNAME); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "password", com.google.gerrit.acceptance.server.mail.MailIT.PASSWORD); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "protocol", "POP3"); cfg.setString(com.google.gerrit.acceptance.server.mail.MailIT.RECEIVEEMAIL, null, "fetchInterval", "99"); return cfg; }

<T> boolean parse(T param, com.google.common.collect.Multimap<java.lang.String, java.lang.String> in, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gerrit.util.cli.CmdLineParser clp = parserFactory.create(param); try { clp.parseOptionMap(in); } catch (org.kohsuke.args4j.CmdLineException e) { if (!(clp.wasHelpRequestedByOption())) { com.google.gerrit.httpd.restapi.RestApiServlet.replyError(req, res, com.google.gerrit.httpd.restapi.SC_BAD_REQUEST, e.getMessage(), e); return false; } } if (clp.wasHelpRequestedByOption()) { java.io.StringWriter msg = new java.io.StringWriter(); clp.printQueryStringUsage(req.getRequestURI(), msg); msg.write('\n'); msg.write('\n'); clp.printUsage(msg, null); msg.write('\n'); com.google.gwtexpui.server.CacheHeaders.setNotCacheable(res); com.google.gerrit.httpd.restapi.RestApiServlet.replyBinaryResult(req, res, com.google.gerrit.extensions.restapi.BinaryResult.create(msg.toString()).setContentType("text/plain")); return false; } return true; }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); info.showAssignee = com.google.gerrit.server.config.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssignee", true)) && (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)))); info.largeChange = cfg.getInt("change", "largeChange", 500); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score")) + " (Shortcut: a)"; info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply")) + "\u2026"; info.updateDelay = ((int) (com.google.gerrit.server.config.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.change.Submit.wholeTopicEnabled(cfg); return info; }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) { return; } com.google.gerrit.server.git.MergeTip mergeTip = args.mergeTip; if ((args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) && (!(args.submoduleOp.hasSubscription(args.destBranch)))) { mergeTip.moveTipTo(toMerge, toMerge); } else { org.eclipse.jgit.lib.PersonIdent myIdent = new org.eclipse.jgit.lib.PersonIdent(args.serverIdent, ctx.getWhen()); com.google.gerrit.server.git.CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge); result = amendGitlink(result); mergeTip.moveTipTo(result, toMerge); args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); } }
@java.lang.Override public void updateRepoImpl(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { com.google.gerrit.server.git.MergeTip mergeTip = args.mergeTip; if ((args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) && (!(args.submoduleOp.hasSubscription(args.destBranch)))) { mergeTip.moveTipTo(toMerge, toMerge); } else { org.eclipse.jgit.lib.PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()); com.google.gerrit.server.git.CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, caller, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge); mergeTip.moveTipTo(amendGitlink(newTip), toMerge); } args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted); acceptMergeTip(mergeTip); }
private boolean validCommit(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.RefControl ctl, org.eclipse.jgit.transport.ReceiveCommand cmd, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { if (validCommits.contains(id)) { return true; } org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(id); rw.parseBody(c); com.google.gerrit.server.git.validators.CommitValidators.Policy policy; if ((((magicBranch) != null) && (cmd.getRefName().equals(magicBranch.cmd.getRefName()))) && (magicBranch.merged)) { policy = CommitValidators.Policy.MERGED; } else { policy = CommitValidators.Policy.RECEIVE_COMMITS; } try (com.google.gerrit.server.events.CommitReceivedEvent receiveEvent = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, project, ctl.getRefName(), rw.getObjectReader(), c, user)) { messages.addAll(commitValidatorsFactory.create(policy, ctl, sshInfo, repo).validate(receiveEvent)); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { logDebug("Commit validation failed on {}", c.name()); messages.addAll(e.getMessages()); reject(cmd, e.getMessage()); return false; } validCommits.add(c.copy()); return true; }
@java.lang.Override protected void updateRepoImpl(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.server.git.IntegrationException, java.io.IOException { args.rw.parseBody(toMerge); psId = com.google.gerrit.server.ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId()); org.eclipse.jgit.revwalk.RevCommit mergeTip = args.mergeTip.getCurrentTip(); args.rw.parseBody(mergeTip); java.lang.String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip); org.eclipse.jgit.lib.PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone()); try { newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false); } catch (com.google.gerrit.extensions.restapi.MergeConflictException mce) { toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT); return; } catch (com.google.gerrit.server.git.MergeIdenticalTreeException mie) { toMerge.setStatusCode(com.google.gerrit.server.git.strategy.CommitMergeStatus.SKIPPED_IDENTICAL_TREE); return; } newCommit = amendGitlink(newCommit); newCommit.copyFrom(toMerge); newCommit.setPatchsetId(psId); newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK); args.mergeTip.moveTipTo(newCommit, newCommit); args.commitStatus.put(newCommit); ctx.addRefUpdate(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), newCommit, psId.toRefName())); patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId); }
@org.junit.Test public void submitWithValidation() throws java.lang.Exception { java.util.concurrent.atomic.AtomicBoolean called = new java.util.concurrent.atomic.AtomicBoolean(false); this.addOnSubmitValidationListener(new com.google.gerrit.server.git.validators.OnSubmitValidationListener() { @java.lang.Override public void preBranchUpdate(com.google.gerrit.acceptance.rest.change.Arguments args) throws com.google.gerrit.server.validators.ValidationException { called.set(true); java.util.HashSet<java.lang.String> refs = com.google.common.collect.Sets.newHashSet(args.getCommands().keySet()); assertThat(refs).contains("refs/heads/master"); refs.remove("refs/heads/master"); if (!(refs.isEmpty())) { assertThat(refs).hasSize(1); assertThat(refs.iterator().next()).startsWith(RefNames.REFS_CHANGES); } } }); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange(); approve(change.getChangeId()); submit(change.getChangeId()); assertThat(called.get()).isTrue(); }
private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { logDebug("Executing updateRepo on {} ops", ops.size()); com.google.gerrit.server.update.NoteDbBatchUpdate.RepoContextImpl ctx = new com.google.gerrit.server.update.NoteDbBatchUpdate.RepoContextImpl(); for (com.google.gerrit.server.update.BatchUpdateOp op : ops.values()) { op.updateRepo(ctx); } logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size()); for (com.google.gerrit.server.update.RepoOnlyOp op : repoOnlyOps) { op.updateRepo(ctx); } if (((onSubmitValidators) != null) && (!(getRefUpdates().isEmpty()))) { onSubmitValidators.validate(project, new com.google.gerrit.server.update.ReadOnlyRepository(getRepository()), ctx.getInserter().newReader(), getRefUpdates()); } if ((repoView) != null) { logDebug("Flushing inserter"); repoView.getInserter().flush(); } else { logDebug("No objects to flush"); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(e); } }
public void validate(com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectReader objectReader, java.util.Map<java.lang.String, org.eclipse.jgit.transport.ReceiveCommand> commands) throws com.google.gerrit.server.git.IntegrationException { try { for (com.google.gerrit.server.git.validators.OnSubmitValidationListener listener : this.listeners) { listener.preBranchUpdate(new com.google.gerrit.server.git.validators.OnSubmitValidationListener.Arguments(project, repo, objectReader, commands)); } } catch (com.google.gerrit.server.validators.ValidationException e) { throw new com.google.gerrit.server.git.IntegrationException(e.getMessage()); } }
private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { logDebug("Executing updateRepo on {} ops", ops.size()); com.google.gerrit.server.update.ReviewDbBatchUpdate.RepoContextImpl ctx = new com.google.gerrit.server.update.ReviewDbBatchUpdate.RepoContextImpl(); for (com.google.gerrit.server.update.BatchUpdateOp op : ops.values()) { op.updateRepo(ctx); } logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size()); for (com.google.gerrit.server.update.RepoOnlyOp op : repoOnlyOps) { op.updateRepo(ctx); } if (((onSubmitValidators) != null) && (!(getRefUpdates().isEmpty()))) { onSubmitValidators.validate(project, new com.google.gerrit.server.update.ReadOnlyRepository(getRepository()), ctx.getInserter().newReader(), getRefUpdates()); } if ((repoView) != null) { logDebug("Flushing inserter"); repoView.getInserter().flush(); } else { logDebug("No objects to flush"); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(e); } }
@java.lang.Override public void preBranchUpdate(com.google.gerrit.acceptance.rest.change.Arguments args) throws com.google.gerrit.server.validators.ValidationException { called.set(true); java.util.HashSet<java.lang.String> refs = com.google.common.collect.Sets.newHashSet(args.getCommands().keySet()); assertThat(refs).contains("refs/heads/master"); refs.remove("refs/heads/master"); if (!(refs.isEmpty())) { assertThat(refs).hasSize(1); assertThat(refs.iterator().next()).startsWith(RefNames.REFS_CHANGES); } }
@java.lang.Override public void preBranchUpdate(com.google.gerrit.acceptance.rest.change.Arguments args) throws com.google.gerrit.server.validators.ValidationException { assertThat(args.getCommands().keySet()).contains("refs/heads/master"); try (org.eclipse.jgit.revwalk.RevWalk rw = args.newRevWalk()) { rw.parseBody(rw.parseCommit(args.getCommands().get("refs/heads/master").getNewId())); } catch (java.io.IOException e) { assertThat(e).isNull(); } projectsCalled.add(args.getProject().get()); if ((projectsCalled.size()) == 2) { throw new com.google.gerrit.server.validators.ValidationException("time to fail"); } }

void insertPatchSetWithoutBatchUpdate() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { try (com.google.gerrit.server.update.BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, com.google.gerrit.common.TimeUtil.nowTs());org.eclipse.jgit.lib.ObjectInserter ins = repo.newObjectInserter()) { bu.setRepository(repo, rp.getRevWalk(), ins); bu.setRequestId(receiveId); addOps(bu, replaceProgress); bu.execute(); } }

private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { logDebug("Executing updateRepo on {} ops", ops.size()); com.google.gerrit.server.update.ReviewDbBatchUpdate.RepoContextImpl ctx = new com.google.gerrit.server.update.ReviewDbBatchUpdate.RepoContextImpl(); for (com.google.gerrit.server.update.BatchUpdateOp op : ops.values()) { op.updateRepo(ctx); } logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size()); for (com.google.gerrit.server.update.RepoOnlyOp op : repoOnlyOps) { op.updateRepo(ctx); } if ((((onSubmitValidators) != null) && ((commands) != null)) && (!(commands.isEmpty()))) { onSubmitValidators.validate(project, new com.google.gerrit.server.update.ReadOnlyRepository(getRepository()), ctx.getInserter().newReader(), commands.getCommands()); } if ((inserter) != null) { logDebug("Flushing inserter"); inserter.flush(); } else { logDebug("No objects to flush"); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(e); } }
protected com.google.gerrit.reviewdb.client.Change newPatchSet(org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo, com.google.gerrit.reviewdb.client.Change c) throws java.lang.Exception { int n = (c.currentPatchSetId().get()) + 1; org.eclipse.jgit.revwalk.RevCommit commit = repo.parseBody(repo.commit().message("message").add(("file" + n), ("contents " + n)).create()); com.google.gerrit.server.project.ChangeControl ctl = changeControlFactory.controlFor(db, c, user); com.google.gerrit.server.change.PatchSetInserter inserter = patchSetFactory.create(ctl, new com.google.gerrit.reviewdb.client.PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db, c.getProject(), user, com.google.gerrit.common.TimeUtil.nowTs());org.eclipse.jgit.lib.ObjectInserter oi = repo.getRepository().newObjectInserter()) { bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi); bu.addOp(c.getId(), inserter); bu.execute(); } return inserter.getChange(); }
private void executeUpdateRepo() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { logDebug("Executing updateRepo on {} ops", ops.size()); com.google.gerrit.server.update.NoteDbBatchUpdate.RepoContextImpl ctx = new com.google.gerrit.server.update.NoteDbBatchUpdate.RepoContextImpl(); for (com.google.gerrit.server.update.BatchUpdateOp op : ops.values()) { op.updateRepo(ctx); } logDebug("Executing updateRepo on {} RepoOnlyOps", repoOnlyOps.size()); for (com.google.gerrit.server.update.RepoOnlyOp op : repoOnlyOps) { op.updateRepo(ctx); } if ((((onSubmitValidators) != null) && ((commands) != null)) && (!(commands.isEmpty()))) { onSubmitValidators.validate(project, new com.google.gerrit.server.update.ReadOnlyRepository(getRepository()), ctx.getInserter().newReader(), commands.getCommands()); } if ((inserter) != null) { logDebug("Flushing inserter"); inserter.flush(); } else { logDebug("No objects to flush"); } } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(e); } }

@java.lang.Override public void updateRepo(com.google.gerrit.server.update.RepoContext ctx) throws java.lang.Exception { commit = ctx.getRevWalk().parseCommit(commitId); ctx.getRevWalk().parseBody(commit); changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), ctx.getRevWalk(), priorCommitId, commitId); if (checkMergedInto) { org.eclipse.jgit.lib.Ref mergedInto = com.google.gerrit.server.git.ReplaceOp.findMergedInto(ctx, dest.get(), commit); if (mergedInto != null) { mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName()); } } if (updateRef) { ctx.addRefUpdate(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commitId, patchSetId.toRefName())); } }
@com.google.common.annotations.VisibleForTesting static boolean reviewDbChangeIsStale(com.google.gerrit.reviewdb.client.Change indexChange, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change reviewDbChange) { if (reviewDbChange == null) { return false; } checkArgument(indexChange.getId().equals(reviewDbChange.getId()), "mismatched change ID: %s != %s", indexChange.getId(), reviewDbChange.getId()); if ((com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage.of(reviewDbChange)) != (com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage.REVIEW_DB)) { return false; } return (reviewDbChange.getRowVersion()) != (indexChange.getRowVersion()); }

@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getName()); } return apply(rsrc.getControl(), input); }
private void emailReviewers(com.google.gerrit.reviewdb.client.Change change, java.util.List<com.google.gerrit.server.change.PostReviewers.Addition> reviewerAdditions, com.google.gerrit.extensions.api.changes.NotifyHandling notify, com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify) { java.util.List<com.google.gerrit.reviewdb.client.Account.Id> to = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.Account.Id> cc = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.server.mail.Address> toByEmail = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.server.mail.Address> ccByEmail = new java.util.ArrayList<>(); for (com.google.gerrit.server.change.PostReviewers.Addition addition : reviewerAdditions) { if ((addition.op.state) == (com.google.gerrit.extensions.client.ReviewerState.REVIEWER)) { to.addAll(addition.op.reviewers.keySet()); toByEmail.addAll(addition.op.reviewersByEmail); } else if ((addition.op.state) == (com.google.gerrit.extensions.client.ReviewerState.CC)) { cc.addAll(addition.op.reviewers.keySet()); ccByEmail.addAll(addition.op.reviewersByEmail); } } postReviewers.emailReviewers(change, to, cc, toByEmail, ccByEmail, notify, accountsToNotify); }

public com.google.gerrit.server.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Account.Id accountId; try { accountId = accounts.parse(input.reviewer).getAccountId(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { com.google.gerrit.server.git.ProjectConfig projectConfig = projectCache.checkedGet(rsrc.getProject()).getConfig(); if (allowGroup) { try { return putGroup(rsrc, input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e2) { if (!(projectConfig.getEnableReviewerByEmail())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFoundUserOrGroup, input.reviewer)); } } } if (!(projectConfig.getEnableReviewerByEmail())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFoundUser, input.reviewer)); } return putAccountByEmail(input.reviewer, rsrc, input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails)); } return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails)); }

private void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { try (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.destRepoKey.toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.srcRepoKey.toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.destBranch.equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.destBranch); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.readBlob(srcRepo, ((srcRef + ":") + (c.xmlPath)))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.recordSubmoduleLabels).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setURI(c.srcRepoUrl.toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritIncludeReader(srcRepo, srcRef)); org.eclipse.jgit.revwalk.RevCommit commit = cmd.call(); } }

@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.changes.ReviewerInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.change.ReviewerResource> reviewers = new java.util.LinkedHashMap<>(); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); for (com.google.gerrit.reviewdb.client.Account.Id accountId : approvalsUtil.getReviewers(db, rsrc.getNotes()).all()) { if (!(reviewers.containsKey(accountId))) { reviewers.put(accountId, resourceFactory.create(rsrc, accountId)); } } return json.format(reviewers.values()); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.changes.ReviewerInfo> apply(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (!(rsrc.isCurrent())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Cannot list reviewers on non-current patch set"); } java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.change.ReviewerResource> reviewers = new java.util.LinkedHashMap<>(); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); for (com.google.gerrit.reviewdb.client.Account.Id accountId : approvalsUtil.getReviewers(db, rsrc.getNotes()).all()) { if (!(reviewers.containsKey(accountId))) { reviewers.put(accountId, resourceFactory.create(rsrc, accountId)); } } return json.format(reviewers.values()); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.changes.ReviewResult> apply(com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { return apply(revision, input, com.google.gerrit.common.TimeUtil.nowTs()); }


public com.google.gerrit.common.data.LabelTypes getLabelTypes() { return changeControl.getLabelTypes(); }
@java.lang.SuppressWarnings({ "rawtypes", "unchecked" }) public void execute(java.util.Collection<com.google.gerrit.server.update.BatchUpdate> updates, com.google.gerrit.server.update.BatchUpdateListener listener, @com.google.gerrit.common.Nullable com.google.gerrit.server.util.RequestId requestId, boolean dryRun) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { checkNotNull(listener); if (migration.disableChangeReviewDb()) { com.google.common.collect.ImmutableList<com.google.gerrit.server.update.NoteDbBatchUpdate> noteDbUpdates = ((com.google.common.collect.ImmutableList) (com.google.common.collect.ImmutableList.copyOf(updates))); com.google.gerrit.server.update.NoteDbBatchUpdate.execute(noteDbUpdates, listener, requestId, dryRun); } else { com.google.common.collect.ImmutableList<com.google.gerrit.server.update.ReviewDbBatchUpdate> reviewDbUpdates = ((com.google.common.collect.ImmutableList) (com.google.common.collect.ImmutableList.copyOf(updates))); com.google.gerrit.server.update.ReviewDbBatchUpdate.execute(reviewDbUpdates, listener, requestId, dryRun); } }



private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.server.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.server.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.List<com.google.gerrit.server.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = json.create(options).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if (results.get(n).more()) { info.get(((info.size()) - 1))._moreChanges = true; } } return res; }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.extensions.common.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.extensions.common.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, e.email), new com.google.gerrit.server.account.DeleteEmail.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.extensions.api.accounts.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid email address"); } if ((input.noConfirmation) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow adding emails"); } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.Email rsrc, com.google.gerrit.server.account.DeleteEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete email address"); } return apply(rsrc.getUser(), rsrc.getEmail()); }
@java.lang.Override public void addEmail(com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), input.email); try { createEmailFactory.create(input.email).apply(rsrc, input); } catch (com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add email", e); } }
@java.lang.Override public void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), email); try { deleteEmail.apply(rsrc, null); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete email", e); } }
private void addEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput(); in.email = email; in.noConfirmation = true; try { createEmailFactory.create(email).apply(rsrc, in); } catch (com.google.gerrit.common.errors.EmailException e) { throw die(e.getMessage()); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { maxCommandWidth = (wide) ? java.lang.Integer.MAX_VALUE : (((((columns) - 8) - 12) - 12) - 4) - 4; stdout.print(java.lang.String.format("%-8s %-12s %-12s %-4s %s\n", "Task", "State", "StartTime", "", "Command")); stdout.print("------------------------------------------------------------------------------\n"); java.util.List<com.google.gerrit.server.config.ListTasks.TaskInfo> tasks; try { tasks = listTasks.apply(new com.google.gerrit.server.config.ConfigResource()); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw die(e); } boolean viewAll = currentUser.getCapabilities().canViewQueue(); long now = com.google.gerrit.common.TimeUtil.nowMs(); if (groupByQueue) { com.google.common.collect.ListMultimap<java.lang.String, com.google.gerrit.server.config.ListTasks.TaskInfo> byQueue = byQueue(tasks); for (java.lang.String queueName : byQueue.keySet()) { com.google.gerrit.server.git.WorkQueue.Executor e = workQueue.getExecutor(queueName); stdout.print(java.lang.String.format("Queue: %s\n", queueName)); print(byQueue.get(queueName), now, viewAll, e.getCorePoolSize()); } } else { print(tasks, now, viewAll, 0); } }



private com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.ExternalIdUpdateListener(accountCache, repoManager, allUsers))); }
private com.google.gerrit.server.git.validators.CommitValidators forReceiveCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(repo, rw); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.CommitterUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.BannedCommitsValidator(rejectCommits), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.ExternalIdUpdateListener(accountCache, repoManager, allUsers))); } }
@org.junit.Test public void pushToExternalIdsBranchRejectsExternalIdWithoutAccountId() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (((com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS) + ":") + (com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS))); allUsersRepo.reset(RefNames.REFS_EXTERNAL_IDS); org.eclipse.jgit.lib.ObjectId rev = com.google.gerrit.server.account.externalids.ExternalIdReader.readRevision(allUsersRepo.getRepository()); org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(allUsersRepo.getRevWalk(), rev); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.create(ExternalId.Key.parse("foo:bar"), admin.id); try (org.eclipse.jgit.lib.ObjectInserter ins = allUsersRepo.getRepository().newObjectInserter()) { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); org.eclipse.jgit.lib.Config c = new org.eclipse.jgit.lib.Config(); extId.writeToConfig(c); c.unset("externalId", extId.key().get(), "accountId"); byte[] raw = c.toText().getBytes(java.nio.charset.StandardCharsets.UTF_8); org.eclipse.jgit.lib.ObjectId dataBlob = ins.insert(com.google.gerrit.acceptance.rest.account.OBJ_BLOB, raw); noteMap.set(noteId, dataBlob); com.google.gerrit.server.account.externalids.ExternalIdsUpdate.commit(allUsersRepo.getRepository(), allUsersRepo.getRevWalk(), ins, rev, noteMap, "Add external ID", admin.getIdent(), admin.getIdent()); allUsersRepo.reset(RefNames.REFS_EXTERNAL_IDS); } allowPushOfExternalIds(); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.pushHead(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); assertRefUpdateFailure(r.getRemoteUpdate(RefNames.REFS_EXTERNAL_IDS), "invalid external IDs"); }
@org.junit.Test public void pushToExternalIdsBranchRejectsBadPassword() throws java.lang.Exception { testPushToExternalIdsBranchRejectsInvalidExternalId(com.google.gerrit.server.account.externalids.ExternalId.create(ExternalId.Key.create(com.google.gerrit.acceptance.rest.account.SCHEME_USERNAME, "foo"), admin.id, null, "non-hashed-password-is-not-allowed")); }
@org.junit.Test public void pushToExternalIdsBranch() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (((com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS) + ":") + (com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS))); allUsersRepo.reset(RefNames.REFS_EXTERNAL_IDS); com.google.gerrit.server.account.externalids.ExternalId newExtId = com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(ExternalId.Key.parse("foo:bar"), admin.id, admin.email.toUpperCase(java.util.Locale.US), "password"); addExtId(allUsersRepo, newExtId); allUsersRepo.reset(RefNames.REFS_EXTERNAL_IDS); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> extIdsBefore = gApi.accounts().self().getExternalIds(); allowPushOfExternalIds(); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.pushHead(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); assertThat(r.getRemoteUpdate(RefNames.REFS_EXTERNAL_IDS).getStatus()).isEqualTo(Status.OK); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> extIdsAfter = gApi.accounts().self().getExternalIds(); assertThat(extIdsAfter).containsExactlyElementsIn(com.google.common.collect.Iterables.concat(extIdsBefore, com.google.common.collect.ImmutableSet.of(toExternalIdInfo(newExtId)))); }




private java.util.List<com.google.gerrit.server.project.ChangeControl> asChangeControls(java.util.List<com.google.gerrit.server.query.change.ChangeData> cds, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = new java.util.ArrayList(cds.size()); for (com.google.gerrit.server.query.change.ChangeData cd : cds) { ctls.add(cd.changeControl(user)); } return ctls; }
public static com.google.gerrit.server.index.IndexConfig fromConfig(org.eclipse.jgit.lib.Config cfg) { return com.google.gerrit.server.index.IndexConfig.create(cfg.getInt("index", null, "maxLimit", 0), cfg.getInt("index", null, "maxPages", 0), cfg.getInt("index", null, "maxTerms", 0)); }
@org.junit.Before public void setUp() throws java.lang.Exception { index = new com.google.gerrit.server.index.change.FakeChangeIndex(FakeChangeIndex.V2); indexes = new com.google.gerrit.server.index.change.ChangeIndexCollection(); indexes.setSearchIndex(index); queryBuilder = new com.google.gerrit.server.index.change.FakeQueryBuilder(indexes); rewrite = new com.google.gerrit.server.index.change.ChangeIndexRewriter(indexes, com.google.gerrit.server.index.IndexConfig.create(0, 0, 3)); }
private java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException { if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return com.google.common.collect.ImmutableSet.of(); } try (com.google.gerrit.metrics.Timer0.Context ctx = readAllLatency.start();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = rw.getObjectReader().open(note.getData(), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.externalids.ExternalIdReader.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; } }
public void createMergesAndHandleConflicts(com.googlesource.gerrit.plugins.automerger.MultipleDownstreamMergeInput mdsMergeInput) throws com.google.gerrit.extensions.restapi.RestApiException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput(); java.util.Map<java.lang.String, java.lang.Short> labels = new java.util.HashMap<java.lang.String, java.lang.Short>(); short vote = 0; try { createDownstreamMerges(mdsMergeInput); reviewInput.message = ("Automerging to " + (com.google.common.base.Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()))) + " succeeded!"; reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } catch (com.googlesource.gerrit.plugins.automerger.FailedMergeException e) { reviewInput.message = e.getDisplayString(); reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; vote = -1; } labels.put(config.getAutomergeLabel(), vote); reviewInput.labels = labels; gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput); }

<T> boolean parse(T param, com.google.common.collect.Multimap<java.lang.String, java.lang.String> in, javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { com.google.gerrit.util.cli.CmdLineParser clp = parserFactory.create(param); com.google.gerrit.server.DynamicOptions pluginOptions = new com.google.gerrit.server.DynamicOptions(param, dynamicBeans); pluginOptions.parseDynamicBeans(clp); pluginOptions.setDynamicBeans(); pluginOptions.onBeanParseStart(); try { clp.parseOptionMap(in); } catch (org.kohsuke.args4j.CmdLineException | java.lang.NumberFormatException e) { if (!(clp.wasHelpRequestedByOption())) { com.google.gerrit.httpd.restapi.RestApiServlet.replyError(req, res, com.google.gerrit.httpd.restapi.SC_BAD_REQUEST, e.getMessage(), e); return false; } } if (clp.wasHelpRequestedByOption()) { java.io.StringWriter msg = new java.io.StringWriter(); clp.printQueryStringUsage(req.getRequestURI(), msg); msg.write('\n'); msg.write('\n'); clp.printUsage(msg, null); msg.write('\n'); com.google.gwtexpui.server.CacheHeaders.setNotCacheable(res); com.google.gerrit.httpd.restapi.RestApiServlet.replyBinaryResult(req, res, com.google.gerrit.extensions.restapi.BinaryResult.create(msg.toString()).setContentType("text/plain")); return false; } pluginOptions.onBeanParseEnd(); return true; }


@java.lang.Override protected void run() { stdout.print("Hello, example administrator\n"); }

public java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> getNameKeys() throws com.google.gerrit.server.project.NoSuchProjectException { java.util.List<com.google.gerrit.reviewdb.client.Project> pList = getProjects(); final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> nameKeys = new java.util.ArrayList(pList.size()); for (com.google.gerrit.reviewdb.client.Project p : pList) { nameKeys.add(p.getNameKey()); } return nameKeys; }
private void parseUpdate(org.eclipse.jgit.transport.ReceiveCommand cmd) { logDebug("Updating {}", cmd); com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.canUpdate()) { if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); batch.addCommand(cmd); } else { if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.CONFIG_UPDATE, RefNames.REFS_CONFIG); } else { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.UPDATE, ctl.getRefName()); } reject(cmd); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi create(com.google.gerrit.extensions.common.ChangeInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.common.ChangeInfo out = createChange.apply(TopLevelResource.INSTANCE, in).value(); return api.create(changes.parse(new com.google.gerrit.reviewdb.client.Change.Id(out._number))); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gerrit.server.git.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create change", e); } }
private void checkGlobalCapabilityPermissions(com.google.gerrit.reviewdb.client.Project.NameKey projectName) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException { if (!(allProjects.equals(projectName))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("Cannot edit global capabilities for projects other than " + (allProjects.get()))); } if (!(identifiedUser.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("Editing global capabilities requires " + (com.google.gerrit.common.data.GlobalCapability.ADMINISTRATE_SERVER))); } }
public java.util.List<com.google.gerrit.reviewdb.client.Project> getProjects() throws com.google.gerrit.server.project.NoSuchProjectException { java.util.Set<com.google.gerrit.reviewdb.client.Project> projects = new java.util.TreeSet<>(new java.util.Comparator<com.google.gerrit.reviewdb.client.Project>() { @java.lang.Override public int compare(com.google.gerrit.reviewdb.client.Project o1, com.google.gerrit.reviewdb.client.Project o2) { return o1.getName().compareTo(o2.getName()); } }); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all()) { try { final com.google.gerrit.server.project.ProjectControl control = projectControlFactory.controlFor(p); final com.google.gerrit.reviewdb.client.Project.NameKey parentK = control.getProject().getParent(); if (parentK != null) { com.google.gerrit.server.project.ProjectControl pControl = projectControlFactory.controlFor(parentK); if ((pControl.isVisible()) || (pControl.isOwner())) { projects.add(pControl.getProject()); } } } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } } projects.add(projectControlFactory.controlFor(allProject).getProject()); return new java.util.ArrayList(projects); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.DeleteChange.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.UpdateException { try (com.google.gerrit.server.git.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.Change.Id id = rsrc.getChange().getId(); bu.setOrder(BatchUpdate.Order.DB_BEFORE_REPO); bu.addOp(id, opProvider.get()); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override protected boolean shouldSendMessage() { return (((sshKey) != null) || ((gpgKeys.size()) > 0)) && ((user.equals(callingUser)) || (!(callingUser.getCapabilities().canAdministrateServer()))); }
public boolean canDelete(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change.Status status) throws com.google.gwtorm.server.OrmException { if (!(isVisible(db))) { return false; } switch (status) { case DRAFT : return ((isOwner()) || (getRefControl().canDeleteDrafts())) || (isAdmin()); case NEW : case ABANDONED : return isAdmin(); case MERGED : default : return false; } }
private boolean isActionAllowed(com.google.gerrit.server.project.ChangeControl changeControl, com.google.gerrit.reviewdb.client.Change.Status status) { return ((status != (com.google.gerrit.reviewdb.client.Change.Status.DRAFT)) || (allowDrafts)) || (changeControl.isAdmin()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to clear HTTP password"); } newPassword = null; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "requires the Administrate Server permission")); } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
private java.util.List<com.google.gerrit.extensions.common.ProjectInfo> getChildProjectsRecursively(com.google.gerrit.server.project.ProjectNode p) { java.util.List<com.google.gerrit.extensions.common.ProjectInfo> allChildren = new java.util.ArrayList<>(); for (com.google.gerrit.server.project.ProjectNode c : p.getChildren()) { if (c.isVisible()) { allChildren.add(json.format(c.getProject())); allChildren.addAll(getChildProjectsRecursively(c)); } } return allChildren; }
private java.util.List<com.google.gerrit.extensions.common.ProjectInfo> getDirectChildProjects(com.google.gerrit.reviewdb.client.Project.NameKey parent) { java.util.List<com.google.gerrit.extensions.common.ProjectInfo> childProjects = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : projectCache.all()) { com.google.gerrit.server.project.ProjectState e = projectCache.get(projectName); if (e == null) { continue; } if (parent.equals(e.getProject().getParent(allProjects))) { childProjects.add(json.format(e.getProject())); } } return childProjects; }

private static java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getProject().getName())); com.google.gerrit.server.project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.extensions.common.ProjectInfo p : children.apply(new com.google.gerrit.server.project.ProjectResource(projectState.controlFor(self.get())))) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } return r; }

private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isReadable(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutUsername.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get()) != (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set username"); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing username"); } if (input == null) { input = new com.google.gerrit.server.account.PutUsername.Input(); } try { changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call(); } catch (java.lang.IllegalStateException e) { if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(e.getMessage()); } throw e; } catch (com.google.gerrit.server.account.InvalidUserNameException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("invalid username"); } catch (com.google.gerrit.common.errors.NameAlreadyUsedException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("username already used"); } return input.username; }

private com.google.gerrit.server.change.PostReviewers.Addition putAccount(java.lang.String reviewer, com.google.gerrit.server.change.ReviewerResource rsrc, com.google.gerrit.extensions.client.ReviewerState state, com.google.gerrit.extensions.api.changes.NotifyHandling notify, com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser().getAccount(); com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl(); if (isValidReviewer(member, control)) { return new com.google.gerrit.server.change.PostReviewers.Addition(reviewer, rsrc.getChangeResource(), com.google.common.collect.ImmutableMap.of(member.getId(), control), state, notify, accountsToNotify); } if (member.isActive()) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Change not visible to %s", reviewer)); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Account of %s is inactive.", reviewer)); }
com.google.gerrit.server.change.PostReviewers.Addition ccCurrentUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.change.RevisionResource revision) { return new com.google.gerrit.server.change.PostReviewers.Addition(user.getUserName(), revision.getChangeResource(), com.google.common.collect.ImmutableMap.of(user.getAccountId(), revision.getControl()), CC, com.google.gerrit.extensions.api.changes.NotifyHandling.NONE, com.google.common.collect.ImmutableListMultimap.of()); }
private void emailReviewers(com.google.gerrit.reviewdb.client.Change change, java.util.List<com.google.gerrit.server.change.PostReviewers.Addition> reviewerAdditions, com.google.gerrit.extensions.api.changes.NotifyHandling notify, com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify) { java.util.List<com.google.gerrit.reviewdb.client.Account.Id> to = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.Account.Id> cc = new java.util.ArrayList<>(); for (com.google.gerrit.server.change.PostReviewers.Addition addition : reviewerAdditions) { if ((addition.op.state) == (com.google.gerrit.extensions.client.ReviewerState.REVIEWER)) { to.addAll(addition.op.reviewers.keySet()); } else if ((addition.op.state) == (com.google.gerrit.extensions.client.ReviewerState.CC)) { cc.addAll(addition.op.reviewers.keySet()); } } postReviewers.emailReviewers(change, to, cc, notify, accountsToNotify); }
void gatherResults() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { if ((migration.readChanges()) && ((op.state) == (CC))) { result.ccs = com.google.common.collect.Lists.newArrayListWithCapacity(op.addedCCs.size()); for (com.google.gerrit.reviewdb.client.Account.Id accountId : op.addedCCs) { com.google.gerrit.server.project.ChangeControl ctl = reviewers.get(accountId); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = permissionBackend.user(ctl.getUser()).database(dbProvider).change(ctl.getNotes()); result.ccs.add(json.format(new com.google.gerrit.extensions.api.changes.ReviewerInfo(accountId.get()), perm, ctl)); } accountLoaderFactory.create(true).fill(result.ccs); } else { result.reviewers = com.google.common.collect.Lists.newArrayListWithCapacity(op.addedReviewers.size()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : op.addedReviewers) { com.google.gerrit.server.project.ChangeControl ctl = reviewers.get(psa.getAccountId()); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = permissionBackend.user(ctl.getUser()).database(dbProvider).change(ctl.getNotes()); result.reviewers.add(json.format(new com.google.gerrit.extensions.api.changes.ReviewerInfo(psa.getAccountId().get()), perm, ctl, com.google.common.collect.ImmutableList.of(psa))); } accountLoaderFactory.create(true).fill(result.reviewers); } }
public com.google.gerrit.server.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Account.Id accountId; try { accountId = accounts.parse(input.reviewer).getAccountId(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { if (allowGroup) { try { return putGroup(rsrc, input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e2) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFoundUserOrGroup, input.reviewer)); } } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.text.MessageFormat.format(com.google.gerrit.server.change.ChangeMessages.get().reviewerNotFoundUser, input.reviewer)); } return putAccount(input.reviewer, reviewerFactory.create(rsrc, accountId), input.state(), input.notify, notifyUtil.resolveAccounts(input.notifyDetails)); }
@java.lang.Override public void clearReviewed(com.google.gerrit.reviewdb.client.PatchSet.Id psId) throws com.google.gwtorm.server.OrmException { try (java.sql.Connection con = ds.getConnection();java.sql.PreparedStatement stmt = con.prepareStatement(("DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID + ? AND PATCH_SET_ID = ?"))) { stmt.setInt(1, psId.getParentKey().get()); stmt.setInt(2, psId.get()); stmt.executeUpdate(); } catch (java.sql.SQLException e) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError("delete", e); } }
@java.lang.Override public void clearReviewed(com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String path) throws com.google.gwtorm.server.OrmException { try (java.sql.Connection con = ds.getConnection();java.sql.PreparedStatement stmt = con.prepareStatement(("DELETE FROM ACCOUNT_PATCH_REVIEWS " + ("WHERE ACCOUNT_ID = ? AND CHANGE_ID + ? AND " + "PATCH_SET_ID = ? AND FILE_NAME = ?")))) { stmt.setInt(1, accountId.get()); stmt.setInt(2, psId.getParentKey().get()); stmt.setInt(3, psId.get()); stmt.setString(4, path); stmt.executeUpdate(); } catch (java.sql.SQLException e) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError("delete", e); } }

@java.lang.Override public java.util.Collection<java.lang.String> findReviewed(com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { try (java.sql.Connection con = ds.getConnection();java.sql.PreparedStatement stmt = con.prepareStatement(("SELECT FILE_NAME FROM ACCOUNT_PATCH_REVIEWS " + "WHERE ACCOUNT_ID = ? AND CHANGE_ID = ? AND PATCH_SET_ID = ?"))) { stmt.setInt(1, accountId.get()); stmt.setInt(2, psId.getParentKey().get()); stmt.setInt(3, psId.get()); try (java.sql.ResultSet rs = stmt.executeQuery()) { java.util.List<java.lang.String> files = new java.util.ArrayList<>(); while (rs.next()) { files.add(rs.getString("FILE_NAME")); } return files; } } catch (java.sql.SQLException e) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError("select", e); } }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE); info.showAssigneeInChangesTable = com.google.gerrit.server.config.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)) && hasAssigneeInIndex)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply and score")) + " (Shortcut: a)"; info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply")) + "\u2026"; info.updateDelay = ((int) (com.google.gerrit.server.config.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.change.Submit.wholeTopicEnabled(cfg); return info; }

@java.lang.Override public com.google.common.base.Optional<com.google.gerrit.server.schema.PatchSetWithReviewedFiles> findReviewed(com.google.gerrit.reviewdb.client.PatchSet.Id psId, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { java.sql.Connection con = ds.getConnection(); java.sql.PreparedStatement stmt; }

public com.google.gerrit.testutil.TestNotesMigration setFromEnv() { switch (com.google.gerrit.testutil.NoteDbMode.get()) { case READ_WRITE : setWriteChanges(true); setReadChanges(true); setChangePrimaryStorage(PrimaryStorage.REVIEW_DB); setDisableChangeReviewDb(false); break; case WRITE : setWriteChanges(true); setReadChanges(false); setChangePrimaryStorage(PrimaryStorage.REVIEW_DB); setDisableChangeReviewDb(false); break; case PRIMARY : setWriteChanges(true); setReadChanges(true); setChangePrimaryStorage(PrimaryStorage.NOTE_DB); setDisableChangeReviewDb(false); break; case DISABLE_CHANGE_REVIEW_DB : setWriteChanges(true); setReadChanges(true); setChangePrimaryStorage(PrimaryStorage.NOTE_DB); setDisableChangeReviewDb(true); break; case CHECK : case OFF : default : setWriteChanges(false); setReadChanges(false); setChangePrimaryStorage(PrimaryStorage.REVIEW_DB); setDisableChangeReviewDb(false); break; } return this; }

@java.lang.Override public void onGitReferenceUpdated(com.amd.gerrit.plugins.manifestsubscription.Event event) { java.lang.String projectName = event.getProjectName(); java.lang.String refName = event.getRefName(); java.lang.String branchName = (refName.startsWith("refs/heads/")) ? refName.substring(11) : ""; com.amd.gerrit.plugins.manifestsubscription.ProjectBranchKey pbKey = new com.amd.gerrit.plugins.manifestsubscription.ProjectBranchKey(projectName, branchName); if (event.getNewObjectId().equals(org.eclipse.jgit.lib.ObjectId.zeroId().toString())) { com.amd.gerrit.plugins.manifestsubscription.ManifestSubscription.log.info(((("Project: " + projectName) + "\nrefName: ") + refName)); } else if (com.amd.gerrit.plugins.manifestsubscription.REFS_CONFIG.equals(refName)) { processProjectConfigChange(event); } else if ((enabledManifestSource.containsKey(projectName)) && (enabledManifestSource.get(projectName).getBranches().contains(branchName))) { processManifestChange(event, projectName, branchName); } else if (subscribedRepos.containsRow(pbKey)) { java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.util.Set<com.amd.gerrit.plugins.manifestsubscription.manifest.Project>>> destinations = subscribedRepos.row(pbKey); for (java.lang.String store : destinations.keySet()) { for (java.lang.String storeBranch : destinations.get(store).keySet()) { java.util.Set<com.amd.gerrit.plugins.manifestsubscription.manifest.Project> ps = destinations.get(store).get(storeBranch); com.amd.gerrit.plugins.manifestsubscription.manifest.Manifest manifest = manifestStores.get(store, storeBranch); java.lang.String manifestSrc = manifestSource.get(store, storeBranch); java.lang.StringBuilder extraCommitMsg = new java.lang.StringBuilder(); com.google.gerrit.reviewdb.client.Project.NameKey p = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); try (org.eclipse.jgit.lib.Repository r = gitRepoManager.openRepository(p);org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(event.getNewObjectId())); extraCommitMsg.append(event.getNewObjectId().substring(0, 7)); extraCommitMsg.append(" "); extraCommitMsg.append(projectName); extraCommitMsg.append(" "); extraCommitMsg.append(c.getShortMessage()); } catch (java.io.IOException e) { e.printStackTrace(); } for (com.amd.gerrit.plugins.manifestsubscription.manifest.Project updateProject : ps) { updateProject.setRevision(event.getNewObjectId()); } try { com.amd.gerrit.plugins.manifestsubscription.Utilities.updateManifest(gitRepoManager, metaDataUpdateFactory, changeHooks, store, ((com.amd.gerrit.plugins.manifestsubscription.ManifestSubscription.STORE_BRANCH_PREFIX) + storeBranch), manifest, manifestSrc, extraCommitMsg.toString(), null); } catch (javax.xml.bind.JAXBException | java.io.IOException e) { e.printStackTrace(); } } } } }

@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { java.lang.String url = com.google.gerrit.server.schema.H2AccountPatchReviewStore.getUrl(sitePaths); com.google.gerrit.server.schema.H2AccountPatchReviewStore.dropTableIfExists(url); com.google.gerrit.server.schema.H2AccountPatchReviewStore.createTableIfNotExists(url); try (java.sql.Connection con = java.sql.DriverManager.getConnection(url);java.sql.PreparedStatement stmt = con.prepareStatement(("INSERT INTO account_patch_reviews " + ("(account_id, change_id, patch_set_id, file_name) VALUES " + "(?, ?, ?, ?)")))) { int batchCount = 0; try (java.sql.Statement s = newStatement(db);java.sql.ResultSet rs = s.executeQuery("SELECT * from account_patch_reviews")) { while (rs.next()) { stmt.setInt(1, rs.getInt("account_id")); stmt.setInt(2, rs.getInt("change_id")); stmt.setInt(3, rs.getInt("patch_set_id")); stmt.setString(4, rs.getString("file_name")); stmt.addBatch(); batchCount++; if (batchCount >= (com.google.gerrit.server.schema.Schema_127.MAX_BATCH_SIZE)) { stmt.executeBatch(); batchCount = 0; } } } if (batchCount > 0) { stmt.executeBatch(); } } catch (java.sql.SQLException e) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError("insert", e); } }









public static com.google.gwtorm.server.OrmException convertError(java.lang.String op, java.sql.SQLException err) { switch (com.google.gerrit.server.schema.H2AccountPatchReviewStore.getSQLStateInt(err)) { case 23001 : case 23505 : return new com.google.gwtorm.server.OrmDuplicateKeyException("ACCOUNT_PATCH_REVIEWS", err); default : if (((err.getCause()) == null) && ((err.getNextException()) != null)) { err.initCause(err.getNextException()); } return new com.google.gwtorm.server.OrmException((op + " failure on ACCOUNT_PATCH_REVIEWS"), err); } }






io.searchbox.client.http.JestHttpClient build() { io.searchbox.client.JestClientFactory factory = new io.searchbox.client.JestClientFactory(); factory.setHttpClientConfig(new io.searchbox.client.config.HttpClientConfig.Builder(url).multiThreaded(true).discoveryEnabled(false).discoveryFrequency(1L, java.util.concurrent.TimeUnit.MINUTES).build()); return ((io.searchbox.client.http.JestHttpClient) (factory.getObject())); }


@org.junit.Test public void setPrivateByOwner() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> userRepo = cloneProject(project, user); com.google.gerrit.acceptance.PushOneCommit.Result result = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master"); setApiUser(user); java.lang.String changeId = result.getChangeId(); assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse(); gApi.changes().id(changeId).setPrivate(true); assertThat(gApi.changes().id(changeId).get().isPrivate).isTrue(); gApi.changes().id(changeId).setPrivate(false); assertThat(gApi.changes().id(changeId).get().isPrivate).isFalse(); }











private void scheduleTask(com.googlesource.gerrit.plugins.replication.PushOne pushOp, int delay, java.util.concurrent.TimeUnit unit) { postEvent(pushOp); pool.schedule(pushOp, delay, unit); }
void schedule(final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String ref, final org.eclipse.jgit.transport.URIish uri, com.googlesource.gerrit.plugins.replication.ReplicationState state) { com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduling replication {}:{} => {}", project, ref, uri); if (!(isVisible(project, state))) { return; } if (!(config.replicatePermissions())) { com.googlesource.gerrit.plugins.replication.PushOne e; synchronized(stateLock) { e = pending.get(uri); } if (e == null) { try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(project)) { try { org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); if (((head != null) && (head.isSymbolic())) && (RefNames.REFS_CONFIG.equals(head.getLeaf().getName()))) { return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("cannot check type of project %s", project), err, state); return; } } catch (java.io.IOException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, state); return; } } } synchronized(stateLock) { com.googlesource.gerrit.plugins.replication.PushOne e = pending.get(uri); if (e == null) { e = opFactory.create(project, uri); e.addRef(ref); scheduleTask(e, config.getDelay(), java.util.concurrent.TimeUnit.SECONDS); pending.put(uri, e); } else if (!(e.getRefs().contains(ref))) { e.addRef(ref); postEvent(e, ref); } state.increasePushTaskCount(project.get(), ref); e.addState(ref, state); com.googlesource.gerrit.plugins.replication.Destination.repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay()); } }
private void postEvent(com.googlesource.gerrit.plugins.replication.PushOne pushOp, java.lang.String inputRef) { java.util.Set<java.lang.String> refs = (inputRef == null) ? pushOp.getRefs() : com.google.common.collect.ImmutableSet.of(inputRef); com.google.gerrit.reviewdb.client.Project.NameKey project = pushOp.getProjectNameKey(); java.lang.String targetNode = com.googlesource.gerrit.plugins.replication.PushResultProcessing.resolveNodeName(pushOp.getURI()); for (java.lang.String ref : refs) { com.googlesource.gerrit.plugins.replication.ReplicationScheduledEvent event = new com.googlesource.gerrit.plugins.replication.ReplicationScheduledEvent(project.get(), ref, targetNode); eventDispatcher.postEvent(new com.google.gerrit.reviewdb.client.Branch.NameKey(project, ref), event); } }
void reschedule(com.googlesource.gerrit.plugins.replication.PushOne pushOp, com.googlesource.gerrit.plugins.replication.Destination.RetryReason reason) { synchronized(stateLock) { org.eclipse.jgit.transport.URIish uri = pushOp.getURI(); com.googlesource.gerrit.plugins.replication.PushOne pendingPushOp = pending.get(uri); if (pendingPushOp != null) { if (pendingPushOp.isRetrying()) { pendingPushOp.addRefs(pushOp.getRefs()); pendingPushOp.addStates(pushOp.getStates()); pushOp.removeStates(); } else { pendingPushOp.cancel(); pending.remove(uri); pushOp.addRefs(pendingPushOp.getRefs()); pushOp.addStates(pendingPushOp.getStates()); pendingPushOp.removeStates(); } } if ((pendingPushOp == null) || (!(pendingPushOp.isRetrying()))) { pending.put(uri, pushOp); switch (reason) { case COLLISION : scheduleTask(pushOp, config.getDelay(), java.util.concurrent.TimeUnit.SECONDS); break; case TRANSPORT_ERROR : case REPOSITORY_MISSING : default : pushOp.setToRetry(); scheduleTask(pushOp, config.getRetryDelay(), java.util.concurrent.TimeUnit.MINUTES); break; } } } }
@org.junit.Before public void setUp() throws java.lang.Exception { java.lang.String url = "http://localhost:" + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.port()); com.ericsson.gerrit.plugins.highavailability.Configuration cfg = mock(com.ericsson.gerrit.plugins.highavailability.Configuration.class); when(cfg.getUser()).thenReturn("user"); when(cfg.getPassword()).thenReturn("pass"); when(cfg.getMaxTries()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.MAX_TRIES); when(cfg.getConnectionTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.TIMEOUT); when(cfg.getSocketTimeout()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.TIMEOUT); when(cfg.getRetryInterval()).thenReturn(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.RETRY_INTERVAL); com.ericsson.gerrit.plugins.highavailability.peers.PeerInfo peerInfo = mock(com.ericsson.gerrit.plugins.highavailability.peers.PeerInfo.class); when(peerInfo.getDirectUrl()).thenReturn(url); httpSession = new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSession(new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpClientProvider(cfg).get(), com.google.inject.util.Providers.of(peerInfo)); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.resetRequests(); }
com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult post(java.lang.String endpoint, java.lang.String content) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(((peerInfo.get().getDirectUrl()) + endpoint)); if (!(com.google.common.base.Strings.isNullOrEmpty(content))) { post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); post.setEntity(new org.apache.http.entity.StringEntity(content, java.nio.charset.StandardCharsets.UTF_8)); } return httpClient.execute(post, new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler()); }
com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult delete(java.lang.String endpoint) throws java.io.IOException { return httpClient.execute(new org.apache.http.client.methods.HttpDelete(((peerInfo.get().getDirectUrl()) + endpoint)), new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler()); }





public boolean canMonitor() { if (userProvider.get().isIdentifiedUser()) { com.google.gerrit.server.account.CapabilityControl ctl = userProvider.get().getCapabilities(); return (ctl.canAdministrateServer()) || (ctl.canPerform(capabilityName)); } return false; }
@java.lang.Override public void onHeadUpdated(com.google.gerrit.extensions.events.HeadUpdatedListener.Event event) { java.lang.String projectName = event.getProjectName(); for (java.util.Map.Entry<java.lang.String, java.util.Set<org.eclipse.jgit.transport.URIish>> entry : getURIs(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), FilterType.ALL).entrySet()) { com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey()); for (org.eclipse.jgit.transport.URIish uri : entry.getValue()) { updateHead(credsProvider, uri, event.getNewHeadName()); } } }
@java.lang.Override public void onNewProjectCreated(com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event) { java.lang.String projectName = event.getProjectName(); for (java.util.Map.Entry<java.lang.String, java.util.Set<org.eclipse.jgit.transport.URIish>> entry : getURIs(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), FilterType.PROJECT_CREATION).entrySet()) { com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey()); for (org.eclipse.jgit.transport.URIish uri : entry.getValue()) { createProject(credsProvider, uri, event.getHeadName()); } } }
private boolean createProject(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish replicateURI, java.lang.String head) { if (!(replicateURI.isRemote())) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.createLocally(replicateURI, head); com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.info(("Created local repository: " + replicateURI)); } else if (com.googlesource.gerrit.plugins.replication.ReplicationQueue.isSSH(replicateURI)) { createRemoteSsh(credsProvider, replicateURI, head); com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.info(("Created remote repository: " + replicateURI)); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(java.lang.String.format(("Cannot create new project on remote site %s." + (" Only local paths and SSH URLs are supported" + " for remote repository creation")), replicateURI)); return false; } return true; }
private void updateHead(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish replicateURI, java.lang.String newHead) { if (!(replicateURI.isRemote())) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.updateHeadLocally(replicateURI, newHead); } else if (com.googlesource.gerrit.plugins.replication.ReplicationQueue.isSSH(replicateURI)) { updateHeadRemoteSsh(credsProvider, replicateURI, newHead); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(java.lang.String.format(("Cannot update HEAD of project on remote site %s." + (" Only local paths and SSH URLs are supported" + " for remote HEAD update.")), replicateURI)); } }
@java.lang.Override public void onProjectDeleted(com.google.gerrit.extensions.events.ProjectDeletedListener.Event event) { java.lang.String projectName = event.getProjectName(); for (java.util.Map.Entry<java.lang.String, java.util.Set<org.eclipse.jgit.transport.URIish>> entry : getURIs(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), FilterType.PROJECT_DELETION).entrySet()) { com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey()); for (org.eclipse.jgit.transport.URIish uri : entry.getValue()) { deleteProject(credsProvider, uri); } } }
private void updateHeadRemoteSsh(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish uri, java.lang.String newHead) { java.lang.String quotedPath = QuotedString.BOURNE.quote(uri.getPath()); java.lang.String cmd = (("cd " + quotedPath) + " && git symbolic-ref HEAD ") + (QuotedString.BOURNE.quote(newHead)); java.io.OutputStream errStream = com.googlesource.gerrit.plugins.replication.ReplicationQueue.newErrorBufferStream(); try { executeRemoteSsh(credsProvider, uri, cmd, errStream); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error(java.lang.String.format(("Error updating HEAD of remote repository at %s to %s:\n" + ((" Exception: %s\n" + " Command: %s\n") + " Output: %s")), uri, newHead, e, cmd, errStream), e); } }
private void deleteProject(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish replicateURI) { if (!(replicateURI.isRemote())) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.deleteLocally(replicateURI); com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.info(("Deleted local repository: " + replicateURI)); } else if (com.googlesource.gerrit.plugins.replication.ReplicationQueue.isSSH(replicateURI)) { deleteRemoteSsh(credsProvider, replicateURI); com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.info(("Deleted remote repository: " + replicateURI)); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(java.lang.String.format(("Cannot delete project on remote site %s." + (" Only local paths and SSH URLs are supported" + " for remote repository deletion")), replicateURI)); } }
private void createRemoteSsh(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish uri, java.lang.String head) { java.lang.String quotedPath = QuotedString.BOURNE.quote(uri.getPath()); java.lang.String cmd = ((("mkdir -p " + quotedPath) + " && cd ") + quotedPath) + " && git init --bare"; if (head != null) { cmd = (cmd + " && git symbolic-ref HEAD ") + (QuotedString.BOURNE.quote(head)); } java.io.OutputStream errStream = com.googlesource.gerrit.plugins.replication.ReplicationQueue.newErrorBufferStream(); try { executeRemoteSsh(credsProvider, uri, cmd, errStream); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error(java.lang.String.format(("Error creating remote repository at %s:\n" + ((" Exception: %s\n" + " Command: %s\n") + " Output: %s")), uri, e, cmd, errStream), e); } }



private void executeRemoteSsh(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish uri, java.lang.String cmd, java.io.OutputStream errStream) throws java.io.IOException { org.eclipse.jgit.transport.RemoteSession ssh = connect(credsProvider, uri); java.lang.Process proc = ssh.exec(cmd, 0); proc.getOutputStream().close(); org.eclipse.jgit.util.io.StreamCopyThread out = new org.eclipse.jgit.util.io.StreamCopyThread(proc.getInputStream(), errStream); org.eclipse.jgit.util.io.StreamCopyThread err = new org.eclipse.jgit.util.io.StreamCopyThread(proc.getErrorStream(), errStream); out.start(); err.start(); try { proc.waitFor(); out.halt(); err.halt(); } catch (java.lang.InterruptedException interrupted) { } ssh.disconnect(); }
private void deleteRemoteSsh(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish uri) { java.lang.String quotedPath = QuotedString.BOURNE.quote(uri.getPath()); java.lang.String cmd = "rm -rf " + quotedPath; java.io.OutputStream errStream = com.googlesource.gerrit.plugins.replication.ReplicationQueue.newErrorBufferStream(); try { executeRemoteSsh(credsProvider, uri, cmd, errStream); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error(java.lang.String.format(("Error deleting remote repository at %s:\n" + ((" Exception: %s\n" + " Command: %s\n") + " Output: %s")), uri, e, cmd, errStream), e); } }




public boolean createProject(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String head) { boolean success = false; for (java.util.Map.Entry<java.lang.String, java.util.Set<org.eclipse.jgit.transport.URIish>> entry : getURIs(project, FilterType.PROJECT_CREATION).entrySet()) { com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider credsProvider = credentialsFactory.create(entry.getKey()); for (org.eclipse.jgit.transport.URIish uri : entry.getValue()) { success &= createProject(credsProvider, uri, head); } } return success; }

private org.eclipse.jgit.transport.RemoteSession connect(org.eclipse.jgit.transport.CredentialsProvider credsProvider, org.eclipse.jgit.transport.URIish uri) throws org.eclipse.jgit.errors.TransportException { return sshSessionFactory.create().getSession(uri, credsProvider, FS.DETECTED, 0); }
@java.lang.Override public boolean isEmpty() { return (((((((((((((((((((((commitSubject) == null) && (approvals.isEmpty())) && ((changeMessage) == null)) && (comments.isEmpty())) && (reviewers.isEmpty())) && ((changeId) == null)) && ((branch) == null)) && ((status) == null)) && ((submissionId) == null)) && ((submitRecords) == null)) && ((assignee) == null)) && ((hashtags) == null)) && ((topic) == null)) && ((commit) == null)) && ((psState) == null)) && ((groups) == null)) && ((tag) == null)) && ((psDescription) == null)) && (!(currentPatchSet))) && ((readOnlyUntil) == null)) && ((isPrivate) == null); }


@java.lang.Override public com.google.gerrit.reviewdb.client.Change createChange(com.google.gerrit.server.git.BatchUpdate.Context ctx) { change = new com.google.gerrit.reviewdb.client.Change(com.google.gerrit.server.change.ChangeInserter.getChangeKey(commit), changeId, ctx.getAccountId(), new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getWhen()); change.setStatus(com.google.common.base.MoreObjects.firstNonNull(status, Change.Status.NEW)); change.setTopic(topic); change.setPrivate(isPrivate); return change; }










private void copyNonConstructorColumnsTo(com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.notedb.ChangeNotesState.ChangeColumns c = checkNotNull(columns(), "columns are required"); if ((c.status()) != null) { change.setStatus(c.status()); } change.setTopic(com.google.common.base.Strings.emptyToNull(c.topic())); change.setLastUpdatedOn(c.lastUpdatedOn()); change.setSubmissionId(c.submissionId()); change.setAssignee(c.assignee()); change.setPrivate(((c.isPrivate()) == null ? false : c.isPrivate())); if (!(patchSets().isEmpty())) { change.setCurrentPatchSet(c.currentPatchSetId(), c.subject(), c.originalSubject()); } else { change.clearCurrentPatchSet(); } }
static com.google.gerrit.server.notedb.ChangeNotesState empty(com.google.gerrit.reviewdb.client.Change change) { return new com.google.gerrit.server.notedb.AutoValue_ChangeNotesState(null, change.getId(), null, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.gerrit.server.ReviewerSet.empty(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableListMultimap.of(), com.google.common.collect.ImmutableListMultimap.of(), null, null); }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); try { com.google.gerrit.server.mail.send.ProjectWatch.Watchers matching = getWatchers(NotifyType.NEW_CHANGES, (!(change.isPrivate()))); for (com.google.gerrit.reviewdb.client.Account.Id user : com.google.common.collect.Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) { if (isOwnerOfProjectOrBranch(user)) { add(RecipientType.TO, user); } } add(RecipientType.TO, matching.to); add(RecipientType.CC, matching.cc); add(RecipientType.BCC, matching.bcc); } catch (com.google.gwtorm.server.OrmException err) { com.google.gerrit.server.mail.send.CreateChangeSender.log.warn("Cannot notify watchers for new change", err); } includeWatchers(NotifyType.NEW_PATCHSETS, (!(change.isPrivate()))); }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); if ((fromId) != null) { reviewers.remove(fromId); } add(RecipientType.TO, reviewers); add(RecipientType.CC, extraCC); rcptToAuthors(RecipientType.CC); bccStarredBy(); removeUsersThatIgnoredTheChange(); includeWatchers(NotifyType.NEW_PATCHSETS, (!(change.isPrivate()))); }

private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(tip.copy(), id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, ((assignee) != null ? assignee.orElse(null) : null), status, com.google.common.collect.Sets.newLinkedHashSet(com.google.common.collect.Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate); }




void addOps(com.google.gerrit.server.update.BatchUpdate bu, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.MultiProgressMonitor.Task progress) throws java.io.IOException { if ((cmd.getResult()) == (NOT_ATTEMPTED)) { cmd.execute(rp); } if (((magicBranch) != null) && (magicBranch.edit)) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.update.BatchUpdateOp() { @java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws java.lang.Exception { return true; } }); return; } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit newCommit = rw.parseCommit(newCommitId); rw.parseBody(newCommit); org.eclipse.jgit.revwalk.RevCommit priorCommit = revisions.inverse().get(priorPatchSet); replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator).setUpdateRef(false); bu.addOp(notes.getChangeId(), replaceOp); if (progress != null) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.ChangeProgressOp(progress)); } }
@java.lang.Override public void rebase(com.google.gerrit.extensions.api.changes.RebaseInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { rebase.apply(change, in); } catch (com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot rebase change", e); } }
@java.lang.Override public void setPrivate(boolean value) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (value) { putPrivate.apply(change, null); } else { deletePrivate.apply(change, null); } } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot change private status", e); } }
@java.lang.Override public void publish() throws com.google.gerrit.extensions.restapi.RestApiException { try { publishDraftChange.apply(change, null); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot publish change", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.AddReviewerResult addReviewer(com.google.gerrit.extensions.api.changes.AddReviewerInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return postReviewers.apply(change, in); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add change reviewer", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo createMergePatchSet(com.google.gerrit.extensions.common.MergePatchSetInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return updateByMerge.apply(change, in).value(); } catch (java.io.IOException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot update change by merge", e); } }
@java.lang.Override public void review(com.google.gerrit.extensions.api.changes.ReviewInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { review.apply(revision, in); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot post review", e); } }
@java.lang.Override public void description(java.lang.String description) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutDescription.Input in = new com.google.gerrit.server.change.PutDescription.Input(); in.description = description; try { putDescription.apply(revision, in); } catch (com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set description", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi rebase(com.google.gerrit.extensions.api.changes.RebaseInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changes.id(rebase.apply(revision, in)._number); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.common.errors.EmailException | com.google.gerrit.server.update.UpdateException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot rebase ps", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi cherryPick(com.google.gerrit.extensions.api.changes.CherryPickInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changes.id(cherryPick.apply(revision, in)._number); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot cherry pick", e); } }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteDraft.apply(revision, null); } catch (com.google.gerrit.server.update.UpdateException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete draft ps", e); } }
@java.lang.Override public void publish() throws com.google.gerrit.extensions.restapi.RestApiException { try { publish.apply(revision, new com.google.gerrit.server.change.PublishDraftPatchSet.Input()); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot publish draft patch set", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.DraftApi createDraft(com.google.gerrit.extensions.api.changes.DraftInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { java.lang.String id = createDraft.apply(revision, in).value().id; return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id); } catch (com.google.gerrit.server.update.UpdateException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create draft", e); } }
@java.lang.Override public void move(com.google.gerrit.extensions.api.changes.MoveInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { move.apply(change, in); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot move change", e); } }
@java.lang.Override public void topic(java.lang.String topic) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input(); in.topic = topic; try { putTopic.apply(change, in); } catch (com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set topic", e); } }
@java.lang.Override public void deleteVote(com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteVote.apply(new com.google.gerrit.server.change.VoteResource(reviewer, input.label), input); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete vote", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi revert(com.google.gerrit.extensions.api.changes.RevertInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changeApi.id(revert.apply(change, in)._number); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot revert change", e); } }
@java.lang.Override public void deleteVote(java.lang.String label) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteVote.apply(new com.google.gerrit.server.change.VoteResource(reviewer, label), null); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete vote", e); } }
@java.lang.Override public void remove(com.google.gerrit.extensions.api.changes.DeleteReviewerInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteReviewer.apply(reviewer, input); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot remove reviewer", e); } }
@java.lang.Override public void deleteVote(java.lang.String label) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteVote.apply(new com.google.gerrit.server.change.VoteResource(reviewer, label), null); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete vote", e); } }
@java.lang.Override public void deleteVote(com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteVote.apply(new com.google.gerrit.server.change.VoteResource(reviewer, input.label), input); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete vote", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi create(com.google.gerrit.extensions.common.ChangeInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.common.ChangeInfo out = createChange.apply(TopLevelResource.INSTANCE, in).value(); return api.create(changes.parse(new com.google.gerrit.reviewdb.client.Change.Id(out._number))); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create change", e); } }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteChange.apply(change, null); } catch (com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete change", e); } }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteDraft.apply(draft, null); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete draft", e); } }
@java.lang.Override public void setReadyForReview(java.lang.String message) throws com.google.gerrit.extensions.restapi.RestApiException { try { setReady.apply(change, new com.google.gerrit.server.change.WorkInProgressOp.Input(message)); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set ready for review state", e); } }
@java.lang.Override public void index() throws com.google.gerrit.extensions.restapi.RestApiException { try { index.apply(change, new com.google.gerrit.server.change.Index.Input()); } catch (java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot index change", e); } }
@java.lang.Override public void setHashtags(com.google.gerrit.extensions.api.changes.HashtagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { postHashtags.apply(change, input); } catch (com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot post hashtags", e); } }
@java.lang.Override public void setWorkInProgress(java.lang.String message) throws com.google.gerrit.extensions.restapi.RestApiException { try { setWip.apply(change, new com.google.gerrit.server.change.WorkInProgressOp.Input(message)); } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set work in progress state", e); } }
@java.lang.Override public java.util.Set<java.lang.String> getHashtags() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getHashtags.apply(change).value(); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot get hashtags", e); } }
@java.lang.Override public void abandon(com.google.gerrit.extensions.api.changes.AbandonInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { abandon.apply(change, in); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot abandon change", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo setAssignee(com.google.gerrit.extensions.api.changes.AssigneeInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { return putAssignee.apply(change, input); } catch (com.google.gerrit.server.update.UpdateException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot set assignee", e); } }
@java.lang.Override public void restore(com.google.gerrit.extensions.api.changes.RestoreInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { restore.apply(change, in); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot restore change", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo deleteAssignee() throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> r = deleteAssignee.apply(change, null); return r.isNone() ? null : r.value(); } catch (com.google.gerrit.server.update.UpdateException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete assignee", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo update(com.google.gerrit.extensions.api.changes.DraftInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return putDraft.apply(draft, in).value(); } catch (com.google.gerrit.server.update.UpdateException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot update draft", e); } }
public com.google.gerrit.extensions.restapi.BinaryResult getContent(com.google.gerrit.server.project.ProjectState project, org.eclipse.jgit.lib.ObjectId revstr, java.lang.String path) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = openRepository(project)) { return getContent(repo, project, revstr, path); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.restapi.BinaryResult> apply(com.google.gerrit.server.change.ChangeEditResource rsrc) throws java.io.IOException { try { com.google.gerrit.server.edit.ChangeEdit edit = rsrc.getChangeEdit(); return com.google.gerrit.extensions.restapi.Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), (base ? org.eclipse.jgit.lib.ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : edit.getEditCommit()), rsrc.getPath())); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException rnfe) { return com.google.gerrit.extensions.restapi.Response.none(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64(); } else if (Patch.MERGE_LIST.equals(path)) { byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64(); } return fileContentUtil.getContent(rsrc.getRevision().getControl().getProjectControl().getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.project.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return fileContentUtil.getContent(rsrc.getProject().getProjectState(), rsrc.getRev(), rsrc.getPath()); }



private java.util.List<com.jcraft.jsch.HostKey> computeHostKeys() { if (listen.isEmpty()) { return java.util.Collections.emptyList(); } final java.util.List<java.security.PublicKey> keys = myHostKeys(); final java.util.List<com.jcraft.jsch.HostKey> r = new java.util.ArrayList<>(); for (final java.security.PublicKey pub : keys) { final org.apache.sshd.common.util.buffer.Buffer buf = new org.apache.sshd.common.util.buffer.ByteArrayBuffer(); buf.putRawPublicKey(pub); final byte[] keyBin = buf.getCompactData(); for (final java.lang.String addr : advertised) { try { r.add(new com.jcraft.jsch.HostKey(addr, keyBin)); } catch (com.jcraft.jsch.JSchException e) { com.google.gerrit.sshd.SshDaemon.sshDaemonLog.warn("Cannot format SSHD host key", e); } } } return java.util.Collections.unmodifiableList(r); }


@java.lang.Override public com.googlesource.gerrit.plugins.manager.repository.PluginInfo apply(java.util.jar.JarEntry entry) { try { java.nio.file.Path entryName = java.nio.file.Paths.get(entry.getName()); java.net.URI pluginUrl = new java.net.URI(((("jar:file:" + (gerritWarFilename)) + "!/") + (entry.getName()))); try (java.util.jar.JarInputStream pluginJar = new java.util.jar.JarInputStream(pluginUrl.toURL().openStream())) { java.util.jar.Manifest manifestJarEntry = getManifestEntry(pluginJar); if (manifestJarEntry != null) { java.util.jar.Attributes pluginAttributes = manifestJarEntry.getMainAttributes(); return new com.googlesource.gerrit.plugins.manager.repository.PluginInfo(pluginAttributes.getValue("Gerrit-PluginName"), pluginAttributes.getValue("Implementation-Version"), "", pluginUrl.toString()); } return new com.googlesource.gerrit.plugins.manager.repository.PluginInfo(entryName.getFileName().toString(), "", "", pluginUrl.toString()); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.manager.repository.CorePluginsRepository.log.error(("Unable to open plugin " + pluginUrl), e); return null; } } catch (java.net.URISyntaxException e) { com.googlesource.gerrit.plugins.manager.repository.CorePluginsRepository.log.error("Invalid plugin filename", e); return null; } }



@org.junit.Test public void ownersFile2Test() throws java.lang.Exception { addFile("add OWNERS", "OWNERS", "per-file *.c=x@x\na@a\nc@c\nb@b\n"); com.google.gerrit.acceptance.PushOneCommit.Result c2 = createChange("add t.c", "t.c", "Hello!"); assertThat(getOwnersResponse(c2)).contains("owners:[ x@x[1+0+0] ], files:[ t.c ]"); com.google.gerrit.acceptance.PushOneCommit.Result c3 = createChange("add t.txt", "t.txt", "Test!"); assertThat(getOwnersResponse(c3)).contains("owners:[ a@a[1+0+0], b@b[1+0+0], c@c[1+0+0] ], files:[ t.txt ]"); }
@org.junit.Test public void ownersFile1Test() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result c1 = createChange("add OWNERS", "OWNERS", "x@x\na@a\n"); assertThat(getOwnersResponse(c1)).contains("owners:[], files:[ OWNERS ]"); com.google.gerrit.acceptance.PushOneCommit.Result c2 = createChange("add t.c", "t.c", "##"); assertThat(getOwnersResponse(c2)).contains("owners:[], files:[ t.c ]"); approveSubmit(c1); assertThat(getOwnersResponse(c2)).contains("owners:[ a@a[1+0+0], x@x[1+0+0] ], files:[ t.c ]"); assertThat(getOwnersResponse(c1)).contains("owners:[ a@a[1+0+0], x@x[1+0+0] ], files:[ OWNERS ]"); java.lang.String expectedTail = "path2owners:{ ./:a@ax@x }, owner2paths:{ a@a:./, x@x:./ } }" + (", file2owners:{ ./t.c:a@ax@x }, reviewers:[], owners:[ " + "a@a[1+0+0], x@x[1+0+0] ], files:[ t.c ] }"); assertThat(getOwnersDebugResponse(c2)).contains(expectedTail); }
private java.util.List<java.lang.String> getOwners(com.googlesource.gerrit.plugins.findowners.OwnersDb db, java.util.Collection<java.lang.String> files) { java.util.Map<java.lang.String, com.googlesource.gerrit.plugins.findowners.OwnerWeights> weights = new java.util.HashMap<>(); db.findOwners(files, weights); java.util.List<java.lang.String> result = new java.util.ArrayList<>(); java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (java.lang.String key : com.googlesource.gerrit.plugins.findowners.OwnerWeights.sortKeys(weights)) { if (!(emails.contains(key))) { result.add(((key + " ") + (weights.get(key).encodeLevelCounts()))); emails.add(key); } } return result; }
@java.lang.Override public void setPrivate(boolean value) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (value) { putPrivate.apply(change, null); } else { deletePrivate.apply(change, null); } } catch (com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot change private status", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.PutPrivate.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to mark private"); } if (rsrc.getChange().isPrivate()) { return com.google.gerrit.extensions.restapi.Response.ok(""); } com.google.gerrit.server.project.ChangeControl control = rsrc.getControl(); com.google.gerrit.server.change.SetPrivateOp op = new com.google.gerrit.server.change.SetPrivateOp(cmUtil, true); try (com.google.gerrit.server.update.BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(control.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.DeletePrivate.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to unmark private"); } if (!(rsrc.getChange().isPrivate())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not private"); } com.google.gerrit.server.project.ChangeControl control = rsrc.getControl(); com.google.gerrit.server.change.SetPrivateOp op = new com.google.gerrit.server.change.SetPrivateOp(cmUtil, false); try (com.google.gerrit.server.update.BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(control.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }

@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject in) { com.google.gerrit.client.api.DefaultActions.UiResult result = asUiResult(in); if ((result.alert()) != null) { com.google.gwt.user.client.Window.alert(result.alert()); } if (((result.redirectUrl()) != null) && (result.openWindow())) { com.google.gwt.user.client.Window.open(result.redirectUrl(), "_blank", null); } else if ((result.redirectUrl()) != null) { com.google.gwt.user.client.Window.Location.assign(result.redirectUrl()); } else { com.google.gerrit.client.Gerrit.display(target); } }
private static com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> callback(final java.lang.String target) { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject in) { com.google.gerrit.client.api.DefaultActions.UiResult result = asUiResult(in); if ((result.alert()) != null) { com.google.gwt.user.client.Window.alert(result.alert()); } if (((result.redirectUrl()) != null) && (result.openWindow())) { com.google.gwt.user.client.Window.open(result.redirectUrl(), "_blank", null); } else if ((result.redirectUrl()) != null) { com.google.gwt.user.client.Window.Location.assign(result.redirectUrl()); } else { com.google.gerrit.client.Gerrit.display(target); } } private com.google.gerrit.client.api.DefaultActions.UiResult asUiResult(com.google.gwt.core.client.JavaScriptObject in) { if (com.google.gerrit.client.rpc.NativeString.is(in)) { java.lang.String str = ((com.google.gerrit.client.rpc.NativeString) (in)).asString(); return str.isEmpty() ? com.google.gerrit.client.api.DefaultActions.UiResult.none() : com.google.gerrit.client.api.DefaultActions.UiResult.alert(str); } return in.cast(); } }; }





private void addCommands() throws com.google.gwtorm.server.OrmException, java.io.IOException { if (isEmpty()) { return; } checkState(((changeRepo) != null), "must set change repo"); if (!(draftUpdates.isEmpty())) { checkState(((allUsersRepo) != null), "must set all users repo"); } com.google.gerrit.server.notedb.NoteDbUpdateManager.addUpdates(changeUpdates, changeRepo); if (!(draftUpdates.isEmpty())) { com.google.gerrit.server.notedb.NoteDbUpdateManager.addUpdates(draftUpdates, allUsersRepo); } if (!(robotCommentUpdates.isEmpty())) { com.google.gerrit.server.notedb.NoteDbUpdateManager.addUpdates(robotCommentUpdates, changeRepo); } for (com.google.gerrit.reviewdb.client.Change.Id id : toDelete) { doDelete(id); } checkExpectedState(); }
public void add(com.google.gerrit.server.notedb.ChangeUpdate update) { checkArgument(update.getProjectName().equals(projectName), "update for project %s cannot be added to manager for project %s", update.getProjectName(), projectName); checkState(((staged) == null), "cannot add new update after staging"); changeUpdates.put(update.getRefName(), update); com.google.gerrit.server.notedb.ChangeDraftUpdate du = update.getDraftUpdate(); if (du != null) { draftUpdates.put(du.getRefName(), du); } com.google.gerrit.server.notedb.RobotCommentUpdate rcu = update.getRobotCommentUpdate(); if (rcu != null) { robotCommentUpdates.put(rcu.getRefName(), rcu); } }





private boolean isEmpty() { if (!(migration.commitChangeWrites())) { return true; } return (((((changeUpdates.isEmpty()) && (draftUpdates.isEmpty())) && (robotCommentUpdates.isEmpty())) && (toDelete.isEmpty())) && (!(com.google.gerrit.server.notedb.NoteDbUpdateManager.hasCommands(changeRepo)))) && (!(com.google.gerrit.server.notedb.NoteDbUpdateManager.hasCommands(allUsersRepo))); }




@java.lang.Override public void modifyCommitMessage(java.lang.String newCommitMessage) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input = new com.google.gerrit.server.change.ChangeEdits.EditMessage.Input(); input.message = newCommitMessage; try { modifyChangeEditCommitMessage.apply(changeResource, input); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot modify commit message of change edit", e); } }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteBranch.apply(resource(), new com.google.gerrit.server.project.DeleteBranch.Input()); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete branch", e); } }
@java.lang.Override public void deleteBranches(com.google.gerrit.extensions.api.projects.DeleteBranchesInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteBranches.apply(checkExists(), in); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete branches", e); } }
@java.lang.Override public void deleteTags(com.google.gerrit.extensions.api.projects.DeleteTagsInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteTags.apply(checkExists(), in); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete tags", e); } }
@java.lang.Override public void modifyFile(java.lang.String filePath, com.google.gerrit.extensions.restapi.RawInput newContent) throws com.google.gerrit.extensions.restapi.RestApiException { try { changeEditsPut.apply(changeResource.getControl(), filePath, newContent); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot modify file of change edit", e); } }
private void parseDelete(org.eclipse.jgit.transport.ReceiveCommand cmd) { logDebug("Deleting {}", cmd); com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); if (ctl.getRefName().startsWith(com.google.gerrit.server.git.REFS_CHANGES)) { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.DELETE_CHANGES, ctl.getRefName()); reject(cmd, "cannot delete changes"); } else if (ctl.canDelete()) { if (!(validRefOperation(cmd))) { return; } batch.addCommand(cmd); } else { if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) { reject(cmd, "cannot delete project configuration"); } else { errors.put(com.google.gerrit.server.git.ReceiveCommits.Error.DELETE, ctl.getRefName()); reject(cmd, "cannot delete references"); } } }
@java.lang.Override public void deleteFile(java.lang.String filePath) throws com.google.gerrit.extensions.restapi.RestApiException { try { changeEditDeleteContent.apply(changeResource.getControl(), filePath); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete file of change edit", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagApi create(com.google.gerrit.extensions.api.projects.TagInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { createTagFactory.create(ref).apply(project, input); return this; } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create tag", e); } }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteTag.apply(resource(), new com.google.gerrit.server.project.DeleteTag.Input()); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException(e.getMessage()); } }
@java.lang.Override public void renameFile(java.lang.String oldFilePath, java.lang.String newFilePath) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.change.ChangeEdits.Post.Input renameInput = new com.google.gerrit.server.change.ChangeEdits.Post.Input(); renameInput.oldPath = oldFilePath; renameInput.newPath = newFilePath; changeEditsPost.apply(changeResource, renameInput); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot rename file of change edit", e); } }
@java.lang.Override public void create() throws com.google.gerrit.extensions.restapi.RestApiException { try { changeEditsPost.apply(changeResource, null); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot create change edit", e); } }
@java.lang.Override public void restoreFile(java.lang.String filePath) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.change.ChangeEdits.Post.Input restoreInput = new com.google.gerrit.server.change.ChangeEdits.Post.Input(); restoreInput.restorePath = filePath; changeEditsPost.apply(changeResource, restoreInput); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot restore file of change edit", e); } }
private void ensureAuthenticatedAndPermitted(com.google.gerrit.server.project.ChangeControl changeControl) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { ensureAuthenticated(); ensurePermitted(changeControl); }
@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo createMergePatchSet(com.google.gerrit.extensions.common.MergePatchSetInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return updateByMerge.apply(change, in).value(); } catch (java.io.IOException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot update change by merge", e); } }
@java.lang.Override public void move(com.google.gerrit.extensions.api.changes.MoveInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { move.apply(change, in); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot move change", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.EditInfo applyFix(java.lang.String fixId) throws com.google.gerrit.extensions.restapi.RestApiException { try { return applyFix.apply(fixes.parse(revision, com.google.gerrit.extensions.restapi.IdString.fromDecoded(fixId)), null).value(); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot apply fix", e); } }
@java.lang.Override public void rebase() throws com.google.gerrit.extensions.restapi.RestApiException { try { rebaseChangeEdit.apply(changeResource, null); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot rebase change edit", e); } }

@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if ((changeKind) != (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) { java.lang.Runnable sender = new java.lang.Runnable() { @java.lang.Override public void run() { try { com.google.gerrit.server.mail.send.ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId()); cm.setFrom(ctx.getAccountId()); cm.setPatchSet(newPatchSet, info); cm.setChangeMessage(msg.getMessage(), ctx.getWhen()); if ((magicBranch) != null) { cm.setNotify(magicBranch.notify); cm.setAccountsToNotify(magicBranch.getAccountsToNotify()); } cm.addReviewers(recipients.getReviewers()); cm.addExtraCC(recipients.getCcOnly()); cm.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReplaceOp.log.error(("Cannot send email for new patch set " + (newPatchSet.getId())), e); } } @java.lang.Override public java.lang.String toString() { return "send-email newpatchset"; } }; if ((requestScopePropagator) != null) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender)); } else { sender.run(); } } com.google.gerrit.extensions.api.changes.NotifyHandling notify = (((magicBranch) != null) && ((magicBranch.notify) != null)) ? magicBranch.notify : com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify); try { fireCommentAddedEvent(ctx); } catch (java.lang.Exception e) { com.google.gerrit.server.git.ReplaceOp.log.warn("comment-added event invocation failed", e); } if ((mergedByPushOp) != null) { mergedByPushOp.postUpdate(ctx); } }
protected boolean canDelete(com.google.gerrit.server.project.ProjectResource rsrc) { com.google.gerrit.server.account.CapabilityControl ctl = userProvider.get().getCapabilities(); return ((ctl.canAdministrateServer()) || (ctl.canPerform((((pluginName) + "-") + (com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT))))) || ((ctl.canPerform((((pluginName) + "-") + (com.googlesource.gerrit.plugins.deleteproject.DeleteOwnProjectCapability.DELETE_OWN_PROJECT)))) && (rsrc.getControl().isOwner())); }
private void assertHasNoChildProjects(com.google.gerrit.server.project.ProjectResource rsrc) throws com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException { java.util.List<com.google.gerrit.extensions.common.ProjectInfo> children = listChildProjectsProvider.get().apply(rsrc); if (!(children.isEmpty())) { java.lang.String childrenString = com.google.common.base.Joiner.on(", ").join(com.google.common.collect.Iterables.transform(children, new com.google.common.base.Function<com.google.gerrit.extensions.common.ProjectInfo, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.extensions.common.ProjectInfo info) { return info.name; } })); throw new com.googlesource.gerrit.plugins.deleteproject.CannotDeleteProjectException((("Cannot delete project because " + "it has children: ") + childrenString)); } }
private Project.NameKey createProject(com.google.gerrit.extensions.api.projects.ProjectInput in) throws com.google.gerrit.extensions.restapi.RestApiException { gApi.projects().create(in); return new com.google.gerrit.reviewdb.client.Project.NameKey(in.name); }
protected Project.NameKey createProject(java.lang.String nameSuffix, com.google.gerrit.reviewdb.client.Project.NameKey parent, boolean createEmptyCommit) throws com.google.gerrit.extensions.restapi.RestApiException { return createProject(nameSuffix, parent, createEmptyCommit, null); }
protected Project.NameKey createProject(java.lang.String nameSuffix, com.google.gerrit.reviewdb.client.Project.NameKey parent, boolean createEmptyCommit, com.google.gerrit.extensions.client.SubmitType submitType) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name(nameSuffix); in.parent = (parent != null) ? parent.get() : null; in.submitType = submitType; in.createEmptyCommit = createEmptyCommit; return createProject(in); }
protected Project.NameKey createProject(java.lang.String nameSuffix) throws com.google.gerrit.extensions.restapi.RestApiException { return createProject(nameSuffix, null); }
protected Project.NameKey createProject(java.lang.String nameSuffix, com.google.gerrit.reviewdb.client.Project.NameKey parent, com.google.gerrit.extensions.client.SubmitType submitType) throws com.google.gerrit.extensions.restapi.RestApiException { return createProject(nameSuffix, parent, true, submitType); }
protected Project.NameKey createProject(java.lang.String nameSuffix, com.google.gerrit.reviewdb.client.Project.NameKey parent) throws com.google.gerrit.extensions.restapi.RestApiException { return createProject(nameSuffix, parent, true, null); }
protected boolean isVisibleTo(com.google.gerrit.server.events.Event event, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if (event instanceof com.google.gerrit.server.events.RefEvent) { com.google.gerrit.server.events.RefEvent refEvent = ((com.google.gerrit.server.events.RefEvent) (event)); java.lang.String ref = refEvent.getRefName(); if (com.google.gerrit.reviewdb.client.PatchSet.isChangeRef(ref)) { com.google.gerrit.reviewdb.client.Change.Id cid = PatchSet.Id.fromRef(ref).getParentKey(); com.google.gerrit.reviewdb.client.Change change = notesFactory.create(dbProvider.get(), refEvent.getProjectNameKey(), cid).getChange(); return isVisibleTo(change, user); } return isVisibleTo(refEvent.getBranchNameKey(), user); } else if (event instanceof com.google.gerrit.server.events.ProjectEvent) { return isVisibleTo(((com.google.gerrit.server.events.ProjectEvent) (event)).getProjectNameKey(), user); } return true; }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getProjectWeblink(java.lang.String projectName) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s", baseUrl, projectName), target); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getBranchWebLink(java.lang.String projectName, java.lang.String branchName) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s/+/%s", baseUrl, projectName, branchName), target); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getPatchSetWebLink(java.lang.String projectName, java.lang.String commit) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s/+/%s", baseUrl, projectName, commit), target); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getFileWebLink(java.lang.String projectName, java.lang.String revision, java.lang.String fileName) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s/+/%s/%s", baseUrl, projectName, revision, fileName), target); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getParentWebLink(java.lang.String projectName, java.lang.String commit) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s/+/%s", baseUrl, projectName, commit), target); }
@java.lang.Override public com.google.gerrit.extensions.common.WebLinkInfo getFileHistoryWebLink(java.lang.String projectName, java.lang.String revision, java.lang.String fileName) { return new com.google.gerrit.extensions.common.WebLinkInfo(name, null, java.lang.String.format("%s/%s/+log/%s/%s", baseUrl, projectName, revision, fileName), target); }
public void createMergesAndHandleConflicts(com.googlesource.gerrit.plugins.automerger.MultipleDownstreamMergeInput mdsMergeInput) throws com.google.gerrit.extensions.restapi.RestApiException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput(); java.util.Map<java.lang.String, java.lang.Short> labels = new java.util.HashMap<java.lang.String, java.lang.Short>(); short vote = 0; try { createDownstreamMerges(mdsMergeInput); reviewInput.message = ("Automerging to " + (com.google.common.base.Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()))) + " succeeded!"; reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } catch (com.googlesource.gerrit.plugins.automerger.FailedMergeException e) { reviewInput.message = e.getDisplayString(); reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; vote = config.getMinAutomergeVote(); } labels.put(config.getAutomergeLabel(), vote); reviewInput.labels = labels; gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput); }
@com.google.common.annotations.VisibleForTesting protected java.util.Set<java.lang.String> getMissingDownstreamMerges(ChangeInfo upstreamChange) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<java.lang.String> missingDownstreamBranches = new java.util.HashSet<>(); java.util.Set<java.lang.String> downstreamBranches = config.getDownstreamBranches(upstreamChange.branch, upstreamChange.project); for (java.lang.String downstreamBranch : downstreamBranches) { boolean dsExists = false; java.lang.String query = (("topic:" + (upstreamChange.topic)) + " status:open branch:") + downstreamBranch; java.util.List<ChangeInfo> changes = gApi.changes().query(query).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get(); for (ChangeInfo change : changes) { com.google.gerrit.extensions.common.RevisionInfo revision = change.revisions.get(change.currentRevision); java.util.List<com.google.gerrit.extensions.common.CommitInfo> parents = revision.commit.parents; if ((parents.size()) > 1) { java.lang.String secondParent = parents.get(1).commit; if (secondParent.equals(upstreamChange.currentRevision)) { dsExists = true; break; } } } if (!dsExists) { missingDownstreamBranches.add(downstreamBranch); } } return missingDownstreamBranches; }


public void deleteCommentByRewritingHistory(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeUpdate update, com.google.gerrit.reviewdb.client.Comment.Key commentKey, com.google.gerrit.reviewdb.client.PatchSet.Id psId, java.lang.String newMessage) throws com.google.gwtorm.server.OrmException { if (com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage.of(update.getChange()).equals(PrimaryStorage.REVIEW_DB)) { com.google.gerrit.reviewdb.client.PatchLineComment.Key key = new com.google.gerrit.reviewdb.client.PatchLineComment.Key(new com.google.gerrit.reviewdb.client.Patch.Key(psId, commentKey.filename), commentKey.uuid); if (db instanceof com.google.gerrit.server.update.BatchUpdateReviewDb) { db = ((com.google.gerrit.server.update.BatchUpdateReviewDb) (db)).unsafeGetDelegate(); } db = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db); com.google.gerrit.reviewdb.client.PatchLineComment patchLineComment = db.patchComments().get(key); if (!(patchLineComment.getStatus().equals(com.google.gerrit.server.PUBLISHED))) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("comment %s is not published", key)); } patchLineComment.setMessage(newMessage); db.patchComments().upsert(java.util.Collections.singleton(patchLineComment)); } update.deleteCommentByRewritingHistory(commentKey.uuid, newMessage); }


public void createMergesAndHandleConflicts(com.googlesource.gerrit.plugins.automerger.MultipleDownstreamMergeInput mdsMergeInput) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.InvalidQueryParameterException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = new com.google.gerrit.extensions.api.changes.ReviewInput(); java.util.Map<java.lang.String, java.lang.Short> labels = new java.util.HashMap<java.lang.String, java.lang.Short>(); try { createDownstreamMerges(mdsMergeInput); reviewInput.message = ("Automerging to " + (com.google.common.base.Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()))) + " succeeded!"; reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } catch (com.googlesource.gerrit.plugins.automerger.FailedMergeException e) { reviewInput.message = e.getDisplayString(); reviewInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; reviewInput.tag = com.googlesource.gerrit.plugins.automerger.DownstreamCreator.MERGE_CONFLICT_TAG; labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote()); } reviewInput.labels = labels; gApi.changes().id(mdsMergeInput.sourceId).revision(mdsMergeInput.currentRevision).review(reviewInput); }
private java.lang.String setTopic(int sourceId, java.lang.String topic) throws com.google.gerrit.extensions.restapi.RestApiException { if ((topic == null) || (topic.isEmpty())) { topic = "am-" + (java.util.UUID.randomUUID().toString()); com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.debug("Setting original change {} topic to {}", sourceId, topic); gApi.changes().id(sourceId).topic(topic); } return topic; }
public void createSingleDownstreamMerge(com.googlesource.gerrit.plugins.automerger.SingleDownstreamMergeInput sdsMergeInput) throws com.google.gerrit.extensions.restapi.RestApiException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String currentTopic = setTopic(sdsMergeInput.sourceId, sdsMergeInput.topic); com.google.gerrit.extensions.common.MergeInput mergeInput = new com.google.gerrit.extensions.common.MergeInput(); mergeInput.source = sdsMergeInput.currentRevision; mergeInput.strategy = "recursive"; com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision); com.google.gerrit.extensions.common.ChangeInput downstreamChangeInput = new com.google.gerrit.extensions.common.ChangeInput(); downstreamChangeInput.project = sdsMergeInput.project; downstreamChangeInput.branch = sdsMergeInput.downstreamBranch; downstreamChangeInput.subject = ((sdsMergeInput.subject) + " am: ") + (sdsMergeInput.currentRevision.substring(0, 10)); downstreamChangeInput.topic = currentTopic; downstreamChangeInput.merge = mergeInput; downstreamChangeInput.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; if (!(sdsMergeInput.doMerge)) { mergeInput.strategy = "ours"; downstreamChangeInput.subject = ((sdsMergeInput.subject) + " skipped: ") + (sdsMergeInput.currentRevision.substring(0, 10)); com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch); } com.google.gerrit.extensions.api.changes.ChangeApi downstreamChange = gApi.changes().create(downstreamChangeInput); updateVote(downstreamChange.get(), config.getAutomergeLabel(), config.getMaxAutomergeVote()); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.AccountCacheImpl.BYID_NAME, Account.Id.class, com.google.gerrit.server.account.AccountState.class).loader(com.google.gerrit.server.account.AccountCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.AccountCacheImpl.BYUSER_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id>>() {}).loader(com.google.gerrit.server.account.AccountCacheImpl.ByNameLoader.class); bind(com.google.gerrit.server.account.AccountCacheImpl.class); bind(com.google.gerrit.server.account.AccountCache.class).to(com.google.gerrit.server.account.AccountCacheImpl.class); } }; }

@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.AccountCacheImpl.BYID_NAME, Account.Id.class, com.google.gerrit.server.account.AccountState.class).loader(com.google.gerrit.server.account.AccountCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.AccountCacheImpl.BYUSER_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id>>() {}).loader(com.google.gerrit.server.account.AccountCacheImpl.ByNameLoader.class); bind(com.google.gerrit.server.account.AccountCacheImpl.class); bind(com.google.gerrit.server.account.AccountCache.class).to(com.google.gerrit.server.account.AccountCacheImpl.class); }

@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { update(c, event.getRefName()); } catch (java.io.IOException | org.eclipse.jgit.api.errors.GitAPIException e) { com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.log.error(java.lang.String.format("update for %s (ref %s) failed", c.toString(), event.getRefName()), e); } } }

public final void addOps(com.google.gerrit.server.update.BatchUpdate bu, java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = buildOps(toMerge); java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> added = com.google.common.collect.Sets.newHashSetWithExpectedSize(ops.size()); for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { added.add(op.getCommit()); } java.util.List<com.google.gerrit.server.git.CodeReviewCommit> difference = new java.util.ArrayList(com.google.common.collect.Sets.difference(toMerge, added)); java.util.Collections.reverse(difference); for (com.google.gerrit.server.git.CodeReviewCommit c : difference) { bu.addOp(c.change().getId(), new com.google.gerrit.server.git.strategy.ImplicitIntegrateOp(args, c)); } for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { bu.addOp(op.getId(), op); } }
protected abstract java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> buildOps(java.util.Collection<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException;
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create(com.google.gerrit.extensions.client.SubmitType submitType, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.git.MergeOp.CommitStatus commitStatus, com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw, com.google.gerrit.server.IdentifiedUser caller, com.google.gerrit.server.git.MergeTip mergeTip, org.eclipse.jgit.revwalk.RevFlag canMergeFlag, com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Set<org.eclipse.jgit.revwalk.RevCommit> alreadyAccepted, java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> incoming, com.google.gerrit.server.util.RequestId submissionId, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling, com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify, com.google.gerrit.server.git.SubmoduleOp submoduleOp, boolean dryrun);
@java.lang.Override public void onRevisionCreated(com.google.gerrit.extensions.events.RevisionCreatedListener.Event event) { com.google.gerrit.extensions.common.ChangeInfo c = event.getChange(); onEvent(new com.google.gerrit.reviewdb.client.Project.NameKey(c.project), c._number, event.getWho().email); }
static java.nio.file.Path getDir(SitePaths sitePaths, java.lang.String prefix, Schema<?> schema) { return sitePaths.index_dir.resolve(java.lang.String.format("%s%04d", prefix, schema.getVersion())); }











@org.junit.Test public void testIndexTaskHashCodeAndEquals() { com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask task = indexEventHandler.new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.CHANGE_ID, false); assertThat(task.equals(task)).isTrue(); assertThat(task.hashCode()).isEqualTo(task.hashCode()); com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask identicalTask = indexEventHandler.new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.CHANGE_ID, false); assertThat(task.equals(identicalTask)).isTrue(); assertThat(task.hashCode()).isEqualTo(identicalTask.hashCode()); assertThat(task.equals(null)).isFalse(); assertThat(task.equals("test")).isFalse(); assertThat(task.hashCode()).isNotEqualTo("test".hashCode()); com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask differentChangeIdTask = indexEventHandler.new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask(123, false); assertThat(task.equals(differentChangeIdTask)).isFalse(); assertThat(task.hashCode()).isNotEqualTo(differentChangeIdTask.hashCode()); com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask removeTask = indexEventHandler.new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.IndexTask(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.CHANGE_ID, true); assertThat(task.equals(removeTask)).isFalse(); assertThat(task.hashCode()).isNotEqualTo(removeTask.hashCode()); }
private void setDefaultRenderer(javax.servlet.FilterConfig filterConfig) { if ((renderer) == null) { renderer = new com.google.gitiles.DefaultRenderer(((filterConfig.getServletContext().getContextPath()) + (com.google.gitiles.GitilesServlet.STATIC_PREFIX)), com.google.common.collect.FluentIterable.from(java.util.Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(com.google.gitiles.Renderer.fileUrlMapper()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles")); } }


@com.google.gerrit.testutil.ConfigSuite.Config public static org.eclipse.jgit.lib.Config againstPreviousIndexVersion() { org.eclipse.jgit.lib.Config cfg = defaultConfig(); java.util.SortedMap<java.lang.Integer, com.google.gerrit.server.index.Schema<com.google.gerrit.server.account.AccountState>> schemas = com.google.gerrit.server.index.SchemaUtil.schemasFromClass(com.google.gerrit.server.index.account.AccountSchemaDefinitions.class, com.google.gerrit.server.account.AccountState.class); if ((schemas.size()) > 1) { int prevVersion = com.google.common.collect.Iterables.get(schemas.keySet(), ((schemas.size()) - 2)); cfg.setInt("index", "lucene", ((AccountSchemaDefinitions.INSTANCE.getName()) + "TestVersion"), prevVersion); } return cfg; }
@com.google.gerrit.testutil.ConfigSuite.Config public static org.eclipse.jgit.lib.Config againstPreviousIndexVersion() { org.eclipse.jgit.lib.Config cfg = defaultConfig(); java.util.SortedMap<java.lang.Integer, com.google.gerrit.server.index.Schema<com.google.gerrit.server.query.change.ChangeData>> schemas = com.google.gerrit.server.index.SchemaUtil.schemasFromClass(com.google.gerrit.server.index.change.ChangeSchemaDefinitions.class, com.google.gerrit.server.query.change.ChangeData.class); if ((schemas.size()) > 1) { int prevVersion = com.google.common.collect.Iterables.get(schemas.keySet(), ((schemas.size()) - 2)); cfg.setInt("index", "lucene", ((ChangeSchemaDefinitions.INSTANCE.getName()) + "TestVersion"), prevVersion); } return cfg; }
@com.google.gerrit.testutil.ConfigSuite.Config public static org.eclipse.jgit.lib.Config againstPreviousIndexVersion() { org.eclipse.jgit.lib.Config cfg = defaultConfig(); java.util.SortedMap<java.lang.Integer, com.google.gerrit.server.index.Schema<com.google.gerrit.reviewdb.client.AccountGroup>> schemas = com.google.gerrit.server.index.SchemaUtil.schemasFromClass(com.google.gerrit.server.index.group.GroupSchemaDefinitions.class, com.google.gerrit.reviewdb.client.AccountGroup.class); if ((schemas.size()) > 1) { int prevVersion = com.google.common.collect.Iterables.get(schemas.keySet(), ((schemas.size()) - 2)); cfg.setInt("index", "lucene", ((GroupSchemaDefinitions.INSTANCE.getName()) + "TestVersion"), prevVersion); } return cfg; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().all().toList(); for (com.google.gerrit.reviewdb.client.AccountGroup accountGroup : accountGroups) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId()); java.util.Optional<java.sql.Timestamp> firstTimeMentioned = com.google.common.collect.Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(java.util.Comparator.naturalOrder()); java.sql.Timestamp createdOn = firstTimeMentioned.orElseGet(() -> java.sql.Timestamp.from(com.google.gerrit.server.schema.Schema_151.AUDIT_CREATION_INSTANT)); accountGroup.setCreatedOn(createdOn); } db.accountGroups().update(accountGroups); }
public java.sql.Timestamp getCreatedOn() { return createdOn; }



private void index(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { java.util.concurrent.atomic.AtomicInteger accountIdLock = getAndIncrementAccountIdLock(id); synchronized(accountIdLock) { indexer.index(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug("Account {} successfully indexed", id); } if ((accountIdLock.decrementAndGet()) == 0) { removeAccountIdLock(id); } }
private void index(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.concurrent.atomic.AtomicInteger changeIdLock = getAndIncrementChangeIdLock(id); synchronized(changeIdLock) { if ("index".equals(operation)) { try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully indexed", id); } if ("delete".equals(operation)) { indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully deleted from index", id); } } if ((changeIdLock.decrementAndGet()) == 0) { removeChangeIdLock(id); } }
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, java.lang.String operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); java.lang.String path = req.getPathInfo(); java.lang.String changeId = path.substring(((path.lastIndexOf('/')) + 1)); com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(changeId); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); index(id, operation); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_CONFLICT, e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.error("Unable to update change index", e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = "Error trying to find a change \n"; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, msg); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }

@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException, javax.servlet.ServletException { rsp.setContentType("text/plain"); rsp.setCharacterEncoding("UTF-8"); java.lang.String path = req.getPathInfo(); java.lang.String accountId = path.substring(((path.lastIndexOf('/')) + 1)); com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(accountId); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); index(id); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_CONFLICT, e.getMessage()); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.error("Unable to update account index", e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }


static com.google.gerrit.acceptance.GerritServer.Description forTestMethod(org.junit.runner.Description testDesc, java.lang.String configName) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description(testDesc, configName, ((testDesc.getAnnotation(com.google.gerrit.acceptance.UseLocalDisk.class)) == null), (((testDesc.getAnnotation(com.google.gerrit.acceptance.NoHttpd.class)) == null) && (!(com.google.gerrit.acceptance.GerritServer.Description.has(com.google.gerrit.acceptance.NoHttpd.class, testDesc.getTestClass())))), (((testDesc.getAnnotation(com.google.gerrit.acceptance.Sandboxed.class)) != null) || (com.google.gerrit.acceptance.GerritServer.Description.has(com.google.gerrit.acceptance.Sandboxed.class, testDesc.getTestClass()))), (((testDesc.getAnnotation(com.google.gerrit.acceptance.UseSsh.class)) != null) || (com.google.gerrit.acceptance.GerritServer.Description.has(com.google.gerrit.acceptance.UseSsh.class, testDesc.getTestClass()))), testDesc.getAnnotation(com.google.gerrit.acceptance.GerritConfig.class), testDesc.getAnnotation(com.google.gerrit.acceptance.GerritConfigs.class)); }





@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { for (com.google.gerrit.server.index.Index<?, com.google.gerrit.server.account.AccountState> i : getWriteIndexes()) { i.replace(byIdCache.get(id)); } fireAccountIndexedEvent(id.get()); }
com.googlesource.gerrit.plugins.lfs.locks.LfsGetLocksResponse listLocksById(java.lang.String project, java.lang.String id) { com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.log.debug("Get lock for {} id in {} project", id, project); com.google.common.cache.Cache<java.lang.String, com.googlesource.gerrit.plugins.lfs.locks.LfsLock> locks = projects.getUnchecked(project); com.googlesource.gerrit.plugins.lfs.locks.LfsLock lock = locks.getIfPresent(id); java.util.List<com.googlesource.gerrit.plugins.lfs.locks.LfsLock> locksById = (lock == null) ? java.util.Collections.emptyList() : com.google.common.collect.Lists.newArrayList(lock); return new com.googlesource.gerrit.plugins.lfs.locks.LfsGetLocksResponse(locksById, null); }
com.googlesource.gerrit.plugins.lfs.locks.LfsLockResponse deleteLock(java.lang.String project, CurrentUser user, java.lang.String lockId, com.googlesource.gerrit.plugins.lfs.locks.LfsDeleteLockInput input) throws org.eclipse.jgit.lfs.errors.LfsException { com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.log.debug("Delete (-f {}) lock for {} in project {}", java.lang.Boolean.TRUE.equals(input.force), lockId, project); com.google.common.cache.Cache<java.lang.String, com.googlesource.gerrit.plugins.lfs.locks.LfsLock> locks = projects.getUnchecked(project); com.googlesource.gerrit.plugins.lfs.locks.LfsLock lock = locks.getIfPresent(lockId); if (lock == null) { throw new org.eclipse.jgit.lfs.errors.LfsException(java.lang.String.format("there is no lock id %s in project %s", lockId, project)); } if (lock.owner.name.equals(user.getUserName())) { locks.invalidate(lockId); return new com.googlesource.gerrit.plugins.lfs.locks.LfsLockResponse(lock); } else if (input.force) { locks.invalidate(lockId); return new com.googlesource.gerrit.plugins.lfs.locks.LfsLockResponse(lock); } throw new org.eclipse.jgit.lfs.errors.LfsException(java.lang.String.format("Lock %s is owned by different user %s", lockId, lock.owner.name)); }
com.googlesource.gerrit.plugins.lfs.locks.LfsLockResponse createLock(java.lang.String project, com.google.gerrit.server.CurrentUser user, com.googlesource.gerrit.plugins.lfs.locks.LfsCreateLockInput input) throws com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.LfsLockExistsException { com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.log.debug("Create lock for {} in project {}", input.path, project); java.lang.String lockId = toLockId.apply(input.path); com.google.common.cache.Cache<java.lang.String, com.googlesource.gerrit.plugins.lfs.locks.LfsLock> locks = projects.getUnchecked(project); com.googlesource.gerrit.plugins.lfs.locks.LfsLock lock = locks.getIfPresent(lockId); if (lock != null) { throw new com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.LfsLockExistsException(lock); } lock = new com.googlesource.gerrit.plugins.lfs.locks.LfsLock(lockId, input.path, now(), new com.googlesource.gerrit.plugins.lfs.locks.LfsLockOwner(user.getUserName())); locks.put(lockId, lock); return new com.googlesource.gerrit.plugins.lfs.locks.LfsLockResponse(lock); }
@java.lang.Override protected void configure() { factory(LfsGetLocksAction.Factory.class); factory(LfsPutLocksAction.Factory.class); }


@java.lang.Override public com.google.common.cache.Cache<java.lang.String, com.googlesource.gerrit.plugins.lfs.locks.LfsLock> load(java.lang.String key) throws java.lang.Exception { return com.google.common.cache.CacheBuilder.newBuilder().build(); }


@java.lang.Override protected void configureServlets() { serveRegex(com.googlesource.gerrit.plugins.lfs.URL_REGEX).with(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.class); populateRepository(defaultBackend); for (com.googlesource.gerrit.plugins.lfs.LfsBackend backend : backends.values()) { populateRepository(backend); } com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.WebUiPlugin.class).toInstance(new com.google.gerrit.extensions.webui.JavaScriptPlugin("lfs-project-info.js")); }

com.googlesource.gerrit.plugins.lfs.locks.LfsGetLocksResponse listLocks(java.lang.String project) { com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.log.debug("Get locks for {} project", project); return new com.googlesource.gerrit.plugins.lfs.locks.LfsGetLocksResponse(projects.getUnchecked(project).asMap().values(), null); }


private void verifyLocks(java.lang.String project, com.googlesource.gerrit.plugins.lfs.locks.LfsLocksContext action) throws java.io.IOException { com.googlesource.gerrit.plugins.lfs.locks.LfsPutLocksAction.log.debug("Verify list of locks for {} project", project); action.sendResponse(new com.googlesource.gerrit.plugins.lfs.locks.LfsVerifyLocksResponse(java.util.Collections.emptyList(), java.util.Collections.emptyList(), null)); }
@java.lang.Override protected void doRun() throws java.io.IOException, org.eclipse.jgit.lfs.errors.LfsException { java.util.regex.Matcher matcher = com.googlesource.gerrit.plugins.lfs.locks.LfsGetLocksAction.LFS_LOCKS_URL.matcher(context.path); if (matcher.matches()) { java.lang.String project = matcher.group(1); java.lang.String lockId = matcher.group(2); if (com.google.common.base.Strings.isNullOrEmpty(lockId)) { createLock(project, context); } else { deleteLock(project, lockId, context); } return; } matcher = com.googlesource.gerrit.plugins.lfs.locks.LfsPutLocksAction.LFS_VERIFICATION_URL.matcher(context.path); if (matcher.matches()) { verifyLocks(matcher.group(1), context); return; } throw new org.eclipse.jgit.lfs.errors.LfsException(java.lang.String.format("Unsupported path %s was provided", context.path)); }





com.googlesource.gerrit.plugins.lfs.locks.LfsVerifyLocksResponse verifyLocks(java.lang.String project, final com.google.gerrit.server.CurrentUser user) { com.googlesource.gerrit.plugins.lfs.locks.LfsLocksHandler.log.debug("Verify list of locks for {} project and user {}", project, user); com.google.common.cache.Cache<java.lang.String, com.googlesource.gerrit.plugins.lfs.locks.LfsLock> locks = projects.getUnchecked(project); java.util.function.Function<com.googlesource.gerrit.plugins.lfs.locks.LfsLock, java.lang.Boolean> isOurs = new java.util.function.Function<com.googlesource.gerrit.plugins.lfs.locks.LfsLock, java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean apply(com.googlesource.gerrit.plugins.lfs.locks.LfsLock input) { return input.owner.name.equals(user.getUserName()); } }; java.util.Map<java.lang.Boolean, java.util.List<com.googlesource.gerrit.plugins.lfs.locks.LfsLock>> groupByOurs = locks.asMap().values().stream().collect(java.util.stream.Collectors.groupingBy(isOurs)); return new com.googlesource.gerrit.plugins.lfs.locks.LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null); }

@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "plugin.high-availability.url", value = com.ericsson.gerrit.plugins.highavailability.cache.CacheEvictionIT.URL) @com.google.gerrit.acceptance.GerritConfig(name = "plugin.high-availability.user", value = "admin") @com.google.gerrit.acceptance.GerritConfig(name = "plugin.high-availability.cacheThreadPoolSize", value = "10") @com.google.gerrit.acceptance.GerritConfig(name = "plugin.high-availability.sharedDirectory", value = "directory") public void flushAndSendPost() throws java.lang.Exception { final java.lang.String flushRequest = "/plugins/high-availability/cache/" + (Constants.PROJECT_LIST); final java.util.concurrent.CyclicBarrier checkPoint = new java.util.concurrent.CyclicBarrier(2); wireMockRule.addMockServiceRequestListener(new com.github.tomakehurst.wiremock.http.RequestListener() { @java.lang.Override public void requestReceived(com.github.tomakehurst.wiremock.http.Request request, com.github.tomakehurst.wiremock.http.Response response) { if (request.getAbsoluteUrl().contains(flushRequest)) { try { checkPoint.await(); } catch (java.lang.InterruptedException | java.util.concurrent.BrokenBarrierException e) { fail(); } } } }); givenThat(post(urlEqualTo(flushRequest)).willReturn(aResponse().withStatus(HttpStatus.SC_NO_CONTENT))); adminSshSession.exec(("gerrit flush-caches --cache " + (Constants.PROJECT_LIST))); checkPoint.await(5, java.util.concurrent.TimeUnit.SECONDS); verify(postRequestedFor(urlEqualTo(flushRequest))); }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); com.google.gerrit.reviewdb.client.Account userAccount = accounts.get(db, userId); userAccount.setPreferredEmail("user@example.com"); db.accounts().update(com.google.common.collect.ImmutableList.of(userAccount)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userAccount.getId())); }


public boolean hasAnyAccount() throws java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { for (org.eclipse.jgit.lib.Ref ref : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values()) { if (RefNames.REFS_USERS_DEFAULT.equals(ref.getName())) { continue; } return true; } return false; } }


private com.google.gerrit.server.IdentifiedUser reloadUser() throws java.io.IOException { accountCache.evict(userId); user = userFactory.create(userId); return user; }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); com.google.gerrit.reviewdb.client.Account userAccount = db.accounts().get(userId); userAccount.setPreferredEmail("user@example.com"); db.accounts().update(com.google.common.collect.ImmutableList.of(userAccount)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userAccount.getId())); }

private java.util.List<com.google.gerrit.reviewdb.client.Account.Id> collectAccounts(org.eclipse.jgit.lib.ProgressMonitor progress) throws com.google.gwtorm.server.OrmException { progress.beginTask("Collecting accounts", ProgressMonitor.UNKNOWN); java.util.List<com.google.gerrit.reviewdb.client.Account.Id> ids = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { for (com.google.gerrit.reviewdb.client.Account account : db.accounts().all()) { ids.add(account.getId()); } } progress.endTask(); return ids; }


@java.lang.Override public void onSuccess(final com.google.gerrit.client.rpc.NativeString httpPassword) { new com.google.gerrit.plugin.client.rpc.RestApi("config").id("server").view(com.google.gerrit.plugin.client.Plugin.get().getPluginName(), "config").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.googlesource.gerrit.plugins.serviceuser.client.ConfigInfo>() { @java.lang.Override public void onSuccess(final com.googlesource.gerrit.plugins.serviceuser.client.ConfigInfo configInfo) { com.googlesource.gerrit.plugins.serviceuser.client.AccountCapabilities.all(new com.google.gwt.user.client.rpc.AsyncCallback<com.googlesource.gerrit.plugins.serviceuser.client.AccountCapabilities>() { @java.lang.Override public void onSuccess(com.googlesource.gerrit.plugins.serviceuser.client.AccountCapabilities ac) { boolean isAdmin = ac.canPerform("administrateServer"); display(serviceUserInfo, httpPassword.asString(), ((configInfo.getAllowEmail()) || isAdmin), ((configInfo.getAllowOwner()) || isAdmin), ((configInfo.getAllowHttpPassword()) || isAdmin)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }, "administrateServer"); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }

public void assertChange(com.google.gerrit.reviewdb.client.Change.Status expectedStatus, java.lang.String expectedTopic, com.google.gerrit.acceptance.TestAccount... expectedReviewers) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = getChange().change(); assertThat(c.getSubject()).isEqualTo(resSubj); assertThat(c.getStatus()).isEqualTo(expectedStatus); assertThat(com.google.common.base.Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic); assertReviewers(c, expectedReviewers); }

@org.junit.Test public void pushForMasterWithCc() throws java.lang.Exception { java.lang.String topic = "my/topic"; com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo(((("refs/for/master/" + topic) + "%cc=") + (user.email))); r.assertOkStatus(); r.assertChange(Change.Status.NEW, topic); com.google.gerrit.acceptance.TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User"); r = pushTo(((((((("refs/for/master/" + topic) + "%cc=") + (admin.email)) + ",cc=") + (user.email)) + ",cc=") + (user2.email))); r.assertOkStatus(); r.assertChange(Change.Status.NEW, topic); java.lang.String nonExistingEmail = "non.existing@example.com"; r = pushTo(((((((("refs/for/master/" + topic) + "%cc=") + (admin.email)) + ",cc=") + nonExistingEmail) + ",cc=") + (user.email))); r.assertErrorStatus((("user \"" + nonExistingEmail) + "\" not found")); }

com.googlesource.gerrit.plugins.webhooks.PostEventTask create(java.lang.String url, com.google.gerrit.server.events.ProjectEvent projectEvent);
@java.lang.Override public void run() { java.lang.String serializedEvent = com.googlesource.gerrit.plugins.webhooks.PostEventTask.GSON.toJson(projectEvent); try { session.post(url, serializedEvent); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.webhooks.PostEventTask.log.error(("Couldn't post event: " + (projectEvent)), e); } }

@java.lang.Override public void run() { java.lang.String serializedEvent = com.googlesource.gerrit.plugins.webhooks.PostEventTask.GSON.toJson(projectEvent); try { session.post(url, serializedEvent); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.webhooks.PostEventTask.log.error(("Couldn't post event: " + (projectEvent)), e); } }
@java.lang.Override public java.lang.String toString() { return java.lang.String.format("%s:%s > %s", projectEvent.type, projectEvent.getProjectNameKey().get(), url); }
@org.junit.Test public void pushForMasterWithCc() throws java.lang.Exception { java.lang.String topic = "my/topic"; com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo(((("refs/for/master/" + topic) + "%cc=") + (user.email))); r.assertOkStatus(); r.assertChange(Change.Status.NEW, topic); com.google.gerrit.acceptance.TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User"); r = pushTo(((((((("refs/for/master/" + topic) + "%cc=") + (admin.email)) + ",cc=") + (user.email)) + ",cc=") + (user2.email))); r.assertOkStatus(); r.assertChange(Change.Status.NEW, topic); java.lang.String nonExistingEmail = "non.existing@example.com"; r = pushTo(((((((("refs/for/master/" + topic) + "%cc=") + (admin.email)) + ",cc=") + nonExistingEmail) + ",cc=") + (user.email))); r.assertErrorStatus((("user \"" + nonExistingEmail) + "\" not found")); }
@org.junit.Test public void create() throws java.lang.Exception { TestAccount foo = accounts.create("foo"); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.username).isEqualTo("foo"); if (com.google.gerrit.testutil.SshMode.useSsh()) { accountIndexedCounter.assertReindexOf(foo, 2); } else { accountIndexedCounter.assertReindexOf(foo, 1); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.getId())); assertThat(ref).isNotNull(); org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); long timestampDiffMs = java.lang.Math.abs((((c.getCommitTime()) * 1000L) - (accountCache.get(foo.getId()).getAccount().getRegisteredOn().getTime()))); assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS); } }
private com.google.gerrit.reviewdb.client.Change.Id getOrRegisterAccount(com.google.gerrit.reviewdb.server.ReviewDb db, java.lang.String login, java.lang.String name, java.lang.String email) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountExternalId.Key userExtKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME, login); com.google.gerrit.reviewdb.server.AccountExternalIdAccess gerritExtIds = db.accountExternalIds(); com.google.gerrit.reviewdb.client.AccountExternalId userExtId = gerritExtIds.get(userExtKey); if (userExtId == null) { return accountImporter.importAccount(login, name, email); } return userExtId.getAccountId(); }


@org.junit.Test public void testGetCacheThreadPoolSize() throws java.lang.Exception { initializeConfiguration(); assertThat(configuration.cache().threadPoolSize()).isEqualTo(0); when(configMock.getInt(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.THREAD_POOL_SIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_THREAD_POOL_SIZE)).thenReturn(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.THREAD_POOL_SIZE); initializeConfiguration(); assertThat(configuration.cache().threadPoolSize()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.THREAD_POOL_SIZE); when(configMock.getInt(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.THREAD_POOL_SIZE_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_THREAD_POOL_SIZE)).thenThrow(new java.lang.IllegalArgumentException(com.ericsson.gerrit.plugins.highavailability.ConfigurationTest.ERROR_MESSAGE)); initializeConfiguration(); assertThat(configuration.cache().threadPoolSize()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_THREAD_POOL_SIZE); }

private void initializeConfiguration() { configuration = new com.ericsson.gerrit.plugins.highavailability.Configuration(cfgFactoryMock, pluginName); }





static com.google.gerrit.server.patch.PatchListEntry empty(final java.lang.String fileName) { return new com.google.gerrit.server.patch.PatchListEntry(com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.patch.PatchListEntry.EMPTY_HEADER, java.util.Collections.<org.eclipse.jgit.diff.Edit>emptyList(), 0, 0, 0, 0); }
static com.google.gerrit.server.patch.PatchListEntry readFrom(java.io.InputStream in) throws java.io.IOException { com.google.gerrit.reviewdb.client.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.ChangeType.values()); com.google.gerrit.reviewdb.client.Patch.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.PatchType.values()); java.lang.String oldName = readString(in); java.lang.String newName = readString(in); byte[] hdr = readBytes(in); int ins = readVarInt32(in); int del = readVarInt32(in); long size = readFixInt64(in); long sizeDelta = readFixInt64(in); int editCount = readVarInt32(in); org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { int beginA = readVarInt32(in); int endA = readVarInt32(in); int beginB = readVarInt32(in); int endB = readVarInt32(in); editArray[i] = new org.eclipse.jgit.diff.Edit(beginA, endA, beginB, endB); } return new com.google.gerrit.server.patch.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.gerrit.server.patch.PatchListEntry.toList(editArray), ins, del, size, sizeDelta); }










private Change.Id insertPatchSet(com.google.gerrit.server.update.BatchUpdate bu, org.eclipse.jgit.lib.Repository git, com.google.gerrit.server.project.ChangeControl destCtl, com.google.gerrit.server.git.CodeReviewCommit cherryPickCommit) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change destChange = destCtl.getChange(); com.google.gerrit.reviewdb.client.PatchSet.Id psId = com.google.gerrit.server.ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId()); com.google.gerrit.server.change.PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit); com.google.gerrit.reviewdb.client.PatchSet.Id newPatchSetId = inserter.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet current = psUtil.current(db.get(), destCtl.getNotes()); bu.addOp(destChange.getId(), inserter.setMessage((("Uploaded patch set " + (newPatchSetId.get())) + ".")).setDraft(current.isDraft()).setNotify(NotifyHandling.NONE)); return destChange.getId(); }
public Change.Id cherryPick(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patch, java.lang.String message, java.lang.String ref, com.google.gerrit.server.project.RefControl refControl, int parent) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.git.IntegrationException, com.google.gerrit.server.project.InvalidChangeOperationException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { return cherryPick(change.getId(), patch.getId(), change.getDest(), change.getTopic(), change.getProject(), org.eclipse.jgit.lib.ObjectId.fromString(patch.getRevision().get()), message, ref, refControl, parent); }

private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.common.data.SubmitRecord.findOkRecord(cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)).isPresent(); }
private java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_LENIENT); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> submittable(java.lang.String str) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.common.data.SubmitRecord.Status status = com.google.common.base.Enums.getIfPresent(SubmitRecord.Status.class, str.toUpperCase()).orNull(); if (status == null) { throw error(("invalid value for submittable:" + str)); } return new com.google.gerrit.server.query.change.SubmittablePredicate(status); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return cd.submitRecords(ChangeField.SUBMIT_RULE_OPTIONS_STRICT).stream().anyMatch(( r) -> r.status == (status)); }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.server.project.SubmitRuleEvaluator(cd).setPatchSet(patchSet).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec)); } return rec.type; }
public static void checkSubmitRule(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet patchSet = cd.currentPatchSet(); if (patchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("missing current patch set for change " + (cd.getId()))); } java.util.List<com.google.gerrit.common.data.SubmitRecord> results = com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd); if (com.google.gerrit.common.data.SubmitRecord.findOkRecord(results).isPresent()) { return; } else if (results.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format("SubmitRuleEvaluator.evaluate for change %s returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get())); } for (com.google.gerrit.common.data.SubmitRecord record : results) { switch (record.status) { case CLOSED : throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is closed"); case RULE_ERROR : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("submit rule error: " + (record.errorMessage))); case NOT_READY : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(com.google.gerrit.server.git.MergeOp.describeLabels(cd, record.labels)); case FORCED : case OK : default : throw new java.lang.IllegalStateException(java.lang.String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get())); } } throw new java.lang.IllegalStateException(); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration); }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(this).getSubmitType(); } return submitTypeRecord; }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData in) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.server.index.change.ChangeField.formatSubmitRecordValues(in).contains(getValue()); }
private static java.lang.Iterable<byte[]> storedSubmitRecords(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.project.SubmitRuleOptions opts) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.server.index.change.ChangeField.storedSubmitRecords(cd.submitRecords(opts)); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData object) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change otherChange = object.change(); if (otherChange == null) { return false; } if (!(otherChange.getDest().equals(c.getDest()))) { return false; } com.google.gerrit.common.data.SubmitTypeRecord str = object.submitTypeRecord(); if (!(str.isOk())) { return false; } org.eclipse.jgit.lib.ObjectId other = org.eclipse.jgit.lib.ObjectId.fromString(object.currentPatchSet().getRevision().get()); com.google.gerrit.server.query.change.ConflictKey conflictsKey = new com.google.gerrit.server.query.change.ConflictKey(changeDataCache.getTestAgainst(), other, str.type, changeDataCache.getProjectState().isUseContentMerge()); java.lang.Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey); if (conflicts != null) { return conflicts; } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(otherChange.getProject());com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw = com.google.gerrit.server.git.CodeReviewCommit.newRevWalk(repo)) { conflicts = !(args.submitDryRun.run(str.type, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw))); args.conflictsCache.put(conflictsKey, conflicts); return conflicts; } catch (com.google.gerrit.server.git.IntegrationException | com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
private void assertNotMergeable(com.google.gerrit.server.query.change.ChangeData change) throws java.lang.Exception { change.setMergeable(null); assertThat(change.isMergeable()).isFalse(); }
@org.junit.Test public void prepopulatedFields() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isFalse(); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change = insert(repo, newChange(repo)); db = new com.google.gerrit.testutil.DisabledReviewDb(); requestContext.setContext(newRequestContext(userId)); java.util.List<com.google.gerrit.server.query.change.ChangeData> cds = queryProcessor.query(queryBuilder.parse(change.getId().toString())).entities(); assertThat(cds).hasSize(1); com.google.gerrit.server.query.change.ChangeData cd = cds.get(0); cd.change(); cd.patchSets(); cd.currentApprovals(); cd.changedLines(); cd.reviewedBy(); cd.reviewers(); cd.unresolvedCommentCount(); cd.isMergeable(); exception.expect(DisabledReviewDb.Disabled.class); cd.messages(); }
private void assertMergeable(com.google.gerrit.server.query.change.ChangeData change) throws java.lang.Exception { change.setMergeable(null); assertThat(change.isMergeable()).isTrue(); }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
private com.google.gerrit.server.IdentifiedUser onBehalfOf(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput in) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions().database(dbProvider); perm.check(ChangePermission.SUBMIT); perm.check(ChangePermission.SUBMIT_AS); com.google.gerrit.server.CurrentUser caller = rsrc.getUser(); com.google.gerrit.server.IdentifiedUser submitter = accounts.parseOnBehalfOf(caller, in.onBehalfOf); try { perm.user(submitter).check(ChangePermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("on_behalf_of account %s cannot see change", submitter.getAccountId())); } return submitter; }
public static java.util.List<java.lang.String> formatSubmitRecordValues(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return com.google.gerrit.server.index.change.ChangeField.formatSubmitRecordValues(cd.submitRecords(com.google.gerrit.server.index.change.ChangeField.SUBMIT_RULE_OPTIONS_STRICT), cd.change().getOwner()); }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment(com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((opts.rule()) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.StringReader(opts.rule())); } } catch (com.googlecode.prolog_cafe.exceptions.CompileException err) { java.lang.String msg; if (((opts.rule()) == null) && (control.getProjectControl().isOwner())) { msg = java.lang.String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage()); } else if ((opts.rule()) != null) { msg = err.getMessage(); } else { msg = java.lang.String.format("Cannot load rules.pl for %s", getProjectName()); } throw new com.google.gerrit.server.project.RuleEvalException(msg, err); } env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.CHANGE_CONTROL, control); if (user != null) { env.set(StoredValues.CURRENT_USER, user); } return env; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd) { try { com.google.gerrit.common.data.SubmitTypeRecord str = cd.submitTypeRecord(); return str.isOk() ? str.type : null; } catch (com.google.gwtorm.server.OrmException e) { logError(("Failed to get submit type for " + (cd.getId())), e); return null; } }
public static com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> create(java.lang.String label, com.google.gerrit.common.data.SubmitRecord.Label.Status status, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts) { java.lang.String lowerLabel = label.toLowerCase(); if ((accounts == null) || (accounts.isEmpty())) { return new com.google.gerrit.server.query.change.SubmitRecordPredicate((((status.name()) + ',') + lowerLabel)); } return com.google.gerrit.server.query.Predicate.or(accounts.stream().map(( a) -> new com.google.gerrit.server.query.change.SubmitRecordPredicate((((((status.name()) + ',') + lowerLabel) + ',') + (a.get())))).collect(java.util.stream.Collectors.toList())); }
private static java.util.List<com.google.gerrit.common.data.SubmitRecord> getSubmitRecords(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { return cd.submitRecords(com.google.gerrit.server.git.MergeOp.SUBMIT_RULE_OPTIONS); }
private void checkSubmitRulesAndState(com.google.gerrit.server.git.ChangeSet cs) throws com.google.gerrit.extensions.restapi.ResourceConflictException { checkArgument((!(cs.furtherHiddenChanges())), "checkSubmitRulesAndState called for topic with hidden change"); for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { try { if ((cd.change().getStatus()) != (Change.Status.NEW)) { commitStatus.problem(cd.getId(), ((("Change " + (cd.getId())) + " is ") + (cd.change().getStatus().toString().toLowerCase()))); } else if (cd.change().isWorkInProgress()) { commitStatus.problem(cd.getId(), (("Change " + (cd.getId())) + " is work in progress")); } else { com.google.gerrit.server.git.MergeOp.checkSubmitRule(cd); } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { commitStatus.problem(cd.getId(), e.getMessage()); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = "Error checking submit rules for change"; com.google.gerrit.server.git.MergeOp.log.warn(((msg + " ") + (cd.getId())), e); commitStatus.problem(cd.getId(), msg); } } commitStatus.maybeFailVerbose(); }
private void bypassSubmitRules(com.google.gerrit.server.git.ChangeSet cs) { checkArgument((!(cs.furtherHiddenChanges())), "cannot bypass submit rules for topic with hidden change"); for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { java.util.List<com.google.gerrit.common.data.SubmitRecord> records; try { records = new java.util.ArrayList(com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd)); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.git.MergeOp.log.warn(("Error checking submit rules for change " + (cd.getId())), e); records = new java.util.ArrayList(1); } com.google.gerrit.common.data.SubmitRecord forced = new com.google.gerrit.common.data.SubmitRecord(); forced.status = SubmitRecord.Status.FORCED; records.add(forced); cd.setSubmitRecords(com.google.gerrit.server.git.MergeOp.SUBMIT_RULE_OPTIONS, records); } }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { for (com.google.gerrit.common.data.PermissionRange pr : cd.changeControl().getLabelRanges()) { if (!(pr.isEmpty())) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : new com.google.gerrit.server.project.SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException { if (!visible) { return cd.changeControl().getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((("Failed to get submit type for " + (cd.getId())) + ": ") + (str.errorMessage))); } return str.type; }


@java.lang.Override public com.google.gerrit.extensions.common.ChangeInfo apply(com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.RevertInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.RefControl refControl = req.getControl().getRefControl(); com.google.gerrit.server.project.ProjectControl projectControl = req.getControl().getProjectControl(); com.google.gerrit.common.data.Capable capable = projectControl.canPushToAtLeastOneRef(); if (capable != (com.google.gerrit.common.data.Capable.OK)) { throw new com.google.gerrit.extensions.restapi.AuthException(capable.getMessage()); } com.google.gerrit.reviewdb.client.Change change = req.getChange(); if (!(refControl.canUpload())) { throw new com.google.gerrit.extensions.restapi.AuthException("revert not permitted"); } else if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } com.google.gerrit.reviewdb.client.Change.Id revertedChangeId = revert(req.getControl(), com.google.common.base.Strings.emptyToNull(input.message)); return json.noOptions().format(req.getProject(), revertedChangeId); }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi cherryPick(com.google.gerrit.extensions.api.changes.CherryPickInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changes.id(cherryPick.apply(revision, in)._number); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot cherry pick", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi revert(com.google.gerrit.extensions.api.changes.RevertInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changeApi.id(revert.apply(change, in)._number); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot revert change", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.access.ProjectAccessInfo access() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getAccess.apply(checkExists()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot get access rights", e); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.ChangeApi cherryPick(com.google.gerrit.extensions.api.changes.CherryPickInput input) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changes.id(cherryPickCommit.apply(commitResource, input)._number); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot cherry pick", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { com.google.gerrit.server.IdentifiedUser currentUser = refControl.getUser().asIdentifiedUser(); final org.eclipse.jgit.lib.PersonIdent committer = receiveEvent.commit.getCommitterIdent(); final org.eclipse.jgit.lib.PersonIdent author = receiveEvent.commit.getAuthorIdent(); final com.google.gerrit.server.project.ProjectControl projectControl = refControl.getProjectControl(); if (projectControl.getProjectState().isUseSignedOffBy()) { boolean sboAuthor = false; boolean sboCommitter = false; boolean sboMe = false; for (final org.eclipse.jgit.revwalk.FooterLine footer : receiveEvent.commit.getFooterLines()) { if (footer.matches(FooterKey.SIGNED_OFF_BY)) { final java.lang.String e = footer.getEmailAddress(); if (e != null) { sboAuthor |= author.getEmailAddress().equals(e); sboCommitter |= committer.getEmailAddress().equals(e); sboMe |= currentUser.hasEmailAddress(e); } } } if ((((!sboAuthor) && (!sboCommitter)) && (!sboMe)) && (!(refControl.canForgeCommitter()))) { throw new com.google.gerrit.server.git.validators.CommitValidationException("not Signed-off-by author/committer/uploader in commit message footer"); } } return java.util.Collections.emptyList(); }
private com.google.gerrit.server.git.validators.CommitValidationMessage getMissingChangeIdErrorMsg(final java.lang.String errMsg, final org.eclipse.jgit.revwalk.RevCommit c) { java.lang.StringBuilder sb = new java.lang.StringBuilder(); sb.append("ERROR: ").append(errMsg); if ((c.getFullMessage().indexOf(com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator.CHANGE_ID_PREFIX)) >= 0) { java.lang.String[] lines = c.getFullMessage().trim().split("\n"); java.lang.String lastLine = ((lines.length) > 0) ? lines[((lines.length) - 1)] : ""; if ((lastLine.indexOf(com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator.CHANGE_ID_PREFIX)) == (-1)) { sb.append('\n'); sb.append('\n'); sb.append("Hint: A potential "); sb.append(FooterConstants.CHANGE_ID.getName()); sb.append("Change-Id was found, but it was not in the "); sb.append("footer (last paragraph) of the commit message."); } } sb.append('\n'); sb.append('\n'); sb.append("Hint: To automatically insert "); sb.append(FooterConstants.CHANGE_ID.getName()); sb.append(", install the hook:\n"); sb.append(getCommitMessageHookInstallationHint()); sb.append('\n'); sb.append("And then amend the commit:\n"); sb.append(" git commit --amend\n"); return new com.google.gerrit.server.git.validators.CommitValidationMessage(sb.toString(), false); }
private void setThreadFactory(com.google.gerrit.server.git.WorkQueue.Executor executor) { final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory(); executor.setThreadFactory(new java.util.concurrent.ThreadFactory() { @java.lang.Override public java.lang.Thread newThread(final java.lang.Runnable task) { final java.lang.Thread t = parent.newThread(task); t.setPriority(java.lang.Thread.MIN_PRIORITY); return t; } }); }
@java.lang.Override public WorkQueue.Executor get() { final com.google.gerrit.server.git.WorkQueue.Executor executor; executor = queues.createQueue(poolSize, "SSH-Stream-Worker"); final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory(); executor.setThreadFactory(new java.util.concurrent.ThreadFactory() { @java.lang.Override public java.lang.Thread newThread(final java.lang.Runnable task) { final java.lang.Thread t = parent.newThread(task); t.setPriority(java.lang.Thread.MIN_PRIORITY); return t; } }); return executor; }
private com.google.common.collect.Multimap<java.lang.String, org.eclipse.jgit.diff.Edit> getEditsDueToRebasePerFilePath(org.eclipse.jgit.revwalk.RevWalk revWalk, org.eclipse.jgit.revwalk.RevCommit commitB, org.eclipse.jgit.revwalk.RevCommit commitA) throws com.google.gerrit.server.patch.PatchListNotAvailableException, java.io.IOException { if (!(arePatchSetCommitsWithRebaseInBetween(revWalk, commitA, commitB))) { return com.google.common.collect.ImmutableMultimap.of(); } return getEditsDueToRebasePerFilePath(commitA, commitB); }
public static com.google.gerrit.server.patch.DiffSummaryKey fromPatchListKey(com.google.gerrit.server.patch.PatchListKey plk) { return new com.google.gerrit.server.patch.DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace()); }
@org.junit.Before public void createTempDirectory() throws java.lang.Exception { sitePath = com.google.gerrit.testutil.TempFileUtil.createTempDirectory(); }
@org.junit.Test public void rebuildEmptySite() throws java.lang.Exception { initSite(); com.google.common.io.Files.asCharSink(new java.io.File(sitePath.toString(), "etc/gerrit.config"), java.nio.charset.StandardCharsets.UTF_8, FileWriteMode.APPEND).write(com.google.gerrit.server.notedb.ConfigNotesMigration.allEnabledConfig().toText()); com.google.gerrit.acceptance.pgm.RebuildNoteDbIT.runGerrit("RebuildNoteDb", "-d", sitePath.toString(), "--show-stack-trace"); }



@org.junit.Test public void deleteCcerFromReviewableChange() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); removeReviewer(sc, extraCcer); assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraCcer).cc(extraReviewer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }

private com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> reviewer(java.lang.String who, boolean forDefaultField) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField); if (java.util.Objects.equals(byState, com.google.gerrit.server.query.Predicate.<com.google.gerrit.server.query.change.ChangeData>any())) { return com.google.gerrit.server.query.Predicate.any(); } if (args.getSchema().hasField(ChangeField.WIP)) { return com.google.gerrit.server.query.Predicate.and(com.google.gerrit.server.query.Predicate.not(new com.google.gerrit.server.query.change.BooleanPredicate(com.google.gerrit.server.index.change.ChangeField.WIP, args.fillArgs)), byState); } return byState; }
@org.junit.Test public void addReviewerToReviewableWipChange() throws java.lang.Exception { forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email); assertThat(sender).notSent(); }); }


@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); change.setWorkInProgress(workInProgress); change.setLastUpdatedOn(ctx.getWhen()); update.setWorkInProgress(workInProgress); addMessage(ctx, update); return true; }




@org.junit.Test public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyOwner() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, com.google.gerrit.acceptance.server.mail.OWNER); assertThat(sender).notSent(); }); }
private com.google.gerrit.acceptance.server.mail.StagedChange stageWipChange() throws java.lang.Exception { return stageChange(this::stageWipChange); }

@org.junit.Test public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS); setApiUser(admin); removeReviewer(sc, extraReviewer); assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void commentOnReviewableChangeByOther() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); review(other, sc.changeId, com.google.gerrit.acceptance.server.mail.ENABLED); assertThat(sender).sent("comment", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void commentOnReviewableChangeByOtherCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); review(other, sc.changeId, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS); assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
public com.google.gerrit.acceptance.AbstractNotificationTest.FakeEmailSenderSubject sent(java.lang.String messageType, com.google.gerrit.acceptance.AbstractNotificationTest.StagedUsers users) { message = actual().nextMessage(); if ((message) == null) { fail("a message was sent"); } recipients = new java.util.HashMap(); recipients.put(com.google.gerrit.acceptance.TO, parseAddresses(message, "To")); recipients.put(com.google.gerrit.acceptance.CC, parseAddresses(message, "CC")); recipients.put(com.google.gerrit.acceptance.BCC, message.rcpt().stream().map(Address::getEmail).filter(( e) -> (!(recipients.get(com.google.gerrit.acceptance.TO).contains(e))) && (!(recipients.get(com.google.gerrit.acceptance.CC).contains(e)))).collect(java.util.stream.Collectors.toList())); this.users = users; if (!(message.headers().containsKey("X-Gerrit-MessageType"))) { fail("a message was sent with X-Gerrit-MessageType header"); } com.google.gerrit.server.mail.send.EmailHeader header = message.headers().get("X-Gerrit-MessageType"); if (!(header.equals(new com.google.gerrit.server.mail.send.EmailHeader.String(messageType)))) { fail(((("message of type " + messageType) + " was sent; X-Gerrit-MessageType is ") + header)); } java.lang.StringBuilder buf = new java.lang.StringBuilder(); buf.append('['); for (com.google.gerrit.acceptance.RecipientType type : com.google.common.collect.ImmutableList.of(com.google.gerrit.acceptance.TO, com.google.gerrit.acceptance.CC, com.google.gerrit.acceptance.BCC)) { buf.append('\n'); buf.append(type); buf.append(':'); java.lang.String delim = " "; for (java.lang.String r : recipients.get(type)) { buf.append(delim); buf.append(com.google.gerrit.acceptance.AbstractNotificationTest.stripUniqueSuffix(r)); delim = ", "; } } buf.append("\n]"); return named(buf.toString()); }

private void rcpt(@com.google.gerrit.common.Nullable com.google.gerrit.acceptance.RecipientType type, java.lang.String email, boolean expected) { if ((recipients.get(type).contains(email)) != expected) { fail((expected ? "notifies" : "doesn't notify"), (((("]\n" + type) + ": ") + (com.google.gerrit.acceptance.AbstractNotificationTest.stripUniqueSuffix(email))) + "\n]")); } }


@org.junit.Test public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.OWNER_REVIEWERS); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }
protected void add(final com.google.gerrit.extensions.api.changes.RecipientType rt, final java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> list) { for (final com.google.gerrit.reviewdb.client.Account.Id id : list) { add(rt, id); } }

protected void add(final com.google.gerrit.extensions.api.changes.RecipientType rt, final com.google.gerrit.reviewdb.client.UserIdentity who) { if ((who != null) && ((who.getAccount()) != null)) { add(rt, who.getAccount()); } }

protected void addByEmail(final com.google.gerrit.extensions.api.changes.RecipientType rt, final java.util.Collection<com.google.gerrit.server.mail.Address> list) { for (final com.google.gerrit.server.mail.Address id : list) { add(rt, id); } }
@org.junit.Test public void abandonReviewableChangeByOtherCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); abandon(sc.changeId, other, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS); assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).to(sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }

protected void add(final com.google.gerrit.extensions.api.changes.RecipientType rt, final com.google.gerrit.reviewdb.client.Account.Id to) { try { if ((!(rcptTo.contains(to))) && (isVisibleTo(to))) { rcptTo.add(to); add(rt, toAddress(to)); } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.mail.send.OutgoingEmail.log.error(("Error reading database for account: " + to), e); } }

protected void add(final com.google.gerrit.extensions.api.changes.RecipientType rt, final com.google.gerrit.server.mail.Address addr) { if (((addr != null) && ((addr.getEmail()) != null)) && ((addr.getEmail().length()) > 0)) { if (!(args.validator.isValid(addr.getEmail()))) { com.google.gerrit.server.mail.send.OutgoingEmail.log.warn((("Not emailing " + (addr.getEmail())) + " (invalid email address)")); } else if (!(args.emailSender.canEmail(addr.getEmail()))) { com.google.gerrit.server.mail.send.OutgoingEmail.log.warn((("Not emailing " + (addr.getEmail())) + " (prohibited by allowrcpt)")); } else if (smtpRcptTo.add(addr)) { switch (rt) { case TO : ((com.google.gerrit.server.mail.send.EmailHeader.AddressList) (headers.get(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_TO))).add(addr); break; case CC : ((com.google.gerrit.server.mail.send.EmailHeader.AddressList) (headers.get(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_CC))).add(addr); break; case BCC : break; } } } }
@org.junit.Test public void abandonWipChange() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); abandon(sc.changeId, sc.owner); assertThat(sender).sent("abandon", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).to(sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }




@org.junit.Test public void addReviewerToWipChangeInNoteDbNotifyAll() throws java.lang.Exception { forAll(( adder) -> { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }




@org.junit.Test public void addReviewerToWipChangeInReviewDbNotifyAll() throws java.lang.Exception { forAll(( adder) -> { assume().that(notesMigration.readChanges()).isFalse(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }

@org.junit.Test public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, other, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, null); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }

@org.junit.Test public void addReviewerToReviewableChangeByOtherInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, other, reviewer.email); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }
@org.junit.Test public void abandonReviewableChangeByOther() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); abandon(sc.changeId, other); assertThat(sender).sent("abandon", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).to(sc.reviewerByEmail).cc(sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }

@org.junit.Test public void addReviewerToWipChange() throws java.lang.Exception { forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email); assertThat(sender).notSent(); }); }
@org.junit.Test public void changeAssigneeOnReviewableChange() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); assign(sc, sc.owner, other); sender.clear(); assign(sc, sc.owner, assignee); assertThat(sender).sent("setassignee", sc).notTo(sc.owner, sc.reviewer, sc.ccer, sc.starrer, other).to(sc.reviewerByEmail).cc(sc.ccerByEmail).to(assignee); }
@org.junit.Test public void addReviewerByEmailToReviewableChangeInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { java.lang.String email = "addedbyemail@example.com"; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); addReviewer(adder, sc.changeId, sc.owner, email); assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }

@org.junit.Test public void addReviewerToReviewableChangeInReviewDb() throws java.lang.Exception { forAll(( adder) -> { assume().that(notesMigration.readChanges()).isFalse(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer); }); }
@org.junit.Test public void addReviewerToWipChangeInNoteDbNotifyAll() throws java.lang.Exception { forAll(( adder) -> { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer); }); }

@org.junit.Test public void addReviewerToReviewableChangeInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer); }); }
@org.junit.Test public void addReviewerToWipChangeInReviewDbNotifyAll() throws java.lang.Exception { forAll(( adder) -> { assume().that(notesMigration.readChanges()).isFalse(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer); }); }


@org.junit.Test public void addReviewerToReviewableChangeInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }
@org.junit.Test public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); abandon(sc.changeId, other, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, com.google.gerrit.acceptance.server.mail.OWNER); assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).notTo(sc.reviewer, sc.ccer, sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }
@org.junit.Test public void abandonReviewableChangeByOther() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); abandon(sc.changeId, other); assertThat(sender).sent("abandon", sc).notTo(other).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }
@org.junit.Test public void abandonReviewableChangeByOtherCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); abandon(sc.changeId, other, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS); assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); }

@org.junit.Test public void abandonWipChangeInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(com.google.gerrit.acceptance.server.mail.ABANDONED_CHANGES); abandon(sc.changeId, sc.owner); assertThat(sender).notSent(); }

@org.junit.Test public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, null); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse(); }); }
private void forAll(com.google.gerrit.acceptance.server.mail.AddReviewerSenderIT.Tester tester) throws java.lang.Exception { for (com.google.gerrit.acceptance.server.mail.AddReviewerSenderIT.Adder adder : com.google.common.collect.ImmutableList.of(singly(), batch())) { tester.test(adder); } }

@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); if ((fromId) != null) { reviewers.remove(fromId); } add(RecipientType.TO, reviewers); add(RecipientType.CC, extraCC); rcptToAuthors(RecipientType.CC); bccStarredBy(); includeWatchers(NotifyType.NEW_PATCHSETS, (((!(patchSet.isDraft())) && (!(change.isWorkInProgress()))) && (!(change.isPrivate())))); removeUsersThatIgnoredTheChange(); }

@org.junit.Test public void addReviewerToReviewableChangeInNoteDbByOwnerCcingSelfNotifyNone() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, com.google.gerrit.acceptance.server.mail.NONE); assertThat(sender).notSent(); }); }

@org.junit.Test public void addReviewerByEmailToReviewableChangeInReviewDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isFalse(); forAll(( adder) -> { java.lang.String email = "addedbyemail@example.com"; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); addReviewer(adder, sc.changeId, sc.owner, email); assertThat(sender).notSent(); }); }

@org.junit.Test public void addReviewerToReviewableChangeByOtherCcingSelfInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, other, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, null); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer); }); }
@org.junit.Test public void addReviewerToReviewableChangeByOtherInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.acceptance.TestAccount other = accounts.create("other", "other@example.com", "other"); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, other, reviewer.email); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer, other); }); }
@org.junit.Test public void addReviewerToReviewableChangeByOwnerCcingSelfInNoteDb() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS, null); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer); }); }
@org.junit.Test public void revertChangeByOtherCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange(); revert(sc, other, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS); assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer).cc(sc.ccer, other).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); assertThat(sender).sent("revert", sc).to(other).cc(sc.owner, sc.reviewer, sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }

@org.junit.Test public void deleteReviewerFromReviewableChangeByAdmin() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); setApiUser(admin); removeReviewer(sc, extraReviewer); assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void deleteReviewerFromReviewableChange() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); removeReviewer(sc, extraReviewer); assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS); assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS); removeReviewer(sc, extraReviewer, NotifyHandling.OWNER); assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).notTo(extraCcer, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
private com.google.gerrit.acceptance.server.mail.StagedChange stageReviewableChange() throws java.lang.Exception { return stageChange(this::stageReviewableChange); }
@org.junit.Test public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS); removeReviewer(sc, extraReviewer); assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void deleteReviewerFromReviewableChangeNotifyOwner() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); removeReviewer(sc, extraReviewer, NotifyHandling.OWNER); assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).notTo(extraCcer, sc.owner, sc.reviewer, sc.ccer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.starrer).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
@org.junit.Test public void addReviewerToReviewableChangeInNoteDbNotifyOwnerReviewers() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); forAll(( adder) -> { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange(); com.google.gerrit.acceptance.TestAccount reviewer = accounts.create("added", "added@example.com", "added"); addReviewer(adder, sc.changeId, sc.owner, reviewer.email, com.google.gerrit.acceptance.server.mail.OWNER_REVIEWERS); assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).notTo(sc.owner, sc.starrer); }); }
@org.junit.Test public void deleteReviewerFromWipChangeNotifyAll() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); removeReviewer(sc, extraReviewer, NotifyHandling.ALL); assertThat(sender).sent("deleteReviewer", sc).notTo(sc.owner).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
private com.google.gerrit.acceptance.server.mail.StagedChange stageReviewableWipChange() throws java.lang.Exception { return stageChange(this::stageReviewableWipChange); }
private com.google.gerrit.acceptance.server.mail.StagedChange stageChange(com.google.gerrit.acceptance.server.mail.DeleteReviewerSenderIT.Stager stager) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stager.stage(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.noScore().reviewer(extraReviewer.email).reviewer(extraCcer.email, ReviewerState.CC, false); gApi.changes().id(sc.changeId).revision("current").review(in); return sc; }
@org.junit.Test public void revertChangeByOther() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange(); revert(sc, other); assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).notTo(other).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); assertThat(sender).sent("revert", sc).cc(sc.owner, sc.reviewer, sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }

@org.junit.Test public void deleteReviewerWithApprovalFromWipChange() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange(); setApiUser(extraReviewer); gApi.changes().id(sc.changeId).revision("current").review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); sender.clear(); setApiUser(sc.owner); removeReviewer(sc, extraReviewer); assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).notTo(sc.owner, sc.ccer, sc.starrer, extraCcer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }

@org.junit.Test public void revertChangeByOwnerCcingSelf() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange(); revert(sc, sc.owner, com.google.gerrit.acceptance.server.mail.CC_ON_OWN_COMMENTS); assertThat(sender).sent("newchange", sc).to(sc.reviewer).cc(sc.owner, sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }

@org.junit.Test public void revertChangeByOwner() throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange(); revert(sc, sc.owner); assertThat(sender).sent("newchange", sc).notTo(sc.owner).to(sc.reviewer).cc(sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).notTo(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); assertThat(sender).sent("revert", sc).notTo(sc.owner).cc(sc.reviewer, sc.ccer).notTo(sc.starrer).notTo(sc.reviewerByEmail, sc.ccerByEmail).bcc(com.google.gerrit.acceptance.server.mail.ALL_COMMENTS); }
public java.util.List<com.google.gerrit.server.git.validators.ValidationMessage> validateForRefOperation() throws com.google.gerrit.server.git.validators.RefOperationValidationException { java.util.List<com.google.gerrit.server.git.validators.ValidationMessage> messages = new java.util.ArrayList<>(); boolean withException = false; java.util.List<com.google.gerrit.server.git.validators.RefOperationValidationListener> listeners = new java.util.ArrayList<>(); listeners.add(new com.google.gerrit.server.git.validators.RefOperationValidators.DisallowDeletionOfUserBranches(allUsersName)); refOperationValidationListeners.forEach(( l) -> listeners.add(l)); try { for (com.google.gerrit.server.git.validators.RefOperationValidationListener listener : listeners) { messages.addAll(listener.onRefOperation(event)); } } catch (com.google.gerrit.server.validators.ValidationException e) { messages.add(new com.google.gerrit.server.git.validators.ValidationMessage(e.getMessage(), true)); withException = true; } if (withException) { throwException(messages, event); } return messages; }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo checkConsistency(com.google.gerrit.extensions.api.config.ConsistencyCheckInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return checkConsistency.get().apply(new com.google.gerrit.server.config.ConfigResource(), in); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot check consistency", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.ValidationMessage> onRefOperation(RefReceivedEvent refEvent) throws com.google.gerrit.server.validators.ValidationException { if (((refEvent.project.getNameKey().equals(allUsersName)) && ((refEvent.command.getRefName().startsWith(RefNames.REFS_USERS)) && (!(refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))))) && (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE))) { if (!(refEvent.user.getCapabilities().canAccessDatabase())) { throw new com.google.gerrit.server.validators.ValidationException("Not allowed to delete user branch."); } } return com.google.common.collect.ImmutableList.of(); }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo apply(com.google.gerrit.server.config.ConfigResource resource, com.google.gerrit.extensions.api.config.ConsistencyCheckInput input) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { com.google.gerrit.server.IdentifiedUser user = userProvider.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } if (!(user.getCapabilities().canAccessDatabase())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to run consistency checks"); } if ((input == null) || ((input.checkAccountExternalIds) == null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("input required"); } com.google.gerrit.extensions.api.config.ConsistencyCheckInfo consistencyCheckInfo = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(); if ((input.checkAccountExternalIds) != null) { consistencyCheckInfo.checkAccountExternalIdsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountExternalIdsResultInfo(externalIdsConsistencyChecker.check()); } return consistencyCheckInfo; }