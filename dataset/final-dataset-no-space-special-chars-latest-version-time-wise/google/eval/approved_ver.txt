static java.util.Map<java.lang.String, java.lang.Integer> getVotes(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, java.lang.Integer> map = new java.util.HashMap<>(); for (com.google.gerrit.reviewdb.client.PatchSetApproval p : changeData.currentApprovals()) { if ((p.getValue()) != 0) { map.put(accountCache.get(p.getAccountId()).getAccount().getPreferredEmail(), java.lang.Integer.valueOf(p.getValue())); } } return map; }
private static java.lang.String readCookie(javax.servlet.http.HttpServletRequest request) { javax.servlet.http.Cookie[] all = request.getCookies(); if (all != null) { for (javax.servlet.http.Cookie c : all) { if (com.google.gerrit.httpd.CacheBasedWebSession.ACCOUNT_COOKIE.equals(c.getName())) { return com.google.common.base.Strings.emptyToNull(c.getValue()); } } } return null; }
private void authFromQueryParameter(java.lang.String accessToken) { key = new com.google.gerrit.httpd.WebSessionManager.Key(accessToken); val = manager.get(key); if ((val) != null) { okPaths.add(AccessPath.REST_API); } }
private static void setCorsHeaders(javax.servlet.http.HttpServletResponse res, java.lang.String origin) { res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_ORIGIN, origin); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true"); res.setHeader(com.google.gerrit.httpd.restapi.ACCESS_CONTROL_MAX_AGE, "600"); com.google.gerrit.httpd.restapi.RestApiServlet.setHeaderList(res, com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_METHODS, com.google.common.collect.Iterables.concat(com.google.gerrit.httpd.restapi.RestApiServlet.ALLOWED_CORS_METHODS, com.google.common.collect.ImmutableList.of("OPTIONS"))); com.google.gerrit.httpd.restapi.RestApiServlet.setHeaderList(res, com.google.gerrit.httpd.restapi.ACCESS_CONTROL_ALLOW_HEADERS, com.google.gerrit.httpd.restapi.RestApiServlet.ALLOWED_CORS_REQUEST_HEADERS); }
private static javax.servlet.http.HttpServletRequest applyXdOverrides(javax.servlet.http.HttpServletRequest req, com.google.gerrit.httpd.restapi.ParameterParser.QueryParams qp) throws com.google.gerrit.extensions.restapi.BadRequestException { if (!("POST".equals(req.getMethod()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("POST required"); } java.lang.String method = qp.xdMethod(); java.lang.String contentType = qp.xdContentType(); if ((method.equals("POST")) || (method.equals("PUT"))) { if (!("text/plain".equals(req.getContentType()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("invalid " + (CONTENT_TYPE))); } else if (com.google.common.base.Strings.isNullOrEmpty(contentType)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(((com.google.gerrit.httpd.restapi.RestApiServlet.XD_CONTENT_TYPE) + " required")); } } return new javax.servlet.http.HttpServletRequestWrapper(req) { @java.lang.Override public java.lang.String getMethod() { return method; } @java.lang.Override public java.lang.String getContentType() { return contentType; } }; }
@org.junit.After public void cleanUp() throws java.lang.Exception { gApi.accounts().id(user42.getId().toString()).setPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } accountCache.evictAllNoReindex(); }
@org.junit.After public void cleanUp() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsers)) { if ((git.exactRef(RefNames.REFS_USERS_DEFAULT)) != null) { org.eclipse.jgit.lib.RefUpdate u = git.updateRef(RefNames.REFS_USERS_DEFAULT); u.setForceUpdate(true); assertThat(u.delete()).isEqualTo(RefUpdate.Result.FORCED); } } accountCache.evictAllNoReindex(); }
private com.google.gerrit.extensions.client.GeneralPreferencesInfo writeToGit(com.google.gerrit.extensions.client.GeneralPreferencesInfo i) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) { com.google.gerrit.server.account.VersionedAccountPreferences p = com.google.gerrit.server.account.VersionedAccountPreferences.forDefault(); p.load(md); com.google.gerrit.server.config.ConfigUtil.storeSection(p.getConfig(), UserConfigSections.GENERAL, null, i, com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()); com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my); com.google.gerrit.server.account.SetPreferences.storeUrlAliases(p, i.urlAliases); p.commit(md); accountCache.evictAllNoReindex(); com.google.gerrit.extensions.client.GeneralPreferencesInfo r = com.google.gerrit.server.config.ConfigUtil.loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new com.google.gerrit.extensions.client.GeneralPreferencesInfo(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(), null); return loader.loadMyMenusAndUrlAliases(r, p, null); } }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate().setRefLogMessage("merged")); } return updates; }
public static boolean isGroupReference(java.lang.String configValue) { return (configValue != null) && (configValue.startsWith(com.google.gerrit.common.data.GroupReference.PREFIX)); }
public java.util.concurrent.ScheduledThreadPoolExecutor createQueue(int poolsize, java.lang.String prefix) { return createQueue(poolsize, prefix, java.lang.Thread.NORM_PRIORITY); }
@java.lang.Override public java.util.concurrent.ScheduledThreadPoolExecutor get() { return queues.createQueue(poolSize, "SSH-Stream-Worker", java.lang.Thread.MIN_PRIORITY); }
public java.util.concurrent.ScheduledThreadPoolExecutor createQueue(int poolsize, java.lang.String prefix, int threadPriority) { com.google.gerrit.server.git.WorkQueue.Executor executor = new com.google.gerrit.server.git.WorkQueue.Executor(poolsize, prefix); executor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false); executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(true); queues.add(executor); if (threadPriority != (java.lang.Thread.NORM_PRIORITY)) { java.util.concurrent.ThreadFactory parent = executor.getThreadFactory(); executor.setThreadFactory(( task) -> { java.lang.Thread t = parent.newThread(task); t.setPriority(threadPriority); return t; }); } return executor; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setTrialMode(boolean trial) { this.trial = trial; return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setForceRebuild(boolean forceRebuild) { this.forceRebuild = forceRebuild; return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setThreads(int threads) { this.threads = threads; return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setChanges(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id> changes) { this.changes = (changes != null) ? com.google.common.collect.ImmutableList.copyOf(changes) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setProjects(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) { this.projects = (projects != null) ? com.google.common.collect.ImmutableList.copyOf(projects) : com.google.common.collect.ImmutableList.of(); return this; }
@java.lang.Override public void close() { executor.shutdownNow(); }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder build() { return new com.google.gerrit.server.notedb.rebuild.SiteRebuilder(sitePaths, schemaFactory, updateManagerFactory, rebuilder, bundleReader, ((threads) > 1 ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService()), projects, changes, progressOut, trial, forceRebuild); }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); if (!(notesMigration.enabled())) { throw die("NoteDb is not enabled."); } com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); try (com.google.gerrit.server.notedb.rebuild.SiteRebuilder rebuilder = rebuilderBuilderProvider.get().setThreads(threads).setProgressOut(java.lang.System.err).setProjects(projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList())).setChanges(changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList())).build()) { return rebuilder.rebuild() ? 0 : 1; } }
public void autoRebuild() throws com.google.gwtorm.server.OrmException, java.io.IOException { checkState(((changes.isEmpty()) && (projects.isEmpty())), "cannot set changes or projects during auto-migration; call rebuild() instead"); java.util.Optional<com.google.gerrit.server.notedb.NotesMigrationState> maybeState = loadState(); if (!(maybeState.isPresent())) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException("Could not determine initial migration state"); } com.google.gerrit.server.notedb.NotesMigrationState state = maybeState.get(); if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) > 0)) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes")); } boolean rebuilt = false; while ((state.compareTo(NotesMigrationState.NOTE_DB_UNFUSED)) < 0) { if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) >= 0)) { return; } switch (state) { case REVIEW_DB : state = turnOnWrites(state); break; case WRITE : state = rebuildAndEnableReads(state); rebuilt = true; break; case READ_WRITE_NO_SEQUENCE : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = enableSequences(); break; case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = setNoteDbPrimary(); break; case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY : state = disableReviewDb(); break; case NOTE_DB_UNFUSED : break; case NOTE_DB : default : throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration out of the following state is not supported:\n" + (state.toText()))); } } }
public com.google.gerrit.server.notedb.rebuild.SiteRebuilder.Builder setProgressOut(java.io.OutputStream progressOut) { this.progressOut = checkNotNull(progressOut); return this; }
@org.junit.Test public void rebuildEmptySiteStartingWithNoteDbDisabed() throws java.lang.Exception { assertNotesMigrationState(NotesMigrationState.REVIEW_DB); com.google.gerrit.acceptance.pgm.RebuildNoteDbIT.runGerrit("RebuildNoteDb", "-d", sitePath, "--show-stack-trace"); assertNotesMigrationState(NotesMigrationState.READ_WRITE_NO_SEQUENCE); }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setForceRebuild(boolean forceRebuild) { this.forceRebuild = forceRebuild; return this; }
@java.lang.Override public int run() throws java.lang.Exception { mustHaveValidSite(); dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); threads = com.google.gerrit.pgm.util.ThreadLimiter.limitThreads(dbInjector, threads); com.google.gerrit.lifecycle.LifecycleManager dbManager = new com.google.gerrit.lifecycle.LifecycleManager(); dbManager.add(dbInjector); dbManager.start(); sysInjector = createSysInjector(); sysInjector.injectMembers(this); com.google.gerrit.lifecycle.LifecycleManager sysManager = new com.google.gerrit.lifecycle.LifecycleManager(); sysManager.add(sysInjector); sysManager.start(); try (com.google.gerrit.server.notedb.rebuild.NoteDbMigrator migrator = migratorBuilderProvider.get().setThreads(threads).setProgressOut(java.lang.System.err).setProjects(projects.stream().map(com.google.gerrit.reviewdb.client.Project.NameKey::new).collect(java.util.stream.Collectors.toList())).setChanges(changes.stream().map(com.google.gerrit.reviewdb.client.Change.Id::new).collect(java.util.stream.Collectors.toList())).setTrialMode(trial).setForceRebuild(force).build()) { if ((!(projects.isEmpty())) || (!(changes.isEmpty()))) { migrator.rebuild(); } else { migrator.migrate(); } } return 0; }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setTrialMode(boolean trial) { this.trial = trial; return this; }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setProjects(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) { this.projects = (projects != null) ? com.google.common.collect.ImmutableList.copyOf(projects) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setThreads(int threads) { this.threads = threads; return this; }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setChanges(@com.google.gerrit.common.Nullable java.util.Collection<com.google.gerrit.reviewdb.client.Change.Id> changes) { this.changes = (changes != null) ? com.google.common.collect.ImmutableList.copyOf(changes) : com.google.common.collect.ImmutableList.of(); return this; }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setProgressOut(java.io.OutputStream progressOut) { this.progressOut = checkNotNull(progressOut); return this; }
public void migrate() throws com.google.gwtorm.server.OrmException, java.io.IOException { checkState(((changes.isEmpty()) && (projects.isEmpty())), "cannot set changes or projects during auto-migration; call rebuild() instead"); java.util.Optional<com.google.gerrit.server.notedb.NotesMigrationState> maybeState = loadState(); if (!(maybeState.isPresent())) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException("Could not determine initial migration state"); } com.google.gerrit.server.notedb.NotesMigrationState state = maybeState.get(); if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) > 0)) { throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes")); } boolean rebuilt = false; while ((state.compareTo(NotesMigrationState.NOTE_DB_UNFUSED)) < 0) { if ((trial) && ((state.compareTo(NotesMigrationState.READ_WRITE_NO_SEQUENCE)) >= 0)) { return; } switch (state) { case REVIEW_DB : state = turnOnWrites(state); break; case WRITE : state = rebuildAndEnableReads(state); rebuilt = true; break; case READ_WRITE_NO_SEQUENCE : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = enableSequences(); break; case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY : if ((forceRebuild) && (!rebuilt)) { state = rebuildAndEnableReads(state); rebuilt = true; } state = setNoteDbPrimary(); break; case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY : state = disableReviewDb(); break; case NOTE_DB_UNFUSED : break; case NOTE_DB : default : throw new com.google.gerrit.server.notedb.rebuild.MigrationException(("Migration out of the following state is not supported:\n" + (state.toText()))); } } }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator build() { return new com.google.gerrit.server.notedb.rebuild.NoteDbMigrator(sitePaths, schemaFactory, updateManagerFactory, rebuilder, bundleReader, ((threads) > 1 ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService()), projects, changes, progressOut, trial, forceRebuild); }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get()); if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory); }
@java.lang.SuppressWarnings("deprecation") public org.eclipse.jgit.lib.ObjectId sha1() { return org.eclipse.jgit.lib.ObjectId.fromRaw(com.google.common.hash.Hashing.sha1().hashString(get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()); }
private java.lang.String etag(com.google.gitiles.doc.DocServlet.MarkdownFile srcmd, @javax.annotation.Nullable com.google.gitiles.doc.DocServlet.MarkdownFile navmd) { byte[] b = new byte[org.eclipse.jgit.lib.Constants.OBJECT_ID_LENGTH]; com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); h.putInt(com.google.gitiles.doc.DocServlet.ETAG_GEN); renderer.getTemplateHash(com.google.gitiles.doc.DocServlet.SOY_FILE).writeBytesTo(b, 0, b.length); h.putBytes(b); if (navmd != null) { navmd.id.copyRawTo(b, 0); h.putBytes(b); } srcmd.id.copyRawTo(b, 0); h.putBytes(b); return h.hash().toString(); }
private static java.lang.String randSuffix() { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); byte[] buf = new byte[8]; org.eclipse.jgit.util.NB.encodeInt64(buf, 0, com.google.gerrit.common.TimeUtil.nowMs()); h.putBytes(buf); com.google.gerrit.server.change.FileContentUtil.rng.nextBytes(buf); h.putBytes(buf); return h.hash().toString(); }
@java.lang.Override public java.lang.String getETag(com.google.gerrit.server.change.RevisionResource rsrc) { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); com.google.gerrit.server.CurrentUser user = rsrc.getControl().getUser(); try { rsrc.getChangeResource().prepareETag(h, user); h.putBoolean(com.google.gerrit.server.change.Submit.wholeTopicEnabled(config)); com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get(); com.google.gerrit.server.git.ChangeSet cs = mergeSuperSet.get().completeChangeSet(db, rsrc.getChange(), user); for (com.google.gerrit.server.query.change.ChangeData cd : cs.changes()) { changeResourceFactory.create(cd.changeControl()).prepareETag(h, user); } h.putBoolean(cs.furtherHiddenChanges()); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gwtorm.server.OrmRuntimeException(e); } return h.hash().toString(); }
com.google.common.hash.HashCode computeTemplateHash(java.lang.String soyFile) { java.net.URL u = templates.get(soyFile); checkState((u != null), "Missing Soy template %s", soyFile); com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); try (java.io.InputStream is = u.openStream();java.io.OutputStream os = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(is, os); } catch (java.io.IOException e) { throw new java.lang.IllegalStateException(("Missing Soy template " + soyFile), e); } return h.hash(); }
@java.lang.Override public java.lang.String getETag() { com.google.gerrit.server.CurrentUser user = control.getUser(); com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, user); return h.hash().toString(); }
private void verifyFileChecksum() { if ((sha1) == null) { java.lang.System.err.println(); java.lang.System.err.flush(); return; } com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); try (java.io.InputStream in = java.nio.file.Files.newInputStream(dst);java.io.OutputStream out = com.google.common.hash.Funnels.asOutputStream(h)) { com.google.common.io.ByteStreams.copy(in, out); } catch (java.io.IOException e) { deleteDst(); throw new com.google.gerrit.common.Die(("cannot checksum " + (dst)), e); } if (sha1.equals(h.hash().toString())) { java.lang.System.err.println((("Checksum " + (dst.getFileName())) + " OK")); java.lang.System.err.flush(); } else if (ui.isBatch()) { deleteDst(); throw new com.google.gerrit.common.Die(((dst) + " SHA-1 checksum does not match")); } else if (!(ui.yesno(null, "error: SHA-1 checksum does not match\nUse %s anyway", dst.getFileName()))) { deleteDst(); throw new com.google.gerrit.common.Die("aborted by user"); } }
public static com.google.gerrit.server.change.PostReview.CommentSetEntry create(com.google.gerrit.reviewdb.client.Comment comment) { return com.google.gerrit.server.change.PostReview.CommentSetEntry.create(comment.key.filename, comment.key.patchSetId, comment.lineNbr, com.google.gerrit.extensions.client.Side.fromShort(comment.side), com.google.common.hash.Hashing.murmur3_128().hashString(comment.message, java.nio.charset.StandardCharsets.UTF_8), comment.range); }
public final void addOps(com.google.gerrit.server.update.BatchUpdate bu, java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> toMerge) throws com.google.gerrit.server.git.IntegrationException { java.util.List<com.google.gerrit.server.git.strategy.SubmitStrategyOp> ops = buildOps(toMerge); java.util.Set<com.google.gerrit.server.git.CodeReviewCommit> added = com.google.common.collect.Sets.newHashSetWithExpectedSize(ops.size()); for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { added.add(op.getCommit()); } java.util.List<com.google.gerrit.server.git.CodeReviewCommit> difference = new java.util.ArrayList(com.google.common.collect.Sets.difference(toMerge, added)); java.util.Collections.reverse(difference); for (com.google.gerrit.server.git.CodeReviewCommit c : difference) { com.google.gerrit.reviewdb.client.Change.Id id = c.change().getId(); bu.addOp(id, new com.google.gerrit.server.git.strategy.ImplicitIntegrateOp(args, c)); maybeAddTestHelperOp(bu, id); } for (com.google.gerrit.server.git.strategy.SubmitStrategyOp op : ops) { bu.addOp(op.getId(), op); maybeAddTestHelperOp(bu, op.getId()); } }
public java.util.List<com.google.gerrit.server.update.BatchUpdate> batchUpdates(java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> projects) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { java.util.List<com.google.gerrit.server.update.BatchUpdate> updates = new java.util.ArrayList(projects.size()); for (com.google.gerrit.reviewdb.client.Project.NameKey project : projects) { updates.add(getRepo(project).getUpdate().setRefLogMessage("merged")); } return updates; }
private void assertSubmittedTogether(java.lang.String changeId, java.lang.Iterable<java.lang.String> expected) throws java.lang.Exception { assertThat(gApi.changes().id(changeId).submittedTogether().stream().map(( i) -> i.changeId)).containsExactlyElementsIn(expected); }
public final org.eclipse.jgit.notes.NoteMap commitNewNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws java.io.IOException { this.overwrite = false; commitNotes(notes, notesBranch, commitAuthor, commitMessage); org.eclipse.jgit.notes.NoteMap newlyCreated = org.eclipse.jgit.notes.NoteMap.newEmptyMap(); for (org.eclipse.jgit.notes.Note n : notes) { if (((base) == null) || (!(base.contains(n)))) { newlyCreated.set(n, n.getData()); } } return newlyCreated; }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } try { com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } catch (com.google.gerrit.common.errors.PermissionDeniedException e) { throw new com.google.gerrit.extensions.restapi.AuthException(e.getMessage()); } } return r; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectControl), input); printCommits(r.newlyBanned, "The following commits were banned"); printCommits(r.alreadyBanned, "The following commits were already banned"); printCommits(r.ignored, "The following ids do not represent commits and were ignored"); } catch (java.lang.Exception e) { throw die(e); } }
public final void commitAllNotes(org.eclipse.jgit.notes.NoteMap notes, java.lang.String notesBranch, org.eclipse.jgit.lib.PersonIdent commitAuthor, java.lang.String commitMessage) throws java.io.IOException { this.overwrite = true; commitNotes(notes, notesBranch, commitAuthor, commitMessage); }
void setMessage(java.lang.String message) throws com.google.gerrit.extensions.restapi.RestApiException;
private static void ensureChangeIdIsCorrect(boolean requireChangeId, java.lang.String currentChangeId, java.lang.String newCommitMessage) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException { org.eclipse.jgit.revwalk.RevCommit revCommit = org.eclipse.jgit.revwalk.RevCommit.parse(org.eclipse.jgit.lib.Constants.encode(((("tree " + (org.eclipse.jgit.lib.ObjectId.zeroId().name())) + "\n\n") + newCommitMessage))); com.google.gerrit.server.util.CommitMessageUtil.checkAndSanitizeCommitMessage(revCommit.getShortMessage()); java.util.List<java.lang.String> changeIdFooters = revCommit.getFooterLines(FooterConstants.CHANGE_ID); if (requireChangeId && (changeIdFooters.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("missing Change-Id footer"); } if ((!(changeIdFooters.isEmpty())) && (!(changeIdFooters.get(0).equals(currentChangeId)))) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("wrong Change-Id footer"); } if ((changeIdFooters.size()) > 1) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("multiple Change-Id footers"); } }
private void ensureCanEditCommitMessage(com.google.gerrit.server.notedb.ChangeNotes changeNotes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { if (!(currentUserProvider.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } try { permissionBackend.user(currentUserProvider.get()).database(db.get()).change(changeNotes).check(ChangePermission.ADD_PATCH_SET); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("modifying commit message not permitted", denied); } }
@java.lang.Override public void setMessage(java.lang.String message) { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
@java.lang.Override public void setMessage(java.lang.String in) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.change.PutMessage.Input input = new com.google.gerrit.server.change.PutMessage.Input(); input.message = in; putMessage.apply(change, input); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot edit commit message", e); } }
public boolean doCanForDefaultPermissionBackend(com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { if (perm instanceof com.google.gerrit.server.permissions.GlobalPermission) { return can(((com.google.gerrit.server.permissions.GlobalPermission) (perm))); } else if (perm instanceof com.google.gerrit.extensions.api.access.PluginPermission) { com.google.gerrit.extensions.api.access.PluginPermission pluginPermission = ((com.google.gerrit.extensions.api.access.PluginPermission) (perm)); return (canPerform(pluginPermission.permissionName())) || ((pluginPermission.fallBackToAdmin()) && (isAdmin())); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private java.util.concurrent.ScheduledThreadPoolExecutor getExecutor() { com.google.gerrit.server.git.QueueProvider.QueueType qt = capabilityFactory.create(user.get()).getQueueType(); return queue.getQueue(qt); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for review"); } if ((change.getStatus()) != (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { if (workInProgress) { return; } email.create(NotifyHandling.ALL, com.google.common.collect.ImmutableListMultimap.of(), notes, ps, ctx.getIdentifiedUser(), cmsg, com.google.common.collect.ImmutableList.of(), cmsg.getMessage(), com.google.common.collect.ImmutableList.of()).sendAsync(); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); notes = ctx.getNotes(); ps = psUtil.get(ctx.getDb(), ctx.getNotes(), change.currentPatchSetId()); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); change.setWorkInProgress(workInProgress); if ((!(change.hasReviewStarted())) && (!(workInProgress))) { change.setReviewStarted(true); } change.setLastUpdatedOn(ctx.getWhen()); update.setWorkInProgress(workInProgress); addMessage(ctx, update); return true; }
private void startReview(com.google.gerrit.acceptance.server.mail.StagedChange sc) throws java.lang.Exception { setApiUser(sc.owner); gApi.changes().id(sc.changeId).setReadyForReview(); gApi.changes().id(sc.changeId).revision("current").review(com.google.gerrit.extensions.api.changes.ReviewInput.noScore()); }
protected com.google.gerrit.acceptance.StandaloneSiteTest.ServerContext startServer() throws java.lang.Exception { return new com.google.gerrit.acceptance.StandaloneSiteTest.ServerContext(startImpl()); }
@org.junit.Test public void migrationDoesNotRequireIndex() throws java.lang.Exception { assertNotesMigrationState(NotesMigrationState.REVIEW_DB); setUpOneChange(); int version = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion(); com.google.gerrit.server.index.GerritIndexStatus status = new com.google.gerrit.server.index.GerritIndexStatus(sitePaths); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isTrue(); status.setReady(ChangeSchemaDefinitions.NAME, version, false); status.save(); migrate("--trial", "false"); assertNotesMigrationState(NotesMigrationState.NOTE_DB_UNFUSED); status = new com.google.gerrit.server.index.GerritIndexStatus(sitePaths); assertThat(status.getReady(ChangeSchemaDefinitions.NAME, version)).isFalse(); assertServerStartupFails(); }
@org.junit.Test public void enableSequencesWithGap() throws java.lang.Exception { testEnableSequences((-1), 502, "512"); }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator build() throws com.google.gerrit.server.notedb.rebuild.MigrationException { return new com.google.gerrit.server.notedb.rebuild.NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, rebuilder, globalNotesMigration, ((threads) > 1 ? com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService()), projects, changes, progressOut, stopAtState, trial, forceRebuild, ((sequenceGap) >= 0 ? sequenceGap : com.google.gerrit.server.Sequences.getChangeSequenceGap(cfg))); }
private static com.google.gerrit.acceptance.GerritServer startOnDisk(com.google.gerrit.acceptance.GerritServer.Description desc, java.nio.file.Path site, com.google.gerrit.pgm.Daemon daemon, java.util.concurrent.CyclicBarrier serverStarted) throws java.lang.Exception { checkNotNull(site); java.util.concurrent.ExecutorService daemonService = java.util.concurrent.Executors.newSingleThreadExecutor(); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = daemonService.submit(() -> { int rc = daemon.main(new java.lang.String[]{ "-d", site.toString(), "--headless", "--console-log", "--show-stack-trace" }); if (rc != 0) { java.lang.System.err.println("Failed to start Gerrit daemon"); serverStarted.reset(); } return null; }); try { serverStarted.await(); } catch (java.util.concurrent.BrokenBarrierException e) { daemon.stop(); throw new com.google.gerrit.acceptance.GerritServer.StartupException("Failed to start Gerrit daemon; see log", e); } java.lang.System.out.println("Gerrit Server Started"); return new com.google.gerrit.acceptance.GerritServer(desc, com.google.gerrit.acceptance.GerritServer.createTestInjector(daemon), daemon, daemonService); }
private com.google.gerrit.server.notedb.NotesMigrationState enableSequences(com.google.gerrit.server.notedb.NotesMigrationState prev) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { @java.lang.SuppressWarnings("deprecation") com.google.gerrit.server.notedb.RepoSequence seq = new com.google.gerrit.server.notedb.RepoSequence(repoManager, allProjects, com.google.gerrit.server.Sequences.CHANGES, () -> ((db.nextChangeId()) + (sequenceGap)) - 1, 1); seq.next(); } return saveState(prev, com.google.gerrit.server.notedb.NotesMigrationState.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); }
public com.google.gerrit.server.notedb.rebuild.NoteDbMigrator.Builder setSequenceGap(int sequenceGap) { this.sequenceGap = sequenceGap; return this; }
@org.junit.Test public void preconditionsFail() throws java.lang.Exception { java.util.List<com.google.gerrit.reviewdb.client.Change.Id> cs = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Change.Id(1)); java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> ps = com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.Project.NameKey("p")); assertMigrationException("Cannot rebuild without noteDb.changes.write=true", ( b) -> b, NoteDbMigrator::rebuild); assertMigrationException("Cannot set both changes and projects", ( b) -> b.setChanges(cs).setProjects(ps), ( m) -> { }); assertMigrationException("Cannot set changes or projects during auto-migration", ( b) -> b.setChanges(cs), NoteDbMigrator::migrate); assertMigrationException("Cannot set changes or projects during auto-migration", ( b) -> b.setProjects(ps), NoteDbMigrator::migrate); setNotesMigrationState(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", ( b) -> b.setTrialMode(true), NoteDbMigrator::migrate); setNotesMigrationState(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY); assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", ( b) -> b.setForceRebuild(true), NoteDbMigrator::migrate); }
protected void assertServerStartupFails() throws java.lang.Exception { try (com.google.gerrit.acceptance.GerritServer server = startImpl()) { fail("expected server startup to fail"); } catch (com.google.gerrit.acceptance.GerritServer e) { } }
private com.google.gerrit.acceptance.GerritServer startImpl() throws java.lang.Exception { return com.google.gerrit.acceptance.GerritServer.start(serverDesc, baseConfig, sitePaths.site_path); }
private void testEnableSequences(int builderOption, int expectedFirstId, java.lang.String expectedRefValue) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); assertThat(id.get()).isEqualTo(1); migrate(( b) -> b.setSequenceGap(builderOption).setStopAtStateForTesting(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY)); assertThat(sequences.nextChangeId()).isEqualTo(expectedFirstId); assertThat(sequences.nextChangeId()).isEqualTo((expectedFirstId + 1)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allProjects);org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader()) { org.eclipse.jgit.lib.Ref ref = repo.exactRef("refs/sequences/changes"); assertThat(ref).isNotNull(); org.eclipse.jgit.lib.ObjectLoader loader = reader.open(ref.getObjectId()); assertThat(loader.getType()).isEqualTo(Constants.OBJ_BLOB); assertThat(new java.lang.String(loader.getCachedBytes(), java.nio.charset.StandardCharsets.UTF_8)).isEqualTo(expectedRefValue); } try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { @java.lang.SuppressWarnings("deprecation") int nextFromReviewDb = db.nextChangeId(); assertThat(nextFromReviewDb).isEqualTo(3); } }
@org.junit.Test public void enableSequencesNoGap() throws java.lang.Exception { testEnableSequences(0, 2, "12"); }
@java.lang.Override public synchronized void stop() { if ((ds) instanceof org.apache.commons.dbcp.BasicDataSource) { try { ((org.apache.commons.dbcp.BasicDataSource) (ds)).close(); } catch (java.sql.SQLException e) { } } }
@java.lang.Override public void onTimeout(org.eclipse.jetty.continuation.Continuation self) { future.cancel(true); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); reject(cmd, "invalid object"); return; } logDebug("Creating {}", cmd); if ((com.google.gerrit.server.git.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); java.lang.String rejectReason = ctl.canCreate(rp.getRepository(), obj); if (rejectReason != null) { reject(cmd, ("prohibited by Gerrit: " + rejectReason)); return; } if (!(validRefOperation(cmd))) { return; } validateNewCommits(ctl, cmd); actualCommands.add(cmd); }
@com.google.gerrit.common.Nullable private java.lang.String canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { if (canUpdate()) { return null; } else if (isMergedIntoBranchOrTag(repo, commit)) { return null; } return ("lacks permission " + (com.google.gerrit.common.data.Permission.PUSH)) + " for creating new commit object"; }
@org.junit.Test public void shouldBlockCreationIfGroupRefIsNotUsed() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); com.google.gerrit.extensions.api.groups.GroupApi dGroup = gApi.groups().create(delegatingGroup); dGroup.addMembers(user.username); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); cfg.getPluginConfig(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidatorIT.PLUGIN_NAME).setString(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, delegatingGroup); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }
@org.junit.Test public void shouldBlockCreationIfDelegatingGroupDoesNotExist() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); java.lang.String gId = "fake-gId"; cfg.getPluginConfig(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidatorIT.PLUGIN_NAME).setGroupReference(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, new com.google.gerrit.common.data.GroupReference(AccountGroup.UUID.parse(gId), delegatingGroup)); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }
@org.junit.Test public void shouldBlockCreationIfUserIsNotInDelegatingGroup() throws java.lang.Exception { java.lang.String ownerGroup = name("groupA"); gApi.groups().create(ownerGroup); java.lang.String parent = name("parentProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.permissionsOnly = true; in.owners = com.google.common.collect.Lists.newArrayList(ownerGroup); adminRestSession.put(("/projects/" + parent), in).assertCreated(); in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.parent = parent; com.google.gerrit.acceptance.RestResponse r = userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in); r.assertConflict(); assertThat(r.getEntityContent()).contains("You must be owner of the parent project"); java.lang.String delegatingGroup = name("groupB"); gApi.groups().create(delegatingGroup); com.google.gerrit.reviewdb.client.Project.NameKey parentNameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(parent); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(parentNameKey).getConfig(); java.lang.String gId = gApi.groups().id(delegatingGroup).get().id; cfg.getPluginConfig(com.ericsson.gerrit.plugins.projectgroupstructure.ProjectCreationValidatorIT.PLUGIN_NAME).setGroupReference(ProjectCreationValidator.DELEGATE_PROJECT_CREATION_TO, new com.google.gerrit.common.data.GroupReference(AccountGroup.UUID.parse(gId), delegatingGroup)); saveProjectConfig(parentNameKey, cfg); userRestSession.put(("/projects/" + (com.google.gerrit.extensions.restapi.Url.encode((parent + "/childProject")))), in).assertConflict(); }
@java.lang.Override protected void run() throws com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure { if ((localDiskRepositoryManager) == null) { throw new com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure(1, "Command only works with disk based repository managers"); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(projectName); if ((projectCache.get(nameKey)) != null) { stdout.println(localDiskRepositoryManager.getBasePath(nameKey).resolve(nameKey.get().concat(Constants.DOT_GIT_EXT))); } else { throw new com.googlesource.gerrit.plugins.adminconsole.UnloggedFailure(1, "Repository not found"); } }
private synchronized void finish(com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt a, java.util.List<com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt> out) { checkState(((readyToStart.getCount()) == 0), "shouldn't be finishing upgrade before starting"); checkState(((finished.getCount()) > 0), "already finished %s upgrades, can't finish %s", numExpected, a); out.add(a); finished.countDown(); }
@java.lang.Override public void configure() { bind(com.google.gerrit.server.index.VersionManager.class).to(com.google.gerrit.elasticsearch.ElasticVersionManager.class); listener().to(com.google.gerrit.elasticsearch.ElasticVersionManager.class); if (onlineUpgrade) { listener().to(com.google.gerrit.server.index.OnlineUpgrader.class); } }
@java.lang.Override public synchronized void onStart(java.lang.String name, int oldVersion, int newVersion) { com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt a = com.google.gerrit.acceptance.pgm.ReindexIT.UpgradeAttempt.create(name, oldVersion, newVersion); try { readyToStart.await(); } catch (java.lang.InterruptedException e) { throw new java.lang.AssertionError(("interrupted waiting to start " + a), e); } checkState(((started.getCount()) > 0), "already started %s upgrades, can't start %s", numExpected, a); startedAttempts.add(a); started.countDown(); }
void runUpgrades() throws java.lang.Exception { readyToStart.countDown(); int timeoutSec = 60; if (!(started.await(timeoutSec, java.util.concurrent.TimeUnit.SECONDS))) { assert_().fail("%s/%s online upgrades started after %ss", ((numExpected) - (started.getCount())), numExpected, timeoutSec); } finished.await(); }
private void assertReady(int expectedReady) throws java.lang.Exception { java.util.Set<java.lang.Integer> allVersions = ChangeSchemaDefinitions.INSTANCE.getSchemas().keySet(); com.google.gerrit.server.index.GerritIndexStatus status = new com.google.gerrit.server.index.GerritIndexStatus(sitePaths); assertThat(allVersions.stream().collect(toImmutableMap(( v) -> v, ( v) -> status.getReady(com.google.gerrit.acceptance.pgm.ReindexIT.CHANGES, v)))).named("ready state for index versions").isEqualTo(allVersions.stream().collect(toImmutableMap(( v) -> v, ( v) -> v == expectedReady))); }
@java.lang.Override public void configure() { bind(com.google.gerrit.server.index.VersionManager.class).to(com.google.gerrit.lucene.LuceneVersionManager.class); listener().to(com.google.gerrit.lucene.LuceneVersionManager.class); if (onlineUpgrade) { listener().to(com.google.gerrit.server.index.OnlineUpgrader.class); } }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { for (com.google.gerrit.reviewdb.client.Account account : scanAccounts(db)) { updateAccountInNoteDb(repo, account); } } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Migrating accounts to NoteDb failed", e); } }
private void updateAccountInNoteDb(org.eclipse.jgit.lib.Repository allUsersRepo, com.google.gerrit.reviewdb.client.Account account) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo); org.eclipse.jgit.lib.PersonIdent ident = serverIdent.get(); md.getCommitBuilder().setAuthor(ident); md.getCommitBuilder().setCommitter(ident); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(null, account.getId()); accountConfig.load(allUsersRepo); accountConfig.setAccount(account); accountConfig.commit(md); }
private org.eclipse.jgit.lib.ObjectId getAccountConfigBlobId(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(id); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(rw.getObjectReader(), AccountConfig.ACCOUNT_CONFIG, commit.getTree())) { return tw != null ? tw.getObjectId(0) : null; } }
public com.google.gerrit.reviewdb.client.Account get(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (readFromGit) { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return read(repo, accountId); } } return db.accounts().get(accountId); }
public java.util.List<com.google.gerrit.reviewdb.client.Account> all(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (readFromGit) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds = allIds(); java.util.List<com.google.gerrit.reviewdb.client.Account> accounts = new java.util.ArrayList(accountIds.size()); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { try { accounts.add(read(repo, accountId)); } catch (java.lang.Exception e) { com.google.gerrit.server.account.Accounts.log.error(java.lang.String.format("Ignoring invalid account %s", accountId.get()), e); } } } return accounts; } return db.accounts().all().toList(); }
private com.google.gerrit.reviewdb.client.Account read(org.eclipse.jgit.lib.Repository allUsersRepository, com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(emailValidator, accountId); accountConfig.load(allUsersRepository); return accountConfig.getAccount(); }
public java.util.List<com.google.gerrit.reviewdb.client.Account> get(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (readFromGit) { java.util.List<com.google.gerrit.reviewdb.client.Account> accounts = new java.util.ArrayList(accountIds.size()); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { accounts.add(read(repo, accountId)); } } return accounts; } return db.accounts().get(accountIds).toList(); }
@org.junit.Test public void pushAccountConfigToUserBranchIsRejected() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, ((com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)) + ":userRef")); allUsersRepo.reset("userRef"); org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, "OOO"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(RefNames.REFS_USERS_SELF); r.assertErrorStatus("account update not allowed"); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if ((revision) != null) { commit.setMessage("Update account\n"); } else if ((account) != null) { commit.setMessage("Create account\n"); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); commit.setCommitter(new org.eclipse.jgit.lib.PersonIdent(commit.getCommitter(), registeredOn)); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); com.google.gerrit.server.account.AccountConfig.setActive(cfg, account.isActive()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_FULL_NAME, account.getFullName()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_PREFERRED_EMAIL, account.getPreferredEmail()); com.google.gerrit.server.account.AccountConfig.set(cfg, com.google.gerrit.server.account.AccountConfig.KEY_STATUS, account.getStatus()); saveConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); return true; }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRef(receiveEvent.refName); if (accountId == null) { return java.util.Collections.emptyList(); } try { org.eclipse.jgit.lib.ObjectId newBlobId = getAccountConfigBlobId(receiveEvent.revWalk, receiveEvent.commit); org.eclipse.jgit.lib.ObjectId oldId = receiveEvent.command.getOldId(); org.eclipse.jgit.lib.ObjectId oldBlobId = (!(org.eclipse.jgit.lib.ObjectId.zeroId().equals(oldId))) ? getAccountConfigBlobId(receiveEvent.revWalk, oldId) : null; if (!(java.util.Objects.equals(oldBlobId, newBlobId))) { throw new com.google.gerrit.server.git.validators.CommitValidationException("account update not allowed"); } } catch (java.io.IOException e) { java.lang.String m = java.lang.String.format("Validating update for account %s failed", accountId.get()); com.google.gerrit.server.git.validators.CommitValidators.log.error(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } return java.util.Collections.emptyList(); }
private com.google.gerrit.reviewdb.client.Account parse(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, registeredOn); account.setActive(cfg.getBoolean(com.google.gerrit.server.account.AccountConfig.ACCOUNT, null, com.google.gerrit.server.account.AccountConfig.KEY_ACTIVE, true)); account.setFullName(com.google.gerrit.server.account.AccountConfig.get(cfg, com.google.gerrit.server.account.AccountConfig.KEY_FULL_NAME)); java.lang.String preferredEmail = com.google.gerrit.server.account.AccountConfig.get(cfg, com.google.gerrit.server.account.AccountConfig.KEY_PREFERRED_EMAIL); account.setPreferredEmail(preferredEmail); if (((emailValidator) != null) && (!(emailValidator.isValid(preferredEmail)))) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, java.lang.String.format("Invalid preferred email: %s", preferredEmail))); } account.setStatus(com.google.gerrit.server.account.AccountConfig.get(cfg, com.google.gerrit.server.account.AccountConfig.KEY_STATUS)); return account; }
public void renderToHtml(com.google.gitiles.doc.html.HtmlBuilder out, org.commonmark.node.Node node) { if (node != null) { html = out; toc = new com.google.gitiles.doc.TocFormatter(html, 3); toc.setRoot(node); node.accept(this); html.finish(); html = null; toc = null; } }
public int getEffectiveMaxBatchChangesLimit(com.google.gerrit.server.CurrentUser user) { com.google.gerrit.server.account.AccountLimits limits = limitsFactory.create(user); if (limits.hasExplicitRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT)) { return limits.getRange(com.google.gerrit.server.git.BATCH_CHANGES_LIMIT).getMax(); } return systemMaxBatchChanges; }
private void addRanges(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.AccountLimits limits) { for (java.lang.String name : com.google.gerrit.common.data.GlobalCapability.getRangeNames()) { if ((want(name)) && (limits.hasExplicitRange(name))) { have.put(name, new com.google.gerrit.server.account.GetCapabilities.Range(limits.getRange(name))); } } }
private void addPriority(java.util.Map<java.lang.String, java.lang.Object> have, com.google.gerrit.server.account.AccountLimits limits) { com.google.gerrit.server.git.QueueProvider.QueueType queue = limits.getQueueType(); if ((queue != (QueueProvider.QueueType.INTERACTIVE)) || (((query) != null) && (query.contains(com.google.gerrit.server.account.PRIORITY)))) { have.put(com.google.gerrit.server.account.PRIORITY, queue); } }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(self); if ((self.get()) != (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : perm.test(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.AccountLimits limits = limitsFactory.create(rsrc.getUser()); addRanges(have, limits); addPriority(have, limits); return OutputFormat.JSON.newGson().toJsonTree(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic() ? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getControl(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
private void grantApprove(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, boolean exclusive) throws java.lang.Exception { grantLabel("Code-Review", (-2), 2, project, "refs/heads/*", false, groupUUID, exclusive); }
@org.junit.Test public void testChangeOwner_BlockedOnParentProject() throws java.lang.Exception { setApiUser(admin); blockApproveForChangeOwner(project); com.google.gerrit.reviewdb.client.Project.NameKey child = createProject("child", project); setApiUser(user); grantApproveToAll(child); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> childRepo = cloneProject(child, user); java.lang.String changeId = createMyChange(childRepo); assertApproveFails(user, changeId); approve(user2, changeId); }
protected void grantLabel(java.lang.String label, int min, int max, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, boolean force, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, boolean exclusive) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.RepositoryNotFoundException { java.lang.String permission = (com.google.gerrit.common.data.Permission.LABEL) + label; try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { md.setMessage(java.lang.String.format("Grant %s on %s", permission, ref)); com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.AccessSection s = config.getAccessSection(ref, true); com.google.gerrit.common.data.Permission p = s.getPermission(permission, true); p.setExclusiveGroup(exclusive); com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.newRule(config, groupUUID); rule.setForce(force); rule.setMin(min); rule.setMax(max); p.add(rule); config.commit(md); projectCache.evict(config.getProject()); } }
protected void blockLabel(java.lang.String label, int min, int max, com.google.gerrit.reviewdb.client.AccountGroup.UUID id, java.lang.String ref, com.google.gerrit.reviewdb.client.Project.NameKey project) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.server.project.Util.block(cfg, ((com.google.gerrit.common.data.Permission.LABEL) + label), min, max, id, ref); saveProjectConfig(project, cfg); }
@org.junit.Test public void testChangeOwner_BlockedOnParentProjectAndExclusiveAllowOnChild() throws java.lang.Exception { setApiUser(admin); blockApproveForChangeOwner(project); com.google.gerrit.reviewdb.client.Project.NameKey child = createProject("child", project); setApiUser(user); grantExclusiveApproveToAll(child); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> childRepo = cloneProject(child, user); java.lang.String changeId = createMyChange(childRepo); assertApproveFails(user, changeId); approve(user2, changeId); }
void populate(int row, com.google.gerrit.client.projects.TagInfo k) { if (k.canDelete()) { com.google.gwt.user.client.ui.CheckBox sel = new com.google.gwt.user.client.ui.CheckBox(); sel.addValueChangeHandler(updateDeleteHandler); table.setWidget(row, 1, sel); canDelete = true; } else { table.setText(row, 1, ""); } table.setWidget(row, 2, new com.google.gwt.user.client.ui.InlineHTML(highlight(k.getShortName(), match))); if ((k.revision()) != null) { table.setText(row, 3, k.revision()); } else { table.setText(row, 3, ""); } com.google.gwt.user.client.ui.FlowPanel actionsPanel = new com.google.gwt.user.client.ui.FlowPanel(); if ((k.webLinks()) != null) { for (com.google.gerrit.client.info.WebLinkInfo webLink : com.google.gerrit.client.rpc.Natives.asList(k.webLinks())) { actionsPanel.add(webLink.toAnchor()); } } table.setWidget(row, 4, actionsPanel); com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter(); java.lang.String iconCellStyle = Gerrit.RESOURCES.css().iconCell(); java.lang.String dataCellStyle = Gerrit.RESOURCES.css().dataCell(); fmt.addStyleName(row, 1, iconCellStyle); fmt.addStyleName(row, 2, dataCellStyle); fmt.addStyleName(row, 3, dataCellStyle); fmt.addStyleName(row, 4, dataCellStyle); setRowItem(row, k); }
private java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> visibleTags(com.google.gerrit.server.project.ProjectControl pctl, org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> tags) { return new com.google.gerrit.server.git.VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, pctl, dbProvider.get(), false).filter(tags, true); }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.RefControl control, com.google.gerrit.server.project.ProjectControl pctl, com.google.gerrit.server.WebLinks links) throws java.io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(pctl.getProject().getName(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (tagger != null ? com.google.gerrit.server.CommonConverters.toGitPerson(tag.getTaggerIdent()) : null), control.canDelete(), (webLinks.isEmpty() ? null : webLinks)); } return new com.google.gerrit.extensions.api.projects.TagInfo(ref.getName(), ref.getObjectId().getName(), control.canDelete(), (webLinks.isEmpty() ? null : webLinks)); }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); com.google.gerrit.server.project.ProjectControl pctl = resource.getControl(); if ((ref != null) && (!(visibleTags(pctl, repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty()))) { return com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, pctl.controlForRef(ref.getName()), pctl, links); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.project.ProjectControl pctl = resource.getControl(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(pctl, repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(ref, rw, pctl.controlForRef(ref.getName()), pctl, links)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.lib.Constants.R_TAGS).start(start).limit(limit).subString(matchSubstring).regex(matchRegex).filter(tags); }
private int reindexAccounts() throws java.lang.Exception { monitor.beginTask("Reindex accounts", ProgressMonitor.UNKNOWN); java.lang.String[] reindexArgs = new java.lang.String[]{ "--site-path", getSitePath().toString(), "--index", com.google.gerrit.server.index.account.AccountSchemaDefinitions.NAME }; java.lang.System.out.println("Migration complete, reindexing accounts with:"); java.lang.System.out.println((" reindex " + (java.lang.String.join(" ", reindexArgs)))); com.google.gerrit.pgm.Reindex reindexPgm = new com.google.gerrit.pgm.Reindex(); int exitCode = reindexPgm.main(reindexArgs); monitor.endTask(); return exitCode; }
protected void allow(com.google.gerrit.reviewdb.client.Project.NameKey p, java.lang.String ref, java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, permission, id, ref); saveProjectConfig(p, cfg); }
private java.util.List<java.lang.String> lsRemote(com.google.gerrit.reviewdb.client.Project.NameKey p, com.google.gerrit.acceptance.TestAccount a) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<?> testRepository = cloneProject(p, a); try (org.eclipse.jgit.api.Git git = testRepository.git()) { return git.lsRemote().call().stream().map(Ref::getName).collect(java.util.stream.Collectors.toList()); } }
static java.lang.String skipShardedRefPart(java.lang.String name) { if (name == null) { return null; } java.lang.String[] parts = name.split("/"); int n = parts.length; if (n < 2) { return null; } int le; for (le = 0; le < (parts[0].length()); le++) { if (!(java.lang.Character.isDigit(parts[0].charAt(le)))) { return null; } } if (le != 2) { return null; } int ie; for (ie = 0; ie < (parts[1].length()); ie++) { if (!(java.lang.Character.isDigit(parts[1].charAt(ie)))) { if (ie == 0) { return null; } break; } } int shard = java.lang.Integer.parseInt(parts[0]); int id = java.lang.Integer.parseInt(parts[1].substring(0, ie)); if ((id % 100) != shard) { return null; } return name.substring(((2 + 1) + ie)); }
static java.lang.Integer parseAfterShardedRefPart(java.lang.String name) { java.lang.String rest = com.google.gerrit.reviewdb.client.RefNames.skipShardedRefPart(name); if ((rest == null) || (!(rest.startsWith("/")))) { return null; } rest = rest.substring(1); int ie; for (ie = 0; ie < (rest.length()); ie++) { if (!(java.lang.Character.isDigit(rest.charAt(ie)))) { break; } } if (ie == 0) { return null; } return java.lang.Integer.parseInt(rest.substring(0, ie)); }
protected void allow(java.lang.String ref, java.lang.String permission, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws java.lang.Exception { allow(project, ref, permission, id); }
@org.junit.Test public void advertisedReferencesOmitStarredChangesRefsOfOtherUsers() throws java.lang.Exception { assume().that(notesMigration.commitChangeWrites()).isTrue(); allow(project, "refs/*", Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); allow(allUsersName, "refs/*", Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); setApiUser(user); gApi.accounts().self().starChange(c3.getId().toString()); java.lang.String starredChangesRef = com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(c3.getId(), user.id); assertThat(lsRemote(allUsersName, user)).contains(starredChangesRef); assertThat(lsRemote(allUsersName, accountCreator.user2())).doesNotContain(starredChangesRef); }
@org.junit.Test public void advertisedReferencesOmitDraftCommentRefsOfOtherUsers() throws java.lang.Exception { assume().that(notesMigration.commitChangeWrites()).isTrue(); allow(project, "refs/*", Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); allow(allUsersName, "refs/*", Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); setApiUser(user); com.google.gerrit.extensions.api.changes.DraftInput draftInput = new com.google.gerrit.extensions.api.changes.DraftInput(); draftInput.line = 1; draftInput.message = "nit: trailing whitespace"; draftInput.path = com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG; gApi.changes().id(c3.getId().get()).current().createDraft(draftInput); java.lang.String draftCommentRef = com.google.gerrit.reviewdb.client.RefNames.refsDraftComments(c3.getId(), user.id); assertThat(lsRemote(allUsersName, user)).contains(draftCommentRef); assertThat(lsRemote(allUsersName, accountCreator.user2())).doesNotContain(draftCommentRef); }
public void load(org.eclipse.jgit.revwalk.RevWalk walk, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { this.rw = walk; this.reader = walk.getObjectReader(); try { revision = (id != null) ? walk.parseCommit(id) : null; onLoad(); } finally { this.rw = null; this.reader = null; } }
@java.lang.Override public void visit(org.commonmark.node.Heading node) { outputNamedAnchor = false; java.lang.String tag = "h" + (node.getLevel()); html.open(tag); java.lang.String id = toc.idFromHeader(node); if (id != null) { html.open("a").attribute("class", "h").attribute("name", id).attribute("href", ("#" + id)).open("span").close("span").close("a"); html.open("a").attribute("class", "h").attribute("name", id.toLowerCase()).attribute("href", ("#" + (id.toLowerCase()))).open("span").close("span").close("a"); } visitChildren(node); html.close(tag); outputNamedAnchor = true; }
public java.util.Optional<com.google.gerrit.reviewdb.client.Comment> getDraft(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.reviewdb.client.Comment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { java.util.Optional<com.google.gerrit.reviewdb.client.Comment> c = getReviewDb(db, notes, key); if ((c.isPresent()) && (!(c.get().author.getId().equals(user.getAccountId())))) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Expected draft %s to belong to account %s, but it belongs to %s", key, user.getAccountId(), c.get().author.getId())); } return c; } return draftByChangeAuthor(db, notes, user.getAccountId()).stream().filter(( c) -> key.equals(c.key)).findFirst(); }
public java.util.Optional<com.google.gerrit.reviewdb.client.Comment> getPublished(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Comment.Key key) throws com.google.gwtorm.server.OrmException { if (!(migration.readChanges())) { return getReviewDb(db, notes, key); } return publishedByChange(db, notes).stream().filter(( c) -> key.equals(c.key)).findFirst(); }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.reviewdb.client.Comment> maybeComment = commentsUtil.getDraft(ctx.getDb(), ctx.getNotes(), ctx.getIdentifiedUser(), key); if (!(maybeComment.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("comment not found: " + (key))); } com.google.gerrit.reviewdb.client.Comment origComment = maybeComment.get(); comment = new com.google.gerrit.reviewdb.client.Comment(origComment); ctx.getUser().updateRealAccountId(comment::setRealAuthor); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(ctx.getChange().getId(), origComment.key.patchSetId); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(psId); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); if (ps == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("patch set not found: " + psId)); } if (((in.path) != null) && (!(in.path.equals(origComment.key.filename)))) { commentsUtil.deleteComments(ctx.getDb(), update, java.util.Collections.singleton(origComment)); comment.key.filename = in.path; } com.google.gerrit.server.CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), ps); commentsUtil.putComments(ctx.getDb(), update, Status.DRAFT, java.util.Collections.singleton(com.google.gerrit.server.change.PutDraftComment.update(comment, in, ctx.getWhen()))); ctx.dontBumpLastUpdatedOn(); return true; }
@org.junit.Test public void includesNavbar() throws java.lang.Exception { java.lang.String navbar = "# Site Title\n" + (("\n" + "* [Home](index.md)\n") + "* [README](README.md)\n"); repo.branch("master").commit().add("README.md", "# page\n\nof information.").add("navbar.md", navbar).create(); java.lang.String html = buildHtml("/repo/+doc/master/README.md"); assertThat(html).contains("<title>Site Title - page</title>"); assertThat(html).contains("<span class=\"Header-anchorTitle\">Site Title</span>"); assertThat(html).contains("<li><a href=\"/b/repo/+/master/index.md\">Home</a></li>"); assertThat(html).contains("<li><a href=\"/b/repo/+/master/README.md\">README</a></li>"); assertThat(html).contains("<h1><a class=\"h\" name=\"page\" href=\"#page\"><span></span></a>page</h1>"); }
void setMessage(com.google.gerrit.extensions.common.CommitMessageInput in) throws com.google.gerrit.extensions.restapi.RestApiException;
private void editCommitMessage(com.google.gerrit.acceptance.server.mail.StagedChange sc, com.google.gerrit.acceptance.TestAccount by, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.NotifyHandling notify, com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy emailStrategy) throws java.lang.Exception { setEmailStrategy(by, emailStrategy); com.google.gerrit.extensions.common.CommitInfo commit = gApi.changes().id(sc.changeId).revision("current").commit(false); com.google.gerrit.extensions.common.CommitMessageInput in = new com.google.gerrit.extensions.common.CommitMessageInput(); in.message = "update\n" + (commit.message); in.notify = notify; gApi.changes().id(sc.changeId).setMessage(in); }
@java.lang.Override public void setMessage(com.google.gerrit.extensions.common.CommitMessageInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { putMessage.apply(change, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot edit commit message", e); } }
@java.lang.Override public void setMessage(com.google.gerrit.extensions.common.CommitMessageInput in) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
@java.lang.Override public void setMessage(java.lang.String msg) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.CommitMessageInput in = new com.google.gerrit.extensions.common.CommitMessageInput(); in.message = msg; setMessage(in); }
private void assertUploadTag(com.google.gerrit.server.query.change.ChangeData cd, java.lang.String expectedTag) throws java.lang.Exception { java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> msgs = cd.messages(); assertThat(msgs).isNotEmpty(); assertThat(com.google.common.collect.Iterables.getLast(msgs).getTag()).isEqualTo(expectedTag); }
@org.junit.Test public void pushWorkInProgressChangeWhenNotOwner() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<?> userRepo = cloneProject(project, user); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%wip"); r.assertOkStatus(); assertThat(r.getChange().change().getOwner()).isEqualTo(user.id); assertThat(r.getChange().change().isWorkInProgress()).isTrue(); com.google.gerrit.acceptance.GitUtil.fetch(testRepo, ((r.getPatchSet().getRefName()) + ":ps")); testRepo.reset("ps"); r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo); r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP); r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo); r.assertOkStatus(); assertThat(r.getChange().change().isWorkInProgress()).isTrue(); r = pushFactory.create(db, user.getIdent(), userRepo).to("refs/for/master%ready"); r.assertOkStatus(); assertThat(r.getChange().change().isWorkInProgress()).isFalse(); com.google.gerrit.acceptance.GitUtil.fetch(testRepo, ((r.getPatchSet().getRefName()) + ":ps")); testRepo.reset("ps"); r = amendChange(r.getChangeId(), "refs/for/master%wip", admin, testRepo); r.assertErrorStatus(ReceiveCommits.ONLY_OWNER_CAN_MODIFY_WIP); r = amendChange(r.getChangeId(), "refs/for/master%ready", admin, testRepo); r.assertOkStatus(); }
@org.junit.Test public void reviewAndStartReview() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createWorkInProgressChange(); r.assertOkStatus(); assertThat(r.getChange().change().isWorkInProgress()).isTrue(); com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.noScore().setWorkInProgress(false); gApi.changes().id(r.getChangeId()).revision("current").review(in); com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().id(r.getChangeId()).get(); assertThat(info.workInProgress).isNull(); }
private java.util.List<java.lang.String> getChangeParents(int changeNumber, java.lang.String currentRevision) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.changes.ChangeApi change = gApi.changes().id(changeNumber); java.util.List<java.lang.String> parents = new java.util.ArrayList<>(); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisionMap = change.get(java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT)).revisions; java.util.List<com.google.gerrit.extensions.common.CommitInfo> changeParents = revisionMap.get(currentRevision).commit.parents; for (com.google.gerrit.extensions.common.CommitInfo commit : changeParents) { parents.add(commit.commit); } return parents; }
private java.lang.String getBaseChangeId(java.util.List<java.lang.String> parents, java.lang.String branch) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.InvalidQueryParameterException { if ((parents.size()) == 0) { com.googlesource.gerrit.plugins.automerger.DownstreamCreator.log.info("No base change id for change with no parents."); return null; } java.lang.String firstParentTopic = getTopic(parents.get(0)); if (firstParentTopic == null) { return null; } java.util.List<ChangeInfo> changesInTopic = getChangesInTopicAndBranch(firstParentTopic, branch); java.lang.String firstParent = parents.get(0); for (ChangeInfo change : changesInTopic) { java.util.List<com.google.gerrit.extensions.common.CommitInfo> topicChangeParents = change.revisions.get(change.currentRevision).commit.parents; if (((topicChangeParents.size()) > 1) && (topicChangeParents.get(1).commit.equals(firstParent))) { return java.lang.String.valueOf(change._number); } } return null; }
private java.lang.String getTopic(java.lang.String revision) throws com.google.gerrit.extensions.restapi.RestApiException, com.googlesource.gerrit.plugins.automerger.InvalidQueryParameterException { com.googlesource.gerrit.plugins.automerger.QueryBuilder queryBuilder = new com.googlesource.gerrit.plugins.automerger.QueryBuilder(); queryBuilder.addParameter("commit", revision); java.util.List<ChangeInfo> changes = gApi.changes().query(queryBuilder.get()).withOption(ListChangesOption.CURRENT_REVISION).get(); if ((changes.size()) > 0) { for (ChangeInfo change : changes) { if ((change.currentRevision.equals(revision)) && ((change.topic) != "")) { return change.topic; } } } return null; }
@java.lang.Override public java.lang.String getAuthorizationUrl() { java.lang.String url = service.getAuthorizationUrl(null); try { if ((domains.size()) == 1) { url += "&hd=" + (java.net.URLEncoder.encode(domains.get(0), java.nio.charset.StandardCharsets.UTF_8.name())); } else if ((domains.size()) > 1) { url += "&hd=*"; } } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.IllegalArgumentException(e); } if (com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.isDebugEnabled()) { com.googlesource.gerrit.plugins.oauth.GoogleOAuthService.log.debug("OAuth2: authorization URL={}", url); } return url; }
protected void assertRebase(org.eclipse.jgit.junit.TestRepository<?> testRepo, boolean contentMerge) throws java.lang.Exception { org.eclipse.jgit.lib.Repository repo = testRepo.getRepository(); org.eclipse.jgit.revwalk.RevCommit localHead = getHead(repo); org.eclipse.jgit.revwalk.RevCommit remoteHead = getRemoteHead(); assertThat(localHead.getId()).isNotEqualTo(remoteHead.getId()); assertThat(remoteHead.getParentCount()).isEqualTo(1); if (!contentMerge) { assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo)); } assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage()); }
private java.nio.file.Path resolvePath(javax.servlet.http.HttpServletRequest req) { return sitePaths.resolve(com.google.common.base.CharMatcher.is('/').trimLeadingFrom(((req.getServletPath()) + (req.getPathInfo())))); }
private static void setMissingHeader(java.util.Map<java.lang.String, com.google.gerrit.server.mail.send.EmailHeader> hdrs, java.lang.String name, java.lang.String value) { if ((!(hdrs.containsKey(name))) || (hdrs.get(name).isEmpty())) { hdrs.put(name, new com.google.gerrit.server.mail.send.EmailHeader.String(value)); } }
protected java.lang.String buildMultipartBody(java.lang.String boundary, java.lang.String textPart, java.lang.String htmlPart) throws java.io.IOException { java.lang.String encodedTextPart = quotedPrintableEncode(textPart); java.lang.String encodedHtmlPart = quotedPrintableEncode(htmlPart); java.lang.String textTransferEncoding = (textPart.equals(encodedTextPart)) ? "7bit" : "quoted-printable"; java.lang.String htmlTransferEncoding = (htmlPart.equals(encodedHtmlPart)) ? "7bit" : "quoted-printable"; return ((((((((((((((((((((("--" + boundary) + "\r\n") + "Content-Type: text/plain; charset=UTF-8\r\n") + "Content-Transfer-Encoding: ") + textTransferEncoding) + "\r\n") + "\r\n") + encodedTextPart) + "\r\n") + "--") + boundary) + "\r\n") + "Content-Type: text/html; charset=UTF-8\r\n") + "Content-Transfer-Encoding: ") + htmlTransferEncoding) + "\r\n") + "\r\n") + encodedHtmlPart) + "\r\n") + "--") + boundary) + "--\r\n"; }
protected java.lang.String quotedPrintableEncode(java.lang.String input) throws java.io.IOException { java.io.ByteArrayOutputStream s = new java.io.ByteArrayOutputStream(); try (org.apache.james.mime4j.codec.QuotedPrintableOutputStream qp = new org.apache.james.mime4j.codec.QuotedPrintableOutputStream(s, false)) { qp.write(input.getBytes(java.nio.charset.StandardCharsets.UTF_8)); } return s.toString(); }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.reviewdb.client.Project p) { com.google.gerrit.extensions.common.ProjectInfo info = new com.google.gerrit.extensions.common.ProjectInfo(); info.name = p.getName(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = p.getParent(allProjects); info.parent = (parentName != null) ? parentName.get() : null; info.description = com.google.common.base.Strings.emptyToNull(p.getDescription()); info.state = p.getState(); info.id = com.google.gerrit.extensions.restapi.Url.encode(info.name); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getProjectLinks(p.getName()); info.webLinks = (links.isEmpty()) ? null : links; return info; }
public com.google.gerrit.extensions.common.ProjectInfo format(com.google.gerrit.server.project.ProjectControl ctl) { com.google.gerrit.extensions.common.ProjectInfo info = format(ctl.getProject()); info.labels = new java.util.HashMap(); for (com.google.gerrit.common.data.LabelType t : ctl.getLabelTypes().getLabelTypes()) { com.google.gerrit.extensions.common.LabelTypeInfo labelInfo = new com.google.gerrit.extensions.common.LabelTypeInfo(); labelInfo.values = t.getValues().stream().collect(java.util.stream.Collectors.toMap(LabelValue::formatValue, LabelValue::getText)); labelInfo.defaultValue = t.getDefaultValue(); info.labels.put(t.getName(), labelInfo); } return info; }
public static com.google.gerrit.acceptance.GerritServer initAndStart(com.google.gerrit.acceptance.GerritServer.Description desc, org.eclipse.jgit.lib.Config baseConfig) throws java.lang.Exception { java.nio.file.Path site = com.google.gerrit.testutil.TempFileUtil.createTempDirectory().toPath(); baseConfig = new org.eclipse.jgit.lib.Config(baseConfig); baseConfig.setString("gerrit", null, "tempSiteDir", site.toString()); try { if (!(desc.memory())) { com.google.gerrit.acceptance.GerritServer.init(desc, baseConfig, site); } return com.google.gerrit.acceptance.GerritServer.start(desc, baseConfig, site, null); } catch (java.lang.Exception e) { com.google.gerrit.testutil.TempFileUtil.recursivelyDelete(site.toFile()); throw e; } }
public org.eclipse.jgit.lib.ObjectId loadRevision() throws com.google.gwtorm.server.OrmException { if (loaded) { return getRevision(); } else if (!(args.migration.readChanges())) { return null; } try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(getProjectName())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(getRefName()); return ref != null ? ref.getObjectId() : null; } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } }
@java.lang.SuppressWarnings("deprecation") private static int nextAccountId(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { return db.nextAccountId(); }
@com.google.gwtorm.server.Sequence(startWith = com.google.gerrit.reviewdb.server.ReviewDb.FIRST_ACCOUNT_ID) @java.lang.Deprecated int nextAccountId() throws com.google.gwtorm.server.OrmException;
public int nextAccountId(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { @java.lang.SuppressWarnings("deprecation") com.google.gerrit.server.notedb.RepoSequence.Seed accountSeed = () -> db.nextAccountId(); com.google.gerrit.server.notedb.RepoSequence accountSeq = new com.google.gerrit.server.notedb.RepoSequence(repoManager, new com.google.gerrit.reviewdb.client.Project.NameKey(allUsersName.get()), com.google.gerrit.server.Sequences.NAME_ACCOUNTS, accountSeed, 1); return accountSeq.next(); }
@java.lang.Override public com.google.gerrit.server.patch.PatchList get(com.google.gerrit.server.patch.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.patch.PatchListNotAvailableException { try { com.google.gerrit.server.patch.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if (pl instanceof com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone) { throw new com.google.gerrit.server.patch.PatchListNotAvailableException((("Error computing " + key) + ". Previous attempt failed with LargeObjectException")); } if ((key.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.patch.DiffSummaryKey.fromPatchListKey(key), com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { fileCache.put(key, new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone()); PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.patch.PatchListNotAvailableException(e); } throw e; } }
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException { if (!visible) { return cd.changeControl().getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((("Failed to get submit type for " + (cd.getId())) + ": ") + (str.errorMessage))); } return str.type; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, this).getSubmitType(); } return submitTypeRecord; }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { for (com.google.gerrit.common.data.PermissionRange pr : cd.changeControl().getLabelRanges()) { if (!(pr.isEmpty())) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at != null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps != null) { for (com.google.gerrit.common.data.SubmitRecord rec : new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord.Label label : rec.labels) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((!(out.approvals.containsKey(name))) && (type != null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec)); } return rec.type; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, changeDataFactory.create(db.get(), rsrc.getControl())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
private com.google.gerrit.rules.PrologEnvironment getPrologEnvironment(com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.server.project.RuleEvalException { com.google.gerrit.server.project.ProjectState projectState = control.getProjectControl().getProjectState(); com.google.gerrit.rules.PrologEnvironment env; try { if ((opts.rule()) == null) { env = projectState.newPrologEnvironment(); } else { env = projectState.newPrologEnvironment("stdin", new java.io.StringReader(opts.rule())); } } catch (com.googlecode.prolog_cafe.exceptions.CompileException err) { java.lang.String msg; if (((opts.rule()) == null) && (control.getProjectControl().isOwner())) { msg = java.lang.String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage()); } else if ((opts.rule()) != null) { msg = err.getMessage(); } else { msg = java.lang.String.format("Cannot load rules.pl for %s", getProjectName()); } throw new com.google.gerrit.server.project.RuleEvalException(msg, err); } env.set(StoredValues.ACCOUNTS, accounts); env.set(StoredValues.ACCOUNT_CACHE, accountCache); env.set(StoredValues.REVIEW_DB, cd.db()); env.set(StoredValues.CHANGE_DATA, cd); env.set(StoredValues.CHANGE_CONTROL, control); if (user != null) { env.set(StoredValues.CURRENT_USER, user); } return env; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, cd).setPatchSet(patchSet).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.auth = getAuthInfo(authConfig, realm); info.change = getChangeInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.defaultTheme = "/static/" + (SitePaths.THEME_FILENAME); } info.sshd = getSshdInfo(config); info.suggest = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getUrlAliasesInfo(config); info.urlAliases = (!(urlAliases.isEmpty())) ? urlAliases : null; info.user = getUserInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> display(@com.google.gerrit.common.Nullable java.io.PrintWriter stdout) { java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = com.google.common.collect.Lists.newArrayList(pluginLoader.getPlugins(all)); java.util.Collections.sort(plugins, new java.util.Comparator<com.google.gerrit.server.plugins.Plugin>() { @java.lang.Override public int compare(com.google.gerrit.server.plugins.Plugin a, com.google.gerrit.server.plugins.Plugin b) { return a.getName().compareTo(b.getName()); } }); if (!(format.isJson())) { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format("%-30s %-10s %-8s %s\n", p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return output; } else if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }
com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.server.account.externalids.ExternalId> byEmails(java.lang.String... emails) throws java.io.IOException;
public com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.server.account.externalids.ExternalId> byEmails(java.lang.String... emails) throws java.io.IOException { return externalIdCache.byEmails(emails); }
@java.lang.Override public com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.server.account.externalids.ExternalId> byEmails(java.lang.String... emails) throws java.io.IOException { throw new java.lang.UnsupportedOperationException(); }
public com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id> byEmails(java.lang.String... emails) throws java.io.IOException { return externalIds.byEmails(emails).entries().stream().collect(toImmutableSetMultimap(java.util.Map.Entry::getKey, ( e) -> e.getValue().accountId())); }
@org.junit.Test public void lookUpByEmail() throws java.lang.Exception { assertEmail(accounts.byEmail(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(accounts.byEmail(email), admin); assertThat(accounts.byEmail(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(accounts.byEmail(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(accounts.byEmail("non-existing@example.com")).isEmpty(); com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id> byEmails = accounts.byEmails(admin.email, user.email); assertEmail(byEmails.get(admin.email), admin); assertEmail(byEmails.get(user.email), user); }
default com.google.common.collect.ImmutableSet<com.google.gerrit.server.account.externalids.ExternalId> byEmail(java.lang.String email) throws java.io.IOException { return byEmails(email).get(email); }
@java.lang.Override public com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.server.account.externalids.ExternalId> byEmails(java.lang.String... emails) throws java.io.IOException { try { com.google.gerrit.server.account.externalids.ExternalIdCacheImpl.AllExternalIds allExternalIds = extIdsByAccount.get(externalIdReader.readRevision()); ImmutableSetMultimap.Builder<java.lang.String, com.google.gerrit.server.account.externalids.ExternalId> byEmails = com.google.common.collect.ImmutableSetMultimap.builder(); for (java.lang.String email : emails) { byEmails.putAll(email, allExternalIds.byEmail().get(email)); } return byEmails.build(); } catch (java.util.concurrent.ExecutionException e) { throw new java.io.IOException("Cannot list external ids by email", e); } }
void loadChangeInfo(boolean fg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(Project.NameKey.asStringOrNull(project), changeId.get()); java.util.EnumSet<com.google.gerrit.extensions.client.ListChangesOption> opts = java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS); if (enableSignedPush()) { opts.add(ListChangesOption.PUSH_CERTIFICATES); } com.google.gerrit.client.changes.ChangeList.addOptions(call, opts); if (!fg) { call.background(); } call.get(cb); }
public static void editWithFiles(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(project, id).addParameterTrue("list").get(cb); }
public static void comment(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String commentId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(project, id, "comments").id(commentId).get(cb); }
public static void detail(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.detail(project, id).get(cb); }
public static void updateDraft(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(project, id, "drafts").id(draftId).put(content, cb); }
public static void deleteDraft(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { CommentApi.revision(project, id, "drafts").id(draftId).delete(cb); }
public static void comments(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(project, id, "comments").get(cb); }
public static void createDraft(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.client.changes.CommentInfo content, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { com.google.gerrit.client.changes.CommentApi.revision(project, id, "drafts").put(content, cb); }
public static com.google.gerrit.client.rpc.RestApi revision(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String revision) { return ChangeApi.change(project, id).view("revisions").id(revision); }
public static com.google.gerrit.client.rpc.RestApi hashtag(@com.google.gerrit.common.Nullable java.lang.String project, int changeId, java.lang.String hashtag) { return com.google.gerrit.client.changes.ChangeApi.change(project, changeId).view("hashtags").id(hashtag); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getSideBySideDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toSideBySideDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toSideBySideDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); toSideBySideDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toSideBySide(getProject(), base, revision, path)); toSideBySideDiffLink.setTitle(PatchUtil.C.sideBySideDiff()); return java.util.Collections.singletonList(toSideBySideDiffLink); }
private static void onRemove(com.google.gwt.dom.client.NativeEvent event) { java.lang.String hashtags = com.google.gerrit.client.change.Hashtags.getDataId(event); if (hashtags != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.PatchSet.Id psId = screen.getPatchSetId(); com.google.gerrit.client.changes.ChangeApi.hashtags(screen.getProject().get(), psId.getParentKey().get()).post(com.google.gerrit.client.change.Hashtags.PostInput.create(null, hashtags), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getProject(), psId)); } } }); } }
private void addHashtag(java.lang.String hashtags) { com.google.gerrit.client.changes.ChangeApi.hashtags(project.get(), changeId.get()).post(com.google.gerrit.client.change.Hashtags.PostInput.create(hashtags, null), new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, psId.getParentKey(), java.lang.String.valueOf(psId.get()))); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gwt.user.client.ui.UIObject.setVisible(error, true); error.setInnerText((err instanceof com.google.gwt.user.client.rpc.StatusCodeException ? ((com.google.gwt.user.client.rpc.StatusCodeException) (err)).getEncodedResponse() : err.getMessage())); hashtagTextBox.setEnabled(true); } }); }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(project.get(), changeId.get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { if ((edit) != null) { edit.setName(edit.commit().commit()); result.revisions().put(edit.name(), com.google.gerrit.client.info.ChangeInfo.RevisionInfo.fromEdit(edit)); } render(result.revisions()); loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.client.info.ChangeInfo info, final java.lang.String revision, final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String commitMessage) { b.setEnabled(false); new com.google.gerrit.client.ui.CherryPickDialog(project) { { sendButton.setText(Util.C.buttonCherryPickChangeSend()); if ((info.status()) == (Change.Status.MERGED)) { message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision)); } else { message.setText(commitMessage.trim()); } } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.project(), info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private static com.google.gerrit.client.rpc.RestApi revision(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String type) { return com.google.gerrit.client.changes.ChangeApi.revision(project, id).view(type); }
public static void draft(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String draftId, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.CommentInfo> cb) { CommentApi.revision(project, id, "drafts").id(draftId).get(cb); }
public static void drafts(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> cb) { com.google.gerrit.client.changes.CommentApi.revision(project, id, "drafts").get(cb); }
@java.lang.Override protected void onLoad() { if ((fetch) == null) { if ((psId.get()) == 0) { com.google.gerrit.client.changes.ChangeApi.editWithCommands(change.project(), change.legacyId().get()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.EditInfo result) { fetch = result.fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } else { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.detail(change.project(), change.legacyId().get()); com.google.gerrit.client.changes.ChangeList.addOptions(call, java.util.EnumSet.of((revision.equals(change.currentRevision()) ? com.google.gerrit.extensions.client.ListChangesOption.CURRENT_REVISION : com.google.gerrit.extensions.client.ListChangesOption.ALL_REVISIONS), ListChangesOption.DOWNLOAD_COMMANDS)); call.get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { fetch = result.revision(revision).fetch(); renderScheme(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, result.legacyId())); }
public static com.google.gerrit.client.rpc.RestApi vote(@com.google.gerrit.common.Nullable java.lang.String project, int id, int reviewer, java.lang.String vote) { return ChangeApi.reviewer(project, id, reviewer).view("votes").id(vote); }
public static void deleteChange(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(project, id).delete(cb); }
public static void delete(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editFile(project, id, path).delete(cb); }
private void scrollToPath(java.lang.String token) { com.google.gerrit.client.change.ProjectChangeId cId; try { cId = com.google.gerrit.client.change.ProjectChangeId.create(token); } catch (java.lang.IllegalArgumentException e) { return; } if (!(changeId.equals(cId.getChangeId()))) { return; } int s = token.indexOf('/', ((cId.identifierLength()) + 1)); if (s < 0) { return; } int c = token.lastIndexOf(','); if (0 <= c) { token = token.substring((s + 1), c); } else { token = token.substring((s + 1)); } if (!(token.isEmpty())) { files.scrollToPath(com.google.gwtorm.client.KeyUtil.decode(token)); } }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(com.google.gerrit.client.diff.Unified.this, getProject(), base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static void put(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String path, java.lang.String content, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { if (Patch.COMMIT_MSG.equals(path)) { com.google.gerrit.client.changes.ChangeEditApi.putMessage(project, id, content, cb); } else { com.google.gerrit.client.changes.ChangeEditApi.editFile(project, id, path).put(content, cb); } }
public static void rename(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String path, java.lang.String newPath, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.oldPath(path); in.newPath(newPath); com.google.gerrit.client.changes.ChangeApi.edit(project, id).post(in, cb); }
void renderPublished(com.google.gerrit.client.diff.DisplaySide forSide, com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> in) { for (com.google.gerrit.client.changes.CommentInfo info : com.google.gerrit.client.rpc.Natives.asList(in)) { com.google.gerrit.client.diff.DisplaySide side = displaySide(info, forSide); if (side != null) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.PublishedBox box = new com.google.gerrit.client.diff.PublishedBox(group, getCommentLinkProcessor(), project, getPatchSetIdFromSide(side), info, side, isOpen()); group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.comment(host.getCmFromSide(side), (cmLinePlusOne - 1))); getPublished().put(info.id(), box); } } }
com.google.gerrit.client.diff.DraftBox addDraftBox(com.google.gerrit.client.diff.DisplaySide side, com.google.gerrit.client.changes.CommentInfo info) { int cmLinePlusOne = (host.getCmLine(((info.line()) - 1), side)) + 1; com.google.gerrit.client.diff.CommentGroup group = group(side, cmLinePlusOne); com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox(group, getCommentLinkProcessor(), project, getPatchSetIdFromSide(side), info, isExpandAll()); if ((info.inReplyTo()) != null) { com.google.gerrit.client.diff.PublishedBox r = getPublished().get(info.inReplyTo()); if (r != null) { r.setReplyBox(box); } } group.add(box); box.setAnnotation(host.getDiffTable().scrollbar.draft(host.getCmFromSide(side), java.lang.Math.max(0, (cmLinePlusOne - 1)))); return box; }
private void renderComments(java.util.List<com.google.gerrit.client.changes.CommentInfo> list) { com.google.gerrit.client.ui.CommentLinkProcessor clp = history.getCommentLinkProcessor(); com.google.gerrit.reviewdb.client.PatchSet.Id ps = new com.google.gerrit.reviewdb.client.PatchSet.Id(history.getChangeId(), info._revisionNumber()); java.util.TreeMap<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> m = com.google.gerrit.client.change.Message.byPath(list); java.util.List<com.google.gerrit.client.changes.CommentInfo> l = m.remove(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, history.getProject(), ps, Util.C.commitMessage(), l)); } l = m.remove(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, history.getProject(), ps, Util.C.mergeList(), l)); } for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.client.changes.CommentInfo>> e : m.entrySet()) { comments.add(new com.google.gerrit.client.change.FileComments(clp, history.getProject(), ps, e.getKey(), e.getValue())); } }
public static void getMeta(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.editor.EditFileInfo> cb) { if ((id.get()) != 0) { throw new java.lang.IllegalStateException("only supported for edits"); } com.google.gerrit.client.changes.ChangeEditApi.editFile(project, id.getParentKey().get(), path).view("meta").get(cb); }
private void loadCommit(com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { if ((rev.isEdit()) || ((rev.commit()) != null)) { return; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks(getProject().get(), changeId.get(), rev.name(), group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { rev.setCommit(info); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet.Id ps, com.google.gerrit.client.changes.CommentInfo info) { return com.google.gerrit.client.Dispatcher.toPatch(project, null, ps, info.path(), ((info.side()) == (com.google.gerrit.extensions.client.Side.PARENT) ? com.google.gerrit.client.diff.DisplaySide.A : com.google.gerrit.client.diff.DisplaySide.B), info.line()); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadDrafts(com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("drafts").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } else { r.add(com.google.gerrit.client.rpc.NativeMap.<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>create()); } return r; }
private static com.google.gerrit.client.rpc.RestApi editMessage(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.change(project, id).view("edit:message"); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } else { super.onFailure(err); } }
static void publishEdit(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.publishEdit(project.get(), id.get(), com.google.gerrit.client.change.EditActions.cs(project, id, editButtons)); }
static void rebaseEdit(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.rebaseEdit(project.get(), id.get(), com.google.gerrit.client.change.EditActions.cs(project, id, editButtons)); }
static void deleteEdit(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.changes.ChangeApi.deleteEdit(project.get(), id.get(), com.google.gerrit.client.change.EditActions.cs(project, id, editButtons)); }
private void delete(java.lang.String path) { hide(); com.google.gerrit.client.changes.ChangeEditApi.delete(project.get(), changeId.get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(project, changeId)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
public static com.google.gerrit.client.rpc.RestApi suggestReviewers(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String q, int n, boolean e) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(project, id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e); if (q != null) { api.addParameter("q", q); } return api; }
public static void includedIn(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo> cb) { com.google.gerrit.client.changes.ChangeApi.call(project, id, "in").get(cb); }
@com.google.gwt.uibinder.client.UiHandler("deleteEdit") void onDeleteEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChangeEdit())) { com.google.gerrit.client.change.EditActions.deleteEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit); } }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... editButtons) { com.google.gerrit.client.change.EditActions.setEnabled(false, editButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.EditActions.setEnabled(true, editButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } else { super.onFailure(err); } } }; }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager(this, getProject(), base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, revision.getParentKey(), revision.getId())); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), getProject(), style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); }
private void open(java.lang.String path) { hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(project, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, revision._number()), path)); }
void onDelete() { if ((popup) != null) { popup.hide(); return; } if ((deleteBox) == null) { deleteBox = new com.google.gerrit.client.change.DeleteFileBox(project, changeId, revision); } deleteBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(deleteButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(deleteBox); p.showRelativeTo(deleteButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); deleteBox.setFocus(true); popup = p; }
private void getImpl(java.lang.Integer id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> cb) { java.lang.String name = changeToProject.get(id); if (name != null) { getImpl(name, cb); return; } com.google.gerrit.client.changes.ChangeApi.change(null, id).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { changeToProject.put(id, result.project()); getImpl(result.project(), cb); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { cb.onFailure(caught); } }); }
public com.google.gerrit.client.rpc.RestApi id(java.lang.String project, int id) { return idRaw((((com.google.gwt.http.client.URL.encodePathSegment(project)) + "~") + id)); }
private com.google.inject.Key<javax.servlet.http.HttpServlet> directChangeById() { return key(new javax.servlet.http.HttpServlet() { private static final long serialVersionUID = 1L; @java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(null, id), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } } }); }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { try { java.lang.String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, ((idString.length()) - 1)); } com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.parse(idString); com.google.gerrit.httpd.UrlModule.toGerrit(com.google.gerrit.common.PageLinks.toChange(null, id), req, rsp); } catch (java.lang.IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } }
static void call(com.google.gerrit.client.info.ChangeInfo changeInfo, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revisionInfo) { if (com.google.gerrit.client.api.ChangeGlue.onSubmitChange(changeInfo, revisionInfo)) { final com.google.gerrit.reviewdb.client.Change.Id changeId = changeInfo.legacyId(); com.google.gerrit.client.changes.ChangeApi.submit(changeInfo.project(), changeId.get(), revisionInfo.name(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.SubmitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.SubmitInfo result) { redisplay(); } @java.lang.Override public void onFailure(java.lang.Throwable err) { if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); } else { super.onFailure(err); } redisplay(); } private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeInfo.projectNameKey(), changeId)); } }); } }
private void redisplay() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(changeInfo.projectNameKey(), changeId)); }
void onRestore(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.restore(project.get(), curr.getParentKey().get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(project, curr.getParentKey())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
private java.util.List<com.google.gerrit.client.ui.InlineHyperlink> getUnifiedDiffLink() { com.google.gerrit.client.ui.InlineHyperlink toUnifiedDiffLink = new com.google.gerrit.client.ui.InlineHyperlink(); toUnifiedDiffLink.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); toUnifiedDiffLink.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toUnified(getProject(), base, revision, path)); toUnifiedDiffLink.setTitle(PatchUtil.C.unifiedDiff()); return java.util.Collections.singletonList(toUnifiedDiffLink); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return info.binary() ? com.google.gerrit.client.Dispatcher.toUnified(project, base, curr, info.path()) : (mode) == (com.google.gerrit.client.change.FileTable.Mode.REVIEW) ? com.google.gerrit.client.Dispatcher.toPatch(project, base, curr, info.path()) : com.google.gerrit.client.Dispatcher.toEditScreen(project, curr, info.path()); }
void onDelete(int idx) { java.lang.String path = list.get(idx).path(); com.google.gerrit.client.changes.ChangeEditApi.delete(project.get(), curr.getParentKey().get(), path, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(project, curr.getParentKey())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(project, curr.getParentKey())); }
private void setReviewed(com.google.gerrit.client.info.FileInfo info, boolean r) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(project.get(), curr).view("files").id(info.path()).view("reviewed"); if (r) { api.put(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } else { api.delete(com.google.gerrit.client.rpc.CallbackGroup.<com.google.gerrit.client.changes.ReviewInfo>emptyCallback()); } }
@java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId, base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(project, changeId, base, rev, openReplyBox, FileTable.Mode.REVIEW)); }
private void countParents(com.google.gerrit.client.rpc.CallbackGroup cbg) { com.google.gerrit.client.changes.ChangeApi.revision(Project.NameKey.asStringOrNull(project), changeId.get(), revision.getId()).view("commit").get(cbg.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.CommitInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.CommitInfo info) { parents = info.parents().length(); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { parents = 0; } })); }
void reloadDiffInfo() { int id = ++(reloadVersionId); com.google.gerrit.client.diff.DiffApi.diff(Project.NameKey.asStringOrNull(project), revision, path).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo diffInfo) { if ((id == (reloadVersionId)) && (isAttached())) { diff = diffInfo; operation(() -> { skipManager.removeAll(); getChunkManager().reset(); getDiffTable().scrollbar.removeDiffAnnotations(); setShowIntraline(prefs.intralineDifference()); render(diff); skipManager.render(prefs.context(), diff); }); } } }); }
private java.lang.Runnable openEditScreen(net.codemirror.lib.CodeMirror cm) { return () -> { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras().activeLine(); int line = (cm.getLineNumber(handle)) + 1; if (Patch.COMMIT_MSG.equals(path)) { line = adjustCommitMessageLine(line); } java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen(project, revision, path, line); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(token); } else { com.google.gerrit.client.Gerrit.display(token); } }; }
void prefetchNextFile() { java.lang.String nextPath = header.getNextPath(); if (nextPath != null) { com.google.gerrit.client.diff.DiffApi.diff(Project.NameKey.asStringOrNull(project), revision, nextPath).base(base.asPatchSetId()).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.diff.DiffInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.diff.DiffInfo info) { new net.codemirror.mode.ModeInjector().add(getContentType(info.metaA())).add(getContentType(info.metaB())).inject(com.google.gerrit.client.rpc.CallbackGroup.<java.lang.Void>emptyCallback()); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private java.lang.Runnable upToChange(boolean openReplyBox) { return () -> { com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); getCommentManager().saveAllDrafts(group); group.done(); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { java.lang.String rev = java.lang.String.valueOf(revision.get()); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId, base.asString(), rev), new com.google.gerrit.client.change.ChangeScreen(project, changeId, base, rev, openReplyBox, FileTable.Mode.REVIEW)); } }); }; }
private void rename(java.lang.String path, java.lang.String newPath) { hide(); com.google.gerrit.client.changes.ChangeEditApi.rename(project.get(), changeId.get(), path, newPath, new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(project, changeId)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); }
static void invoke(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.rpc.RestApi api) { com.google.gerrit.client.api.DefaultActions.invoke(action, api, com.google.gerrit.client.api.DefaultActions.callback(com.google.gerrit.common.PageLinks.toChange(change.projectNameKey(), change.legacyId()))); }
private static void codemirror(final java.lang.String token, final com.google.gerrit.client.DiffObject base, @com.google.gerrit.common.Nullable final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(project, base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); } }); }
@com.google.gwt.uibinder.client.UiHandler("permalink") void onReload(com.google.gwt.event.dom.client.ClickEvent e) { e.preventDefault(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); }
@java.lang.Override com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry> getScreenLoadCallback(final com.google.gerrit.client.diff.CommentsCollections comments) { return new com.google.gerrit.client.rpc.ScreenLoadCallback<com.google.gerrit.client.projects.ConfigInfoCache.Entry>(this) { @java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(com.google.gerrit.client.diff.SideBySide.this, getProject(), base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); } }; }
public static java.lang.String toChangeId(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id c) { if (project == null) { return java.lang.String.valueOf(c.get()); } return ((project.get()) + (com.google.gerrit.common.PageLinks.PROJECT_CHANGE_DELIMITER)) + (c.get()); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.cherrypick(info.project(), info.legacyId().get(), revision, getDestinationBranch(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
private static java.lang.String toChangeNoSlash(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id c) { if (project != null) { return (("/c/" + (project.get())) + (com.google.gerrit.common.PageLinks.PROJECT_CHANGE_DELIMITER)) + c; } return "/c/" + c; }
public static java.lang.String toChangeInEditMode(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id c) { return (com.google.gerrit.common.PageLinks.toChangeNoSlash(project, c)) + ",edit/"; }
private void loadDiff(com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group) { java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments = loadComments(rev, group); java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts = loadDrafts(rev, group); loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts); if ((com.google.gerrit.client.Gerrit.isSignedIn()) && ((fileTableMode) == (FileTable.Mode.REVIEW))) { com.google.gerrit.client.changes.ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { files.markReviewed(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); } }
@com.google.gwt.uibinder.client.UiHandler("rebaseEdit") void onRebaseEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.rebaseEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit); }
private void updateToken(com.google.gerrit.client.info.ChangeInfo info, com.google.gerrit.client.DiffObject base, com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev) { java.lang.StringBuilder token = new java.lang.StringBuilder("/c/").append(com.google.gerrit.common.PageLinks.toChangeId(info.projectNameKey(), info.legacyId())).append("/"); if ((base.asString()) != null) { token.append(base.asString()).append(".."); } if (((base.asString()) != null) || (!(rev.name().equals(info.currentRevision())))) { token.append(rev._number()); } setToken(token.toString()); }
@com.google.gwt.uibinder.client.UiHandler("publishEdit") void onPublishEdit(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.EditActions.publishEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit); }
void showUpdates(com.google.gerrit.client.info.ChangeInfo newInfo) { if ((!(isAttached())) || (newInfo.updated().equals(lastDisplayedUpdate))) { return; } com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> om = changeInfo.messages(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> nm = newInfo.messages(); if (om == null) { om = com.google.gwt.core.client.JsArray.createArray().cast(); } if (nm == null) { nm = com.google.gwt.core.client.JsArray.createArray().cast(); } if ((om.length()) == (nm.length())) { return; } if ((updateAvailable) == null) { updateAvailable = new com.google.gerrit.client.change.UpdateAvailableBar() { @java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); } @java.lang.Override void onIgnore(java.sql.Timestamp newTime) { lastDisplayedUpdate = newTime; } }; } updateAvailable.set(com.google.gerrit.client.rpc.Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated()); if (!(updateAvailable.isAttached())) { add(updateAvailable); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, psId.getParentKey(), java.lang.String.valueOf(psId.get()))); }
private com.google.gerrit.client.ui.InlineHyperlink createLink(java.lang.String label, com.google.gerrit.client.DiffObject id) { assert (other) != null; if (sideA) { assert !(other.idActive.isBaseOrAutoMerge()); } com.google.gerrit.client.DiffObject diffBase = (sideA) ? id : other.idActive; com.google.gerrit.client.DiffObject revision = (sideA) ? other.idActive : id; return new com.google.gerrit.client.ui.InlineHyperlink(label, (parent.isSideBySide() ? com.google.gerrit.client.Dispatcher.toSideBySide(project, diffBase, revision.asPatchSetId(), path) : com.google.gerrit.client.Dispatcher.toUnified(project, diffBase, revision.asPatchSetId(), path))); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.createChange(project, branch, topic, message, base, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); hide(); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); hide(); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.EditInfo edit, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.edit(change.project(), change.legacyId().get()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.EditGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(edit); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
public static void get(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, boolean base, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.rpc.RestApi api; if ((id.get()) != 0) { api = com.google.gerrit.client.changes.ChangeApi.revision(Project.NameKey.asStringOrNull(project), id).view("files").id(path).view("content"); } else if (Patch.COMMIT_MSG.equals(path)) { api = com.google.gerrit.client.changes.ChangeEditApi.editMessage(Project.NameKey.asStringOrNull(project), id.getParentKey().get()).addParameter("base", base); } else { api = com.google.gerrit.client.changes.ChangeEditApi.editFile(Project.NameKey.asStringOrNull(project), id.getParentKey().get(), path).addParameter("base", base); } api.get(cb); }
public static void putMessage(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String m, com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.editMessage(project, id).put(m, cb); }
public static void restore(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String path, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.VoidResult> cb) { com.google.gerrit.client.changes.ChangeEditApi.Input in = com.google.gerrit.client.changes.ChangeEditApi.Input.create(); in.restorePath(path); com.google.gerrit.client.changes.ChangeApi.edit(project, id).post(in, cb); }
private static com.google.gerrit.client.rpc.RestApi editFile(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String path) { return com.google.gerrit.client.changes.ChangeApi.edit(project, id).id(path); }
void setUpBlame(final net.codemirror.lib.CodeMirror cm, boolean isBase, com.google.gerrit.reviewdb.client.PatchSet.Id rev, java.lang.String path) { if (((!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) && (com.google.gerrit.client.Gerrit.isSignedIn())) && (com.google.gerrit.client.Gerrit.info().change().allowBlame())) { com.google.gwt.user.client.ui.Anchor blameIcon = createBlameIcon(); blameIcon.addClickHandler(new com.google.gwt.event.dom.client.ClickHandler() { @java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(Project.NameKey.asStringOrNull(project), rev, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } } }); linkPanel.add(blameIcon); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent clickEvent) { if ((cm.extras().getBlameInfo()) != null) { cm.extras().toggleAnnotation(); } else { com.google.gerrit.client.changes.ChangeApi.blame(Project.NameKey.asStringOrNull(project), rev, path, isBase).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.blame.BlameInfo> lines) { cm.extras().toggleAnnotation(lines); } }); } }
private com.google.gwt.user.client.ui.Widget createEditIcon() { com.google.gerrit.reviewdb.client.PatchSet.Id id = (idActive.isBaseOrAutoMerge()) ? other.idActive.asPatchSetId() : idActive.asPatchSetId(); com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.edit()), ("#" + (com.google.gerrit.client.Dispatcher.toEditScreen(project, id, path)))); anchor.setTitle(PatchUtil.C.edit()); return anchor; }
public static void get(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString> cb) { com.google.gerrit.client.changes.ChangeEditApi.get(project, id, path, false, cb); }
private java.lang.String getReplyCommentName() { return "savedReplyComment-" + (com.google.gerrit.common.PageLinks.toChangeId(project, changeId)); }
@com.google.gwt.uibinder.client.UiHandler("fix") void onFix(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); java.lang.String t = com.google.gerrit.client.Dispatcher.toEditScreen(project, psId, comment.path(), comment.line()); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(t); } else { com.google.gerrit.client.Gerrit.display(t); } }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.restore(project.get(), id.get(), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); hide(); } }); }
@java.lang.Override protected void onOpenRow(int row) { final com.google.gerrit.client.info.ChangeInfo c = getRowItem(row); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(c.projectNameKey(), c.legacyId())); }
@com.google.gwt.uibinder.client.UiHandler("done") void onReplyDone(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (!(com.google.gerrit.client.Gerrit.isSignedIn())) { com.google.gerrit.client.Gerrit.doSignIn(getCommentManager().host.getToken()); } else if ((replyBox) == null) { done.setEnabled(false); com.google.gerrit.client.changes.CommentInfo input = com.google.gerrit.client.changes.CommentInfo.createReply(comment); input.message(PatchUtil.C.cannedReplyDone()); com.google.gerrit.client.changes.CommentApi.createDraft(Project.NameKey.asStringOrNull(project), psId, input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { done.setEnabled(true); setOpen(false); getCommentManager().addDraftBox(displaySide, result); } }); } else { openReplyBox(); setOpen(false); } }
private java.lang.String getInlineCommentName(com.google.gerrit.client.changes.CommentInfo comment) { if ((psId) == null) { return null; } java.lang.String result = "patchComment-"; if ((comment.id()) != null) { result = ("patchCommentEdit-" + (comment.id())) + "-"; } else if ((comment.inReplyTo()) != null) { result = ("patchReply-" + (comment.inReplyTo())) + "-"; } result += com.google.gerrit.common.PageLinks.toChangeId(project, changeId); result += ((((("-" + (psId.getId())) + "-") + (com.google.gerrit.client.change.LocalComments.btoa(comment.path()))) + "-") + (comment.side())) + "-"; if (comment.hasRange()) { result += (((((("R" + (comment.range().startLine())) + ",") + (comment.range().startCharacter())) + "-") + (comment.range().endLine())) + ",") + (comment.range().endCharacter()); } else { result += comment.line(); } return result; }
public static void saveInlineComments() { final com.google.gerrit.client.change.LocalComments.StorageBackend storage = new com.google.gerrit.client.change.LocalComments.StorageBackend(); for (java.lang.String cookie : storage.getKeys()) { if (com.google.gerrit.client.change.LocalComments.isInlineComment(cookie)) { com.google.gerrit.client.change.LocalComments.InlineComment input = com.google.gerrit.client.change.LocalComments.getInlineComment(cookie); if ((input.commentInfo.id()) == null) { com.google.gerrit.client.changes.CommentApi.createDraft(Project.NameKey.asStringOrNull(input.project), input.psId, input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } }); } else { com.google.gerrit.client.changes.CommentApi.updateDraft(Project.NameKey.asStringOrNull(input.project), input.psId, input.commentInfo.id(), input.commentInfo, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.CommentInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.CommentInfo result) { storage.removeItem(cookie); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotFound(caught)) { storage.removeItem(cookie); } else { super.onFailure(caught); } } }); } } } }
public static java.lang.String toChange(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id c, java.lang.String b, java.lang.String p) { java.lang.String u = com.google.gerrit.common.PageLinks.toChange(project, c); if (b != null) { u += b + ".."; } u += p; return u; }
private java.lang.String url(com.google.gerrit.client.info.ChangeInfo.RevisionInfo r) { return com.google.gerrit.common.PageLinks.toChange(project, changeId, r.id()); }
@java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } else { super.onFailure(err); } }
static void call(com.google.gwt.user.client.ui.Button b, java.lang.String project) { b.setEnabled(false); new com.google.gerrit.client.ui.CreateChangeDialog(new com.google.gerrit.reviewdb.client.Project.NameKey(project)) { { sendButton.setText(AdminConstants.I.buttonCreate()); message.setText(AdminConstants.I.buttonCreateDescription()); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
private com.google.gwtexpui.globalkey.client.KeyCommand setupNav(com.google.gerrit.client.ui.InlineHyperlink link, char key, java.lang.String help, com.google.gerrit.client.info.FileInfo info) { if (info != null) { final java.lang.String url = url(info); link.setTargetHistoryToken(url); link.setTitle(PatchUtil.M.fileNameWithShortcutKey(com.google.gerrit.client.info.FileInfo.getFileName(info.path()), java.lang.Character.toString(key))); com.google.gwtexpui.globalkey.client.KeyCommand k = new com.google.gwtexpui.globalkey.client.KeyCommand(0, key, help) { @java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(url); } }; keys.add(k); if (link == (prev)) { hasPrev = true; } else { hasNext = true; } return k; } link.getElement().getStyle().setVisibility(Visibility.HIDDEN); keys.add(new com.google.gerrit.client.diff.UpToChangeCommand(projectKey, patchSetId, 0, key)); return null; }
public static com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject> cs(com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.change.ChangeActions.setEnabled(false, draftButtons); return new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { com.google.gerrit.client.change.ChangeActions.setEnabled(true, draftButtons); if (com.google.gerrit.client.change.SubmitFailureDialog.isConflict(err)) { new com.google.gerrit.client.change.SubmitFailureDialog(err.getMessage()).center(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } else { super.onFailure(err); } } }; }
static void delete(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteRevision(project.get(), id.get(), revision, com.google.gerrit.client.change.ChangeActions.cs(project, id, draftButtons)); }
static void unmarkPrivate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.unmarkPrivate(project.get(), id.get(), com.google.gerrit.client.change.ChangeActions.cs(project, id, draftButtons)); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); }
public static void restore(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(project, id, "restore").post(input, cb); }
static void publish(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String revision, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.publish(project.get(), id.get(), revision, com.google.gerrit.client.change.ChangeActions.cs(project, id, draftButtons)); }
static void markPrivate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.markPrivate(project.get(), id.get(), com.google.gerrit.client.change.ChangeActions.cs(project, id, draftButtons)); }
void onRename() { if ((popup) != null) { popup.hide(); return; } if ((renameBox) == null) { renameBox = new com.google.gerrit.client.change.RenameFileBox(project, changeId, revision); } renameBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(renameButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(renameBox); p.showRelativeTo(renameButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); renameBox.setFocus(true); popup = p; }
public void onEdit() { if ((popup) != null) { popup.hide(); return; } files.unregisterKeys(); if ((addBox) == null) { addBox = new com.google.gerrit.client.change.AddFileBox(project, changeId, revision, files); } addBox.clearPath(); final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(addButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; } } }); p.add(addBox); p.showRelativeTo(addButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); addBox.setFocus(true); popup = p; }
private void doSearch() { final java.lang.String query = searchBox.getText().trim(); if ("".equals(query)) { return; } searchBox.setFocus(false); if (((dropdown) != null) && (dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc()))) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toDocumentationQuery(query)); } else { if (query.matches("^[1-9][0-9]*$")) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(null, Change.Id.parse(query))); } else { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeQuery(query), com.google.gerrit.client.changes.QueryScreen.forQuery(query)); } } }
@java.lang.Override protected void onLoad() { commentsPanel.setVisible(false); post.setEnabled(false); if (lc.hasReplyComment()) { message.setText(lc.getReplyComment()); lc.removeReplyComment(); } com.google.gerrit.client.changes.ChangeApi.drafts(project.get(), psId.getParentKey().get()).get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { displayComments(result); post.setEnabled(true); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { post.setEnabled(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleDeferred(new com.google.gwt.core.client.Scheduler.ScheduledCommand() { @java.lang.Override public void execute() { message.setFocus(true); } }); com.google.gwt.core.client.Scheduler.get().scheduleFixedDelay(new com.google.gwt.core.client.Scheduler.RepeatingCommand() { @java.lang.Override public boolean execute() { java.lang.String t = message.getText(); if (t != null) { message.setCursorPos(t.length()); } return false; } }, 0); }
private static com.google.gerrit.client.rpc.RestApi call(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String action) { return com.google.gerrit.client.changes.ChangeApi.change(project, id).view(action); }
private void displayComments(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> m) { comments.clear(); com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo> l = m.get(Patch.COMMIT_MSG); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, project, psId, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.COMMIT_MSG, l))); } l = m.get(Patch.MERGE_LIST); if (l != null) { comments.add(new com.google.gerrit.client.change.FileComments(clp, project, psId, Util.C.commitMessage(), com.google.gerrit.client.change.ReplyBox.copyPath(Patch.MERGE_LIST, l))); } java.util.List<java.lang.String> paths = new java.util.ArrayList(m.keySet()); java.util.Collections.sort(paths); for (java.lang.String path : paths) { if (!(com.google.gerrit.reviewdb.client.Patch.isMagic(path))) { comments.add(new com.google.gerrit.client.change.FileComments(clp, project, psId, path, com.google.gerrit.client.change.ReplyBox.copyPath(path, m.get(path)))); } } commentsPanel.setVisible(((comments.getWidgetCount()) > 0)); }
Project.NameKey getProject() { return project; }
@com.google.gwt.uibinder.client.UiHandler({ "discard1", "discard2" }) void onDiscard(com.google.gwt.event.dom.client.ClickEvent e) { e.stopPropagation(); if (isNew()) { removeUI(); restoreSelection(); } else { setEdit(false); pendingGroup = new com.google.gerrit.client.rpc.CallbackGroup(); com.google.gerrit.client.changes.CommentApi.deleteDraft(Project.NameKey.asStringOrNull(project), psId, comment.id(), pendingGroup.addFinal(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { pendingGroup = null; removeUI(); } })); } }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(project.get(), id.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static java.lang.String toEditScreen(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, int line) { return com.google.gerrit.client.Dispatcher.toPatch("edit", project, com.google.gerrit.client.DiffObject.base(), revision, fileName, null, line); }
static void call(final com.google.gwt.user.client.ui.Button b, final com.google.gerrit.reviewdb.client.Project.NameKey project, final java.lang.String branch, final com.google.gerrit.reviewdb.client.Change.Id id, final java.lang.String revision, final boolean enabled) { b.setEnabled(false); new com.google.gerrit.client.ui.RebaseDialog(project, branch, id, enabled) { @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.rebase(project.get(), id.get(), revision, getBase(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override protected void onRequestSuggestions(com.google.gerrit.client.change.Request req, com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(project.get(), changeId.get(), revision.name()).view("files"); if ((req.getQuery()) != null) { api.addParameter("q", ((req.getQuery()) == null ? "" : req.getQuery())); } api.background().get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { java.util.List<com.google.gerrit.client.change.Suggestion> r = new java.util.ArrayList<>(); for (java.lang.String path : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.PathSuggestOracle.PathSuggestion(path)); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { java.util.List<com.google.gerrit.client.change.Suggestion> none = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(none)); } }); }
public static void unmarkPrivate(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(project, id).view("private.delete").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
private static java.lang.String url(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet.Id ps, com.google.gerrit.client.changes.CommentInfo info) { return com.google.gerrit.client.Dispatcher.toPatch(project, null, ps, info.path()); }
@java.lang.Override void onShow() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); }
@com.google.gwt.uibinder.client.UiHandler("deleteRevision") void onDeleteRevision(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteDraftRevision())) { com.google.gerrit.client.change.ChangeActions.delete(getProject(), changeId, revision, publish, deleteRevision); } }
@java.lang.Override public void onClick(com.google.gwt.event.dom.client.ClickEvent event) { if (((replyAction) != null) && (replyAction.isVisible())) { replyAction.quickApprove(input); } else { com.google.gerrit.client.changes.ChangeApi.revision(project.get(), changeId.get(), revision).view("review").post(input, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); } }); } }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); }
private void postReview() { in.message(message.getText().trim()); in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS); in.prePost(); com.google.gerrit.client.changes.ChangeApi.revision(project.get(), psId.getParentKey().get(), revision).view("review").post(in, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ReviewInput>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ReviewInput result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, psId)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { if (com.google.gerrit.client.rpc.RestApi.isNotSignedIn(caught)) { lc.setReplyComment(message.getText()); } super.onFailure(caught); } }); hide(); }
public static com.google.gerrit.client.rpc.RestApi reviewer(@com.google.gerrit.common.Nullable java.lang.String project, int id, int reviewer) { return ChangeApi.change(project, id).view("reviewers").id(reviewer); }
public static void markPrivate(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.change(project, id).view("private").post(com.google.gerrit.client.changes.ChangeApi.PrivateInput.create(), cb); }
public static com.google.gerrit.client.rpc.RestApi actions(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String revision) { if ((revision == null) || (revision.equals(""))) { revision = "current"; } return com.google.gerrit.client.changes.ChangeApi.call(project, id, revision, "actions"); }
static void call(final com.google.gwt.user.client.ui.Button b, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String revision, java.lang.String commitSubject) { b.setEnabled(false); new com.google.gerrit.client.ui.TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) { { sendButton.setText(Util.C.buttonRevertChangeSend()); message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision)); } @java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(project.get(), id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); } @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { super.onClose(event); b.setEnabled(true); } }.center(); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.revert(project.get(), id.get(), getMessageText(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
private com.google.gerrit.client.rpc.RestApi reviewed() { return com.google.gerrit.client.changes.ChangeApi.revision(Project.NameKey.asStringOrNull(projectKey), patchSetId).view("files").id(path).view("reviewed"); }
private java.lang.String url(com.google.gerrit.client.info.FileInfo info) { return (diffScreenType) == (com.google.gerrit.extensions.client.GeneralPreferencesInfo.DiffView.UNIFIED_DIFF) ? com.google.gerrit.client.Dispatcher.toUnified(projectKey, base, patchSetId, info.path()) : com.google.gerrit.client.Dispatcher.toSideBySide(projectKey, base, patchSetId, info.path()); }
@java.lang.Override protected void onLoad() { com.google.gerrit.client.diff.DiffApi.list(Project.NameKey.asStringOrNull(projectKey), patchSetId, base.asPatchSetId(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> result) { files = result.values(); com.google.gerrit.client.info.FileInfo.sortFileInfoByPath(files); fileNumber.setInnerText(java.lang.Integer.toString(((com.google.gerrit.client.rpc.Natives.asList(files).indexOf(result.get(path))) + 1))); fileCount.setInnerText(java.lang.Integer.toString(files.length())); } }); if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.changes.ChangeApi.revision(Project.NameKey.asStringOrNull(projectKey), patchSetId).view("files").addParameterTrue("reviewed").get(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JsArrayString>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArrayString result) { boolean b = com.google.gerrit.client.rpc.Natives.asList(result).contains(path); reviewed.setValue(b, false); if ((!b) && ((reviewedState) == (com.google.gerrit.client.diff.Header.ReviewedState.AUTO_REVIEW))) { postAutoReviewed(); } reviewedState = com.google.gerrit.client.diff.Header.ReviewedState.LOADED; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private static void onRemoveReviewer(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); if (user != null) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.reviewer(screen.getProject().get(), changeId.get(), user).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getProject(), changeId)); } } }); } }
private static void onRemoveVote(com.google.gwt.dom.client.NativeEvent event) { java.lang.Integer user = com.google.gerrit.client.change.Labels.getDataId(event); java.lang.String vote = com.google.gerrit.client.change.Labels.getVoteId(event); if ((user != null) && (vote != null)) { final com.google.gerrit.client.change.ChangeScreen screen = com.google.gerrit.client.change.ChangeScreen.get(event); final com.google.gerrit.reviewdb.client.Change.Id changeId = screen.getPatchSetId().getParentKey(); com.google.gerrit.client.changes.ChangeApi.vote(screen.getProject().get(), changeId.get(), user, vote).delete(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JavaScriptObject>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getProject(), changeId)); } } }); } }
@java.lang.Override public void onSuccess(com.google.gwt.core.client.JavaScriptObject result) { if (screen.isCurrentView()) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(screen.getProject(), changeId)); } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String query = com.google.common.base.CharMatcher.is('/').trimTrailingFrom(req.getPathInfo()); java.util.List<com.google.gerrit.extensions.common.ChangeInfo> results; try { results = changes.query(query).withLimit(2).get(); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { com.google.gerrit.httpd.DirectChangeByCommit.log.warn(("Cannot process query by URL: /r/" + query), e); results = com.google.common.collect.ImmutableList.of(); } java.lang.String token; if ((results.size()) == 1) { com.google.gerrit.extensions.common.ChangeInfo ci = results.iterator().next(); token = com.google.gerrit.common.PageLinks.toChange(new com.google.gerrit.reviewdb.client.Project.NameKey(ci.project), new com.google.gerrit.reviewdb.client.Change.Id(ci._number)); } else { token = com.google.gerrit.common.PageLinks.toChangeQuery(query); } com.google.gerrit.httpd.UrlModule.toGerrit(token, req, rsp); }
public static com.google.gerrit.client.rpc.RestApi reviewers(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.change(project, id).view("reviewers"); }
private static com.google.gerrit.client.rpc.RestApi call(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, java.lang.String action) { return ChangeApi.change(project, id).view("revisions").id(commit).view(action); }
public static void setAssignee(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String user, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.AssigneeInput input = com.google.gerrit.client.changes.ChangeApi.AssigneeInput.create(); input.assignee(user); com.google.gerrit.client.changes.ChangeApi.change(project, id).view("assignee").put(input, cb); }
public static void edit(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.EditInfo> cb) { com.google.gerrit.client.changes.ChangeApi.edit(project, id).get(cb); }
@java.lang.Override protected com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.ChangeList> loadCallback() { return new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.changes.ChangeList>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(c.projectNameKey(), id)); } else { display(result); com.google.gerrit.client.changes.QueryScreen.this.display(); } } } }; }
@java.lang.Override public void onSuccess(com.google.gerrit.client.changes.ChangeList result) { if (isAttached()) { if (((result.length()) == 1) && (com.google.gerrit.client.changes.QueryScreen.isSingleQuery(query))) { com.google.gerrit.client.info.ChangeInfo c = result.get(0); com.google.gerrit.reviewdb.client.Change.Id id = c.legacyId(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(c.projectNameKey(), id)); } else { display(result); this.display(); } } }
@java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(getProjectKey(), changeId)); } else { displayReadOnly(access); } }
public static void submit(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.changes.SubmitInfo> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(project, id, commit, "submit").post(in, cb); }
public static void deleteRevision(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.revision(project, id, commit).delete(cb); }
public static com.google.gerrit.client.rpc.RestApi reviewer(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String reviewer) { return ChangeApi.change(project, id).view("reviewers").id(reviewer); }
public static void commitWithLinks(@com.google.gerrit.common.Nullable java.lang.String project, int changeId, java.lang.String revision, com.google.gerrit.client.rpc.CallbackGroup.Callback<com.google.gerrit.client.info.ChangeInfo.CommitInfo> callback) { com.google.gerrit.client.changes.ChangeApi.revision(project, changeId, revision).view("commit").addParameterTrue("links").get(callback); }
@com.google.gwt.uibinder.client.UiHandler("publish") void onPublish(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.publish(getProject(), changeId, revision, publish, deleteRevision); }
public static void deleteEdit(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.edit(project, id).delete(cb); }
public static void revert(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(project, id, "revert").post(input, cb); }
public static com.google.gerrit.client.rpc.RestApi drafts(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.call(project, id, "drafts"); }
@com.google.gwt.uibinder.client.UiHandler("review") void onReview(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent event) { final com.google.gerrit.common.data.ProjectAccess access = driver.flush(); if (driver.hasErrors()) { com.google.gwt.user.client.Window.alert(AdminConstants.I.errorsMustBeFixed()); return; } java.lang.String message = commitMessage.getText().trim(); if ("".equals(message)) { message = null; } enable(false); Util.PROJECT_SVC.reviewProjectAccess(getProjectKey(), access.getRevision(), message, access.getLocal(), access.getInheritsFrom(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.reviewdb.client.Change.Id>() { @java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.Change.Id changeId) { enable(true); commitMessage.setText(""); error.clear(); if (changeId != null) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(getProjectKey(), changeId)); } else { displayReadOnly(access); } } @java.lang.Override public void onFailure(java.lang.Throwable caught) { error.clear(); enable(true); super.onFailure(caught); } }); }
public static void deleteAssignee(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.AccountInfo> cb) { com.google.gerrit.client.changes.ChangeApi.change(project, id).view("assignee").delete(cb); }
public static void rebaseEdit(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(project, id).view("edit:rebase").post(in, cb); }
@java.lang.Override void send(java.lang.String message) { com.google.gerrit.client.changes.ChangeApi.abandon(project.get(), id.get(), message, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, id)); hide(); } }); }
void updateReviewerList() { com.google.gerrit.client.changes.ChangeApi.detail(project.get(), changeId.get(), new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { display(result); } }); }
public static com.google.gerrit.client.rpc.RestApi blame(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path, boolean base) { return ChangeApi.revision(project, id).view("files").id(path).view("blame").addParameter("base", base); }
private void initRevisionsAction(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision, com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actions) { int currentPatchSet; if (((info.currentRevision()) != null) && (info.revisions().containsKey(info.currentRevision()))) { currentPatchSet = info.revision(info.currentRevision())._number(); } else { com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.RevisionInfo> revList = info.revisions().values(); com.google.gerrit.client.info.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber(revList); currentPatchSet = revList.get(((revList.length()) - 1))._number(); } java.lang.String currentlyViewedPatchSet; boolean isPatchSetCurrent = true; java.lang.String revisionId = info.revision(revision).id(); if (revisionId.equals("edit")) { currentlyViewedPatchSet = Resources.M.editPatchSet(com.google.gerrit.client.info.ChangeInfo.RevisionInfo.findEditParent(info.revisions().values())); currentPatchSet = (info.revisions().values().length()) - 1; } else { currentlyViewedPatchSet = revisionId; if (!(currentlyViewedPatchSet.equals(java.lang.Integer.toString(currentPatchSet)))) { isPatchSetCurrent = false; } } patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet)); updatePatchSetsTextStyle(isPatchSetCurrent); patchSetsAction = new com.google.gerrit.client.change.PatchSetsAction(info.projectNameKey(), info.legacyId(), revision, edit, style, headerLine, patchSets); com.google.gerrit.client.info.ChangeInfo.RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { if (actions.containsKey("publish")) { publish.setVisible(true); publish.setTitle(actions.get("publish").title()); } if (actions.containsKey("/")) { deleteRevision.setVisible(true); deleteRevision.setTitle(actions.get("/").title()); } } }
public static java.lang.String toPatch(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { return com.google.gerrit.client.Dispatcher.toPatch("", project, diffBase, revision, fileName, side, line); }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(project, id, line)); }
private void initIncludedInAction(com.google.gerrit.client.info.ChangeInfo info) { if ((info.status()) == (com.google.gerrit.reviewdb.client.Change.Status.MERGED)) { includedInAction = new com.google.gerrit.client.change.IncludedInAction(info.projectNameKey(), info.legacyId(), style, headerLine, includedIn); includedIn.setVisible(true); } }
public static java.lang.String toPatch(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("", project, diffBase, revision, fileName, null, 0); }
public static java.lang.String toUnified(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName) { return com.google.gerrit.client.Dispatcher.toPatch("unified", project, diffBase, revision, fileName, null, 0); }
@java.lang.Override protected void preDisplay(com.google.gerrit.client.projects.ConfigInfoCache.Entry result) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager(this, getProject(), base, revision, path, result.getCommentLinkProcessor(), getChangeStatus().isOpen()); setTheme(result.getTheme()); display(comments); header.setupPrevNextFiles(comments); }
private static java.lang.String toPatch(java.lang.String type, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.PatchSet.Id revision, java.lang.String fileName, com.google.gerrit.client.diff.DisplaySide side, int line) { com.google.gerrit.reviewdb.client.Change.Id c = revision.getParentKey(); java.lang.StringBuilder p = new java.lang.StringBuilder(com.google.gerrit.common.PageLinks.toChange(project, c)); if ((diffBase != null) && ((diffBase.asString()) != null)) { p.append(diffBase.asString()).append(".."); } p.append(revision.getId()).append("/").append(com.google.gwtorm.client.KeyUtil.encode(fileName)); if (((type != null) && (!(type.isEmpty()))) && ((!("sidebyside".equals(type))) || (com.google.gerrit.client.Dispatcher.preferUnified()))) { p.append(",").append(type); } if ((side == (com.google.gerrit.client.diff.DisplaySide.A)) && (line > 0)) { p.append("@a").append(line); } else if (line > 0) { p.append("@").append(line); } return p.toString(); }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.change(change.project(), change.legacyId().get()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.ChangeGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override protected void onLoad() { if (!(loaded)) { com.google.gerrit.client.changes.ChangeApi.includedIn(project.get(), changeId.get(), new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo.IncludedInInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo.IncludedInInfo r) { branches.setInnerSafeHtml(formatList(r.branches())); tags.setInnerSafeHtml(formatList(r.tags())); for (java.lang.String n : r.externalNames()) { com.google.gwt.core.client.JsArrayString external = r.external(n); if ((external.length()) > 0) { appendRow(n, external); } } loaded = true; } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } }); } }
private void renderLinksToDiff() { com.google.gerrit.client.ui.InlineHyperlink sbs = new com.google.gerrit.client.ui.InlineHyperlink(); sbs.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.sideBySideDiff())); sbs.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch(projectKey, "sidebyside", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path))); sbs.setTitle(PatchUtil.C.sideBySideDiff()); linkPanel.add(sbs); com.google.gerrit.client.ui.InlineHyperlink unified = new com.google.gerrit.client.ui.InlineHyperlink(); unified.setHTML(new com.google.gwt.user.client.ui.ImageResourceRenderer().render(Gerrit.RESOURCES.unifiedDiff())); unified.setTargetHistoryToken(com.google.gerrit.client.Dispatcher.toPatch(projectKey, "unified", null, new com.google.gerrit.reviewdb.client.Patch.Key(revision, path))); unified.setTitle(PatchUtil.C.unifiedDiff()); linkPanel.add(unified); }
@com.google.gwt.uibinder.client.UiHandler("abandon") void onAbandon(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((abandonAction) == null) { abandonAction = new com.google.gerrit.client.change.AbandonAction(abandon, project, changeId); } abandonAction.show(); }
private java.lang.Runnable save() { return () -> { if (!(cmEdit.isClean(generation))) { close.setEnabled(false); java.lang.String text = cmEdit.getValue(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String trimmed = (text.trim()) + "\r"; if (!(trimmed.equals(text))) { text = trimmed; cmEdit.setValue(text); } } final int g = cmEdit.changeGeneration(false); com.google.gerrit.client.changes.ChangeEditApi.put(Project.NameKey.asStringOrNull(projectKey), revision.getParentKey().get(), path, text, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.VoidResult>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.VoidResult result) { generation = g; setClean(cmEdit.isClean(g)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { close.setEnabled(true); } }); } }; }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.SideBySide(project, base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); }
static void delete(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, com.google.gwt.user.client.ui.Button... draftButtons) { com.google.gerrit.client.changes.ChangeApi.deleteChange(project.get(), id.get(), com.google.gerrit.client.change.ChangeActions.mine(draftButtons)); }
@java.lang.Override public void onKeyPress(com.google.gwt.event.dom.client.KeyPressEvent event) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, changeId)); }
@com.google.gwt.uibinder.client.UiHandler("followUp") void onFollowUp(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((followUpAction) == null) { followUpAction = new com.google.gerrit.client.change.FollowUpAction(followUp, project.get(), branch, topic, key); } followUpAction.show(); }
@com.google.gwt.uibinder.client.UiHandler("showBase") void onShowBase(com.google.gwt.event.logical.shared.ValueChangeEvent<java.lang.Boolean> e) { boolean shouldShow = e.getValue(); if (shouldShow) { if ((baseContent) == null) { com.google.gerrit.client.changes.ChangeEditApi.get(projectKey, revision, path, true, new com.google.gerrit.client.rpc.HttpCallback<com.google.gerrit.client.rpc.NativeString>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.HttpResponse<com.google.gerrit.client.rpc.NativeString> fc) { baseContent = fc; displayBase(); } @java.lang.Override public void onFailure(java.lang.Throwable e) { } }); } else { displayBase(); } } else { cmBase.getWrapperElement().getParentElement().addClassName(style.hideBase()); cmEdit.getWrapperElement().getParentElement().addClassName(style.fullWidth()); mv.getGapElement().addClassName(style.hideBase()); } mv.setShowDifferences(shouldShow); }
public static void publishEdit(@com.google.gerrit.common.Nullable java.lang.String project, int id, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.change(project, id).view("edit:publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi edit(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.change(project, id).view("edit"); }
public static void list(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, com.google.gerrit.reviewdb.client.PatchSet.Id base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(project, id).view("files"); if (base != null) { if ((base.get()) < 0) { api.addParameter("parent", (-(base.get()))); } else { api.addParameter("base", base.get()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSend() { com.google.gerrit.client.changes.ChangeApi.createChange(project, getDestinationBranch(), getDestinationTopic(), message.getText(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { sent = true; hide(); com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(result.projectNameKey(), result.legacyId())); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { enableButtons(true); super.onFailure(caught); } }); }
public static void abandon(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String msg, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.MessageInput input = com.google.gerrit.client.changes.ChangeApi.MessageInput.create(); input.message(com.google.gerrit.client.changes.ChangeApi.emptyToNull(msg)); com.google.gerrit.client.changes.ChangeApi.call(project, id, "abandon").post(input, cb); }
void loadRevisionInfo() { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.actions(getProject().get(), changeId.get(), revision); call.background(); call.get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.ActionInfo> actionMap) { actionMap.copyKeysIntoChildren("id"); renderRevisionInfo(changeInfo, actionMap); } }); }
private void initEditMode(com.google.gerrit.client.info.ChangeInfo info, java.lang.String revision) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); if (info.status().isOpen()) { if (isEditModeEnabled(info, rev)) { editMode.setVisible(((fileTableMode) == (FileTable.Mode.REVIEW))); addFile.setVisible((!(editMode.isVisible()))); deleteFile.setVisible((!(editMode.isVisible()))); renameFile.setVisible((!(editMode.isVisible()))); reviewMode.setVisible((!(editMode.isVisible()))); addFileAction = new com.google.gerrit.client.change.AddFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile, files); deleteFileAction = new com.google.gerrit.client.change.DeleteFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile); renameFileAction = new com.google.gerrit.client.change.RenameFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile); } else { editMode.setVisible(false); addFile.setVisible(false); reviewMode.setVisible(false); } if (rev.isEdit()) { if (info.hasEditBasedOnCurrentPatchSet()) { publishEdit.setVisible(true); } else { rebaseEdit.setVisible(true); } deleteEdit.setVisible(true); } } else if (rev.isEdit()) { deleteEdit.setStyleName(style.highlight()); deleteEdit.setVisible(true); } } }
public static com.google.gerrit.client.rpc.RestApi revision(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id) { int cn = id.getParentKey().get(); java.lang.String revision = com.google.gerrit.client.changes.RevisionInfoCache.get(id); if (revision != null) { return ChangeApi.revision(project, cn, revision); } return ChangeApi.change(project, cn).view("revisions").id(id.get()); }
void set(com.google.gerrit.client.info.ChangeInfo info) { this.changeId = info.legacyId(); this.project = info.projectNameKey(); display(info); reviewerSuggestOracle.setChange(project, changeId); addReviewerIcon.setVisible(com.google.gerrit.client.Gerrit.isSignedIn()); }
@com.google.gwt.uibinder.client.UiHandler("restore") void onRestore(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if ((restoreAction) == null) { restoreAction = new com.google.gerrit.client.change.RestoreAction(restore, project, changeId); } restoreAction.show(); }
public static com.google.gerrit.client.rpc.RestApi change(@com.google.gerrit.common.Nullable java.lang.String project, int id) { if (project == null) { return new com.google.gerrit.client.rpc.RestApi("/changes/").id(java.lang.String.valueOf(id)); } else { return new com.google.gerrit.client.rpc.RestApi("/changes/").id(project, id); } }
private static void patch(java.lang.String token, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.client.DiffObject base, com.google.gerrit.reviewdb.client.Patch.Key id, com.google.gerrit.client.diff.DisplaySide side, int line, java.lang.String panelType) { java.lang.String panel = panelType; if (panel == null) { int c = token.lastIndexOf(','); panel = (0 <= c) ? token.substring((c + 1)) : ""; } if (("".equals(panel)) || ("cm".equals(panel))) { if (com.google.gerrit.client.Dispatcher.preferUnified()) { com.google.gerrit.client.Dispatcher.unified(token, project, base, id, side, line); } else { com.google.gerrit.client.Dispatcher.codemirror(token, base, project, id, side, line); } } else if ("sidebyside".equals(panel)) { com.google.gerrit.client.Dispatcher.codemirror(token, base, project, id, side, line); } else if ("unified".equals(panel)) { com.google.gerrit.client.Dispatcher.unified(token, project, base, id, side, line); } else if ("edit".equals(panel)) { if ((!(com.google.gerrit.reviewdb.client.Patch.isMagic(id.get()))) || (Patch.COMMIT_MSG.equals(id.get()))) { com.google.gerrit.client.Dispatcher.codemirrorForEdit(token, project, id, line); } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } } else { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); } }
private static void unified(final java.lang.String token, final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.client.DiffObject base, final com.google.gerrit.reviewdb.client.Patch.Key id, final com.google.gerrit.client.diff.DisplaySide side, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(project, base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); } }); }
private java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> loadComments(final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, com.google.gerrit.client.rpc.CallbackGroup group) { final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> r = new java.util.ArrayList<>(1); com.google.gerrit.client.changes.ChangeApi.comments(getProject().get(), changeId.get()).get(group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>> result) { r.add(com.google.gerrit.client.change.ChangeScreen.filterForRevision(result, rev._number())); history.addComments(result); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { } })); return r; }
void load(com.google.gerrit.client.rpc.CallbackGroup group) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.comments(Project.NameKey.asStringOrNull(project), base.asPatchSetId(), group.add(publishedBase())); } com.google.gerrit.client.changes.CommentApi.comments(Project.NameKey.asStringOrNull(project), revision, group.add(publishedRevision())); if (com.google.gerrit.client.Gerrit.isSignedIn()) { if (base.isPatchSet()) { com.google.gerrit.client.changes.CommentApi.drafts(Project.NameKey.asStringOrNull(project), base.asPatchSetId(), group.add(draftsBase())); } com.google.gerrit.client.changes.CommentApi.drafts(Project.NameKey.asStringOrNull(project), revision, group.add(draftsRevision())); } }
static void call(com.google.gwt.user.client.ui.Button b, com.google.gerrit.reviewdb.client.Project.NameKey project) { b.setEnabled(false); com.google.gerrit.client.changes.ChangeApi.createChange(project.get(), RefNames.REFS_CONFIG, null, AdminConstants.I.editConfigMessage(), null, new com.google.gerrit.client.rpc.GerritCallback<com.google.gerrit.client.info.ChangeInfo>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(project, new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), "project.config")); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { b.setEnabled(true); super.onFailure(caught); } }); }
public static void message(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, java.lang.String message, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gerrit.client.changes.ChangeApi.CherryPickInput input = com.google.gerrit.client.changes.ChangeApi.CherryPickInput.create(); input.setMessage(message); com.google.gerrit.client.changes.ChangeApi.call(project, id, commit, "message").post(input, cb); }
@java.lang.Override protected void onRequestSuggestions(com.google.gerrit.client.change.Request req, com.google.gerrit.client.change.Callback cb) { com.google.gerrit.client.changes.ChangeApi.suggestReviewers(project.get(), changeId.get(), req.getQuery(), req.getLimit(), false).get(new com.google.gerrit.client.rpc.GerritCallback<com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo>>() { @java.lang.Override public void onSuccess(com.google.gwt.core.client.JsArray<com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo> result) { java.util.List<com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion> r = new java.util.ArrayList(result.length()); for (com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo reviewer : com.google.gerrit.client.rpc.Natives.asList(result)) { r.add(new com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion(reviewer, req.getQuery())); } cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } @java.lang.Override public void onFailure(java.lang.Throwable err) { java.util.List<com.google.gerrit.client.change.Suggestion> r = java.util.Collections.emptyList(); cb.onSuggestionsReady(req, new com.google.gerrit.client.change.Response(r)); } }); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.client.Dispatcher.toEditScreen(project, new com.google.gerrit.reviewdb.client.PatchSet.Id(result.legacyId(), 1), "project.config")); }
public static void topic(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String topic, com.google.gwt.user.client.rpc.AsyncCallback<java.lang.String> cb) { com.google.gerrit.client.rpc.RestApi call = com.google.gerrit.client.changes.ChangeApi.call(project, id, "topic"); topic = com.google.gerrit.client.changes.ChangeApi.emptyToNull(topic); if (topic != null) { com.google.gerrit.client.changes.ChangeApi.TopicInput input = com.google.gerrit.client.changes.ChangeApi.TopicInput.create(); input.topic(topic); call.put(input, com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } else { call.delete(com.google.gerrit.client.rpc.NativeString.unwrap(cb)); } }
public static void rebase(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, java.lang.String base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.info.ChangeInfo> cb) { com.google.gerrit.client.changes.ChangeApi.RebaseInput rebaseInput = com.google.gerrit.client.changes.ChangeApi.RebaseInput.create(); rebaseInput.setBase(base); com.google.gerrit.client.changes.ChangeApi.call(project, id, commit, "rebase").post(rebaseInput, cb); }
public static com.google.gerrit.client.rpc.RestApi hashtags(@com.google.gerrit.common.Nullable java.lang.String project, int changeId) { return com.google.gerrit.client.changes.ChangeApi.change(project, changeId).view("hashtags"); }
@com.google.gwt.uibinder.client.UiHandler("save") void onSave(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.changes.ChangeApi.topic(project.get(), psId.getParentKey().get(), input.getValue().trim(), new com.google.gerrit.client.rpc.GerritCallback<java.lang.String>() { @java.lang.Override public void onSuccess(java.lang.String result) { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChange(project, psId)); } }); onCancel(null); }
void onReply(com.google.gerrit.client.info.ChangeInfo.MessageInfo msg) { if ((popup) != null) { popup.hide(); return; } if ((replyBox) == null) { replyBox = new com.google.gerrit.client.change.ReplyBox(clp, project, psId, revision, allLabels, permittedLabels); allLabels = null; permittedLabels = null; } if (msg != null) { replyBox.replyTo(msg); } final com.google.gwt.user.client.ui.PopupPanel p = new com.google.gwt.user.client.ui.PopupPanel(true, false); p.setStyleName(style.replyBox()); p.addAutoHidePartner(replyButton.getElement()); p.addAutoHidePartner(quickApproveButton.getElement()); p.addCloseHandler(new com.google.gwt.event.logical.shared.CloseHandler<com.google.gwt.user.client.ui.PopupPanel>() { @java.lang.Override public void onClose(com.google.gwt.event.logical.shared.CloseEvent<com.google.gwt.user.client.ui.PopupPanel> event) { if ((popup) == p) { popup = null; if ((hasDraftComments) || (replyBox.hasMessage())) { replyButton.setStyleName(style.highlight()); } } } }); p.add(replyBox); com.google.gwt.user.client.Window.scrollTo(0, 0); replyButton.removeStyleName(style.highlight()); p.showRelativeTo(replyButton); com.google.gwtexpui.globalkey.client.GlobalKey.dialog(p); popup = p; }
public static void onAction(com.google.gerrit.client.info.ChangeInfo change, com.google.gerrit.client.info.ChangeInfo.RevisionInfo revision, com.google.gerrit.client.info.ActionInfo action, com.google.gerrit.client.actions.ActionButton button) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(change.project(), change.legacyId().get(), revision.name()).view(action.id()); com.google.gwt.core.client.JavaScriptObject f = com.google.gerrit.client.api.RevisionGlue.get(action.id()); if (f != null) { com.google.gerrit.client.api.ActionContext c = com.google.gerrit.client.api.ActionContext.create(api); c.set(action); c.set(change); c.set(revision); c.button(button); com.google.gerrit.client.api.ApiGlue.invoke(f, c); } else { com.google.gerrit.client.api.DefaultActions.invoke(change, action, api); } }
@java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.diff.Unified(project, base, com.google.gerrit.client.DiffObject.patchSet(id.getParentKey()), id.get(), side, line)); }
public static com.google.gerrit.client.diff.DiffApi diff(@com.google.gerrit.common.Nullable java.lang.String project, com.google.gerrit.reviewdb.client.PatchSet.Id id, java.lang.String path) { return new com.google.gerrit.client.diff.DiffApi(com.google.gerrit.client.changes.ChangeApi.revision(project, id).view("files").id(path).view("diff")); }
public static com.google.gerrit.client.rpc.RestApi detail(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.call(project, id, "detail"); }
public static void publish(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String commit, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gwt.core.client.JavaScriptObject> cb) { com.google.gwt.core.client.JavaScriptObject in = com.google.gwt.core.client.JavaScriptObject.createObject(); com.google.gerrit.client.changes.ChangeApi.call(project, id, commit, "publish").post(in, cb); }
public static com.google.gerrit.client.rpc.RestApi comments(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.call(project, id, "comments"); }
private void loadFileList(final com.google.gerrit.client.DiffObject base, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo baseRev, final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev, final java.sql.Timestamp myLastReply, com.google.gerrit.client.rpc.CallbackGroup group, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> comments, final java.util.List<com.google.gerrit.client.rpc.NativeMap<com.google.gwt.core.client.JsArray<com.google.gerrit.client.changes.CommentInfo>>> drafts) { com.google.gerrit.client.diff.DiffApi.list(getProject().get(), changeId.get(), rev.name(), baseRev, group.add(new com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>>() { @java.lang.Override public void onSuccess(com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo> m) { files.set(base, new com.google.gerrit.reviewdb.client.PatchSet.Id(changeId, rev._number()), getProject(), style, reply, fileTableMode, ((edit) != null)); files.setValue(m, myLastReply, (comments != null ? comments.get(0) : null), (drafts != null ? drafts.get(0) : null)); } @java.lang.Override public void onFailure(java.lang.Throwable caught) { files.showError(caught); } })); }
public void setChange(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id changeId) { this.project = project; this.changeId = changeId; }
@com.google.gwt.uibinder.client.UiHandler("unmarkPrivate") void onUnmarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.unmarkPrivate(project, changeId, unmarkPrivate); }
@com.google.gwt.uibinder.client.UiHandler("deleteChange") void onDeleteChange(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { if (com.google.gwt.user.client.Window.confirm(Resources.C.deleteChange())) { com.google.gerrit.client.change.ChangeActions.delete(project, changeId, deleteChange); } }
@com.google.gwt.uibinder.client.UiHandler("markPrivate") void onMarkPrivate(@java.lang.SuppressWarnings("unused") com.google.gwt.event.dom.client.ClickEvent e) { com.google.gerrit.client.change.ChangeActions.markPrivate(project, changeId, markPrivate); }
public static void list(@com.google.gerrit.common.Nullable java.lang.String project, int id, java.lang.String revision, com.google.gerrit.client.info.ChangeInfo.RevisionInfo base, com.google.gwt.user.client.rpc.AsyncCallback<com.google.gerrit.client.rpc.NativeMap<com.google.gerrit.client.info.FileInfo>> cb) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision(project, id, revision).view("files"); if (base != null) { if ((base._number()) < 0) { api.addParameter("parent", (-(base._number()))); } else { api.addParameter("base", base.name()); } } api.get(com.google.gerrit.client.rpc.NativeMap.copyKeysIntoChildren("path", cb)); }
@java.lang.Override public void onSuccess(com.google.gerrit.client.info.ChangeInfo info) { info.init(); if ((project) == null) { project = info.projectNameKey(); } initCurrentRevision(info); final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev = info.revision(revision); com.google.gerrit.client.rpc.CallbackGroup group = new com.google.gerrit.client.rpc.CallbackGroup(); loadCommit(rev, group); group.addListener(new com.google.gerrit.client.rpc.GerritCallback<java.lang.Void>() { @java.lang.Override public void onSuccess(java.lang.Void result) { if ((base.isBase()) && (rev.isMerge())) { base = com.google.gerrit.client.DiffObject.parse(info.legacyId(), com.google.gerrit.client.Gerrit.getUserPreferences().defaultBaseForMerges().getBase()); } loadConfigInfo(info, base); com.google.gwt.core.client.JsArray<com.google.gerrit.client.info.ChangeInfo.MessageInfo> mAr = info.messages(); for (int i = 0; i < (mAr.length()); i++) { if ((mAr.get(i).tag()) != null) { hideTaggedComments.setVisible(true); break; } } } }); group.done(); }
public static java.lang.String toPatch(@com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String type, com.google.gerrit.client.DiffObject diffBase, com.google.gerrit.reviewdb.client.Patch.Key id) { return com.google.gerrit.client.Dispatcher.toPatch(type, project, diffBase, id.getParentKey(), id.get(), null, 0); }
private static void codemirrorForEdit(final java.lang.String token, @com.google.gerrit.common.Nullable final com.google.gerrit.reviewdb.client.Project.NameKey project, final com.google.gerrit.reviewdb.client.Patch.Key id, final int line) { com.google.gwt.core.client.GWT.runAsync(new com.google.gerrit.client.Dispatcher.AsyncSplit(token) { @java.lang.Override public void onSuccess() { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.editor.EditScreen(project, id, line)); } }); }
public static com.google.gerrit.client.rpc.RestApi editWithCommands(@com.google.gerrit.common.Nullable java.lang.String project, int id) { return com.google.gerrit.client.changes.ChangeApi.edit(project, id).addParameterTrue("download-commands"); }
private void upToChange() { com.google.gerrit.client.Gerrit.display(com.google.gerrit.common.PageLinks.toChangeInEditMode(projectKey, revision.getParentKey())); }
private boolean handlePolyGerritParam(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res) throws java.io.IOException { if ((!(options.enableGwtUi())) || (!("GET".equals(req.getMethod())))) { return false; } boolean redirect = false; java.lang.String param = req.getParameter("polygerrit"); if ("1".equals(param)) { setPolyGerritCookie(req, res, UiType.POLYGERRIT); redirect = true; } else if ("0".equals(param)) { setPolyGerritCookie(req, res, UiType.GWT); redirect = true; } if (redirect) { res.sendRedirect(req.getRequestURL().toString()); } return redirect; }
void addFile(java.lang.String dirPath, java.lang.String filePath, java.lang.String[] lines) { com.googlesource.gerrit.plugins.findowners.Parser.Result result = com.googlesource.gerrit.plugins.findowners.Parser.parseFile(dirPath, filePath, lines); if (result.stopLooking) { stopLooking.add(dirPath); } addPreferredEmails(result.owner2paths.keySet()); for (java.lang.String owner : result.owner2paths.keySet()) { java.lang.String email = preferredEmails.get(owner); for (java.lang.String path : result.owner2paths.get(owner)) { addOwnerPathPair(email, path); } } if (com.googlesource.gerrit.plugins.findowners.Config.getReportSyntaxError()) { result.warnings.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.warn(w)); result.errors.forEach(( w) -> com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error(w)); } }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Accounts accounts, org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.query.change.ChangeData changeData) throws com.google.gwtorm.server.OrmException { return get(accountCache, accounts, repo, changeData, changeData.currentPatchSet().getId().get()); }
@java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(accountCache, accounts, key, repository, project, branch, files); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Accounts accounts, org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.query.change.ChangeData changeData, int patchset) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change().getProject(); java.lang.String branch = changeData.change().getDest().get(); java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey(changeData.getId().get(), patchset, branch); return get(accountCache, accounts, dbKey, repository, project, branch, changeData.currentFilePaths()); }
com.googlesource.gerrit.plugins.findowners.OwnersDb get(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Accounts accounts, java.lang.String key, org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String branch, java.util.Collection<java.lang.String> files) { if ((dbCache) == null) { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(accountCache, accounts, key, repository, project, branch, files); } try { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(((((("Get from cash " + (dbCache)) + ", key=") + key) + ", cache size=") + (dbCache.size()))); return dbCache.get(key, new java.util.concurrent.Callable<com.googlesource.gerrit.plugins.findowners.OwnersDb>() { @java.lang.Override public com.googlesource.gerrit.plugins.findowners.OwnersDb call() { com.googlesource.gerrit.plugins.findowners.Cache.log.trace(("Create new OwnersDb, key=" + key)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(accountCache, accounts, key, repository, project, branch, files); } }); } catch (java.util.concurrent.ExecutionException e) { com.googlesource.gerrit.plugins.findowners.Cache.log.error(("Cache.get has exception: " + e)); return new com.googlesource.gerrit.plugins.findowners.OwnersDb(accountCache, accounts, key, repository, project, branch, files); } }
@org.junit.Test public void actionApplyTest() throws java.lang.Exception { com.googlesource.gerrit.plugins.findowners.Cache cache = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().init(0, 10); assertThat(cache.size()).isEqualTo(0); com.google.gerrit.extensions.common.ChangeInfo changeInfo = newChangeInfo("test Action.apply"); com.google.gerrit.server.change.ChangeResource cr = parseChangeResource(changeInfo.changeId); com.googlesource.gerrit.plugins.findowners.Action.Parameters param = new com.googlesource.gerrit.plugins.findowners.Action.Parameters(); com.googlesource.gerrit.plugins.findowners.Action action = new com.googlesource.gerrit.plugins.findowners.Action("find-owners", null, null, null, changeDataFactory, accountCache, accounts, repoManager); com.google.gerrit.extensions.restapi.Response<com.googlesource.gerrit.plugins.findowners.RestResult> response = action.apply(db, cr, param); com.googlesource.gerrit.plugins.findowners.RestResult result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, false); param.debug = true; response = action.apply(db, cr, param); result = response.value(); com.googlesource.gerrit.plugins.findowners.FindOwnersIT.verifyRestResult(result, 1, 1, changeInfo._number, true); assertThat(result.dbgmsgs.user).isEqualTo("?"); assertThat(result.dbgmsgs.project).isEqualTo(changeInfo.project); assertThat(result.dbgmsgs.branch).contains(changeInfo.branch); assertThat(result.dbgmsgs.path2owners).isEmpty(); assertThat(result.dbgmsgs.owner2paths).isEmpty(); assertThat(result.file2owners).isEmpty(); assertThat(result.reviewers).isEmpty(); assertThat(result.owners).isEmpty(); assertThat(result.files).isEmpty(); assertThat(cache.size()).isEqualTo(0); }
int findApproval(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Accounts accounts) throws com.google.gwtorm.server.OrmException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExemptFromOwnerApproval(changeData)) { return 0; } com.googlesource.gerrit.plugins.findowners.OwnersDb db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(accountCache, accounts, repository, changeData); if ((db.getNumOwners()) <= 0) { return 0; } if ((minVoteLevel) <= 0) { minVoteLevel = com.googlesource.gerrit.plugins.findowners.Config.getMinOwnerVoteLevel(changeData); } com.googlesource.gerrit.plugins.findowners.Checker.log.trace(("findApproval db key = " + (db.key))); return findApproval(accountCache, db); }
public static int findApproval(com.googlecode.prolog_cafe.lang.Prolog engine, int minVoteLevel) { try { com.google.gerrit.server.account.AccountCache accountCache = StoredValues.ACCOUNT_CACHE.get(engine); com.google.gerrit.server.account.Accounts accounts = StoredValues.ACCOUNTS.get(engine); com.google.gerrit.server.query.change.ChangeData changeData = StoredValues.CHANGE_DATA.get(engine); org.eclipse.jgit.lib.Repository repository = StoredValues.REPOSITORY.get(engine); return new com.googlesource.gerrit.plugins.findowners.Checker(repository, changeData, minVoteLevel).findApproval(accountCache, accounts); } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.findowners.Checker.log.error("Exception", e); return 0; } }
void addPreferredEmails(java.util.Set<java.lang.String> ownerEmails) { java.util.List<java.lang.String> owners = new java.util.ArrayList<java.lang.String>(ownerEmails); owners.removeIf(( o) -> (preferredEmails.get(o)) != null); if ((owners.size()) > 0) { java.lang.String[] emails = new java.lang.String[owners.size()]; owners.toArray(emails); com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id> email2ids = null; try { email2ids = accounts.byEmails(emails); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error("accounts.byEmails failed with exception: ", e); } for (java.lang.String owner : emails) { java.lang.String email = owner; try { if (email2ids == null) { errors.add(owner); } else { java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> ids = email2ids.get(owner); if ((ids == null) || ((ids.size()) != 1)) { errors.add(owner); } else { email = accountCache.get(ids.iterator().next()).getAccount().getPreferredEmail(); } } } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.findowners.OwnersDb.log.error(("Fail to find preferred email of " + owner), e); errors.add(owner); } preferredEmails.put(owner, email); } } }
static java.lang.String nameOf(java.lang.String name) { if (name.endsWith(".disabled")) { name = name.substring(0, name.lastIndexOf('.')); } int ext = name.lastIndexOf('.'); return 0 < ext ? name.substring(0, ext) : name; }
static java.util.List<java.nio.file.Path> listPlugins(java.nio.file.Path pluginsDir) throws java.io.IOException { return com.google.gerrit.server.plugins.PluginUtil.listPlugins(pluginsDir, null); }
private Change.Id parseRevertOf(com.google.gerrit.server.notedb.ChangeNotesCommit commit) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String footer = parseOneFooter(commit, com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_REVERT_OF); if (footer == null) { return null; } java.lang.Integer revertOf = com.google.common.primitives.Ints.tryParse(footer); if (revertOf == null) { throw invalidFooter(com.google.gerrit.server.notedb.ChangeNoteUtil.FOOTER_REVERT_OF, footer); } return new com.google.gerrit.reviewdb.client.Change.Id(revertOf); }
@org.junit.Test public void setRevertOfPersistsValue() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change changeToRevert = newChange(); com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange(project, changeOwner.getAccountId()); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); update.setChangeId(c.getKey().get()); update.setRevertOf(changeToRevert.getId().get()); update.commit(); assertThat(newNotes(c).getRevertOf()).isEqualTo(changeToRevert.getId()); }
@org.junit.Test public void setRevertOfToCurrentChangeFails() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange(); com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate(c, changeOwner); exception.expect(java.lang.IllegalArgumentException.class); exception.expectMessage("A change cannot revert itself"); update.setRevertOf(c.getId().get()); }
public void setRevertOf(int revertOf) { int ownId = getChange().getId().get(); checkArgument((ownId != revertOf), "A change cannot revert itself"); this.revertOf = revertOf; rootOnly = true; }
private com.google.gerrit.server.notedb.ChangeNotesState buildState() { return com.google.gerrit.server.notedb.ChangeNotesState.create(tip.copy(), id, new com.google.gerrit.reviewdb.client.Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, ((assignee) != null ? assignee.orElse(null) : null), status, com.google.common.collect.Sets.newLinkedHashSet(com.google.common.collect.Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), com.google.gerrit.server.ReviewerSet.fromTable(com.google.common.collect.Tables.transpose(reviewers)), com.google.gerrit.server.ReviewerByEmailSet.fromTable(com.google.common.collect.Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf); }
@org.junit.Test public void revert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit(); ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get(); java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> sourceMessages = new java.util.ArrayList(gApi.changes().id(r.getChangeId()).get().messages); assertThat(sourceMessages).hasSize(4); java.lang.String expectedMessage = java.lang.String.format("Created a revert of this change as %s", revertChange.changeId); assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage); assertThat(revertChange.messages).hasSize(1); assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1."); assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "plugins.allowRemoteAdmin", value = "true") public void pluginManagement() throws java.lang.Exception { assertThat(list().get()).isEmpty(); assertThat(list().all().get()).isEmpty(); com.google.gerrit.extensions.api.plugins.PluginApi test; com.google.gerrit.extensions.common.PluginInfo info; com.google.gerrit.extensions.common.InstallPluginInput input = new com.google.gerrit.extensions.common.InstallPluginInput(); input.raw = com.google.gerrit.common.RawInputUtil.create(com.google.gerrit.acceptance.api.plugin.PluginIT.JS_PLUGIN_CONTENT); for (java.lang.String plugin : com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS) { test = gApi.plugins().install((plugin + ".js"), input); assertThat(test).isNotNull(); info = test.get(); assertThat(info.id).isEqualTo(plugin); assertThat(info.disabled).isNull(); } assertPlugins(list().get(), com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS); test = gApi.plugins().name("plugin-a"); test.disable(); test = gApi.plugins().name("plugin-a"); info = test.get(); assertThat(info.disabled).isTrue(); assertPlugins(list().get(), com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.subList(1, com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS.size())); assertPlugins(list().all().get(), com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS); test.enable(); test = gApi.plugins().name("plugin-a"); info = test.get(); assertThat(info.disabled).isNull(); assertPlugins(list().get(), com.google.gerrit.acceptance.api.plugin.PluginIT.PLUGINS); }
public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> display(@com.google.gerrit.common.Nullable java.io.PrintWriter stdout) { java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = new java.util.TreeMap<>(); java.util.stream.Stream<com.google.gerrit.server.plugins.Plugin> s = com.google.common.collect.Streams.stream(pluginLoader.getPlugins(all)).sorted(java.util.Comparator.comparing(Plugin::getName)); if ((start) > 0) { s = s.skip(start); } if ((limit) > 0) { s = s.limit(limit); } java.util.List<com.google.gerrit.server.plugins.Plugin> plugins = s.collect(java.util.stream.Collectors.toList()); if (!(format.isJson())) { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (com.google.gerrit.server.plugins.Plugin p : plugins) { com.google.gerrit.extensions.common.PluginInfo info = com.google.gerrit.server.plugins.ListPlugins.toPluginInfo(p); if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format("%-30s %-10s %-8s %s\n", p.getName(), com.google.common.base.Strings.nullToEmpty(info.version), (p.isDisabled() ? "DISABLED" : "ENABLED"), p.getSrcFile().getFileName()); } } if (stdout == null) { return output; } else if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } stdout.flush(); return null; }
public com.google.gerrit.server.update.BatchUpdate create(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.CurrentUser user, java.sql.Timestamp when) { if (migration.disableChangeReviewDb()) { return noteDbBatchUpdateFactory.create(db, project, user, when); } return reviewDbBatchUpdateFactory.create(db, project, user, when); }
private void setChangeId(int id) { changeId = new com.google.gerrit.reviewdb.client.Change.Id(id); ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(((magicBranch.isPrivate) || ((receiveConfig.privateByDefault) && (!(magicBranch.removePrivate))))).setWorkInProgress(magicBranch.workInProgress).setValidate(false); if (magicBranch.draft) { ins.setDraft(magicBranch.draft); } else if (magicBranch.merged) { ins.setStatus(Change.Status.MERGED); } cmd = new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName()); if ((rp.getPushCertificate()) != null) { ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature()); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.privateByDefault", value = "true") public void pushWithPrivateByDefaultEnabled() throws java.lang.Exception { assertThat(createChange().getChange().change().isPrivate()).isEqualTo(true); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.privateByDefault", value = "true") public void createChangeWithPrivateByDefaultEnabled() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true); }
@org.junit.Test public void createChangeWithPrivateByDefaultDisabled() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().create(new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change")).get(); assertThat(info.isPrivate).isNull(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.privateByDefault", value = "true") public void createChangeBypassPrivateByDefaultEnabled() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = false; assertThat(gApi.changes().create(input).get().isPrivate).isNull(); }
@org.junit.Test public void pushWithPrivateByDefaultDisabled() throws java.lang.Exception { assertThat(createChange().getChange().change().isPrivate()).isEqualTo(false); }
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(user, id.substring(0, z), n.intValue()); } } if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return find(new com.google.gerrit.reviewdb.client.Change.Id(n), user); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeControls(query.byBranchKey(t.branch(), t.id()), user); } } return asChangeControls(query.byKeyPrefix(id), user); }
boolean isMergedIntoVisibleRef(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Collection<org.eclipse.jgit.lib.Ref> unfilteredRefs) throws java.io.IOException { com.google.gerrit.server.git.VisibleRefFilter filter = refFilter.create(state, repo); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> m = com.google.common.collect.Maps.newHashMapWithExpectedSize(unfilteredRefs.size()); for (org.eclipse.jgit.lib.Ref r : unfilteredRefs) { m.put(r.getName(), r); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = filter.filter(m, true); return com.google.gerrit.server.change.IncludedInResolver.includedInAny(repo, rw, commit, refs.values()); }
com.google.gerrit.common.EventListener getEventListener();
public void removeGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> foundGroup = groups.get(db, groupUuid); if (!(foundGroup.isPresent())) { return; } com.google.gerrit.reviewdb.client.AccountGroup group = foundGroup.get(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { boolean isMember = groups.isMember(db, group, accountId); if (isMember) { com.google.gerrit.reviewdb.client.AccountGroupMember.Key key = new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId); membersToRemove.add(new com.google.gerrit.reviewdb.client.AccountGroupMember(key)); } } if (membersToRemove.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), membersToRemove); } db.accountGroupMembers().delete(membersToRemove); for (com.google.gerrit.reviewdb.client.AccountGroupMember member : membersToRemove) { accountCache.evict(member.getAccountId()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.accounts.AccountInput input) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply((input != null ? input : new com.google.gerrit.extensions.api.accounts.AccountInput())); }
public java.util.stream.Stream<com.google.gerrit.reviewdb.client.AccountGroup.Id> getParentGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> accountGroupByIds = db.accountGroupById().byIncludeUUID(includedGroupUuid); return com.google.common.collect.Streams.stream(accountGroupByIds).map(AccountGroupById::getGroupId); }
private boolean isMember(com.google.gerrit.reviewdb.client.AccountGroup parent, com.google.gerrit.common.data.GroupDescription.Basic member) throws com.google.gwtorm.server.OrmException { return groups.isIncluded(dbProvider.get(), parent.getId(), member.getGroupUUID()); }
public boolean isIncluded(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentId, com.google.gerrit.reviewdb.client.AccountGroup.UUID childGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentId, childGroupUuid); return (db.accountGroupById().get(key)) != null; }
public java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getIncludes() { return includes; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutOwner.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup accountGroup = resource.toAccountGroup(); if (accountGroup == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("owner is required"); } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); if (!(accountGroup.getOwnerGroupUUID().equals(owner.getGroupUUID()))) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = resource.getGroupUUID(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, ( group) -> group.setOwnerGroupUUID(owner.getGroupUUID())); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } } return json.format(owner); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.PutDescription.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.group.PutDescription.Input(); } com.google.gerrit.reviewdb.client.AccountGroup accountGroup = resource.toAccountGroup(); if (accountGroup == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } else if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not group owner"); } java.lang.String newDescription = com.google.common.base.Strings.emptyToNull(input.description); if (!(java.util.Objects.equals(accountGroup.getDescription(), newDescription))) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = resource.getGroupUUID(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, ( group) -> group.setDescription(newDescription)); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid)); } } return com.google.common.base.Strings.isNullOrEmpty(input.description) ? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.ok(input.description); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> getMembers() { return members; }
public java.util.stream.Stream<com.google.gerrit.reviewdb.client.AccountGroup.Id> getParentGroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid) throws com.google.gwtorm.server.OrmException { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> accountGroupByIds = db.accountGroupById().byIncludeUUID(includedGroupUuid); return com.google.common.collect.Streams.stream(accountGroupByIds).map(AccountGroupById::getGroupId); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return groups.getParentGroups(db, key).map(groupCache::get).map(AccountGroup::getGroupUUID).filter(java.util.Objects::nonNull).collect(toImmutableList()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup internalGroup = resource.toAccountGroup(); if (internalGroup == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } input = com.google.gerrit.server.group.AddMembers.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(("Cannot delete members from group " + (internalGroup.getName()))); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = new java.util.HashSet<>(); for (java.lang.String nameOrEmail : input.members) { com.google.gerrit.reviewdb.client.Account a = accounts.parse(nameOrEmail).getAccount(); membersToRemove.add(a.getId()); } groupsUpdateProvider.get().removeGroupMembers(db.get(), internalGroup.getGroupUUID(), membersToRemove); return com.google.gerrit.extensions.restapi.Response.none(); }
private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } args.groups.getMembers(db, ig.getGroupUUID()).forEach(matching.accounts::add); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) { if (seen.add(m)) { q.add(m); } } } }
public com.google.gerrit.reviewdb.client.AccountGroup getExistingGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName accountGroupName = db.accountGroupNames().get(groupName); if (accountGroupName == null) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupName.toString()); } com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = accountGroupName.getId(); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); if (group == null) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupName.toString()); } return group; }
public void addGroupMember(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = getExistingGroup(db, groupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); if (com.google.gerrit.pgm.init.GroupsOnInit.isMember(db, groupId, accountId)) { return; } db.accountGroupMembers().insert(com.google.common.collect.ImmutableList.of(new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)))); }
private void deliverToMembers(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List matching, com.google.gerrit.reviewdb.client.AccountGroup.UUID startUUID) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = args.db.get(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen = new java.util.HashSet<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> q = new java.util.ArrayList<>(); seen.add(startUUID); q.add(startUUID); while (!(q.isEmpty())) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = q.remove(((q.size()) - 1)); com.google.gerrit.common.data.GroupDescription.Basic group = args.groupBackend.get(uuid); if (!(com.google.common.base.Strings.isNullOrEmpty(group.getEmailAddress()))) { matching.emails.add(new com.google.gerrit.server.mail.Address(group.getEmailAddress())); continue; } com.google.gerrit.reviewdb.client.AccountGroup ig = com.google.gerrit.common.data.GroupDescriptions.toAccountGroup(group); if (ig == null) { continue; } args.groups.getMembers(db, ig.getId()).forEach(matching.accounts::add); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) { if (seen.add(m)) { q.add(m); } } } }
private void addGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup group, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> newMembers = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountIds) { boolean isMember = groups.isMember(db, group, accountId); if (!isMember) { com.google.gerrit.reviewdb.client.AccountGroupMember.Key key = new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId); newMembers.add(new com.google.gerrit.reviewdb.client.AccountGroupMember(key)); } } if (newMembers.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers); } db.accountGroupMembers().insert(newMembers); for (com.google.gerrit.reviewdb.client.AccountGroupMember newMember : newMembers) { accountCache.evict(newMember.getAccountId()); } }
public void addGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup group) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName gn = new com.google.gerrit.reviewdb.client.AccountGroupName(group); db.accountGroupNames().insert(com.google.common.collect.ImmutableList.of(gn)); db.accountGroups().insert(com.google.common.collect.ImmutableList.of(group)); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> conflicts(java.lang.String value) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.Change> changes = parseChange(value); java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> or = new java.util.ArrayList(changes.size()); for (com.google.gerrit.reviewdb.client.Change c : changes) { or.add(com.google.gerrit.server.query.change.ConflictsPredicate.create(args, value, c)); } return com.google.gerrit.server.query.Predicate.or(or); }
@java.lang.SuppressWarnings("unchecked") @java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("change %s not found", id.get())); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error("cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("internal server error"); } }
public void addChange(java.lang.String id, java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.change.ChangeResource> changes, com.google.gerrit.server.project.ProjectControl projectControl, boolean useIndex) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> matched = (useIndex) ? changeFinder.find(id, currentUser) : changeFromNotesFactory(id, currentUser); java.util.List<com.google.gerrit.server.project.ChangeControl> toAdd = new java.util.ArrayList(changes.size()); boolean canMaintainServer; try { permissionBackend.user(currentUser).check(GlobalPermission.MAINTAIN_SERVER); canMaintainServer = true; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e) { canMaintainServer = false; } for (com.google.gerrit.server.project.ChangeControl ctl : matched) { if (((!(changes.containsKey(ctl.getId()))) && (inProject(projectControl, ctl.getProject()))) && (canMaintainServer || (permissionBackend.user(currentUser).change(ctl.getNotes()).database(db).test(ChangePermission.READ)))) { toAdd.add(ctl); } } if (toAdd.isEmpty()) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) + "\" no such change")); } else if ((toAdd.size()) > 1) { throw new com.google.gerrit.sshd.BaseCommand.UnloggedFailure(1, (("\"" + id) + "\" matches multiple changes")); } com.google.gerrit.server.project.ChangeControl ctl = toAdd.get(0); changes.put(ctl.getId(), changesCollection.parse(ctl)); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change; try { change = cd.change(); if (change == null) { return false; } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); com.google.gerrit.server.project.ChangeControl cc = changeControl.controlFor(notes, user); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gwtorm.server.OrmException("unable to check permissions", e); } if (visible) { cd.cacheVisibleTo(cc); return true; } return false; }
@com.google.gerrit.common.Nullable private java.lang.String canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.lang.String userId) { if (canUpdate()) { return null; } else if (projectControl.isReachableFromHeadsOrTags(repo, commit)) { return null; } return ((userId + " lacks permission ") + (com.google.gerrit.common.data.Permission.PUSH)) + " for creating new commit object"; }
public boolean isReachableFrom(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { refs = refFilter.create(state, repo).filter(refs, true); return com.google.gerrit.server.change.IncludedInResolver.includedInAny(repo, rw, commit, refs.values()); } catch (java.io.IOException e) { com.google.gerrit.server.project.CommitsCollection.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getProject().getNameKey()), e); return false; } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id.encoded(), user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(canRead(ctl))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(ctl); }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getProject().getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot look up change for commit " + (commit.name())) + " in ") + project), e); } return isReachableFrom(state, repo, commit, repo.getAllRefs()); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.project.ChangeControl> ctls = changeFinder.find(id, user.get()); if (ctls.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((ctls.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.project.ChangeControl ctl = ctls.get(0); if (!(canRead(ctl))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(ctl); }
public void unlink(com.google.gerrit.reviewdb.client.Account.Id from, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (extIdKeys.isEmpty()) { return; } try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.ArrayList(extIdKeys.size()); for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(extIdKey); if (extId != null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (extIdKey.get())) + "' in use by another account")); } extIds.add(extId); } else { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (extIdKey.get())) + "' not found")); } } externalIdsUpdateFactory.create().delete(extIds); if (extIds.stream().anyMatch(( e) -> (e.email()) != null)) { accountsUpdateFactory.create().update(db, from, ( a) -> { if ((a.getPreferredEmail()) != null) { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if (a.getPreferredEmail().equals(extId.email())) { a.setPreferredEmail(null); break; } } } }); } } }
@org.junit.Test public void lookUpByEmail() throws java.lang.Exception { assertEmail(emails.getAccountFor(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(emails.getAccountFor(email), admin); assertThat(emails.getAccountFor(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(emails.getAccountFor(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(emails.getAccountFor("non-existing@example.com")).isEmpty(); com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id> byEmails = emails.getAccountsFor(admin.email, user.email); assertEmail(byEmails.get(admin.email), admin); assertEmail(byEmails.get(user.email), user); }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(who.getExternalIdKey()); if (extId != null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress()) != null) { accountsUpdateFactory.create().update(db, to, ( a) -> { if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); } }); } } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); } }
@org.junit.Test public void lookUpByEmail() throws java.lang.Exception { assertEmail(emails.getAccountFor(admin.email), admin); java.lang.String email = "foo.bar@example.com"; externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(ExternalId.Key.parse("foo:bar"), admin.id, email)); assertEmail(emails.getAccountFor(email), admin); assertThat(emails.getAccountFor(admin.email.toUpperCase(java.util.Locale.US))).isEmpty(); assertThat(emails.getAccountFor(admin.email.substring(0, admin.email.indexOf('@')))).isEmpty(); assertThat(emails.getAccountFor("non-existing@example.com")).isEmpty(); com.google.common.collect.ImmutableSetMultimap<java.lang.String, com.google.gerrit.reviewdb.client.Account.Id> byEmails = emails.getAccountsFor(admin.email, user.email); assertEmail(byEmails.get(admin.email), admin); assertEmail(byEmails.get(user.email), user); }
@java.lang.Override public void advertiseRefs(org.eclipse.jgit.transport.BaseReceivePack rp) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { com.google.gerrit.server.git.receive.ReceiveCommitsAdvertiseRefsHook.Result r = advertiseRefs(com.google.gerrit.server.git.receive.HookUtil.ensureAllRefsAdvertised(rp)); rp.setAdvertisedRefs(r.allRefs(), r.additionalHaves()); }
private void showDoc(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse res, com.google.gitiles.GitilesView view, com.google.gitiles.doc.MarkdownToHtml.Builder fmt, com.google.gitiles.doc.Navbar navbar, com.google.gitiles.doc.DocServlet.MarkdownFile srcFile) throws java.io.IOException { java.util.Map<java.lang.String, java.lang.Object> data = new java.util.HashMap<>(); data.putAll(navbar.toSoyData()); com.google.gitiles.doc.MarkdownConfig cfg = navbar.getConfig(); org.commonmark.node.Node doc = com.google.gitiles.doc.GitilesMarkdown.parse(cfg, srcFile.consumeContent()); data.put("pageTitle", com.google.gitiles.doc.DocServlet.pageTitle(doc, srcFile)); if ((view.getType()) != (GitilesView.Type.ROOTED_DOC)) { data.put("sourceUrl", com.google.gitiles.GitilesView.show().copyFrom(view).toUrl()); data.put("logUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl()); data.put("blameUrl", com.google.gitiles.GitilesView.blame().copyFrom(view).toUrl()); } if ((cfg.analyticsId) != null) { data.put("analyticsId", cfg.analyticsId); } try (java.io.OutputStream out = startRenderCompressedStreamingHtml(req, res, com.google.gitiles.doc.DocServlet.SOY_TEMPLATE, data)) { java.io.Writer w = newWriter(out, res); fmt.setConfig(cfg).setFilePath(srcFile.path).build().renderToHtml(new com.google.gitiles.doc.html.StreamHtmlBuilder(w), doc); w.flush(); } catch (com.google.gitiles.doc.RuntimeIOException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); throw e; } }
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.lang.Exception { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.getDestBranch().equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.getDestBranch()); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.Utils.readBlob(srcRepo, ((srcRef + ":") + (c.getXmlPath())))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.isRecordSubmoduleLabels()).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setTargetURI(c.getDestRepoKey().toString()).setURI(c.getBaseUri().toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.RepoUpdater.GerritIncludeReader(srcRepo, srcRef)); cmd.call(); }
@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { com.googlesource.gerrit.plugins.supermanifest.SubModuleUpdater subModuleUpdater; switch (c.getToolType()) { case Repo : subModuleUpdater = new com.googlesource.gerrit.plugins.supermanifest.RepoUpdater(serverIdent, canonicalWebUrl); break; default : throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("invalid toolType: %s", c.getToolType().name())); } try (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { subModuleUpdater.update(reader, c, event.getRefName()); } } catch (java.lang.Exception e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); java.io.StringWriter sw = new java.io.StringWriter(); java.io.PrintWriter pw = new java.io.PrintWriter(sw); e.printStackTrace(pw); error("update for %s (ref %s) failed: %s", c.toString(), event.getRefName(), sw); } } }
public com.googlesource.gerrit.plugins.supermanifest.ToolType getToolType() { return toolType; }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Ancient group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.testutil.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
public com.google.inject.Injector getInjector() { return injector; }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.testutil.TestUpdateUI()); com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups().get(groupId); assertThat(group.getCreatedOn()).isAtLeast(testStartTime); }
public com.google.gerrit.reviewdb.server.ReviewDb getDb() { return db; }
private void setUp() throws java.lang.Exception { injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testutil.InMemoryModule()); injector.injectMembers(this); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); lifecycle.start(); try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); com.google.gerrit.reviewdb.client.Account.Id userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); com.google.gerrit.server.IdentifiedUser user = userFactory.create(userId); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getUser() { return user; } @java.lang.Override public com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> getReviewDbProvider() { return com.google.inject.util.Providers.of(db); } }); }
@java.lang.Override public void evaluate() throws java.lang.Throwable { try { setUp(); statement.evaluate(); } finally { tearDown(); } }
private void tearDown() { if ((lifecycle) != null) { lifecycle.stop(); } if ((requestContext) != null) { requestContext.setContext(null); } if ((db) != null) { db.close(); } com.google.gerrit.testutil.InMemoryDatabase.drop(inMemoryDatabase); }
public abstract com.google.gerrit.server.update.RetryHelper.Options.Builder timeout(java.time.Duration timeout);
@com.google.gerrit.common.Nullable abstract java.time.Duration timeout();
public abstract com.google.gerrit.server.update.RetryHelper.Options build();
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { builder.withStopStrategy(com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeout(), defaultTimeout).toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS)).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); if ((opts.listener()) != null) { builder.withRetryListener(opts.listener()); } } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } }
public java.time.Duration getDefaultTimeout() { return defaultTimeout; }
private java.lang.String getPluginCanonicalWebUrl(java.lang.String name) { java.lang.String canonicalWebUrl = urlProvider.get(); if (com.google.common.base.Strings.isNullOrEmpty(canonicalWebUrl)) { return "/plugins/" + name; } java.lang.String url = java.lang.String.format("%s/plugins/%s/", com.google.common.base.CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl), name); return url; }
static java.lang.String computeCanonicalPath(java.lang.String canonicalURL) throws java.net.URISyntaxException { if (com.google.common.base.Strings.isNullOrEmpty(canonicalURL)) { return ""; } java.net.URI uri = new java.net.URI(canonicalURL); return uri.getPath().replaceAll("/$", ""); }
public Project.NameKey project() { return project; }
private java.util.Optional<com.google.gerrit.server.patch.DiffSummary> getDiffSummary(com.google.gerrit.reviewdb.client.Change c, com.google.gerrit.reviewdb.client.PatchSet ps) { java.lang.Integer psId = ps.getId().get(); if ((diffSummaries) == null) { diffSummaries = new java.util.HashMap(); } java.util.Optional<com.google.gerrit.server.patch.DiffSummary> r = diffSummaries.get(psId); if (r == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } try { r = java.util.Optional.of(patchListCache.getDiffSummary(c, ps)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { r = java.util.Optional.empty(); } diffSummaries.put(psId, r); } return r; }
public java.util.Set<java.lang.String> stars(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { if ((starsOf) != null) { if (!(starsOf.accountId().equals(accountId))) { starsOf = null; } } if ((starsOf) == null) { if ((stars) != null) { starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, stars.get(accountId)); } else { if (!(lazyLoad)) { return com.google.common.collect.ImmutableSet.of(); } starsOf = com.google.gerrit.server.query.change.ChangeData.StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId)); } } return starsOf.stars(); }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSetApproval> approvals() throws com.google.gwtorm.server.OrmException { if ((allApprovals) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableListMultimap.of(); } allApprovals = approvalsUtil.byChange(db, notes()); } return allApprovals; }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() throws com.google.gwtorm.server.OrmException { if ((submitTypeRecord) == null) { submitTypeRecord = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, this).getSubmitType(); } return submitTypeRecord; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> submitRecords(com.google.gerrit.server.project.SubmitRuleOptions options) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.common.data.SubmitRecord> records = submitRecords.get(options); if (records == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } records = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, this).setOptions(options).evaluate(); submitRecords.put(options, records); } return records; }
public static void ensureCurrentPatchSetLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentPatchSet(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if (((cd.currentPatchSet) == null) && ((cd.patchSets) == null)) { missing.put(cd.change().currentPatchSetId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.reviewdb.client.PatchSet ps : first.db.patchSets().get(missing.keySet())) { missing.get(ps.getId()).currentPatchSet = ps; } }
public java.util.Collection<com.google.gerrit.reviewdb.client.PatchSet> patchSets() throws com.google.gwtorm.server.OrmException { if ((patchSets) == null) { patchSets = psUtil.byChange(db, notes()); } return patchSets; }
public static void ensureMessagesLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.messages(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.messages) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.changeMessages().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.ChangeMessage> result = results.get(i); if (result != null) { batch.get(i).messages = result.toList(); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.RobotComment> robotComments() throws com.google.gwtorm.server.OrmException { if ((robotComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } robotComments = commentsUtil.robotCommentsByChange(notes()); } return robotComments; }
public java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages() throws com.google.gwtorm.server.OrmException { if ((messages) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } messages = cmUtil.byChange(db, notes()); } return messages; }
public static com.google.gerrit.server.query.change.ChangeData createForTest(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.Change.Id id, int currentPatchSetId) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, project, id, null, null, null); cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(id, currentPatchSetId)); return cd; }
public com.google.gerrit.server.ReviewerSet reviewers() throws com.google.gwtorm.server.OrmException { if ((reviewers) == null) { if (!(lazyLoad)) { return com.google.gerrit.server.ReviewerSet.empty(); } reviewers = approvalsUtil.getReviewers(notes(), approvals().values()); } return reviewers; }
public java.util.List<com.google.gerrit.server.ReviewerStatusUpdate> reviewerUpdates() throws com.google.gwtorm.server.OrmException { if ((reviewerUpdates) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } reviewerUpdates = approvalsUtil.getReviewerUpdates(notes()); } return reviewerUpdates; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> editRefs() throws com.google.gwtorm.server.OrmException { if ((editsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } editsByUser = new java.util.HashMap(); com.google.gerrit.reviewdb.client.Change.Id id = checkNotNull(change.getId()); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> e : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).entrySet()) { if (id.equals(Change.Id.fromEditRefPart(e.getKey()))) { editsByUser.put(Account.Id.fromRefPart(e.getKey()), e.getValue()); } } } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } return editsByUser; }
private boolean loadCommitData() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (ps == null) { return false; } java.lang.String sha1 = ps.getRevision().get(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project());org.eclipse.jgit.revwalk.RevWalk walk = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit c = walk.parseCommit(org.eclipse.jgit.lib.ObjectId.fromString(sha1)); commitMessage = c.getFullMessage(); commitFooters = c.getFooterLines(); author = c.getAuthorIdent(); committer = c.getCommitterIdent(); } return true; }
public static void ensureCurrentApprovalsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.currentApprovals(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.currentApprovals) == null) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change().currentPatchSetId(); results.add(cd.db.patchSetApprovals().byPatchSet(psId)); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSetApproval> result = results.get(i); if (result != null) { batch.get(i).currentApprovals = com.google.gerrit.server.ApprovalsUtil.sortApprovals(result); } } } }
public java.util.Collection<com.google.gerrit.reviewdb.client.Comment> publishedComments() throws com.google.gwtorm.server.OrmException { if ((publishedComments) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } publishedComments = commentsUtil.publishedByChange(db, notes()); } return publishedComments; }
public java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> currentApprovals() throws com.google.gwtorm.server.OrmException { if ((currentApprovals) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { currentApprovals = java.util.Collections.emptyList(); } else { try { currentApprovals = com.google.common.collect.ImmutableList.copyOf(approvalsUtil.byPatchSet(db, changeControl(), c.currentPatchSetId(), null, null)); } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { currentApprovals = java.util.Collections.emptyList(); } else { throw e; } } } } return currentApprovals; }
public com.google.gerrit.server.notedb.ChangeNotes notes() throws com.google.gwtorm.server.OrmException { if ((notes) == null) { if (!(lazyLoad)) { throw new com.google.gwtorm.server.OrmException("ChangeNotes not available, lazyLoad = false"); } notes = notesFactory.create(db, project(), legacyId); } return notes; }
public com.google.common.collect.ImmutableMap<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.StarredChangesUtil.StarRef> starRefs() throws com.google.gwtorm.server.OrmException { if ((starRefs) == null) { if (!(lazyLoad)) { return com.google.common.collect.ImmutableMap.of(); } starRefs = checkNotNull(starredChangesUtil).byChange(legacyId); } return starRefs; }
public com.google.gerrit.server.project.ChangeControl changeControl(com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { if ((changeControl) != null) { com.google.gerrit.server.CurrentUser oldUser = user; if (com.google.gerrit.server.query.change.ChangeData.sameUser(user, oldUser)) { return changeControl; } throw new java.lang.IllegalStateException(("user already specified: " + (changeControl.getUser()))); } try { if ((change) != null) { changeControl = changeControlFactory.controlFor(db, change, user); } else { changeControl = changeControlFactory.controlFor(db, project(), legacyId, user); } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } return changeControl; }
public com.google.gerrit.server.project.ChangeControl changeControl() throws com.google.gwtorm.server.OrmException { if ((changeControl) == null) { com.google.gerrit.reviewdb.client.Change c = change(); try { changeControl = changeControlFactory.controlFor(db, c, userFactory.create(c.getOwner())); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(e); } } return changeControl; }
public static void ensureAllPatchSetsLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.patchSets(); } return; } java.util.List<com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet>> results = new java.util.ArrayList<>(com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE); for (java.util.List<com.google.gerrit.server.query.change.ChangeData> batch : com.google.common.collect.Iterables.partition(changes, com.google.gerrit.server.query.change.ChangeData.BATCH_SIZE)) { results.clear(); for (com.google.gerrit.server.query.change.ChangeData cd : batch) { if ((cd.patchSets) == null) { results.add(cd.db.patchSets().byChange(cd.getId())); } else { results.add(null); } } for (int i = 0; i < (batch.size()); i++) { com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.PatchSet> result = results.get(i); if (result != null) { batch.get(i).patchSets = result.toList(); } } } }
public com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> trackingFooters() throws com.google.gwtorm.server.OrmException, java.io.IOException { return trackingFooters.extract(commitFooters()); }
public com.google.gerrit.reviewdb.client.Change reloadChange() throws com.google.gwtorm.server.OrmException { try { notes = notesFactory.createChecked(db, project, legacyId); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gwtorm.server.OrmException(("Unable to load change " + (legacyId)), e); } change = notes.getChange(); setPatchSets(null); return change; }
public java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.Ref> draftRefs() throws com.google.gwtorm.server.OrmException { if ((draftsByUser) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyMap(); } com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return java.util.Collections.emptyMap(); } draftsByUser = new java.util.HashMap(); if (notesMigration.readChanges()) { for (org.eclipse.jgit.lib.Ref ref : commentsUtil.getDraftRefs(notes.getChangeId())) { com.google.gerrit.reviewdb.client.Account.Id account = Account.Id.fromRefSuffix(ref.getName()); if ((account != null) && (!(notes().getDraftComments(account, ref).isEmpty()))) { draftsByUser.put(account, ref); } } } else { for (Comment sc : commentsUtil.draftByChange(db, notes())) { draftsByUser.put(sc.author.getId(), null); } } } return draftsByUser; }
public static void ensureChangeLoaded(java.lang.Iterable<com.google.gerrit.server.query.change.ChangeData> changes) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData first = com.google.common.collect.Iterables.getFirst(changes, null); if (first == null) { return; } else if (first.notesMigration.readChanges()) { for (com.google.gerrit.server.query.change.ChangeData cd : changes) { cd.change(); } return; } java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.query.change.ChangeData> missing = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { if ((cd.change) == null) { missing.put(cd.getId(), cd); } } if (missing.isEmpty()) { return; } for (com.google.gerrit.server.notedb.ChangeNotes notes : first.notesFactory.create(first.db, missing.keySet())) { missing.get(notes.getChangeId()).change = notes.getChange(); } }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change = cd.change(); if (change == null) { return false; } com.google.gerrit.server.project.ChangeControl changeControl; com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); try { changeControl = changeControlFactory.controlFor(notes, user); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return false; } boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gwtorm.server.OrmException("unable to check permissions", e); } if (visible) { cd.cacheVisibleTo(changeControl); return true; } return false; }
java.lang.String readString(java.lang.String defaultValue, java.util.Set<java.lang.String> allowedValues, java.lang.String message);
@java.lang.Override public java.lang.String readString(java.lang.String defaultValue, java.util.Set<java.lang.String> allowedValues, java.lang.String message) { return ui.readString(defaultValue, allowedValues, message); }
@java.lang.Override public java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException { java.util.stream.Stream<com.google.gerrit.server.plugins.Plugin> s = com.google.common.collect.Streams.stream(pluginLoader.getPlugins(all)); if ((matchPrefix) != null) { checkMatchOptions((((matchSubstring) == null) && ((matchRegex) == null))); s = s.filter(( p) -> p.getName().startsWith(matchPrefix)); } else if ((matchSubstring) != null) { checkMatchOptions((((matchPrefix) == null) && ((matchRegex) == null))); java.lang.String substring = matchSubstring.toLowerCase(java.util.Locale.US); s = s.filter(( p) -> p.getName().toLowerCase(Locale.US).contains(substring)); } else if ((matchRegex) != null) { checkMatchOptions((((matchPrefix) == null) && ((matchSubstring) == null))); java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(matchRegex); s = s.filter(( p) -> pattern.matcher(p.getName()).matches()); } s = s.sorted(java.util.Comparator.comparing(Plugin::getName)); if ((start) > 0) { s = s.skip(start); } if ((limit) > 0) { s = s.limit(limit); } return new java.util.TreeMap(s.collect(java.util.stream.Collectors.toMap(( p) -> p.getName(), ( p) -> toPluginInfo(p)))); }
@java.lang.Override public void run() throws java.lang.Exception { list.setAll(all); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> output = list.apply(TopLevelResource.INSTANCE); if (format.isJson()) { format.newGson().toJson(output, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.PluginInfo>>() {}.getType(), stdout); stdout.print('\n'); } else { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.extensions.common.PluginInfo> p : output.entrySet()) { com.google.gerrit.extensions.common.PluginInfo info = p.getValue(); stdout.format("%-30s %-10s %-8s %s\n", p.getKey(), com.google.common.base.Strings.nullToEmpty(info.version), status(info.disabled), com.google.common.base.Strings.nullToEmpty(info.filename)); } } stdout.flush(); }
public boolean isDisabled() { return (enforceVisibility) && ((getPermittedLimit()) <= 0); }
public int getQueryLimit() { return getRange(GlobalCapability.QUERY_LIMIT).getMax(); }
private int getEffectiveLimit(com.google.gerrit.index.query.Predicate<T> p) { java.util.List<java.lang.Integer> possibleLimits = new java.util.ArrayList<>(4); possibleLimits.add(getBackendSupportedLimit()); possibleLimits.add(getPermittedLimit()); if ((userProvidedLimit) > 0) { possibleLimits.add(userProvidedLimit); } if ((limitField) != null) { java.lang.Integer limitFromPredicate = com.google.gerrit.index.query.LimitPredicate.getLimit(limitField, p); if (limitFromPredicate != null) { possibleLimits.add(limitFromPredicate); } } int result = com.google.common.collect.Ordering.natural().min(possibleLimits); com.google.gerrit.server.query.QueryProcessor.checkState((result > 0), "effective limit should be positive"); return result; }
@java.lang.Override public java.lang.String toString() { return ((("(" + (com.google.gerrit.extensions.conditions.BooleanCondition.maybeTrim(a, getClass()))) + " || ") + (com.google.gerrit.extensions.conditions.BooleanCondition.maybeTrim(a, getClass()))) + ")"; }
@java.lang.Override public java.lang.String toString() { return ((("(" + (com.google.gerrit.extensions.conditions.BooleanCondition.maybeTrim(a, getClass()))) + " && ") + (com.google.gerrit.extensions.conditions.BooleanCondition.maybeTrim(a, getClass()))) + ")"; }
public <R extends com.google.gerrit.extensions.restapi.RestResource> java.lang.Iterable<com.google.gerrit.extensions.webui.UiAction.Description> from(com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<R>> views, R resource) { java.util.List<com.google.gerrit.extensions.webui.UiAction.Description> descs = com.google.common.collect.Streams.stream(views).map(( e) -> describe(e, resource)).filter(java.util.Objects::nonNull).collect(java.util.stream.Collectors.toList()); java.util.List<com.google.gerrit.server.permissions.PermissionBackendCondition> conds = com.google.common.collect.Streams.concat(descs.stream().flatMap(( u) -> com.google.common.collect.Streams.stream(visibleCondition(u))), descs.stream().flatMap(( u) -> com.google.common.collect.Streams.stream(enabledCondition(u)))).collect(java.util.stream.Collectors.toList()); permissionBackend.bulkEvaluateTest(conds); return descs.stream().filter(( u) -> u.isVisible()).collect(java.util.stream.Collectors.toList()); }
static java.lang.String computeFromRequest(javax.servlet.http.HttpServletRequest req) { java.lang.StringBuffer url = req.getRequestURL(); try { url = new java.lang.StringBuffer(java.net.URLDecoder.decode(url.toString(), java.nio.charset.StandardCharsets.UTF_8.name())); url.setLength(((url.length()) - (req.getServletPath().length()))); if ((url.charAt(((url.length()) - 1))) != '/') { url.append('/'); } return url.toString(); } catch (java.io.UnsupportedEncodingException e) { throw new java.lang.IllegalStateException(("Unsupported encoding for request URL " + url), e); } }
private boolean canReadRef(java.lang.String ref) { try { permissionBackend.user(user).project(projectCtl.getProject().getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error("unable to check permissions", e); return false; } return true; }
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectControl projectControl = controlFor(project); if (!(shouldReplicate(projectControl))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.user(projectControl.getUser()).project(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; } }).call(); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("source project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
private java.util.List<org.eclipse.jgit.lib.Ref> getBranchRefs(com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.project.ProjectControl projectControl) { org.eclipse.jgit.lib.Ref[] result = new org.eclipse.jgit.lib.Ref[showBranch.size()]; try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(projectName)) { com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(currentUser).project(projectName); for (int i = 0; i < (showBranch.size()); i++) { org.eclipse.jgit.lib.Ref ref = git.findRef(showBranch.get(i)); if ((all) && (projectControl.isOwner())) { result[i] = ref; } else if ((ref != null) && ((ref.getObjectId()) != null)) { try { perm.ref(ref.getLeaf().getName()).check(RefPermission.READ); result[i] = ref; } catch (com.google.gerrit.extensions.restapi.AuthException e) { continue; } } } } catch (java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { } return java.util.Arrays.asList(result); }
private static java.lang.String getDriverFromUrl(java.lang.String url) { if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.POSTGRESQL)) { return "org.postgresql.Driver"; } if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.MYSQL)) { return "com.mysql.jdbc.Driver"; } if (url.contains(com.google.gerrit.server.schema.JdbcAccountPatchReviewStore.MARIADB)) { return "org.mariadb.jdbc.Driver"; } return "org.h2.Driver"; }
public static com.google.gerrit.server.account.externalids.ExternalId createWithEmail(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email) { return com.google.gerrit.server.account.externalids.ExternalId.create(key, accountId, com.google.common.base.Strings.emptyToNull(email), null); }
public static com.google.gerrit.server.account.externalids.ExternalId create(java.lang.String scheme, java.lang.String id, com.google.gerrit.reviewdb.client.Account.Id accountId) { return com.google.gerrit.server.account.externalids.ExternalId.create(com.google.gerrit.server.account.externalids.ExternalId.Key.create(scheme, id), accountId, null, null); }
private static com.google.gerrit.server.account.externalids.ExternalId parse(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); return com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); }
public static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); checkState(extId.equals(actualExtId), "external id %s should be removed, but it's not matching the actual external id %s", extId.toString(), actualExtId.toString()); noteMap.remove(noteId); return actualExtId; }
public static com.google.gerrit.server.account.externalids.ExternalId create(com.google.gerrit.server.account.externalids.ExternalId.Key key, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String email, @com.google.gerrit.common.Nullable java.lang.String hashedPassword) { return com.google.gerrit.server.account.externalids.ExternalId.create(key, accountId, com.google.common.base.Strings.emptyToNull(email), com.google.common.base.Strings.emptyToNull(hashedPassword), null); }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); if (expectedAccountId != null) { checkState(expectedAccountId.equals(extId.accountId()), ("external id %s should be removed for account %s," + " but external id belongs to account %s"), extIdKey.get(), expectedAccountId.get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; }
private java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException { if (rev.equals(org.eclipse.jgit.lib.ObjectId.zeroId())) { return com.google.common.collect.ImmutableSet.of(); } try (com.google.gerrit.metrics.Timer0.Context ctx = readAllLatency.start();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap noteMap = com.google.gerrit.server.account.externalids.ExternalIdReader.readNoteMap(rw, rev); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = rw.getObjectReader().open(note.getData(), com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdReader.MAX_NOTE_SZ); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw, note.getData())); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIdReader.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; } }
public java.lang.String toSubmodules() { java.lang.StringBuffer buf = new java.lang.StringBuffer(); sortByPath(); for (com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project p : projects) { buf.append(p.toSubmodules()); buf.append("\n"); } return buf.toString(); }
public void sortByPath() { java.util.Arrays.sort(projects, new com.googlesource.gerrit.plugins.supermanifest.JiriProjects.SortbyPath()); }
public com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project[] getProjects() { return projects; }
@java.lang.Override public int compare(com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project a, com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project b) { java.lang.String p1 = com.googlesource.gerrit.plugins.supermanifest.StringUtil.stripAndaddCharsAtEnd(a.getPath(), "/"); java.lang.String p2 = com.googlesource.gerrit.plugins.supermanifest.StringUtil.stripAndaddCharsAtEnd(b.getPath(), "/"); return p1.compareTo(p2); }
@java.lang.Override public boolean equals(java.lang.Object obj) { com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project p = ((com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project) (obj)); if (!(name.equals(p.name))) { return false; } if (!(path.equals(p.path))) { return false; } if (!(remote.equals(p.remote))) { return false; } if (!(remotebranch.equals(p.remotebranch))) { return false; } if (!(revision.equals(p.revision))) { return false; } return true; }
@java.lang.Override public java.lang.String toString() { return java.lang.String.format("%s (%s) => %s", src(), toolType, dest()); }
@java.lang.Override public java.lang.String toString() { java.lang.StringBuffer buf = new java.lang.StringBuffer(); if ((projects.length) > 0) { buf.append("projects:\n"); for (com.googlesource.gerrit.plugins.supermanifest.JiriProjects.Project p : projects) { buf.append(com.googlesource.gerrit.plugins.supermanifest.StringUtil.addTab(p.toString())); } } return buf.toString(); }
public com.googlesource.gerrit.plugins.supermanifest.JiriManifest.LocalImport[] getLocalImports() { return localImports; }
@java.lang.Override public java.lang.String toString() { java.lang.StringBuffer buf = new java.lang.StringBuffer(""); if ((imports.length) > 0) { buf.append((("import: " + (imports.length)) + "\n")); } if ((localImports.length) > 0) { buf.append("localImports:\n"); for (com.googlesource.gerrit.plugins.supermanifest.JiriManifest.LocalImport l : localImports) { buf.append(com.googlesource.gerrit.plugins.supermanifest.StringUtil.addTab(l.toString())); } } return buf.toString(); }
public com.googlesource.gerrit.plugins.supermanifest.JiriManifest.Import[] getImports() { return imports; }
public static com.google.gerrit.index.query.Predicate<com.google.gerrit.reviewdb.client.AccountGroup> name(java.lang.String name) { return new com.google.gerrit.server.query.group.GroupPredicates.GroupPredicate(com.google.gerrit.server.index.group.GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); GroupInfo group = createGroup(name("Group")); assertQuery(("name:" + (group.name)), group); assertQuery(("name:" + (group.name.toLowerCase(Locale.US)))); GroupInfo groupWithHyphen = createGroup(name("group-with-hyphen")); createGroup(name("group-no-match-with-hyphen")); assertQuery(("name:" + (groupWithHyphen.name)), groupWithHyphen); }
public byte[] toByteArray() { checkState(((blobId()) != null), "Missing blobId in external ID %s", key().get()); byte[] b = new byte[(2 * (org.eclipse.jgit.lib.Constants.OBJECT_ID_STRING_LENGTH)) + 1]; key().sha1().copyTo(b, 0); b[org.eclipse.jgit.lib.Constants.OBJECT_ID_STRING_LENGTH] = ':'; blobId().copyTo(b, ((org.eclipse.jgit.lib.Constants.OBJECT_ID_STRING_LENGTH) + 1)); return b; }
@com.google.gerrit.common.Nullable private java.lang.String canCreateCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.server.permissions.PermissionBackend.ForRef forRef) throws com.google.gerrit.server.permissions.PermissionBackendException { if (projectState.controlFor(user).isReachableFromHeadsOrTags(repo, commit)) { return null; } else if (testAuditLogged(forRef, RefPermission.UPDATE)) { return null; } return (((user.getAccountId()) + " lacks permission ") + (com.google.gerrit.common.data.Permission.PUSH)) + " for creating new commit object"; }
private boolean testAuditLogged(com.google.gerrit.server.permissions.PermissionBackend.ForRef forRef, com.google.gerrit.server.permissions.RefPermission p) throws com.google.gerrit.server.permissions.PermissionBackendException { try { forRef.check(p); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } return true; }
private boolean isProjectStatePermittingWrite() { return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE); }
private void parseCreate(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { org.eclipse.jgit.revwalk.RevObject obj; try { obj = rp.getRevWalk().parseAny(cmd.getNewId()); } catch (java.io.IOException err) { logError((((("Invalid object " + (cmd.getNewId().name())) + " for ") + (cmd.getRefName())) + " creation"), err); reject(cmd, "invalid object"); return; } logDebug("Creating {}", cmd); if ((com.google.gerrit.server.git.receive.ReceiveCommits.isHead(cmd)) && (!(isCommit(cmd)))) { return; } com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project.getName(), cmd.getRefName()); java.lang.String rejectReason = createRefControl.canCreateRef(rp.getRepository(), obj, user, branch); if (rejectReason != null) { reject(cmd, ("prohibited by Gerrit: " + rejectReason)); return; } if (!(validRefOperation(cmd))) { return; } com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef(cmd.getRefName()); validateNewCommits(ctl, cmd); actualCommands.add(cmd); }
public boolean permitsRead() { return permitsRead; }
public boolean permitsWrite() { return permitsWrite; }
private boolean can(com.google.gerrit.server.permissions.ChangePermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { try { switch (perm) { case READ : return isVisible(db(), changeData()); case ABANDON : return canAbandon(db()); case DELETE : return canDelete(db(), getChange().getStatus()); case ADD_PATCH_SET : return canAddPatchSet(db()); case EDIT_ASSIGNEE : return canEditAssignee(); case EDIT_DESCRIPTION : return canEditDescription(); case EDIT_HASHTAGS : return canEditHashtags(); case EDIT_TOPIC_NAME : return canEditTopicName(); case REBASE : return canRebase(db()); case RESTORE : return canRestore(db()); case SUBMIT : return getRefControl().canSubmit(isOwner()); case REMOVE_REVIEWER : case SUBMIT_AS : return getRefControl().canPerform(perm.permissionName().get()); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.permissions.PermissionBackendException("unavailable", e); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.gerrit.server.update.RetryHelper.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.server.update.RetryHelper.MetricListener listener = null; try { com.github.rholder.retry.RetryerBuilder<T> builder = com.github.rholder.retry.RetryerBuilder.newBuilder(); if (migration.disableChangeReviewDb()) { listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(opts.listener()); builder.withRetryListener(listener).withStopStrategy(com.github.rholder.retry.StopStrategies.stopAfterDelay(firstNonNull(opts.timeout(), defaultTimeout).toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS)).withWaitStrategy(waitStrategy).retryIfException(com.google.gerrit.server.update.RetryHelper::isLockFailure); } else { } return builder.build().call(() -> action.call(updateFactory)); } catch (java.util.concurrent.ExecutionException | com.github.rholder.retry.RetryException e) { if (e instanceof com.github.rholder.retry.RetryException) { metrics.timeoutCount.increment(); } if ((e.getCause()) != null) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), com.google.gerrit.extensions.restapi.RestApiException.class); } throw new com.google.gerrit.server.update.UpdateException(e); } finally { if (listener != null) { metrics.attemptCounts.record(listener.getAttemptCount()); } } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, projectCache.checkedGet(ctx.getProject()).getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
private java.util.List<com.google.gerrit.server.change.RevisionResource> loadEdit(com.google.gerrit.server.change.ChangeResource change, com.google.gerrit.reviewdb.client.RevId revid) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser()); if (edit.isPresent()) { com.google.gerrit.reviewdb.client.PatchSet ps = new com.google.gerrit.reviewdb.client.PatchSet(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 0)); com.google.gerrit.reviewdb.client.RevId editRevId = new com.google.gerrit.reviewdb.client.RevId(org.eclipse.jgit.lib.ObjectId.toString(edit.get().getEditCommit())); ps.setRevision(editRevId); if ((revid == null) || (editRevId.equals(revid))) { return java.util.Collections.singletonList(new com.google.gerrit.server.change.RevisionResource(change, ps, edit)); } } return java.util.Collections.emptyList(); }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(control.getNotes()); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(change.getId()); }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), rsrc.getNotes()); return includedIn.apply(rsrc.getProject(), ps.getRevision().get()); }
@java.lang.Override protected com.google.gerrit.extensions.common.ChangeInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.extensions.api.changes.AbandonInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { req.permissions().database(dbProvider).check(ChangePermission.ABANDON); com.google.gerrit.extensions.api.changes.NotifyHandling notify = ((input.notify) == null) ? defaultNotify(req.getChange()) : input.notify; com.google.gerrit.reviewdb.client.Change change = abandon(updateFactory, req.getNotes(), req.getUser(), input.message, notify, notifyUtil.resolveAccounts(input.notifyDetails)); return json.noOptions().format(change); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, notes, user, "", defaultNotify(notes.getChange()), com.google.common.collect.ImmutableListMultimap.of()); }
public com.google.gerrit.reviewdb.client.Change abandon(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser user, java.lang.String msgTxt) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { return abandon(updateFactory, notes, user, msgTxt, defaultNotify(notes.getChange()), com.google.common.collect.ImmutableListMultimap.of()); }
private java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> lookupChangeEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, java.io.IOException { return changeEditUtil.byChange(notes); }
private static void checkedAdd(com.google.gerrit.server.query.change.ChangeData cd, java.util.List<com.google.gerrit.server.project.ChangeControl> ctls, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { try { ctls.add(cd.changeControl(user)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { } }
@org.junit.Test public void lookUpByPreferredEmail() throws java.lang.Exception { java.lang.String prefix = "foo.preferred"; java.lang.String prefEmail = prefix + "@example.com"; com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); accountsUpdate.create().update(foo.id, ( a) -> a.setPreferredEmail(prefEmail)); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> accountsByPrefEmail = emails.getAccountFor(prefEmail); assertThat(accountsByPrefEmail).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(accountsByPrefEmail)).isEqualTo(foo.id); accountsByPrefEmail = emails.getAccountFor(prefix); assertThat(accountsByPrefEmail).isEmpty(); accountsByPrefEmail = emails.getAccountFor(prefEmail.toUpperCase(java.util.Locale.US)); assertThat(accountsByPrefEmail).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return setInactiveFlag.activate(rsrc.getUser()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot deactivate own account"); } return setInactiveFlag.deactivate(rsrc.getUser()); }
@org.junit.Test public void pushAccountConfigToUserBranchForReviewIsRejectedOnSubmitIfPreferredEmailIsInvalid() throws java.lang.Exception { java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String noEmail = "no.email"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, noEmail); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + userRef)); r.assertOkStatus(); accountIndexedCounter.assertNoReindex(); assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("invalid account configuration: invalid preferred email '%s' for account '%s'", noEmail, admin.id)); gApi.changes().id(r.getChangeId()).current().submit(); }
@org.junit.Test public void pushAccountConfigWithPrefEmailThatDoesNotExistAsExtIdToUserBranchForReviewAndSubmit() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); accountIndexedCounter.clear(); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String email = "some.email@example.com"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + userRef)); r.assertOkStatus(); accountIndexedCounter.assertNoReindex(); assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef); setApiUser(foo); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r.getChangeId()).current().submit(); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().self().get(); assertThat(info.email).isEqualTo(email); assertThat(info.name).isEqualTo(foo.fullName); }
public com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.reviewdb.client.Branch.NameKey branch, com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.revwalk.RevWalk rw) throws java.io.IOException { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(perm), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(perm, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(user, perm, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(user, perm, projectCache.checkedGet(branch.getParentKey())), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(projectCache.checkedGet(branch.getParentKey()), user, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(branch, user, rw, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators), new com.google.gerrit.server.git.validators.CommitValidators.ExternalIdUpdateListener(allUsers, externalIdsConsistencyChecker), new com.google.gerrit.server.git.validators.CommitValidators.AccountCommitValidator(allUsers, accountValidator))); }
@org.junit.Test public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws java.lang.Exception { TestAccount foo = accountCreator.create(name("foo")); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); accountIndexedCounter.clear(); com.google.gerrit.reviewdb.client.AccountGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")); grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID()); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRef + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String email = "some.email@example.com"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email); pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus(); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.email).isEqualTo(email); assertThat(info.name).isEqualTo(foo.fullName); }
@org.junit.Test public void pushAccountConfigToUserBranchIsRejectedIfPreferredEmailIsInvalid() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, ((com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)) + ":userRef")); allUsersRepo.reset("userRef"); java.lang.String noEmail = "no.email"; org.eclipse.jgit.lib.Config ac = getAccountConfig(allUsersRepo); ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, noEmail); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(RefNames.REFS_USERS_SELF); r.assertErrorStatus("invalid account configuration"); r.assertMessage(java.lang.String.format("invalid preferred email '%s' for account '%s'", noEmail, admin.id)); accountIndexedCounter.assertNoReindex(); }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("You should only have no more than one --project and -n with --suggest"); } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().map(( pc) -> pc.getProjectState()).orElse(null)), ((limit) <= 0 ? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupRefs.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic desc = groupBackend.get(ref.getUUID()); if (desc != null) { groupInfos.add(json.addOptions(options).format(desc)); } } return groupInfos; }
private org.eclipse.jgit.revwalk.RevCommit newMergeCommit(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.lib.ObjectInserter oi, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.ProjectState projectState, org.eclipse.jgit.revwalk.RevCommit mergeTip, com.google.gerrit.extensions.common.MergeInput merge, org.eclipse.jgit.lib.PersonIdent authorIdent, java.lang.String commitMessage) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { if (com.google.common.base.Strings.isNullOrEmpty(merge.source)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("merge.source must be non-empty"); } org.eclipse.jgit.revwalk.RevCommit sourceCommit = com.google.gerrit.server.git.MergeUtil.resolveCommit(repo, rw, merge.source); if (!(commits.canRead(projectState, repo, sourceCommit))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("do not have read permission for: " + (merge.source))); } com.google.gerrit.server.git.MergeUtil mergeUtil = mergeUtilFactory.create(projectState); java.lang.String mergeStrategy = com.google.common.base.MoreObjects.firstNonNull(com.google.common.base.Strings.emptyToNull(merge.strategy), mergeUtil.mergeStrategyName()); return com.google.gerrit.server.git.MergeUtil.createMergeCommit(oi, repo.getConfig(), mergeTip, sourceCommit, mergeStrategy, authorIdent, commitMessage, rw); }
@java.lang.Override public java.lang.Void call() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { for (com.google.gerrit.server.notedb.ChangeNotes notes : notesFactory.scan(repo, db, project)) { try { indexer.index(changeDataFactory.create(db, notes)); done.update(1); verboseWriter.println(("Reindexed change " + (notes.getChangeId()))); } catch (java.util.concurrent.RejectedExecutionException e) { failSilently(); } catch (java.lang.Exception e) { fail(("Failed to index change " + (notes.getChangeId())), true, e); } } } catch (org.eclipse.jgit.errors.RepositoryNotFoundException rnfe) { com.google.gerrit.server.index.change.AllChangesIndexer.log.error(rnfe.getMessage()); } return null; }
private com.google.gerrit.server.notedb.ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(com.google.gerrit.reviewdb.client.Change change) throws com.google.gwtorm.server.OrmException { checkState((!(args.migration.readChanges())), "do not call createFromChangeWhenNoteDbDisabled when NoteDb is enabled"); return new com.google.gerrit.server.notedb.ChangeNotes(args, change).load(); }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChangesByScan() { com.google.gerrit.reviewdb.client.Project.NameKey project = projectCtl.getProject().getNameKey(); try { java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.reviewdb.client.Branch.NameKey> visibleChanges = new java.util.HashMap<>(); for (com.google.gerrit.server.notedb.ChangeNotes.Factory.ChangeNotesResult r : ((java.lang.Iterable<com.google.gerrit.server.notedb.ChangeNotes.Factory.ChangeNotesResult>) (changeNotesFactory.scan(git, db.get(), project)::iterator))) { if (r.error().isPresent()) { throw new com.google.gwtorm.server.OrmException(r.error().get()); } com.google.gerrit.server.notedb.ChangeNotes cn = r.notes(); if (permissionBackend.user(user).change(cn).database(db).test(ChangePermission.READ)) { visibleChanges.put(cn.getChangeId(), cn.getChange().getDest()); } } return visibleChanges; } catch (java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.VisibleRefFilter.log.error((("Cannot load changes for project " + project) + ", assuming no changes are visible"), e); return java.util.Collections.emptyMap(); } }
private java.util.stream.Stream<com.google.gerrit.server.notedb.ChangeNotes.Factory.ChangeNotesResult> scanNoteDb(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) throws java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes.Factory.ScanResult sr = com.google.gerrit.server.notedb.ChangeNotes.Factory.scanChangeIds(repo); com.google.gerrit.server.notedb.NoteDbChangeState.PrimaryStorage defaultStorage = args.migration.changePrimaryStorage(); return sr.all().stream().map(( id) -> scanOneNoteDbChange(db, project, sr, defaultStorage, id)).filter(java.util.Objects::nonNull); }
public java.util.stream.Stream<com.google.gerrit.server.notedb.ChangeNotes.Factory.ChangeNotesResult> scan(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey project) throws java.io.IOException { return args.migration.readChanges() ? scanNoteDb(repo, db, project) : scanReviewDb(repo, db); }
public com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> create(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.function.Predicate<com.google.gerrit.server.notedb.ChangeNotes> predicate) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.common.collect.ListMultimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.notedb.ChangeNotes> m = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); if (args.migration.readChanges()) { for (com.google.gerrit.reviewdb.client.Project.NameKey project : projectCache.all()) { try (org.eclipse.jgit.lib.Repository repo = args.repoManager.openRepository(project)) { scanNoteDb(repo, db, project).filter(( r) -> !(r.error().isPresent())).map(com.google.gerrit.server.notedb.ChangeNotes.Factory.ChangeNotesResult::notes).filter(predicate).forEach(( n) -> m.put(n.getProjectName(), n)); } } } else { for (com.google.gerrit.reviewdb.client.Change change : com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb(db).changes().all()) { com.google.gerrit.server.notedb.ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change); if (predicate.test(notes)) { m.put(change.getProject(), notes); } } } return com.google.common.collect.ImmutableListMultimap.copyOf(m); }
private static com.google.gerrit.server.notedb.ChangeNotes.Factory.ScanResult scanChangeIds(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromPs = com.google.common.collect.ImmutableSet.builder(); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.Change.Id> fromMeta = com.google.common.collect.ImmutableSet.builder(); for (org.eclipse.jgit.lib.Ref r : repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES).values()) { com.google.gerrit.reviewdb.client.Change.Id id = Change.Id.fromRef(r.getName()); if (id != null) { (r.getName().endsWith(RefNames.META_SUFFIX) ? fromMeta : fromPs).add(id); } } return new com.google.gerrit.server.notedb.AutoValue_ChangeNotes_Factory_ScanResult(fromPs.build(), fromMeta.build()); }
@java.lang.Override public void stop() { threadPool = null; }
private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo group = visibleGroups.get(id); if (group == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_SENTINEL; if (control.isVisible()) { group = groupJson.format(control.getGroup()); group.id = null; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { com.google.gerrit.server.project.GetAccess.LOG.warn(("NoSuchGroupException; ignoring group " + id), e); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_SENTINEL; } visibleGroups.put(id, group); } return group; }
private com.google.gerrit.extensions.api.access.AccessSectionInfo createAccessSection(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> groups, com.google.gerrit.common.data.AccessSection section) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.api.access.AccessSectionInfo accessSectionInfo = new com.google.gerrit.extensions.api.access.AccessSectionInfo(); accessSectionInfo.permissions = new java.util.HashMap(); for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { com.google.gerrit.extensions.api.access.PermissionInfo pInfo = new com.google.gerrit.extensions.api.access.PermissionInfo(p.getLabel(), (p.getExclusiveGroup() ? true : null)); pInfo.rules = new java.util.HashMap(); for (com.google.gerrit.common.data.PermissionRule r : p.getRules()) { com.google.gerrit.extensions.api.access.PermissionRuleInfo info = new com.google.gerrit.extensions.api.access.PermissionRuleInfo(com.google.gerrit.server.project.GetAccess.ACTION_TYPE.get(r.getAction()), r.getForce()); if (r.hasRange()) { info.max = r.getMax(); info.min = r.getMin(); } com.google.gerrit.reviewdb.client.AccountGroup.UUID group = r.getGroup().getUUID(); if (group != null) { pInfo.rules.put(group.get(), info); loadGroup(groups, group); } } accessSectionInfo.permissions.put(p.getName(), pInfo); } return accessSectionInfo; }
boolean isPatchSetLocked(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { if ((getChange().getStatus()) == (Change.Status.MERGED)) { return false; } for (com.google.gerrit.reviewdb.client.PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId(), null, null)) { com.google.gerrit.common.data.LabelType type = getProjectControl().getProjectState().getLabelTypes(getNotes(), getUser()).byLabel(ap.getLabel()); if (((type != null) && ((ap.getValue()) == 1)) && (type.getFunctionName().equalsIgnoreCase("PatchSetLock"))) { return true; } } return false; }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { user = ctx.getIdentifiedUser(); notes = ctx.getNotes(); ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId); boolean dirty = false; dirty |= insertComments(ctx); dirty |= insertRobotComments(ctx); dirty |= updateLabels(projectState, ctx); dirty |= insertMessage(ctx); return dirty; }
private void fireCommentAddedEvent(com.google.gerrit.server.update.Context ctx) throws java.io.IOException { if (approvals.isEmpty()) { return; } java.util.List<com.google.gerrit.common.data.LabelType> labels = projectCache.checkedGet(ctx.getProject()).getLabelTypes(notes, ctx.getUser()).getLabelTypes(); java.util.Map<java.lang.String, java.lang.Short> allApprovals = new java.util.HashMap<>(); java.util.Map<java.lang.String, java.lang.Short> oldApprovals = new java.util.HashMap<>(); for (com.google.gerrit.common.data.LabelType lt : labels) { allApprovals.put(lt.getName(), ((short) (0))); oldApprovals.put(lt.getName(), null); } for (java.util.Map.Entry<java.lang.String, java.lang.Short> entry : approvals.entrySet()) { if ((entry.getValue()) != 0) { allApprovals.put(entry.getKey(), entry.getValue()); oldApprovals.put(entry.getKey(), ((short) (0))); } } commentAdded.fire(notes.getChange(), newPatchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen()); }
public com.google.gerrit.server.git.LabelNormalizer.Result normalize(com.google.gerrit.server.project.ChangeControl ctl, java.util.Collection<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> unchanged = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> updated = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> deleted = com.google.common.collect.Lists.newArrayListWithCapacity(approvals.size()); com.google.gerrit.common.data.LabelTypes labelTypes = ctl.getProjectControl().getProjectState().getLabelTypes(ctl.getNotes(), ctl.getUser()); for (com.google.gerrit.reviewdb.client.PatchSetApproval psa : approvals) { com.google.gerrit.reviewdb.client.Change.Id changeId = psa.getKey().getParentKey().getParentKey(); checkArgument(changeId.equals(ctl.getId()), "Approval %s does not match change %s", psa.getKey(), ctl.getChange().getKey()); if (psa.isLegacySubmit()) { unchanged.add(psa); continue; } com.google.gerrit.common.data.LabelType label = labelTypes.byLabel(psa.getLabelId()); if (label == null) { deleted.add(psa); continue; } com.google.gerrit.reviewdb.client.PatchSetApproval copy = copy(psa); applyTypeFloor(label, copy); if (!(applyRightFloor(ctl, label, copy))) { deleted.add(psa); } else if ((copy.getValue()) != (psa.getValue())) { updated.add(copy); } else { unchanged.add(psa); } } return com.google.gerrit.server.git.LabelNormalizer.Result.create(unchanged, updated, deleted); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(com.google.gerrit.reviewdb.server.ReviewDb db, java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail); if (m.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$")) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(nameOrEmail); if (exists(db, id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.server.account.AccountState who = byId.getByUsername(nameOrEmail); if (who != null) { return java.util.Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(db, nameOrEmail); }
private boolean verify(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { java.lang.String username = com.google.gerrit.httpd.RemoteUserUtil.getRemoteUser(req, loginHttpHeader); if (username == null) { rsp.sendError(com.google.gerrit.httpd.SC_FORBIDDEN); return false; } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } final com.google.gerrit.server.account.AccountState who = accountCache.getByUsername(username); if ((who == null) || (!(who.getAccount().isActive()))) { rsp.sendError(com.google.gerrit.httpd.SC_UNAUTHORIZED); return false; } com.google.gerrit.httpd.WebSession ws = session.get(); ws.setUserAccountId(who.getAccount().getId()); ws.setAccessPathOk(AccessPath.GIT, true); ws.setAccessPathOk(AccessPath.REST_API, true); return true; }
@java.lang.Override public boolean validateIdentity(org.apache.sshd.server.session.ServerSession session, java.lang.String identity) { final com.google.gerrit.sshd.SshSession sd = session.getAttribute(SshSession.KEY); int at = identity.indexOf('@'); java.lang.String username; if (at == (-1)) { username = identity; } else { username = identity.substring(0, at); } if (config.getBoolean("auth", "userNameToLowerCase", false)) { username = username.toLowerCase(java.util.Locale.US); } com.google.gerrit.server.account.AccountState state = accounts.getByUsername(username); com.google.gerrit.reviewdb.client.Account account = (state == null) ? null : state.getAccount(); boolean active = (account != null) && (account.isActive()); if (active) { return com.google.gerrit.sshd.SshUtil.success(username, session, sshScope, sshLog, sd, com.google.gerrit.sshd.SshUtil.createUser(sd, userFactory, account.getId())); } return false; }
public java.util.List<java.lang.String> patterns() { return java.util.Collections.unmodifiableList(patterns); }
void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException;
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException { org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString()); org.eclipse.jgit.lib.Repository srcRepo = reader.openRepository(c.getSrcRepoKey().toString()); org.eclipse.jgit.gitrepo.RepoCommand cmd = new org.eclipse.jgit.gitrepo.RepoCommand(destRepo); if (c.getDestBranch().equals("*")) { cmd.setTargetBranch(srcRef.substring(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS.length())); } else { cmd.setTargetBranch(c.getDestBranch()); } java.io.InputStream manifestStream = new java.io.ByteArrayInputStream(com.googlesource.gerrit.plugins.supermanifest.Utils.readBlob(srcRepo, ((srcRef + ":") + (c.getXmlPath())))); cmd.setAuthor(serverIdent).setRecordRemoteBranch(true).setRecordSubmoduleLabels(c.isRecordSubmoduleLabels()).setInputStream(manifestStream).setRecommendShallow(true).setRemoteReader(reader).setTargetURI(c.getDestRepoKey().toString()).setURI(c.getBaseUri().toString()); cmd.setIncludedFileReader(new com.googlesource.gerrit.plugins.supermanifest.RepoUpdater.GerritIncludeReader(srcRepo, srcRef)); cmd.call(); }
private void updateForConfig(com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, com.googlesource.gerrit.plugins.supermanifest.Event event) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { com.googlesource.gerrit.plugins.supermanifest.SubModuleUpdater subModuleUpdater; switch (c.getToolType()) { case Repo : subModuleUpdater = new com.googlesource.gerrit.plugins.supermanifest.RepoUpdater(serverIdent, canonicalWebUrl); break; case Jiri : subModuleUpdater = new com.googlesource.gerrit.plugins.supermanifest.JiriUpdater(serverIdent, canonicalWebUrl); break; default : throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("invalid toolType: %s", c.getToolType().name())); } try (com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader = new com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader()) { subModuleUpdater.update(reader, c, event.getRefName()); } }
@java.lang.Override public synchronized void onGitReferenceUpdated(com.googlesource.gerrit.plugins.supermanifest.Event event) { if (event.getProjectName().equals(allProjectsName.get())) { if (event.getRefName().equals("refs/meta/config")) { updateConfiguration(); } return; } for (com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c : config) { if (!(c.srcRepoKey.get().equals(event.getProjectName()))) { continue; } if (!((c.destBranch.equals("*")) || (c.srcRef.equals(event.getRefName())))) { continue; } if ((c.destBranch.equals("*")) && (!(event.getRefName().startsWith(com.googlesource.gerrit.plugins.supermanifest.REFS_HEADS)))) { continue; } try { updateForConfig(c, event); } catch (org.eclipse.jgit.errors.ConfigInvalidException | java.io.IOException | org.eclipse.jgit.api.errors.GitAPIException e) { java.lang.StackTraceElement here = java.lang.Thread.currentThread().getStackTrace()[1]; e.setStackTrace(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), here)); java.io.StringWriter sw = new java.io.StringWriter(); java.io.PrintWriter pw = new java.io.PrintWriter(sw); e.printStackTrace(pw); error("update for %s (ref %s) failed: %s", c.toString(), event.getRefName(), sw); } } }
private static java.lang.String getString(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String subSection, java.lang.String name, java.lang.String defaultValue) { java.lang.String value = cfg.getString(section, subSection, name); return value == null ? defaultValue : value; }
private static boolean getBoolean(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, boolean defaultValue) { try { return cfg.getBoolean(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error(java.lang.String.format("invalid value for %s; using default value %s", name, defaultValue)); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve boolean value: " + (e.getMessage())), e); return defaultValue; } }
@java.lang.Override protected void configure() { bind(new com.google.inject.TypeLiteral<com.google.common.base.Optional<com.ericsson.gerrit.plugins.highavailability.peers.PeerInfo>>() {}).toProvider(com.ericsson.gerrit.plugins.highavailability.peers.PeerInfoProvider.class); if ((strategy) == (Configuration.PeerInfoStrategy.JGROUPS)) { listener().to(com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.class); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); update(resource.getProjectState().getProject().getName(), resource.getRef(), false); return com.google.gerrit.extensions.restapi.Response.none(); }
void run(SitePaths replica, org.eclipse.jgit.storage.file.FileBasedConfig pluginConfig) throws java.lang.Exception { this.replica = replica; com.google.gerrit.common.FileUtil.mkdirsOrDie(replica.site_path, ("cannot create " + (replica.site_path))); configureMainSection(pluginConfig); configurePeerInfo(pluginConfig); for (java.nio.file.Path dir : listDirsForCopy()) { copyFiles(dir); } com.ericsson.gerrit.plugins.highavailability.SetupLocalHAReplica.mkdir(replica.logs_dir); com.ericsson.gerrit.plugins.highavailability.SetupLocalHAReplica.mkdir(replica.tmp_dir); symlink(java.nio.file.Paths.get(masterConfig.getString("gerrit", null, "basePath"))); symlink(sharedDir); org.eclipse.jgit.storage.file.FileBasedConfig replicaConfig = new org.eclipse.jgit.storage.file.FileBasedConfig(replica.gerrit_config.toFile(), org.eclipse.jgit.util.FS.DETECTED); replicaConfig.load(); if ("h2".equals(masterConfig.getString("database", null, "type"))) { masterConfig.setBoolean("database", "h2", "autoServer", true); replicaConfig.setBoolean("database", "h2", "autoServer", true); symlinkH2ReviewDbDir(); } }
private boolean createHAReplicaSite(org.eclipse.jgit.storage.file.FileBasedConfig pluginConfig) throws java.lang.Exception { ui.header("HA replica site setup"); ui.message(("It is possible to create a copy of the master site and configure both sites to run\n" + ((((("in HA mode as peers. This is possible when the directory where the copy will be\n" + "created is accessible from this machine\n") + "\n") + "NOTE: This step is optional. If you want to create the other site manually, or\n") + "if the other site needs to be created in a directory not accessible from this\n") + "machine then please skip this step.\n"))); if (ui.yesno(true, "Create a HA replica site")) { java.lang.String replicaPath = ui.readString("ha/1", "Location of the HA replica"); java.nio.file.Path replica = site.site_path.resolve(java.nio.file.Paths.get(replicaPath)); if (java.nio.file.Files.exists(replica)) { ui.message("%s already exists, exiting", replica); return true; } config.save(); setupLocalHAReplica.run(new com.google.gerrit.server.config.SitePaths(replica), pluginConfig); return true; } return false; }
@java.lang.Override public void run() throws java.lang.Exception { ui.message("\n"); ui.header("%s Plugin", pluginName); if (ui.yesno(true, "Configure %s", pluginName)) { ui.header("Configuring %s", pluginName); java.nio.file.Path pluginConfigFile = site.etc_dir.resolve(((pluginName) + ".config")); config = new org.eclipse.jgit.storage.file.FileBasedConfig(pluginConfigFile.toFile(), org.eclipse.jgit.util.FS.DETECTED); config.load(); configureHttp(); configureCacheSection(); configureIndexSection(); configureWebsessiosSection(); if (!(createHAReplicaSite(config))) { configureMainSection(); configurePeerInfoSection(); config.save(); } flags.cfg.setBoolean("database", "h2", "autoServer", true); } }
private void configureMainSection(org.eclipse.jgit.storage.file.FileBasedConfig pluginConfig) throws java.io.IOException { pluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.MAIN_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SHARED_DIRECTORY_KEY, master.site_path.relativize(sharedDir).toString()); pluginConfig.save(); }
private static void mkdir(java.nio.file.Path dir) throws java.io.IOException { java.nio.file.Files.createDirectories(dir); }
private boolean shouldSkip(java.nio.file.Path p) throws java.io.IOException { java.nio.file.Path resolved = master.site_path.resolve(p); for (java.nio.file.Path skip : toSkip) { if ((java.nio.file.Files.exists(skip)) && (java.nio.file.Files.isSameFile(resolved, skip))) { return true; } } return false; }
private void configurePeerInfo(org.eclipse.jgit.storage.file.FileBasedConfig pluginConfig) throws java.io.IOException { pluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.PEER_INFO_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.STRATEGY_KEY, "jgroups"); pluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.PEER_INFO_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SUBSECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUSTER_NAME_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_CLUSTER_NAME); pluginConfig.save(); }
private void configureMainSection() { ui.header("Main section"); java.lang.String sharedDirDefault = (ui.isBatch()) ? com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SHARED_DIRECTORY : null; java.lang.String shared = promptAndSetString("Shared directory", com.ericsson.gerrit.plugins.highavailability.Configuration.MAIN_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.SHARED_DIRECTORY_KEY, sharedDirDefault); if (!(com.google.common.base.Strings.isNullOrEmpty(shared))) { java.nio.file.Path resolved = site.site_path.resolve(java.nio.file.Paths.get(shared)); com.google.gerrit.common.FileUtil.mkdirsOrDie(resolved, ("cannot create " + resolved)); } }
private boolean applyRightFloor(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.common.data.LabelType lt, com.google.gerrit.reviewdb.client.PatchSetApproval a) throws com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.ForChange forChange = permissionBackend.user(userFactory.create(a.getAccountId())).database(db).change(notes); try { forChange.check(new com.google.gerrit.server.permissions.LabelPermission(lt.getName())); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } try { forChange.check(new com.google.gerrit.server.permissions.LabelPermission.WithValue(lt.getName(), a.getValue())); return true; } catch (com.google.gerrit.extensions.restapi.AuthException e) { a.setValue(forChange.squashThenCheck(lt, a.getValue())); return true; } }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert(@com.google.gerrit.common.Nullable java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getPureRevert.setClaimedOriginal(claimedOriginal).apply(change); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot compute pure revert", e); } }
@org.junit.Test public void pureRevertReturnsTrueForPureRevert() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); merge(r); java.lang.String revertId = gApi.changes().id(r.getChangeId()).revert().get().id; assertThat(gApi.changes().id(revertId).pureRevert().isPureRevert).isTrue(); assertThat(gApi.changes().id(revertId).pureRevert(getRemoteHead().toObjectId().name()).isPureRevert).isTrue(); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert() throws com.google.gerrit.extensions.restapi.RestApiException { return pureRevert(null); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert(java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
com.google.gerrit.extensions.common.PureRevertInfo pureRevert() throws com.google.gerrit.extensions.restapi.RestApiException;
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo pureRevert() throws com.google.gerrit.extensions.restapi.RestApiException { throw new com.google.gerrit.extensions.restapi.NotImplementedException(); }
com.google.gerrit.extensions.common.PureRevertInfo pureRevert(java.lang.String claimedOriginal) throws com.google.gerrit.extensions.restapi.RestApiException;
private java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents() { java.util.Set<com.google.gerrit.reviewdb.client.Project.NameKey> parents = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all()) { com.google.gerrit.server.project.ProjectState ps = projectCache.get(p); if (ps != null) { com.google.gerrit.reviewdb.client.Project.NameKey parent = ps.getProject().getParent(); if (parent != null) { parents.add(parent); } } } parents.add(allProjects); return parents; }
private void service() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.Failure, java.io.IOException { state = projectControl.getProjectState(); project = state.getProject(); projectName = project.getNameKey(); try { repo = repoManager.openRepository(projectName); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.sshd.Failure(1, (("fatal: '" + (project.getName())) + "': not a git archive"), e); } try { runImpl(); } finally { repo.close(); } }
private boolean validCommit(org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, com.google.gerrit.reviewdb.client.Branch.NameKey branch, org.eclipse.jgit.transport.ReceiveCommand cmd, org.eclipse.jgit.lib.ObjectId id) throws java.io.IOException { if (validCommits.contains(id)) { return true; } org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(id); rw.parseBody(c); try (com.google.gerrit.server.events.CommitReceivedEvent receiveEvent = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, project, branch.get(), rw.getObjectReader(), c, user)) { boolean isMerged = (((magicBranch) != null) && (cmd.getRefName().equals(magicBranch.cmd.getRefName()))) && (magicBranch.merged); com.google.gerrit.server.git.validators.CommitValidators validators = (isMerged) ? commitValidatorsFactory.forMergedCommits(perm, user.asIdentifiedUser()) : commitValidatorsFactory.forReceiveCommits(perm, branch, user.asIdentifiedUser(), sshInfo, repo, rw); messages.addAll(validators.validate(receiveEvent)); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { logDebug("Commit validation failed on {}", c.name()); messages.addAll(e.getMessages()); reject(cmd, e.getMessage()); return false; } validCommits.add(c.copy()); return true; }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.ResourceConflictException, java.io.IOException { if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName); try { try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(cmd, projectCache.checkedGet(ctx.getProject()).getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, new com.google.gerrit.reviewdb.client.Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
private void validate(com.google.gerrit.server.update.RepoContext ctx) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (checkAddPatchSetPermission) { permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origNotes).check(ChangePermission.ADD_PATCH_SET); } if (!(validate)) { return; } com.google.gerrit.server.permissions.PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origNotes.getChange().getDest()); java.lang.String refName = getPatchSetId().toRefName(); try (com.google.gerrit.server.events.CommitReceivedEvent event = new com.google.gerrit.server.events.CommitReceivedEvent(new org.eclipse.jgit.transport.ReceiveCommand(org.eclipse.jgit.lib.ObjectId.zeroId(), commitId, ((refName.substring(0, ((refName.lastIndexOf('/')) + 1))) + "new")), projectCache.checkedGet(origNotes.getProjectName()).getProject(), origNotes.getChange().getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) { commitValidatorsFactory.forGerritCommits(perm, origNotes.getChange().getDest(), ctx.getIdentifiedUser(), new com.google.gerrit.server.ssh.NoSshInfo(), ctx.getRevWalk()).validate(event); } catch (com.google.gerrit.server.git.validators.CommitValidationException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getFullMessage()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } com.google.gerrit.reviewdb.client.Account.Id accountId = Account.Id.fromRef(receiveEvent.refName); if (accountId == null) { return java.util.Collections.emptyList(); } try { java.util.List<java.lang.String> errorMessages = accountValidator.validate(accountId, receiveEvent.revWalk, receiveEvent.command.getOldId(), receiveEvent.commit); if (!(errorMessages.isEmpty())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("invalid account configuration", errorMessages.stream().map(( m) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(m, true)).collect(java.util.stream.Collectors.toList())); } } catch (java.io.IOException e) { java.lang.String m = java.lang.String.format("Validating update for account %s failed", accountId.get()); com.google.gerrit.server.git.validators.CommitValidators.log.error(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } return java.util.Collections.emptyList(); }
@java.lang.Override public Project.NameKey getProjectNameKey() { return project.getNameKey(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if ((allUsers.equals(receiveEvent.project.getNameKey())) && (RefNames.REFS_EXTERNAL_IDS.equals(receiveEvent.refName))) { try { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = externalIdsConsistencyChecker.check(receiveEvent.commit); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> msgs = problems.stream().map(( p) -> new com.google.gerrit.server.git.validators.CommitValidationMessage(p.message, (p.status == ConsistencyProblemInfo.Status.ERROR))).collect(java.util.stream.Collectors.toList()); if (msgs.stream().anyMatch(( m) -> m.isError())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("invalid external IDs", msgs); } return msgs; } catch (java.io.IOException e) { java.lang.String m = "error validating external IDs"; com.google.gerrit.server.git.validators.CommitValidators.log.warn(m, e); throw new com.google.gerrit.server.git.validators.CommitValidationException(m, e); } } return java.util.Collections.emptyList(); }
private void assertNoProblems(com.google.gerrit.server.notedb.ChangeNotes notes, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix) throws java.lang.Exception { assertThat(checker.check(controlForNotes(notes), fix).problems()).isEmpty(); }
private com.google.gerrit.server.project.ChangeControl controlForNotes(com.google.gerrit.server.notedb.ChangeNotes notes) throws java.lang.Exception { return changeControlFactory.controlFor(notes, userFactory.create(admin.id)); }
private com.google.gerrit.server.notedb.ChangeNotes incrementPatchSet(com.google.gerrit.server.notedb.ChangeNotes notes, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { com.google.gerrit.server.change.PatchSetInserter ins; try (com.google.gerrit.server.update.BatchUpdate bu = newUpdate(notes.getChange().getOwner())) { ins = patchSetInserterFactory.create(notes, nextPatchSetId(notes), commit).setValidate(false).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE); bu.addOp(notes.getChangeId(), ins).execute(); } return reload(notes); }
private void assertProblems(com.google.gerrit.server.notedb.ChangeNotes notes, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.FixInput fix, com.google.gerrit.extensions.common.ProblemInfo first, com.google.gerrit.extensions.common.ProblemInfo... rest) throws java.lang.Exception { java.util.List<com.google.gerrit.extensions.common.ProblemInfo> expected = new java.util.ArrayList((1 + (rest.length))); expected.add(first); expected.addAll(java.util.Arrays.asList(rest)); assertThat(checker.check(controlForNotes(notes), fix).problems()).containsExactlyElementsIn(expected).inOrder(); }
@org.junit.Test public void missingRepo() throws java.lang.Exception { assumeNoteDbDisabled(); com.google.gerrit.server.notedb.ChangeNotes notes = insertChange(); com.google.gerrit.reviewdb.client.Project.NameKey name = notes.getProjectName(); com.google.gerrit.server.project.ChangeControl ctl = controlForNotes(notes); ((com.google.gerrit.testutil.InMemoryRepositoryManager) (repoManager)).deleteRepository(name); assertThat(checker.check(ctl, null).problems()).containsExactly(com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem(("Destination repository not found: " + name))); }
private void setUpChange() throws java.lang.Exception { change = new com.google.gerrit.reviewdb.client.Change(new com.google.gerrit.reviewdb.client.Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new com.google.gerrit.reviewdb.client.Change.Id(1), userId, new com.google.gerrit.reviewdb.client.Branch.NameKey(allProjects, "refs/heads/master"), com.google.gerrit.common.TimeUtil.nowTs()); com.google.gerrit.reviewdb.client.PatchSetInfo ps = new com.google.gerrit.reviewdb.client.PatchSetInfo(new com.google.gerrit.reviewdb.client.PatchSet.Id(change.getId(), 1)); ps.setSubject("Test change"); change.setCurrentPatchSet(ps); db.changes().insert(com.google.common.collect.ImmutableList.of(change)); notes = changeNotesFactory.createChecked(db, change); }
private java.util.List<com.google.gerrit.server.notedb.ChangeNotes> asChangeNotes(java.util.List<com.google.gerrit.server.query.change.ChangeData> cds) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = new java.util.ArrayList(cds.size()); if (!(indexConfig.separateChangeSubIndexes())) { for (com.google.gerrit.server.query.change.ChangeData cd : cds) { notes.add(cd.notes()); } return notes; } java.util.Set<com.google.gerrit.reviewdb.client.Change.Id> seen = com.google.common.collect.Sets.newHashSetWithExpectedSize(cds.size()); for (com.google.gerrit.server.query.change.ChangeData cd : cds) { if (seen.add(cd.getId())) { notes.add(cd.notes()); } } return notes; }
private com.google.gerrit.server.change.ChangeResource parseResource(com.google.gerrit.acceptance.PushOneCommit.Result r) throws java.lang.Exception { return parseChangeResource(r.getChangeId()); }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded()); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(controlFor(change)); }
private java.util.List<com.google.gerrit.server.notedb.ChangeNotes> changeFromNotesFactory(java.lang.String id) throws com.google.gerrit.sshd.BaseCommand.UnloggedFailure, com.google.gwtorm.server.OrmException { return changeNotesFactory.create(db, parseId(id)); }
public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { if (id.isEmpty()) { return java.util.Collections.emptyList(); } int z = id.lastIndexOf('~'); int y = id.lastIndexOf('~', (z - 1)); if ((y < 0) && (z > 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id.substring((z + 1))); if (n != null) { return fromProjectNumber(id.substring(0, z), n.intValue()); } } if ((y < 0) && (z < 0)) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return find(new com.google.gerrit.reviewdb.client.Change.Id(n)); } } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if ((y > 0) && (z > 0)) { java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id, y, z); if (triplet.isPresent()) { com.google.gerrit.server.change.ChangeTriplet t = triplet.get(); return asChangeNotes(query.byBranchKey(t.branch(), t.id())); } } return asChangeNotes(query.byKeyPrefix(id)); }
private java.util.List<com.google.gerrit.server.notedb.ChangeNotes> fromProjectNumber(java.lang.String project, int changeNumber) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change.Id cId = new com.google.gerrit.reviewdb.client.Change.Id(changeNumber); try { return com.google.common.collect.ImmutableList.of(changeNotesFactory.createChecked(reviewDb.get(), Project.NameKey.parse(project), cId)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { return java.util.Collections.emptyList(); } catch (com.google.gwtorm.server.OrmException e) { if ((com.google.common.base.Throwables.getRootCause(e)) instanceof org.eclipse.jgit.errors.RepositoryNotFoundException) { return java.util.Collections.emptyList(); } throw e; } }
public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gwtorm.server.OrmException { java.lang.String project = changeIdProjectCache.getIfPresent(id); if (project != null) { return fromProjectNumber(project, id.get()); } com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); java.util.List<com.google.gerrit.server.query.change.ChangeData> r = query.byLegacyChangeId(id); if ((r.size()) == 1) { changeIdProjectCache.put(id, r.get(0).project().get()); } return asChangeNotes(r); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } else if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(controlFor(change)); }
private java.lang.String formatChangeUrl(java.lang.String url, com.google.gerrit.server.git.Input input) { java.lang.StringBuilder m = new java.lang.StringBuilder().append(" ").append(com.google.gerrit.server.ChangeUtil.formatChangeUrl(url, input.getChange())).append(" ").append(com.google.gerrit.server.ChangeUtil.cropSubject(input.getSubject())); if (input.isDraft()) { m.append(" [DRAFT]"); } if (input.isEdit()) { m.append(" [EDIT]"); } if (input.isPrivate()) { m.append(" [PRIVATE]"); } if (input.isWorkInProgress()) { m.append(" [WIP]"); } return m.toString(); }
@java.lang.Override public org.eclipse.jgit.lib.Config get() { org.eclipse.jgit.storage.file.FileBasedConfig baseConfig = com.google.gerrit.server.config.GerritServerConfigProvider.loadConfig(null, site.gerrit_config); if (!(baseConfig.getFile().exists())) { com.google.gerrit.server.config.GerritServerConfigProvider.log.info((("No " + (site.gerrit_config.toAbsolutePath())) + "; assuming defaults")); } org.eclipse.jgit.storage.file.FileBasedConfig noteDbConfigOverBaseConfig = com.google.gerrit.server.config.GerritServerConfigProvider.loadConfig(baseConfig, site.notedb_config); com.google.gerrit.server.config.GerritServerConfigProvider.checkNoteDbConfig(noteDbConfigOverBaseConfig); return new com.google.gerrit.server.config.GerritConfig(noteDbConfigOverBaseConfig, baseConfig, secureStore); }
private com.google.gerrit.acceptance.MergeableFileBasedConfig newConfig() throws java.lang.Exception { java.io.File f = java.io.File.createTempFile(getClass().getSimpleName(), ".config"); f.deleteOnExit(); return new com.google.gerrit.acceptance.MergeableFileBasedConfig(f, org.eclipse.jgit.util.FS.detect()); }
private static org.eclipse.jgit.storage.file.FileBasedConfig loadConfig(@com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config base, java.nio.file.Path path) { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(base, path.toFile(), org.eclipse.jgit.util.FS.DETECTED); try { cfg.load(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.inject.ProvisionException(e.getMessage(), e); } return cfg; }
@com.google.gerrit.common.Nullable public abstract java.lang.Boolean isWorkInProgress();
@com.google.gerrit.common.Nullable public abstract java.lang.Boolean isEdit();
@com.google.gerrit.common.Nullable public abstract java.lang.Boolean isDraft();
abstract com.google.gerrit.reviewdb.client.Change change();
private boolean requestReplace(org.eclipse.jgit.transport.ReceiveCommand cmd, boolean checkMergedInto, com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.revwalk.RevCommit newCommit) { if (change.getStatus().isClosed()) { reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().setChange(change).build())); return false; } com.google.gerrit.server.git.receive.ReceiveCommits.ReplaceRequest req = new com.google.gerrit.server.git.receive.ReceiveCommits.ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto); if (replaceByChange.containsKey(req.ontoChange)) { reject(cmd, "duplicate request"); return false; } replaceByChange.put(req.ontoChange, req); return true; }
@com.google.gerrit.common.Nullable public abstract java.lang.Boolean isPrivate();
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(db.get(), revision.getChangeResource()); return new java.util.HashSet(changeData.filePaths(revision.getPatchSet())); }
public Change.Id getId() { return notes.getChangeId(); }
public boolean isUserOwner() { com.google.gerrit.reviewdb.client.Account.Id owner = getChange().getOwner(); return (user.isIdentifiedUser()) && (user.asIdentifiedUser().getAccountId().equals(owner)); }
@java.lang.Override public java.lang.String getETag() { com.google.common.hash.Hasher h = com.google.common.hash.Hashing.murmur3_128().newHasher(); if (user.isIdentifiedUser()) { h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), java.nio.charset.StandardCharsets.UTF_8); } prepareETag(h, user); return h.hash().toString(); }
@java.lang.Override public com.google.gerrit.extensions.client.SubmitType apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getChangeResource())); com.google.gerrit.common.data.SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).getSubmitType(); if ((rec.status) != (SubmitTypeRecord.Status.OK)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec)); } return rec.type; }
private boolean isReviewer(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { if (ctx.getAccountId().equals(ctx.getChange().getOwner())) { return true; } com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), ctx); com.google.gerrit.server.ReviewerSet reviewers = cd.reviewers(); if (reviewers.byState(com.google.gerrit.server.change.REVIEWER).contains(ctx.getAccountId())) { return true; } return false; }
@java.lang.Override public java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.common.TestSubmitRuleInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { if (input == null) { input = new com.google.gerrit.extensions.common.TestSubmitRuleInput(); } if (((input.rule) != null) && (!(rules.isProjectRulesEnabled()))) { throw new com.google.gerrit.extensions.restapi.AuthException("project rules are disabled"); } input.filters = com.google.common.base.MoreObjects.firstNonNull(input.filters, filters); com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.google.gerrit.server.project.SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getChangeResource())); java.util.List<com.google.gerrit.common.data.SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(((input.filters) == (com.google.gerrit.extensions.common.TestSubmitRuleInput.Filters.SKIP))).setRule(input.rule).evaluate(); java.util.List<com.google.gerrit.server.change.TestSubmitRule.Record> out = com.google.common.collect.Lists.newArrayListWithCapacity(records.size()); com.google.gerrit.server.account.AccountLoader accounts = accountInfoFactory.create(true); for (com.google.gerrit.common.data.SubmitRecord r : records) { out.add(new com.google.gerrit.server.change.TestSubmitRule.Record(r, accounts)); } if (!(out.isEmpty())) { out.get(0).prologReductionCount = evaluator.getReductionsConsumed(); } accounts.fill(); return out; }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(ctl);org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null); accountLoader.fill(); return rev; } }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, path, parent); }
public com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.change.RevisionResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), rsrc.getChangeResource()); return format(cd, java.util.Optional.of(rsrc.getPatchSet().getId()), true); }
public PermissionBackend.ForChange permissions() { return permissionBackend.user(user).change(notes); }
public com.google.gerrit.reviewdb.client.Change getChange() { return notes.getChange(); }
@java.lang.Override public com.google.gerrit.extensions.common.PureRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.PatchSet currentPatchSet = psUtil.current(dbProvider.get(), rsrc.getNotes()); if (currentPatchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("current revision is missing"); } else if (!(changeControlFactory.controlFor(rsrc.getNotes(), rsrc.getUser()).isPatchVisible(currentPatchSet, dbProvider.get()))) { throw new com.google.gerrit.extensions.restapi.AuthException("current revision not accessible"); } return getPureRevert(rsrc.getNotes()); }
private void addPureRevertSubmitRule() throws java.lang.Exception { modifySubmitRules(("submit_rule(submit(R)) :- \n" + ((((((("gerrit:pure_revert(1), \n" + "!,") + "gerrit:commit_author(A), \n") + "R = label(\'Is-Pure-Revert\', ok(A)).\n") + "submit_rule(submit(R)) :- \n") + "gerrit:pure_revert(U), \n") + "U \\= 1,") + "R = label(\'Is-Pure-Revert\', need(_)). \n\n"))); }
@com.google.gerrit.common.Nullable public java.lang.Boolean isPureRevert() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getPureRevert(notes()).isPureRevert; } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new com.google.gwtorm.server.OrmException("could not compute pure revert", e); } }
@org.junit.Test public void pureRevertFactAllowsSubmissionOfPureReverts() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master"); merge(r1); addPureRevertSubmitRule(); java.lang.String revertId = gApi.changes().id(r1.getChangeId()).revert().get().changeId; approve(revertId); gApi.changes().id(revertId).current().submit(); }
@org.junit.Test public void pureRevertFactBlocksSubmissionOfNonPureReverts() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master"); merge(r1); addPureRevertSubmitRule(); java.lang.String revertId = gApi.changes().id(r1.getChangeId()).revert().get().changeId; amendChange(revertId); approve(revertId); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Failed to submit 1 change due to the following problems"); exception.expectMessage("needs Is-Pure-Revert"); gApi.changes().id(revertId).current().submit(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> getMembers(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seenGroups) { seenGroups.add(groupUUID); java.util.Optional<com.google.gerrit.server.group.InternalGroup> internalGroup = groupCache.get(groupUUID); if (!(internalGroup.isPresent())) { return com.google.common.collect.ImmutableSet.of(); } com.google.gerrit.server.group.InternalGroup group = internalGroup.get(); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> indirectMembers = new java.util.HashSet<>(); if ((recursive) && (groupControl.canSeeGroup())) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seenGroups.contains(subgroupUuid))) { indirectMembers.addAll(getMembers(subgroupUuid, seenGroups)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
private void addSubgroups(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.group.AddSubgroups.Input input = AddSubgroups.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).collect(java.util.stream.Collectors.toList())); addSubgroups.apply(rsrc, input); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::get).map(AccountState::getAccount).collect(toImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.union(directMembers, indirectMembers); }
public void removeSubgroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> subgroupsToRemove = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : subgroupUuids) { boolean isSubgroup = groups.isSubgroup(db, parentGroupUuid, subgroupUuid); if (isSubgroup) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid); subgroupsToRemove.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (subgroupsToRemove.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), subgroupsToRemove); } db.accountGroupById().delete(subgroupsToRemove); groupCache.evict(parentGroup.getGroupUUID(), parentGroup.getId(), parentGroup.getNameKey()); for (com.google.gerrit.reviewdb.client.AccountGroupById groupToRemove : subgroupsToRemove) { groupIncludeCache.evictParentGroupsOf(groupToRemove.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }
public void addSubgroups(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID parentGroupUuid, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuids) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup parentGroup = groups.getExistingGroup(db, parentGroupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId = parentGroup.getId(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newSubgroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID includedGroupUuid : subgroupUuids) { boolean isSubgroup = groups.isSubgroup(db, parentGroupUuid, includedGroupUuid); if (!isSubgroup) { com.google.gerrit.reviewdb.client.AccountGroupById.Key key = new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, includedGroupUuid); newSubgroups.add(new com.google.gerrit.reviewdb.client.AccountGroupById(key)); } } if (newSubgroups.isEmpty()) { return; } if ((currentUser) != null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), newSubgroups); } db.accountGroupById().insert(newSubgroups); groupCache.evict(parentGroup.getGroupUUID(), parentGroup.getId(), parentGroup.getNameKey()); for (com.google.gerrit.reviewdb.client.AccountGroupById newIncludedGroup : newSubgroups) { groupIncludeCache.evictParentGroupsOf(newIncludedGroup.getIncludeUUID()); } groupIncludeCache.evictSubgroupsOf(parentGroupUuid); }
@java.lang.Override public org.scribe.model.Verb getAccessTokenVerb() { return org.scribe.model.Verb.POST; }
@java.lang.Override public org.scribe.model.Token getAccessToken(org.scribe.model.Token requestToken, org.scribe.model.Verifier verifier) { org.scribe.model.OAuthRequest request = new org.scribe.model.OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint()); request.addBodyParameter(OAuthConstants.CLIENT_ID, config.getApiKey()); request.addBodyParameter(OAuthConstants.CLIENT_SECRET, config.getApiSecret()); request.addBodyParameter(OAuthConstants.CODE, verifier.getValue()); request.addBodyParameter(OAuthConstants.REDIRECT_URI, config.getCallback()); if (config.hasScope()) { request.addBodyParameter(OAuthConstants.SCOPE, config.getScope()); } request.addBodyParameter(com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService.GRANT_TYPE, com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService.GRANT_TYPE_VALUE); org.scribe.model.Response response = request.send(); return api.getAccessTokenExtractor().extract(response.getBody()); }
@java.lang.Override public java.lang.String getAuthorizationUrl(org.scribe.model.Token requestToken) { return api.getAuthorizationUrl(config); }
@java.lang.Override public void signRequest(org.scribe.model.Token accessToken, org.scribe.model.OAuthRequest request) { request.addQuerystringParameter(OAuthConstants.ACCESS_TOKEN, accessToken.getToken()); }
@java.lang.Override public org.scribe.model.Token getRequestToken() { throw new java.lang.UnsupportedOperationException("Unsupported operation, please use 'getAuthorizationUrl' and redirect your users there"); }
@java.lang.Override public org.scribe.oauth.OAuthService createService(org.scribe.model.OAuthConfig config) { return new com.googlesource.gerrit.plugins.oauth.DexApi.DexOAuthService(this, config); }
@java.lang.Override public java.lang.String getAuthorizationUrl(org.scribe.model.OAuthConfig config) { return java.lang.String.format(com.googlesource.gerrit.plugins.oauth.DexApi.AUTHORIZE_URL, rootUrl, config.getApiKey(), org.scribe.utils.OAuthEncoder.encode(config.getCallback()), config.getScope().replaceAll(" ", "+")); }
private void loadPublished(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, java.lang.String file) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) { comments.include(notes.getChangeId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(notes.getChangeId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null) { p.setCommentCount(((p.getCommentCount()) + 1)); } } }
private org.eclipse.jgit.lib.ObjectId getEditRev() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException, java.io.IOException { edit = editReader.byChange(notes); if (edit.isPresent()) { return edit.get().getEditCommit(); } throw new com.google.gerrit.server.project.NoSuchChangeException(notes.getChangeId()); }
private void loadDrafts(java.util.Map<com.google.gerrit.reviewdb.client.Patch.Key, com.google.gerrit.reviewdb.client.Patch> byKey, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.String file) throws com.google.gwtorm.server.OrmException { for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) { comments.include(notes.getChangeId(), c); com.google.gerrit.reviewdb.client.PatchSet.Id psId = new com.google.gerrit.reviewdb.client.PatchSet.Id(notes.getChangeId(), c.key.patchSetId); com.google.gerrit.reviewdb.client.Patch.Key pKey = new com.google.gerrit.reviewdb.client.Patch.Key(psId, c.key.filename); com.google.gerrit.reviewdb.client.Patch p = byKey.get(pKey); if (p != null) { p.setDraftCount(((p.getDraftCount()) + 1)); } } }
@java.lang.Override public boolean updateChange(com.google.gerrit.server.update.ChangeContext ctx) throws com.google.gwtorm.server.OrmException { change = ctx.getChange(); com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId()); newTopicName = com.google.common.base.Strings.nullToEmpty(input.topic); oldTopicName = com.google.common.base.Strings.nullToEmpty(change.getTopic()); if (oldTopicName.equals(newTopicName)) { return false; } java.lang.String summary; if (oldTopicName.isEmpty()) { summary = "Topic set to " + (newTopicName); } else if (newTopicName.isEmpty()) { summary = ("Topic " + (oldTopicName)) + " removed"; } else { summary = java.lang.String.format("Topic changed from %s to %s", oldTopicName, newTopicName); } change.setTopic(com.google.common.base.Strings.emptyToNull(newTopicName)); update.setTopic(change.getTopic()); com.google.gerrit.reviewdb.client.ChangeMessage cmsg = com.google.gerrit.server.ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.TAG_SET_TOPIC); cmUtil.addChangeMessage(ctx.getDb(), update, cmsg); return true; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, com.google.gerrit.server.change.PutTopic.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); if (((input != null) && ((input.topic) != null)) && ((input.topic.length()) > (com.google.gerrit.server.ChangeUtil.TOPIC_MAX_LENGTH))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH)); } com.google.gerrit.server.change.PutTopic.Op op = new com.google.gerrit.server.change.PutTopic.Op((input != null ? input : new com.google.gerrit.server.change.PutTopic.Input())); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(op.newTopicName); }
public static boolean isDefaultDashboard(@com.google.gerrit.common.Nullable com.google.gerrit.extensions.restapi.IdString id) { return (id != null) && (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id.toString())); }
public static boolean isDefaultDashboard(@com.google.gerrit.common.Nullable java.lang.String id) { return com.google.gerrit.server.project.DashboardsCollection.DEFAULT_DASHBOARD_NAME.equals(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo get(boolean inherited) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDashboard.get().setInherited(inherited).apply(resource()); } catch (java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot read dashboard", e); } }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectControl ctl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = ctl.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = ctl.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(ctl, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : ctl.getProjectState().tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { ctl = ps.controlFor(ctl.getUser()); return parse(ctl, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.project.ProjectControl myCtl = parent.getControl(); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(myCtl); } java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').limit(2).split(id.get())); if ((parts.size()) != 2) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.CurrentUser user = myCtl.getUser(); java.lang.String ref = parts.get(0); java.lang.String path = parts.get(1); for (com.google.gerrit.server.project.ProjectState ps : myCtl.getProjectState().tree()) { try { return parse(ps.controlFor(user), ref, path, myCtl); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource, ?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public com.google.gerrit.server.project.GetDashboard setInherited(boolean inherited) { this.inherited = inherited; return this; }
private void attemptToMergeAtomic(com.criteo.gerrit.plugins.automerge.Change change) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { final java.util.List<com.google.gerrit.extensions.common.ChangeInfo> related = com.google.common.collect.Lists.newArrayList(); related.addAll(api.changes().query(("status: open AND topic: " + (change.topic))).withOption(ListChangesOption.CURRENT_REVISION).get()); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { if (!(atomicityHelper.isSubmittable(info.project, info._number))) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Change {} is not submittable because same topic change {} has not all approvals.", change.number, info._number); return; } } for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { boolean dependsOnNonMergedCommit = atomicityHelper.hasDependentReview(info.project, info._number); if ((!(info.mergeable)) || dependsOnNonMergedCommit) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Change {} is not mergeable because same topic change {} {}", change.number, info._number, (!(info.mergeable) ? "is non mergeable" : "depends on a non merged commit.")); if (!(info.mergeable)) { reviewUpdater.commentOnReview(change.project, change.number, java.lang.String.format(config.cantMergeGitConflict.getContent(), info._number)); } return; } } com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info("Submitting atomic change {}...", change.number); for (final com.google.gerrit.extensions.common.ChangeInfo info : related) { atomicityHelper.mergeReview(info.project, info._number); } }
public void commentOnReview(java.lang.String project, int number, java.lang.String comment) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput reviewInput = createComment(comment); applyComment(project, number, reviewInput); }
private com.google.gerrit.extensions.api.changes.ReviewInput createComment(java.lang.String comment) { return new com.google.gerrit.extensions.api.changes.ReviewInput().message(((com.criteo.gerrit.plugins.automerge.ReviewUpdater.commentsPrefix) + comment)); }
java.lang.String getContent() { if (templatePath.exists()) { try { return com.google.common.io.Files.toString(templatePath, Charsets.UTF_8); } catch (final java.io.IOException exc) { com.criteo.gerrit.plugins.automerge.PluginComment.log.error(("Not able to read " + (templatePath)), exc); } } return defaultMessage; }
public void setMinusOne(java.lang.String project, int number, java.lang.String comment) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.ReviewInput message = createComment(comment).label("Code-Review", (-1)); applyComment(project, number, message); }
private void processNewAtomicPatchSet(com.criteo.gerrit.plugins.automerge.Change change) { try { checkReviewExists(change.number); if (atomicityHelper.hasDependentReview(change.project, change.number)) { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format("Warn the user by setting -1 on change %d, as other atomic changes exists on the same repository.", change.number)); reviewUpdater.setMinusOne(change.project, change.number, config.atomicReviewsSameRepo.getContent()); } else { com.criteo.gerrit.plugins.automerge.AutomaticMerger.log.info(java.lang.String.format("Detected atomic review on change %d.", change.number)); reviewUpdater.commentOnReview(change.project, change.number, config.atomicReviewDetected.getContent()); } } catch (com.google.gerrit.extensions.restapi.RestApiException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.update.UpdateException e) { throw new java.lang.RuntimeException(e); } }
public void ignore(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { star(rsrc.getUser().asIdentifiedUser().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL), com.google.common.collect.ImmutableSet.of()); }
public void unignore(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { star(rsrc.getUser().asIdentifiedUser().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.Mute.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.StarredChangesUtil.IllegalLabelException, com.google.gwtorm.server.OrmException { if (rsrc.isUserOwner()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("cannot mute own change"); } if (!(isMuted(rsrc))) { stars.mute(rsrc); } return com.google.gerrit.extensions.restapi.Response.ok(""); }
static java.util.Set<java.lang.String> extractTags(java.util.Set<java.lang.String> input) throws com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagException { if (input == null) { return java.util.Collections.emptySet(); } java.util.HashSet<java.lang.String> result = new java.util.HashSet<>(); for (java.lang.String hashtag : input) { if (hashtag.contains(",")) { throw com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagException.hashtagsMayNotContainCommas(); } hashtag = com.google.gerrit.server.change.HashtagsUtil.cleanupHashtag(hashtag); if (!(hashtag.isEmpty())) { result.add(hashtag); } } return result; }
static com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagException hashtagsMayNotContainCommas() { return new com.google.gerrit.server.change.HashtagsUtil.InvalidHashtagException("hashtags may not contain commas"); }
@org.junit.Test public void dashboardDoesNotExist() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceNotFoundException.class); gApi.projects().name(project.get()).dashboard("my:dashboard").get(); }
@java.lang.Override public com.google.gerrit.extensions.api.config.AccessCheckInfo checkAccess(com.google.gerrit.extensions.api.config.AccessCheckInput in) throws com.google.gerrit.extensions.restapi.RestApiException { try { return checkAccess.apply(checkExists(), in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot check access rights", e); } }
@org.junit.Test public void emptyInput() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("input requires 'account'"); gApi.projects().name(normalProject.get()).checkAccess(new com.google.gerrit.extensions.api.config.AccessCheckInput()); }
@org.junit.Test public void nonexistentEmail() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); exception.expectMessage("cannot find account doesnotexist@invalid.com"); gApi.projects().name(normalProject.get()).checkAccess(new com.google.gerrit.extensions.api.config.AccessCheckInput("doesnotexist@invalid.com", null)); }
private com.google.gerrit.extensions.client.SubmitType submitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet ps, boolean visible) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!visible) { return projectCache.checkedGet(cd.project()).getProject().getSubmitType(); } com.google.gerrit.common.data.SubmitTypeRecord str = (ps == (cd.currentPatchSet())) ? cd.submitTypeRecord() : submitRuleEvaluatorFactory.create(cd).setPatchSet(ps).getSubmitType(); if (!(str.isOk())) { logErrorAndThrow(((("Failed to get submit type for " + (cd.getId())) + ": ") + (str.errorMessage))); } return str.type; }
public static java.lang.String normalizeDashboardRef(java.lang.String ref) { if (!(ref.startsWith(com.google.gerrit.server.project.REFS_DASHBOARDS))) { return (REFS_DASHBOARDS) + ref; } return ref; }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectControl ctl, com.google.gerrit.extensions.api.projects.DashboardInfo info, com.google.gerrit.server.project.ProjectControl myCtl) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.AmbiguousObjectException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.IncorrectObjectTypeException { java.lang.String ref = com.google.gerrit.server.project.DashboardsCollection.normalizeDashboardRef(info.ref); try { permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).ref(ref).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository.isValidRefName(ref))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(ctl.getProject().getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.project.DashboardResource(myCtl, ref, info.path, cfg, false); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } }
private boolean canImport() { return (permissionBackend.user(userProvider).testOrFalse(new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, ImportCapability.ID))) || (permissionBackend.user(userProvider).testOrFalse(com.googlesource.gerrit.plugins.importer.ADMINISTRATE_SERVER)); }
private boolean canCompleteImport(com.google.gerrit.server.project.ProjectResource rsrc) { return (permissionBackend.user(currentUserProvider).testOrFalse(com.googlesource.gerrit.plugins.importer.ADMINISTRATE_SERVER)) || ((permissionBackend.user(currentUserProvider).testOrFalse(new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, ImportCapability.ID))) && (rsrc.getControl().isOwner())); }
private boolean canCopy() { return (permissionBackend.user(currentUserProvider).testOrFalse(com.googlesource.gerrit.plugins.importer.ADMINISTRATE_SERVER)) || (permissionBackend.user(currentUserProvider).testOrFalse(new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, CopyProjectCapability.ID))); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Copy...").setTitle(java.lang.String.format("Copy project %s", rsrc.getName())).setVisible(canCopy()); }
private boolean canResumeCopy(com.google.gerrit.server.project.ProjectResource rsrc) { return (permissionBackend.user(currentUserProvider).testOrFalse(com.googlesource.gerrit.plugins.importer.ADMINISTRATE_SERVER)) || ((permissionBackend.user(currentUserProvider).testOrFalse(new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, CopyProjectCapability.ID))) && (rsrc.getControl().isOwner())); }
private boolean canResumeImport(com.google.gerrit.server.project.ProjectResource rsrc) { return (permissionBackend.user(currentUserProvider).testOrFalse(com.googlesource.gerrit.plugins.importer.ADMINISTRATE_SERVER)) || ((permissionBackend.user(currentUserProvider).testOrFalse(new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, ImportCapability.ID))) && (rsrc.getControl().isOwner())); }
@java.lang.Override protected void run() throws com.google.gerrit.common.errors.NoSuchAccountException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.validators.ValidationException, com.google.gwtorm.server.OrmException, com.googlesource.gerrit.plugins.importer.UnloggedFailure, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { com.googlesource.gerrit.plugins.importer.ImportProject.Input input = new com.googlesource.gerrit.plugins.importer.ImportProject.Input(); input.from = url; input.name = name; input.user = user; input.pass = com.googlesource.gerrit.plugins.importer.PasswordUtil.readPassword(in, pass); if (!(com.google.common.base.Strings.isNullOrEmpty(parent))) { input.parent = parent; } try { com.googlesource.gerrit.plugins.importer.ImportProject importer = importProjectFactory.create(new com.google.gerrit.reviewdb.client.Project.NameKey(project)); if (!(quiet)) { importer.setErr(stderr); } com.googlesource.gerrit.plugins.importer.ImportStatistic stats = importer.apply(new com.google.gerrit.server.config.ConfigResource(), input); stdout.print((("Created Changes: " + (stats.numChangesCreated)) + "\n")); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
public static boolean isValidHttpUri(java.lang.String val) { return (((val.startsWith("https://")) || (val.startsWith("http://"))) || (val.startsWith("//"))) && (com.google.gitiles.doc.html.HtmlBuilder.URI.getValueFilter().matcher(val).find()); }
@java.lang.Override public com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID> load(com.google.gerrit.reviewdb.client.AccountGroup.UUID key) throws com.google.gwtorm.server.OrmException { java.util.stream.Stream<com.google.gerrit.server.group.InternalGroup> internalGroupStream; if (groupIndexProvider.get().getSchema().hasField(GroupField.SUBGROUP)) { internalGroupStream = groupQueryProvider.get().bySubgroup(key).stream(); } else { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { internalGroupStream = com.google.gerrit.server.group.Groups.getParentGroupsFromReviewDb(db, key).map(groupCache::get).flatMap(Streams::stream); } } return internalGroupStream.map(InternalGroup::getGroupUUID).collect(toImmutableList()); }
@org.junit.Test public void getGroup() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup adminGroup = getFromCache("Administrators"); testGetGroup(adminGroup.getGroupUUID().get(), adminGroup); testGetGroup(adminGroup.getName(), adminGroup); testGetGroup(adminGroup.getId().get(), adminGroup); }
@org.junit.Test public void branchDelegation2() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, fixers, "refs/heads/x/y/*"); com.google.gerrit.server.project.Util.doNotInherit(local, com.google.gerrit.server.project.OWNER, "refs/heads/x/y/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwnerAnyRef(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); com.google.gerrit.server.project.ProjectControl uFix = user(local, fixers); assertNotOwner(uFix); assertOwnerAnyRef(uFix); assertOwner("refs/heads/x/y/*", uFix); assertOwner("refs/heads/x/y/bar", uFix); assertNotOwner("refs/heads/x/*", uFix); assertNotOwner("refs/heads/x/y", uFix); assertNotOwner("refs/*", uFix); assertNotOwner("refs/heads/master", uFix); }
private boolean canAddRefs() { return (canPerformOnAnyRef(Permission.CREATE)) || (isOwnerAnyRef()); }
@org.junit.Test public void branchDelegation1() { com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.ADMIN, "refs/*"); com.google.gerrit.server.project.Util.allow(local, com.google.gerrit.server.project.OWNER, com.google.gerrit.server.project.Util.DEVS, "refs/heads/x/*"); com.google.gerrit.server.project.ProjectControl uDev = user(local, com.google.gerrit.server.project.Util.DEVS); assertNotOwner(uDev); assertOwnerAnyRef(uDev); assertOwner("refs/heads/x/*", uDev); assertOwner("refs/heads/x/y", uDev); assertOwner("refs/heads/x/y/*", uDev); assertNotOwner("refs/*", uDev); assertNotOwner("refs/heads/master", uDev); }
void cacheVisibleTo(com.google.gerrit.server.project.ChangeControl ctl) { visibleTo = ctl.getUser(); changeControl = ctl; }
public java.lang.Boolean isMergeable() throws com.google.gwtorm.server.OrmException { if ((mergeable) == null) { com.google.gerrit.reviewdb.client.Change c = change(); if (c == null) { return null; } if ((c.getStatus()) == (Change.Status.MERGED)) { mergeable = true; } else if ((c.getStatus()) == (Change.Status.ABANDONED)) { return null; } else if (c.isWorkInProgress()) { return null; } else { if (!(lazyLoad)) { return null; } com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); try { if ((ps == null) || (!(changeControl().isPatchVisible(ps, db)))) { return null; } } catch (com.google.gwtorm.server.OrmException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchChangeException) { return null; } throw e; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project())) { org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(c.getDest().get()); com.google.gerrit.common.data.SubmitTypeRecord str = submitTypeRecord(); if (!(str.isOk())) { return false; } java.lang.String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName(); mergeable = mergeabilityCache.get(org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(e); } } } return mergeable; }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want && (ctl.isPatchVisible(in, db.get()))) { res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo)); } } return res; } }
private java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages(com.google.gerrit.server.project.ChangeControl ctl, com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes()); if (messages.isEmpty()) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.extensions.common.ChangeMessageInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(messages.size()); for (com.google.gerrit.reviewdb.client.ChangeMessage message : messages) { com.google.gerrit.reviewdb.client.PatchSet.Id patchNum = message.getPatchSetId(); com.google.gerrit.reviewdb.client.PatchSet ps = (patchNum != null) ? map.get(patchNum) : null; if ((patchNum == null) || (ctl.isPatchVisible(ps, db.get()))) { com.google.gerrit.extensions.common.ChangeMessageInfo cmi = new com.google.gerrit.extensions.common.ChangeMessageInfo(); cmi.id = message.getKey().get(); cmi.author = accountLoader.get(message.getAuthor()); cmi.date = message.getWrittenOn(); cmi.message = message.getMessage(); cmi.tag = message.getTag(); cmi._revisionNumber = (patchNum != null) ? patchNum.get() : null; com.google.gerrit.reviewdb.client.Account.Id realAuthor = message.getRealAuthor(); if (realAuthor != null) { cmi.realAuthor = accountLoader.get(realAuthor); } result.add(cmi); } } return result; }
private java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> query() throws com.google.gerrit.index.query.QueryParseException, com.google.gwtorm.server.OrmException { if (imp.isDisabled()) { throw new com.google.gerrit.index.query.QueryParseException("query disabled"); } if (((queries) == null) || (queries.isEmpty())) { queries = java.util.Collections.singletonList("status:open"); } else if ((queries.size()) > 10) { throw new com.google.gerrit.index.query.QueryParseException("limit of 10 queries"); } int cnt = queries.size(); java.util.List<com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.query.change.ChangeData>> results = imp.query(qb.parse(queries)); com.google.gerrit.server.change.ChangeJson cjson = json.create(options); cjson.setPluginDefinedAttributesFactory(this.imp); java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> res = cjson.lazyLoad(com.google.gerrit.server.query.change.QueryChanges.containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results); for (int n = 0; n < cnt; n++) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = res.get(n); if ((results.get(n).more()) && (!(info.isEmpty()))) { com.google.common.collect.Iterables.getLast(info)._moreChanges = true; } } return res; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { try { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { org.eclipse.jgit.lib.ProgressMonitor pm = new org.eclipse.jgit.lib.TextProgressMonitor(); pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN); for (com.google.gerrit.reviewdb.client.Account.Id id : ((java.lang.Iterable<com.google.gerrit.reviewdb.client.Account.Id>) (com.google.gerrit.server.account.Accounts.readUserRefs(repo)::iterator))) { if (removeMyDrafts(repo, id)) { pm.update(1); } } pm.endTask(); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Removing \"My Drafts\" menu items failed", e); } }
public static <T extends java.lang.Throwable> void throwIfNotStaleFileHandle(T e) throws T { if (!(com.googlesource.gerrit.plugins.events.fsstore.Nfs.isStaleFileHandleInCausalChain(e))) { throw e; } }
public static boolean isStaleFileHandleInCausalChain(java.lang.Throwable throwable) { while (throwable != null) { if ((throwable instanceof java.io.IOException) && (com.googlesource.gerrit.plugins.events.fsstore.Nfs.isStaleFileHandle(((java.io.IOException) (throwable))))) { return true; } throwable = throwable.getCause(); } return false; }
@org.junit.Test public void cannotGetDashboardWithInheritedForNonDefault() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DashboardInfo info = createDashboard(DashboardsCollection.DEFAULT_DASHBOARD_NAME, "test"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("inherited flag can only be used with default"); gApi.projects().name(project.get()).dashboard(info.id).get(true); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.externalids.ExternalId id = externalIds.get(who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if ((autoUpdateAccountActiveStatus) && (who.authProvidesAccountActiveStatus())) { if ((who.isActive()) && (!(act.isActive()))) { try { setInactiveFlag.activate(act.getId()); act = byIdCache.get(id.accountId()).getAccount(); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.server.account.AccountException(("Unable to activate account " + (act.getId())), e); } } else if ((!(who.isActive())) && (act.isActive())) { try { setInactiveFlag.deactivate(act.getId()); act = byIdCache.get(id.accountId()).getAccount(); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw new com.google.gerrit.server.account.AccountException(("Unable to deactivate account " + (act.getId())), e); } } } if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
default boolean isActive(@java.lang.SuppressWarnings("unused") java.lang.String username) throws com.google.gerrit.server.account.AccountException, javax.naming.NamingException, javax.security.auth.login.LoginException { return true; }
@java.lang.Override public void start() { if (!(supportAutomaticAccountActivityUpdate)) { return; } long interval = scheduleConfig.getInterval(); long delay = scheduleConfig.getInitialDelay(); if ((delay == (MISSING_CONFIG)) && (interval == (MISSING_CONFIG))) { com.google.gerrit.server.account.AccountDeactivator.log.info("Ignoring missing accountDeactivator schedule configuration"); } else if ((delay < 0) || (interval <= 0)) { com.google.gerrit.server.account.AccountDeactivator.log.warn(java.lang.String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig)); } else { queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, java.util.concurrent.TimeUnit.MILLISECONDS); } }
public boolean isActive() { return active; }
@java.lang.Override public boolean isActive(java.lang.String username) throws com.google.gerrit.server.account.AccountException, javax.naming.NamingException, javax.security.auth.login.LoginException { try { javax.naming.directory.DirContext ctx = helper.open(); com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema = helper.getSchema(ctx); helper.findAccount(schema, ctx, username, false); } catch (com.google.gerrit.server.auth.NoSuchUserException e) { return false; } return true; }
public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( a) -> { if (!(a.isActive())) { alreadyInactive.set(true); } else { a.setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (alreadyInactive.get()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, ( a) -> { if (a.isActive()) { alreadyActive.set(true); } else { a.setActive(true); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return alreadyActive.get() ? com.google.gerrit.extensions.restapi.Response.ok("") : com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.DeleteActive.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) == (rsrc.getUser())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot deactivate own account"); } return setInactiveFlag.deactivate(rsrc.getUser().getAccountId()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutActive.Input input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return setInactiveFlag.activate(rsrc.getUser().getAccountId()); }
@java.lang.Override public void run() { com.google.gerrit.server.account.AccountDeactivator.log.debug("Running account deactivations"); try { int numberOfAccountsDeactivated = 0; for (com.google.gerrit.server.account.AccountState acc : accountQueryProvider.get().query(com.google.gerrit.server.query.account.AccountPredicates.isActive())) { com.google.gerrit.server.account.AccountDeactivator.log.debug(("processing account " + (acc.getUserName()))); if (((acc.getUserName()) != null) && (!(realm.isActive(acc.getUserName())))) { sif.deactivate(acc.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivator.log.debug(("deactivated accout " + (acc.getUserName()))); numberOfAccountsDeactivated++; } } com.google.gerrit.server.account.AccountDeactivator.log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error(("Failed to deactivate inactive accounts " + (e.getMessage())), e); } }
public void setActive(java.lang.Boolean isActive) { this.active = isActive; }
@org.junit.Test public void setReviewedAndUnreviewedLabelsForDifferentPatchSets() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); setApiUser(user); gApi.changes().id(changeId).markAsReviewed(true); assertThat(gApi.changes().id(changeId).get().reviewed).isTrue(); amendChange(changeId); assertThat(gApi.changes().id(changeId).get().reviewed).isNull(); gApi.changes().id(changeId).markAsReviewed(false); assertThat(gApi.changes().id(changeId).get().reviewed).isNull(); assertThat(gApi.accounts().self().getStars(changeId)).containsExactly((((com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL) + "/") + 1), (((com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL) + "/") + 2)); }
@org.junit.Test public void cannotSetReviewedLabelForPatchSetThatAlreadyHasUnreviewedLabel() throws java.lang.Exception { java.lang.String changeId = createChange().getChangeId(); setApiUser(user); gApi.changes().id(changeId).markAsReviewed(false); assertThat(gApi.changes().id(changeId).get().reviewed).isNull(); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage((((((((("The labels " + (com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL)) + "/") + 1) + " and ") + (com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL)) + "/") + 1) + " are mutually exclusive. Only one of them can be set.")); gApi.accounts().self().setStars(changeId, new com.google.gerrit.extensions.api.changes.StarsInput(com.google.common.collect.ImmutableSet.of(((com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL) + "/1")))); }
@java.lang.Override public void markAsReviewed(boolean reviewed) throws com.google.gerrit.extensions.restapi.RestApiException { try { if (reviewed) { markAsReviewed.apply(change, new com.google.gerrit.server.change.MarkAsReviewed.Input()); } else { markAsUnreviewed.apply(change, new com.google.gerrit.server.change.MarkAsUnreviewed.Input()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot mark change as " + (reviewed ? "reviewed" : "unreviewed")), e); } }
private static java.lang.String getReviewedLabel(com.google.gerrit.reviewdb.client.Change change) { return com.google.gerrit.server.StarredChangesUtil.getReviewedLabel(change.currentPatchSetId().get()); }
private static java.lang.String getUnreviewedLabel(com.google.gerrit.reviewdb.client.Change change) { return com.google.gerrit.server.StarredChangesUtil.getUnreviewedLabel(change.currentPatchSetId().get()); }
private static void checkMutuallyExclusiveLabels(java.util.Set<java.lang.String> labels) throws com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException { if (labels.containsAll(com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL))) { throw new com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException(com.google.gerrit.server.StarredChangesUtil.DEFAULT_LABEL, com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL); } java.util.Set<java.lang.Integer> reviewedPatchSets = labels.stream().filter(( l) -> l.startsWith(com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL)).map(( l) -> java.lang.Integer.valueOf(l.substring(((com.google.gerrit.server.StarredChangesUtil.REVIEWED_LABEL.length()) + 1)))).collect(java.util.stream.Collectors.toSet()); java.util.Set<java.lang.Integer> unreviewedPatchSets = labels.stream().filter(( l) -> l.startsWith(com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL)).map(( l) -> java.lang.Integer.valueOf(l.substring(((com.google.gerrit.server.StarredChangesUtil.UNREVIEWED_LABEL.length()) + 1)))).collect(java.util.stream.Collectors.toSet()); java.util.Optional<java.lang.Integer> ps = com.google.common.collect.Sets.intersection(reviewedPatchSets, unreviewedPatchSets).stream().findFirst(); if (ps.isPresent()) { throw new com.google.gerrit.server.StarredChangesUtil.MutuallyExclusiveLabelsException(com.google.gerrit.server.StarredChangesUtil.getReviewedLabel(ps.get()), com.google.gerrit.server.StarredChangesUtil.getUnreviewedLabel(ps.get())); } }
private static com.google.gerrit.server.StarredChangesUtil.StarRef readLabels(org.eclipse.jgit.lib.Repository repo, java.lang.String refName) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); if (ref == null) { return com.google.gerrit.server.StarredChangesUtil.StarRef.MISSING; } try (org.eclipse.jgit.lib.ObjectReader reader = repo.newObjectReader()) { org.eclipse.jgit.lib.ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB); return com.google.gerrit.server.StarredChangesUtil.StarRef.create(ref, com.google.common.base.Splitter.on(com.google.common.base.CharMatcher.whitespace()).omitEmptyStrings().split(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8))); } }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Mark Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc)); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE; if (ui.yesno(false, "Migrate draft changes to work-in-progress changes (default is private)?")) { strategy = com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.WORK_IN_PROGRESS; } ui.message(java.lang.String.format("Replace draft changes with %s changes ...", strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_159.DraftWorkflowMigrationStrategy.PRIVATE)) ? "is_private" : "work_in_progress"; e.execute(java.lang.String.format(("UPDATE changes SET %s = 'Y' WHERE status = 'd' OR " + ("EXISTS (SELECT * FROM patch_sets WHERE " + "patch_sets.change_id = changes.change_id AND patch_sets.draft = 'Y')")), column)); e.execute("UPDATE changes SET status = 'n' WHERE status = 'd'"); } ui.message("done"); }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Mark Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible((!(isReviewed(rsrc)))); }
protected java.lang.ClassLoader getMergedClassLoader(java.lang.ClassLoader beanCl, java.lang.ClassLoader dynamicBeanCl) { java.util.Map<java.lang.ClassLoader, java.lang.ref.WeakReference<java.lang.ClassLoader>> mergedClByCl = com.google.gerrit.server.DynamicOptions.mergedClByCls.get(beanCl); if (mergedClByCl == null) { mergedClByCl = java.util.Collections.synchronizedMap(new java.util.WeakHashMap<>()); com.google.gerrit.server.DynamicOptions.mergedClByCls.put(beanCl, mergedClByCl); } java.lang.ref.WeakReference<java.lang.ClassLoader> mergedClRef = mergedClByCl.get(dynamicBeanCl); java.lang.ClassLoader mergedCl = null; if (mergedClRef != null) { mergedCl = mergedClRef.get(); } if (mergedCl == null) { mergedCl = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); mergedClByCl.put(dynamicBeanCl, new java.lang.ref.WeakReference(mergedCl)); } return mergedCl; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = getMergedClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { try { java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); com.google.inject.Injector modulesInjector = injector; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { modulesInjector = injector.createChildInjector(); for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { java.lang.Class<java.lang.Module> mClass = ((java.lang.Class<java.lang.Module>) (loader.loadClass(moduleName))); modules.add(modulesInjector.getInstance(mClass)); } } return modulesInjector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); try { if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { try { java.lang.Class<?> moduleClass = loader.loadClass(moduleName); modules.add(((java.lang.Module) (moduleClass.getConstructor().newInstance()))); } catch (java.lang.NoSuchMethodException | java.lang.InstantiationException | java.lang.IllegalAccessException | java.lang.reflect.InvocationTargetException e) { com.google.gerrit.server.DynamicOptions.log.error(("ERROR loading/instantiating module " + moduleName), e); } } } return injector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.SuppressWarnings("unchecked") public com.google.gerrit.server.DynamicOptions.DynamicBean getDynamicBean(java.lang.Object bean, com.google.gerrit.server.DynamicOptions.DynamicBean dynamicBean) { java.lang.ClassLoader coreCl = getClass().getClassLoader(); java.lang.ClassLoader beanCl = bean.getClass().getClassLoader(); java.lang.ClassLoader loader = beanCl; if (beanCl != coreCl) { java.lang.ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader(); if (beanCl != dynamicBeanCl) { loader = new com.google.gerrit.server.plugins.DelegatingClassLoader(beanCl, dynamicBeanCl); } } java.lang.String className = null; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ClassNameProvider) { className = ((com.google.gerrit.server.DynamicOptions.ClassNameProvider) (dynamicBean)).getClassName(); } else if (loader != beanCl) { className = dynamicBean.getClass().getCanonicalName(); } if (className != null) { try { java.util.List<java.lang.Module> modules = new java.util.ArrayList<>(); com.google.inject.Injector modulesInjector = injector; if (dynamicBean instanceof com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) { modulesInjector = injector.createChildInjector(); for (java.lang.String moduleName : ((com.google.gerrit.server.DynamicOptions.ModulesClassNamesProvider) (dynamicBean)).getModulesClassNames()) { java.lang.Class<java.lang.Module> mClass = ((java.lang.Class<java.lang.Module>) (loader.loadClass(moduleName))); modules.add(modulesInjector.getInstance(mClass)); } } return modulesInjector.createChildInjector(modules).getInstance(((java.lang.Class<com.google.gerrit.server.DynamicOptions.DynamicBean>) (loader.loadClass(className)))); } catch (java.lang.ClassNotFoundException e) { throw new java.lang.RuntimeException(e); } } return dynamicBean; }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: unable to check permissions " + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(projectControl.getProjectState(), repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(projectControl.getProject().getNameKey(), up); } try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(javax.servlet.http.HttpServletRequest req, org.eclipse.jgit.lib.Repository repo) { org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(preUploadHooks))); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); com.google.gerrit.server.project.ProjectControl pc = ((com.google.gerrit.server.project.ProjectControl) (req.getAttribute(com.google.gerrit.httpd.GitOverHttpServlet.ATT_CONTROL))); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(pc.getProject().getNameKey(), up); } return up; }
@java.lang.Override public org.eclipse.jgit.transport.UploadPack create(com.google.gerrit.acceptance.InProcessProtocol.Context req, org.eclipse.jgit.lib.Repository repo) throws org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException { threadContext.setContext(req); com.google.gerrit.acceptance.InProcessProtocol.current.set(req); try { permissionBackend.user(userProvider).project(req.project).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.eclipse.jgit.transport.resolver.ServiceNotAuthorizedException(); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.RuntimeException(e); } com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(req.project); } catch (java.io.IOException e) { throw new java.lang.RuntimeException(e); } if (projectState == null) { throw new java.lang.RuntimeException(("can't load project state for " + (req.project.get()))); } org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setPackConfig(transferConfig.getPackConfig()); up.setTimeout(transferConfig.getTimeout()); up.setAdvertiseRefsHook(refFilterFactory.create(projectState, repo)); java.util.List<org.eclipse.jgit.transport.PreUploadHook> hooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); hooks.add(uploadValidatorsFactory.create(projectState.getProject(), repo, "localhost-test")); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(hooks)); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(req.project, up); } return up; }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.extensions.restapi.TopLevelResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { java.util.List<java.util.List<com.google.gerrit.extensions.common.ChangeInfo>> out; try { out = query(); } catch (com.google.gerrit.server.query.QueryRequiresAuthException e) { throw new com.google.gerrit.extensions.restapi.AuthException("Must be signed-in to use this operator"); } catch (com.google.gerrit.server.query.QueryParseException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage(), e); } return (out.size()) == 1 ? out.get(0) : out; }
void assertRefUpdateFor(java.util.Map<java.lang.String, java.lang.Integer> expectedProjectRefUpdateCounts) { for (java.util.Map.Entry<java.lang.String, java.lang.Integer> e : expectedProjectRefUpdateCounts.entrySet()) { assertThat(getCount(e.getKey())).isEqualTo(e.getValue()); } assertThat(countsByProjectRefs).hasSize(expectedProjectRefUpdateCounts.size()); clear(); }
@org.junit.Test public void create() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = create(2); refUpdateCounter.assertRefUpdateFor(com.google.gerrit.acceptance.api.accounts.AccountIT.RefUpdateCounter.projectRef(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)), com.google.gerrit.acceptance.api.accounts.AccountIT.RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS)); }
@java.lang.Override public void onGitReferenceUpdated(com.google.gerrit.acceptance.api.accounts.Event event) { countsByProjectRefs.incrementAndGet(com.google.gerrit.acceptance.api.accounts.AccountIT.RefUpdateCounter.projectRef(event.getProjectName(), event.getRefName())); }
void assertRefUpdateFor(java.lang.String... projectRefs) { java.util.Map<java.lang.String, java.lang.Integer> expectedRefUpdateCounts = new java.util.HashMap<>(); for (java.lang.String projectRef : projectRefs) { expectedRefUpdateCounts.put(projectRef, 1); } assertRefUpdateFor(expectedRefUpdateCounts); }
void clear() { countsByProjectRefs.clear(); }
@org.junit.Test @com.google.gerrit.acceptance.UseSsh public void createWithSshKeys() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = create(3); refUpdateCounter.assertRefUpdateFor(com.google.common.collect.ImmutableMap.of(com.google.gerrit.acceptance.api.accounts.AccountIT.RefUpdateCounter.projectRef(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)), 2, com.google.gerrit.acceptance.api.accounts.AccountIT.RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), 1)); }
long getCount(java.lang.String projectRef) { return countsByProjectRefs.get(projectRef); }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.project.ProjectState> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.project.ProjectState> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneProjectIndex.QuerySource(opts, queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneProjectIndex.NAME_SORT_FIELD, SortField.Type.STRING, false))); }
@com.google.inject.Provides java.util.Collection<com.google.gerrit.index.IndexDefinition<?, ?, ?>> getIndexDefinitions(com.google.gerrit.server.index.account.AccountIndexDefinition accounts, com.google.gerrit.server.index.change.ChangeIndexDefinition changes, com.google.gerrit.server.index.group.GroupIndexDefinition groups) { java.util.Collection<com.google.gerrit.index.IndexDefinition<?, ?, ?>> result = com.google.common.collect.ImmutableList.<com.google.gerrit.index.IndexDefinition<?, ?, ?>>of(accounts, groups, changes); java.util.Set<java.lang.String> expected = com.google.common.collect.FluentIterable.from(com.google.gerrit.server.index.IndexModule.ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet(); java.util.Set<java.lang.String> actual = com.google.common.collect.FluentIterable.from(result).transform(IndexDefinition::getName).toSet(); if (!(expected.equals(actual))) { throw new com.google.inject.ProvisionException(((("need index definitions for all schemas: " + expected) + " != ") + actual)); } return result; }
public static java.util.Set<java.lang.String> projectFields(com.google.gerrit.index.QueryOptions opts) { java.util.Set<java.lang.String> fs = opts.fields(); return fs.contains(ProjectField.NAME.getName()) ? fs : com.google.common.collect.Sets.union(fs, com.google.common.collect.ImmutableSet.of(ProjectField.NAME.getName())); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.extensions.restapi.TopLevelResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { if (com.google.common.base.Strings.isNullOrEmpty(query)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing query field"); } com.google.gerrit.server.index.project.ProjectIndex searchIndex = indexes.getSearchIndex(); if (searchIndex == null) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("no project index"); } if ((start) != 0) { queryProcessor.setStart(start); } if ((limit) != 0) { queryProcessor.setUserProvidedLimit(limit); } try { com.google.gerrit.index.query.QueryResult<com.google.gerrit.server.project.ProjectState> result = queryProcessor.query(queryBuilder.parse(query)); java.util.List<com.google.gerrit.server.project.ProjectState> projects = result.entities(); java.util.ArrayList<com.google.gerrit.extensions.common.ProjectInfo> projectInfos = com.google.common.collect.Lists.newArrayListWithCapacity(projects.size()); for (com.google.gerrit.server.project.ProjectState projectState : projects) { projectInfos.add(json.format(projectState.getProject())); } return projectInfos; } catch (com.google.gerrit.index.query.QueryParseException e) { throw new com.google.gerrit.extensions.restapi.BadRequestException(e.getMessage()); } }
private static org.apache.lucene.store.Directory dir(com.google.gerrit.index.Schema<com.google.gerrit.server.project.ProjectState> schema, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.SitePaths sitePaths) throws java.io.IOException { if (com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest(cfg)) { return new org.apache.lucene.store.RAMDirectory(); } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir(sitePaths, com.google.gerrit.lucene.LuceneProjectIndex.PROJECTS, schema); return org.apache.lucene.store.FSDirectory.open(indexDir); }
private Account.Id createAccount(java.lang.String username, java.lang.String fullName, java.lang.String email, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email != null) { accountManager.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, ( a) -> { a.setFullName(fullName); a.setPreferredEmail(email); a.setActive(active); }); return id; } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.receive.ReceiveCommits.isConfig(cmd)) { logDebug("Reloading project in cache"); try { projectCache.evict(project); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(("Cannot evict from project cache, name key: " + (project.getName())), e); } com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug("Updating project description"); repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.receive.ReceiveCommits.log.warn(("cannot update description of " + (project.getName())), e); } } }
@java.lang.Override public void evict(com.google.gerrit.reviewdb.client.Project p) throws java.io.IOException { evict(p.getNameKey()); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws java.io.IOException { for (com.google.gerrit.index.Index<?, com.google.gerrit.server.project.ProjectState> i : getWriteIndexes()) { i.replace(projectCache.get(nameKey)); } fireProjectIndexedEvent(nameKey.get()); }
@java.lang.Override public void replace(com.google.gerrit.server.project.ProjectState projectState) throws java.io.IOException { try { replace(com.google.gerrit.lucene.LuceneProjectIndex.idTerm(projectState), toDocument(projectState)).get(); } catch (java.util.concurrent.ExecutionException | java.lang.InterruptedException e) { throw new java.io.IOException(e); } }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.project.ProjectState> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.project.ProjectState> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.elasticsearch.ElasticProjectIndex.QuerySource(p, opts); }
private org.eclipse.jgit.lib.Repository openRepository(java.nio.file.Path path, com.google.gerrit.reviewdb.client.Project.NameKey name) throws org.eclipse.jgit.errors.RepositoryNotFoundException { if (isUnreasonableName(name)) { throw new org.eclipse.jgit.errors.RepositoryNotFoundException(("Invalid name: " + name)); } org.eclipse.jgit.lib.RepositoryCache.FileKey loc = org.eclipse.jgit.lib.RepositoryCache.FileKey.lenient(path.resolve(name.get()).toFile(), FS.DETECTED); try { return org.eclipse.jgit.lib.RepositoryCache.open(loc); } catch (java.io.IOException e1) { final org.eclipse.jgit.errors.RepositoryNotFoundException e2; e2 = new org.eclipse.jgit.errors.RepositoryNotFoundException(("Cannot open repository " + name)); e2.initCause(e1); throw e2; } }
private void setAccount() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { user = genericUserFactory.create(id); rsrc = new com.google.gerrit.server.account.AccountResource(user); try { for (java.lang.String email : addEmails) { addEmail(email); } for (java.lang.String email : deleteEmails) { deleteEmail(email); } if ((preferredEmail) != null) { putPreferred(preferredEmail); } if ((fullName) != null) { com.google.gerrit.server.account.PutName.Input in = new com.google.gerrit.server.account.PutName.Input(); in.name = fullName; putName.apply(rsrc, in); } if (((httpPassword) != null) || (clearHttpPassword)) { com.google.gerrit.extensions.common.HttpPasswordInput in = new com.google.gerrit.extensions.common.HttpPasswordInput(); in.httpPassword = httpPassword; putHttpPassword.apply(rsrc, in); } if (active) { putActive.apply(rsrc, null); } else if (inactive) { try { deleteActive.apply(rsrc, null); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } addSshKeys = readSshKey(addSshKeys); if (!(addSshKeys.isEmpty())) { addSshKeys(addSshKeys); } deleteSshKeys = readSshKey(deleteSshKeys); if (!(deleteSshKeys.isEmpty())) { deleteSshKeys(deleteSshKeys); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.common.HttpPasswordInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } if (input == null) { input = new com.google.gerrit.extensions.common.HttpPasswordInput(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { newPassword = null; } else { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> load(com.google.gerrit.reviewdb.client.AccountGroup.Id key) throws java.lang.Exception { if (hasGroupIndex) { return groupQueryProvider.get().byId(key); } try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return groups.getGroup(db, key); } }
@org.junit.Test public void pushToPublishMagicBranchIsAllowed() throws java.lang.Exception { createChange("refs/publish/master"); com.google.gerrit.acceptance.PushOneCommit.Result result = pushTo("refs/publish/master"); result.assertOkStatus(); assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* is deprecated, use refs/for/* instead.\n"); }
@java.lang.Override public java.lang.String formQueryFromRequestParameters(java.util.Map<java.lang.String, java.lang.String> params) throws com.ericsson.gerrit.plugins.eventslog.MalformedQueryException { if (params == null) { return getDefaultQuery(); } java.lang.String[] dates; try { dates = parseDates(params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_ONE), params.get(com.ericsson.gerrit.plugins.eventslog.sql.SQLQueryMaker.TIME_TWO)); } catch (java.time.format.DateTimeParseException e) { throw new com.ericsson.gerrit.plugins.eventslog.MalformedQueryException(e); } return java.lang.String.format("SELECT * FROM %s WHERE %s BETWEEN '%s' and '%s' LIMIT %d", com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME, com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.DATE_ENTRY, dates[0], dates[1], returnLimit); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error("Couldn't fire event", e); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); java.lang.Boolean isWorldReadable = null; try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want) { if (isWorldReadable == null) { isWorldReadable = isWorldReadable(cd); } res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo, isWorldReadable)); } } return res; } }
private boolean isWorldReadable(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { try { permissionBackendForChange(anonymous, cd).check(ChangePermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException ae) { return false; } }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.patch.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null, isWorldReadable(cd)); accountLoader.fill(); return rev; } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> makeFetchMap(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in, boolean isWorldReadable) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FetchInfo> r = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.registration.DynamicMap.Entry<com.google.gerrit.extensions.config.DownloadScheme> e : downloadSchemes) { java.lang.String schemeName = e.getExportName(); com.google.gerrit.extensions.config.DownloadScheme scheme = e.getProvider().get(); if ((!(scheme.isEnabled())) || ((scheme.isAuthRequired()) && (!(userProvider.get().isIdentifiedUser())))) { continue; } if ((!(scheme.isAuthSupported())) && (!isWorldReadable)) { continue; } java.lang.String projectName = cd.project().get(); java.lang.String url = scheme.getUrl(projectName); java.lang.String refName = in.getRefName(); com.google.gerrit.extensions.common.FetchInfo fetchInfo = new com.google.gerrit.extensions.common.FetchInfo(url, refName); r.put(schemeName, fetchInfo); if (has(com.google.gerrit.server.change.DOWNLOAD_COMMANDS)) { com.google.gerrit.server.change.ChangeJson.populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo); } } return r; }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error("Couldn't fire event", e); } }
com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List all() { return com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List.union(to, cc, bcc); }
private static com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List union(com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List... others) { com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List union = new com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List(); for (com.google.gerrit.server.mail.send.ProjectWatch.Watchers.List other : others) { union.accounts.addAll(other.accounts); union.emails.addAll(other.emails); } return union; }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canUpdate(); case FORCE_UPDATE : return canForceUpdate(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_SERVER : return canForgeGerritServerIdentity(); case MERGE : return canUploadMerges(); case CREATE_CHANGE : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case READ_PRIVATE_CHANGES : return canViewPrivateChanges(); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name()); case WRITE_CONFIG : return isOwner(); case SKIP_VALIDATION : return ((((canForgeAuthor()) && (canForgeCommitter())) && (canForgeGerritServerIdentity())) && (canUploadMerges())) && (!(projectControl.getProjectState().isUseSignedOffBy())); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private boolean isOwnerOfProjectOrBranch(com.google.gerrit.reviewdb.client.Account.Id userId) { return permissionBackend.user(identifiedUserFactory.create(userId)).ref(change.getDest()).testOrFalse(RefPermission.WRITE_CONFIG); }
private boolean canWriteConfig() throws com.google.gerrit.server.permissions.PermissionBackendException { checkNotNull(user); if ((canWriteConfig) != null) { return canWriteConfig; } try { permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_CONFIG); canWriteConfig = true; } catch (com.google.gerrit.extensions.restapi.AuthException e) { canWriteConfig = false; } return canWriteConfig; }
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isInternalUser()) || (canPerformOnAnyRef(Permission.READ)))) || (isOwner()); case READ : return (!(isHidden())) && (allRefsAreVisible(java.util.Collections.emptySet())); case READ_NO_CONFIG : return (!(isHidden())) && (allRefsAreVisible(com.google.common.collect.ImmutableSet.of(RefNames.REFS_CONFIG))); case CREATE_REF : return canAddRefs(); case CREATE_CHANGE : return canCreateChanges(); case RUN_RECEIVE_PACK : return canRunReceivePack(); case RUN_UPLOAD_PACK : return canRunUploadPack(); case BAN_COMMIT : case READ_REFLOG : case READ_CONFIG : case WRITE_CONFIG : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.BanCommit.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResultInfo r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input != null) && ((input.commits) != null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList<>(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } com.google.gerrit.server.git.BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason); r.newlyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommits(result.getAlreadyBannedCommits()); r.ignored = com.google.gerrit.server.project.BanCommit.transformCommits(result.getIgnoredObjectIds()); } return r; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.ChangeInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.FixInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(user); if (!(rsrc.isUserOwner())) { perm.project(rsrc.getProject()).check(ProjectPermission.READ_CONFIG); } return com.google.gerrit.extensions.restapi.Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc)); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG); return apply(rsrc.getProjectState(), input); }
@org.junit.Test public void nonOwnerCannotSetConfig() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ConfigInput input = createTestConfigInput(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("write config not permitted"); gApi.projects().name(project.get()).config(input); }
@java.lang.Override public java.lang.String format(org.apache.log4j.spi.LoggingEvent event) { final java.lang.StringBuffer buf = new java.lang.StringBuffer(128); buf.append(formatDate(event.getTimeStamp())); buf.append(' '); buf.append(event.getLevel().toString()); req(DeleteLog.ACCOUNT_ID, buf, event); req(DeleteLog.USER_NAME, buf, event); buf.append(' '); buf.append(event.getMessage()); req(DeleteLog.PROJECT_NAME, buf, event); opt(DeleteLog.OPTIONS, buf, event); opt(DeleteLog.ERROR, buf, event); buf.append('\n'); return buf.toString(); }
private java.lang.String formatDate(long now) { java.time.ZonedDateTime zdt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(now), java.time.ZoneId.systemDefault()); return zdt.format(com.googlesource.gerrit.plugins.deleteproject.DeleteLogLayout.DATE_FORMATTER); }
@java.lang.Override public boolean match(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { if (cd.fastIsVisibleTo(user)) { return true; } com.google.gerrit.reviewdb.client.Change change = cd.change(); if (change == null) { return false; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.createFromIndexedChange(change); boolean visible; try { visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { if ((e.getCause()) instanceof com.google.gerrit.server.project.NoSuchProjectException) { com.google.gerrit.server.query.change.ChangeIsVisibleToPredicate.logger.info("No such project: {}", cd.project()); return false; } throw new com.google.gwtorm.server.OrmException("unable to check permissions", e); } if (visible) { cd.cacheVisibleTo(user); return true; } return false; }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> toAccounts(java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p) { java.util.Set<com.google.gerrit.reviewdb.client.Account> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); for (java.lang.String r : in) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(r); if (account != null) { reviewers.add(account); continue; } } catch (com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.error(("Failed to resolve account " + r), e); continue; } try { reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p)); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Reviewer %s is neither an account nor a group", r)); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s and project %s", r, p)); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.log.warn(java.lang.String.format("Failed to list accounts for group %s", r), e); } } return reviewers; }
com.google.gerrit.server.git.receive.ReplaceOp create(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.reviewdb.client.Branch.NameKey dest, boolean checkMergedInto, @com.google.inject.assistedinject.Assisted("priorPatchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id priorPatchSetId, @com.google.inject.assistedinject.Assisted("priorCommitId") org.eclipse.jgit.lib.ObjectId priorCommit, @com.google.inject.assistedinject.Assisted("patchSetId") com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, @com.google.inject.assistedinject.Assisted("commitId") org.eclipse.jgit.lib.ObjectId commitId, com.google.gerrit.reviewdb.client.PatchSetInfo info, java.util.List<java.lang.String> groups, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.receive.ReceiveCommits.MagicBranchInput magicBranch, @com.google.gerrit.common.Nullable org.eclipse.jgit.transport.PushCertificate pushCertificate);
void addOps(com.google.gerrit.server.update.BatchUpdate bu, @com.google.gerrit.common.Nullable com.google.gerrit.server.git.MultiProgressMonitor.Task progress) throws java.io.IOException { if (((magicBranch) != null) && ((magicBranch.edit) || (magicBranch.draft))) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ReceiveCommits.ReindexOnlyOp()); if ((prev) != null) { bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(prev)); } bu.addRepoOnlyOp(new com.google.gerrit.server.git.receive.ReceiveCommits.UpdateOneRefOp(cmd)); return; } org.eclipse.jgit.revwalk.RevWalk rw = rp.getRevWalk(); org.eclipse.jgit.revwalk.RevCommit newCommit = rw.parseCommit(newCommitId); rw.parseBody(newCommit); org.eclipse.jgit.revwalk.RevCommit priorCommit = revisions.inverse().get(priorPatchSet); replaceOp = replaceOpFactory.create(projectState, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator); bu.addOp(notes.getChangeId(), replaceOp); if (progress != null) { bu.addOp(notes.getChangeId(), new com.google.gerrit.server.git.receive.ChangeProgressOp(progress)); } }
@java.lang.Override protected void runImpl() throws com.google.gerrit.sshd.commands.Failure, java.io.IOException { try { permissionBackend.user(user).project(projectState.getNameKey()).check(ProjectPermission.RUN_UPLOAD_PACK); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.sshd.commands.Failure(1, "fatal: upload-pack not permitted on this server"); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.sshd.commands.Failure(1, ("fatal: unable to check permissions " + e)); } final org.eclipse.jgit.transport.UploadPack up = new org.eclipse.jgit.transport.UploadPack(repo); up.setAdvertiseRefsHook(refFilterFactory.create(projectState, repo)); up.setPackConfig(config.getPackConfig()); up.setTimeout(config.getTimeout()); up.setPostUploadHook(org.eclipse.jgit.transport.PostUploadHookChain.newChain(com.google.common.collect.Lists.newArrayList(postUploadHooks))); java.util.List<org.eclipse.jgit.transport.PreUploadHook> allPreUploadHooks = com.google.common.collect.Lists.newArrayList(preUploadHooks); allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString())); up.setPreUploadHook(org.eclipse.jgit.transport.PreUploadHookChain.newChain(allPreUploadHooks)); for (com.google.gerrit.server.git.UploadPackInitializer initializer : uploadPackInitializers) { initializer.init(projectState.getNameKey(), up); } try { up.upload(in, out, err); session.setPeerAgent(up.getPeerUserAgent()); } catch (com.google.gerrit.server.git.validators.UploadValidationException e) { if (!(e.isOutput())) { up.sendMessage(e.getMessage()); } } }
private void index(com.google.gerrit.server.project.ProjectState projectState) { try { index.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), null); } catch (java.lang.Exception e) { writeError("error", java.lang.String.format("Unable to index %s: %s", projectState.getName(), e.getMessage())); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.project.BanCommit.Input input = BanCommit.Input.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName)); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), input); printCommits(r.newlyBanned, "The following commits were banned"); printCommits(r.alreadyBanned, "The following commits were already banned"); printCommits(r.ignored, "The following ids do not represent commits and were ignored"); } catch (java.lang.Exception e) { throw die(e); } }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> filterGroupsOwnedBy(java.util.function.Predicate<com.google.gerrit.common.data.GroupDescription.Internal> filter) throws com.google.gwtorm.server.OrmException { java.util.regex.Pattern pattern = getRegexPattern(); java.util.stream.Stream<com.google.gerrit.common.data.GroupDescription.Internal> foundGroups = groups.getAll(db.get()).map(GroupDescriptions::forAccountGroup).filter(( group) -> !(isNotRelevant(pattern, group))).filter(filter).sorted(com.google.gerrit.server.group.ListGroups.GROUP_COMPARATOR).skip(start); if ((limit) > 0) { foundGroups = foundGroups.limit(limit); } java.util.List<com.google.gerrit.common.data.GroupDescription.Internal> ownedGroups = foundGroups.collect(toImmutableList()); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = new java.util.ArrayList(ownedGroups.size()); for (com.google.gerrit.common.data.GroupDescription.Internal group : ownedGroups) { groupInfos.add(json.addOptions(options).format(group)); } return groupInfos; }
public java.util.List<com.google.gerrit.extensions.common.GroupInfo> get() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if (!(com.google.common.base.Strings.isNullOrEmpty(suggest))) { return suggestGroups(); } if ((!(com.google.common.base.Strings.isNullOrEmpty(matchSubstring))) && (!(com.google.common.base.Strings.isNullOrEmpty(matchRegex)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Specify one of m/r"); } if ((ownedBy) != null) { return getGroupsOwnedBy(ownedBy); } if (owned) { return getGroupsOwnedBy(((user) != null ? userFactory.create(user) : identifiedUser.get())); } if ((user) != null) { return accountGetGroups.apply(new com.google.gerrit.server.account.AccountResource(userFactory.create(user))); } return getAllGroups(); }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> getGroupsOwnedBy(java.lang.String id) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { java.lang.String uuid = groupsCollection.parse(id).getGroupUUID().get(); return filterGroupsOwnedBy(( group) -> group.getOwnerGroupUUID().get().equals(uuid)); }
@org.kohsuke.args4j.Option(name = "--owned-by", usage = "list groups owned by the given group uuid") public void setOwnedBy(java.lang.String ownedBy) { this.ownedBy = ownedBy; }
public java.lang.String getOwnedBy() { return ownedBy; }
public com.google.gerrit.extensions.api.groups.Groups.ListRequest withOwnedBy(java.lang.String ownedBy) { this.ownedBy = ownedBy; return this; }
@org.junit.Test public void getGroupsByOwner() throws java.lang.Exception { java.lang.String parent = createGroup("test-parent"); java.util.List<java.lang.String> children = java.util.Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent)); java.util.List<com.google.gerrit.extensions.common.GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID().get()).get(); assertThat(owned.stream().map(( g) -> g.name).collect(java.util.stream.Collectors.toList())).containsExactlyElementsIn(children); owned = gApi.groups().list().withOwnedBy(parent).get(); assertThat(owned.stream().map(( g) -> g.name).collect(java.util.stream.Collectors.toList())).containsExactlyElementsIn(children); owned = gApi.groups().list().withOwnedBy(owned.get(0).id).get(); assertThat(owned).isEmpty(); exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); exception.expectMessage("Group Not Found: does-not-exist"); gApi.groups().list().withOwnedBy("does-not-exist").get(); }
private void checkLabels(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.common.data.LabelTypes labelTypes, java.util.Map<java.lang.String, java.lang.Short> labels) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions(); java.util.Iterator<java.util.Map.Entry<java.lang.String, java.lang.Short>> itr = labels.entrySet().iterator(); while (itr.hasNext()) { java.util.Map.Entry<java.lang.String, java.lang.Short> ent = itr.next(); com.google.gerrit.common.data.LabelType lt = labelTypes.byLabel(ent.getKey()); if (lt == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("label \"%s\" is not a configured label", ent.getKey())); } if (((ent.getValue()) == null) || ((ent.getValue()) == 0)) { continue; } if ((lt.getValue(ent.getValue())) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue())); } short val = ent.getValue(); try { perm.check(new com.google.gerrit.server.permissions.LabelPermission.WithValue(lt, val)); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Applying label \"%s\": %d is restricted", lt.getName(), val)); } } }
protected static com.google.gerrit.acceptance.AbstractNotificationTest.FakeEmailSenderSubject assertThat(com.google.gerrit.testutil.FakeEmailSender sender) { return assertAbout(com.google.gerrit.acceptance.AbstractNotificationTest.FakeEmailSenderSubject::new).that(sender); }
public static com.google.gerrit.extensions.common.EditInfoSubject assertThat(com.google.gerrit.extensions.common.EditInfo editInfo) { return assertAbout(com.google.gerrit.extensions.common.EditInfoSubject::new).that(editInfo); }
public static com.google.gerrit.extensions.common.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.FixReplacementInfoSubject::new).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common.FixSuggestionInfoSubject assertThat(com.google.gerrit.extensions.common.FixSuggestionInfo fixSuggestionInfo) { return assertAbout(com.google.gerrit.extensions.common.FixSuggestionInfoSubject::new).that(fixSuggestionInfo); }
public static com.google.gerrit.extensions.common.GitPersonSubject assertThat(com.google.gerrit.extensions.common.GitPerson gitPerson) { return assertAbout(com.google.gerrit.extensions.common.GitPersonSubject::new).that(gitPerson); }
public static com.google.gerrit.extensions.common.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.RobotCommentInfoSubject::new).that(robotCommentInfo); }
public static com.google.gerrit.extensions.restapi.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.BinaryResultSubject::new).that(binaryResult); }
public static com.google.gerrit.server.edit.tree.ChangeFileContentModificationSubject assertThat(com.google.gerrit.server.edit.tree.ChangeFileContentModification modification) { return assertAbout(com.google.gerrit.server.edit.tree.ChangeFileContentModificationSubject::new).that(modification); }
public static com.google.gerrit.extensions.common.ContentEntrySubject assertThat(com.google.gerrit.extensions.common.DiffInfo.ContentEntry contentEntry) { return assertAbout(com.google.gerrit.extensions.common.ContentEntrySubject::new).that(contentEntry); }
public static com.google.gerrit.server.edit.tree.TreeModificationSubject assertThat(com.google.gerrit.server.edit.tree.TreeModification treeModification) { return assertAbout(com.google.gerrit.server.edit.tree.TreeModificationSubject::new).that(treeModification); }
public static com.google.gerrit.extensions.common.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.CommitInfoSubject::new).that(commitInfo); }
public static com.google.gerrit.extensions.client.RangeSubject assertThat(com.google.gerrit.extensions.client.Comment.Range range) { return assertAbout(com.google.gerrit.extensions.client.RangeSubject::new).that(range); }
public static com.google.gerrit.extensions.common.FileInfoSubject assertThat(com.google.gerrit.extensions.common.FileInfo fileInfo) { return assertAbout(com.google.gerrit.extensions.common.FileInfoSubject::new).that(fileInfo); }
public static com.google.gerrit.extensions.common.PathSubject assertThat(java.nio.file.Path path) { return assertAbout(com.google.gerrit.extensions.common.PathSubject::new).that(path); }
public static com.google.gerrit.extensions.common.DiffInfoSubject assertThat(com.google.gerrit.extensions.common.DiffInfo diffInfo) { return assertAbout(com.google.gerrit.extensions.common.DiffInfoSubject::new).that(diffInfo); }
static java.lang.String getOwnersFileName(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.query.change.ChangeData c) { if (((com.googlesource.gerrit.plugins.findowners.Config.config) != null) && (project != null)) { try { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS); if (name.trim().equals("")) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((((((("Project " + project) + " has wrong ") + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) + ": \"") + name) + "\" for ") + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(c)))); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.findowners.Config.log.error(((("Cannot find project " + project) + " for ") + (com.googlesource.gerrit.plugins.findowners.Config.getChangeId(c))), e); } } return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (java.sql.PreparedStatement uuidRetrieval = prepareStatement(db, "SELECT group_uuid FROM account_groups WHERE group_id = ?");java.sql.PreparedStatement groupDeletion = prepareStatement(db, "DELETE FROM account_groups WHERE group_id = ?");java.sql.PreparedStatement groupNameDeletion = prepareStatement(db, "DELETE FROM account_group_names WHERE group_id = ?")) { for (com.google.gerrit.reviewdb.client.AccountGroup.Id id : com.google.gerrit.server.schema.Schema_87.scanSystemGroups(db)) { java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupUuid = com.google.gerrit.server.schema.Schema_87.getUuid(uuidRetrieval, id); if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) { groupDeletion.setInt(1, id.get()); groupDeletion.executeUpdate(); groupNameDeletion.setInt(1, id.get()); groupNameDeletion.executeUpdate(); } } } }
@org.junit.Before public void setUp() throws java.lang.Exception { testEnv.getInjector().injectMembers(this); db = testEnv.getDb(); assume().that(((db) instanceof com.google.gwtorm.jdbc.JdbcSchema)).isTrue(); connection = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection(); createdOnRetrieval = connection.prepareStatement("SELECT created_on FROM account_groups WHERE group_id = ?"); createdOnUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?"); auditEntryDeletion = connection.prepareStatement("DELETE FROM account_group_members_audit WHERE group_id = ?"); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (java.sql.PreparedStatement groupUpdate = prepareStatement(db, "UPDATE account_groups SET created_on = ? WHERE group_id = ?");java.sql.PreparedStatement addedOnRetrieval = prepareStatement(db, ("SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC"))) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.Id> accountGroups = com.google.gerrit.server.schema.Schema_151.getAllGroupIds(db); for (com.google.gerrit.reviewdb.client.AccountGroup.Id groupId : accountGroups) { java.util.Optional<java.sql.Timestamp> firstTimeMentioned = com.google.gerrit.server.schema.Schema_151.getFirstTimeMentioned(addedOnRetrieval, groupId); java.sql.Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs); groupUpdate.setTimestamp(1, createdOn); groupUpdate.setInt(2, groupId.get()); groupUpdate.executeUpdate(); } } }
public java.lang.String getChangeMessageThreadId() { return ((((("<gerrit." + (change.getCreatedOn().getTime())) + ".") + (change.getKey().get())) + "@") + (this.getGerritHost())) + ">"; }
@java.lang.Override protected void init() throws com.google.gerrit.common.errors.EmailException { super.init(); setListIdHeader(); }
private void setReviewer(boolean add, java.lang.String id) throws java.lang.Exception { adminSshSession.exec(java.lang.String.format("gerrit set-reviewers -%s %s %s", (add ? "a" : "r"), user.email, id)); assert_().withFailureMessage(adminSshSession.getError()).that(adminSshSession.hasError()).isFalse(); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> reviewers = change.getChange().getReviewers().all(); if (add) { assertThat(reviewers).contains(user.id); } else { assertThat(reviewers).doesNotContain(user.id); } }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections(com.googlesource.gerrit.plugins.webhooks.RemoteConfig.REMOTE)) { com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote = remoteFactory.create(cfg, name); if (com.google.common.base.Strings.isNullOrEmpty(remote.getUrl())) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("remote.{}.url not defined, skipping this remote", name); continue; } taskFactory.create(projectEvent, remote).schedule(); } }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, processor, projectCreated, remote); }
@org.junit.Test public void nonProjectEventNotProcessed() { com.google.gerrit.server.events.Event nonProjectEvent = new com.google.gerrit.server.events.Event("non-project-event") {}; eventHandler.onEvent(nonProjectEvent); verifyZeroInteractions(remoteFactory); verifyZeroInteractions(taskFactory); verifyZeroInteractions(postTask); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote);
@org.junit.Test public void remoteUrlUndefinedTaskNotScheduled() { when(config.getSubsections(eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.REMOTE))).thenReturn(com.google.common.collect.ImmutableSet.of(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO)); eventHandler.onEvent(projectCreated); verifyZeroInteractions(taskFactory); verifyZeroInteractions(postTask); }
@org.junit.Test public void remoteUrlDefinedTaskScheduled() { when(config.getSubsections(eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.REMOTE))).thenReturn(com.google.common.collect.ImmutableSet.of(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO)); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO_URL); eventHandler.onEvent(projectCreated); verify(taskFactory, times(1)).create(eq(projectCreated), eq(remote)); verify(postTask, times(1)).schedule(); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(projectCreated.getProjectNameKey()).thenReturn(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME); when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(remoteFactory.create(eq(config), eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO))).thenReturn(remote); when(taskFactory.create(eq(projectCreated), eq(remote))).thenReturn(postTask); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, remoteFactory, taskFactory); }
java.lang.String process(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote);
@java.lang.Override public java.lang.String doProcess(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote) { return com.googlesource.gerrit.plugins.webhooks.processors.GerritEventProcessor.GSON.toJson(event); }
protected boolean shouldProcess(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote) { java.lang.String[] wantedEvents = remote.getEvents(); if ((wantedEvents.length) == 0) { return true; } for (java.lang.String type : wantedEvents) { if ((!(com.google.common.base.Strings.isNullOrEmpty(type))) && (type.equals(event.getType()))) { return true; } } return false; }
@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class); bind(org.apache.http.impl.client.CloseableHttpClient.class).toProvider(com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class).in(Scopes.SINGLETON); factory(PostTask.Factory.class); factory(RemoteConfig.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); install(processors); }
public java.util.List<com.google.gerrit.server.project.ChangeControl> find(java.lang.String id, com.google.gerrit.server.CurrentUser user) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.InternalChangeQuery query = queryProvider.get().noFields(); if (id.matches((((("^([0-9a-fA-F]{" + (com.google.gerrit.reviewdb.client.RevId.ABBREV_LEN)) + ",") + (com.google.gerrit.reviewdb.client.RevId.LEN)) + "})$"))) { return asChangeControls(query.byCommit(id), user); } if ((!(id.isEmpty())) && ((id.charAt(0)) != '0')) { java.lang.Integer n = com.google.common.primitives.Ints.tryParse(id); if (n != null) { return asChangeControls(query.byLegacyChangeId(new com.google.gerrit.reviewdb.client.Change.Id(n)), user); } } if (!(id.contains("~"))) { return asChangeControls(query.byKeyPrefix(id), user); } java.util.Optional<com.google.gerrit.server.change.ChangeTriplet> triplet = com.google.gerrit.server.change.ChangeTriplet.parse(id); if (triplet.isPresent()) { return asChangeControls(query.byBranchKey(triplet.get().branch(), triplet.get().id()), user); } return java.util.Collections.emptyList(); }
@java.lang.Override public void setStatus(java.lang.String status) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.accounts.StatusInput in = new com.google.gerrit.extensions.api.accounts.StatusInput(status); try { putStatus.apply(account, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot set status", e); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.api.accounts.StatusInput input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.api.accounts.StatusInput(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), ( a) -> a.setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()) ? com.google.gerrit.extensions.restapi.Response.none() : com.google.gerrit.extensions.restapi.Response.ok(account.getStatus()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.StatusInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get()) != (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } return apply(rsrc.getUser(), input); }
protected void configLabel(java.lang.String label, java.lang.String func) throws java.lang.Exception { configLabel(project, label, func, value(1, "Passes"), value(0, "No score"), value((-1), "Failed")); }
protected java.lang.String createAccount(java.lang.String name, java.lang.String group) throws java.lang.Exception { name = name(name); accountCreator.create(name, group); return name; }
@org.junit.Test public void noNormalizeByPermission() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); allow(pc, forLabel("Verified"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 2); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(notes, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
@org.junit.Test public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig pc = loadAllProjects(); allow(pc, forLabel("Code-Review"), (-1), 1, com.google.gerrit.server.git.REGISTERED_USERS, "refs/heads/*"); save(pc); com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 0); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 0); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(notes, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
protected void configLabel(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String label, java.lang.String func, com.google.gerrit.common.data.LabelValue... value) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(project).getConfig(); com.google.gerrit.common.data.LabelType labelType = category(label, value); labelType.setFunctionName(func); cfg.getLabelSections().put(labelType.getName(), labelType); saveProjectConfig(project, cfg); }
@org.junit.Test public void emptyPermissionRangeKeepsResult() throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa(userId, "Code-Review", 1); com.google.gerrit.reviewdb.client.PatchSetApproval v = psa(userId, "Verified", 1); assertEquals(com.google.gerrit.server.git.LabelNormalizer.Result.create(com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v), com.google.gerrit.server.git.LabelNormalizerTest.list(), com.google.gerrit.server.git.LabelNormalizerTest.list()), norm.normalize(notes, com.google.gerrit.server.git.LabelNormalizerTest.list(cr, v))); }
public com.google.gerrit.common.data.LabelFunction getFunction() { if ((functionName) == null) { return null; } java.util.Optional<com.google.gerrit.common.data.LabelFunction> f = com.google.gerrit.common.data.LabelFunction.parse(functionName); if (!(f.isPresent())) { throw new java.lang.IllegalStateException(("Unsupported functionName: " + (functionName))); } return f.get(); }
public void setFunction(@com.google.gerrit.common.Nullable com.google.gerrit.common.data.LabelFunction function) { this.functionName = (function != null) ? function.getFunctionName() : null; }
@org.junit.Test public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get(), com.google.gerrit.acceptance.git.DETAILED_LABELS, com.google.gerrit.acceptance.git.MESSAGES, com.google.gerrit.acceptance.git.DETAILED_ACCOUNTS); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(2); int indexAdmin = (admin.fullName.equals(cr.all.get(0).name)) ? 0 : 1; int indexUser = (indexAdmin == 0) ? 1 : 0; assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName); assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1); assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName); assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1."); assertThatUserIsOnlyReviewer(ci, admin); }
@org.junit.Test public void pushNewPatchSetForMasterWithApprovals() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo("refs/for/master"); r.assertOkStatus(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId()); r = push.to("refs/for/master/%l=Code-Review+2"); ChangeInfo ci = get(r.getChangeId(), com.google.gerrit.acceptance.git.DETAILED_LABELS, com.google.gerrit.acceptance.git.MESSAGES, com.google.gerrit.acceptance.git.DETAILED_ACCOUNTS); LabelInfo cr = ci.labels.get("Code-Review"); assertThat(com.google.common.collect.Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2."); assertThatUserIsOnlyReviewer(ci, admin); assertThat(cr.all).hasSize(1); assertThat(cr.all.get(0).name).isEqualTo("Administrator"); assertThat(cr.all.get(0).value).isEqualTo(2); }
@org.junit.Test public void pushWithMultipleApprovals() throws java.lang.Exception { com.google.gerrit.common.data.LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value((-1), "Negative")); com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet(project).getConfig(); com.google.gerrit.reviewdb.client.AccountGroup.UUID anon = systemGroupBackend.getGroup(com.google.gerrit.acceptance.git.ANONYMOUS_USERS).getUUID(); java.lang.String heads = "refs/heads/*"; com.google.gerrit.server.project.Util.allow(config, com.google.gerrit.common.data.Permission.forLabel("Custom-Label"), (-1), 1, anon, heads); config.getLabelSections().put(Q.getName(), Q); saveProjectConfig(project, config); org.eclipse.jgit.revwalk.RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create(); com.google.gerrit.acceptance.GitUtil.pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false); ChangeInfo ci = get(com.google.gerrit.acceptance.GitUtil.getChangeId(testRepo, c).get(), com.google.gerrit.acceptance.git.DETAILED_LABELS, com.google.gerrit.acceptance.git.DETAILED_ACCOUNTS); com.google.gerrit.extensions.common.LabelInfo cr = ci.labels.get("Code-Review"); assertThat(cr.all).hasSize(1); cr = ci.labels.get("Custom-Label"); assertThat(cr.all).hasSize(1); assertThatUserIsOnlyReviewer(ci, admin); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("patchSetNumber", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("createdOn", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeDeletions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("is-draft", java.lang.Boolean.toString(patchSetAttribute.isDraft))); properties.add(propertyFactory.create("isDraft", java.lang.Boolean.toString(patchSetAttribute.isDraft))); properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "author")); return properties; }
private com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getGroupsWithMember(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id memberId) throws com.google.gwtorm.server.OrmException { java.util.stream.Stream<com.google.gerrit.server.group.InternalGroup> internalGroupStream; com.google.gerrit.server.index.group.GroupIndex groupIndex = groupIndexProvider.get(); if ((groupIndex != null) && (groupIndex.getSchema().hasField(GroupField.MEMBER))) { internalGroupStream = groupQueryProvider.get().byMember(memberId).stream(); } else { internalGroupStream = com.google.gerrit.server.group.Groups.getGroupsWithMemberFromReviewDb(db, memberId).map(groupCache::get).flatMap(Streams::stream); } return internalGroupStream.map(InternalGroup::getGroupUUID).collect(toImmutableSet()); }
private com.google.gerrit.reviewdb.client.PatchSet findBasePatchSet(java.lang.String baseChange) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(baseChange); if ((notes.size()) != 1) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(("Base change not found: " + baseChange)); } com.google.gerrit.server.notedb.ChangeNotes change = com.google.common.collect.Iterables.getOnlyElement(notes); try { permissionBackend.user(user).change(change).database(db).check(ChangePermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(("Read not permitted for " + baseChange)); } return psUtil.current(db.get(), change); }
@org.junit.Test public void createMergePatchSetCannotBaseOnInvisibleChange() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit initialHead = getRemoteHead(); createBranch("foo"); createBranch("bar"); merge(createChange("refs/for/foo")); testRepo.reset(initialHead); java.lang.String baseChange = createChange("refs/for/bar").getChangeId(); gApi.changes().id(baseChange).setPrivate(true, "set private"); setApiUser(user); testRepo.reset(initialHead); java.lang.String changeId = createChange().getChangeId(); exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); exception.expectMessage(("Read not permitted for " + baseChange)); gApi.changes().id(changeId).createMergePatchSet(createMergePatchSetInput(baseChange)); }
@java.lang.Override public java.lang.String getRevision(com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId) { try { com.google.gerrit.extensions.common.ChangeInfo info = gApi.changes().id(patchSetId.getParentKey().get()).get(java.util.EnumSet.of(ListChangesOption.ALL_REVISIONS)); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> e : info.revisions.entrySet()) { if ((e.getValue()._number) == (patchSetId.get())) { return e.getKey(); } } return null; } catch (com.google.gerrit.extensions.restapi.RestApiException e) { } return null; }
public java.util.Map<java.lang.String, java.util.Set<java.lang.String>> getIssueIds(java.lang.String projectName, java.lang.String commitId, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> current = getIssueIds(projectName, commitId); if (patchSetId != null) { java.util.Map<java.lang.String, java.util.Set<java.lang.String>> previous = com.google.common.collect.Maps.newHashMap(); if ((patchSetId.get()) != 1) { com.google.gerrit.reviewdb.client.PatchSet.Id previousPatchSetId = new com.google.gerrit.reviewdb.client.PatchSet.Id(patchSetId.getParentKey(), ((patchSetId.get()) - 1)); java.lang.String previousPatchSet = db.getRevision(previousPatchSetId); if (previousPatchSet != null) { previous = getIssueIds(projectName, previousPatchSet); } } for (java.lang.String issue : current.keySet()) { java.util.Set<java.lang.String> currentOccurrences = current.get(issue); java.util.Set<java.lang.String> previousOccurrences = previous.get(issue); java.util.Set<java.lang.String> newOccurrences; if ((previousOccurrences == null) || (previousOccurrences.isEmpty())) { newOccurrences = com.google.common.collect.Sets.newHashSet(currentOccurrences); } else { newOccurrences = com.google.common.collect.Sets.newHashSet(currentOccurrences); newOccurrences.removeAll(previousOccurrences); } for (java.lang.String occurrence : newOccurrences) { currentOccurrences.add(("added@" + occurrence)); } } } return current; }
@java.lang.Override protected void configure() { itsConfig = createMock(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class); bind(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(itsConfig); commitMessageFetcher = createMock(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class); bind(com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class).toInstance(commitMessageFetcher); db = createMock(com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.PatchSetDb.class); bind(com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.PatchSetDb.class).toInstance(db); }
@java.lang.Override public void setUp() throws java.lang.Exception { super.setUp(); injector = com.google.inject.Guice.createInjector(new com.googlesource.gerrit.plugins.its.base.util.IssueExtractorTest.TestModule()); }
@org.junit.Test public void notesMigrationStateListener() throws java.lang.Exception { com.google.gerrit.server.notedb.rebuild.NotesMigrationStateListener listener = createStrictMock(com.google.gerrit.server.notedb.rebuild.NotesMigrationStateListener.class); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.REVIEW_DB, com.google.gerrit.acceptance.server.notedb.WRITE); expectLastCall(); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.WRITE, com.google.gerrit.acceptance.server.notedb.READ_WRITE_NO_SEQUENCE); expectLastCall(); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_NO_SEQUENCE, com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY); expectLastCall(); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY, com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY); listener.preStateChange(com.google.gerrit.acceptance.server.notedb.READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY, com.google.gerrit.acceptance.server.notedb.NOTE_DB); expectLastCall(); replay(listener); addListener(listener); createChange(); migrate(( b) -> b); assertNotesMigrationState(com.google.gerrit.acceptance.server.notedb.NOTE_DB, false, false); verify(listener); }
com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(java.lang.String endpoint, com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request request) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(endpoint); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); request.headers.entrySet().stream().forEach(( e) -> { post.addHeader(e.getKey(), e.getValue()); }); post.setEntity(new org.apache.http.entity.StringEntity(request.body, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(eq(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL), eq(content))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", url); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(url, content.get()); if ((!(result.successful)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (cfg.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
@java.lang.Override public java.lang.String toString() { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); return content.isPresent() ? content.get().toString() : "no content"; }
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(eq(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL), eq(content))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(eq(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL), eq(content))).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@java.lang.Override public java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> doProcess(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request(com.googlesource.gerrit.plugins.webhooks.processors.GerritEventProcessor.GSON.toJson(event))); }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(eq(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL), eq(content))).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(eq(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL), eq(content))).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(cfg.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(cfg.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(java.util.Optional.of(content)); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, cfg, processor, projectCreated, remote); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(nameKey); if (projectState != null) { com.google.gerrit.server.project.ProjectData projectData = projectState.toProjectData(); for (com.google.gerrit.server.index.project.ProjectIndex i : getWriteIndexes()) { i.replace(projectData); } fireProjectIndexedEvent(nameKey.get()); } else { for (com.google.gerrit.server.index.project.ProjectIndex i : getWriteIndexes()) { i.delete(nameKey); } } }
@org.junit.Test public void addReviewerThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); fail("Expected ResourceNotFoundException"); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } setApiUser(admin); com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput(); in.reviewer = user.email; com.google.gerrit.extensions.api.changes.AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in); assertThat(r.input).isEqualTo(user.email); assertThat(r.error).contains("does not have permission to see this change"); assertThat(r.reviewers).isNull(); }
@org.junit.Test public void fetchExternalIdsBranch() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, user); try { com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); fail("expected TransportException"); } catch (org.eclipse.jgit.api.errors.TransportException e) { assertThat(e.getMessage()).isEqualTo((("Remote does not have " + (com.google.gerrit.reviewdb.client.RefNames.REFS_EXTERNAL_IDS)) + " available for fetch.")); } allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); allUsersRepo = cloneProject(allUsers, user); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, RefNames.REFS_EXTERNAL_IDS); }
@org.junit.Test public void addInvalidEmail() throws java.lang.Exception { java.util.List<java.lang.String> emails = com.google.common.collect.ImmutableList.of("new.email", "new.email@", "@example.com", "new.email@example.africa"); for (java.lang.String email : emails) { com.google.gerrit.extensions.api.accounts.EmailInput input = newEmailInput(email); try { gApi.accounts().self().addEmail(input); fail(("Expected BadRequestException for invalid email address: " + email)); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { assertThat(e).hasMessageThat().isEqualTo("invalid email address"); } } accountIndexedCounter.assertNoReindex(); }
@org.junit.Test public void deactivateNotActive() throws java.lang.Exception { assertThat(gApi.accounts().id("user").getActive()).isTrue(); gApi.accounts().id("user").setActive(false); assertThat(gApi.accounts().id("user").getActive()).isFalse(); try { gApi.accounts().id("user").setActive(false); fail("Expected exception"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e.getMessage()).isEqualTo("account not active"); } gApi.accounts().id("user").setActive(true); }
@org.junit.Test public void failWhenWritesDisabled() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); assertThat(gApi.changes().id(id.get()).info().topic).isNull(); setNotesMigration(false, true); try { gApi.changes().id(id.get()).topic(name("a-topic")); fail("Expected write to fail"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isNull(); assertChangeUpToDate(true, id); }
@org.junit.Test public void rebuildWhenWritesDisabledWorksButDoesNotWrite() throws java.lang.Exception { setNotesMigration(true, true); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getPatchSetId().getParentKey(); assertChangeUpToDate(true, id); setNotesMigration(false, false); gApi.changes().id(id.get()).topic(name("a-topic")); setInvalidNoteDbState(id); assertChangeUpToDate(false, id); setNotesMigration(false, true); assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); try { gApi.changes().id(id.get()).topic(name("other-topic")); fail("Expected write to fail"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertChangesReadOnly(e); } assertThat(gApi.changes().id(id.get()).info().topic).isEqualTo(name("a-topic")); assertChangeUpToDate(false, id); }
private void assertBadRequest(com.google.gerrit.extensions.api.plugins.Plugins.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.TagInfo> req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.ProjectApi.ListRefsRequest<com.google.gerrit.extensions.api.projects.BranchInfo> req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
@org.junit.Test public void deleteBranchesNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); branches.add("refs/heads/does-not-exist"); input.branches = branches; try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void pushCommitOfOtherUserThatCannotSeeChange() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey p = createProject("p"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(p).getConfig(); com.google.gerrit.server.project.Util.allow(cfg, Permission.READ, groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*"); com.google.gerrit.server.project.Util.block(cfg, Permission.READ, com.google.gerrit.acceptance.api.change.REGISTERED_USERS, "refs/*"); saveProjectConfig(p, cfg); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(p, admin); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, user.getIdent(), repo); com.google.gerrit.acceptance.PushOneCommit.Result result = push.to("refs/for/master"); result.assertOkStatus(); ChangeInfo change = gApi.changes().id(result.getChangeId()).get(); assertThat(change.owner._accountId).isEqualTo(admin.id.get()); com.google.gerrit.extensions.common.CommitInfo commit = change.revisions.get(change.currentRevision).commit; assertThat(commit.author.email).isEqualTo(user.email); assertThat(commit.committer.email).isEqualTo(user.email); setApiUser(user); try { gApi.changes().id(result.getChangeId()).get(); fail("Expected ResourceNotFoundException"); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.REVIEWER)).isNull(); assertThat(change.reviewers.get(com.google.gerrit.acceptance.api.change.CC)).isNull(); assertThat(sender.getMessages()).isEmpty(); }
@org.junit.Test public void deleteBranchesNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); java.util.List<java.lang.String> branches = com.google.common.collect.Lists.newArrayList("refs/heads/does-not-exist"); branches.addAll(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); input.branches = branches; try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.common.collect.ImmutableList.of("refs/heads/does-not-exist"))); } assertBranchesDeleted(); }
@org.junit.Test public void mixingSubmitTypesOnOneBranchFails() throws java.lang.Exception { setRulesPl(com.google.gerrit.acceptance.api.change.SubmitTypeRuleIT.SUBMIT_TYPE_FROM_SUBJECT); com.google.gerrit.acceptance.PushOneCommit.Result r1 = createChange("master", "CHERRY_PICK 1"); com.google.gerrit.acceptance.PushOneCommit.Result r2 = createChange("master", "MERGE_IF_NECESSARY 2"); gApi.changes().id(r1.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(r2.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); try { gApi.changes().id(r2.getChangeId()).current().submit(); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(((((((("Failed to submit 2 changes due to the following problems:\n" + "Change ") + (r1.getChange().getId())) + ": Change has submit type ") + "CHERRY_PICK, but previously chose submit type MERGE_IF_NECESSARY ") + "from change ") + (r2.getChange().getId())) + " in the same batch")); } }
@org.junit.Test public void deleteTagsNotFoundContinue() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList("refs/tags/does-not-exist"); tags.addAll(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); input.tags = tags; try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsNotFound() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); java.util.List<java.lang.String> tags = com.google.common.collect.Lists.newArrayList(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); tags.add("refs/tags/does-not-exist"); input.tags = tags; try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.common.collect.ImmutableList.of("refs/tags/does-not-exist"))); } assertTagsDeleted(); }
@org.junit.Test public void deleteTagsForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteTagsInput input = new com.google.gerrit.extensions.api.projects.DeleteTagsInput(); input.tags = com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS; setApiUser(user); try { project().deleteTags(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS)); } setApiUser(admin); assertTags(com.google.gerrit.acceptance.rest.project.DeleteTagsIT.TAGS); }
private java.lang.String cherryPick(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case REWORK : case TRIVIAL_REBASE : break; case NO_CODE_CHANGE : case NO_CHANGE : case MERGE_FIRST_PARENT_UPDATE : default : fail(("unexpected change kind: " + changeKind)); } testRepo.reset(getRemoteHead()); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "other.txt", ("new content " + (java.lang.System.nanoTime()))).to("refs/for/master"); r.assertOkStatus(); vote(admin, r.getChangeId(), 2, 1); merge(r); java.lang.String subject = (com.google.gerrit.acceptance.api.change.TRIVIAL_REBASE.equals(changeKind)) ? com.google.gerrit.acceptance.PushOneCommit.SUBJECT : "Reworked change " + (java.lang.System.nanoTime()); com.google.gerrit.extensions.api.changes.CherryPickInput in = new com.google.gerrit.extensions.api.changes.CherryPickInput(); in.destination = "master"; in.message = java.lang.String.format("%s\n\nChange-Id: %s", subject, changeId); com.google.gerrit.extensions.common.ChangeInfo c = gApi.changes().id(changeId).revision("current").cherryPick(in).get(); return c.changeId; }
private void updateChange(java.lang.String changeId, com.google.gerrit.extensions.client.ChangeKind changeKind) throws java.lang.Exception { switch (changeKind) { case NO_CODE_CHANGE : noCodeChange(changeId); return; case REWORK : rework(changeId); return; case TRIVIAL_REBASE : trivialRebase(changeId); return; case MERGE_FIRST_PARENT_UPDATE : updateFirstParent(changeId); return; case NO_CHANGE : noChange(changeId); return; default : fail(("unexpected change kind: " + changeKind)); } }
private void assertBadRequest(com.google.gerrit.extensions.api.groups.Groups.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { } }
protected void submit(java.lang.String changeId, com.google.gerrit.extensions.api.changes.SubmitInput input, java.lang.Class<? extends com.google.gerrit.extensions.restapi.RestApiException> expectedExceptionType, java.lang.String expectedExceptionMsg) throws java.lang.Exception { approve(changeId); if (expectedExceptionType == null) { assertSubmittable(changeId); } try { gApi.changes().id(changeId).current().submit(input); if (expectedExceptionType != null) { fail(("Expected exception of type " + (expectedExceptionType.getSimpleName()))); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { if (expectedExceptionType == null) { throw e; } if ((!(expectedExceptionType.isAssignableFrom(e.getClass()))) || (!(e.getMessage().equals(expectedExceptionMsg)))) { throw new java.lang.AssertionError((((((((("Expected exception of type " + (expectedExceptionType.getSimpleName())) + " with message: \"") + expectedExceptionMsg) + "\" but got exception of type ") + (e.getClass().getSimpleName())) + " with message \"") + (e.getMessage())) + "\""), e); } return; } com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).info(); assertMerged(change.changeId); }
private void assertBadRequest(com.google.gerrit.extensions.api.projects.Projects.ListRequest req) throws java.lang.Exception { try { req.get(); fail("Expected BadRequestException"); } catch (com.google.gerrit.extensions.restapi.BadRequestException expected) { } }
@org.junit.Test public void deleteBranchesForbidden() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput(); input.branches = com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES; setApiUser(user); try { project().deleteBranches(input); fail("Expected ResourceConflictException"); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { assertThat(e).hasMessageThat().isEqualTo(errorMessageForBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES)); } setApiUser(admin); assertBranches(com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES); }
@org.junit.Test public void createChangeRespectsCLA() throws java.lang.Exception { assume().that(isContributorAgreementsEnabled()).isTrue(); setUseContributorAgreements(InheritableBoolean.FALSE); gApi.changes().create(newChangeInput()); setUseContributorAgreements(InheritableBoolean.TRUE); try { gApi.changes().create(newChangeInput()); fail("Expected AuthException"); } catch (com.google.gerrit.extensions.restapi.AuthException e) { assertThat(e.getMessage()).contains("A Contributor Agreement must be completed"); } gApi.accounts().self().signAgreement(caAutoVerify.getName()); setApiUser(user); gApi.changes().create(newChangeInput()); }
private java.util.List<com.google.gerrit.extensions.common.AccountInfo> getTransitiveMembers(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.ListMembers.checkSameGroup(group, groupControl); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> members = getTransitiveMemberIds(group, groupControl, new java.util.HashSet(com.google.common.collect.ImmutableSet.of(group.getGroupUUID()))); return toAccountInfos(members); }
public java.util.List<com.google.gerrit.extensions.common.AccountInfo> getDirectMembers(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.ListMembers.checkSameGroup(group, groupControl); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> directMembers = com.google.gerrit.server.group.ListMembers.getDirectMemberIds(group, groupControl); return toAccountInfos(directMembers); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.GROUPS_WITH_MEMBER_NAME, Account.Id.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.GroupsWithMemberLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.EXTERNAL_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); } }; }
java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> getSubgroups();
@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.GROUPS_WITH_MEMBER_NAME, Account.Id.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.GroupsWithMemberLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.PARENT_GROUPS_NAME, AccountGroup.UUID.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.ParentGroupsLoader.class); cache(com.google.gerrit.server.account.GroupIncludeCacheImpl.EXTERNAL_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<com.google.common.collect.ImmutableList<com.google.gerrit.reviewdb.client.AccountGroup.UUID>>() {}).loader(com.google.gerrit.server.account.GroupIncludeCacheImpl.AllExternalLoader.class); bind(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); bind(com.google.gerrit.server.account.GroupIncludeCache.class).to(com.google.gerrit.server.account.GroupIncludeCacheImpl.class); }
java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> getMembers();
private static java.lang.String shortenSubject(java.lang.String subject) { if ((subject.length()) < 73) { return subject; } else { return (subject.substring(0, 69)) + "..."; } }
public static com.google.gerrit.extensions.common.testing.RobotCommentInfoSubject assertThat(com.google.gerrit.extensions.common.RobotCommentInfo robotCommentInfo) { return assertAbout(com.google.gerrit.extensions.common.testing.RobotCommentInfoSubject::new).that(robotCommentInfo); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Ancient group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); removeAuditEntriesFor(groupId); schema151.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
@org.junit.Test public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Group for schema migration"); setCreatedOnToVeryOldTimestamp(groupId); schema151.migrateData(db, new com.google.gerrit.testing.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isAtLeast(testStartTime); }
public static com.google.gerrit.extensions.common.testing.FixReplacementInfoSubject assertThat(com.google.gerrit.extensions.common.FixReplacementInfo fixReplacementInfo) { return assertAbout(com.google.gerrit.extensions.common.testing.FixReplacementInfoSubject::new).that(fixReplacementInfo); }
public static com.google.gerrit.extensions.common.testing.CommitInfoSubject assertThat(com.google.gerrit.extensions.common.CommitInfo commitInfo) { return assertAbout(com.google.gerrit.extensions.common.testing.CommitInfoSubject::new).that(commitInfo); }
public static com.google.gerrit.extensions.restapi.testing.BinaryResultSubject assertThat(com.google.gerrit.extensions.restapi.BinaryResult binaryResult) { return assertAbout(com.google.gerrit.extensions.restapi.testing.BinaryResultSubject::new).that(binaryResult); }
private void createSubmoduleCommitMsg(java.lang.StringBuilder msgbuf, com.google.gerrit.reviewdb.client.SubmoduleSubscription s, com.google.gerrit.server.git.MergeOpRepoManager.OpenRepo subOr, org.eclipse.jgit.revwalk.RevCommit newCommit, org.eclipse.jgit.revwalk.RevCommit oldCommit) throws com.google.gerrit.server.git.SubmoduleException { msgbuf.append(("* Update " + (s.getPath()))); msgbuf.append(((" from branch '" + (s.getSubmodule().getShortName())) + "'")); msgbuf.append(("\n to " + (newCommit.getName()))); if (oldCommit == null) { return; } try { subOr.rw.resetRetain(subOr.canMergeFlag); subOr.rw.markStart(newCommit); subOr.rw.markUninteresting(oldCommit); for (org.eclipse.jgit.revwalk.RevCommit c : subOr.rw) { subOr.rw.parseBody(c); if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.SUBJECT_ONLY)) { msgbuf.append(("\n - " + (c.getShortMessage()))); } else if ((verboseSuperProject) == (com.google.gerrit.server.config.VerboseSuperprojectUpdate.TRUE)) { msgbuf.append(("\n - " + (c.getFullMessage().replace("\n", "\n ")))); } } } catch (java.io.IOException e) { throw new com.google.gerrit.server.git.SubmoduleException("Could not perform a revwalk to create superproject commit message", e); } }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.ProjectEvent)) { return; } com.google.gerrit.server.events.ProjectEvent projectEvent = ((com.google.gerrit.server.events.ProjectEvent) (event)); org.eclipse.jgit.lib.Config cfg; try { cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent); return; } for (java.lang.String name : cfg.getSubsections(com.googlesource.gerrit.plugins.webhooks.RemoteConfig.REMOTE)) { com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote = remoteFactory.create(cfg, name); if (com.google.common.base.Strings.isNullOrEmpty(remote.getUrl())) { com.googlesource.gerrit.plugins.webhooks.EventHandler.log.warn("remote.{}.url not defined, skipping this remote", name); continue; } taskFactory.create(projectEvent, remote).schedule(); } }
@org.junit.Test public void eventsNotSpecifiedAllEventsShouldProcess() throws java.lang.Exception { when(remote.getEvents()).thenReturn(new java.lang.String[]{ }); boolean actual = processor.shouldProcess(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, remote); assertThat(actual).isTrue(); actual = processor.shouldProcess(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, remote); assertThat(actual).isTrue(); }
com.googlesource.gerrit.plugins.webhooks.PostTask create(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote);
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.post(remote, content.get()); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
public org.eclipse.jgit.lib.Config getEffective() { return config; }
public java.lang.String getUrl() { return url; }
protected boolean shouldProcess(com.google.gerrit.server.events.ProjectEvent event, com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote) { java.lang.String[] wantedEvents = remote.getEvents(); if ((wantedEvents.length) == 0) { return true; } for (java.lang.String type : wantedEvents) { if ((!(com.google.common.base.Strings.isNullOrEmpty(type))) && (type.equals(event.getType()))) { return true; } } return false; }
@org.junit.Test public void specifiedEventTypesShouldProcess() throws java.lang.Exception { when(remote.getEvents()).thenReturn(new java.lang.String[]{ "project-created" }); boolean actual = processor.shouldProcess(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.PROJECT_CREATED, remote); assertThat(actual).isTrue(); }
@org.junit.Test public void rescheduleOnRecoverableException() throws java.io.IOException { when(session.post(eq(remote), eq(content))).thenThrow(java.io.IOException.class); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void keepReschedulingMaxTriesTimes() throws java.io.IOException { when(session.post(eq(remote), eq(content))).thenThrow(java.io.IOException.class); when(executor.schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS)).then(new org.mockito.stubbing.Answer<java.lang.Void>() { @java.lang.Override public java.lang.Void answer(org.mockito.invocation.InvocationOnMock invocation) throws java.lang.Throwable { task.run(); return null; } }); task.run(); verify(executor, times(((com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES) - 1))).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Test public void rescheduleOnError() throws java.io.IOException { when(session.post(eq(remote), eq(content))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT); task.run(); verify(executor, times(1)).schedule(task, com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL, java.util.concurrent.TimeUnit.MILLISECONDS); }
@org.junit.Before public void setup() { when(remote.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(remote.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(java.util.Optional.of(content)); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, session, processor, projectCreated, remote); }
@org.junit.Test public void noRescheduleOnNonRecoverableException() throws java.io.IOException { when(session.post(eq(remote), eq(content))).thenThrow(javax.net.ssl.SSLException.class); task.run(); verifyZeroInteractions(executor); }
com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult post(com.googlesource.gerrit.plugins.webhooks.RemoteConfig remote, com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request request) throws java.io.IOException { org.apache.http.client.methods.HttpPost post = new org.apache.http.client.methods.HttpPost(remote.getUrl()); post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); post.setConfig(getConfig(remote)); request.headers.entrySet().stream().forEach(( e) -> { post.addHeader(e.getKey(), e.getValue()); }); post.setEntity(new org.apache.http.entity.StringEntity(request.body, java.nio.charset.StandardCharsets.UTF_8)); return httpClient.execute(post, new com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler()); }
@org.junit.Before public void setup() throws com.google.gerrit.server.project.NoSuchProjectException { when(projectCreated.getProjectNameKey()).thenReturn(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME); when(configFactory.getProjectPluginConfigWithInheritance(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PROJECT_NAME, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN)).thenReturn(config); when(remoteFactory.create(eq(config), eq(com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.FOO))).thenReturn(remote); when(taskFactory.create(eq(projectCreated), eq(remote))).thenReturn(postTask); eventHandler = new com.googlesource.gerrit.plugins.webhooks.EventHandler(configFactory, com.googlesource.gerrit.plugins.webhooks.EventHandlerTest.PLUGIN, remoteFactory, taskFactory); }
@org.junit.Test public void noRescheduleOnSuccess() throws java.io.IOException { when(session.post(eq(remote), eq(content))).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT); task.run(); verifyZeroInteractions(executor); }
@org.junit.Test public void nonSpecifiedProjectEventTypesNotProcess() throws java.lang.Exception { when(remote.getEvents()).thenReturn(new java.lang.String[]{ "project-created" }); boolean actual = processor.shouldProcess(com.googlesource.gerrit.plugins.webhooks.processors.AbstractEventProcessorTest.REF_UPDATED, remote); assertThat(actual).isFalse(); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("No content. Webhook [{}] skipped.", remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.get().post(remote, content.get()); if ((!(result.successful)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(result.message); reschedule(); } } catch (java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); } } }
@org.junit.Before public void setup() { when(remote.getRetryInterval()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL); when(remote.getMaxTries()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.MAX_TRIES); when(remote.getUrl()).thenReturn(com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL); when(processor.process(eq(projectCreated), eq(remote))).thenReturn(java.util.Optional.of(content)); task = new com.googlesource.gerrit.plugins.webhooks.PostTask(executor, com.google.inject.util.Providers.of(session), processor, projectCreated, remote); }
@org.junit.Test public void version() { java.util.regex.Pattern expected = (com.google.gerrit.launcher.GerritLauncher.isRunningInEclipse()) ? com.google.gerrit.common.VersionTest.DEV_PATTERN : com.google.gerrit.common.VersionTest.GIT_DESCRIBE_PATTERN; assertThat(com.google.gerrit.common.Version.getVersion()).matches(expected); assertThat(com.google.gerrit.common.Version.getVersion()).matches(expected); }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { pushToGroupBranch(allUsers, "group update not allowed"); }
private void createGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter oi = r.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyTree = oi.insert(Constants.OBJ_TREE, new byte[]{ }); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(emptyTree); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage("Create group"); org.eclipse.jgit.lib.ObjectId emptyCommit = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(ref); updateRef.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.update(rw)).isEqualTo(RefUpdate.Result.NEW); } }
@org.junit.Test public void pushToGroupBranchForReviewForAllUsersRepoIsRejectedOnSubmit() throws java.lang.Exception { pushToGroupBranchForReviewAndSubmit(allUsers, "group update not allowed"); }
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> additions) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("Cannot edit global capabilities for projects other than " + (allProjects.get()))); } } if ((isGroupsMutationDisallowed(config.getName())) && (section.getName().startsWith(RefNames.REFS_GROUPS))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS)); } } for (com.google.gerrit.common.data.AccessSection section : additions) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (!isGlobalCapabilities) { if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid section name"); } com.google.gerrit.server.project.RefPattern.validate(name); } else { for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isCapability(p.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException((("Cannot add non-global capability " + (p.getName())) + " to global capabilities")); } } } } }
@org.junit.Test public void updateGroupRefPermissions() throws java.lang.Exception { ProjectAccessInput accessInput = newProjectAccessInput(); accessInput.add.put(((RefNames.REFS_GROUPS) + "*"), createDefaultAccessSectionInfo()); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("Permissions on refs/groups/ is managed by Gerrit and cannot be modified"); gApi.projects().name(allProjects.get()).access(accessInput); }
@java.lang.Override public org.eclipse.jgit.lib.RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); next = seed.get(); } else { oldId = ref.getObjectId(); next = parse(rw, oldId); } return store(repo, rw, oldId, ((next) + (count))); }
@java.lang.Override public org.eclipse.jgit.lib.RefUpdate.Result call() throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); afterReadRef.run(); org.eclipse.jgit.lib.ObjectId oldId; if (ref == null) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId(); } else { oldId = ref.getObjectId(); int next = parse(rw, oldId); if (next >= (value)) { return org.eclipse.jgit.lib.RefUpdate.Result.NO_CHANGE; } } return store(repo, rw, oldId, value); }
@org.junit.Test public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", com.google.common.collect.ImmutableMap.of("groups", "global:Registered-Users\tRegistered Users", ProjectConfig.PROJECT_CONFIG, config)).to(RefNames.REFS_CONFIG); r.assertOkStatus(); }
@org.junit.Test public void pushGroupsAccessSectionChangeToAllUsersFails() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG); r.assertErrorStatus("invalid project configuration"); r.assertMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified"); }
@org.junit.Test public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig(); com.google.gerrit.common.data.AccessSection as = new com.google.gerrit.common.data.AccessSection(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo")); com.google.gerrit.common.data.Permission perm = new com.google.gerrit.common.data.Permission("push"); perm.add(new com.google.gerrit.common.data.PermissionRule(systemGroupBackend.getGroup(com.google.gerrit.acceptance.api.group.ANONYMOUS_USERS))); as.addPermission(perm); projectConfig.replace(as); saveProjectConfig(allUsers, projectConfig); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString(); assertThat(config).contains("[access \"refs/groups/foo\"]"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG); r.assertOkStatus(); }
@org.junit.Test public void allUsersCanOnlyInheritFromAllProjects() throws java.lang.Exception { com.google.gerrit.extensions.api.access.ProjectAccessInput accessInput = newProjectAccessInput(); accessInput.parent = project.get(); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage((((allUsers.get()) + " must inherit from ") + (allProjects.get()))); gApi.projects().name(allUsers.get()).access(accessInput); }
@org.junit.Test public void pushToGroupBranchForNonAllUsersRepo() throws java.lang.Exception { pushToGroupBranch(project, null); }
private void assertGroupOwnerPermissions(java.lang.String groupUuid, java.lang.String expectedOwnerUuid) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.access.PermissionInfo newPermissionInfo = new com.google.gerrit.extensions.api.access.PermissionInfo(null, null); newPermissionInfo.rules = com.google.common.collect.ImmutableMap.of(expectedOwnerUuid, new com.google.gerrit.extensions.api.access.PermissionRuleInfo(com.google.gerrit.extensions.api.access.PermissionRuleInfo.Action.ALLOW, false)); ProjectAccessInfo access = gApi.projects().name(allUsers.get()).access(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(AccountGroup.UUID.parse(groupUuid)); assertThat(access.local).containsKey(groupRef); assertThat(access.local.get(groupRef).permissions).containsExactly(Permission.PUSH, newPermissionInfo, Permission.READ, newPermissionInfo); }
@org.junit.Test public void groupOwner() throws java.lang.Exception { java.lang.String adminUUID = getFromCache("Administrators").getGroupUUID().get(); java.lang.String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get(); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(adminUUID).owner().id)).isEqualTo(adminUUID); java.lang.String name = name("group"); com.google.gerrit.extensions.common.GroupInfo info = gApi.groups().create(name).get(); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id); gApi.groups().id(name).owner("Registered Users"); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID); if (groupsInNoteDb()) { assertGroupOwnerPermissions(info.id, registeredUUID); } gApi.groups().id(name).owner(adminUUID); assertThat(com.google.gerrit.extensions.restapi.Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID); if (groupsInNoteDb()) { assertGroupOwnerPermissions(info.id, adminUUID); } exception.expect(com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); gApi.groups().id(name).owner("Non-Existing Group"); }
@org.junit.Test public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig(); com.google.gerrit.common.data.AccessSection as = new com.google.gerrit.common.data.AccessSection(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo")); com.google.gerrit.common.data.Permission perm = new com.google.gerrit.common.data.Permission("push"); perm.add(new com.google.gerrit.common.data.PermissionRule(systemGroupBackend.getGroup(com.google.gerrit.acceptance.api.group.ANONYMOUS_USERS))); as.addPermission(perm); projectConfig.replace(as); saveProjectConfig(allUsers, projectConfig); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString(); assertThat(config).contains("[access \"refs/groups/foo\"]"); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG); r.assertOkStatus(); }
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.db.GroupConfig groupConfig = loadFor(groupUuid); if (!(groupConfig.getLoadedGroup().isPresent())) { return java.util.Optional.empty(); } return updateGroupInNoteDb(groupConfig, groupUpdate); }
private void createGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter oi = r.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyTree = oi.insert(Constants.OBJ_TREE, new byte[]{ }); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(emptyTree); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage("Create group"); org.eclipse.jgit.lib.ObjectId emptyCommit = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(ref); updateRef.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.update(rw)).isEqualTo(RefUpdate.Result.NEW); } }
private java.util.Optional<com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.server.group.db.GroupConfig groupConfig, com.google.gerrit.server.group.db.InternalGroupUpdate groupUpdate) throws java.io.IOException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> originalGroup = groupConfig.getLoadedGroup(); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(groupConfig); com.google.gerrit.server.group.InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new java.lang.IllegalStateException("Updated group wasn't automatically loaded")); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> modifiedMembers = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedMembers(originalGroup, updatedGroup); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> modifiedSubgroups = com.google.gerrit.server.group.db.GroupsUpdate.getModifiedSubgroups(originalGroup, updatedGroup); java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> previousName = com.google.gerrit.server.group.db.GroupsUpdate.getPreviousNameIfModified(originalGroup, updatedGroup); projectCache.evict(allUsersName); com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.Builder resultBuilder = com.google.gerrit.server.group.db.GroupsUpdate.UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups); previousName.ifPresent(resultBuilder::setPreviousGroupName); return java.util.Optional.of(resultBuilder.build()); }
private void pushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedError) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").setParents(com.google.common.collect.ImmutableList.of()).to(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("foo")))); if (expectedError != null) { r.assertErrorStatus(expectedError); } else { r.assertOkStatus(); } java.lang.String groupRefName = (com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("bar")); createGroupBranch(project, groupRefName); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", "group.config", "some content").to(groupRefName); if (expectedError != null) { r.assertErrorStatus(expectedError); } else { r.assertOkStatus(); } }
@org.junit.Test public void createGroup() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(newGroupName).get(); com.google.gerrit.acceptance.api.group.GroupAssert.assertGroupInfo(getFromCache(newGroupName), g); if (groupsInNoteDb()) { assertGroupOwnerPermissions(g.id, g.id); } }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { pushToGroupBranch(allUsers, "group update not allowed"); }
@java.lang.SuppressWarnings("deprecation") @org.junit.Test public void createGroupWithProperties() throws java.lang.Exception { com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("newGroup"); in.description = "Test description"; in.visibleToAll = true; in.ownerId = getFromCache("Administrators").getGroupUUID().get(); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(in).detail(); assertThat(g.description).isEqualTo(in.description); assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll); assertThat(g.ownerId).isEqualTo(in.ownerId); if (groupsInNoteDb()) { assertGroupOwnerPermissions(g.id, in.ownerId); } }
@org.junit.Test public void pushGroupsAccessSectionChangeToAllUsersFails() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG); java.lang.String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(config); cfg.setString("access", ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "foo"), "push", "group Registered Users"); config = cfg.toText(); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG); r.assertErrorStatus("invalid project configuration"); r.assertMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified"); }
private com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData load(int expectedValue) throws java.lang.Exception { return load(com.google.gerrit.server.git.VersionedMetaDataTest.DEFAULT_REF, expectedValue); }
@org.junit.Test public void sharedBatchRefUpdate() throws java.lang.Exception { com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData d1 = load("refs/meta/1", 0); com.google.gerrit.server.git.VersionedMetaDataTest.MyMetaData d2 = load("refs/meta/2", 0); org.eclipse.jgit.lib.BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate(); try (com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch1 = d1.openUpdate(newMetaDataUpdate(bru));com.google.gerrit.server.git.VersionedMetaData.BatchMetaDataUpdate batch2 = d2.openUpdate(newMetaDataUpdate(bru))) { d1.setIncrement(1); batch1.write(d1, newCommitBuilder()); d2.setIncrement(2000); batch2.write(d2, newCommitBuilder()); d1.setIncrement(3); batch1.write(d1, newCommitBuilder()); d2.setIncrement(4000); batch2.write(d2, newCommitBuilder()); batch1.commit(); batch2.commit(); } assertMyMetaData(d1.getRefName(), 0); assertMyMetaData(d2.getRefName(), 0); assertThat(bru.getCommands().stream().map(ReceiveCommand::getRefName)).containsExactly("refs/meta/1", "refs/meta/2"); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { com.google.gerrit.server.update.RefUpdateUtil.executeChecked(bru, rw); } assertMyMetaData(d1.getRefName(), 4, "Increment conf.value by 1", "Increment conf.value by 3"); assertMyMetaData(d2.getRefName(), 6000, "Increment conf.value by 2000", "Increment conf.value by 4000"); }
@java.lang.Override public void update(com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.GerritRemoteReader reader, com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c, java.lang.String srcRef) throws java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository destRepo = reader.openRepository(c.getDestRepoKey().toString())) { com.googlesource.gerrit.plugins.supermanifest.JiriProjects projects = com.googlesource.gerrit.plugins.supermanifest.JiriManifestParser.getProjects(reader, c.getSrcRepoKey().toString(), srcRef, c.getXmlPath()); java.lang.String targetRef = (c.getDestBranch().equals("*")) ? srcRef : (REFS_HEADS) + (c.getDestBranch()); updateSubmodules(destRepo, targetRef, java.net.URI.create(((c.getDestRepoKey().toString()) + "/")), projects, reader); } }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(name); if (!(projectState.getProject().getState().permitsRead())) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.gitiles.FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }
@org.junit.Test public void createBranchByAdmin() throws java.lang.Exception { assertCreateSucceeds(testBranch); }
@org.junit.Test public void createBranchByAdminCreateReferenceBlocked_Forbidden() throws java.lang.Exception { blockCreateReference(); assertCreateFails(testBranch, com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void createBranchByProjectOwnerCreateReferenceBlocked_Forbidden() throws java.lang.Exception { grantOwner(); blockCreateReference(); setApiUser(user); assertCreateFails(testBranch, com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void createBranchByProjectOwner() throws java.lang.Exception { grantOwner(); setApiUser(user); assertCreateSucceeds(testBranch); }
@org.junit.Test public void createBranch_Forbidden() throws java.lang.Exception { setApiUser(user); assertCreateFails(testBranch, com.google.gerrit.extensions.restapi.AuthException.class, "create not permitted for refs/heads/test"); }
@org.junit.Test public void branchAlreadyExists_Conflict() throws java.lang.Exception { assertCreateSucceeds(testBranch); assertCreateFails(testBranch, com.google.gerrit.extensions.restapi.ResourceConflictException.class); }
@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grant(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.DELETE, true, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); com.google.gerrit.server.group.InternalGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null); assertThat(adminGroup).isNotNull(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroup.getGroupUUID()); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains("Not allowed to delete group branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef)).isNotNull(); } }
@java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { cache(com.google.gerrit.server.account.GroupCacheImpl.BYID_NAME, AccountGroup.Id.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByIdLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYNAME_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByNameLoader.class); cache(com.google.gerrit.server.account.GroupCacheImpl.BYUUID_NAME, java.lang.String.class, new com.google.inject.TypeLiteral<java.util.Optional<com.google.gerrit.server.group.InternalGroup>>() {}).maximumWeight(java.lang.Long.MAX_VALUE).loader(com.google.gerrit.server.account.GroupCacheImpl.ByUUIDLoader.class); bind(com.google.gerrit.server.account.GroupCacheImpl.class); bind(com.google.gerrit.server.account.GroupCache.class).to(com.google.gerrit.server.account.GroupCacheImpl.class); } }; }
@java.lang.Override public void viewAccepted(org.jgroups.View view) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("viewAccepted(view: {}) called", view); synchronized(this) { if ((view.getMembers().size()) > 2) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.warn(("{} members joined the jgroups cluster {} ({}). " + " Only two members are supported. Members: {}"), view.getMembers().size(), jgroupsConfig.clusterName(), channel.getName(), view.getMembers()); } if (((peerAddress) != null) && (!(view.getMembers().contains(peerAddress)))) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("viewAccepted(): removed peerInfo"); peerAddress = null; peerInfo = java.util.Optional.empty(); } } if ((view.size()) > 1) { try { channel.send(new org.jgroups.Message(null, myUrl)); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("Sending a message over channel {} to cluster {} failed", channel.getName(), jgroupsConfig.clusterName(), e); } } }
public void connect() { try { channel = new org.jgroups.JChannel(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { channel.getProtocolStack().getTransport().setBindAddress(address.get()); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.info("Channel {} successfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName()); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerInfoProvider.log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e); } }
@java.lang.Override public void cleanUp() { for (java.nio.file.Path path : listFiles()) { com.google.gerrit.httpd.WebSessionManager.Val val = readFile(path); if (val != null) { java.time.Instant expires = java.time.Instant.ofEpochMilli(val.getExpiresAt()); if (expires.isBefore(java.time.Instant.ofEpochMilli(com.google.gerrit.common.TimeUtil.nowMs()))) { deleteFile(path); } } } }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.index.query.FieldBundle> readRaw() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException("not implemented"); }
default java.util.Optional<com.google.gerrit.index.query.FieldBundle> getRaw(K key, com.google.gerrit.index.QueryOptions opts) throws java.io.IOException { opts = opts.withStart(0).withLimit(2); java.util.List<com.google.gerrit.index.query.FieldBundle> results; try { results = getSource(keyPredicate(key), opts).readRaw().toList(); } catch (com.google.gerrit.index.query.QueryParseException e) { throw new java.io.IOException("Unexpected QueryParseException during get()", e); } catch (com.google.gwtorm.server.OrmException e) { throw new java.io.IOException(e); } if ((results.size()) > 1) { throw new java.io.IOException(((("Multiple results found in index for key " + key) + ": ") + results)); } return results.stream().findFirst(); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.index.query.FieldBundle> readRaw() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException("not implemented"); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.index.query.FieldBundle> readRaw() throws com.google.gwtorm.server.OrmException { throw new java.lang.UnsupportedOperationException("not implemented"); }
com.google.gwtorm.server.ResultSet<com.google.gerrit.index.query.FieldBundle> readRaw() throws com.google.gwtorm.server.OrmException;
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.index.query.FieldBundle> readRaw() throws com.google.gwtorm.server.OrmException { return source.readRaw(); }
@org.junit.Test public void advertisedReferencesOmitUserBranchesOfOtherUsers() throws java.lang.Exception { allow(allUsersName, ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + "*"), Permission.READ, com.google.gerrit.acceptance.git.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<?> userTestRepository = cloneProject(allUsers, user); try (org.eclipse.jgit.api.Git git = userTestRepository.git()) { assertThat(getUserRefs(git)).containsExactly(RefNames.REFS_USERS_SELF, com.google.gerrit.reviewdb.client.RefNames.refsUsers(user.id)); } }
@org.junit.Test public void advertisedReferencesIncludeAllUserBranchesWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); try { org.eclipse.jgit.junit.TestRepository<?> userTestRepository = cloneProject(allUsers, user); try (org.eclipse.jgit.api.Git git = userTestRepository.git()) { assertThat(getUserRefs(git)).containsExactly(com.google.gerrit.reviewdb.client.RefNames.refsUsers(user.id), com.google.gerrit.reviewdb.client.RefNames.refsUsers(admin.id)); } } finally { removeGlobalCapabilities(com.google.gerrit.acceptance.git.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); } }
@java.lang.Override protected void configure() { if (!(enabled)) { bind(com.google.gerrit.server.account.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiModule.NoGpgApi.class); return; } bind(com.google.gerrit.server.account.GpgApiAdapter.class).to(com.google.gerrit.gpg.api.GpgApiAdapterImpl.class); factory(GpgKeyApiImpl.Factory.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.gpg.api.GPG_KEY_KIND); child(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.GpgKeys.class); post(com.google.gerrit.gpg.api.ACCOUNT_KIND, "gpgkeys").to(com.google.gerrit.gpg.server.PostGpgKeys.class); get(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(GpgKeys.Get.class); delete(com.google.gerrit.gpg.api.GPG_KEY_KIND).to(com.google.gerrit.gpg.server.DeleteGpgKey.class); }
@org.junit.Test public void stalenessChecker() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); com.google.gerrit.extensions.common.GroupInfo groupInfo = gApi.groups().create(name("foo")).get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupInfo.id); assertThat(stalenessChecker.isStale(groupUuid)).isFalse(); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(groupUuid); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(repo.exactRef(groupRef).getObjectId()); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), com.google.gerrit.common.TimeUtil.nowTs()); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(commit.getTree()); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage(commit.getFullMessage()); org.eclipse.jgit.lib.ObjectId emptyCommit = oi.insert(cb); oi.flush(); org.eclipse.jgit.lib.RefUpdate updateRef = repo.updateRef(groupRef); updateRef.setExpectedOldObjectId(commit.toObjectId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRef.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED); } groupsByUUIDCache.invalidate(groupUuid); assertThat(stalenessChecker.isStale(groupUuid)).isTrue(); gApi.groups().id(groupInfo.id).index(); assertThat(stalenessChecker.isStale(groupUuid)).isFalse(); }
private boolean groupsInNoteDb() { return (cfg.getBoolean("user", "writeGroupsToNoteDb", false)) && (cfg.getBoolean("user", "readGroupsFromNoteDb", false)); }
public boolean isStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(config.getBoolean("user", "readGroupsFromNoteDb", false))) { return false; } com.google.gerrit.server.index.group.GroupIndex i = indexes.getSearchIndex(); if (i == null) { return false; } if (!(i.getSchema().hasField(GroupField.REF_STATE))) { return false; } java.util.Optional<com.google.gerrit.index.query.FieldBundle> result = i.getRaw(id, com.google.gerrit.server.index.group.IndexedGroupQuery.createOptions(indexConfig, 0, 1, com.google.gerrit.server.index.group.StalenessChecker.FIELDS)); if (!(result.isPresent())) { return true; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(id)); org.eclipse.jgit.lib.ObjectId head = (ref == null) ? org.eclipse.jgit.lib.ObjectId.zeroId() : ref.getObjectId(); return !(head.equals(org.eclipse.jgit.lib.ObjectId.fromString(result.get().getValue(GroupField.REF_STATE), 0))); } }
@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getOldFilePath(); }
@java.lang.Override public com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(edit.getOldFilePath(), adjustedFilePath, edit.getBeginA(), edit.getEndA(), ((edit.getBeginB()) + shiftedAmount), ((edit.getEndB()) + shiftedAmount), (!(java.util.Objects.equals(edit.getNewFilePath(), adjustedFilePath)))); }
private com.google.gerrit.server.diff.PatchList listFor(com.google.gerrit.server.diff.PatchListKey key) throws com.google.gerrit.server.diff.PatchListNotAvailableException { return patchListCache.get(key, notes.getProjectName()); }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder(com.google.gerrit.server.diff.PatchList list, org.eclipse.jgit.lib.Repository git) { final com.google.gerrit.server.patch.PatchScriptBuilder b = builderFactory.get(); b.setRepository(git, notes.getProjectName()); b.setChange(notes.getChange()); b.setDiffPrefs(diffPrefs); b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId()); return b; }
public java.util.Optional<com.google.gerrit.server.diff.DiffSummary.ChangedLines> changedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((changedLines) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } changedLines = computeChangedLines(); } return changedLines; }
private com.google.gerrit.server.diff.PatchListKey keyFor(com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { if ((parentNum) < 0) { return com.google.gerrit.server.diff.PatchListKey.againstCommit(aId, bId, whitespace); } return com.google.gerrit.server.diff.PatchListKey.againstParentNum(((parentNum) + 1), bId, whitespace); }
@org.junit.Test public void empty1() { final java.lang.String name = "empty-file"; final com.google.gerrit.server.diff.PatchListEntry e = com.google.gerrit.server.diff.PatchListEntry.empty(name); assertNull(e.getOldName()); assertEquals(name, e.getNewName()); assertSame(Patch.PatchType.UNIFIED, e.getPatchType()); assertSame(Patch.ChangeType.MODIFIED, e.getChangeType()); assertTrue(e.getEdits().isEmpty()); }
private com.google.gerrit.server.diff.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree); if (tw == null) { return Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return new com.google.gerrit.server.diff.Text(repo.open(tw.getObjectId(0), Constants.OBJ_BLOB)); } else if ((tw.getFileMode(0).getObjectType()) == (org.eclipse.jgit.lib.Constants.OBJ_COMMIT)) { java.lang.String str = "Subproject commit " + (org.eclipse.jgit.lib.ObjectId.toString(tw.getObjectId(0))); return new com.google.gerrit.server.diff.Text(str.getBytes(java.nio.charset.StandardCharsets.UTF_8)); } else { return Text.EMPTY; } }
private static boolean isBlankLineGap(com.google.gerrit.server.diff.Text a, int b, int e) { for (; b < e; b++) { if (!(com.google.gerrit.server.patch.IntraLineLoader.BLANK_LINE_RE.matcher(a.getString(b)).matches())) { return false; } } return true; }
private static boolean isControlBlockStart(com.google.gerrit.server.diff.Text a, int idx) { return com.google.gerrit.server.patch.IntraLineLoader.CONTROL_BLOCK_START_RE.matcher(a.getString(idx)).find(); }
com.google.gerrit.server.patch.IntraLineLoader create(com.google.gerrit.server.diff.IntraLineDiffKey key, com.google.gerrit.server.diff.IntraLineDiffArgs args);
private static void combineLineEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.server.diff.Text a, com.google.gerrit.server.diff.Text b) { for (int j = 0; j < ((edits.size()) - 1);) { org.eclipse.jgit.diff.Edit c = edits.get(j); org.eclipse.jgit.diff.Edit n = edits.get((j + 1)); final int ad = (n.getBeginA()) - (c.getEndA()); final int bd = (n.getBeginB()) - (c.getEndB()); if ((((1 <= ad) && (com.google.gerrit.server.patch.IntraLineLoader.isBlankLineGap(a, c.getEndA(), n.getBeginA()))) || ((1 <= bd) && (com.google.gerrit.server.patch.IntraLineLoader.isBlankLineGap(b, c.getEndB(), n.getBeginB())))) || (((ad == 1) && (bd == 1)) && (com.google.gerrit.server.patch.IntraLineLoader.isControlBlockStart(a, c.getEndA())))) { int ab = c.getBeginA(); int ae = n.getEndA(); int bb = c.getBeginB(); int be = n.getEndB(); edits.set(j, new org.eclipse.jgit.diff.Edit(ab, ae, bb, be)); edits.remove((j + 1)); continue; } j++; } }
@java.lang.Override public com.google.gerrit.server.diff.DiffSummary call() throws java.lang.Exception { com.google.gerrit.server.diff.PatchList patchList = patchListCache.get(key.toPatchListKey(), project); return com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(patchList); }
void setTrees(com.google.gerrit.server.diff.ComparisonType ct, org.eclipse.jgit.lib.ObjectId a, org.eclipse.jgit.lib.ObjectId b) { comparisonType = ct; aId = a; bId = b; }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.diff.IntraLineDiff::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public static java.util.stream.Stream<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> toEdits(com.google.gerrit.server.diff.PatchListEntry patchListEntry) { com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> edits = patchListEntry.getEdits(); if (edits.isEmpty()) { return java.util.stream.Stream.of(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.createForNoContentEdit(patchListEntry)); } return edits.stream().map(( edit) -> com.google.gerrit.server.patch.ContextAwareEdit.create(patchListEntry, edit)); }
private static org.eclipse.jgit.diff.Edit copy(org.eclipse.jgit.diff.Edit edit) { if (edit instanceof org.eclipse.jgit.diff.ReplaceEdit) { return com.google.gerrit.server.diff.IntraLineDiff.copy(((org.eclipse.jgit.diff.ReplaceEdit) (edit))); } return new org.eclipse.jgit.diff.Edit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB()); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeEnum(out, status); writeVarInt32(out, edits.size()); for (org.eclipse.jgit.diff.Edit e : edits) { com.google.gerrit.server.diff.IntraLineDiff.writeEdit(out, e); if (e instanceof org.eclipse.jgit.diff.ReplaceEdit) { org.eclipse.jgit.diff.ReplaceEdit r = ((org.eclipse.jgit.diff.ReplaceEdit) (e)); writeVarInt32(out, r.getInternalEdits().size()); for (org.eclipse.jgit.diff.Edit i : r.getInternalEdits()) { com.google.gerrit.server.diff.IntraLineDiff.writeEdit(out, i); } } else { writeVarInt32(out, 0); } } }
public static com.google.gerrit.server.diff.IntraLineDiffKey create(org.eclipse.jgit.lib.ObjectId aId, org.eclipse.jgit.lib.ObjectId bId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.diff.AutoValue_IntraLineDiffKey(aId, bId, whitespace); }
public java.util.List<java.lang.String> currentFilePaths() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((currentFiles) == null) { if (!(lazyLoad)) { return java.util.Collections.emptyList(); } java.util.Optional<com.google.gerrit.server.diff.DiffSummary> p = getDiffSummary(); currentFiles = p.map(DiffSummary::getPaths).orElse(java.util.Collections.emptyList()); } return currentFiles; }
private java.util.Optional<com.google.gerrit.server.diff.DiffSummary.ChangedLines> computeChangedLines() throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.diff.DiffSummary> ds = getDiffSummary(); if (ds.isPresent()) { return java.util.Optional.of(ds.get().getChangedLines()); } return java.util.Optional.empty(); }
@java.lang.Override public int hash(com.google.gerrit.server.diff.CharText seq, int ptr) { return seq.charAt(ptr); }
public void setChangedLines(int insertions, int deletions) { changedLines = java.util.Optional.of(new com.google.gerrit.server.diff.DiffSummary.ChangedLines(insertions, deletions)); }
private java.util.Optional<com.google.gerrit.server.diff.DiffSummary> getDiffSummary() throws com.google.gwtorm.server.OrmException, java.io.IOException { if ((diffSummary) == null) { if (!(lazyLoad)) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Change c = change(); com.google.gerrit.reviewdb.client.PatchSet ps = currentPatchSet(); if (((c == null) || (ps == null)) || (!(loadCommitData()))) { return java.util.Optional.empty(); } org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.diff.PatchListKey pk = ((parentCount) > 1) ? com.google.gerrit.server.diff.PatchListKey.againstParentNum(1, id, ws) : com.google.gerrit.server.diff.PatchListKey.againstDefaultBase(id, ws); com.google.gerrit.server.diff.DiffSummaryKey key = com.google.gerrit.server.diff.DiffSummaryKey.fromPatchListKey(pk); try { diffSummary = java.util.Optional.of(patchListCache.getDiffSummary(key, c.getProject())); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { diffSummary = java.util.Optional.empty(); } } return diffSummary; }
private static org.eclipse.jgit.diff.ReplaceEdit copy(org.eclipse.jgit.diff.ReplaceEdit edit) { java.util.List<org.eclipse.jgit.diff.Edit> internalEdits = edit.getInternalEdits().stream().map(com.google.gerrit.server.diff.IntraLineDiff::copy).collect(java.util.stream.Collectors.toList()); return new org.eclipse.jgit.diff.ReplaceEdit(edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), internalEdits); }
public com.google.gerrit.server.diff.IntraLineDiff.Status getStatus() { return status; }
public void transformReferencesOfSideA(java.util.List<com.google.gerrit.server.diff.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.patch.EditTransformer.SideAStrategy.INSTANCE); }
@java.lang.Override public int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getEndB(); }
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(java.lang.String oldFilePath, java.lang.String newFilePath, int beginA, int endA, int beginB, int endB, boolean filePathAdjusted) { java.lang.String adjustedOldFilePath = com.google.common.base.MoreObjects.firstNonNull(oldFilePath, newFilePath); boolean implicitRename = (!(java.util.Objects.equals(oldFilePath, newFilePath))) && filePathAdjusted; return new com.google.gerrit.server.patch.AutoValue_EditTransformer_ContextAwareEdit(adjustedOldFilePath, newFilePath, beginA, endA, beginB, endB, implicitRename); }
private static java.lang.String newName(com.google.gerrit.server.diff.PatchListEntry entry) { switch (entry.getChangeType()) { case DELETED : return null; case ADDED : case MODIFIED : case COPIED : case RENAMED : case REWRITE : default : return entry.getNewName(); } }
@java.lang.Override public com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(adjustedFilePath, edit.getNewFilePath(), ((edit.getBeginA()) + shiftedAmount), ((edit.getEndA()) + shiftedAmount), edit.getBeginB(), edit.getEndB(), (!(java.util.Objects.equals(edit.getOldFilePath(), adjustedFilePath)))); }
@java.lang.Override public int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getBeginA(); }
public static java.lang.Module module() { return new com.google.gerrit.server.cache.CacheModule() { @java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.diff.PatchListKey.class, com.google.gerrit.server.diff.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.diff.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.diff.IntraLineDiffKey.class, com.google.gerrit.server.diff.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.diff.DiffSummaryKey.class, com.google.gerrit.server.diff.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.diff.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); } }; }
@java.lang.Override public com.google.gerrit.server.diff.DiffSummary getDiffSummary(com.google.gerrit.server.diff.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.diff.PatchListNotAvailableException { try { return diffSummaryCache.get(key, diffSummaryLoaderFactory.create(key, project)); } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.diff.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.diff.PatchListNotAvailableException(e); } throw e; } }
@java.lang.Override public int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getBeginB(); }
private static boolean isModify(com.google.gerrit.server.diff.PatchListEntry content) { switch (content.getChangeType()) { case MODIFIED : case COPIED : case RENAMED : case REWRITE : return true; case ADDED : case DELETED : default : return false; } }
private java.lang.String getLine(com.google.gerrit.server.diff.PatchFile fileInfo, short side, int lineNbr) { try { return fileInfo.getLine(side, lineNbr); } catch (java.io.IOException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format("Failed to read file on side %d", side), err); return ""; } catch (java.lang.IndexOutOfBoundsException err) { com.google.gerrit.server.mail.send.CommentSender.log.debug(java.lang.String.format("Failed to get line number of file on side %d", side), err); return ""; } catch (com.google.gerrit.common.errors.NoSuchEntityException err) { com.google.gerrit.server.mail.send.CommentSender.log.warn(java.lang.String.format("Side %d of file didn't exist", side), err); return ""; } }
private java.util.List<java.lang.String> getLinesByRange(com.google.gerrit.reviewdb.client.Comment.Range range, com.google.gerrit.server.diff.PatchFile fileData, short side) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); for (int n = range.startLine; n <= (range.endLine); n++) { java.lang.String s = getLine(fileData, side, n); if (((n == (range.startLine)) && (n == (range.endLine))) && ((range.startChar) < (range.endChar))) { s = s.substring(java.lang.Math.min(range.startChar, s.length()), java.lang.Math.min(range.endChar, s.length())); } else if (n == (range.startLine)) { s = s.substring(java.lang.Math.min(range.startChar, s.length())); } else if (n == (range.endLine)) { s = s.substring(0, java.lang.Math.min(range.endChar, s.length())); } lines.add(s); } return lines; }
private static java.util.stream.Stream<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> transformEdits(com.google.gerrit.server.patch.EditTransformer.SideStrategy sideStrategy, java.util.List<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> originalEdits, java.util.List<com.google.gerrit.server.diff.PatchListEntry> transformingEntries) { if (transformingEntries.isEmpty()) { return originalEdits.stream(); } return transformingEntries.stream().flatMap(( transEntry) -> transformEdits(sideStrategy, originalEdits, transEntry.getEdits(), transEntry.getNewName()).stream()); }
int getBegin(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.diff.PatchList get(com.google.gerrit.server.diff.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.diff.PatchListNotAvailableException { try { com.google.gerrit.server.diff.PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project)); if (pl instanceof com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone) { throw new com.google.gerrit.server.patch.PatchListObjectTooLargeException((("Error computing " + key) + ". Previous attempt failed with LargeObjectException")); } if ((key.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF)) { diffSummaryCache.put(com.google.gerrit.server.diff.DiffSummaryKey.fromPatchListKey(key), com.google.gerrit.server.patch.DiffSummaryLoader.toDiffSummary(pl)); } return pl; } catch (java.util.concurrent.ExecutionException e) { PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.diff.PatchListNotAvailableException(e); } catch (com.google.common.util.concurrent.UncheckedExecutionException e) { if ((e.getCause()) instanceof org.eclipse.jgit.errors.LargeObjectException) { fileCache.put(key, new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone()); PatchListLoader.log.warn(("Error computing " + key), e); throw new com.google.gerrit.server.diff.PatchListNotAvailableException(e); } throw e; } }
@java.lang.Override public java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getNewFilePath(); }
private java.util.List<java.lang.String> getLinesOfComment(com.google.gerrit.reviewdb.client.Comment comment, com.google.gerrit.server.diff.PatchFile fileData) { java.util.List<java.lang.String> lines = new java.util.ArrayList<>(); if ((comment.lineNbr) == 0) { return lines; } if ((comment.range) == null) { lines.add(getLine(fileData, comment.side, comment.lineNbr)); } else { lines.addAll(getLinesByRange(comment.range, fileData, comment.side)); } return lines; }
@java.lang.Override protected void configure() { factory(PatchListLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.FILE_NAME, com.google.gerrit.server.diff.PatchListKey.class, com.google.gerrit.server.diff.PatchList.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.diff.PatchListWeigher.class); factory(IntraLineLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.INTRA_NAME, com.google.gerrit.server.diff.IntraLineDiffKey.class, com.google.gerrit.server.diff.IntraLineDiff.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.IntraLineWeigher.class); factory(DiffSummaryLoader.Factory.class); persist(com.google.gerrit.server.patch.PatchListCacheImpl.DIFF_SUMMARY, com.google.gerrit.server.diff.DiffSummaryKey.class, com.google.gerrit.server.diff.DiffSummary.class).maximumWeight((10 << 20)).weigher(com.google.gerrit.server.patch.DiffSummaryWeigher.class).diskLimit((1 << 30)); bind(com.google.gerrit.server.patch.PatchListCacheImpl.class); bind(com.google.gerrit.server.diff.PatchListCache.class).to(com.google.gerrit.server.patch.PatchListCacheImpl.class); }
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.diff.PatchListEntry patchListEntry, org.eclipse.jgit.diff.Edit edit) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), edit.getBeginA(), edit.getEndA(), edit.getBeginB(), edit.getEndB(), false); }
private com.google.gerrit.server.diff.Text load(org.eclipse.jgit.lib.ObjectId tree, java.lang.String path, org.eclipse.jgit.lib.ObjectReader reader) throws java.io.IOException, org.eclipse.jgit.errors.CorruptObjectException, org.eclipse.jgit.errors.IncorrectObjectTypeException, org.eclipse.jgit.errors.MissingObjectException { if (path == null) { return com.google.gerrit.server.diff.Text.EMPTY; } final org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(reader, path, tree); if (tw == null) { return com.google.gerrit.server.diff.Text.EMPTY; } if ((tw.getFileMode(0).getObjectType()) != (org.eclipse.jgit.lib.Constants.OBJ_BLOB)) { return com.google.gerrit.server.diff.Text.EMPTY; } return new com.google.gerrit.server.diff.Text(reader.open(tw.getObjectId(0), Constants.OBJ_BLOB)); }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { status = readEnum(in, com.google.gerrit.server.diff.IntraLineDiff.Status.values()); int editCount = readVarInt32(in); org.eclipse.jgit.diff.Edit[] editArray = new org.eclipse.jgit.diff.Edit[editCount]; for (int i = 0; i < editCount; i++) { editArray[i] = com.google.gerrit.server.diff.IntraLineDiff.readEdit(in); int innerCount = readVarInt32(in); if (0 < innerCount) { org.eclipse.jgit.diff.Edit[] inner = new org.eclipse.jgit.diff.Edit[innerCount]; for (int j = 0; j < innerCount; j++) { inner[j] = com.google.gerrit.server.diff.IntraLineDiff.readEdit(in); } editArray[i] = new org.eclipse.jgit.diff.ReplaceEdit(editArray[i], com.google.gerrit.server.diff.IntraLineDiff.toList(inner)); } } edits = com.google.common.collect.ImmutableList.copyOf(editArray); }
com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit create(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit, int shiftedAmount, java.lang.String adjustedFilePath);
public com.google.gerrit.server.diff.PatchListCache getPatchListCache() { return patchListCache; }
private static java.lang.String oldName(com.google.gerrit.server.diff.PatchListEntry entry) { switch (entry.getChangeType()) { case ADDED : return null; case DELETED : case MODIFIED : case REWRITE : return entry.getNewName(); case COPIED : case RENAMED : default : return entry.getOldName(); } }
@java.lang.Override public org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.diff.PatchListNotAvailableException { return get(change, patchSet, parentNum).getOldId(); }
@java.lang.Override public com.google.gerrit.server.diff.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.diff.PatchListNotAvailableException { return get(change, patchSet, null); }
private void transformEdits(java.util.List<com.google.gerrit.server.diff.PatchListEntry> transformingEntries, com.google.gerrit.server.patch.EditTransformer.SideStrategy sideStrategy) { java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit>> editsPerFilePath = edits.stream().collect(java.util.stream.Collectors.groupingBy(sideStrategy::getFilePath)); java.util.Map<java.lang.String, java.util.List<com.google.gerrit.server.diff.PatchListEntry>> transEntriesPerPath = transformingEntries.stream().collect(java.util.stream.Collectors.groupingBy(com.google.gerrit.server.patch.EditTransformer::getOldFilePath)); edits = editsPerFilePath.entrySet().stream().flatMap(( pathAndEdits) -> { java.util.List<com.google.gerrit.server.diff.PatchListEntry> transEntries = transEntriesPerPath.getOrDefault(pathAndEdits.getKey(), com.google.common.collect.ImmutableList.of()); return com.google.gerrit.server.patch.EditTransformer.transformEdits(sideStrategy, pathAndEdits.getValue(), transEntries); }).collect(java.util.stream.Collectors.toList()); }
com.google.gerrit.common.data.PatchScript toPatchScript(com.google.gerrit.server.diff.PatchListEntry content, com.google.gerrit.common.data.CommentDetail comments, java.util.List<com.google.gerrit.reviewdb.client.Patch> history) throws java.io.IOException { reader = db.newObjectReader(); try { return build(content, comments, history); } finally { reader.close(); } }
public com.google.gerrit.reviewdb.client.Patch.PatchType getPatchType() { return com.google.gerrit.reviewdb.client.Patch.PatchType.forCode(patchType); }
public void setPatchType(com.google.gerrit.reviewdb.client.Patch.PatchType type) { patchType = type.getCode(); }
int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
static com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit createForNoContentEdit(com.google.gerrit.server.diff.PatchListEntry patchListEntry) { return com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit.create(patchListEntry.getOldName(), patchListEntry.getNewName(), (-1), (-1), (-1), (-1), false); }
@java.lang.Override public com.google.gerrit.server.diff.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.diff.IntraLineDiffKey key, com.google.gerrit.server.diff.IntraLineDiffArgs args) { if (computeIntraline) { try { return intraCache.get(key, intraLoaderFactory.create(key, args)); } catch (java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e) { IntraLineLoader.log.warn(("Error computing " + key), e); return new com.google.gerrit.server.diff.IntraLineDiff(IntraLineDiff.Status.ERROR); } } return new com.google.gerrit.server.diff.IntraLineDiff(IntraLineDiff.Status.DISABLED); }
public void transformReferencesOfSideB(java.util.List<com.google.gerrit.server.diff.PatchListEntry> transformationEntries) { transformEdits(transformationEntries, com.google.gerrit.server.patch.EditTransformer.SideBStrategy.INSTANCE); }
private static boolean canCoalesce(com.google.gerrit.server.diff.CharText a, int b, int e) { while (b < e) { if ((a.charAt((b++))) == '\n') { return false; } } return true; }
java.lang.String getFilePath(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit);
@java.lang.Override public com.google.gerrit.server.diff.IntraLineDiff call() throws java.lang.Exception { java.util.concurrent.Future<com.google.gerrit.server.diff.IntraLineDiff> result = diffExecutor.submit(() -> com.google.gerrit.server.patch.IntraLineLoader.compute(args.aText(), args.bText(), args.edits())); try { return result.get(timeoutMillis, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.InterruptedException | java.util.concurrent.TimeoutException e) { com.google.gerrit.server.patch.IntraLineLoader.log.warn(((((((((((((timeoutMillis) + " ms timeout reached for IntraLineDiff") + " in project ") + (args.project())) + " on commit ") + (args.commit().name())) + " for path ") + (args.path())) + " comparing ") + (key.getBlobA().name())) + "..") + (key.getBlobB().name()))); result.cancel(true); return new com.google.gerrit.server.diff.IntraLineDiff(IntraLineDiff.Status.TIMEOUT); } catch (java.util.concurrent.ExecutionException e) { com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.lang.Exception.class); throw new java.lang.Exception(e.getMessage(), e.getCause()); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account restorer, java.lang.String reason, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeRestored.Event event = new com.google.gerrit.server.extensions.events.ChangeRestored.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when); for (com.google.gerrit.extensions.events.ChangeRestoredListener l : listeners) { try { l.onChangeRestored(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeRestored.log.error("Couldn't fire event", e); } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account uploader, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notify) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.RevisionCreated.Event event = new com.google.gerrit.server.extensions.events.RevisionCreated.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify); for (com.google.gerrit.extensions.events.RevisionCreatedListener l : listeners) { try { l.onRevisionCreated(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.RevisionCreated.log.error("Couldn't fire event", e); } }
private com.google.gerrit.server.diff.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.diff.PatchListNotAvailableException { com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); if ((patchSet.getRevision()) == null) { throw new com.google.gerrit.server.diff.PatchListNotAvailableException(("revision is null for " + (patchSet.getId()))); } org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; if (parentNum != null) { return get(com.google.gerrit.server.diff.PatchListKey.againstParentNum(parentNum, b, ws), project); } return get(com.google.gerrit.server.diff.PatchListKey.againstDefaultBase(b, ws), project); }
public com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsPerFilePath() { return edits.stream().collect(toMultimap(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit::getNewFilePath, java.util.function.Function.identity(), ArrayListMultimap::create)); }
public com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> getEdits() { return com.google.gerrit.server.diff.IntraLineDiff.deepCopyEdits(edits); }
@java.lang.Override public boolean equals(com.google.gerrit.server.diff.CharText a, int ai, com.google.gerrit.server.diff.CharText b, int bi) { return (a.charAt(ai)) == (b.charAt(bi)); }
static com.google.gerrit.server.diff.DiffSummary toDiffSummary(com.google.gerrit.server.diff.PatchList patchList) { java.util.List<java.lang.String> r = new java.util.ArrayList(patchList.getPatches().size()); for (com.google.gerrit.server.diff.PatchListEntry e : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { continue; } switch (e.getChangeType()) { case ADDED : case MODIFIED : case DELETED : case COPIED : case REWRITE : r.add(e.getNewName()); break; case RENAMED : r.add(e.getOldName()); r.add(e.getNewName()); break; } } java.util.Collections.sort(r); return new com.google.gerrit.server.diff.DiffSummary(r.toArray(new java.lang.String[r.size()]), patchList.getInsertions(), patchList.getDeletions()); }
public static com.google.gerrit.server.diff.PatchListKey againstCommit(org.eclipse.jgit.lib.AnyObjectId otherCommitId, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace whitespace) { return new com.google.gerrit.server.diff.PatchListKey(otherCommitId, newId, whitespace, com.google.gerrit.server.diff.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
protected com.google.gerrit.server.diff.PatchList getPatchList() throws com.google.gerrit.server.diff.PatchListNotAvailableException { if ((patchSet) != null) { return args.patchListCache.get(change, patchSet); } throw new com.google.gerrit.server.diff.PatchListNotAvailableException("no patchSet specified"); }
public java.lang.String getUnifiedDiff() { com.google.gerrit.server.diff.PatchList patchList; try { patchList = getPatchList(); if ((patchList.getOldId()) == null) { return "[Octopus merge; cannot be formatted as a diff.]\n"; } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn(("Cannot format patch " + (e.getMessage()))); return ""; } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot format patch", e); return ""; } int maxSize = args.settings.maximumDiffSize; org.eclipse.jgit.util.TemporaryBuffer.Heap buf = new org.eclipse.jgit.util.TemporaryBuffer.Heap(java.lang.Math.min(com.google.gerrit.server.mail.send.ChangeEmail.HEAP_EST_SIZE, maxSize), maxSize); try (org.eclipse.jgit.diff.DiffFormatter fmt = new org.eclipse.jgit.diff.DiffFormatter(buf)) { try (org.eclipse.jgit.lib.Repository git = args.server.openRepository(change.getProject())) { try { fmt.setRepository(git); fmt.setDetectRenames(true); fmt.format(patchList.getOldId(), patchList.getNewId()); return org.eclipse.jgit.util.RawParseUtils.decode(buf.toByteArray()); } catch (java.io.IOException e) { if (org.eclipse.jgit.internal.JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) { return ""; } com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot format patch", e); return ""; } } catch (java.io.IOException e) { com.google.gerrit.server.mail.send.ChangeEmail.log.error("Cannot open repository to format patch", e); return ""; } } }
public java.lang.String getChangeDetail() { try { java.lang.StringBuilder detail = new java.lang.StringBuilder(); if ((patchSetInfo) != null) { detail.append(patchSetInfo.getMessage().trim()).append("\n"); } else { detail.append(change.getSubject().trim()).append("\n"); } if ((patchSet) != null) { detail.append("---\n"); com.google.gerrit.server.diff.PatchList patchList = getPatchList(); for (com.google.gerrit.server.diff.PatchListEntry p : patchList.getPatches()) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(p.getNewName())) { continue; } detail.append(p.getChangeType().getCode()).append(" ").append(p.getNewName()).append("\n"); } detail.append(java.text.MessageFormat.format(("" + ((("{0,choice,0#0 files|1#1 file|1<{0} files} changed, " + "{1,choice,0#0 insertions|1#1 insertion|1<{1} insertions}(+), ") + "{2,choice,0#0 deletions|1#1 deletion|1<{2} deletions}(-)") + "\n")), ((patchList.getPatches().size()) - 1), patchList.getInsertions(), patchList.getDeletions())); detail.append("\n"); } return detail.toString(); } catch (java.lang.Exception err) { com.google.gerrit.server.mail.send.ChangeEmail.log.warn("Cannot format change detail", err); return ""; } }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) { com.googlecode.prolog_cafe.lang.Term a5 = engine.r5; @java.lang.SuppressWarnings("unchecked") java.util.Iterator<com.google.gerrit.server.diff.PatchListEntry> iter = ((java.util.Iterator<com.google.gerrit.server.diff.PatchListEntry>) (((com.googlecode.prolog_cafe.lang.JavaObjectTerm) (a5)).object())); if (!(iter.hasNext())) { return engine.fail(); } return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.cont = cont; engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); if (a1 instanceof com.googlecode.prolog_cafe.lang.VariableTerm) { throw new com.googlecode.prolog_cafe.exceptions.PInstantiationException(this, 1); } if (!(a1 instanceof com.googlecode.prolog_cafe.lang.SymbolTerm)) { throw new com.googlecode.prolog_cafe.exceptions.IllegalTypeException(this, 1, "symbol", a1); } java.util.regex.Pattern regex = java.util.regex.Pattern.compile(a1.name()); engine.r1 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(regex); engine.r2 = arg2; engine.r3 = arg3; engine.r4 = arg4; com.google.gerrit.server.diff.PatchList pl = StoredValues.PATCH_LIST.get(engine); java.util.Iterator<com.google.gerrit.server.diff.PatchListEntry> iter = pl.getPatches().iterator(); engine.r5 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm(iter); return engine.jtry5(gerrit.PRED_commit_delta_4.commit_delta_check, gerrit.PRED_commit_delta_4.commit_delta_next); }
@org.junit.Test public void largeObjectTombstoneGetsCached() { com.google.gerrit.server.diff.PatchListKey key = com.google.gerrit.server.diff.PatchListKey.againstDefaultBase(org.eclipse.jgit.lib.ObjectId.zeroId(), Whitespace.IGNORE_ALL); com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone tombstone = new com.google.gerrit.server.patch.PatchListCacheImpl.LargeObjectTombstone(); abstractPatchListCache.put(key, tombstone); assertThat(abstractPatchListCache.getIfPresent(key)).isSameAs(tombstone); }
private static void assertAdded(java.lang.String expectedNewName, com.google.gerrit.server.diff.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.ADDED); }
private com.google.gerrit.server.diff.PatchListKey getKey(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) { return com.google.gerrit.server.diff.PatchListKey.againstCommit(revisionIdA, revisionIdB, Whitespace.IGNORE_NONE); }
private static void assertDeleted(java.lang.String expectedNewName, com.google.gerrit.server.diff.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.DELETED); }
private static void assertName(java.lang.String expectedNewName, com.google.gerrit.server.diff.PatchListEntry e) { assertThat(e.getNewName()).isEqualTo(expectedNewName); assertThat(e.getOldName()).isNull(); }
private java.util.List<com.google.gerrit.server.diff.PatchListEntry> getCurrentPatches(java.lang.String changeId) throws java.lang.Exception { return patchListCache.get(getKey(null, getCurrentRevisionId(changeId)), project).getPatches(); }
private java.util.List<com.google.gerrit.server.diff.PatchListEntry> getPatches(org.eclipse.jgit.lib.ObjectId revisionIdA, org.eclipse.jgit.lib.ObjectId revisionIdB) throws java.lang.Exception { return patchListCache.get(getKey(revisionIdA, revisionIdB), project).getPatches(); }
private static void assertModified(java.lang.String expectedNewName, com.google.gerrit.server.diff.PatchListEntry e) { com.google.gerrit.acceptance.server.change.PatchListCacheIT.assertName(expectedNewName, e); assertThat(e.getChangeType()).isEqualTo(ChangeType.MODIFIED); }
public void addPatchSetFileNames(com.google.gerrit.server.data.PatchSetAttribute patchSetAttribute, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) { try { com.google.gerrit.server.diff.PatchList patchList = patchListCache.get(change, patchSet); for (com.google.gerrit.server.diff.PatchListEntry patch : patchList.getPatches()) { if ((patchSetAttribute.files) == null) { patchSetAttribute.files = new java.util.ArrayList(); } com.google.gerrit.server.data.PatchAttribute p = new com.google.gerrit.server.data.PatchAttribute(); p.file = patch.getNewName(); p.fileOld = patch.getOldName(); p.type = patch.getChangeType(); p.deletions -= patch.getDeletions(); p.insertions = patch.getInsertions(); patchSetAttribute.files.add(p); } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.events.EventFactory.log.warn(("Cannot get patch list: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { com.google.gerrit.server.events.EventFactory.log.warn("Cannot get patch list", e); } }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, org.eclipse.jgit.lib.ObjectId objectId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.diff.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId a = (base == null) ? null : org.eclipse.jgit.lib.ObjectId.fromString(base.getRevision().get()); return toFileInfoMap(change, com.google.gerrit.server.diff.PatchListKey.againstCommit(a, objectId, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.diff.PatchListNotAvailableException { return toFileInfoMap(change, patchSet.getRevision(), null); }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.diff.PatchListKey key) throws com.google.gerrit.server.diff.PatchListNotAvailableException { com.google.gerrit.server.diff.PatchList list = patchListCache.get(key, change.getProject()); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> files = new java.util.TreeMap<>(); for (com.google.gerrit.server.diff.PatchListEntry e : list.getPatches()) { com.google.gerrit.extensions.common.FileInfo d = new com.google.gerrit.extensions.common.FileInfo(); d.status = ((e.getChangeType()) != (Patch.ChangeType.MODIFIED)) ? e.getChangeType().getCode() : null; d.oldPath = e.getOldName(); d.sizeDelta = e.getSizeDelta(); d.size = e.getSize(); if ((e.getPatchType()) == (Patch.PatchType.BINARY)) { d.binary = true; } else { d.linesInserted = ((e.getInsertions()) > 0) ? e.getInsertions() : null; d.linesDeleted = ((e.getDeletions()) > 0) ? e.getDeletions() : null; } com.google.gerrit.extensions.common.FileInfo o = files.put(e.getNewName(), d); if (o != null) { d.status = Patch.ChangeType.REWRITE.getCode(); d.sizeDelta = o.sizeDelta; d.size = o.size; if (((o.binary) != null) && (o.binary)) { d.binary = true; } if ((o.linesInserted) != null) { d.linesInserted = o.linesInserted; } if ((o.linesDeleted) != null) { d.linesDeleted = o.linesDeleted; } } } return files; }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, int parent) throws com.google.gerrit.server.diff.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, com.google.gerrit.server.diff.PatchListKey.againstParentNum((parent + 1), b, Whitespace.IGNORE_NONE)); }
java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo> toFileInfoMap(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.RevId revision, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base) throws com.google.gerrit.server.diff.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId objectId = org.eclipse.jgit.lib.ObjectId.fromString(revision.get()); return toFileInfoMap(change, objectId, base); }
public com.google.gerrit.server.diff.DiffSummary.ChangedLines getChangedLines() { return new com.google.gerrit.server.diff.DiffSummary.ChangedLines(insertions, deletions); }
public com.google.gerrit.extensions.common.RevisionInfo getRevisionInfo(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet in) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { com.google.gerrit.extensions.common.RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null, isWorldReadable(cd)); accountLoader.fill(); return rev; } }
static com.google.gerrit.server.diff.ComparisonType readFrom(java.io.InputStream in) throws java.io.IOException { int p = readVarInt32(in); java.lang.Integer parentNum = (p > 0) ? p : null; boolean autoMerge = (readVarInt32(in)) != 0; return new com.google.gerrit.server.diff.ComparisonType(parentNum, autoMerge); }
private com.google.gerrit.extensions.common.ChangeInfo format(com.google.gerrit.server.query.change.ChangeData cd, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws com.google.gwtorm.server.OrmException { try { if (fillAccountLoader) { accountLoader = accountLoaderFactory.create(has(com.google.gerrit.server.change.DETAILED_ACCOUNTS)); com.google.gerrit.extensions.common.ChangeInfo res = toChangeInfo(cd, limitToPsId); accountLoader.fill(); return res; } return toChangeInfo(cd, limitToPsId); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (!(has(com.google.gerrit.server.change.CHECK))) { com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(e); } return checkOnly(cd); } }
private java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> revisions(com.google.gerrit.server.query.change.ChangeData cd, java.util.Map<com.google.gerrit.reviewdb.client.PatchSet.Id, com.google.gerrit.reviewdb.client.PatchSet> map, java.util.Optional<com.google.gerrit.reviewdb.client.PatchSet.Id> limitToPsId, com.google.gerrit.extensions.common.ChangeInfo changeInfo) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Map<java.lang.String, com.google.gerrit.extensions.common.RevisionInfo> res = new java.util.LinkedHashMap<>(); java.lang.Boolean isWorldReadable = null; try (org.eclipse.jgit.lib.Repository repo = openRepoIfNecessary(cd.project());org.eclipse.jgit.revwalk.RevWalk rw = newRevWalk(repo)) { for (com.google.gerrit.reviewdb.client.PatchSet in : map.values()) { com.google.gerrit.reviewdb.client.PatchSet.Id id = in.getId(); boolean want = false; if (has(com.google.gerrit.server.change.ALL_REVISIONS)) { want = true; } else if (limitToPsId.isPresent()) { want = id.equals(limitToPsId.get()); } else { want = id.equals(cd.change().currentPatchSetId()); } if (want) { if (isWorldReadable == null) { isWorldReadable = isWorldReadable(cd); } res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo, isWorldReadable)); } } return res; } }
private java.util.List<com.google.gerrit.extensions.common.ChangeInfo> toChangeInfo(java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.extensions.common.ChangeInfo> out, java.util.List<com.google.gerrit.server.query.change.ChangeData> changes) { java.util.List<com.google.gerrit.extensions.common.ChangeInfo> info = com.google.common.collect.Lists.newArrayListWithCapacity(changes.size()); for (com.google.gerrit.server.query.change.ChangeData cd : changes) { com.google.gerrit.extensions.common.ChangeInfo i = out.get(cd.getId()); if (i == null) { try { i = toChangeInfo(cd, java.util.Optional.empty()); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException | com.google.gerrit.server.project.NoSuchProjectException | java.lang.RuntimeException e) { if (has(com.google.gerrit.server.change.CHECK)) { i = checkOnly(cd); } else if (e instanceof com.google.gerrit.server.project.NoSuchChangeException) { com.google.gerrit.server.change.ChangeJson.log.info((("NoSuchChangeException: Omitting corrupt change " + (cd.getId())) + " from results. Seems to be stale in the index.")); continue; } else { com.google.gerrit.server.change.ChangeJson.log.warn((("Omitting corrupt change " + (cd.getId())) + " from results"), e); continue; } } out.put(cd.getId(), i); } info.add(i); } return info; }
@java.lang.Override public int weigh(com.google.gerrit.server.diff.DiffSummaryKey key, com.google.gerrit.server.diff.DiffSummary value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 16) + 8) + (2 * 4)) + 16) + 8; for (java.lang.String p : value.getPaths()) { size += ((((16 + 8) + (4 * 4)) + 16) + 8) + ((p.length()) * 2); } return size; }
public static com.google.gerrit.server.diff.ComparisonType againstAutoMerge() { return new com.google.gerrit.server.diff.ComparisonType(null, true); }
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException { writeCanBeNull(out, oldId); out.writeInt(((parentNum) == null ? 0 : parentNum)); writeNotNull(out, newId); java.lang.Character c = com.google.gerrit.server.diff.PatchListKey.WHITESPACE_TYPES.get(whitespace); if (c == null) { throw new java.io.IOException(("Invalid whitespace type: " + (whitespace))); } out.writeChar(c); out.writeChar(com.google.gerrit.server.diff.PatchListKey.ALGORITHM_TYPES.get(algorithm)); }
public static com.google.gerrit.server.diff.ComparisonType againstParent(int parentNum) { return new com.google.gerrit.server.diff.ComparisonType(parentNum, false); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.diff.PatchListKey) { com.google.gerrit.server.diff.PatchListKey k = ((com.google.gerrit.server.diff.PatchListKey) (o)); return ((((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace))) && ((algorithm) == (k.algorithm)); } return false; }
public static void setCommentRevId(com.google.gerrit.reviewdb.client.Comment c, com.google.gerrit.server.diff.PatchListCache cache, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gwtorm.server.OrmException { checkArgument(((c.key.patchSetId) == (ps.getId().get())), "cannot set RevId for patch set %s on comment %s", ps.getId(), c); if ((c.revId) == null) { try { if ((com.google.gerrit.extensions.client.Side.fromShort(c.side)) == (com.google.gerrit.extensions.client.Side.PARENT)) { if ((c.side) < 0) { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, (-(c.side)))); } else { c.revId = org.eclipse.jgit.lib.ObjectId.toString(cache.getOldId(change, ps, null)); } } else { c.revId = ps.getRevision().get(); } } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { throw new com.google.gwtorm.server.OrmException(e); } } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.changes.ReviewResult> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.RevisionResource revision, com.google.gerrit.extensions.api.changes.ReviewInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return apply(updateFactory, revision, input, com.google.gerrit.common.TimeUtil.nowTs()); }
private java.util.Set<java.lang.String> getAffectedFilePaths(com.google.gerrit.server.change.RevisionResource revision) throws com.google.gerrit.server.diff.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId newId = org.eclipse.jgit.lib.ObjectId.fromString(revision.getPatchSet().getRevision().get()); com.google.gerrit.server.diff.DiffSummaryKey key = com.google.gerrit.server.diff.DiffSummaryKey.fromPatchListKey(com.google.gerrit.server.diff.PatchListKey.againstDefaultBase(newId, Whitespace.IGNORE_NONE)); com.google.gerrit.server.diff.DiffSummary ds = patchListCache.getDiffSummary(key, revision.getProject()); return new java.util.HashSet(ds.getPaths()); }
private <T extends com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput> void checkComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<T>> commentsPerPath) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.diff.PatchListNotAvailableException { java.util.Set<java.lang.String> revisionFilePaths = getAffectedFilePaths(revision); for (java.util.Map.Entry<java.lang.String, java.util.List<T>> entry : commentsPerPath.entrySet()) { java.lang.String path = entry.getKey(); com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId = revision.getChange().currentPatchSetId(); com.google.gerrit.server.change.PostReview.ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId); java.util.List<T> comments = entry.getValue(); for (T comment : comments) { com.google.gerrit.server.change.PostReview.ensureLineIsNonNegative(comment.line, path); com.google.gerrit.server.change.PostReview.ensureCommentNotOnMagicFilesOfAutoMerge(path, comment); com.google.gerrit.server.change.PostReview.ensureRangeIsValid(path, comment.range); } } }
private void checkRobotComments(com.google.gerrit.server.change.RevisionResource revision, java.util.Map<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> in) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.diff.PatchListNotAvailableException { com.google.gerrit.server.change.PostReview.cleanUpComments(in); for (java.util.Map.Entry<java.lang.String, java.util.List<com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput>> e : in.entrySet()) { java.lang.String commentPath = e.getKey(); for (com.google.gerrit.extensions.api.changes.ReviewInput.RobotCommentInput c : e.getValue()) { ensureSizeOfJsonInputIsWithinBounds(c); com.google.gerrit.server.change.PostReview.ensureRobotIdIsSet(c.robotId, commentPath); com.google.gerrit.server.change.PostReview.ensureRobotRunIdIsSet(c.robotRunId, commentPath); com.google.gerrit.server.change.PostReview.ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath); } } checkComments(revision, in); }
com.google.gerrit.server.diff.PatchList get(com.google.gerrit.server.diff.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.diff.PatchListNotAvailableException;
com.google.gerrit.server.diff.IntraLineDiff getIntraLineDiff(com.google.gerrit.server.diff.IntraLineDiffKey key, com.google.gerrit.server.diff.IntraLineDiffArgs args);
org.eclipse.jgit.lib.ObjectId getOldId(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.lang.Integer parentNum) throws com.google.gerrit.server.diff.PatchListNotAvailableException;
com.google.gerrit.server.diff.DiffSummary getDiffSummary(com.google.gerrit.server.diff.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project) throws com.google.gerrit.server.diff.PatchListNotAvailableException;
com.google.gerrit.server.diff.PatchList get(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gerrit.server.diff.PatchListNotAvailableException;
private java.util.Collection<java.lang.String> reviewed(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.reviewdb.client.Account.Id userId = user.getAccountId(); com.google.gerrit.reviewdb.client.PatchSet patchSetId = resource.getPatchSet(); java.util.Optional<com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId); if (o.isPresent()) { com.google.gerrit.server.change.AccountPatchReviewStore.PatchSetWithReviewedFiles res = o.get(); if (res.patchSetId().equals(patchSetId.getId())) { return res.files(); } try { return copy(res.files(), res.patchSetId(), resource, userId); } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn(("Cannot copy patch review flags: " + (e.getMessage()))); } catch (java.io.IOException | com.google.gerrit.server.diff.PatchListNotAvailableException e) { com.google.gerrit.server.change.Files.ListFiles.log.warn("Cannot copy patch review flags", e); } } return java.util.Collections.emptyList(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.RevisionResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { checkOptions(); if (reviewed) { return com.google.gerrit.extensions.restapi.Response.ok(reviewed(resource)); } else if ((query) != null) { return com.google.gerrit.extensions.restapi.Response.ok(query(resource)); } com.google.gerrit.extensions.restapi.Response<java.util.Map<java.lang.String, com.google.gerrit.extensions.common.FileInfo>> r; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(resource.getChangeResource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), baseResource.getPatchSet())); } else if ((parentNum) > 0) { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), ((parentNum) - 1))); } else { r = com.google.gerrit.extensions.restapi.Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet())); } if (resource.isCacheable()) { r.caching(com.google.gerrit.extensions.restapi.CacheControl.PRIVATE(7, java.util.concurrent.TimeUnit.DAYS)); } return r; }
private static java.nio.charset.Charset charset(byte[] content, java.lang.String encoding) { if (encoding == null) { org.mozilla.universalchardet.UniversalDetector d = new org.mozilla.universalchardet.UniversalDetector(null); d.handleData(content, 0, content.length); d.dataEnd(); encoding = d.getDetectedCharset(); } if (encoding == null) { return java.nio.charset.StandardCharsets.ISO_8859_1; } try { return java.nio.charset.Charset.forName(encoding); } catch (java.nio.charset.IllegalCharsetNameException err) { com.google.gerrit.server.diff.Text.log.error(((("Invalid detected charset name '" + encoding) + "': ") + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } catch (java.nio.charset.UnsupportedCharsetException err) { com.google.gerrit.server.diff.Text.log.error(((("Detected charset '" + encoding) + "' not supported: ") + err)); return java.nio.charset.StandardCharsets.ISO_8859_1; } }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account author, java.lang.String comment, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.CommentAdded.Event event = new com.google.gerrit.server.extensions.events.CommentAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when); for (com.google.gerrit.extensions.events.CommentAddedListener l : listeners) { try { l.onCommentAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.CommentAdded.log.error("Couldn't fire event", e); } }
public static byte[] asByteArray(org.eclipse.jgit.lib.ObjectLoader ldr) throws java.io.IOException, org.eclipse.jgit.errors.LargeObjectException, org.eclipse.jgit.errors.MissingObjectException { return ldr.getCachedBytes(com.google.gerrit.server.diff.Text.bigFileThreshold); }
@java.lang.Override protected java.lang.String decode(int s, int e) { if ((charset) == null) { charset = com.google.gerrit.server.diff.Text.charset(content, null); } return org.eclipse.jgit.util.RawParseUtils.decode(charset, content, s, e); }
public static com.google.gerrit.server.diff.Text forMergeList(com.google.gerrit.server.diff.ComparisonType comparisonType, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(commitId); java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case 0 : break; case 1 : { break; } default : int uniterestingParent = (comparisonType.isAgainstParent()) ? comparisonType.getParentNum() : 1; b.append("Merge List:\n\n"); for (org.eclipse.jgit.revwalk.RevCommit commit : com.google.gerrit.server.diff.MergeListBuilder.build(rw, c, uniterestingParent)) { b.append("* "); b.append(reader.abbreviate(commit, 8).name()); b.append(" "); b.append(commit.getShortMessage()); b.append("\n"); } } return new com.google.gerrit.server.diff.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
@org.junit.Test public void fileOrder() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, com.google.gerrit.reviewdb.client.Patch.MERGE_LIST, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.diff.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@org.junit.Test public void fileOrderNoMerge() { java.lang.String[] names = new java.lang.String[]{ "zzz", "def/g", "/!xxx", "abc", "qrx", com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG }; java.lang.String[] want = new java.lang.String[]{ com.google.gerrit.reviewdb.client.Patch.COMMIT_MSG, "/!xxx", "abc", "def/g", "qrx", "zzz" }; java.util.Arrays.sort(names, 0, names.length, new java.util.Comparator<java.lang.String>() { @java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.diff.PatchList.comparePaths(o1, o2); } }); assertThat(names).isEqualTo(want); }
@java.lang.Override public int compare(java.lang.String o1, java.lang.String o2) { return com.google.gerrit.server.diff.PatchList.comparePaths(o1, o2); }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { return revisionInfo(project.getNameKey(), ps); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, com.google.gerrit.reviewdb.client.Account reviewer, com.google.gerrit.reviewdb.client.Account remover, java.lang.String message, java.util.Map<java.lang.String, java.lang.Short> newApprovals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerDeleted.Event event = new com.google.gerrit.server.extensions.events.ReviewerDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when); for (com.google.gerrit.extensions.events.ReviewerDeletedListener listener : listeners) { try { listener.onReviewerDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, listener, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerDeleted.log.error("Couldn't fire event", e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.diff.PatchListKey key, com.google.gerrit.server.diff.PatchList value) { int size = ((((((16 + (4 * 8)) + (2 * 36)) + 8) + 16) + (3 * 8)) + (3 * 4)) + 20; for (com.google.gerrit.server.diff.PatchListEntry e : value.getPatches()) { size += e.weigh(); } return size; }
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException { oldId = readCanBeNull(in); int n = in.readInt(); parentNum = (n == 0) ? null : java.lang.Integer.valueOf(n); newId = readNotNull(in); char t = in.readChar(); whitespace = com.google.gerrit.server.diff.PatchListKey.WHITESPACE_TYPES.inverse().get(t); if ((whitespace) == null) { throw new java.io.IOException(("Invalid whitespace type code: " + t)); } char algorithmCharacter = in.readChar(); algorithm = com.google.gerrit.server.diff.PatchListKey.ALGORITHM_TYPES.inverse().get(algorithmCharacter); }
public static com.google.gerrit.server.diff.PatchListKey againstParentNum(int parentNum, org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.diff.PatchListKey(parentNum, newId, ws, com.google.gerrit.server.diff.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public com.google.gerrit.server.diff.PatchListKey.Algorithm getAlgorithm() { return algorithm; }
public com.google.gerrit.extensions.common.RevisionInfo revisionInfo(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.reviewdb.client.PatchSet ps) throws com.google.gerrit.server.GpgException, com.google.gerrit.server.diff.PatchListNotAvailableException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey()); return changeJson.getRevisionInfo(cd, ps); }
public static com.google.gerrit.server.diff.PatchListKey againstDefaultBase(org.eclipse.jgit.lib.AnyObjectId newId, com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws) { return new com.google.gerrit.server.diff.PatchListKey(null, newId, ws, com.google.gerrit.server.diff.PatchListKey.Algorithm.OPTIMIZED_DIFF); }
public static com.google.gerrit.server.diff.Text forCommit(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.AnyObjectId commitId) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { org.eclipse.jgit.revwalk.RevCommit c; if (commitId instanceof org.eclipse.jgit.revwalk.RevCommit) { c = ((org.eclipse.jgit.revwalk.RevCommit) (commitId)); } else { c = rw.parseCommit(commitId); } java.lang.StringBuilder b = new java.lang.StringBuilder(); switch (c.getParentCount()) { case 0 : break; case 1 : { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(0); rw.parseBody(p); b.append("Parent: "); b.append(reader.abbreviate(p, 8).name()); b.append(" ("); b.append(p.getShortMessage()); b.append(")\n"); break; } default : for (int i = 0; i < (c.getParentCount()); i++) { org.eclipse.jgit.revwalk.RevCommit p = c.getParent(i); rw.parseBody(p); b.append((i == 0 ? "Merge Of: " : " ")); b.append(reader.abbreviate(p, 8).name()); b.append(" ("); b.append(p.getShortMessage()); b.append(")\n"); } } com.google.gerrit.server.diff.Text.appendPersonIdent(b, "Author", c.getAuthorIdent()); com.google.gerrit.server.diff.Text.appendPersonIdent(b, "Commit", c.getCommitterIdent()); b.append("\n"); b.append(c.getFullMessage()); return new com.google.gerrit.server.diff.Text(b.toString().getBytes(java.nio.charset.StandardCharsets.UTF_8)); } }
com.google.gerrit.server.patch.DiffSummaryLoader create(com.google.gerrit.server.diff.DiffSummaryKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
@java.lang.Override public com.googlecode.prolog_cafe.lang.Operation exec(com.googlecode.prolog_cafe.lang.Prolog engine) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.setB0(); com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference(); com.googlecode.prolog_cafe.lang.Term a2 = arg2.dereference(); com.googlecode.prolog_cafe.lang.Term a3 = arg3.dereference(); com.google.gerrit.server.diff.PatchList pl = StoredValues.PATCH_LIST.get(engine); if (!(a1.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(((pl.getPatches().size()) - (countMagicFiles(pl.getPatches())))), engine.trail))) { return engine.fail(); } if (!(a2.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getInsertions()), engine.trail))) { return engine.fail(); } if (!(a3.unify(new com.googlecode.prolog_cafe.lang.IntegerTerm(pl.getDeletions()), engine.trail))) { return engine.fail(); } return cont; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Optional<com.google.gerrit.server.edit.ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser()); if (!(edit.isPresent())) { return com.google.gerrit.extensions.restapi.Response.none(); } com.google.gerrit.extensions.common.EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands); if (list) { com.google.gerrit.reviewdb.client.PatchSet basePatchSet = null; if ((base) != null) { com.google.gerrit.server.change.RevisionResource baseResource = revisions.parse(rsrc, com.google.gerrit.extensions.restapi.IdString.fromDecoded(base)); basePatchSet = baseResource.getPatchSet(); } try { editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getEditCommit(), basePatchSet); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } } return com.google.gerrit.extensions.restapi.Response.ok(editInfo); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account reviewer, java.util.Map<java.lang.String, java.lang.Short> approvals, java.util.Map<java.lang.String, java.lang.Short> oldApprovals, com.google.gerrit.extensions.api.changes.NotifyHandling notify, java.lang.String message, com.google.gerrit.reviewdb.client.Account remover, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.VoteDeleted.Event event = new com.google.gerrit.server.extensions.events.VoteDeleted.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when); for (com.google.gerrit.extensions.events.VoteDeletedListener l : listeners) { try { l.onVoteDeleted(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.VoteDeleted.log.error("Couldn't fire event", e); } }
private static com.google.common.collect.ImmutableList<org.eclipse.jgit.diff.Edit> deepCopyEdits(java.util.List<org.eclipse.jgit.diff.Edit> edits) { return edits.stream().map(com.google.gerrit.server.diff.IntraLineDiffArgs::copy).collect(com.google.common.collect.ImmutableList.toImmutableList()); }
public abstract com.google.gerrit.server.diff.Text aText();
public abstract com.google.gerrit.server.diff.Text bText();
public static com.google.gerrit.server.diff.IntraLineDiffArgs create(com.google.gerrit.server.diff.Text aText, com.google.gerrit.server.diff.Text bText, java.util.List<org.eclipse.jgit.diff.Edit> edits, com.google.gerrit.reviewdb.client.Project.NameKey project, org.eclipse.jgit.lib.ObjectId commit, java.lang.String path) { return new com.google.gerrit.server.diff.AutoValue_IntraLineDiffArgs(aText, bText, com.google.gerrit.server.diff.IntraLineDiffArgs.deepCopyEdits(edits), project, commit, path); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.diff.DiffSummaryKey) { com.google.gerrit.server.diff.DiffSummaryKey k = ((com.google.gerrit.server.diff.DiffSummaryKey) (o)); return (((java.util.Objects.equals(oldId, k.oldId)) && (java.util.Objects.equals(parentNum, k.parentNum))) && (java.util.Objects.equals(newId, k.newId))) && ((whitespace) == (k.whitespace)); } return false; }
public static com.google.gerrit.server.diff.DiffSummaryKey fromPatchListKey(com.google.gerrit.server.diff.PatchListKey plk) { com.google.common.base.Preconditions.checkArgument(((plk.getAlgorithm()) == (PatchListKey.Algorithm.OPTIMIZED_DIFF))); return new com.google.gerrit.server.diff.DiffSummaryKey(plk.getOldId(), plk.getParentNum(), plk.getNewId(), plk.getWhitespace()); }
public com.google.gerrit.server.diff.PatchListKey toPatchListKey() { return new com.google.gerrit.server.diff.PatchListKey(oldId, parentNum, newId, whitespace, PatchListKey.Algorithm.OPTIMIZED_DIFF); }
private com.google.gerrit.server.diff.PatchListEntry newCommitMessage(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit) throws java.io.IOException { com.google.gerrit.server.diff.Text aText = (aCommit != null) ? com.google.gerrit.server.diff.Text.forCommit(reader, aCommit) : com.google.gerrit.server.diff.Text.EMPTY; com.google.gerrit.server.diff.Text bText = com.google.gerrit.server.diff.Text.forCommit(reader, bCommit); return com.google.gerrit.server.patch.PatchListLoader.createPatchListEntry(cmp, aCommit, aText, bText, Patch.COMMIT_MSG); }
@java.lang.Override public com.google.gerrit.server.diff.PatchList call() throws com.google.gerrit.server.diff.PatchListNotAvailableException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter ins = newInserter(repo);org.eclipse.jgit.lib.ObjectReader reader = ins.newReader();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(reader)) { return readPatchList(repo, rw, ins); } }
private java.util.Optional<com.google.gerrit.server.diff.PatchListEntry> getPatchListEntry(org.eclipse.jgit.lib.ObjectReader objectReader, org.eclipse.jgit.diff.DiffFormatter diffFormatter, org.eclipse.jgit.diff.DiffEntry diffEntry, org.eclipse.jgit.revwalk.RevTree treeA, org.eclipse.jgit.revwalk.RevTree treeB, java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebase) throws java.io.IOException { org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(key.getNewId(), diffFormatter, diffEntry); long oldSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getOldMode(), diffEntry.getOldPath(), treeA); long newSize = com.google.gerrit.server.patch.PatchListLoader.getFileSize(objectReader, diffEntry.getNewMode(), diffEntry.getNewPath(), treeB); java.util.Set<org.eclipse.jgit.diff.Edit> contentEditsDueToRebase = com.google.gerrit.server.patch.PatchListLoader.getContentEdits(editsDueToRebase); com.google.gerrit.server.diff.PatchListEntry patchListEntry = com.google.gerrit.server.patch.PatchListLoader.newEntry(treeA, fileHeader, contentEditsDueToRebase, newSize, (newSize - oldSize)); if (com.google.gerrit.server.patch.EditTransformer.toEdits(patchListEntry).allMatch(editsDueToRebase::contains)) { return java.util.Optional.empty(); } return java.util.Optional.of(patchListEntry); }
private com.google.gerrit.server.diff.ComparisonType getComparisonType(org.eclipse.jgit.revwalk.RevObject a, org.eclipse.jgit.revwalk.RevCommit b) { for (int i = 0; i < (b.getParentCount()); i++) { if (b.getParent(i).equals(a)) { return com.google.gerrit.server.diff.ComparisonType.againstParent((i + 1)); } } if (((key.getOldId()) == null) && ((b.getParentCount()) > 0)) { return com.google.gerrit.server.diff.ComparisonType.againstAutoMerge(); } return com.google.gerrit.server.diff.ComparisonType.againstOtherPatchSet(); }
private com.google.gerrit.server.diff.PatchListEntry newMergeList(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.revwalk.RevCommit aCommit, org.eclipse.jgit.revwalk.RevCommit bCommit, com.google.gerrit.server.diff.ComparisonType comparisonType) throws java.io.IOException { com.google.gerrit.server.diff.Text aText = (aCommit != null) ? com.google.gerrit.server.diff.Text.forMergeList(comparisonType, reader, aCommit) : com.google.gerrit.server.diff.Text.EMPTY; com.google.gerrit.server.diff.Text bText = com.google.gerrit.server.diff.Text.forMergeList(comparisonType, reader, bCommit); return com.google.gerrit.server.patch.PatchListLoader.createPatchListEntry(cmp, aCommit, aText, bText, Patch.MERGE_LIST); }
private static java.util.Set<org.eclipse.jgit.diff.Edit> getContentEdits(java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebase) { return editsDueToRebase.stream().map(ContextAwareEdit::toEdit).filter(java.util.Optional::isPresent).map(java.util.Optional::get).collect(java.util.stream.Collectors.toSet()); }
private static com.google.gerrit.server.diff.PatchListEntry newEntry(org.eclipse.jgit.revwalk.RevTree aTree, org.eclipse.jgit.patch.FileHeader fileHeader, java.util.Set<org.eclipse.jgit.diff.Edit> editsDueToRebase, long size, long sizeDelta) { if (((aTree == null) || ((fileHeader.getPatchType()) != (org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED))) || (fileHeader.getHunks().isEmpty())) { return new com.google.gerrit.server.diff.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } java.util.List<org.eclipse.jgit.diff.Edit> edits = fileHeader.toEditList(); if (edits.isEmpty()) { return new com.google.gerrit.server.diff.PatchListEntry(fileHeader, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), size, sizeDelta); } return new com.google.gerrit.server.diff.PatchListEntry(fileHeader, edits, editsDueToRebase, size, sizeDelta); }
private org.eclipse.jgit.revwalk.RevObject aFor(com.google.gerrit.server.diff.PatchListKey key, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.revwalk.RevCommit b) throws java.io.IOException { if ((key.getOldId()) != null) { return rw.parseAny(key.getOldId()); } switch (b.getParentCount()) { case 0 : return rw.parseAny(com.google.gerrit.server.patch.PatchListLoader.emptyTree(ins)); case 1 : { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(0); rw.parseBody(r); return r; } case 2 : if ((key.getParentNum()) != null) { org.eclipse.jgit.revwalk.RevCommit r = b.getParent(((key.getParentNum()) - 1)); rw.parseBody(r); return r; } return autoMerger.merge(repo, rw, ins, b, mergeStrategy); default : return null; } }
private java.util.List<com.google.gerrit.server.diff.PatchListEntry> getRelevantPatchListEntries(java.util.List<org.eclipse.jgit.diff.DiffEntry> parentDiffEntries, org.eclipse.jgit.revwalk.RevCommit parentCommitA, org.eclipse.jgit.revwalk.RevCommit parentCommitB, java.util.Set<java.lang.String> touchedFilePaths, org.eclipse.jgit.diff.DiffFormatter diffFormatter) throws java.io.IOException { java.util.List<com.google.gerrit.server.diff.PatchListEntry> parentPatchListEntries = new java.util.ArrayList(parentDiffEntries.size()); for (org.eclipse.jgit.diff.DiffEntry parentDiffEntry : parentDiffEntries) { if (!(com.google.gerrit.server.patch.PatchListLoader.isTouched(touchedFilePaths, parentDiffEntry))) { continue; } org.eclipse.jgit.patch.FileHeader fileHeader = toFileHeader(parentCommitB, diffFormatter, parentDiffEntry); com.google.gerrit.server.diff.PatchListEntry patchListEntry = com.google.gerrit.server.patch.PatchListLoader.newEntry(parentCommitA.getTree(), fileHeader, com.google.common.collect.ImmutableSet.of(), 0, 0); parentPatchListEntries.add(patchListEntry); } return parentPatchListEntries; }
private static com.google.gerrit.server.diff.PatchListEntry createPatchListEntry(org.eclipse.jgit.diff.RawTextComparator cmp, org.eclipse.jgit.revwalk.RevCommit aCommit, com.google.gerrit.server.diff.Text aText, com.google.gerrit.server.diff.Text bText, java.lang.String fileName) { byte[] rawHdr = com.google.gerrit.server.patch.PatchListLoader.getRawHeader((aCommit != null), fileName); byte[] aContent = aText.getContent(); byte[] bContent = bText.getContent(); long size = bContent.length; long sizeDelta = (bContent.length) - (aContent.length); org.eclipse.jgit.diff.RawText aRawText = new org.eclipse.jgit.diff.RawText(aContent); org.eclipse.jgit.diff.RawText bRawText = new org.eclipse.jgit.diff.RawText(bContent); org.eclipse.jgit.diff.EditList edits = new org.eclipse.jgit.diff.HistogramDiff().diff(cmp, aRawText, bRawText); org.eclipse.jgit.patch.FileHeader fh = new org.eclipse.jgit.patch.FileHeader(rawHdr, edits, org.eclipse.jgit.patch.FileHeader.PatchType.UNIFIED); return new com.google.gerrit.server.diff.PatchListEntry(fh, edits, com.google.common.collect.ImmutableSet.of(), size, sizeDelta); }
private static java.util.Set<java.lang.String> getTouchedFilePaths(com.google.gerrit.server.diff.PatchListEntry patchListEntry) { java.lang.String oldFilePath = patchListEntry.getOldName(); java.lang.String newFilePath = patchListEntry.getNewName(); return oldFilePath == null ? com.google.common.collect.ImmutableSet.of(newFilePath) : com.google.common.collect.ImmutableSet.of(oldFilePath, newFilePath); }
public abstract com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsDueToRebasePerFilePath();
com.google.gerrit.server.patch.PatchListLoader create(com.google.gerrit.server.diff.PatchListKey key, com.google.gerrit.reviewdb.client.Project.NameKey project);
private static java.util.Set<com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> getEditsDueToRebase(com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath, org.eclipse.jgit.diff.DiffEntry diffEntry) { if (editsDueToRebasePerFilePath.isEmpty()) { return com.google.common.collect.ImmutableSet.of(); } java.lang.String filePath = diffEntry.getNewPath(); if ((diffEntry.getChangeType()) == (org.eclipse.jgit.diff.DiffEntry.ChangeType.DELETE)) { filePath = diffEntry.getOldPath(); } return com.google.common.collect.ImmutableSet.copyOf(editsDueToRebasePerFilePath.get(filePath)); }
public static com.google.gerrit.server.patch.PatchListLoader.EditsDueToRebaseResult create(java.util.List<org.eclipse.jgit.diff.DiffEntry> relevantDiffEntries, com.google.common.collect.Multimap<java.lang.String, com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit> editsDueToRebasePerFilePath) { return new com.google.gerrit.server.patch.AutoValue_PatchListLoader_EditsDueToRebaseResult(relevantDiffEntries, editsDueToRebasePerFilePath); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account abandoner, java.lang.String reason, java.sql.Timestamp when, com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeAbandoned.Event event = new com.google.gerrit.server.extensions.events.ChangeAbandoned.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling); for (com.google.gerrit.extensions.events.ChangeAbandonedListener l : listeners) { try { l.onChangeAbandoned(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeAbandoned.log.error("Couldn't fire event", e); } }
@java.lang.Override public int weigh(com.google.gerrit.server.diff.IntraLineDiffKey key, com.google.gerrit.server.diff.IntraLineDiff value) { return ((((((((16 + (8 * 8)) + (2 * 36)) + 16) + (2 * 8)) + 16) + 8) + 4) + 20) + (((8 + 16) + (4 * 4)) * (value.getEdits().size())); }
private int search(java.lang.String fileName) { com.google.gerrit.server.diff.PatchListEntry want = com.google.gerrit.server.diff.PatchListEntry.empty(fileName); return java.util.Arrays.binarySearch(patches, 0, patches.length, want, com.google.gerrit.server.diff.PatchList.PATCH_CMP); }
private int countMagicFiles(java.util.List<com.google.gerrit.server.diff.PatchListEntry> entries) { int count = 0; for (com.google.gerrit.server.diff.PatchListEntry e : entries) { if (com.google.gerrit.reviewdb.client.Patch.isMagic(e.getNewName())) { count++; } } return count; }
private static java.lang.String getOldFilePath(com.google.gerrit.server.diff.PatchListEntry patchListEntry) { return com.google.common.base.MoreObjects.firstNonNull(patchListEntry.getOldName(), patchListEntry.getNewName()); }
static com.google.gerrit.server.diff.PatchListEntry readFrom(java.io.InputStream in) throws java.io.IOException { com.google.gerrit.reviewdb.client.Patch.ChangeType changeType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.ChangeType.values()); com.google.gerrit.reviewdb.client.Patch.PatchType patchType = readEnum(in, com.google.gerrit.reviewdb.client.Patch.PatchType.values()); java.lang.String oldName = readString(in); java.lang.String newName = readString(in); byte[] hdr = readBytes(in); int ins = readVarInt32(in); int del = readVarInt32(in); long size = readFixInt64(in); long sizeDelta = readFixInt64(in); org.eclipse.jgit.diff.Edit[] editArray = com.google.gerrit.server.diff.PatchListEntry.readEditArray(in); org.eclipse.jgit.diff.Edit[] editsDueToRebase = com.google.gerrit.server.diff.PatchListEntry.readEditArray(in); return new com.google.gerrit.server.diff.PatchListEntry(changeType, patchType, oldName, newName, hdr, com.google.common.collect.ImmutableList.copyOf(editArray), com.google.common.collect.ImmutableSet.copyOf(editsDueToRebase), ins, del, size, sizeDelta); }
@java.lang.Override public int getEnd(com.google.gerrit.server.patch.EditTransformer.ContextAwareEdit edit) { return edit.getEndA(); }
@java.lang.Override public com.google.gerrit.server.diff.PatchList createValue(com.googlecode.prolog_cafe.lang.Prolog engine) { com.google.gerrit.server.rules.PrologEnvironment env = ((com.google.gerrit.server.rules.PrologEnvironment) (engine.control)); com.google.gerrit.reviewdb.client.PatchSet ps = com.google.gerrit.server.rules.StoredValues.getPatchSet(engine); com.google.gerrit.server.diff.PatchListCache plCache = env.getArgs().getPatchListCache(); com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.rules.StoredValues.getChange(engine); com.google.gerrit.reviewdb.client.Project.NameKey project = change.getProject(); org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get()); com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace ws = com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE; com.google.gerrit.server.diff.PatchListKey plKey = com.google.gerrit.server.diff.PatchListKey.againstDefaultBase(b, ws); com.google.gerrit.server.diff.PatchList patchList; try { patchList = plCache.get(plKey, project); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException e) { throw new com.googlecode.prolog_cafe.exceptions.SystemException(("Cannot create " + plKey)); } return patchList; }
private void writeObject(java.io.ObjectOutputStream output) throws java.io.IOException { final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream(); try (java.util.zip.DeflaterOutputStream out = new java.util.zip.DeflaterOutputStream(buf)) { writeCanBeNull(out, oldId); writeNotNull(out, newId); writeVarInt32(out, (isMerge ? 1 : 0)); comparisonType.writeTo(out); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeVarInt32(out, patches.length); for (com.google.gerrit.server.diff.PatchListEntry p : patches) { p.writeTo(out); } } writeBytes(output, buf.toByteArray()); }
public static com.google.gerrit.server.diff.ComparisonType againstOtherPatchSet() { return new com.google.gerrit.server.diff.ComparisonType(null, false); }
private static com.google.gerrit.reviewdb.client.Patch.PatchType toPatchType(org.eclipse.jgit.patch.FileHeader hdr) { com.google.gerrit.reviewdb.client.Patch.PatchType pt; switch (hdr.getPatchType()) { case UNIFIED : pt = com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED; break; case GIT_BINARY : case BINARY : pt = com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY; break; default : throw new java.lang.IllegalArgumentException(("Unsupported type " + (hdr.getPatchType()))); } if (pt != (com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY)) { final byte[] buf = hdr.getBuffer(); for (int ptr = hdr.getStartOffset(); ptr < (hdr.getEndOffset()); ptr++) { if ((buf[ptr]) == '\u0000') { pt = com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY; break; } } } return pt; }
void writeTo(java.io.OutputStream out) throws java.io.IOException { writeEnum(out, changeType); writeEnum(out, patchType); writeString(out, oldName); writeString(out, newName); writeBytes(out, header); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeFixInt64(out, size); writeFixInt64(out, sizeDelta); com.google.gerrit.server.diff.PatchListEntry.writeEditArray(out, edits); com.google.gerrit.server.diff.PatchListEntry.writeEditArray(out, editsDueToRebase); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet patchSet, java.util.List<com.google.gerrit.reviewdb.client.Account> reviewers, com.google.gerrit.reviewdb.client.Account adder, java.sql.Timestamp when) { if ((!(listeners.iterator().hasNext())) || (reviewers.isEmpty())) { return; } try { com.google.gerrit.server.extensions.events.ReviewerAdded.Event event = new com.google.gerrit.server.extensions.events.ReviewerAdded.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), com.google.common.collect.Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when); for (com.google.gerrit.extensions.events.ReviewerAddedListener l : listeners) { try { l.onReviewersAdded(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ReviewerAdded.log.error("Couldn't fire event", e); } }
public java.util.List<com.google.gerrit.server.diff.PatchListEntry> getPatches() { return java.util.Collections.unmodifiableList(java.util.Arrays.asList(patches)); }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.Account merger, java.lang.String newRevisionId, java.sql.Timestamp when) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.ChangeMerged.Event event = new com.google.gerrit.server.extensions.events.ChangeMerged.Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when); for (com.google.gerrit.extensions.events.ChangeMergedListener l : listeners) { try { l.onChangeMerged(event); } catch (java.lang.Exception e) { util.logEventListenerError(this, l, e); } } } catch (com.google.gerrit.server.patch.PatchListObjectTooLargeException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.warn(("Couldn't fire event: " + (e.getMessage()))); } catch (com.google.gerrit.server.diff.PatchListNotAvailableException | com.google.gerrit.server.GpgException | java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.extensions.events.ChangeMerged.log.error("Couldn't fire event", e); } }
@java.lang.Override public int compare(com.google.gerrit.server.diff.PatchListEntry a, com.google.gerrit.server.diff.PatchListEntry b) { return com.google.gerrit.server.diff.PatchList.comparePaths(a.getNewName(), b.getNewName()); }
public com.google.gerrit.reviewdb.client.Patch.PatchType getPatchType() { return patchType; }
private static byte[] compact(org.eclipse.jgit.patch.FileHeader h) { final int end = com.google.gerrit.server.diff.PatchListEntry.end(h); if (((h.getStartOffset()) == 0) && (end == (h.getBuffer().length))) { return h.getBuffer(); } final byte[] buf = new byte[end - (h.getStartOffset())]; java.lang.System.arraycopy(h.getBuffer(), h.getStartOffset(), buf, 0, buf.length); return buf; }
public java.util.List<com.google.gerrit.reviewdb.client.Patch> toPatchList(com.google.gerrit.reviewdb.client.PatchSet.Id setId) { final java.util.ArrayList<com.google.gerrit.reviewdb.client.Patch> r = new java.util.ArrayList(patches.length); for (com.google.gerrit.server.diff.PatchListEntry e : patches) { r.add(e.toPatch(setId)); } return r; }
public int weigh() { int size = ((((((16 + (6 * 8)) + (2 * 4)) + 20) + 16) + 8) + 4) + 20; size += com.google.gerrit.server.diff.PatchListEntry.stringSize(oldName); size += com.google.gerrit.server.diff.PatchListEntry.stringSize(newName); size += header.length; size += ((8 + 16) + (4 * 4)) * (edits.size()); size += ((8 + 16) + (4 * 4)) * (editsDueToRebase.size()); return size; }
public com.google.gerrit.server.diff.PatchListEntry get(java.lang.String fileName) { final int index = search(fileName); return 0 <= index ? patches[index] : com.google.gerrit.server.diff.PatchListEntry.empty(fileName); }
public static com.google.gerrit.server.diff.PatchListEntry empty(java.lang.String fileName) { return new com.google.gerrit.server.diff.PatchListEntry(com.google.gerrit.reviewdb.client.Patch.ChangeType.MODIFIED, com.google.gerrit.reviewdb.client.Patch.PatchType.UNIFIED, null, fileName, com.google.gerrit.server.diff.PatchListEntry.EMPTY_HEADER, com.google.common.collect.ImmutableList.of(), com.google.common.collect.ImmutableSet.of(), 0, 0, 0, 0); }
private byte[] getMergeList(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change.Id changeId = notes.getChangeId(); com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.current(db.get(), notes); if (ps == null) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(notes.getProjectName());org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(git)) { return com.google.gerrit.server.diff.Text.forMergeList(com.google.gerrit.server.diff.ComparisonType.againstAutoMerge(), revWalk.getObjectReader(), org.eclipse.jgit.lib.ObjectId.fromString(ps.getRevision().get())).getContent(); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException e) { throw new com.google.gerrit.server.project.NoSuchChangeException(changeId, e); } }
public com.google.gerrit.server.diff.ComparisonType getComparisonType() { return comparisonType; }
private void readObject(java.io.ObjectInputStream input) throws java.io.IOException { final java.io.ByteArrayInputStream buf = new java.io.ByteArrayInputStream(readBytes(input)); try (java.util.zip.InflaterInputStream in = new java.util.zip.InflaterInputStream(buf)) { oldId = readCanBeNull(in); newId = readNotNull(in); isMerge = (readVarInt32(in)) != 0; comparisonType = com.google.gerrit.server.diff.ComparisonType.readFrom(in); insertions = readVarInt32(in); deletions = readVarInt32(in); final int cnt = readVarInt32(in); final com.google.gerrit.server.diff.PatchListEntry[] all = new com.google.gerrit.server.diff.PatchListEntry[cnt]; for (int i = 0; i < (all.length); i++) { all[i] = com.google.gerrit.server.diff.PatchListEntry.readFrom(in); } patches = all; } }
private static java.util.List<org.eclipse.jgit.diff.Edit> intraline(java.lang.String a, java.lang.String b, org.eclipse.jgit.diff.Edit lines) throws java.lang.Exception { com.google.gerrit.server.diff.Text aText = new com.google.gerrit.server.diff.Text(a.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.diff.Text bText = new com.google.gerrit.server.diff.Text(b.getBytes(java.nio.charset.StandardCharsets.UTF_8)); com.google.gerrit.server.diff.IntraLineDiff diff = com.google.gerrit.server.patch.IntraLineLoader.compute(aText, bText, com.google.common.collect.ImmutableList.of(lines)); assertThat(diff.getStatus()).isEqualTo(IntraLineDiff.Status.EDIT_LIST); java.util.List<org.eclipse.jgit.diff.Edit> actualEdits = diff.getEdits(); assertThat(actualEdits).hasSize(1); org.eclipse.jgit.diff.Edit actualEdit = actualEdits.get(0); assertThat(actualEdit.getBeginA()).isEqualTo(lines.getBeginA()); assertThat(actualEdit.getEndA()).isEqualTo(lines.getEndA()); assertThat(actualEdit.getBeginB()).isEqualTo(lines.getBeginB()); assertThat(actualEdit.getEndB()).isEqualTo(lines.getEndB()); assertThat(actualEdit).isInstanceOf(org.eclipse.jgit.diff.ReplaceEdit.class); return ((org.eclipse.jgit.diff.ReplaceEdit) (actualEdit)).getInternalEdits(); }
@java.lang.SuppressWarnings("deprecation") @com.google.common.annotations.VisibleForTesting static org.eclipse.jgit.lib.ObjectId getNoteKey(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { return org.eclipse.jgit.lib.ObjectId.fromRaw(com.google.common.hash.Hashing.sha1().hashString(groupName.get(), java.nio.charset.StandardCharsets.UTF_8).asBytes()); }
private static com.google.gerrit.server.group.InternalGroup removeRefState(com.google.gerrit.server.group.InternalGroup group) throws java.lang.Exception { return group.toBuilder().setRefState(null).build(); }
private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> logGroupNames() throws java.lang.Exception { return com.google.gerrit.server.group.db.testing.GroupTestUtil.log(repo, com.google.gerrit.server.group.db.REFS_GROUPNAMES); }
private com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log(com.google.gerrit.reviewdb.client.AccountGroup g) throws java.lang.Exception { return com.google.gerrit.server.group.db.testing.GroupTestUtil.log(repo, com.google.gerrit.reviewdb.client.RefNames.refsGroups(g.getGroupUUID())); }
private static java.lang.String getAsNoteData(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.UUID_PARAM, uuid.get()); config.setString(com.google.gerrit.server.group.db.GroupNameNotes.SECTION_NAME, null, com.google.gerrit.server.group.db.GroupNameNotes.NAME_PARAM, groupName.get()); return config.toText(); }
@com.google.common.annotations.VisibleForTesting public static com.google.gerrit.common.data.GroupReference getGroupReference(org.eclipse.jgit.lib.ObjectReader reader, org.eclipse.jgit.lib.ObjectId noteDataBlobId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { byte[] noteData = reader.open(noteDataBlobId, com.google.gerrit.server.group.db.OBJ_BLOB).getCachedBytes(); return com.google.gerrit.server.group.db.GroupNameNotes.getFromNoteData(noteData); }
@java.lang.Override public void run() { com.google.gerrit.server.account.AccountDeactivator.log.info("Running account deactivations"); try { int numberOfAccountsDeactivated = 0; for (com.google.gerrit.server.account.AccountState acc : accountQueryProvider.get().query(com.google.gerrit.server.query.account.AccountPredicates.isActive())) { if (processAccount(acc)) { numberOfAccountsDeactivated++; } } com.google.gerrit.server.account.AccountDeactivator.log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated); } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountDeactivator.log.error(("Failed to complete deactivation of accounts: " + (e.getMessage())), e); } }
private boolean matchCriteria(com.google.gerrit.server.config.PluginConfig config, java.lang.String criteria, @com.google.gerrit.common.Nullable java.lang.String value, boolean allowRegex, boolean refMatcher) { java.lang.String[] c = config.getStringList(criteria); if ((c.length) == 0) { return true; } if (value == null) { return false; } if (allowRegex) { return java.util.Arrays.stream(c).anyMatch(( s) -> com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.match(value, s, refMatcher)); } return java.util.Arrays.asList(c).contains(value); }
@java.lang.Override public org.apache.http.impl.client.CloseableHttpClient get() { return org.apache.http.impl.client.HttpClients.custom().setConnectionManager(create(socketMgr.get())).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build(); }
public boolean getSslVerify() { return sslVerify; }
public boolean getSslVerify() { return config.getBoolean(com.googlesource.gerrit.plugins.webhooks.RemoteConfig.REMOTE, name, com.googlesource.gerrit.plugins.webhooks.RemoteConfig.SSL_VERIFY, global.getSslVerify()); }
@java.lang.Override protected void configure() { bind(java.util.concurrent.ScheduledExecutorService.class).annotatedWith(com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class).toProvider(com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class).in(Scopes.SINGLETON); factory(PostTask.Factory.class); factory(RemoteConfig.Factory.class); factory(HttpSession.Factory.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.common.EventListener.class).to(com.googlesource.gerrit.plugins.webhooks.EventHandler.class); bind(org.apache.http.impl.client.CloseableHttpClient.class).annotatedWith(com.google.inject.name.Names.named(com.googlesource.gerrit.plugins.webhooks.DefaultHttpClientProvider.DEFAULT)).toProvider(com.googlesource.gerrit.plugins.webhooks.DefaultHttpClientProvider.class).in(Scopes.SINGLETON); bind(org.apache.http.impl.client.CloseableHttpClient.class).annotatedWith(com.google.inject.name.Names.named(com.googlesource.gerrit.plugins.webhooks.SslVerifyingHttpClientProvider.SSL_VERIFY)).toProvider(com.googlesource.gerrit.plugins.webhooks.SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON); install(processors); }
@org.junit.Test public void pushToGroupsBranchForNonAllUsersRepo() throws java.lang.Exception { assertCreateGroupBranch(project, null); java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(project, groupRef, true, null); }
private void assertPushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRefName, boolean createRef, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, RefNames.REFS_GROUPNAMES, Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); if (createRef) { createGroupBranch(project, groupRefName); } com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + ":groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", GroupConfig.GROUP_CONFIG_FILE, "some content").to(groupRefName); if (expectedErrorOnUpdate != null) { r.assertErrorStatus(expectedErrorOnUpdate); } else { r.assertOkStatus(); } }
@org.junit.Test public void pushToGroupNamesBranchForNonAllUsersRepo() throws java.lang.Exception { assertPushToGroupBranch(project, RefNames.REFS_GROUPNAMES, true, null); }
@org.junit.Test public void pushToGroupNamesBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); allowGlobalCapabilities(com.google.gerrit.acceptance.api.group.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); assertPushToGroupBranch(allUsers, RefNames.REFS_GROUPNAMES, false, "group update not allowed"); }
private void assertCreateGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.PUSH, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Update group config", GroupConfig.GROUP_CONFIG_FILE, "some content").setParents(com.google.common.collect.ImmutableList.of()).to(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + (name("bar")))); if (expectedErrorOnCreate != null) { r.assertErrorStatus(expectedErrorOnCreate); } else { r.assertOkStatus(); } }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(allUsers, groupRef, (!(groupsInNoteDb())), "group update not allowed"); }
@java.lang.Override public void index(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { for (com.google.gerrit.index.Index<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.server.account.AccountState> i : getWriteIndexes()) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull(id); if (accountState != null) { i.replace(accountState); } else { i.delete(id); } } fireAccountIndexedEvent(id.get()); com.google.gerrit.server.index.account.AccountIndexerImpl.autoReindexIfStale(id); }
private void autoReindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) { if (autoReindexIfStale) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = reindexIfStale(id); } }
@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) { java.util.concurrent.Callable<java.lang.Boolean> task = () -> { if (stalenessChecker.isStale(id)) { index(id); return true; } return false; }; return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancellationPropagating(batchExecutor.submit(task)), IndexUtils.MAPPER); }
private void assertStaleAccountAndReindex(com.google.gerrit.reviewdb.client.Account.Id accountId) throws java.io.IOException { accountsCache.invalidate(accountId); assertThat(stalenessChecker.isStale(accountId)).isTrue(); accountIndexer.index(accountId); assertThat(stalenessChecker.isStale(accountId)).isFalse(); }
private void assertWriteGroupToReviewDbBlockedException(java.lang.Exception e) throws java.lang.Exception { java.lang.Throwable t = com.google.common.base.Throwables.getRootCause(e); assertThat(t).isInstanceOf(com.google.gwtorm.server.OrmException.class); assertThat(t.getMessage()).isEqualTo("Updates to groups in ReviewDb are blocked"); }
@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void blockReviewDbUpdatesOnGroupUpdate() throws java.lang.Exception { assume().that(groupsInNoteDb()).isFalse(); java.lang.String group1 = gApi.groups().create(name("foo")).get().id; java.lang.String group2 = gApi.groups().create(name("bar")).get().id; cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true); try { gApi.groups().id(group1).addGroups(group2); fail("Expected RestApiException: Updates to groups in ReviewDb are blocked"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertWriteGroupToReviewDbBlockedException(e); } }
@org.junit.Test @com.google.gerrit.acceptance.Sandboxed public void blockReviewDbUpdatesOnGroupCreation() throws java.lang.Exception { assume().that(groupsInNoteDb()).isFalse(); cfg.setBoolean("user", null, "blockReviewDbGroupUpdates", true); try { gApi.groups().create(name("foo")); fail("Expected RestApiException: Updates to groups in ReviewDb are blocked"); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { assertWriteGroupToReviewDbBlockedException(e); } }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.project.ProjectData> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.project.ProjectData> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneQuerySource(opts.filterFields(IndexUtils::projectFields), queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneProjectIndex.NAME_SORT_FIELD, SortField.Type.STRING, false))); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<V> read() throws com.google.gwtorm.server.OrmException { return readImpl(( doc) -> fromDocument(doc)); }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.group.InternalGroup> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.group.InternalGroup> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneQuerySource(opts.filterFields(IndexUtils::groupFields), queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneGroupIndex.UUID_SORT_FIELD, SortField.Type.STRING, false))); }
@java.lang.Override public com.google.gerrit.index.query.DataSource<com.google.gerrit.server.account.AccountState> getSource(com.google.gerrit.index.query.Predicate<com.google.gerrit.server.account.AccountState> p, com.google.gerrit.index.QueryOptions opts) throws com.google.gerrit.index.query.QueryParseException { return new com.google.gerrit.lucene.LuceneQuerySource(opts.filterFields(IndexUtils::accountFields), queryBuilder.toQuery(p), new org.apache.lucene.search.Sort(new org.apache.lucene.search.SortField(com.google.gerrit.lucene.LuceneAccountIndex.ID_SORT_FIELD, SortField.Type.LONG, true))); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupById get(com.google.gerrit.reviewdb.client.AccountGroupById.Key key) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> all() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id id) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupById.Key> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.Id> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroup> byUUID(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> byAccount(com.google.gerrit.reviewdb.client.Account.Id id) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupName get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byGroupInclude(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.AccountGroup.UUID incGroupUUID) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupMember get(com.google.gerrit.reviewdb.client.AccountGroupMember.Key key) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupByIdAud get(com.google.gerrit.reviewdb.client.AccountGroupByIdAud.Key key) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroupMemberAudit get(com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key key) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> all() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupByIdAud.Key> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> all() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroup get(com.google.gerrit.reviewdb.client.AccountGroup.Id id) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> byGroup(com.google.gerrit.reviewdb.client.AccountGroup.Id id) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMember> get(java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroupMember.Key> keys) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupName> iterateAllEntities() { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupById> byIncludeUUID(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> byGroupAccount(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.Account.Id accountId) { throw new java.lang.UnsupportedOperationException(com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper.MSG); }
@java.lang.Override public org.eclipse.jgit.revwalk.RevCommit commit(com.google.gerrit.server.git.MetaDataUpdate update) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit c = super.commit(update); loadedGroup = java.util.Optional.of(loadedGroup.get().toBuilder().setRefState(c.toObjectId()).build()); return c; }
@org.junit.Test public void getAuditLog() throws java.lang.Exception { com.google.gerrit.extensions.api.groups.GroupApi g = gApi.groups().create(name("group")); java.util.List<? extends com.google.gerrit.extensions.common.GroupAuditEventInfo> auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(1); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, admin.id); g.addMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(2); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id); g.removeMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(3); assertAuditEvent(auditEvents.get(0), Type.REMOVE_USER, admin.id, user.id); java.lang.String otherGroup = name("otherGroup"); gApi.groups().create(otherGroup); g.addGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(4); assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup); g.removeGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(5); assertAuditEvent(auditEvents.get(0), Type.REMOVE_GROUP, admin.id, otherGroup); java.lang.Thread.sleep(1000); g.addMembers(user.username); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(6); assertAuditEvent(auditEvents.get(0), Type.ADD_USER, admin.id, user.id); g.addGroups(otherGroup); auditEvents = g.auditLog(); assertThat(auditEvents).hasSize(7); assertAuditEvent(auditEvents.get(0), Type.ADD_GROUP, admin.id, otherGroup); java.sql.Timestamp lastDate = null; for (com.google.gerrit.extensions.common.GroupAuditEventInfo auditEvent : auditEvents) { if (lastDate != null) { assertThat(lastDate).isAtLeast(auditEvent.date); } lastDate = auditEvent.date; } }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getMembersAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> audits = db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); java.util.Collections.sort(audits, java.util.Comparator.comparing((com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a) -> a.getAddedOn())); return audits; }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getSubgroupsAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> audits = db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); java.util.Collections.sort(audits, java.util.Comparator.comparing((com.google.gerrit.reviewdb.client.AccountGroupByIdAud a) -> a.getAddedOn())); return audits; }
final com.google.common.collect.ImmutableList<T> parseAuditLog(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)); if (ref == null) { return com.google.common.collect.ImmutableList.of(); } com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = com.google.gerrit.server.group.db.GroupConfig.loadForGroup(repo, uuid).getLoadedGroup().get().getId(); rw.reset(); rw.markStart(rw.parseCommit(ref.getObjectId())); rw.setRetainBody(true); rw.sort(RevSort.COMMIT_TIME_DESC, true); rw.sort(RevSort.REVERSE, true); com.google.common.collect.ImmutableList.Builder<T> result = com.google.common.collect.ImmutableList.builder(); org.eclipse.jgit.revwalk.RevCommit c; while ((c = rw.next()) != null) { parse(uuid, c).ifPresent(( pc) -> visit(groupId, pc, result)); } return result.build(); } }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> getSubgroupsAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getSubgroupsAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupByIdAud().byGroup(group.get().getId()).toList(); }
public java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> getMembersAudit(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (groupsMigration.readFromNoteDb()) { return auditLogReader.getMembersAudit(groupUuid); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> group = com.google.gerrit.server.group.db.Groups.getGroupFromReviewDb(db, groupUuid); if (!(group.isPresent())) { return com.google.common.collect.ImmutableList.of(); } return db.accountGroupMembersAudit().byGroup(group.get().getId()).toList(); }