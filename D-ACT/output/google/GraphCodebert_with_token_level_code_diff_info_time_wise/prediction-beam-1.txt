@java.lang.Override protected com.google.gerrit.server.group.InternalGroup fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(source.getAsJsonObject().get(GroupField.UUID.getName()).getAsString()); return groupCache.get(uuid).orElse(nullOrEmpty(uuid).orElse(null); }
@java.lang.Override protected com.google.gerrit.server.project.ProjectData fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(source.getAsJsonObject().get(ProjectField.NAME).getAsString()); return projectCache.get(nameKey).toProjectData(); }
protected abstract V com.google.gson.GsonObject docType(com.google.gson.JsonObject doc, java.util.Set<java.lang.String> fields);
@java.lang.Override protected com.google.gerrit.server.account.AccountState fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(source.getAsJsonObject().get(com.google.gerrit.elasticsearch.ID.getName()).getAsInt()); return accountCache.get().get(id); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<V> read() throws com.google.gwtorm.server.OrmException { return readImpl(doc, doc, doc.fields()); }
@java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb open() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = delegate.open(); if (migration.readChanges()) { if (migration.disableChangeReviewDb()) { if (migration.disableChangeReviewDb()) { db = new com.google.gerrit.reviewdb.server.ReviewDbWrapper(db); } db = new com.google.gerrit.reviewdb.server.ReviewDbWrapper(db); } if (groupsMigration.disableFromNoteDb()) { if (groupsMigration.disableGroupReviewDb()) { db = new com.google.gerrit.reviewdb.server.ReviewDbWrapper(db); } db = db.accounts().get(db); } return db; }
static java.lang.String getGroupName(com.google.gerrit.server.account.GroupCache groupCache, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) { java.lang.String uuid = groupUuid.get(); java.lang.String name = groupCache.get(groupUuid).map(InternalGroup::getName).orElse(uuid); return com.google.gerrit.server.group.Sets.formatNameEmail(name, uuid); }
@org.junit.Test public void includeExternalGroup() throws java.lang.Exception { java.lang.String g = createGroup("group"); java.lang.String subgroupUuid = System.REGISTERED_USERS.get(); gApi.groups().id(g).addGroups(g).addGroups(submoduleUuid); java.util.List<com.google.gerrit.extensions.common.GroupInfo> subgroups = gApi.groups().id(g).includedGroups); java.util.List<com.google.gerrit.extensions.common.GroupInfo> subgroups = gApi.groups().id(g).includedGroups(); assertThat(subgroups).isEqualTo(1); assertThat(subgroups.get(0).groupId).isNull(); if (groupsMigration.writeToNoteDb()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().id(g).get().id); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { com.google.gerrit.reviewdb.client.AccountGroupTest.UUID uuid = new com.google.gerrit.server.group.TestUtil.TestUtil.log(repo, com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)); assertThat(log).hasSize(2); assertThat(log.get(1)).message().isEqualTo("Update group\nAdd-group: global: Global: global: Global-groups"); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> audit = groups.getSubgroups(db, uuid); assertThat(audit).hasSize(1); assertThat(log).hasSize(1); } } return result; }
@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named( MonitoringCapability.ID)).to(com.googlesource.gerrit.plugins.javax.annotation.Timestamp.class); if (cfg.getBoolean("allowTopMenu", true)) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).to(com.googlesource.gerrit.plugins.javax.servlet.Servlet.Timer.class); } final java.nio.file.Path directory =TARGET_WINDORIZORY.resolve(pluginName); if ((java.nio.file.Files.isDirectory(directory)) && (java.nio.file.Files.isDirectory(directory))) { storage_directory = directory; } else { storage_directory = tmpDir.resolve(pluginName); } if ((java.lang.System.getProperty(((pluginName) + ".storage-directory") == null) { java.lang.System.setProperty(((pluginName) + ".storage-directory") + ".storage-directory")); } }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = com.googlesource.gerrit.plugins.javax.servlet.Json.JsonFilter.JAXBinder.TEMPTY_DOTORY.resolve(com.googlesource.gerrit.plugins.javax.servlet.JodyFilter.JAMAMAMAMEL, java.nio.file.Path tmpFile[]{ tmp.toString(), java.nio.file.Files.JAVAMAMAMEL_PREFIX); if (java.nio.file.Files.isDirectory(defaultDataDir)) { try { java.nio.file.Files.createDirectories(defaultDataDir); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javax.plugins.javax.servlet.Json.GerritFilter.JsonFilter.log.error("Creation of javax.nio.file.NameJAVAMLETE_PEL, default path failed.", defaultDataDir, e); throw new java.lang.RuntimeException(e); } } return defaultDataDir.toString(); }
private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage) throws java.io.IOException { return new java.util.concurrent.atomic.AtomicLong(repo, commitMessage, null); }
private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage, @com.google.gerrit.common.Nullable org.eclipse.jgit.lib.ObjectId treeId) throws java.io.IOException { try (org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter()) { if (treeId == null) { treeId = oi.insert(Constants.OBJ_TREE, new byte[]{ }); } org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.CommitBuilder(); org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(treeId); cb.setCommitter(ident); cb.setCommitter(ident); cb.setAuthor(commitMessage); org.eclipse.jgit.lib.ObjectId commit = oi.insert(cb); oi.flush(); return commit; } }
@org.junit.Test public void pushToDeletedGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(allUsers, groupRef, true, "group update not allowed"); }
@org.junit.Test @com.google.gerrit.acceptance.Sandboxedb.Test public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); com.google.gerrit.server.group.InternalGroup adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orElse(null); assertThat(adminGroup).isNotNull(); testCannotDeleteGroupBranch(((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroup.getGroupUUID())); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if ((receiveEvent.command.getRefName().startsWith(RefNames.REFS_DELETED_GROUPS)) || (receiveEvent.command.getRefName().startsWith(RefNames.REFS_DELEPS)); return java.util.Collections.emptyList(); } return java.util.Collections.emptyList(); }
private void createBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, java.lang.String commitMessage) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter oi = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyCommit = createCommit(r, commitMessage); org.eclipse.jgit.lib.ObjectId emptyCommit = r.updateRef(r, commitMessage); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(r, commitMessage); org.eclipse.jgit.lib.RefUpdate updateRef = r.updateRef(ref); updateRef.setExpectedOldObjectId(emptyCommit); assertThat(updateRefUpdate.Result.NEW); } }
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || ((!(allUsersName.equals(destBranch.nameKey()))) || (!(destBranch.equals(RefNames.REFS_DELETE_GROUPS))) && (!(destBranch.equals(RefNames.REFS_DEFAULT_GROUPS))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException("not allowed to allowed to allowed to allowed"); }
@org.junit.Test public void pushToDeletedGroupsBranchForNonAllUsersRepo() throws java.lang.Exception { assertCreateGroupBranch(project, null); java.lang.String groupRef = com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroupBranch(project, groupRef, true, null); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFileNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developr)); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationErrors()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationError()).getMessage()).isEqualTo(((("Group " + (staff.getName())) + " not in ") + (GroupList.FILE_NAME))); }
@org.junit.Test public void readConfigLabelScores() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developr, com.google.gerrit.server.git.ProjectConfigTest.group(developrpc)).add("project.config", com.google.gerrit.server.git.ProjectConfigTest.group(developrpc)).add("project.config", com.google.gerrit.server.git.ProjectConfigTest.group(ev); java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> labels = cfg.getLabelSections(); com.google.gerrit.common.data.LabelType type = labels.entrySet().next().next().getValue(); assertThat(type.isCopyMinScore()).isNotEqualTo(LabelType.DEFAULT_MIN_MIN_MIN_MIN_MIN_MIN_MIN_MIN); assertThat(type.isCopyMaxScore()).isNotEqualTo(LabelType.DEFAULT_MAX_MIN_MIN_MIN_MIN_MIN); assertThat(type.isCopyAllScoresOnTrivialRebase()).isNotEqualTo(LabelType.DEFAULT_CODE_MERGE_PRIVIAL_UPDATE); assertThat(type.isCopyAllScoresOnTrivialRebase()).isNotEqualTo(LabelType.DEFAULT_CODE_NOT_UPDATE); assertThat(type.isCopyAllScoresIfNoTrivialRebase()).isNotEqualTo(LabelType.DEFAULT_ALL_PRIVIAL_PRIVIAL_UPDATE); assertThat(type.isCopyAllScoresIfNoCodeChange()).isNotEqualTo(LabelType.DE_COPTRA_ALL_NOT_PRIVIAL_UPDATE); assertThat(type.isCopyAllScoresIfNoCodeChange()).isNotEqualTo(labelType.DEFAULT_ALL_PRIVIAL_PRIVIAL_PRIVIAL_PRIVIAL_UPDATE); assertThat(type.isCopyAllScoresIfNoCode()).isNotEqualTo(
@org.junit.Test public void editPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(evict); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig cfg = cfg.getPluginConfig("project"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(1); pluginCfg.setGroupReference("key1", staff); pluginCfg.setGroupReference("key1", staff); pluginCfg.setGroupReference("key1", staff); pluginCfg.setGroupReference("key1", staff); pluginCfg.setGroupReference("key1", staff); rev = commit(rev, "project.config")).isEqualTo((((("" + (("" + (("" + "\"\n") + (staff.toConfig().get())) + "\n")); assertThat(text(rev, "groups")).isEqualTo(((((((("UUID Name " + "#\n") + (staff.getUUID().get())) + (staff.getName())) + "\n")); }
@org.junit.Test public void readPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developr)); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginCfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(evict); }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = java.nio.file.Paths.get(java.lang.System.getProperty("java.lang.System.tmpdir"))).resolve(com.googlesource.gerrit.plugins.javax.servlet.GerritMockFilter.JAXBJAXBJAVAM_PACK_PREFIX); if (java.nio.file.Files.isDirectory(tmp)) { return tmp.toString(); } return java.nio.file.Paths.Paths.toNullable(tmp); }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo apply(com.google.gerrit.server.config.ConfigResource resource, com.google.gerrit.extensions.api.config.ConsistencyCheckInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE); if ((input == null) || ((input.checkAccounts) == null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("check required"); } com.google.gerrit.extensions.api.config.ConsistencyCheckInfo consistencyCheckInfo = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(); if ((input.checkAccounts) == null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckInfo(accountsConsistencyChecker.check()); } if ((input.checkAccounts)!= null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckInfo.CheckAccountsResultInfo(accountsConsistencyChecker.check()); } if ((input.checkAccountExternalIds)!= null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckInfo.CheckResultInfo(groupsConsistencyChecker.check()); } return consistencyCheckInfo; }
public void setAllowSaveEmptyName(boolean allowSaveEmptyName) { this.allowSaveEmptyName = com.google.gerrit.server.project.ProjectControl.getNameKey(allowSaveEmpty); }
private GroupBundle.Builder newGroupBundle() { java.sql.Timestamp ts = new java.sql.Timestamp(TestTimeUtil.ST.ST.toEphemerle()); com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("group-1"), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.Account.Id(1000), group.getId())); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(member, new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupById("subgroup")); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupById(group, new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup
private static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.GroupNameNotes.Sets.Sets.Sets.UTF_8); java.lang.String uuid = com.google.common.base.Strings.nullToEmpty(config.getString(com.google.gerrit.server.group.GroupNameSets.Sets.Sets.NAME, null, com.google.gerrit.server.group.GroupNameSUBMES)); if (uuid == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Unsupported for group '%s'", name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }
@java.lang.Override public int hashCode() { return java.lang.System.identityHashCode(this); }
private java.util.Optional<java.lang.String> getNewName() { if (groupUpdate.isPresent()) { return groupUpdate.get().getName().map((n) -> com.google.common.base.Strings.nullToEmpty(n.get())); } else if (groupCreation.isPresent()) { return java.util.Optional.of(com.google.common.base.Strings.nullToEmpty(groupCreation.get().getNameKey().get())); } return java.util.Optional.emptySet(); }
public boolean accToRealm(@java.lang.SuppressWarnings("unused") java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { return false; }
@java.lang.Override public boolean accToRealm(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { for (com.google.gerrit.server.account.externalids.ExternalId id : externalIds) { if (id.toString().contains(com.google.gerrit.server.account.externalids.SCHEME_GERRIT)) { return true; } } return false; }
@java.lang.Override public boolean accToRealm(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { for (com.google.gerrit.server.account.externalids.ExternalId id : externalIds) { if (id.toString().contains(com.google.gerrit.server.account.externalids.SCHEME_EXTERNAL)) { return true; } } return false; }
private boolean processAccount(com.google.gerrit.server.account.AccountState account) { com.google.gerrit.server.account.AccountDeactivate(("Account " + (account.getUserName()))); try { if (((account.getUserName())!= null) && (!(realm.isActive(account.getUserName()))) { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> ids = externalIds.byAccount(account.getAccount().getId()); if (realm.acc.containsKey(ids)) { sif.deactivate(account.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivate(("Already activated, already deleted, continuing, continuing...", account.getUserName()); return true; } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { com.google.gerrit.server.account.AccountDeactivateDeactivateDelet.log.error("Could not activated, already activated, continuing, continuing, continuing..."); } return false; }
private static boolean isByIdConsumeConsume(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> reviewDbIds, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> reviewDbByIdAudits) { com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.reviewdb.client.AccountGroup.Id> reviewDbById = com.google.common.collect.Sets.newHashSet<com.google.gerrit.reviewdb.client.AccountGroup.Id>(); com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> reviewDbById = com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbByIdByIdById = com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> noteDbByIdById = com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> noteDbByIdByIdByIdById; return com.google.gerrit.server.group.GroupBundle.GroupBundle.asList(reviewDbByIdAuditIdAuditIdAuditId, noteDbByIdAuditsById, noteDb); }
private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> toMemberAuditEntriesByMemberId(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> memberAudits) { return memberAudits.stream().flatMap(com.google.common.collect.Multimap.toMultimap(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> memberAudits) -> memberAudits.stream().map(com.google.common.collect.Multimap.toList(com.google.gerrit.server.group.GroupBundle.AuditEntry::getTarget, java.util.Function<com.google.gerrit.server.group.GroupBundle.AuditEntry> com.google.common.collect.MultimapBuilder.hashKeys().treeSetValues(com.google.gerrit.server.group.GroupBundle.AuditEntry::getTarget, java.util.Function<com.google.gerrit.server.group.GroupBundle.AuditEntry>::treeSetValues) { com.google.common.collect.MultimapBuilder.hashKeys.hashKeys().treeSetValues(com.google.gerrit.server.group.GroupBundle.Audit_ENT_ENTRY_COMPARATOR).build(); }
private static boolean isMemberConsConsConsumed(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDb, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDb, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDbMembersAudits) { com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> reviewDbMembersAuditsByMemberId = com.google.common.collect.Sets.newArrayListMultimap<com.google.gerrit.reviewdb.client.AccountGroup.Id, com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbByMemberId = com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbByMemberId = com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbByMemberId = com.google.gerrit.server.group.GroupBundle.GroupBundle.Entry<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbByMemberId = com.google.gerrit.server.group.GroupBundle.GroupBundle.toMemberId(reviewDbMemberAuditsByMemberId, noteDb); return com.google.gerrit.server.group.GroupBundle.areToAll(reviewDbMemberAuditsByMemberId, noteDb); }
private static boolean areConspected(com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> reviewDbByMemberAuditsByMemberId, com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> reviewDbMemberAuditsByMemberId) { for (java.lang.String memberId : reviewDbMemberAuditsByMemberAuditsByMemberId.keySet()) { java.util.List<com.google.gerrit.server.group.GroupBundle.GroupBundle.AuditEntry> reviewDbAuditEntries = com.google.common.collect.ImmutableList.copyOf(reviewDbMemberAuditEntry.get(memberId)); java.util.SortedSet<com.google.gerrit.server.group.GroupBundle.AuditEntry> noteDbAuditEntries = com.google.common.collect.ImmutableList.copyOf(reviewDbMemberAuditEntry.get(memberId); java.util.SortedSet<com.google.gerrit.server.group.GroupBundle.AuditEntry> noteDbAuditEntry = reviewDbEntry.get(reviewDbEntry); if (!(reviewDbIndexedDbIndexedRefs.size())) { com.google.gerrit.server.group.GroupBundle.AuditEntry reviewDbAuditEntry = reviewDbAuditEntries.get(reviewDbIndex); if (!(reviewDbIndexedRefEntry.equals(reviewDbAuditEntry.getAction()))) { com.google.gerrit.server.group.GroupBundle.AuditEntry reviewDbAuditEntry = reviewDbAuditEntries.get(reviewDbIndex); if (!(reviewDbAuditEntry.size())) { com.google.gerrit.server.group.GroupBundle.Entry reviewDbAuditEntry = reviewDbAuditEntries.get(reviewDbIndex); if (!(reviewDbAuditEntry.size())) { continue; } } if (!(reviewDbIndexedReviewDbAuditEntry.size())) { return false; } } if (reviewDbIndex!= (
private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditEntry> toByIdAuditEntriesByIdById(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byIdAudits) { return byIdAudits.stream().flatMap(com.google.common.collect.Multimap.toMultimap(com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> byIdAudits) -> byIdAudits.key().collect(com.google.common.collect.Multimap.toList(com.google.gerrit.server.group.GroupBundle.AuditEntry::getTarget, java.util.Function<com.google.gerrit.server.group.GroupBundle.AuditEntry> com.google.common.collect.MultimapBuilder.hashKeys().treeSetValues(com.google.gerrit.server.group.GroupBundle.AuditEntry::audit_ENT_entry).build(); }
public java.lang.String getName() { if ((fullName)!= null) { return fullName; } if ((preferredEmail)!= null) { return fullName; } return prefs; }
private static org.eclipse.jgit.lib.PersonIdent ident(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String anonymousCowardName, com.google.gerrit.server.CurrentUser u, java.util.Date when) { com.google.gerrit.server.notedb.AbstractChangeUpdate.checkUserType(u); if (u instanceof com.google.gerrit.server.IdentifiedUser) { return noteUtil.newIdent(u.asIdentifiedUser().getAccount(), when, serverIdent); } else if (u instanceof com.google.gerrit.server.InternalUser) { return serverIdent; } throw new java.lang.IllegalStateException(); }
public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check(org.eclipse.jgit.lib.Repository repo, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroupReference> byUUID) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(groupsMigration.writeToNoteDb())) { return new java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref>(); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getAllRefs(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); com.google.common.collect.Maps.newHashMap<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> nameMap = com.google.common.collect.HashMap.create(); readGroups(repo, refs, problems, problems, nameMap); if (!(problems.isEmpty())) { return problems; } problems = checkGlobalConsistency(byUUID, nameMap); return problems; }
public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check() throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.HashMap<>(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = globalChecker.check(repo, groups); if (!(problems.isEmpty())) { return problems; } for (com.google.gerrit.server.group.InternalGroupInfo.ConsistencyChecker p : groups.values()) { problems.addAll(checkGroup(g, groups)); } return problems; } }
@com.google.gerrit.common.Nullable public com.google.gerrit.server.group.GroupDbConsistencyChecker.Result check(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.gerrit.server.group.GitDbConsistencyChecker.Result r = doChecker.Result((repo) + ") + (r.problems.isEmpty())) + " not group")); return r; }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (checkStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_OK)) { return; } else { try { rsp.sendError(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_SERVER_ERROR); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.log.error("Failed to send error response", e); } } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { if (sp.contains(com.google.gerrit.server.IdentifiedUser.getServletResponse(req)) { rsp.httpdapStatus.INSTANCE.isNull(com.google.gerrit.server.IdentifiedUserServlet.class); } }
@org.junit.Before public void setUp() throws java.lang.Exception { when(currentUserProviderMock.get()).thenReturn(currentUserMock); when(currentUserMock.getCapabilities()).thenReturn(capabilityControlMock); when(capabilityControlMock.canAdministrateServer()).thenReturn(true); servlet = new com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.highavailability.Html(tempFolder.getRoot().toPath(), currentUserProviderMock); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forwarder.HttpServletResponse rsp) { if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.rest.HttpResponse rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.rest.HttpResponse rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_NO_CONTENT); } try { setUnchecked(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.log.error("Error to set {}", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.SC_INTERNAL_SERVER_ERROR); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forward.HttpServletResponse rsp) { if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.rest.HttpResponse rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.rest.HttpResponse rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.config.SC_NO_CONTENT); return; } try { setHealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.log.error("Error to set {}", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.SC_INTERNAL_SERVER_ERROR); } }
private void sendError(com.ericsson.gerrit.plugins.highavailability.highavailability.HttpServletResponse rsp, int statusCode) { try { rsp.sendError(statusCode); } catch (java.io.IOException e) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.forward.SC_INTERNAL_SERVER_ERROR); com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.H2.log.error("Failed to send error response response response response response response response", e); } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forwarder.HttpServletResponse rsp) { if (nawaitFile.exists()) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_SERVER_UNAVAILABLE); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.config.SC_SERVER_UNAVAILABLE); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (http.isNotNullOrEmpty()) { rsp.httpdapResponse rsp.restoreCase(com.google.gerrit.server.IdentifiedUser.getServletResponse(req, com.google.gerrit.server.IdentifiedUser.getServletResponse rsp); } }
private static int getInt(org.eclipse.jgit.lib.Config cfg, java.lang.String section, int defaultValue) { try { return cfg.getInt(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error("Failed to retrieve value for {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve integer value: {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve integer value: " + (e.getMessage()))), e); return defaultValue; } }
private static boolean getBoolean(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, boolean defaultValue) { try { return cfg.getBoolean(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error("Failed to retrieve boolean value {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve boolean value: {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve boolean value: " + (e.getMessage())), e); return defaultValue; } }
private void evictCache(com.google.common.cache.Cache<?,?> cache, java.lang.String cacheName, java.lang.Object key) { if (Constants.PROJECT_LIST.equals(cacheName)) { cache.invalidateAll(); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug("Failed to {}", cacheName); } else { cache.invalidate(key); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug("Cannot {} from {}", key, cacheName); } }
public java.lang.String[] getIssueIds(java.lang.String haystack) { java.util.regex.Pattern pattern = itConfig.getIssuePattern(); if (pattern == null) return new java.lang.String[]{} return new java.lang.String[]{} }; com.googlesource.gerrit.plugins.its.base.base.its.IssueExtractor.log.debug("{}'}'", pattern.pattern()).returning(); java.util.regex.Matcher matcher = com.google.common.collect.Sets.newHashSet(); java.util.regex.Matcher matcher = pattern.matcher( haystack); int groupIdx = itConfig.matcher(wecherrystack); if (!(com.google.common.base.Strings.isNullOrEmpty(issueId))) { java.lang.String issueId = matcher.group(groupIdx); if (!(com.google.common.base.Strings.isNullOrEmpty(issueId))) { issues.add(issueId); } } return issues.toArray(new java.lang.String[issues.size()]); }
public boolean isEnabled(com.google.gerrit.reviewdb.client.Project.NameKey projectName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectNK); if (projectState == null) { com.googlesource.gerrit.plugins.its.base.its.its.its.ItsConfig.log.error("Failed to check if ((projectName.get()) == null) { com.googlesource.gerrit.plugins.its.base.its.its.its.its.ItsConfig.log.error("Failed to check if ((projectState == null) && (!(projectState))) { return true; } if (isEnforcedByAnyParentProject(refName).equals(refName).getString("enabled", "false")); return true; } return!("false".equals(pluginCfgFactory.getFromProjectConfigWithInheritance(projectState, pluginName).getString("enabled", "false")); }
@org.junit.Test public void rebuild() throws java.lang.Exception { assume().that(groupsMigration.writeToNoteDb()).isTrue(); com.google.gerrit.extensions.common.GroupInfo g = gApi.groups().create(name("group")).get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g.id); java.lang.String refName = com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid; try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(uuid);org.eclipse.jgit.lib.ObjectId oldId; com.google.gerrit.reviewdb.client.RefNames.refsGroups = new com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid); org.eclipse.jgit.lib.ObjectId oldId = repo.fromNoteDb(refName); org.eclipse.jgit.junit.TestRepository repo = repo.exactRef(repo, uuid); org.eclipse.jgit.junit.TestRepository repo = repo.exactRef(refName); assertThat(adminRestSession.postOK((("/groups/" + uuid) + "/rebuild"), "").getEntityContent()).isEqualTo("No differences between ReviewDb"); try (org.eclipse.jgit.lib.Repository repo = repo.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); assertThat(ref).isNotNull(); com.google.gerrit.server.group.GroupBundle newBundle(repo, uuid); assertThat(newBundle.group()).isEqualTo(oldId); com.google.gerrit.server.group.GroupBundle newBundle(repo, uuid); assertThat(newBundle.group()).isEqualTo(oldBundle.group()); } }
private java.lang.String getCommentChangeEvent(java.lang.String action, java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = ""; java.lang.String changeNumber = com.google.common.base.Strings.nullToEmpty(map.get("changeNumber"); if (!(changeNumber.isEmpty())) { changeNumber += " + action; } return ("\n" + " + changeNumber) + action; }
private java.lang.String formatPerson(java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Name") + "Username")); if (ret.isEmpty()) { return com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Username")); } return ret; }
static java.lang.String getOwnersFileName(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.query.change.ChangeData c) { if (((com.googlesource.gerrit.plugins.findowners.Config.config)!= null) && (projectState!= null)) { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.getFromProjectConfigWithInheritance(projectState, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getString(com.googlesource.gerrit.plugins.findowners.Config.OWNERS_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME))); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; }
private boolean shouldReplicate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (java.io.IOException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } return shouldReplicate(projectState, userProvider.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("Project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
public java.util.regex.Pattern getIssuePattern() { java.util.Optional<java.lang.String> match = com.googlesource.gerrit.plugins.its.base.base.its.Predicate<com.google.gerrit.extensions.api.projects.CommentLinkInfo>() { @java.lang.Override public boolean apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return ((input.match)!= null) && (!(input.match.trim().isEmpty()))) { filter(input.match.trim().isEmpty()); } }).transform(new com.googlesource.gerrit.plugins.its.base.base.Function<com.google.gerrit.extensions.api.projects.CommentLinkInfo, java.lang.String>() { @java.lang.Override public java.lang.String apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return input.match; }).last(); }).last(); }).last(); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("patch-set-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("createdOn", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("parents", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("insertions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(extractFrom(patchSetAttribute.uploader, "uploader")); properties.addAll(extractFrom(patchSetAttribute.author, "uploader")); }
public static com.google.common.collect.ImmutableList<java.lang.String> compare(com.google.gerrit.server.group.GroupBundle reviewDbBundle, com.google.gerrit.server.group.GroupBundle noteDbBundle, com.google.gerrit.server.group.GroupBundle noteDbBundle) { return com.google.common.collect.ImmutableList.compare(reviewdb.reviewdb.group().getGroupBundle(), com.google.gerrit.server.group.GroupBundle.Bundle.compare(reviewDbBundle, noteDbBundle, true); }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException { if (canRemoveReviewerWithoutPermission.REVIEWER)) { return; } permissionBackend.user(currentUser).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).check(dbProvider).check(ChangePermission.REVIEWER); }
public void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.Account.Id reviewer) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, "noSuchProjectException e); }
@org.junit.Test public void testHealthCheckEnabled() throws java.lang.Exception { when(configMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.DELETE, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HE, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HE, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HE)); assertThat(configuration.highCheck().enabled()).isFalse(); }
@java.lang.Override public org.junit.runner.model.Statement apply(org.junit.runner.model.Statement base, org.junit.runner.Description description) { return new org.junit.runner.model.Statement() { @java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; beforeTest(description); try (com.google.gerrit.acceptance.ProjectConfigResolver.firstNonNull(allProjects, allUsers)) { base.evaluate(); } finally { afterTest(); } } }
protected com.google.gerrit.acceptance.ProjectConfigResolver resetProjects(com.google.gerrit.reviewdb.client.Project.NameKey projectName, java.lang.String projectName) throws java.lang.Exception { return new com.google.gerrit.acceptance.ProjectConfigResolver(repoManager, metaDataUpdateFactory, projectCache, projects); }
@java.lang.Override public void evaluate() throws java.lang.ThrowableException { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); try (com.google.gerrit.acceptance.ProjectConfigResolver resetApproval = resetProjects(allProjects, allUsers)) { base.evaluate(); } finally { afterTest(); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPS); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.common.data.GroupReference> groupReferences = com.google.common.collect.ImmutableSet.builder(); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> uuidMap = new java.util.HashMap<>(); java.util.Map<java.lang.String, com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> uuidMap = new java.util.HashMap<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.server.group.GroupReference groupReference = com.google.gerrit.server.group.GroupNameKey.getGroupReference(reader, note.getData()); groupReference.add(groupReference); } com.google.gerrit.server.group.GroupNameKey = com.google.gerrit.server.group.GroupNameKey.getGroupReference(uuid, uuidMap); if (uuid!= null) { throw new com.google
public static com.google.gerrit.server.group.GroupConfig createForNewGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.group.InternalGroupCreation groupCreation) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupCreation.getGroupUUID(), repository); groupConfig.load(repository); groupConfig.setGroupCreation(groupCreation); return groupConfig; }
public static com.google.gerrit.server.group.GroupConfig loadForGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupUUID.getAccountGroup().groupUUID()); groupConfig.load(repository); return groupConfig; }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> getLoadedGroup() { checkLoaded(); return loadLoaded(); }
public static com.google.gerrit.server.group.GroupConfig loadForGroupDescription(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, org.eclipse.jgit.lib.ObjectId commitId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupUuid.getAccountGroup()); groupConfig.load(repository, commitId); return groupConfig; }
private java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> loadGroup(com.google.gerrit.common.data.GroupReference groupReference) { java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> group = groupCache.get(groupReference.getUUID()).map(InternalGroupDescription::new); if (!(group.isPresent())) { com.google.gerrit.server.group.GroupDbChecker.log.warn("Couldn't found for group " + (com.google.gerrit.server.group.GroupDescription.UUID uuid) from groupName)); } return group; }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictsSuggestParameters()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("No not have no more than " + (conflicts))); } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(com.google.common.collect.Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().findFirst().orElse(null)), ((limit) <= 10) : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupBackend.size()); for (com.google.gerrit.common.data.GroupReference ref : groupBackend.get(ref.getUUID()); if (desc!= null) { groupInfos.add(json.addOptions(options).format(desc)); } else if ((groupBackend) instanceof com.google.gerrit.server.account.InternalGroupBackend) { com.google.gerrit.server.group.GroupDbConnection.Basic db = groupBackend.get(ref.getUUID()); if (desc!= null) { groupInfos.add(json.addOptions(options).format(desc)); } else if ((groupBackend) instanceof com.google.gerrit.server.account.InternalGroupBackend) { com.google.gerrit.server.group.GroupDbConnection.log.log.warn("Cannot check for group %s of group name", ref.getUUID()); } } return groupInfos; }
int findApproval(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.EmailCache.getInstanceKeyApproval(changeData)) { return 0; }
static int getMinOwnerLevelLevel(com.google.gerrit.server.project.ProjectState projectState) throws com.google.gwtorm.server.OrmException { return ((com.googlesource.gerrit.plugins.findowners.Config) == null) || (projectState == null)? com.googlesource.gerrit.plugins.findowners.Config.config.config_ProjectConfigWithInheritance(projectState, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_OWNER_VOTE_LEVELOPTIONS, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_LEVELOPVELOP, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_LEVELOP, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_LEVELOPVELOPVELOP, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_VisibleTo(com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER_VOTE_VOTE_VOTE_LEVELOP, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER); }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRefPredicate.ForRef perm, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Project.NameKey projectName, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.reviewdb.client.Project.NameKey projectName, com.google.gerrit.server.WebLinks links) throws java.io.IOException, org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevObject object = rw.parseAny(ref.getObjectId()); boolean canDelete = perm.testOrFalse(RefPermission.DELETE); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.server.api.projects.TagInfo(tag.getName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), (com.google.gerrit.server.CurrentUser) (object instanceof com.google.gerrit.server.IdentifiedUser) { @java.lang.Override public com.google.gerrit.server.CurrentUser getCurrentUser(com.google.gerrit.server.change.Tag) (object.getWhen().getTime())), null), null, (webLinks.isEmpty())? null : webLinks)); } java.sql.Timestamp timestamp = (object instanceof org.eclipse.jgit.revwalk.RevCommit) (object instanceof org.eclipse.jgit.revwalk.RevCommit) (object instanceof org.eclipse.jgit
@org.junit.Test public void lightweightTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/heads/master"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInput input = new com.google.gerrit.extensions.api.projects.TagInput(); input.ref = new com.google.gerrit.extensions.api.projects.TagInput(); input.refs = "v1.0"; input.revision = r.getCommit().getName(); com.google.gerrit.extensions.api.projects.TagInfo result = tag(input.ref).create(input).create(input).get(); assertThat(result.revision).isEqualTo(((R_TAGS) + (input.ref))); assertThat(result.revision).isEqualTo(input.revision); input.ref = "refs/tags/v2.0"; result = tag(input.ref).create(input.ref); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.canDelete).isTrue(); assertThat(result.canDelete).isTrue(); setApiUser(user); result = tag(input.ref).get(); event.canDelete = user.ref).get(); event.canDelete = project.get(); event.canDelete = project.get(); event.canDelete = project.get(); event.canDeleteRefUpdatedEvents(project.get(), null, null, result.revision); }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.load = com.google.common.collect.ImmutableSet.of(account); this.registeredOn = account.getRegisteredOn(); }
@com.google.common.Nullable public java.util.Optional<com.google.gerrit.reviewdb.client.Account> getLoadedAccount() { checkLoaded(); return loadAccount(); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision)!= null) { rw.reset(); rw.markStart(revision); rw.markStart(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadedAccount = com.google.gerrit.server.account.AccountConfig.readFromAccount(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadedOn = true; } isLoaded = true; }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.notedb.ChangeNotes> openChangesById(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.notedb.ChangeNotes> r = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchOpen(branch)) { r.put(cd.change().getId(), cd.notes()); } return r; }
@org.junit.Test public void testErrorDuringTransitionToHeal() throws java.io.IOException { java.nio.file.Files.createFile(tempFolder.newFolder("unchecked")).toPath().resolve("child")); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doPost(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_ERROR); }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (sshdFile.exists()) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_SERVER_UNAVAILABLE); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.forward.SC_NO_CONTENT); }
@org.junit.Test public void testErrorDuringTransitionToUntransport() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_ERROR); }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setHealthy(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.highavailability.H_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.log.error("Error to set {}", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_SERVER_ERROR); } }
@org.junit.Before public void setUp() throws java.lang.Exception { servlet = new com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.HookServlet(tempFolder.getRoot().toPath()); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setUnchecked(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.forward.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.highavailability.H_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.highavailability.log.error("Error to set {}", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_ERROR); } }
@java.lang.Override public com.google.gerrit.extensions.common.BaseRevertInfo pureRevert(@com.google.gerrit.common.Nullable java.lang.String claimed) throws com.google.gerrit.extensions.restapi.RestApiException { try { return calculate pureRevert.getNativeRevert(change.getNotes(), claimedOriginal); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot compute pure revert revert revert", e); } }
@com.google.gerrit.common.Nullable public java.lang.Boolean isPureRevert() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getPureRevert(notes(), null).isForceRevert; } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { throw new com.google.gwtorm.server.OrmException("Cannot not compute pure revert", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.BaseRevertInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException, java.io.IOException { return calculateNativeRevert.get(rsrc.getNotes(), claimedOriginal); }
private void setUp(java.lang.Object target) throws java.lang.Exception { injector = com.google.inject.Guice.createInjector(new com.google.gerrit.testutil.InMemoryModule()); injector = new com.google.inject.ProvisionManager(); lifecycle.add(inMemoryDatabase.getDatabase().open()) { schemaCreator.add(inMemoryDatabase.getDatabase().open()) { schemaCreator.create(inMemoryDatabase.getDatabase().open()) { schemaCreator.create(inMemoryDatabase.getDatabase().open())); } db = schemaFactory.open(); setApiUser(accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId()); }
@org.junit.Test public void testErrorDuringTransitionToUnTransitionToUnHealthy() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock).sendError(com.ericsson.gerrit.plugins.highavailability.highavailability.highavailability.SC_INTERNAL_ERROR); }
private java.lang.String getProtocolStack(org.eclipse.jgit.lib.Config cfg, SitePaths site) { java.lang.String location = cfg.getString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.Protocol_STACK_STACK_KEY); if (p.isAbsolute()) { return null; } java.nio.file.Path p = java.nio.file.Paths.get(location); if (p.isAbsolute()) { return site.etc_dir.resolve(location).toString(); } return site.etc_dir.resolve(location).toString(); }
public java.lang.String protocolStack() { return protocolStack; }
private org.junit.Json getChannel() { java.lang.String protocol = ""; try { protocolStack = javax.nio.JChannel.class; return protocolStack == null? new org.jgit.groups.Json.JsonConnection() : new org.jgit.JsonConnection(protocolStack.toString()), protocolStackTr, e); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.Json.JGroupsPeerInfoProvider.log.error("Unable to create a new channel with {}", protocolStack, e); return null; } }
public void connect() { try { channel = getChannel(); java.util.Optional<java.net.InetAddress> address = finder.findAddress(); if (address.isPresent()) { com.ericsson.gerrit.plugins.highavailability.peers.JGroupsPeerPeerPeerInfoProvider.log.debug(("Cannot lookup webstack: " + (channel.getProtocolStack()))); com.ericsson.gerrit.plugins.highavailability.peers.Jobs.JGroupsPeerPeerInfoProviderProviderProvider.log.debug("Connecting bound to {}", address.get()); } else { com.ericsson.gerrit.plugins.highavailability.peers.jgroups.JGroupsPeerPeerInfoProviderProvider.log.warn("Could not bound: {}", address.get()); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clgroupsConfig.clientsConfig.Croups(0), jgroupsConfig.clgroupsConfig.clientsConfig.clientsConfig.CONFIG); com.ericsson.gerrit.plugins.highavailability.peers.Jobs.JGroupsPeerInfoProviderProvider.log.info("Jroups {} for channel {} failed", jgroupsConfig.clazzConfig.clusterName(), jgroupsConfig.clazzConfig.clusterName(), javax.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.peers.Json.Json.JGroupsPeerInfoProviderProviderProvider.log.error("JGroups {} for channel {} failed", jgroupsConfig.getName(), javax.lang.Exception e); } } }
protected void setUseSignedOffBy(com.google.gerrit.extensions.client.InheritableBoolean value) throws java.lang.Exception { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.getProject().setBooleanConfig(Boolean.use_SIGNED_ONLY, value); config.commit(md); projectCache.evict(config.getProject()); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(state.is(BooleanProjectConfig.useSignedOffBy())) { return java.util.Collections.emptyList(); } org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); org.eclipse.jgit.lib.PersonIdent author = commit.getCommitterIdent(); boolean sboAuthor = false; boolean sboCommitter = false; for (org.eclipse.jgit.revwalk.FooterLine footer : commit.getFooterLines()) { if (e!= null) { sboCommitter |= author.getEmailAddress().equals(e); sboMe |= author.hasEmailAddress(e); sboMe |= user.hasEmailAddress(e); } } } if (((!sboAuthor) && (!sboMe)) { try { perm.check(RefPermission.FORGE_COMMITTER); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.server.git.validators.CommitValidationException("Invalid Signed-by author/committer/committer/committer/committer/committer", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.validators.CommitValidators.log.error("Cannot check for commit message footer in commit message footer", e); throw new com.google.gerrit.server.git.validators.CommitValidationException("check for commit message", e); } }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case FORCE_AUTHOR : return canUpdate(); case FORGE : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_CHANGE : return canUpload(); case FORGE_CHANGE : return canUpload(); case FORGE_CHANGE : return canUpload(); case CREATE_BY_SUBMIT : return canUpload(); case UPDATE_BY_SUBMIT : return projectControl.controlForRef(("refs/for/" + (getRefName()))).canSubmit(true); case READ_PRIVATE_CHANGE : return isOwner(); case READ_CONFIG : return isOwner(); case READ_CONFIG : return isOwner(); case READ_CONFIG : return isOwner(); case READ_CONFIG : return (((((canForgeAuthor()) && (canForgeCommitter())) && (canUploadMerge(com.google.gerrit.server.permissions.PermissionBackend.REFS_CONFIG.equals(RefNames.REFS_CONFIG))) && (canUploadMerge())) && (canUploadMerge(projectControl.useSUBMIT_OFFBY_OFFBY_OFFBY)))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@org.junit.Test public void createProjectWithProperties() throws java.lang.Exception { java.lang.String newProjectName = name("newProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = newProjectName; in.description = com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.InheritableBoolean.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects().create(in).get(); assertThat(p.name).isEqualTo(newProjectName); com.google.gerrit.reviewdb.client.Project project = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(newProjectName)).getProject(); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertThat(project.getDescription()).isEqualTo(in.description); assertThat(project.getSubmitType()).isEqualTo(in.submitType); assertThat(project.getBooleanConfig(BooleanProjectConfig.useSignedOffBy()); assertThat(project.getBooleanConfig(BooleanProjectConfig.useSignedOffBy()); assertThat(project.getBooleanConfig(BooleanProjectConfig.useSignedOffBy()); assertThat(project.getBooleanConfig(Boolean.useSignedOffBy()); assertThat(project.getBooleanConfig(Boolean.useSignedOffBy()); assertThat(project.getBoolean(Boolean.useSignedOffBy()); assertThat(project.getBoolean(Boolean.useS
private java.util.Set<java.util.Map.Entry<java.lang.String, com.google.gerrit.server.schema.Schema_PAGE.AccountSetAttribute>> getFields(com.google.gerrit.reviewdb.server.ReviewDb db) throws com.google.gwtorm.server.OrmException { java.sql.Connection connection = schema.getConnection(); java.sql.Connection connection = schema.getConnection().listColumns(connection, com.google.gerrit.server.schema.Schema_PAGES.TABLE); return com.google.gerrit.server.schema.Schema_PAGES.ACCOUNT_FIELDS_MAP.entrySet().stream().filter(( e) -> columns.contains(e.getKey()))).collect(java.util.stream.Collectors.toSet()); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> scanAccounts(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.ProgressMonitor pm) throws java.sql.SQLException { java.util.Set<java.lang.String, com.google.gerrit.server.schema.Schema_PAGES.AccountSetter>> fields = getFields(db); if (fields.isEmpty()) { return java.util.Collections.emptySet(); } java.lang.String query = fields.stream().map((f) -> f.getKey()).collect(java.util.stream.Collectors.joining(account_id, registered_ON, java.lang.String.format("%s FROM account %s", com.google.gerrit.server.schema.Schema_PAGE.TABLE))); try (java.sql.Statement stmt = newStatement(db);java.sql.ResultSet rs = stmt.executeQuery(db);java.util.Set<com.google.gerrit.reviewdb.client.Account> s = new java.util.HashSet<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)), rs.getTimestamp(2)); for (java.util.Map.Entry<java.lang.String, com.google.gerrit.server.schema.Schema_154.AccountSetAttribute> field : fields) { field.getValue().set(a, rs, field.getKey()); } s.add(a); pm.update(a); } return s; }
protected boolean isRest(javax.servlet.ServletRequest req) { return restURI.matcher(getURI(req)).matches(); }
public synchronized boolean inGracePermission() { if (((clause) <= 0) { return (((clause) <= 0) > 0; } return (((clause) && ((lastpermits) > 0)) > 0; }
private final com.googlesource.gerrit.plugins.quota.Module.HolderType createWithBurttategy(com.google.gerrit.reviewdb.client.Account.Id key) throws java.lang.Exception { return createWithUrls(finderConfigType, userFactory.firstMatching(limitConfigType, userFactory.create(limitConfigTypeType, userFactory.create(key))); }
@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.httpd.AllRequestFilter.class).to(com.googlesource.gerrit.plugins.quota.MaxRequestRateEnumerator.class); cache(com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_ACCOUNTID, Account.Id.class, Account.Id.class, Account.Id.class, Account.Id.Id.class); cache(com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_RESTAMP, java.lang.String.class, com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_REMOTEHOST, java.lang.String.class, class).loader(com.googlesource.gerrit.plugins.quota.HttpModule.RestApiLoaderRemoteHost.class); bind(com.google.inject.name.Names.named(RateMsgHelper.class); bindConstant().annotatedWith(com.google.inject.name.Names.named(RateMsgHelper.REVISION_CONFIG), com.google.inject.servlet.Name.named(RateUtil.TAG_CONFIG), com.google.inject.name.Named(RateMsgHelper.class); bindConstant().annotatedWith(com.google.inject.name.Name.name.name.name.name(RateMsgHelper.REVISION_CONFIG), "class not be (com.google.inject.name.Name.name.name.name.name()) { }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if (isRest(req)) { com.googlesource.gerrit.plugins.quota.Module.Mapper.Handler rate = null; com.google.gerrit.server.CurrentUser u = user.get(); com.google.gerrit.server.CurrentUser u = user.get(); com.google.gerrit.server.CurrentUser u = user.get(); com.google.gerrit.reviewdb.client.Account.Id accountId = null; if (u.isIdentifiedUser()) { accountId = u.asIdentifiedUser().getAccountId(); try { accountId = u.asIdentifiedUser().getAccount(); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.text.MessageFormat.format("Cannot get rate for account %s'{}{}'{}'{}'}'}'", accountId); com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnum.log.warn(msg, e); } } else { try { try { try { try { catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.text.MessageFormat.format("Cannot get rate %s", e); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.text.MessageFormat.format("Cannot get rate %s", e); com.googlesource.gerrit.plugins.quota.RestApiRequestRateEnum(msg, e); } } } if (((!(rateLimiter.isGranted())) && (!(rateLimiter.get().get().get().get().get()))) && (!(rateCapacity.get().tryAcquire()))) { java.lang.String msg = java.text.MessageFormat.format(limitExceededMsg, (((rateLimiter.get().getRate()) * (com.googles
private final com.googlesource.gerrit.plugins.quota.Module.Holder createWithBurttategy(com.google.common.base.Optional<com.googlesource.gerrit.plugins.quota.AccountLimitsConfig.Rate> limit) throws java.lang.Exception { if (limit.isPresent()) { return com.googlesource.gerrit.plugins.quota.Module.Holder.createWithBurttifyWithBurttifyWithBurttify(limit); } return com.googlesource.gerrit.plugins.quota.Module.Holder.createWithBurttifyWithBurttifyWithRatator(limit); }
@java.lang.Override public final com.googlesource.gerrit.plugins.quota.Module.Holder load(key) throws java.lang.Exception { if (((kind) == (com.googlesource.gerrit.plugins.quota.Module.AbstractHolderCacheLoader.ANONYMOUS)) && (key instanceof com.google.gerrit.reviewdb.client.Project.NameKey.NameKey.ANONYMOUS)) { return createWithBurttify(kind, com.google.common.base.Strings.Nullable.emptyTo(com.google.gerrit.reviewdb.client.Account.Id) (key))) { return createWithBurttify(com.google.gerrit.reviewdb.client.Account.Id) (key))); } return com.googlesource.gerrit.plugins.quota.Module.Holder.EMPTY; }
public <T> T execute(com.google.gerrit.server.update.Action<T> T> T> action) { return execute(action, defaultValue); }
@java.lang.Override protected boolean retryOn(java.lang.Throwable t) { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } return t.getCause(); }
public <T> T execute(com.google.gerrit.server.update.Action<com.google.gerrit.server.update.Action<com.google.gerrit.server.update.BatchUpdate.Factory, T> action, com.google.gerrit.server.update.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { if (!(migration.disableChangeReviewDb())) { return doExecute(updateFactory, action, com.google.gerrit.server.update.UpdateException.class); } return doExecute(updateFactory, action, opts); } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.update.UpdateException.class); throw new com.google.gerrit.server.update.UpdateException(t); } }
private com.google.gerrit.server.account.ExternalIdsUpdate.RefsUpdate updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdate updateNoteMap) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return retryHelper.execute(updateRepository(allUsersName); }
public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> recursiveChildProjects(com.google.gerrit.reviewdb.client.Project.NameKey parent) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project.NameKey> children = parentToChildren(project); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project.NameKey> children = parentToChildren(project); java.util.List<com.google.gerrit.extensions.common.ProjectInfo> results = new java.util.ArrayList<>(); depthFirstFormat(results, perm, projects, children, parent); return results; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return childProjectLists.recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, notesFactory, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, submitDryRun, submitDryRun, conflictsCache, conflictsCache, conflictsCache, conflictsCache, conflictsCache, index, indexConfig, indexConfig, indexConfig, indexConfig, starredChangesUtil, accountCache, allowsDrafts, allowsDrafts, allowsDrafts, notesMigration); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.index.Predicate<com.google.gerrit.server.query.change.ChangeData> parentproject(java.lang.String name) { return new com.google.gerrit.server.query.change.ParentProjectPredicate(args.projectCache, args.childProjectLINK, args.self, name); }
public boolean isReachableFrom(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { refs = refFilter.create(state, repo).filter(refs, true); return com.google.gerrit.server.change.IncludedInResolver.includedInAny(repo, rw, commit, refs.values()); } catch (java.io.IOException e) { com.google.gerrit.server.project.Unable.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getNameKey()), e); return false; } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = state.get().encodeVisibility(true).byProjectCommit(true).byProjectCommit(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot lookup change for commit " + (commit.name())) + " in ") + project), e); return true; } return result; }
boolean isReachableFromHeadsOrTags(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.RefDatabase refdb = repo.getRefDatabase(); java.util.Collection<org.eclipse.jgit.lib.Ref> heads = refdb.getRefs(Constants.R_HEADS).values(); java.util.Collection<org.eclipse.jgit.lib.Ref> tags = refdb.getRefs(Constants.R_TAGS).values(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Maps.newHashMapWithExpectedSize(((heads.size()) + (tags.size()))); for (org.eclipse.jgit.lib.Ref r : com.google.common.collect.Iterables.concat(heads, tags)) { refs.put(r.getName(), r); } return result; } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s in repository %s", commit.name(), getProject().getNameKey()), e); return false; } }
protected static java.util.List<com.google.gerrit.server.index.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.gerrit.server.project.ChildProjectLists childProjectLender, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.project.ProjectResource(projectState, self.get()); for (com.google.gerrit.extensions.common.ProjectInfo p : childProjectLists) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn("Cannot check permissions to expand child projects", e); } return r; }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.sql.Timestamp when, boolean isPrivate) { if (!(listeners.iterator().hasNext())) { return; } try { com.google.gerrit.server.extensions.events.PrivateStateChanged.Event event = new com.google.gerrit.server.extensions.events.PrivateState(util.changeInfo(change), util.accountInfo(account), isPrivate, when); for (com.google.gerrit.extensions.events.PrivateState l : listeners) { try { l.onPrivateState(((account), isPrivate, when); } catch (java.lang.Exception e) { com.google.gerrit.server.extensions.events.PrivateStateChanged.log.error("Couldn't fire event", e); } } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.extensions.events.PrivateStateChanged.log.error("Couldn't fire event", e); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { com.google.gerrit.server.update.ChangeUpdate.loggerrit.warn(ctx.getUser(), ctx.getWhen()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canDeletePrivate(rsrc.getChange().isPrivate())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to unmark private"); } if (!(rsrc.getChange().isPrivate())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not allowed to unmark private"); } com.google.gerrit.server.change.SetPrivateOp op = setPrivateOpFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.data.ChangeAttribute asChangeAttribute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.data.ChangeAttribute a = new com.google.gerrit.server.data.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.topic = change.getTopic(); a.id = change.getKey().get(); a.subject = change.getKey().get(); a.subject = change.getSubject(); try { a.commitMessage = changeDataFactory.create(db, change).commitMessage(); } catch (java.lang.Exception e) { com.google.gerrit.server.events.EventFactory.log.error(("Failed to full commit message for change " + (a.number))); } a.url = getChangeUrl(change.getOwner()); a.owner = asAccountAttribute(change.getOwner()); a.status = change.getStatus(); a.createdOn = (change.getCreatedOn().getTime()) / 1000L; a.isWorkInProgress = (change.isWorkInProgress())? true : null; a.isPrivate = (change.isWorkInProgress())? true : null; a.isPrivate = (change.isWorkInProgress())? true : null; a.isPrivate = (change.isWorkInProgress())? true : null; return a; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canSetPrivate(rsrc.isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to mark private"); } if (rsrc.getChange().isPrivate()) { return com.google.gerrit.extensions.restapi.Response.ok(""); } com.google.gerrit.server.change.SetPrivateOp op = setPrivateOpFactory.create(cmUtil, true, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElse(MethodNotAllowedException.new); if (recursive) { return groupMembers.getTransformer(group, resource.getControl()); } return groupMembers.get(group, resource.getControl()); }
private void addInternalDetails(com.google.gerrit.extensions.common.GroupInfo info, com.google.gerrit.common.data.GroupDescription.Internal internalGroup, java.util.Function<com.google.gerrit.server.account.GroupControl> groupControlSupplier) throws com.google.gwtorm.server.OrmException { info.description = com.google.common.base.Strings.emptyToNull(internalGroup.getDescription()); info.groupId = internalGroup.getId().get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerGroupUUID = internalGroup.getOwnerGroupUUID(); if (ownerGroupUUID!= null) { info.ownerId = com.google.gerrit.extensions.restapi.Url.encode(ownerGroupUUID.get()); com.google.gerrit.common.data.GroupDescription.Basic o = groupBackend.get(ownerGroupUUID); if (o!= null) { info.ownerId = o.getName(); } } info.createdOn = internalGroup.getCreatedOn(); if (options.contains(com.google.gerrit.server.group.MERS)) { info.members = groupMembers.get().getDirectMembers(internalGroup, groupControlSupplier.get()); } if (options.contains(com.google.gerrit.server.group.INCLUDES)) { info.includes = listSubgroups.get().getDirections(internalGroup, groupControlSupplier.get()); } }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, notesFactory, notesFactory, accountResolver, notesFactory, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, submitDryRun, conflictsCache, conflictsCache, conflictsCache, conflictsCache, conflictsCache, conflictsCache, conflictsCache, conflicts); }
void display(java.io.PrintWriter writer) throws com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(name)); java.lang.String errorText = errorText.get(errorText); if (!(group.isPresent())) { writer.write(errorText); writer.flush(); return; } java.util.List<com.google.gerrit.extensions.common.AccountInfo> members = groupMembers.getDirectMembers(group.get()); com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(writer, '\t'); formatter.addColumn("id"); formatter.addColumn("id"); formatter.addColumn("username"); formatter.addColumn("email"); formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.nextLine(); for (com.google.gerrit.extensions.common.AccountInfo member : members) { if (member == null) { continue; } formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member, "n/accountId)); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member, "n/a")); formatter.nextLine(); } formatter.finish(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.api.allowedIdentifiers", values = { "PROJECT_NUMERIC_ID", "NUMERIC_ID"); public void revisionChangeIdReturnsBadRequest() throws java.lang.Exception { com.google.gerrit.extensions.api.changes.ChangeApi cApi cApi1 = gApi.changes().id(project.get(), changeInfo._number); assertThat(cApi1.get().changeId).isEqualTo(changeInfo.changeId); com.google.gerrit.extensions.api.changes.ChangeApi cApi2 = gApi.changes().id(changeInfo._number); assertThat(cApi2.get().changeId).isEqualTo(changeInfo.changeId); com.google.gerrit.extensions.common.ChangeInfo ci = gApi.changes().create(new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "different message")).get(); exception.expect(com.google.gerrit.extensions.restapi.RestApiException.class); exception.expectMessage((("The following change number " + (ci.changeNumber)) + " is not permitted.")); gApi.changes().id(ci.changeId); }
private void checkIdType(com.google.gerrit.server.ChangeFluentIterable<com.google.gerrit.server.change.Finder.ChangeIdType> type, boolean enforceDeprecation, java.lang.String val) throws com.google.gerrit.extensions.restapi.UnsupportedOperationException { if (enforceDeprecation && (!(allowIdTypes.contains(type))) { throw new com.google.gerrit.extensions.restapi.UnsupportedOperationException(java.lang.String.format(("The following change ID %s is not permitted." + "Use '\" does not use 'use '")), val)); } changeIdCounter.increment(type); }
public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { try { return find(id, false); } catch (com.google.gerrit.server.notedb.ChangeNotesException e) { return com.google.common.collect.ImmutableList.of(); } }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Star parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.parse(TopLevelResource.INSTANCE, id); java.util.Set<java.lang.String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId()); java.util.Set<java.lang.String> labels = starredChangesUtil.getLabels(user.getAccountId(), change.getId()); return new com.google.gerrit.server.account.AccountResource.Star(user, change, labels); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(TopLevelResource.INSTANCE, id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("%s not found", id)); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error("Cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot resolve change", e); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("not allowed for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
@java.lang.Override public AccountResource.StarredChange parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.parse(TopLevelResource.INSTANCE, id); if (starredChangesUtil.getLabels(user.getAccountId(), change.getId()).contains(StarredChangesUtil.DEFAULT_LABEL)) { return new com.google.gerrit.server.account.AccountResource.StarredChange(user, change); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void delete(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalIdNotes.remove(rw, noteMap, extId); removedExtIds.add(extId); } }); cacheUpdates.add(( o) -> removedExtIds) -> { externalIdCache.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); } }
private void addExtId(org.eclipse.jgit.junit.TestRepository<?> testRepo, com.google.gerrit.server.account.externalids.ExternalId... extIds) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.externalids.ExternalIdNotes extId = externalIdNotesFactory.load(testRepo.getRepository()); extIdNotes.insert(java.util.Arrays.asList(extIds)); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, null, testRepo.getRepository())) { extIdUpdate.insert(admin.getIdent()); } catch (com.google.gerrit.server.git.MetaDataUpdateException e) { com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, null, e); extIdNotes.commit(admin.getIdent()); extIdNotes.commit(admin.getIdent()); extIdNotes.commit(metaDataUpdate); } }
@org.junit.Test public void retryOnLockFailure() throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId.Key fooId = ExternalId.create("foo", "foo"); com.google.gerrit.server.account.externalids.ExternalId.Key barId = ExternalId.create("foo", "foo"); final java.util.concurrent.atomic.AtomicBoolean doneBatchBoolean doneBgUpdate = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.server.account.externalids.ExternalIdsUpdate update = new com.google.gerrit.server.account.externalids.ExternalIdsUpdate(repoManager, (com.google.gerrit.acceptance.rest.account.external.metaDataUpdateFactory.create(com.google.gerrit.acceptance.rest.account.externalids.allUsers), accountCache, allUsers, externalIds, externalIds, new com.google.gerrit.server.update.DisabledExternalIdCache(), new com.google.gerrit.server.update.DisabledExternalIdCache(), new com.google.gerrit.server.update.DisabledHelper(cfg, retryMetrics, null, null, null, (r) -> r.withBlockStrategy(new com.google.gerrit.server.account.externalids.DisabledExternalIdCacheImpl() { @java.lang.Override public void block(long time) { try { if (!(doneBgUpdate.get())) { try { extIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.create(barId, admin.id)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException | com.google.gwtorm.server.OrmException e) { } } } }); assertThat(doneBgwtorm.server.OrmException | com.google.gerrit.server.account.ExternalId.create(fooId, admin.id)); update.setCreatedOnFailure(java.lang.String.format("%s does not found: %s", id, new com.google.gerrit.server.account
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.ExternalIdNotes.loadReadOnly(repo).get(key); } }
private void updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdater) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { retryHelper.remove(updateRepository, (i) -> { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.externalids.ExternalIdNotes extId = new com.google.gerrit.server.account.externalids.ExternalIdKeys(externalIdCache, accountCache, repo).setAfterReadRevision(afterReadRevision).load(); i.update(extIdNotes); try (com.google.gerrit.server.git.MetaDataUpdate mdUpdate = metaDataUpdateFactory.create()) { extIdNotes.commit(metaDataUpdate); } updateCount.increment(); return null; } }); }
public void upsert(com.google.gerrit.server.account.externalids.ExternalId extId) throws com.google.gwtorm.server.OrmException { upsert(java.util.Collections.singleton(extId)); }
public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all() throws java.io.IOException { checkLoaded(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = com.google.gerrit.server.account.externalids.ExternalId.readNoteData(rw, note.getData()); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw, note.getData())); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIdNotes.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteId = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalId.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); checkState(extId.equals(actualExtId), "external id %s should be removed the actual external id %s", extId.toString(), actualExtId.toString()); noteMap.remove(noteId); return actualExtId; }
public void delete(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId.Key> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalId.remove(rw, noteMap, extId); removedExtIds.add(removedExtId); } }); cacheUpdates.add(o, n, removedExtIds); }
public void replace(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkLoaded(); com.google.gerrit.server.account.externalids.ExternalIdNotes.checkSameAccount(toAdd, accountId); checkExternalIdKeysDynExists(ExternalId.Key.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw) -> { for (com.google.gerrit.server.account.externalids.ExternalId extIdKey : toDelete) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalId.remove(rw, noteMap, extId); removedExtIds.add(removedExtId); removedExtIds.add(removedExtId); } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { com.google.gerrit.server.account.externalids.ExternalIdUpdatedExtId = com.google.gerrit.server.account.externalids.ExternalIdKeys.upsert(rw, inserter, extId); updatedExtIds.add(o, n, removedExtId); } }); cacheUpdates.add(accountId); cacheUpdates.onReplace(o, n, removedExtId); }
public void deleteByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(((rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { removeExtIds.add(( o) -> { removedExtIds.add(extId); removedExtIds.add(extId); } }); cacheUpdates.add(o, n, removedExtIds); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (readOnly) { throw new java.io.IOException("Updating external IDs is disabled"); } if (noteMapUpdates.isEmpty()) { return false; } if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Update external IDs\n"); } if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Update external IDs\n"); } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { for (com.google.gerrit.server.account.externalids.ExternalIdNotes.Key noteMap : noteMapUpdates) { try { noteMap.execute(rw, noteMap); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new java.io.IOException(e); } } org.eclipse.jgit.revwalk.RevTree oldTree = ((revision)!= null)? rw.parseTree(revision) : null; org.eclipse.jgit.lib.ObjectId newTreeId = noteMap.writeTree(inserter); if (newTreeId.equals(oldTree)) { return false; } commit.setTreeId(newTreeId); return true; } }
private void evictAccounts(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws java.io.IOException { if ((accountCache)!= null) { for (com.google.gerrit.reviewdb.client.Account.Id id : extIds.key().map(((((accountId) -> accountId).collect(java.util.stream.Collectors.toSet()))); } }
private static com.google.gerrit.server.account.externalids.ExternalId upsert(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.lib.ObjectInserter ins, com.google.gerrit.server.account.externalids.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); org.eclipse.jgit.lib.Config c = new org.eclipse.jgit.lib.Config(); if (noteMap.contains(noteMap.get(noteId), com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); try { c.fromText(new java.lang.String(raw, java.nio.charset.StandardCharsets.UTF_8)); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Invalid external id %s for note %s: %s: %s", noteId, e.getMessage())); } } extId.writeToConfig(c); byte[] raw = c.toText().getBytes(java.nio.charset.StandardCharsets.UTF_8); org.eclipse.jgit.lib.ObjectId noteData = ins.insert(com.google.gerrit.server.account.externalids.ExternalId.OBJ_BLOB, raw); noteMap.set(noteMap); return com.google.gerrit.server.account.externalids.ExternalId.create(extId, noteData); }
public void updateExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { updateExternalIds().add(extId); }
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.ExternalIdNotes.loadReadOnly(repo, rev).get(key); } }
public void upsert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(((rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalId updatedExtId = com.google.gerrit.server.account.externalids.ExternalIdUpdatedOn(rw, inserter, noteMap, extId); updatedExtIds.add(updatedExtId); } }); cacheUpdates.on(o, n, updatedExtIds); cacheUpdates(o, n, updatedExtIds); }
public void insert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkLoaded(); checkLoaded(); checkLoaded(); checkExternalIds().add(((( o) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) -> { com.google.gerrit.server.account.externalids.ExternalId insertExtId = com.google.gerrit.server.account.externalids.ExternalId.upsert(key); newExtIds.add(insertExtId); newExtIds.add(insertExtId); newExtIdCache.onCreate(o, n, extIds); } }); cacheUpdates.add(o, n, n, newExtIds); }
public void replaceByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException { checkExternalIdKeysDynExists(ExternalId.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMapUpdates.add(( rw, n) -> { for (com.google.gerrit.server.account.externalids.ExternalId extIdKey : toDelete) { com.google.gerrit.server.account.externalids.ExternalId removedExtId = com.google.gerrit.server.account.externalids.ExternalId.remove(rw, inserter, extIdKey, extId); removedExtIds.add(removedExtId); updatedExtIds.add(insertExtId); } }); cacheUpdates.add(( o) -> removedExtIds(insertExtIds.stream().stream()).collect(java.util.stream.Collectors.stream.Collectors.toSet())); }
public void addExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { createdExternalIdsBuilder().add(extId); }
public void deleteExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { deletedExternalIdsBuilder().add(extId); }
@com.google.gerrit.common.Nullable public com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.externalids.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = com.google.gerrit.server.account.externalids.ExternalId.readNoteData(rw, noteDataId); return com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, note, noteDataId); } }
public static java.util.Set<com.google.gerrit.server.account.externalids.ExternalId.Key> from(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { return extIds.key().map(java.util.stream.Collectors.toSet()); }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteId = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalId.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); if (expectedAccountId!= null) { checkState(expectedAccountId.equals(extId.accountId()), expectedAccountIdKey.get(), extIdKey.get(), extId.get(), extId.get()); } noteMap.remove(noteId); return extId; }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.api.account.StatusInput input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.api.account.StatusInput(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), (u.update().update().setStatus(com.google.common.base.Strings.nullToEmpty(newStatus))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()); }
public static com.google.gerrit.server.account.InternalAccountUpdate.Builder builder() { return new com.google.gerrit.server.account.AutoValue_InternalAccountUpdate.Builder(); }
private void updateAccountInfo() { if ((setFullNameTo) == null) { return; } logDebug("Not empty full name of caller"); try { com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), user.getFullName()); if (com.google.common.base.Strings.isNullOrEmpty(u.account().getFullName())) { u.update().setFullName(setFullNameTo); } }); if (account!= null) { user.getAccount().setFullName(account.getFullName()); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { logWarn("Failed to update full name of caller of caller of caller of caller of caller of caller", e); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException((("Id: " + (extId.key().get())) + " in use by another account")); } update(who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress())!= null) { accountsUpdateFactory.create().update(to, (u.account().getEmail()) == null); } } else { externalIdsUpdateFactory.create().update(to, (u.account().getEmail()) == null? u.getEmailAddress() : null; } } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public void unlink(com.google.gerrit.reviewdb.client.Account.Id from, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (extIdKeys.isEmpty()) { return; } java.util.List<com.google.gerrit.server.account.externalids.ExternalId.Key> extIds = new java.util.ArrayList(extIdKeys.size()); for (com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(extIdKey); if (extId!= null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("account " + (extIdKey.get())) + " in use by another account")); } extIds.add(extId); } extIdsUpdateFactory.create().delete(extId); if (extIds.stream().anyMatch(( e) -> e.email())!= null)) { accountsUpdateFactory.create().update(from, (u.account().email()).toString(extId.email())); for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if ((u.account().getPreferredEmail())!= null) { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if (u.account().equals(extId.email()) { u.update(u); } } } } }
public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, (u.isActive()) { if (!(accountId.isActive())) { alreadyInactive.set(true); } else { u.update().setActive(false); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("not found"); } if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("account not active"); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyActive = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, (u) -> { if (u.account().isActive()) { alreadyActive.set(true); } else { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(""); } return alreadyActive.get(); }
@org.junit.Before public void setUpInjector() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = com.google.gerrit.test.InMemoryModule.newDefaultConfig(); cfg.setInt("receive", null, "maxTrustDepth", 2); cfg.setStringList("receive", null, "trustedKey", com.google.common.collect.ImmutableList.of(com.google.gerrit.gpg.Fingerprint.toString(keyB().getPublicKey().getFingerprint()), com.google.gerrit.gpg.Fingerprint.toString(keyD().getPublicKey().getFingerprint())); com.google.inject.Injector injector = com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(in); lifecycle.injectMembers(this); lifecycle.start(); db = schemaFactory.open(); schemaCreator.create(db); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); accountsUpdate.create().update(userId, (u) -> u.update().setPreferredEmail("user@example.com")); user = reloadUser(); requestContext.setContext(userId, (u) -> u.update().setPreferredEmail("user@example.com")); user = reloadUser(); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getReviewDbProvider() { return user; } @java.lang.Override public com.google.gerrit.server.CurrentUser getReviewDbProvider() { return user; } @java.lang.Override public com.google.gerrit.server.CurrentUser getReviewDbProvider() { return getReviewDbProvider(); } }); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyPreferred = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), user.getAccountId()); com.google.gerrit.reviewdb.client.Account accountId = accountsUpdate.create().update(user); if (email!= null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } else { u.update().setPreferredEmail(email); } }); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(""); } return alreadyPreferred.get()? com.google.gerrit.extensions.restapi.Response.created(""); }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.ExternalId.forUser("user")).getAccountId(); java.lang.String email = "user@example.com"; externalIdsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createEmail(userId, email)); accountsUpdate.create().update(userId, (u) -> u.update().setPreferredEmail(email)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userId)); }
@org.junit.Test public void pushAccountConfigToUserBranchInvalidPreferredEmail() throws java.lang.Exception { TestAccount = accountCreator.create(name("foo"), ((name("foo") + "foo") + "@example.com"), "Foo"); java.lang.String userRef = com.google.gerrit.reviewdb.client.RefNames.refsUsers(foo.id); java.lang.String noEmail = "no email"; accountsUpdate.create().update(foo.id, (u) -> u.update().updateUserName(noEmail)); accountIndexedCounter.clear(); grant(allUsers, userRef, Permission.PUSH, false, com.google.gerrit.acceptance.api.account.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers, foo); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRefName))); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (userRefName))); com.google.gerrit.acceptance.GitUtil.fetch(allUsersRepo, (AccountConfig.ACCOUNT_USERS))); java.lang.String status = "user refRef"; java.lang.String status = "user refs/user ref %s/user %s", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).to(userRef).toString()).to(user.email); pushFactory.create(db, foo.getIdent(), allUsersRepo, allUsersRepo, AccountConfig.ACCOUNT_CONFIG, ac.name).to(user.fullName); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.id.id.get()).get(); assertThat(info.name).isEqualTo(foo.fullName); assertThat(info.name).isEqualTo(foo.name); assertThat(info.name).isEqualTo(foo.name);
@org.junit.Test public void updateAccountWithoutAccountConfigNoteDb() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount anonymousCoward = accountCreator.create(); assertUserBranchWithoutAccountConfig(anonymousCoward.getId()); java.lang.String status = "OOO"; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(anonymousCoward.getId(), (u) -> updateUserName(user)); assertThat(account).isNotNull(); assertThat(account.getFullName()).isNull(); assertThat(account.getFullName()).isNull(); assertThat(account.getStatus()).isEqualTo(status); assertThat(account.getStatus()).isEqualTo(status); }
@org.junit.Test public void lookupUpByPreferences() throws java.lang.Exception { java.lang.String prefix = "foo.preferred"; java.lang.String prefEmail = prefix.pre"; com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); accountsUpdate.create().update(foo.id, u.update().setPreferredEmail(prefsEmail)); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> accountsByPrefix = emails.get(prefsByPrefix); assertThat(accounts).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(accountsByPrefix).isEqualTo(foo.id); accountsByPrefix = emails.get(prefix); assertThat(accounts.getAccountFor(prefix).isEqualTo(foo.id); accountsByPrefix = emails.get(Prefix); assertThat(accountByPrefix).isEmpty(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.common.NameInput input) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.common.NameKey(); } if (!(realm.allowsEdit(AccountFieldName.FULL_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing name"); } java.lang.String newName = input.name; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), (u) -> u.update().setFullName(com.google.common.base.Strings.nullToEmpty(newName))); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("not found"); } return com.google.gerrit.server.project.GetUser; }
public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.stream.Function<com.google.gerrit.server.account.AccountUpdate> event) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return update(accountId, com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableList.of(com.google.gerrit.server.account.Account.SCHANGE_NAME), com.google.common.collect.ImmutableList.of(com.google.common.collect.ImmutableSet.of(com.google.common.collect.ImmutableSet.of(com.google.common.collect.ImmutableSet.of(com.google.gerrit.server.account.Account.SCHANGE_ALL)); }
@com.google.gerrit.common.Nullable public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.List<com.google.gerrit.server.account.AccountUpdate>>ConsistConsistConsistency) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (consume.isEmpty()) { return null; } com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); java.util.Optional<com.google.gerrit.reviewdb.client.Account> account = com.google.gerrit.server.account.AccountUpdate.create(account.get()); if (account.isPresent()) { com.google.gerrit.server.account.AccountUpdate accountUpdate = com.google.gerrit.server.account.AccountUpdate.create(account.get()); if (account.isPresent()) { com.google.gerrit.server.account.AccountUpdate accountUpdate.create(accountUpdate.get()); } return accountConfig.getLoadedAccount().orElse(null); }
public com.google.gerrit.reviewdb.client.Account insert(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.concurrent.Callable<com.google.gerrit.server.account.AccountUpdate> init) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountConfig account = read(accountId); com.google.gerrit.server.account.AccountUpdate account = accountCache.create(accountId); com.google.gerrit.server.account.AccountUpdate accountUpdate = accountUpdate.create(account); init.setAccountUpdate(accountUpdate); commitNew(accountUpdate.buildUpdate()); return accountConfig.getLoadedAccount().get(); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); if ((revision)!= null) { commit.setMessage("notify account"); } else { commit.setMessage("message"); } else { commit.setMessage("message"); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); if (accountUpdate.isPresent()) { com.google.gerrit.server.account.AccountConfig.writeToConfig(accountUpdate.get(), cfg); } saveConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); loadConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); loadConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); loadConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG, cfg); return true; }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.loadAccount = java.util.Optional.of(account); this.accountUpdate = java.util.Optional.of(account); this.accountUpdate = java.util.Optional.of(account); this.accountUpdate = java.util.Optional.of(account); this.accountUpdate = account.getRegisteredOn(); if (account!= null) { setStatus(com.google.common.base.Strings.nullToEmpty(account.getPreferredEmail()).isEmpty(account.getPreferredEmail()).build()); } if ((account!= null) && (!(account.isEmpty()))) { setStatus(com.google.common.base.Strings.nullToEmpty(account.getStatus()).isEmpty(account.getPreferredEmail()).build()); } }
private Account.Id createAccountExternalRequestContext(java.lang.String username, java.lang.String fullName, java.lang.String email, java.lang.String email, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email!= null) { accountManager.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); }
@org.junit.Test public void checkMetaId() throws java.lang.Exception { assertThat(accounts.get(admin.getId()).getMetaId()).isEqualTo(getMetaId()); com.google.gerrit.server.account.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(seq.getId()); com.google.gerrit.reviewdb.client.Account account = accountId.create(); com.google.gerrit.reviewdb.client.Account account = accountId.create(); com.google.gerrit.reviewdb.client.Account account = accountId.insert(accountId, (u) -> { assertThat(account.getMetaId()).isEqualTo(getMetaId(accountId)); com.google.gerrit.reviewdb.client.Account updatedAccount = accountId(accountId, (u) -> { assertThat(account.getMetaId()).isNotEqualTo(updatedAccount.getMetaId()); assertThat(updatedAccount.getMetaId()).isNotEqualTo(getMetaId(accountId)); } }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "fatal: FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); java.lang.System.exit(1); return; } if ((revnumberFile)!= null) { try (java.io.BufferedReader reader = java.nio.file.Files.newBufferedReader(revnumberFile.toPath())) { revnumber = reader.readLine(); } } if (mock) { tmpdir = java.nio.file.Files.createTempDirectory("asciidoctor-").toFile(); } if (bazel) { try (java.io.file.ZipOutputStream zip = new java.nio.file.Files.createTempOutputStream(java.nio.file.Paths.newOutputStream(java.nio.file.Paths.get(zipFile))) { revdir = reader.readLine(); } catch (java.io.File csshd) { AsciiDoctor.zipFile(new java.io.File(java.nio.file.Files.newOutputStream(java.nio.file.Paths.getPath()))) { renderFiles(inputFiles, zip); java.io.File[] cssFiles = tmpdir.listFiles(new java.io.File(tmpFileDir, zip.getName(), zip); for (java.io.File css : cssFiles) { AsciiDoctor.zipFile(css.getName(), zip); } } } } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.update.LockFailureHandler<T> retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.LockFailure, (t) -> t instanceof com.google.gerrit.server.git.LockFailureException, com.google.gerrit.server.git.LockFailureException.log.error(java.lang.String.class) { try { return retryerBuilder.build().call(action.call()); } catch (java.util.concurrent.ExecutionException e) { java.lang.Throwable t = e; if ((e.getCause())!= null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfInstanceOf(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.lib.ConfigInvalidException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private <T> T execute(com.google.gerrit.server.update.RetryHelper.ChangeAction<T> changeAction, com.google.gerrit.server.update.Retryer.ChangeAction<T> changeAction, com.google.gerrit.server.update.Retryer.ChangeAction<T> retryer) throws java.lang.Throwable { try { return retryer.call(() -> changeAction.call(updateFactory); } catch (java.util.concurrent.ExecutionException | com.google.gerrit.server.update.RetryException e) { if (e instanceof com.google.gerrit.server.rholder.Retry.RetryException) { metrics.increment(); } if ((e instanceof com.google.gerrit.server.rholder.Retry.RetryException) { metrics.timeoutCount.increment(); } if ((e instanceof com.google.gerrit.server.rholder.RetryException) { metrics.timeoutCount.increment(); } throw e; } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.update.Retryer.RetryerBuilder<T> retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.RetryHelper.defaults(), exceptionPredicate); try { return retryerBuilder.build().call(() -> action.call()); } catch (java.util.concurrent.ExecutionException | com.google.gwtorm.server.OrmException e) { java.lang.Throwable t = e; if ((e.getCause())!= null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); throw new com.google.gwtorm.server.OrmException(t); } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.ChangeAction<T> changeAction, com.google.gerrit.server.update.UpdateAction<T> changeAction, com.google.gerrit.server.update.UpdateException { try { if (!(migration.disableChangeReviewDb())) { return execute(changeAction, com.google.gerrit.server.update.Update.UpdateException.class); } com.google.gerrit.server.update.UpdateManager.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.LockHelper.MetricListener(); try { com.google.gerrit.server.update.LockHelper.MetricListener listener = new com.google.gerrit.server.update.LockHelper.MetricListener(); try { com.google.gerrit.server.update.LockHelper.MetricListener listener = createRetryerBuilder(opts, (t) -> { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); return execute(changeAction, retryerBuilder.build()); } finally { metrics.attemptCounts.record(listener.getRetries()); } } } catch (java.lang.Throwable t) { com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.update.UpdateException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.update.UpdateException.class); throw new com.google.gerrit.server.update.UpdateException(t); } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.Action<T> action) { return execute(com.google.gerrit.server.update.LockFailure.Action<T> action, com.google.gerrit.server.git.LockFailure.log.warn("Cannot delete this change %s", action.getName(), com.google.gerrit.server.git.LockFailure.concurrent.ExecutionException.ExecutionException.onFailureException { try { return execute(t).isNull(); } catch (java.io.IOException e) { com.google.gerrit.server.git.LockFailure.log.error("Cannot lock failed to delete " + (t.getMessage()))); } }
private void recursivelyExpandGroups(final java.util.Set<java.lang.String> groupDNs, final com.google.gerrit.server.auth.ldap.Helper.LdapSchemaSchema schema, final javax.naming.directory.DirContext ctx, final javax.naming.directory.DirContext ctx, final java.lang.String groupDN) { if (((groupDNs.add(groupDN)) && ((schema.accountMemberField)!= null)) && (schema.accountMemberExpandGroups)) { com.google.common.collect.ImmutableSet<java.lang.String> cachedGroupName = parentGroups.getIfPresent(groupDN); if (cachedParentsDNs == null) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> dns = com.google.common.collect.ImmutableSet.builder(); try { final javax.naming.directory.Attribute compositeGroupName = new javax.naming.common.collect.ImmutableSet.builder(); try { final javax.naming.directory.Attribute compositeGroupName = new javax.naming.Naming.builder(); try { final javax.naming.directory.Attribute compositeGroupName = new javax.naming.naming.directory.CompileName().add(groupDN); final jns.add(((java.lang.String) (groups.next()))); } catch (javax.naming.Naming.NamingException e) { } } catch (javax.naming.Naming.NamingException e) { } } } catch (javax.naming.NamingException e) { com.google.common.base.Joiner.log.warn(("Cannot not find account " + groupDN), e); } for (java.lang.String dn : cachedParentsDNs) { recursivelyExpandGroups(groupDNs, cn); } }
com.google.gerrit.server.api.changes.FileApiImpl create(com.google.gerrit.server.change.FileResource r);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.Subgroup.SubgroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc.getMemberDescription()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.VoteResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.VoteResource parse(com.google.gerrit.server.change.ReviewerResource reviewer, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((reviewer.getRevisionResource())!= null) && (!(reviewer.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("not access on non-current patch set"); } return new com.google.gerrit.server.change.VoteResource(reviewer, id.get()); }
@java.lang.Override public GroupDescription.Basic get(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { if (!(handles(uuid))) { return null; } java.lang.String groupDn = uuid.get().substring(com.google.gerrit.server.auth.ldap.Ldap.LDAP_UUID.length()); com.google.gerrit.server.CurrentUser user = userProvider.get(); if (!(user.isIdentifiedUser())) { return null; } java.lang.String name = uuid.get().substring(user.asIdentifiedUser()).contains(uuid); if (!(membershipsOf(uuid))) { return null; } } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.auth.ldap.LdapGroupBackend.log.warn(java.lang.String.format("Cannot lookup account %s in LDAP user %s", e); return null; } } final java.lang.String name = (com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME) + (com.google.gerrit.server.auth.ldap.LdapGroupBackend.CnFor(groupDn)); return uuid; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.AccountResource resource, com.google.gerrit.extensions.common.AccountInfo info) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { com.google.gerrit.server.permissions.PermissionBackendException in = new com.google.gerrit.server.permissions.PermissionBackendException(); in.commitMessage = (input!= null)? input.commitMessage : null; return defaultSetter.get().apply(resource, in); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@org.junit.Test public void updateGroupNamesWithEmptyCollectionLeastCollectionLeastAllNotes() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = com.google.gerrit.server.group.Test.Test.newName(repo)).containsExactly("a", "a-1", "a-1", "b-2"); updateGroupNames(ident); assertThat(com.google.gerrit.server.group.TestUtil.readNameToUuidMap(repo)).isEmpty(); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(2); assertThat(com.google.gerrit.server.group.TestUtil.readNameToUuidMap(repo)).isEmpty(); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(); assertThat(log).hasSize(2); assertThat(log.get(1)).message().isEqualTo("Account names"); }
@org.junit.Test public void emptyGroupName() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g = newGroup(""); updateGroupNames(com.google.gerrit.server.group.GroupNameKey.newPersonIdent(), g); assertThat(com.google.gerrit.server.group.TestUtil.readNameToUuidMap(repo)).containsExactly("", "-1"); assertThat(readNameNote(g)).isEqualTo("=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=-1=20=20=0]; }
@org.junit.Test public void updateGroupNames() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.common.data.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = logDebug("b"); assertThat(log).parents().isEmpty(); assertThat(log.get(0)).parents().isEmpty(); assertThat(log.get(0)).parents().isEmpty(); assertThat(log.get(0)).isEmpty(); assertThat(log.get(0)).author().isEqualTo("a", "a-1 account names"); assertThat(com.google.gerrit.server.group.TestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b-1"); java.lang.String commit = log.get(0).commit; updateGroupNames(com.google.gerrit.server.group.TestUtil.newNameToUuidMap(repo)).containsExactly("a", "a-1", "b-2"); java.lang.String commit = log.get(0).commit; updateGroupNames(com.google.gerrit.server.group.TestUtil.newNameKey(), g1, g2); log = logDebug("cannot update group"); updateGroupNames(com.google.gerrit.server.group.TestUtil.newName(db.get().getPersonIdent(), g1, g2, "a-1", "b-2"); assertThat(log.get(0)).commit().isEqualTo(commit); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.MemberResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddMembers.PutMember create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.group.AddMembers.PutMembers.PutMember(put, id.get()); }
@java.lang.Override public com.google.gerrit.server.group.MemberResource parse(com.google.gerrit.server.group.GroupResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal group = parent.asInternalGroup().orElseThrow(MethodNotAllowedException::new); com.google.gerrit.server.IdentifiedUser user = accounts.parse(TopLevelResource.INSTANCE, id).getUser(); if ((parent.getControl().canSeeMember(user.getAccountId())) && (com.google.gerrit.server.group.MembersCollection.isMember(group.getAccountId()))) { return new com.google.gerrit.server.group.MemberResource(parent, user); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { return list.get(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FixResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.FixResource parse(com.google.gerrit.server.change.RevisionResource revisionResource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String fixId = id.get(); com.google.gerrit.server.notedb.ChangeNotes changeNotes = revisionResource.getNotes(); java.util.List<com.google.gerrit.reviewdb.client.RobotComment> robotComments = com.google.common.collect.Lists.newArrayListWithCapacity(changeNotes, revisionResource.getPatchSet().getId()); for (com.google.gerrit.reviewdb.client.RobotComment robotComment : robotComments) { if (java.util.Objects.equals(fixId, fixSuggestion.fixId)) { return new com.google.gerrit.server.change.FixResource(revisionResource, fixSuggestion.replacements); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.update.ChangeResource req, com.google.gerrit.server.change.ChangeResource req, TopicInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); if (((input.topic)!= null) && ((input.topic.topic.length()) > (com.google.gerrit.server.ChangeUtil.TOPIC_MAX_LENGTH)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("Topic %s does not limit (input.topic(input.topic(input.topic), "%s"), ChangeUtil.TOP_MAX_LENGTH)); } com.google.gerrit.server.change.PutTopic.Op op = new com.google.gerrit.server.change.PutTopic.Op((input!= null? input.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(req.getId(), op); u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName), op); }
@org.junit.Test public void byLabelGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); createAccount("user2"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); java.lang.String g1 = createGroup("group2", "Administrators"); java.lang.String gApi.groups().id(g1).addMembers("user1"); gApi.groups().id(g2).addMembers("user1"); gApi.groups().id(g2).addMembers("user2"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo), user1); requestContext.setContext(newRequestContext(user1)); gApi.changes().id(change1.getId().get()).current().review(new com.google.gerrit.extensions.api.changes.ReviewInput().label("Code-Review", 1)); requestContext.setContext(newRequestContext(userId)); requestContext.setContext(newRequestContext(userId)); assertQuery("label:Code-Review=+1", change1); assertQuery("label:Code-Review=+1", change1); assertQuery("label:code=+1", account2); assertQuery("label=+1", account2); assertQuery("label:Code-Review=+1", account2); assertQuery("label:user2"); assertQuery("label:Code-Review=+1", account2); assertQuery("label:user2"); }
@org.junit.Test public void submitRecords() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); gApi.changes().id(change1.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); requestContext.setContext(newRequestContext(user1)); assertQuery("submittable", change1); assertQuery("submittable", change1); assertQuery("submittable", change1); assertQuery("submittable:not_ready", change1); assertQuery("submittable:not_ready", change1); assertQuery("submittable:not_ready", change1); assertQuery("submittable:not_ready", change1); assertQuery("submittable:not_ready", change1); assertQuery("label:notify", user1); assertQuery("label:notify", user1); assertQuery("label:user=user=user=user=user=user=user=user=user1); assertQuery("label:user=user=user=user=user=user=user=user=user1); assertQuery("label:user=user=user=user=user1, user1); assertQuery("label:user:user:user:user:user2, user1); assertQuery("label:user:user2, user1); assertQuery("label:user=user.getUser:user2", change1); assertQuery("label:user2, user1); assertQuery("label:user2", change1); assertQuery("label:user2.getChangeA=ok("Code-Id:user", change1); }
@java.lang.Override public com.google.gerrit.extensions.common.CommitInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws java.io.IOException { return com.google.gerrit.server.git.CommitUtil.toCommitInfo(rsrc.getCommit()); }
@java.lang.Override public com.google.gerrit.server.project.CreateTag create(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString name) { return createTagFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.GroupInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not found"); }
public static java.lang.String describe(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { return user.getAccountId().toString(); } if (user instanceof com.google.gerrit.server.query.change.SingleGroupUser) { return user.toString(); } return user.toString(); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.AccountLoader loader = infoFactory.create(true); com.google.gerrit.extensions.common.AccountInfo info = loader.get(rsrc.getMember().getAccountId()); loader.fill(); return info; }
private static java.lang.String getGroupName(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { return groupCache.get(groupId).map(("Internal account " + groupId)); }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById m : values) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = m.getIncludeUUID(); java.lang.String groupName = groupBackend.get(groupUuid).getName(); com.google.gerrit.reviewdb.client.AccountGroup.UUID targetUuid = m.getGroupId(); java.lang.String targetName = getGroupName(targetUuid).getName(); com.google.gerrit.reviewdb.client.AccountGroup.UUID targetGroupName = m.getGroupId(); java.lang.String targetGroupName = getGroupName(targetUuid); descriptions.add(java.text.MessageFormat.format("{0}/{1}", "}", groupUuid, groupUuid, groupUuid, targetUuid, targetGroupName)); } logOrmException(header, me, e); }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { for (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroup(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { auditUpdates.add(me, removedOn); auditUpdates.add(audit); } } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, removedOn); } } db.accountGroupMembersAudit().update(auditUpdates); db.accountGroupMembersAudit().insert(auditInserts); db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log delete accounts from account event performed by user", me, removed, e); } }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, addedOn); auditInserts.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to account event performed by account event performed by user", me, e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { for (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } } if (audit!= null) { audit.removed(me, removedOn); auditUpdates.add(audit); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from user", me, removed, e); } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Topic"); }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, addedOn); includesAudit.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to account event performed by user performed by user", me, e); } }
public static void logFailToLoadFromGroupRefAsException(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { com.google.gerrit.server.group.GroupDbConsistencyChecker.logConsistencyProblem(("Cannot with account %s from account %s from account %s", notes)); }
@com.google.common.annotations.VisibleForTesting static java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkWithGroupNameNotes(org.eclipse.jgit.lib.Repository allUsersRepo, java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException { try { java.util.Optional<com.google.gerrit.common.data.GroupReference> groupRef = com.google.gerrit.server.group.GroupNameKey.loadOneGroupReference(allUsersRepo, groupName); if (!(groupRef.isPresent())) { return com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.group.ConsistencyChecker.ConsistencyProblemInfo(allUsersRepo, groupName); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = groupRef.get().getUUID(); java.lang.String name = groupRef.get().getName(); java.lang.String name = groupRef.get().getName(); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); if (!(java.util.Objects.equals(groupUUID, uuid))) { problems.add(warning("Cannot check name '%s' has UUID '%s'", groupName, groupUUID, groupUUID, uuid)); } if (!(java.util.Objects.equals(groupName, name))) { problems.add(warning("Cannot check name '%s' for account %s'", name)); } return problems; } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { return com.google.common.collect.ImmutableList.of(("Failed to check check consistency with account %s'", e.getName(), e.getMessage(), e.getMessage(), e.getMessage(), e.getMessage(), e.getMessage()); } }
private void readGroups(org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs, com.google.gerrit.server.group.Git.GitConsistencyChecker.Result result) throws java.io.IOException { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : refs.entrySet()) { if (!(entry.getKey().startsWith(RefNames.REFS_GROUPS))) { continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey()); if (uuid == null) { result.problems.add(error("Cannot UUID from %s", entry.getKey().getObjectId()); continue; } try { com.google.gerrit.server.group.GroupConfig cfg = com.google.gerrit.server.group.GroupConfig.loadForGroup(repo, uuid, entry.getValue().getObjectId()); result.uuidToGroupMap.put(uuid, cfg.getLoadedGroup().get()); result.uuidToGroupMap.put(uuid, cfg.getLoadedGroup().get()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { result.prolog.warn("Error parsing for parse: %s does not parse: %s does not parse: %s", e.getMessage())); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ParentInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return apply(rsrc, input, true); }
public void validateParentUpdate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser user, java.lang.String newParent, boolean checkIfAdmin) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException { if (checkIfAdmin) { permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); } if ((project.equals(allProjects)) && (!(allProjects.get().equals(newParent))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("Project must inherit from %s", allUsers.get())); } if (project.equals(allProjects)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Project project " + (allProjects.get()))); } newParent = com.google.common.base.Strings.emptyToNull(newParent); if (parent == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project project " + newParent) + " not found")); } if (parent.getName().equals(project.get())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("project " + (p) + " not found")); } if (parent.getName().equals(project.get())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("project set parent
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.TagResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.TagResource parse(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return new com.google.gerrit.server.project.TagResource(rsrc.getProjectState(), rsrc.getUser(), list.get().get().get(rsrc, id)); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AgreementInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { if (!( agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Authentication required"); } if (!(self.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("not allowed"); } com.google.gerrit.server.IdentifiedUser user = self.get().asIdentifiedUser(); if (!(self.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get contributor agreements"); } java.util.List<com.google.gerrit.extensions.common.AgreementInfo> results = new java.util.ArrayList<>(); java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> caches = new java.util.ArrayList<>(); java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> ce = projectCache.getAllProjects().getConfig().getConfig().getConfig().getContributorAgreements(); for (com.google.gerrit.common.data.ContributorAgreement ca : ca.getAccepted()) { java.util.List<com.google.gerrit.common.data.PermissionRule> groupIds = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.PermissionRule rule : ca.getAccepted()) { if ((rule.getGroup().getUUID())!= null) { groupIds.add(rule.getUUID()); } else { com.google.gerrit.server.account.GetAgreements.log.warn(((((("rule " + (rule.getRule())) + " is not match")); } else { com.google.gerrit.server.account.GetAgreements.log.warn(((("Cannot access rule " + (rule.getGroup())) + (rule
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.get(accountId).getUserName(); com.google.gerrit.reviewdb.client.AccountGroup.UUID u = m.getAccountId(); java.lang.String name = getGroupName(accountId); descriptions.add(java.text.MessageFormat.format("{0}/{1}", com.google.gerrit.reviewdb.client.AccountGroup.UUID.getAccountGroupId()); java.lang.String groupName = getGroupName(0, com.google.gerrit.reviewdb.client.AccountGroup.UUID.UUID.get(accountId).getAccountId(); java.lang.String groupName = getGroupName(0, com.google.gerrit.reviewdb.client.AccountGroup.Id.UUID()); java.lang.String me = m.text.format("AccountGroup %s/{0}", e.getName()); if (e.getMessage()) { com.google.gerrit.reviewdb.client.AccountGroup.Id id = m.get(accountId); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.get(id); java.lang.String me = m.format("/email", me, me, e.getName()); if (me == null) { e.add(me, e); } } }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.index.AccessCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.access.AccessResource.ACCESS_KIND); }
private void testCannotCreateGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, Permission.CREATE); grant(allUsers, com.google.gerrit.server.account.externalids.InMemoryRepository> allUsersRepo = cloneProject(allUsers); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo).to(groupRef); r.assertErrorStatus(); assertThat(r.getMessage()).contains("CREATE allowed to create account branch branch."); try (org.eclipse.jgit.lib.Repository repo = repo.openRepository(allUsers)) { assertThat(r.getMessage()).contains("CREATE " + group branch.name()); r.assertError(); } }
private static <T> com.google.common.collect.ImmutableSet<T> logIfNotUnique(com.google.gerrit.server.group.GroupBundle.Source source, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.Iterable<T> iterable, java.lang.Class<T> comparator, java.lang.Class<T> comparator, java.lang.Class<T> comparator, java.lang.Class<T> comparator) { java.util.List<T> list = com.google.common.collect.Streams.stream(iterable).sorted(com.google.common.collect.ImmutableSet.of(list); com.google.common.collect.ImmutableSet<T> set = com.google.common.collect.ImmutableSet.copyOf(list); if ((set.size())!= (list.size())) { com.google.gerrit.server.group.GroupBundle.log.warn("Could not found {} in {}", uuid, source, clazz.getSimpleName(), iterable); } return set; }
public static void updateGroupFile(org.eclipse.jgit.lib.Repository allUsersRepo, org.eclipse.jgit.lib.PersonIdent serverIdent, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String fileName, java.lang.String contents) throws java.lang.Exception { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo)) { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.revwalk.RevWalk> testRepository = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo)) { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.lib.Repository> testRepository = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo, rw); try (org.eclipse.jgit.revwalk.RevWalk rw = rw.parseCommit(refName); if (ref!= null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); if (c!= null) { builder.parent(c); } builder.create(); } builder.create(); } }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.project.ProjectResource rsrc) { return json.format(rsrc.getProjectState()); }
com.google.gerrit.server.api.projects.BranchApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
private com.google.gerrit.server.project.BranchResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return branches.parse(project, com.google.gerrit.server.permissions.PermissionBackend.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult file(java.lang.String path) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.project.FileResource resource = filesCollection.parse(resource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); return getContent.apply(resource); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve file", e); } }
@org.junit.Test public void groupNameNoteHasDifferentUUID() throws java.lang.Exception { updateGroupNamesRef("g-1", uuid-1 = gid-1", "uuid-1 = g-1 = g-1"; java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.Git.ConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("No 1 'g-1' for user '%s' '%s' in 'u' in '' '' in '' in ''' in '' in ''' in '' in '' in ''' in '' in 'uuid - '' in '''")); }
@org.junit.Test public void groupNameNoteIsConsistent() throws java.lang.Exception { updateGroupNamesRef("g-1", uuid-1 = "uuid-1= uuid-1=1= g-1 = g-1"; java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.Git.ConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).isEmpty(); }
@org.junit.Test public void groupNameNoteDbNotParse() throws java.lang.Exception { updateGroupNamesRef("g-1", "[invalid"); java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.ConsistencyCheckerChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("Checking to check configuration file name notes: " + (com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); }
@org.junit.Test public void groupNameNoteIsMissing() throws java.lang.Exception { updateGroupNamesRef("g-2", uuid-2 = "uuid-2= g-2", uuid-2 = g-2, "g-2= g-2", g-2, java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = com.google.gerrit.server.group.Git.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly("warning("g-1 with name 'g-1' doesn't exist in all names")); }
@org.junit.Test public void groupNameNoteHasDifferentName() throws java.lang.Exception { updateGroupNamesRef("g-1", uuid-1 = "uuid-1=u=g-1", uuid-2 = g-2, "g-2", uuid-2", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1", "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly("warning("1 note of name 'g-1'")); }
@org.junit.Test public void groupNameNoteHasDifferentNameAndUUID() throws java.lang.Exception { updateGroupNamesRef("g-1", uuid-2 = gid-2", "uuid-2 = g-2", uuid-2 = g-2, "uid-2", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1" + "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly(warning("No 1 '' has '' has '' in '' in '' in '' in ''' in ''' in '''")); }
com.google.gerrit.server.api.projects.ChildProjectApiImpl create(com.google.gerrit.server.project.ChildProjectResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteTagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.tags) == null)) || (input.tags.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to specified"); } deleteRefFactory.create(project).refs(input.tags).prefix(com.google.gerrit.server.project.R_TAGS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static void logInvalid(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, org.eclipse.jgit.revwalk.RevCommit c, org.eclipse.jgit.revwalk.FooterLine line) { com.google.gerrit.server.group.AuditLogReader.log.debug("Error footer line in commit {}", c.name(), c.name(), c.name(), c.name(), line); }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResultInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.ProjectResource rsrc, BanCommitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.ProjectResource rsrc, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResult r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input!= null) && ((input.commits)!= null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBan = new java.util.ArrayList(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } } com.google.gerrit.server.git.BanCommitResult result = banCommit.scan(rsrc.getNameKey(), rsrc.getUser(), commitsToBan, input.reason); r.newBanned = com.google.gerrit.server.project.BanCommit.transformCommit(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transformCommit(result.getNewlyBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.transform(result.getNewBannedCommits()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.get(result.
private GroupBundle.Builder newGroupBundle() { com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("account-1"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("account-1"), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.Account.Id(new com.google.gerrit.reviewdb.client.Account.Id(0)), ts); com.google.gerrit.reviewdb.client.AccountGroupMember member = new com.google.gerrit.reviewdb.client.AccountGroupMember(member, new com.google.gerrit.reviewdb.client.Account.Id(10000), ts); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.Account.Id(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup")); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupById(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup")); com.google.gerrit.reviewdb.client.AccountGroupByIdAud byIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.GlobalUser.name", value = Users.name", value = Users.name("global:Anonymous-User.conflict") public void createGroupWithDefaultNameOfSystemGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Cannot name Users is not"); gApi.groups().create(userId); }
com.google.gerrit.server.api.changes.RobotCommentApiImpl create(com.google.gerrit.server.change.RobotCommentResource c);
private com.google.gerrit.extensions.common.AuthInfo getAuthInfo(com.google.gerrit.server.config.AuthConfig cfg, com.google.gerrit.server.account.Realm realm) { com.google.gerrit.extensions.common.AuthInfo info = new com.google.gerrit.extensions.common.AuthInfo(); info.authType = cfg.getAuthType(); info.useContributorAgreements = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.isUseContributorAgreements()); info.editAccountFields = cfg.getEditableBoolean(cfg.getEditableFields()); info.editAccountUrl = cfg.getEditableAccountUrl(); info.editAccountUrl = cfg.getGitBasicAuthPolicy(); info.gitBasicAuthPolicy = cfg.getGitBasicAuthPolicy(); if ((info.useContributorAgreements)!= null) { java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> agreements = projectCache.getAllProjects().getConfig().getConfig().getContributorAgreements(); if (!(Agreements.isEmpty())) { info.contains(Agreements); } } switch (info.authType) { case LDAP : case LDAP : case LDAP : info.registerText = cfg.authType(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterText(); info.registerText = cfg.getRegisterFullName(); info.registerText = cfg.getRegisterFullName(); info.httpPassword = cfg.getHttpPasswordUrl(); info.httpPasswordUrl = cfg.getHttpPasswordUrl(); info.httpPassword = null; case HTTP_LDAP : case HTTP_LDAP_LDAP : info.httpPasswordUrl = cfg.getHttpPasswordUrl(); break; case HTTP_LDAP : case HTTP_LD
@org.junit.Test public void pushToGroupForReviewForAllUsersRepoIsSubmit() throws java.lang.Exception { pushToGroupBranchForReviewers(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID()), "not allowed update not allowed"); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.global:Anonymous-Users.name", value = Users.name", value = Users.toString(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Cannot Users already exists exists exists")); gApi.groups().create(user).create("user")); }
@org.junit.Test public void createDuplicateSystemGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String newGroupName = Users.USER_SensitiveName_Conflict(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("groups already exists exists exists exists exists exists"); gApi.groups().create(newGroupName); }
private void testCannotDeleteGroupBranch(java.lang.String refPattern, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, refPattern, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsers); org.eclipse.jgit.transport.RemoteRefUpdate refUpdate = r.getRemoteUpdate(groupRef); assertThat(refUpdate.getStatus()).isEqualTo(RemoteRefUpdate.Status.REJECTED_OTHER_REASON); assertThat(refUpdate.getMessage()).contains("Multiple allowed to delete account branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRef))).isNotNull(); } }
private void pushToGroupBranchForReview(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRef, java.lang.String expectedError) throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grant(groupsInNoteDb()).isTrue(); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS, false); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), com.google.gerrit.acceptance.api.group.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRef + "account.config")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(repo, admin.getIdent(), repo, account.getIdent(), "accounts"), content + groupRef)); r.assertOkStatus(); assertThat(r.getChange().change().getDest().get()).isEqualTo(groupRef); gApi.changes().id(r.getChangeId()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); exception.expectMessage("not allowed to update not allowed"); }
@org.junit.Test public void pushToGroupNamesBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); allowGlobalCapabilities(com.google.gerrit.acceptance.api.group.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); assertPushToGroupBranch(allUsers, RefNames.REFS_GROUPS, RefNames.REFS_GROUPS, "update not allowed"); }
@org.junit.Test public void pushToDeletedGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.RefNames.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("foo")).get().id)); createBranch(allUsers, groupRef); assertPushToGroupBranch(allUsers, groupRef); }
@org.junit.Test public void createDuplicateInternalGroupCaseSensitiveName_Conflict() throws java.lang.Exception { java.lang.String duplicateGroupName = name("dupGroup"); gApi.groups().create(dupGroupName); gApi.groups().create(dGroupName); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage((("Cannot create " + (d.getDuplicateName())) + " already exists")); gApi.groups().create(d.getId()); }
private void assertPushToGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String groupRefName, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.Group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_DELETED_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.rest.group.InMemoryRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefName + "groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = cloneProject(repo, (groupRefName + "groupRef")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(repo, (groupRefName + "groupConfig.GROUP_CONFIG_CONFIG")); repo.reset("groupRef"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo.getIdent(), repo.getIdent(), repo.getIdent(), "groupConfig.GROUP_CONFIG_CONFIG_CONFIG_CONFIG_CONFIG")); if (expectedErrorOnUpdate!= null) { r.assertError(("group " + ") + (expected
private void assertCreateGroupBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.REGISTERED_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, false, com.google.gerrit.acceptance.api.group.InMemoryRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, GroupConfig.GROUP_CONFIG_CONFIG_CONFIG); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, com.google.gerrit.server.account.GetPreferences.create(admin.getIdent(), repo, "groupConfig.GROUP_CONFIG_CONFIG_CONFIG_FILE, content "")); if (expectedErrorOnCreate!= null) { r.assertErrorOnCreate(expectedErrorOnCreate); } else { r.assertError("No create project " + (expectedErrorOnCreate); } }
@org.junit.Test public void onlyVisibleGroupsReturned() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.api.groups.GroupInput in = newGroupName; in.name = newGroupName; in.description = adminGroupName; in.description = adminGroupUuid().get(); in.ownerId = adminGroupUuid().get(); in.ownerId = adminGroupUuid().get(); gApi.groups().create(in); assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName); setApiUser(user); gApi.groups().id(newGroupName).addMembers(newGroupName); setApiUser(user); gApi.groups().id(newGroupName).addMembers(user.username); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName); }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { assertPushToGroupBranch(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID()), "not allowed to allowed to allowed"); }
@org.junit.Test public void groupDescription() throws java.lang.Exception { java.lang.String name = name("group"); gApi.groups().create(name); gApi.groups().create(name); assertThat(gApi.groups().id(desc).description()).isEmpty(); java.lang.String desc = gApi.groups().id(name).description(desc); assertThat(gApi.groups().id(desc).description()).isEqualTo(desc); gApi.groups().id(name).description(); assertThat(gApi.groups().id(null).description()).isEqualTo(null); gApi.groups().id(name).description(); assertThat(gApi.groups().id(name).description()).isEmpty(); gApi.groups().id(name).description(""); assertThat(gApi.groups().id(name).description()).isEmpty(); }
@org.junit.Test public void reindexPermissions() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount groupOwner = accountCreator.user2(); com.google.gerrit.acceptance.TestAccount groupOwner = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("group"); in.members = java.util.Collections.singleton(groupOwner).stream().map(( u) -> u.id.toString()).collect(java.util.stream.Collectors.toList()); in.visibleToAll = true; com.google.gerrit.extensions.common.GroupInfo group = gApi.groups().create(in).get(); setApiUser(group.id).index(); setApiUser(group.id).index(); setApiUser(group.id).index(); setApiUser(group.id).index(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("Unsupported operation account account"); gApi.groups().id(group.id).index(); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("Unsupported operation"); gApi.groups().id(group.id).index(); }
@org.junit.Test public void createDuplicateSystemGroupCaseInConflict() throws java.lang.Exception { java.lang.String newGroupName = "user"; exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Cannot Users already exists exists exists exists"); gApi.groups().create(newGroupName); }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.query.change.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); boolean hasAssigneeInIndex = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE); boolean hasAssigneeInIndex = com.google.gerrit.server.query.change.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)) && hasAssigneeInIndex)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.largeChange = com.google.gerrit.server.query.change.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)); info.private ChangeTooltip = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply")) + (Shortcut: a)")); info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyTooltip")).orElse("Reply")) + (Shortcut: a)")); info.replyLabel = (java.util.Optional.ofNullable(cfg.getString("change", null, "replyLabel")).orElse("Reply")) + "; info info.updateDelay = (com.google.gerrit.server.change.GetServerInfo.log.error(((("Cannot change " + (com.google.gerrit.server.change.SubmitRecord.getTimeUnit.UNTRAILED_CONFIG)) + ") + (com.google.gerrit.server.change.Submit
private com.google.gerrit.extensions.common.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllProjectsName allUsersName) { com.google.gerrit.extensions.common.GerritInfo info = new com.google.gerrit.extensions.common.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugUrl"); info.docUrl = cfg.getString("gerrit", null, "reportBugText"); info.docSearch = docSearcher.isAvailable(); info.editGpgKeys = com.google.gerrit.server.config.GetServerInfo.toBoolean(((enableSignedPush) && (cfg.getBoolean("gerrit", null, "editGpgKeys", true))))); info.webUis = java.util.EnumSet.noneOf(com.google.gerrit.extensions.client.UiType.class); if (gerritOptions.enableGwtUi()) { info.webUis.add(UiType.GWT); } if (gerritOptions.enablePolyGerrit()) { info.webUis.add(UiType.POLYGERRIT); } return info; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.accounts = getAccountsInfo(accountVisibilityProvider); info.auth = getAccountsInfo(accountVisibilityProvider); info.auth = getAuthInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.noteDbEnabled = com.google.gerrit.server.config.GetServerInfo.toBoolean(isNoteDbEnabled()); info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(site_theme)) { info.defaultTheme = getPluginInfo(); info.suggest = getSshdInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getSuggestInfo(config); java.util.Map<java.lang.String, java.lang.String> urlAliases = getSuggestInfo(config); info.urlAliases = getSuggestInfo(config); info.urlAliases = getReceiveInfo(anonymousCowardName); info.receive = getReceiveInfo(); return info; }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> views() { return views; }
@java.lang.Override public void check() throws com.google.gerrit.server.StartupException { java.lang.String invalid = cfg.getSubsections("groups").stream().stream().filter(( sub) -> { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(sub); com.google.gerrit.server.account.GroupBackend groupBackend = universal.backend(uuid); return (groupBackend == null) || ((groupBackend.get(uuid))) + "' not found")).collect(java.util.stream.Collectors.joining(", ").toString()); if (!(invalidate.isEmpty())) { throw new com.google.gerrit.server.plugins.StartupException(java.lang.String.format((((("Calculated for '%s' in gerrit.config must be '\n" + gerrit.config must be invalid: ") + invalid")); } }
@org.kohsuke.args4j.Option(name = "--query", aliases = { "-q", usage = { "-g", usage = "expect user") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { addGroup(uuid); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.account.GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromDecoded(groupName)); com.google.gerrit.server.account.GroupResource rsrc = new com.google.gerrit.extensions.common.NameKey(); input.name = newGroupName; putName.apply(rsrc, input); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw die(e); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> getGroupFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUUID); if ((accountGroups.size()) == 1) { return java.util.Optional.of(com.google.common.collect.Iterables.getOnlyElement(accountGroups)); } else if (accountGroups.isEmpty()) { return java.util.Optional.empty(); } else if (accountGroups.isEmpty()) { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot account UUID " + groupUUID)); } } else if (accountGroups.isEmpty()) { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot account UUID " + groupUUID)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.BranchResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(parent.getRevision()), id.get()); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFileNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developr)).add("project.config", ("project.config", ("user= " + (sshd.toConfigValue()))).create(); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationError()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationError()).getMessage()).isEqualTo(((("Account " + (com.google.gerrit.server.git.ProjectConfigTest.DEFAULT_ACCOUNT_NAME)) + " not in ") + (GroupList.FILE_NAME))); }
@org.junit.Test public void editConfigMissingGroupTableEntry() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developer)).add("project.config", ("project.config", ("(((exclusiveGroupPermissions/*" + ") + (((exclusiveGroupPermissions = read) + ") + ((exclusiveGroupPermissions = read submit\n") + ") + " submit\n") + " submit = account ") + (exclusiveGroupPermissions = account.config") + " submit\n") + " submit = account.config")).isEqualTo(("project.config")); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.common.data.Permission submit = section.getPermission(Permission.SUBMIT); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))); rev = commit(cfg); assertThat(text(rev, "project.config")).isEqualTo(("Upload.config")); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.access.AccessResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.access.AccessResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.api.projects.TagInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("resource " + (resource.getTagInfo().ref)) + ") + (resource.getTagInfo().ref)) + ")")); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).ref(rsrc.getBranchKey()).check(RefPermission.DELETE); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("ref " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc.getRef()).ref(rsrc.getRef()).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server.group.GroupResource resource) { return com.google.gerrit.server.group.GroupJson.createOptions(resource.getGroup()); }
@org.kohsuke.args4j.Option(name = "-o", usage = "--o", usage = options perm) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--query2", aliases = { "-q2", aliases = { "-q2", usage = { this.query = query; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo apply(com.google.gerrit.server.project.DashboardResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if ((inherited) && (!(rsrc.isProjectDefault()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("missing flag can be provided"); } if (rsrc.isProjectDefault()) { try { rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } } return com.google.gerrit.server.project.DashboardsCollection.parse(rsrc.getProjectState().getProject(), rsrc.getRefName().substring(com.google.gerrit.server.project.REFS_DASHBOARDS.length()), rsrc.getConfig(), rsrc.getConfig(), rsrc.getConfig(), rsrc.getConfig().getName(), true); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.common.base.Strings.isNullOrEmpty(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
private com.google.gerrit.server.project.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.extensions.restapi.UrlString.fromUrl(((ref + ':') + path))); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.RobotCommentResource> views() { return views; }
@org.junit.Test public void byOwner() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo ownerGroup = createGroup(name("owner-account")); com.google.gerrit.extensions.common.GroupInfo group = createGroupWithOwner(name("owner-account"), ownerGroup); createGroup(name("group2")); assertQuery(("owner: "group2")); assertQuery(("owner: " + (group.id))); assertQuery(("owner:" + (ownerGroup.id)), group, ownerGroup); assertQuery(("owner:" + (ownerGroup.name)), group, ownerGroup); }
@java.lang.Override public com.google.gerrit.server.change.RobotCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.RobotComment c : commentsUtil.robotCommentsByPatchSet(notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.RobotCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); GroupInfo group = createGroup(name("Group")); assertQuery(("name: " + (group.name)), group); assertQuery(("name("account-with-with-with-with-with-with-h))); assertQuery(("name("account-with-with-with-with-with-with-h"), groupWithHighlight.name)), groupWithIns); }
@org.junit.Test public void byDefaultField() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("foo-account")); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("foo-account")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroupWithDescription(name("group3"), ("group2"), ("group must be UUID of foo and the UUID of group2: " + (group2.id))); assertQuery("foo", group1, group3); assertQuery("foo", group1, group3); assertQuery(group2.id, group2); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64(); } else if (Patch.MERGE_LIST.equals(path)) { byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_MERGE_LIST).base64(); } return fileContentUtil.getContent(projectCache.checkedGet(rsrc.getRevision().getPatchSet().getPatchSet().getRevision().get()), path, parent); }
@org.junit.Test public void fixCommitPostDATESAllAuditEventsAndAuditEventsAndInHatches() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.util.Stream future = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); com.google.gerrit.server.group.GroupBundleUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); com.google.gerrit.server.group.GroupBundle b = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).byId(g, "x") byId(g, "x")).build(); rebuilder.rebuild(repo, b, null); assertMigration(repo, b, null); assertMigrationClean(reload(re), null); assertMigration(repo, b, null); assertMigration(repo, b, null); assertMigration(reload(log.get(1), "group " + (6@server-id")).named(3); assertThat(log.stream().map((c) -> c.committer.date).collect(toImmutableList())).named("%s", log).named("%s", log\n")); assertThat(log.stream().map((c) -> c.committer.get(2), c.committer.date).isEqualTo(toImmutableList()))).named("%s", log).named("%s", log).named("%s", log).named("%s", log).isEqualTo(com.google.gerrit.common.TimeUtil.nowTs()).isEqualTo(toImmutableList())); assertThat(com.google.gerrit.common.TimeUtil.nowTs()).isEqualTo(com.google.gerrit.common.TimeUtil.nowTs()).isEqualTo(toString()).isEqualTo(toImmutableList())); assertThat(log.get
@org.junit.Test public void memberAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.GroupBundleTest.Bundle b = groupBackend(g).members(member(g, 1)).memberAudit(addMember(addMember(g, 1, 9, t2, t2, t1, t1, t1))).build(); rebuild(repo, b); assertMigrationClean(reload(g), null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertServerCommit(log.get(1), "Email to account account account account 2@server-id"); assertServerCommit(log.get(1), "Email to a @java.lang.Override public void on server-Id")); assertEquals(log.get(2), "Email to a @server-id")); assertCommit(log.get(2), "Email to a @server-Id"); assertCommit(log.get(2), "Email to a @server-Id")); assertCommit(log.get(3), "Email to a @server-Id")); }
@org.junit.Test public void unauditByIdAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.reviewdb.client.AccountGroup g = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).byId(g, "x"), byId(g, "x")).byId(g, "x")).build(); rebuilder.rebuild(repo, b, null); assertMigration(repo, b, null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertMigrationCleaned(reload(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(1), "8@server-id8")); assertServerCommit(log.get(2), "Group<java.lang.String> group "Zoned-id8")); assertServerCommit(log.get(2), "Group<java.lang.String> group "Z")); }
@org.junit.Test public void matchingByIdAuditsAreIgnored() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.GroupBundleTest.Builder b = com.google.gerrit.server.group.GroupRebuilderTest.builder().group(g).byId(g, "x", 8, t1), addById(g, "x", 8, t3), addById(g, "x", 9, t3), addById(g, "x", 9, t3), addAndRemoveById(g, "x", 9, t3), t5), rebuild(); rebuild(repo, b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertEquals(log.get(1), "9@server-id")); assertEquals(log.get(1), "9@server-id")); assertCommit(log.get(2), "9@server-id")); assertCommit(log.get(2), "9@server-id")); }
@org.junit.Test public void unauditMembershipsAddedAtEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.reviewdb.client.AccountGroup g = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).members(member(g, 1), member(g, 3), member(g, 3), member(g, 3), member(g, 3), member(g, 3, com.google.gerrit.common.TimeUtil.nowTs())); assertMigration.rebuild(repo, b, null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertServerCommit(log.get(0), "8@server-id>8@server-id"); assertServerCommit(log.get(2), "Email address:8@server-id")); assertServerCommit(log.get(2), "Email to 2@server-id " + (8@server-id > 2@server-id")); }
@org.junit.Test public void auditAtSameTimestampBrokenByType() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp ts = com.google.gerrit.common.TimeUtil.nowTs(); int user1 = 9; int user1 = 9; int user1 = 9; com.google.gerrit.server.group.GroupBundleTest.builder().group(g).members(member(g, 1), member(g, 3), member(g, 3), member(g, user1), member(g, user1), addMember(g, 3, user1, user1, ts)).byId(g, user1, user1, ts)).byId(g, user1, user1, ts)).build(); rebuild(repo, b, "x")).build(); rebuild(repo, b, "x", com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(5); assertMigration.reload(revision).hasSize(5); assertMigration.rebuild(reload(g), null); assertMigration.revision(revision.get(1), (("\n" + (("\n" + ": %s\n") + ": Code-Id>")).build(); assertEquals(log.get(1), ("user \"" + (("\n" + (("\n" + (("\n" + ": ": ": %s\n") + (("\n" + (("\n" + (("\n" + (("\n" + ": \""@server-id > 1@server-id") + ")")); assertCommit(log.get(2), ("u.get(2), com.google.gerrit.extensions.common.CommitInfo.log.get(2), "Email to group " + (("\n" + (("\n" + (("\n" + (("\n" + (("\n" + (("\n" + " + (com.google.gerrit.extensions
@org.junit.Test public void byIdAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t1 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.GroupBundleBundle b = groupRebuilderTest.builder().group(g).byId(g, "x")).byIdAudit(addById(g, "x")).build(); rebuilder.rebuild(repo, b, "x", 9, 9, t1, t3)).build(); rebuild(repo, b); assertMigration(repo, b, null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertEquals(repo, "x", com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log.get(1), "9a")).hasSize(4); assertServerCommit(log.get(2), "9@server-id8")); assertCommit(log.get(2), "9@server-id8")); assertCommit(log.get(3), "9@server-Id"); assertCommit(log.get(3), "9@server-Id"); }
@org.junit.Test public void membersAndSubgroups() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.reviewdb.client.AccountGroup g = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).members(member(g, 1), member(g, 2)).byId(g, "x")).build(); rebuilder.rebuild(reload(g), b); assertMigration(reload(g), null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(2); assertEquals(2); assertServerCommit(log.get(0), ("(("\n" + (("\n" + Account 1@server-id>\n") + "\"u") + "Group.<server-id>")); }
@org.junit.Test public void allGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); g.setDescription("Description"); g.setDescription("Description"); g.setVisibleToAll(true); com.google.gerrit.server.group.GroupBundleBundleBundle b = com.google.gerrit.server.group.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigrationClean(reload(re), null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertServerCommit(log.get(0), "Account "account account"); }
@org.junit.Test public void memberAuditLegacyRemoved() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.reviewdb.client.AccountGroup g = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).members(member(g, 2)).memberAudit(addAndLegacyRemoveMember(g, 2, com.google.gerrit.common.TimeUtil.nowTs())); rebuild(repo, b, null); assertMigration(repo, b, null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertEquals(com.google.gerrit.extensions.common.CommitInfo.log.error("Failed to account 1 account 1", 2, 8, com.google.gerrit.common.TimeUtil.nowTs())); assertPersonEquals(log.get(1), "Email address account account account account account 1@server-id"); assertEquals(log.get(2), "8@server-id")); assertCommit(log.get(3), "Email to a @server-Id")); assertCommit(log.get(3), "Email to 2@server-id " + 2@server-id")); }
@org.junit.Test public void simpleGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.reviewdb.client.AccountGroup g = com.google.gerrit.server.group.GroupBundleTest.builder().group(g).build(); rebuilder.rebuild(repo, b, null); assertMigrationCleanup(reload(g), null); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertCommit(log.get(0), "Accounts account account account"); assertCommit(log.get(0), "Email address", accountId)); assertCommit(logGroupNames()).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.project.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return fileContentUtil.getContent(rsrc.getProjectState(), rsrc.getRev(), rsrc.getPath(), null); }
@org.junit.Test public void byDescription() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroupWithDescription(name("group1"), "Test account group"); com.google.gerrit.extensions.common.GroupInfo group2 = createGroupWithDescription(name("group2"), "group of project foo."); assertQuery("description:test", group1, group1); assertQuery("description:non-existing"); assertQuery("description:non-existing"); assertQuery("description:non-existing"); assertQuery("description:non-existing"); assertQuery("description:non-existing"); assertQuery("description:operator requires a value requires a value:\"")); assertQuery("description:\"\"\"\"")); }
@org.junit.Test public void bySubgroups() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(Group.SUBGROUP); assertFailsQuery(Group.SUBGROUP); assertFailsQuery("subgroup:someGroup:someGroup"); assertFailedQuery("subgroup:someGroup1", operator is not supportedByAccountGroup(parentGroup1.id, parentGroup2.id, parentGroup2.id); return; } com.google.gerrit.extensions.common.GroupInfo parentGroup = createGroup(name("parentGroup1")); com.google.gerrit.extensions.common.GroupInfo parentGroup = createGroup(name("subGroup2")); com.google.gerrit.extensions.common.GroupInfo subGroup = createGroup(name("subGroup2")); com.google.gerrit.extensions.common.GroupInfo subGroup = createGroup(name("subGroup2")); com.google.gerrit.extensions.common.GroupInfo subGroup = createGroup(name("subGroup2")); gApi.groups().id(parentGroup.id).addGroups(subGroup.id); assertQuery(("subgroup: " + (subGroup.id)), parentGroup2); assertQuery(("subgroup: " + (subGroup.id))); assertQuery(("subgroup: " + (subGroup.id))); assertQuery(("subgroup: " + (subGroup.id))); assertQuery(("subgroup: " + (subGroup.id))); }
@org.junit.Test public void byMember() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(Group.MEMBER); assertFailedQuery("member:someName", "user1@example.com"); assertFailedQuery("member:someName", "user1@example.com"); return; } com.google.gerrit.extensions.common.AccountInfo user2 = createAccount("user2", "User2", "user2@example.com"); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("group1"), user1); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2"), user1); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2"), user1); assertQuery(("member: "group:" + (user1.name)), group1, group3); assertQuery(("member:" + (user1.name))); assertQuery(("member: " + (user1.name))); assertQuery(("member: " + (user1.name))); gApi.groups().id(group2.id(group2.id).addMembers(user1.username); assertQuery(("member: " + (user1.name))); assertQuery(("member: " + (user1.name))); }
@org.junit.Test public void byInname() throws java.lang.Exception { java.lang.String namePart = getSanitizedMethodName(); namePart = com.google.common.base.CharMatcher.is('_').removeFrom(namePart); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup((("account-" + namePart) + "-")); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup((("account-" + namePart) + "-")); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup((("account-" + namePart) + "3")); assertQuery(("inname: ") + nameGroup), group2, group2, group2); assertQuery(("inname: " + (namePart.toLowerCase(java.util.Locale.US))), group1, group2); assertQuery(("inname: " + (namePart.toLowerCase(java.util.Locale.US))), group1, group2); }
@org.junit.Test public void byIsVisibleToAll() throws java.lang.Exception { assertQuery("is:visible to all"); com.google.gerrit.extensions.common.GroupInfo groupThatIsVisibleToAll = createGroupThatIsVisibleToAll(name("account-is-visible-to")); createGroup(name("group"); createGroup(name("group")); assertQuery("is:visible", groupThatIsVisibleToAll); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.write", value = "true") public void deleteGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Not allowed to delete account branch branch branch branch branch branch."); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("branch " + (rsrc.getRef())) + ") + (rsrc.getRef())) + " already exists")); }
com.google.gerrit.server.api.changes.CommentApiImpl create(com.google.gerrit.server.change.CommentResource c);
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Move Change ").setTitle("Move change", ").filter(change.getDest()).testDesc(change.getDest()).testDesc(com.google.gerrit.server.change.CREATE_CHANGE), rsrc.permissions().database(dbProvider).database(dbProvider).testOrCreate(dbProvider).database(dbProvider).testOrCreate(dbProvider).database(dbProvider).testOrCreate(dbProvider).database(dbProvider).dbProvider))); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getProjectState().getDescription()); }
private com.google.gerrit.server.project.ProjectResource checkExists() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((name) == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(name); } return project; }
com.google.gerrit.server.api.projects.ProjectApiImpl create(com.google.gerrit.server.api.projects.ProjectResource project);
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destBranch.equals(destProject.getNameKey()))) || (!(com.google.gerrit.reviewdb.client.RefNames.isGroupRef(destBranch.get()))) { return; } throw new com.google.gerrit.server.validators.ValidationException("not allowed to allowed to allowed"); }
public static AccountGroup.UUID make(java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent creator) { java.security.MessageDigest md = org.eclipse.jgit.lib.Constants.newMessageDigest(); md.put(org.eclipse.jgit.lib.Constants.encode((("CREATE " + (creator.toExternalString())) + "\n")); md.put(org.eclipse.jgit.lib.Constants.encode(java.lang.String.valueOf(java.lang.Math.max(java.lang.Math.random())))); return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(org.eclipse.jgit.lib.ObjectId.fromRaw(md.fromRaw(md.getRaw(md.d.getRaw(md.d.getRaw(md.d.getRaw(md.getRaw(md.d.get().get())))); }
@org.junit.Test public void createdOnPopupForGroupsCreatedOnGroupsCreatedOnGroupsCreatedOnAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("Group for schema migration migration migration migration migration"); setCreatedOn(groupId); schema.migrationData(db, new com.google.gerrit.testutil.TestUpdateUI()); java.sql.Timestamp createdOn(db, new com.google.gerrit.testutil.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.project.ProjectState projectState, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId())!= null)? ref.getObjectId().name() : null; info.canDelete = ((!(targets.contains(ref.getName()))) && (perm.testOrFalse(RefPermission.DELETE)))? true : null; com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.WebLinkInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty())? null : links; return info; }
com.google.gerrit.extensions.api.projects.BranchInfo toBranchInfo(com.google.gerrit.server.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.lib.Ref r = db.exactRef(rsrc.getRef()); if (r == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, com.google.common.collect.ImmutableList.of(r)).get(0); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> allBranches(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.util.List<org.eclipse.jgit.lib.Ref> refs; try (org.eclipse.jgit.lib.Repository db = repoManager.openRepository(rsrc.getNameKey())) { java.util.Collection<org.eclipse.jgit.lib.Ref> heads = db.getRefDatabase().getRefs(Constants.R_HEADS).values(); refs = new java.util.ArrayList(((heads.size()) + 3)); refs.addAll(heads); refs.addAll(db.getRefDatabase().exactRef(Constants.HEAD, RefNames.REFS_CONFIG, RefNames.REFS_CONFIG, RefNames.REFS_USERS_DEFAULT).values()); refs.addAll(db, refs); refs.addAll(db, refs); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noGitRepository) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, refs); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.BranchInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring).start(start).limit(limit).filter(limit).filter(allBranches(allBranches(rsrc)); }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> toBranchInfo(com.google.gerrit.server.project.ProjectResource rsrc, java.util.List<org.eclipse.jgit.lib.Ref> refs) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Set<java.lang.String> targets = com.google.common.collect.Sets.newHashSetWithExpectedSize(1); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { targets.add(ref.getTarget().getName()); } } com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey()); java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> branches = new java.util.ArrayList(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { java.lang.String target = ref.getTarget().getName(); if (!(perm.ref(target).test(RefPermission.READ))) { continue; } if (target.startsWith(Constants.R_HEADS.length()); } com.google.gerrit.extensions.api.projects.BranchInfo b = new com.google.gerrit.extensions.api.projects.BranchInfo(); b.ref = new com.google.gerrit.extensions.api.projects.BranchInfo(); b.ref = ref.getName(); b.revision = target; branches.add(b); if (!(Constants.equals(ref.getName()))) { b.canDelete = (perm.getName())? true : null; } } if (perm.canDelete = (perm.getName()) { if (perm.ref(ref.getName()).testOrFalse(RefPermission.DELETE)) { return null; } } if (perm.ref(ref.getName()).testOrFalse(ref.getName()).testOr
@java.lang.Override public Account.Accepted apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) { com.google.gerrit.reviewdb.client.Project.NameKey project = resource.getNameKey(); com.google.gerrit.server.git.MultiProgressMonitor.Task mpt = new com.google.gerrit.server.git.MultiProgressMonitor(com.google.common.io.ByteStreams.nullOutputStream(), ").beginSubTask("unKNOWN"); com.google.gerrit.server.index.change.AllChangesIndexer allChangesIndexer = allChangesIndexerProvider.get(); allChangesIndexer.setVerboseOut(null); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<java.lang.Void> ignored = executor.submit(allChangesIndexer.repositoryIndex(indexer, project, mpt)); return com.google.gerrit.extensions.restapi.Response.acceptance.acceptance.Response.accept((("unindex " + project) + " submitted for reindexing")); }
@org.kohsuke.args4j.Option(name = "--owned-by", usage = "--owned by the account") public void setOwnedBy(java.lang.String ownedBy) { this.ownedBy = ownedBy; }
@org.kohsuke.args4j.Option(name = "--account", aliases = { "-g", aliases = { "-g", usage = "ex") + to parse") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { groupsToInclude.add(uuid); }
@org.kohsuke.args4j.Option(name = "-o", usage = "-o", usage = options perm) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--regex", aliases = { "-r", aliases = "REGEX", usage = "REGEX", usage = "REGEX", usage = "REGEX account"); this.matchRegex = matchRegex; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); permissionBackend.user(resource.getNameKey()).ref(tag).check(RefPermission.DELETE); deleteRefFactory.create(resource).ref(tag).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.server.index.QueryParseException getException(java.lang.String operatorName) { return new com.google.gerrit.server.index.QueryParseException(java.lang.String.format("Unsupported operator is not supported by account version", name)); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Authentication must be set"); } com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, user.getUserName())); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId newExtId = com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword); externalIdsUpdate.create().upsert(newExtId); return com.google.common.base.Strings.isNullOrEmpty(newPassword); }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { int id = config.getInt(com.google.gerrit.server.group.GroupConfigEntry.SECTION_NAME, super.keyName, (-1)); if (id < 0) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Unsupported of account %s must be negative, found %d", id)); } group.setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(id)); }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.project.ChildProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((recursive) || (rsrc.isDirectChild())) { return json.format(rsrc.getChild().getProject()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getChild().getProject()); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.GroupInfo> apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = rsrc.asInternalGroup().orElse(MethodNotAllowedException.new); return getDirectSubsections(group, rsrc.getControl()); }
private java.util.List<com.google.gerrit.reviewdb.client.Account.Id> suggestAccounts(com.google.gerrit.server.change.SuggestReviewers suggestReviewers) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.metrics.Timer0.Context ctx = metrics.queryAccountsLatency.start()) { try (com.google.gerrit.metrics.Timer0.Context ctx = metrics.queryAccountsLatency.start()) { com.google.gerrit.index.QueryResult<com.google.gerrit.server.account.AccountState> result = queryProvider.get().setUserProviders.start(); return result.entries().stream().map(((suggestReviewers.getLimit()) * (com.google.gerrit.server.query.change.ReviewerPredicates.DANDIDATE_LISTLIER))); } catch (com.google.gerrit.server.query.QueryParseException e) { return result.entries().stream().map(( a) -> a.getAccount().getId()).collect(java.util.stream.Collectors.toList()); } } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.Submodule.Subview<com.google.gerrit.server.group.Subgroup.Subgroup.Ui> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddSubgroups.PutSubmodule create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.group.AddSubgroups.PutSubmodule(addSubgroups, id.get()); }
@java.lang.Override public com.google.gerrit.server.group.Subgroup.SubgroupResource parse(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.common.data.GroupDescription.Internal parent = resource.asInternalGroup().orElseThrow(MethodNotAllowedException, (com.google.gerrit.server.group.Subgroups.SubgroupsCollection.isSubgroup(parent, member))); com.google.gerrit.common.data.GroupDescription.Basic member = groupsCollection.parse(TopLevelResource.INSTANCE, id).getGroup(); if ((resource.getControl().canSeeGroup()) && (com.google.gerrit.server.group.Subgroups.SubgroupsCollection.isSubgroup(parent, member))) { return new com.google.gerrit.server.group.Submodule.SubmoduleResource(resource, member); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() { return list; }
com.google.gerrit.server.api.changes.DraftApiImpl create(com.google.gerrit.server.change.DraftCommentResource d);
@org.kohsuke.args4j.Option(name = "--match", aliases = { "-m", aliases = { "-m", usage = "MATCH", usage = "MATCH", usage = "MATCH", usage = "MATCH", usage = "MATCH", usage = "MATCH", usage = "MATCH", usage = matchSubstring; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptionsInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.common.GroupOptionsInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException.class); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed"); } if ((input == null) { input.visibleToAll = false; } if ((input.visibleToAll) == null) { com.google.gerrit.reviewdb.client.AccountGroup.UUID group = internalGroup.getGroup().setVisibleToAll(input.visibleToAll); com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroupUUID(); com.google.gerrit.server.group.InternalGroupUpdate group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.Builder.builder().setVisibleToAll(input.visibleToAll).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Unsupported patch set group %s not found", groupUuid)); } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource resource) { com.google.gerrit.reviewdb.client.Project.NameKey parentName = resource.getProjectState().getProject(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = project.getParent(allProjectsName); return parentName!= null? parentName.get() : ""; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.GarbageCollect.Input input) { com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getNameKey(); if (input.async) { return applyAsync(project, input); } return applySync(project, input); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Garbage", ").setTitle("GarbageGarbageGarbage collection"); }
protected com.google.gerrit.common.data.ContributorAgreement configureContributorAgreement(boolean autoVerify) throws java.lang.Exception { com.google.gerrit.common.data.ContributorAgreement ca; if (autoVerify) { com.google.gerrit.common.data.ContributorAgreement ca; if (autoVerify) { java.lang.String g = createGroup("cla-test-test-account"); com.google.gerrit.extensions.api.groups.GroupApi groupApi = gApi.groups().id(g); groupApi.description("cla test account"); com.google.gerrit.common.data.GroupReference group = group(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupApi.detail().id)); com.google.gerrit.common.data.GroupReference group = new com.google.gerrit.common.data.GroupReference(groupRef); rule.setAction(PermissionRule.Action.Action.ALLOW); ca = new com.google.gerrit.common.data.PermissionRule(groupRef); rule.setAction(PermissionRule.Action.ALLOW); ca.setAccepted(com.google.common.collect.ImmutableList.of(rule)); } else { ca = new com.google.gerrit.common.data.ContributorAgreement("cla-test-test-test-auto-verify"); ca.setAccepted(com.google.common.collect.ImmutableList.of(rule)); } else { ca.setDescription("description"); ca.setDescription("description"); ca.setAgreementUrl("agreement-verify"); com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig(); saveProjectConfig(ca); saveProjectConfig(allProjects, cfg); return ca; } }
@java.lang.Override public com.google.gerrit.server.change.FileResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.change.FileResource(rev, id.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FileResource> views() { return views; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.extensions.api.projects.BanCommitInput input = com.google.gerrit.extensions.api.projects.BanCommitInput.fromCommits(com.google.common.collect.Lists.transform(commitsToBan, ObjectId::getName()); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResultInfo r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), input); printCommits(r.alreadyBanned, "Already not exist"); } catch (java.lang.Exception e) { throw die(e); } }
@java.lang.Override void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroup.Builder group, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ownerGroupUuid = config.getString(com.google.gerrit.server.group.GroupConfigEntry.SECTION_NAME, null, super.keyName); if (com.google.common.base.Strings.isNullOrEmpty(ownerGroupUuid)) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Account %s must be defined", groupUuid.get())); } group.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(ownerGroupUUID)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteBranchesInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.branches) == null)) || (input.branches.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to specified"); } deleteRefFactory.create(project).refs(input.branches).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gwtorm.server.OrmException { if (((in == null) || ((in.message) == null)) || (in.message.trim().isEmpty())) { return delete.applyImpl(updateFactory, rsrc, null); } else if (((in.id)!= null) && (!(rsrc.getId().equals(in.id))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to match URL"); } else if (((in.line)!= null) && ((in.line)!= null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not end"); } else if (((in.line)!= null) && ((in.line)!= null)) && ((in.line)!= (in.lineLine))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported end line"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.PutDraftComment.Op op = new com.google.gerrit.server.change.PutDraftComment.Op(rsrc.getComment(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())); com.google.gerrit.server.change.PutDraftComment.Op op = new com.google.gerrit.server.change.PutDraftComment.Op(rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common
private java.util.Optional<com.google.gerrit.server.group.GitDbUpdate.UpdateResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(allUsersRepo, groupUuid); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); if (!(groupConfig.getLoadedGroup().isPresent())) { if (!(groupConfig.getLoadedGroup().isPresent())) { if (!(groupConfig.readFromNoteDb())) { throw new com.google.gerrit.common.errors.NoSuchGroupException(groupUuid); } return java.util.Optional.empty(); } com.google.gerrit.server.group.InternalGroup originalGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.server.group.GroupNameKey oldName = null; if (groupUpdate.getName().isPresent()) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = null; if (groupUpdate.getName().isPresent()) { com.google.gerrit.server.group.GroupNameKey newName = null; if (groupUpdate.getName().isPresent()) { com.google.gerrit.server.group.InternalNameKey newName = null; com.google.gerrit.server.group.InternalNameKey newName = null; if (group.getName().isPresent()) { com.google.gerrit.server.group.Internal.add(allUsersRepo, groupUuid, oldName, newName); } } commit(allUsersRepo, group
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id id, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.reviewdb.client.AccountGroupById id : groupMemberAuditListeners) { try { auditListener.onAddGroupsToGroup(actors, added, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot to log add groups to account event", e); } } }
private void addMembers(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input input = AddMembers.Input.fromMembers(initialMembers.stream().map(java.lang.Object::toString).collect(java.util.stream.Collectors.toList())); addMembers.apply(rsrc, input); }
private void addSubgroups(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input input = AddSubgroups.Input.fromGroups(initialGroups.stream().map(com.google.gerrit.reviewdb.client.AccountGroup.UUID::get).map(java.util.stream.Collectors.toList())); addSubgroups.apply(rsrc, input); }
@org.kohsuke.args4j.Option(name = "--account", aliases = "-g", aliases = "GROUP", metaVar = "GROUP", usage = "GROUP", usage = set of groups to be included in the group") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { initialGroups.add(id); }
@java.lang.Override public void replace(com.google.gerrit.server.group.InternalGroup group) throws java.io.IOException { io.searchbox.core.Bulk bulk = new io.searchbox.core.Bulk.Builder().defaultIndex(indexName).defaultType(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS, group)).refresh(groupName).build(); io.searchbox.client.JestResult result = client.execute(bulk); if (!(result.isSucceeded())) { throw new java.io.IOException(java.lang.String.format("Unsupported to account %s in index %s in index %s: %s: %s: %s", group.getGroupUUID().get(), indexName, result.getErrorMessage())); } }
private void reportGroupsAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupUuidList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = groupUuidList.stream().map(( uuid) -> groupCache.get(uuid).map(com.google.gerrit.server.group.InternalGroup::getName)).flatMap(com.google.gerrit.server.group.InternalGroup::getName)).flatMap(com.google.gerrit.server.group.InternalGroup::getName)).flatMap(out.write(java.lang.String.format("%s: %s: %s: %s", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gerrit.sshd.commands.UnloggedFailure, java.lang.Exception { try { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid : groups) { com.google.gerrit.server.group.GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(groupUuid.get())); if (!(accountsToRemove.isEmpty())) { deleteMembersAction("remove"); reportMembersAction("from", fromMembers(accountsToRemove)); reportMembersAction("removed", fromResource, accountsToRemove); } if (!(groupsToRemove.isEmpty())) { deleteSubgroupsAction("removed"); } if (!(groupsToRemove.isEmpty())) { deleteSubgroupsAction("remove"); reportMembersAction("from", from resource, accountsToRemove); reportMembersAction("add resource", from resource, accountsToRemove); } if (!(groupsToAdd.isEmpty())) { addMembersAction("add resource from resource", accountsToAdd); reportMembersAction("add resource", fromMembers(groupsToAdd)); reportMembersAction("add resource", groupsToAdd); } if (!(groupsToInclude.isEmpty())) { addSubgroupsAction("in"); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(((accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(out.write(java.lang.String.format("%s: %s: %s: %s", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("resource " + (resource.getName())) + ") + (resource.getName())) + " already exists")); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { com.google.gerrit.extensions.api.projects.ConfigInput inputInput = new com.google.gerrit.extensions.api.projects.ConfigInput(); configInput.requireChangeId = requireChangeID; configInput = submitType; configInput.useContentMerge = contentMerge; configInput.useContentMerge = contentMerge; configInput.useSignedOffBy = contentMerge; configInput.useSignedOffBy = com.google.common.base.Strings.emptyToNull(projectDescription))!= null; configInput.maxObjectSizeLimit = maxObjectSizeLimit; if ((com.google.common.base.Strings.emptyToNull(projectDescription))!= null) { configInput.create(new com.google.common.base.Strings.emptyToNull(projectDescription)); } else { configInput.description = projectState.getProject().getDescription(); } try { putConfig.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), configInput); } catch (com.google.gerrit.extensions.restapi.RestApiException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw die(e); } }
com.google.gerrit.server.api.groups.GroupApiImpl create(com.google.gerrit.server.group.GroupResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo owner() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getOwner.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot get account owner", e); } }
@java.lang.Override public void options(com.google.gerrit.extensions.common.GroupOptionsInfo info) throws com.google.gerrit.extensions.restapi.RestApiException { try { putOptions.apply(rsrc, options); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put account", e); } }
@java.lang.Override public void index() throws com.google.gerrit.extensions.restapi.RestApiException { try { index.apply(rsrc, new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot index account account", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> members(boolean recursive) throws com.google.gerrit.extensions.restapi.RestApiException { listMembers.setRecursive(recursive); try { return listMembers.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot list members", e); } }
@java.lang.Override public void removeMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot remove account members", e); } }
@java.lang.Override public void name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.NameInput in = new com.google.gerrit.extensions.common.NameKey(); in.name = name; try { putName.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put account name", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo detail() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDetail.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve account", e); } }
@java.lang.Override public void addMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { addMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot add members", e); } }
@java.lang.Override public void description(java.lang.String description) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.DescriptionInput in = new com.google.gerrit.extensions.common.Description.Input(); in.description = description; try { putDescription.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put account description", e); } }
@org.kohsuke.args4j.Option(name = "--member", aliases = { "-m", metaVar = "USERNAME", usage = "USERNAME", usage = "USERNAME", usage = set of users to be users to be users to be users to be users") { addMember(id); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { com.google.gerrit.server.account.GroupResource rsrc = createGroup(); if (!(initialMembers.isEmpty())) { addMembers(rsrc); } if (!(initialGroups.isEmpty())) { addMembers(rsrc); } if (!(initialGroups.isEmpty())) { addSubgroups(rsrc); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e); } }
private com.google.gerrit.server.group.GroupResource createGroup() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.groups.GroupInput input = new com.google.gerrit.extensions.api.groups.GroupInput(); input.description = groupDescription; input.visibleToAll = visibleToAll; if ((ownerGroupId)!= null) { input.ownerId = java.lang.String.valueOf(ownerGroupId.get()); } com.google.gerrit.extensions.common.GroupInfo group = createGroupFactory.create(groupName).apply(TopLevelResource.INSTANCE, input); return groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(group.id)); }
@java.lang.Override public com.google.gerrit.extensions.api.groups.GroupApi create(com.google.gerrit.extensions.api.groups.GroupInput in) throws com.google.gerrit.extensions.restapi.RestApiException { if ((checkNotNull(in, "GroupInput").name) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Group must configure name"); } try { com.google.gerrit.server.group.CreateGroupImpl.CreateGroup impl = createGroup.create(in.name); permissionBackend.user(user).checkAny(com.google.gerrit.server.permissions.GlobalPermission.fromAnnotation(impl.getClass())); com.google.gerrit.extensions.common.GroupInfo info = impl.apply(TopLevelResource.INSTANCE, in); return id(info.id); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot create account " + (in.name)), e); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPS); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository);org.eclipse.jgit.lib.ObjectReader reader = revWalk.getObjectReader()) { org.eclipse.jgit.revwalk.RevCommit notesCommit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.revwalk.RevCommit noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notesCommit); java.util.Set<com.google.gerrit.common.data.GroupReference> groupReference = new java.util.LinkedHashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.server.group.GitDbTable.getGroupReference(reader, note.getData()); boolean result = groupMap.add(groupReference); if (!result) { com.google.gerrit.server.group.Sets.log.error((("Unsupported reference " + (%s) is not duplicate in account)) + ") + account in account")); } } return com.google.common.collect.ImmutableSet.copyOf(groupReference); } }
private java.lang.String getCommitMessage() { if ((oldGroupName.isPresent()) && (newGroupName.isPresent())) { return java.lang.String.format("Account from '%s' to '%s' to '%s'", oldGroupName.get(), newGroupName.get()); } if (newGroupName.isPresent()) { return java.lang.String.format("%s'", newGroupName.get()); } if (oldGroupName.isPresent()) { return java.lang.String.format("No-op'", newGroupName.get()); } return "No-op"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource resource, com.google.gerrit.extensions.common.AgreementInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Authentication required"); } if ((self.get())!= (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to enter contributor"); } java.lang.String agreementName = com.google.common.base.Strings.nullToEmpty(input.name); com.google.gerrit.common.data.ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(a); com.google.gerrit.common.data.ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(a.name); if (ca == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("No enter a non-autoVerify agreement"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = ca.getAutoVerify().getConfig().getUUID(); if (uuid == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot enter a non-autoVerify agreement"); } com.google.gerrit.reviewdb.client.Account account = self.get().getAccount(); try { addMembers.addMembers(uuid, com.google.common.collect.ImmutableSet.of(account.getId())); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot create account failed"); } } }
@org.junit.Test public void sharedGroupID() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setString("group", null, "name", g2.groupId); cfg.setString("group", null, "ownerGroupUuid", g2.groupId); updateGroupFile(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)),GroupConfig.GROUP_CONFIG_CONFIG_CONFIG_CONFIG_FILE, cfg.toText()); assertError("not allowed to accountId id"); }
@org.junit.Test public void missingGroupNameRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(RefNames.REFS_GROUPS); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("Cannot does not exist"); }
@org.junit.Test public void nameWithoutGroupRef() throws java.lang.Exception { java.lang.String decorationName = name("group", null, "uuid", com.google.gerrit.acceptance.api.group.Git.GroupsConsistencyIT.BUGINHERIT_UUID); config.setString("group", null, "uuid", com.google.gerrit.acceptance.api.group.GroupNameKey.BUGINHERIT_GROUPS, com.google.gerrit.acceptance.group.GroupNameNotes.getNoteKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(blockedName)).getName(), config.toText()); assertError("accounts missing as account ref"); }
@org.junit.Test public void missingNameEntry() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefRename ru = repo.renameRef(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))); org.eclipse.jgit.lib.RefUpdate ru = ru.renameRef(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.acceptance.api.group.GitHubGroup.UUID(g1.id))); org.eclipse.jgit.lib.RefUpdate.Result result = ru.rename(); assertThat(result).isEqualTo(Result.RENAMED); } assertError((("No " + (com.google.gerrit.acceptance.api.group.Git.GitHubConsistencyIT.BUGIN_UUID)) + " has no entry")); } assertError((("unmodify " + (com.google.gerrit.acceptance.api.group.Git.Git.GroupsConsistencyCheck.BUGIN_UUID)) + " has no entry")); }
@org.junit.Test public void unknownOwnerGroup() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setString("group", null, "id", g1.groupId); cfg.setString("group", null, "ownerGroupUuid", com.google.gerrit.acceptance.api.group.Git.GroupsConsistencyIT.BUGIN_UUID); updateGroupFile(com.google.gerrit.acceptance.api.group.GroupsConsistency(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))), GroupConfig.GROUP_CONFIG_CONFIG_CONFIG); assertError("owner account"); }
@org.junit.Test public void missingGroupRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("Cannot account ref ref ref"); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo get() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getGroup.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve account", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultSetter.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { if (name == null) { return java.util.Optional.empty(); } try { return byName.get(name.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot lookup account %s by name", name.get()), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { try { return byId.get(groupId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(("Cannot load account " + groupId), e); return java.util.Optional.empty(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { if (groupUuid == null) { return java.util.Optional.empty(); } try { return byUUID.get(groupUuid.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot lookup account %s by uuid", groupUuid.get()), e); return java.util.Optional.empty(); } }
private void index(com.google.gerrit.server.project.ProjectState projectState) { index.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), null); }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (org.eclipse.jgit.lib.Constants.R_TAGS) + tagName; } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); if ((ref!= null) && (!(visibleTags(resource.getProjectState(), repo, com.google.common.collect.ImmutableMap.of(ref.getName(), ref)).isEmpty())) { return com.google.gerrit.server.project.ListTags.createTagInfo(permissionBackend.user(resource.getUser()).project(resource.getNameKey()).project(ref.getNameKey()).ref(ref.getNameKey()), ref, rw, resource.getNameKey(), links); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(resource.getNameKey()); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getProjectState(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(perm.ref(perm.getName()), ref, rw, resource.getNameKey(), links)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.Set<java.lang.String>> apply(com.google.gerrit.server.change.ChangeResource req) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = req.getNotes().load(); java.util.Set<java.lang.String> hashtags = notes.getHashtags(); if (hashtags == null) { hashtags = java.util.Collections.emptySet(); } return com.google.gerrit.extensions.restapi.Response.ok(hashtags); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.write", value = "true") public void createGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"),Permission.CREATE, com.google.gerrit.acceptance.rest.project.REGISTERED_USERS); assertCreateFails(new com.google.gerrit.reviewdb.client.Branch.NameKey(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.RefNames.REFS_GROURCES), com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID()), com.google.gerrit.acceptance.rest.ResourceConflictException.class, com.google.gerrit.extensions.restapi.ResourceConflictException.class, "not allowed to create account branch."); }
private java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> list(com.google.gerrit.server.api.groups.ListRequest req) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.restapi.TopLevelResource tlr = com.google.gerrit.extensions.restapi.TopLevelResource.INSTANCE; com.google.gerrit.server.group.ListGroups list = listGroups.get(); list.setOptions(req.getOptions()); for (java.lang.String project : req.getProjects()) { try { com.google.gerrit.server.project.ProjectResource rsrc = projects.parse(tlr, com.google.gerrit.extensions.restapi.IdString.fromDecoded(project)); list.addProject(rsrc.getProjectState()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot look up project " + project), e); } } for (java.lang.String group : req.getGroups()) { list.addGroup(groups.parse(group).getGroupUUID()); } list.setVisibleToAll(req.getVisibleToAll()); if ((req.getOwnedBy())!= null) { try { list.setVisibleToAll(req.getVisibleToAll()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot find user " + (req.getUser()))); } } list.setUser(accounts.getUser()).setAccountId()); list.setLimit(req.getLimit()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.List<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.extensions.restapi.Response.ok(java.util.Collections.emptyList()); } com.google.gerrit.server.account.AccountLoader accountLoader = accountLoaderFactory.create(true); java.util.List<com.google.gerrit.extensions.common.AccountInfo> infos = pastAssignees.stream().map(accountLoader::get).collect(java.util.stream.Collectors.toList()); accountLoader.fill(); return com.google.gerrit.extensions.restapi.Response.ok(infos); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> visibleto(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (isEmpty()) { return is_visible(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); if (!(m.isEmpty())) { java.util.List<com.google.gerrit.reviewdb.client.Account.Id> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { return visibleto(args.userFactory.create(id)); } return com.google.gerrit.server.index.Predicate.or(p); } java.util.Collection<com.google.gerrit.common.data.GroupReference> suggestions = args.groupBackend.suggest(who, null); if (!(suggested.isEmpty())) { java.util.HashSet<com.google.gerrit.common.data.GroupReference> suggestions = new java.util.HashSet<>(); for (com.google.gerrit.common.data.GroupReference ref : suggestions) { ids.add(ref.getUUID()); } return visibleto(new com.google.gerrit.server.query.change.SingleGroupUser(ids)); } throw error((("No user or account or account or account or account or account or " + who) + "\"")); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } else if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(id.get()); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id.get()); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(group); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.group.GroupResource(ctl); }
public void visit(org.eclipse.jgit.revwalk.RevCommit c) { checkState((!(done))), "Groups"); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> infos = getWatchers(c); if ((interestingParents.size()) == 0) { return; } else if ((interestingParents.size()) == 1) { groups.put(c, c.name()); return; } else if ((interestingParents.size()) == 1) { groups.putAll(c, groups.get(i)); return; } java.util.Set<java.lang.String> thisCommit = groups.get(p); if (org.eclipse.jgit.revwalk.RevCommit p : interestingParents) { java.util.Set<java.lang.String> parentGroups = groups.get(p); if (isGroupFromExistingPatchSet(p, parentGroup)) { throw new java.lang.IllegalStateException(java.lang.String.format("Cannot account %s of commit %s of commit %s of commit %s of commit %s", c.name(), c.name())); } for (java.lang.String parentGroup : parentGroups) { if (isGroupFromExistingPatchSet(p, parentGroup)) { throw new java.lang.IllegalStateException(java.lang.String.format("This account %s of commit %s of commit %s of commit %s of commit %s", c.name(), c.name())); } else { parentGroupsNewInThisPush.add(parentGroup); } } } java.lang.Iterable<java.lang.String> toAlias; if (thisCommitGroups) { java.lang.String firstParent = com.google.common.collect.ImmutableSet.ImmutableSet.of(firstParentPush, 1); toAlias = com.google.common.collect.ImmutableSet.of(firstParentPush, 1); toAlias = com.google.common.collect.ImmutableSet.of(firstParentPush, 1); toAlias = com.google.common.collect.Iterables.Iterables.skip(firstParentPush.get(firstParentPushOnePush, 1); toAlias = com.google.common.collect.
private org.eclipse.jgit.lib.ObjectId parseGroup(org.eclipse.jgit.lib.ObjectId forCommit, java.lang.String group) { try { return org.eclipse.jgit.lib.ObjectId.fromString(group); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.git.GroupCollector.log.warn("Cannot for commit {} is not a SHA - 1: {}", forCommit.name(), group); return null; } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc); }
@org.junit.Test public void createGroupAsUserIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit = createExpand(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expaudit); }
private com.google.gerrit.server.group.InternalGroup updateGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws java.lang.Exception { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(allUsersRepo, uuid); groupConfig.setGroupUpdate(groupUpdate, AbstractGroupTest.getAccountNameEmail, AbstractUserTest.getAccountNameEmail, AbstractGroupTest.getGroupNameEmail, AbstractGroupTest.getGroupNameKey(), com.google.gerrit.server.group.GroupConfig.createForAllUsersNameKey(userIdent)); return groupConfig.getLoadedGroup(); }
@org.junit.Test public void addMultigroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup subgroup1 = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroup subgroup1 = createGroupAsUser(2, "test-account-account-2"); com.google.gerrit.server.group.InternalGroup subgroup2 = createGroupAsUser(3, "test-account-account-3"); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid2 = subgroup2.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid2 = subgroup2.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid1, subgroupUuid2)); assertTipCommit(uuid, com.google.common.collect.ImmutableSet.of(subgroup.getId(), subgroupUuid2)); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit = createExpand(group.getId(), subgroupUuid1, subgroupUuid2); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit = createExpandExpand(group.getId(), subgroupUuid2, userId, getTipTimestamp(uuid))); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit2 = createExpand(group.getId(), subgroupUuid2, userId, getTipTimestamp(uuid))); assertThat(auditLogReader.getSubgroups().getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expandAllUsersRepo, e); }
@org.junit.Test public void createGroupAsServerIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroup(1, "test-account", serverIdent, null); assertThat(auditLogReader.getMembersAudit(allUsersRepo, group.getGroupUUID())).hasSize(0); }
private com.google.gerrit.server.group.InternalGroup createGroup(int next, java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent authorIdent, com.google.gerrit.reviewdb.client.Account.Id authorId) throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = com.google.gerrit.server.group.InternalGroupCreation.builder().setGroupUUID(com.google.gerrit.server.account.GroupUUID.make(groupName, serverIdent)).setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName))).setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName)).build(); com.google.gerrit.server.group.InternalGroupUpdate group = (authorIdent.equals(serverIdent))? com.google.gerrit.reviewdb.client.AccountGroup.UUID.builder().setDescription("Groups").build() : com.google.gerrit.server.group.InternalGroupUpdate.builder().setDescription("Groups").build(); com.google.gerrit.server.group.GroupConfig groupConfig = (authorIdent.equals(serverIdent))? com.google.gerrit.server.group.InternalGroupUpdate.Builder().setDescription("Groups").setDescription(groupCreateGroupTest.getAccountNameEmail()).setMemberModification((members) -> com.google.common.collect.ImmutableSet.of(authorIdent))).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); assertCreateGroup(authorIdent, commit); return groupConfig.getLoadedGroup(); }
private void assertCreateGroup(org.eclipse.jgit.lib.PersonIdent authorIdent, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { if (authorIdent.equals(serverIdent)) { assertServerCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), "cannot account"); } else { assertCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), java.lang.String.format("%s has %s@%s@%s", userId, userId, com.google.gerrit.server.group.Server.Server_ID), getAccountName(userId), getAccountName(userId), getAccountEmail(userId)); } }
void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException;
@org.junit.Test public void addAndRemoveSubgroups() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup subgroup = createGroupAsUser(2, "test-account-account-2"); com.google.gerrit.reviewdb.client.AccountGroup subgroup = createGroupAsUser(2, "test-account-account-2"); com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroup = subgroup.getGroupUUID(); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format("accountGroup<accountGroup<accountGroup<%s> subgroupUuid, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getSubgroups().get(allUsersRepo, uuid)).containsExactly(expaudit); removeSubgroups(uuid, com.google.common.collect.ImmutableSet.of(subgroupUuid)); assertTipCommit(uuid, java.lang.String.format("AccountGroup<accountGroup<%s> subgroupUuid, uuid)).containsExactly(expaudit); assertThat(audit.getSubgroups().format("AccountGroup<%s\n" + uuid)).containsExactly(expAudit); assertThat(audit.getSubgroupsAudit(allUsersRepo, uuid)).containsExactly(expaudit); }
@org.junit.Test public void addMultiMembers() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getId(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit euid = createExpand(groupId, userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id1 = new com.google.gerrit.reviewdb.client.Account.Id(100003); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit = new com.google.gerrit.reviewdb.client.Account.Id(100003); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id1, id2)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit2 = createExpand(groupId, id1, userId, getTipTimestamp(uuid)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit3 = createExpand(groupId, id2, userId, getTipTimestamp(uuid)); assertThat(audit.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1, extAudit3).inOrder(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.CommitResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { if (com.google.gerrit.reviewdb.client.Patch.isMagic(id.get())) { return new com.google.gerrit.server.project.FileResource(parent.getProjectState(), parent.getCommit(), id.get()); } return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), parent.getCommit(), id.get()); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in._oneMember = id; try { java.util.List<com.google.gerrit.extensions.common.AccountInfo> list = put.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gwtorm.server.OrmException { return get.apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return list.get().toBranchInfo(rsrc); }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(org.eclipse.jgit.lib.Repository allUsersRepo, com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.UUID::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = group.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.GroupNameKey name = com.google.gerrit.server.group.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getNameKey); com.google.gerrit.server.group.GroupNameKey name = com.google.gerrit.server.group.GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); commit(allUsersRepo, groupNameNotes); return groupConfig.getLoadedGroup().orElse(); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.UPDATE)) { logDebug("Ref cache on fast-forward of {}", cmd.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, cmd.getNewId(), cmd.getNewId()); } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(cmd)) { logDebug("Executing project cache project cache", refName, cmd.getNewId()); } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(cmd)) { logDebug("Cannot create project {}", nameKey, nameKey); } com.google.gerrit.server.project.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug("Cannot create project description", repo.setGitwebDescription(ps.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(("Cannot update description of " + (project.getName())), e); } if (allProjectsName.equals(project.getNameKey())) { try { createGroupPermissionSyntax.sync(); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.error("Cannot update account", e); } } }
@java.lang.Override public com.google.gerrit.server.project.RepositoryStatistics apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); return new com.google.gerrit.server.project.RepositoryStatistics(gc.getStatistics()); } catch (org.eclipse.jgit.api.errors.GitAPIException | org.eclipse.jgit.api.errors.JGitInternalException | org.eclipse.jgit.api.errors.JGitInternalException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getName()); } }
@org.junit.Test public void addAndRemoveMember() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroup group = createGroupAsUser(1, "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit expAudit1 = createExpand(group.getId(), userId, userId, getTipTimestamp(uuid)); assertThat(auditLogReader.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit e = new com.google.gerrit.reviewdb.client.Account.Id(10042); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit2 = createExpand(group.getId(), id, userId, getTipTimestamp(uuid)); assertTipCommit(audit.getMembersAudit(allUsersRepo, com.google.common.collect.ImmutableSet.of(id)); assertThat(audit.getMembersAudit(uuid, com.google.common.collect.ImmutableSet.of(id)); assertThat(audit.getMembersAudit(uuid)); assertThat(audit.getMembersAudit(uuid, com.google.common.collect.ImmutableSet.of(id)); assertThat(audit.getMembersAudit(allUsersRepo, uuid)).containsExactly(expand(expaudit.getId(), getTipTimestamp(uuid)); assertThat(audit.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit.getMembersAudit(allUsersRepo, uuid)).inOrder(); }
static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.GroupNameNotes.Sets.Sets.Sets_NAME, null, com.google.gerrit.server.group.GroupNameKeyNotes.SCH); java.lang.String name = com.google.common.base.Strings.nullToEmpty(config.getString(com.google.gerrit.server.group.GroupNameSECTION_NAME, null, com.google.gerrit.server.group.GroupNameSUBMES)); if (uuid == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Account for account '%s' must be defined", name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.FixResource fixResource, java.lang.Void nothing) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.RevisionResource revisionResource = fixResource.getRevisionResource(); com.google.gerrit.reviewdb.client.Project.NameKey project = revisionResource.getProject(); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); com.google.gerrit.reviewdb.client.PatchSet patchSet patchSet = revisionResource.getPatchSet(); try (org.eclipse.jgit.lib.Repository repository = gitRepositoryManager.openRepository(project)) { java.util.List<com.google.gerrit.server.edit.tree.TreeModification> treeModification = fixReplacementInterpreter.toTree(repository, projectState, patchSetCommitId, treeModifications); com.google.gerrit.extensions.restapi.Response.ok(changeEditJson.toEditInfo(changeEdit, false)); return com.google.gerrit.extensions.restapi.Response.ok(changeEditJson.toEditInfo(changeEdit, false)); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) {
com.google.gerrit.server.api.projects.DashboardApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String id);
public com.google.gerrit.server.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String reviewer = input.reviewer; com.google.gerrit.extensions.client.ReviewerState state = input.state(); com.google.gerrit.extensions.client.ReviewerState state = input.state(); com.google.gerrit.extensions.api.changes.NotifyHandling notify = input.notify; com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify = input.notify; com.google.common.collect.ListMultimap<com.google.gerrit.extensions.api.changes.RecipientType, com.google.gerrit.reviewdb.client.Account.Id> accountsToNotify = null; try { accountsToNotify = notifyUtil.checkNotify(input.notifyDetails); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { return fail(reviewer, e.getMessage()); } boolean confirmed = input.confirmed(); boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail(); com.google.gerrit.server.change.PostReviewers.Addition byAccountId = addByAccountId(reviewer, rsrc, state, notify, allowByEmail); if (byAccount!= null) { return byAccount; } return addByEmail(reviewer, rsrc, stateToNotify); }
private java.lang.String createCommitMessage(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> originalMembers, java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> originalMembers, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>> originalSubgroups, java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.UUID>> originalSubgroups) { java.lang.String summaryLine = (groupCreation.isPresent())? account : accountId; java.util.String summary = new java.util.StringJoiner("\n", "", "); java.util.StringJoiner footer = new java.util.StringJoiner("", "", "); updatedSubmoduleName = new java.util.StringJoiner("", "", "); updatedMembers.setEmptyValue(""); if (getCommitFootersForRename().add(footerLiner)) { updatedMembers.setEmptyValue(""); updatedMembers.setEmptyValue(""); updatedMembers.setEmptyValue(""); updatedMembers.ifendsWithRename(originalSubmoduleFootersForSubmoduleModifications(originalSubgroups, newMembers, newSubmoduleOp(originalSubgroups, newSubmoduleName)); java.lang.String footer = footer.toString(); return summaryLine + footer; } }
@java.lang.Override protected void run() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.HeadInput input = new com.google.gerrit.extensions.api.projects.HeadInput(); input.ref = newHead; try { setHead.apply(new com.google.gerrit.server.project.ProjectResource(project, user), input); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw die(e); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.DraftCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> getChildrenForReparenting(com.google.gerrit.server.project.ProjectState parent) throws com.google.gerrit.server.permissions.PermissionBackendException { final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> childProjects = new java.util.ArrayList<>(); final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> exclude = new java.util.ArrayList(exists.size()); for (com.google.gerrit.server.project.ProjectState ex : sec.exists()) { ent.add(includedChild.getProject().getNameKey()); } final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> automExcluded = new java.util.ArrayList(exists.size()); if ((newParentKey)!= null) { automaticallyExcluded.addAll(getAllParents(newParentKey)); } for (com.google.gerrit.extensions.common.ProjectInfo child : listChildProjects.apply(new com.google.gerrit.server.project.ProjectResource(parent, user)) { final com.google.gerrit.reviewdb.client.Project.NameKey childName = new com.google.gerrit.reviewdb.client.Project.NameKey(child.name); if (!(exists.contains(childName))) { if (!(ormExcluded.contains(childName))) { childProjects.add(childName); } else { stdout.println(((((("Excluded " + childName) + ") + (newParentKey)) + "'.")); } } } return childProjects; }
public com.google.gerrit.extensions.common.AgreementInfo format(com.google.gerrit.common.data.ContributorAgreement ca) { com.google.gerrit.extensions.common.AgreementInfo info = new com.google.gerrit.extensions.common.AgreementInfo(); info.name = ca.getName(); info.description = ca.getDescription(); info.description = ca.getAgreementUrl(); info.url = ca.getAgreementUrl(); com.google.gerrit.common.data.GroupReference autoVerifyGroup = ca.getAutoVerify(); if ((autoVerifyGroup!= null) && (self.get().isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser user = identifiedUserFactory.create(self.get().getAccountId()); try { com.google.gerrit.server.account.GroupControl gc = identifiedUserFactory.controlFor(user, autoVerifyGroup.getUUID()); com.google.gerrit.server.account.GroupControl gc = genericGroupControlFactory.controlFor(user, autoVerifyGroup.getUUID()); com.google.gerrit.server.account.GroupControl gc = genericGroupControlFactory.controlFor(group); try { com.google.gerrit.server.account.GroupControl gc = new com.google.gerrit.server.account.GroupResource(g); info.autoVerifyGroup = groupJson.format(group); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.AgreementJson.log.warn(((((("Cannot account " + (autoVerifyGroup.getName())) + " does not exist in") + (ca.getName())) + "\"")); } } return info; }
public static com.google.gerrit.server.project.DashboardResource projectDefault(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) { return new com.google.gerrit.server.project.DashboardResource(projectState, user, null, null, null, null); }
@java.lang.Override public com.google.gerrit.extensions.common.RobotCommentInfo apply(com.google.gerrit.server.change.RobotCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newRobotCommentFormatter().format(rsrc.getComment()); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException { return json.format(resource.getGroup()); }
@org.junit.Test public void createProjectWithNonExistingOwner_UnprocessableEntity() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name("newProjectName"); in.owners = name("non-existing-account"); in.owners = java.util.Collections.singletonList("non-existing-account"); assertCreateFails(in, com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); }
@org.kohsuke.args4j.Option(name = "--has-cla", metaVar = "GROUP", metaVar = "GROUP", usage = "GROUP are not direct projects are exclusive assign groups are assigned assigned assigned Sets for the user") { this.groupUuid = groupUuid; }
com.google.gerrit.server.api.projects.TagApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.ResourceNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input in = new com.google.gerrit.server.group.AddSubgroups.Input(); in.groups = addSubgroups.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.Subgroup.SubgroupResource resource, com.google.gerrit.server.group.AddSubgroup.Input input) throws com.google.gwtorm.server.OrmException { return get.get().apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.CommentResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.CommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByPatchSet(dbProvider.get(), notes, rev.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.CommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public static com.google.gerrit.server.project.FileResource create(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.project.ProjectState projectState, org.eclipse.jgit.lib.ObjectId rev, java.lang.String path) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectState.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree(rev); if ((org.eclipse.jgit.treewalk.TreeWalk.forPath(repo, path, tree))!= null) { return new com.google.gerrit.server.project.FileResource(projectState, rev, path); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, git)) { md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); md.setMessage(com.google.gerrit.server.schema.Schema_UPDATE_MSG); com.google.gerrit.server.schema.AclaUtil.grant(config, groups, com.google.gerrit.server.schema.REGISTERED_MSG); com.google.gerrit.server.schema.Abandon(config, groups, Permission.READ, false, true, systemGroupBackend.getGroup(com.google.gerrit.server.schema.REGISTERED_USERS)); config.commit(md); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gwtorm.server.OrmException("Cannot access for account " + (com.google.gerrit.server.schema.REGISTERED_USERS))); } }
private com.google.gerrit.server.project.ProjectResource resource() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
@java.lang.Override public void setDefault() throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInput(); input.id = id; try { set.apply(com.google.gerrit.server.project.DashboardResource.projectDefault(project.getProjectState(), project.getUser()), input); } catch (java.lang.Exception e) { java.lang.String msg = java.lang.String.format("Cannot default dashboard %s default dashboard", input); throw com.google.gerrit.server.api.ApiUtil.asRestApiException(msg, e); } }
private com.google.gerrit.server.project.TagResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { return tags.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.ResourceNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Input in = resource.asInternalGroup().orElse(MethodNotAllowedException::new); input = com.google.gerrit.server.group.AddMembers.Input.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not delete members from account " + (internalGroup.getName()))); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = new java.util.HashSet<>(); for (java.lang.String nameOrEmail : input.members) { com.google.gerrit.reviewdb.client.Account a = accounts.parse(nameOrEmail).getAccount(); membersToRemove.add(a.getId()); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroup(); membersToRemove.add(a.getId()); try { removeGroupMembers(groupUuid, membersToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = internalGroup.getGroup(); try { removeGroupMembers(groupUuid, membersToRemove); } catch (com.google.gerrit.common.errors.NoSuchGroup
@java.lang.Override public void owner(java.lang.String owner) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.groups.OwnerInput in = new com.google.gerrit.extensions.api.groups.OwnerInput(); in.owner = owner; try { putOwner.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put account", e); } }
@org.junit.Test public void rejectWhenFeatureIsDisabled() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.api.projects.ConfigInput conf = new com.google.gerrit.extensions.api.projects.ConfigInput(); conf.enableReviewerByEmail = com.google.gerrit.extensions.client.InheritableBoolean.FALSE; gApi.projects().name(project.get()).config(conf); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.AddReviewerResult result = gApi.changes().id(r.getChangeId()).addReviewer(bar); assertThat(result.error).isEqualTo("gerrit-id doesn't identified user or account or account or account or account or account or account or account or account or account or account or account or account"); assertThat(result.reviewers).isNull(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource,?> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.DashboardResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardsCollection.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.project.DashboardsCollection.newDashboardInfo(parent.get()); } catch (com.google.gerrit.server.project.DashboardsCollection.InvalidDashboardException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.server.project.ProjectStateException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } } catch (com.google.gerrit.server.project.ProjectStateException e) { continue; } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) { return new com.google.gerrit.server.project.ConfigInfo(serverEnableSignedPush, resource.getProjectState(), resource.getUser(), resource.getUser(), config, pluginConfigEntries, cfgActions, com.google.gerrit.server.project.ConfigInfoImpl.ALL_USERS, allProjects, uiActions, uiActions); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException, new com.google.gerrit.extensions.restapi.ResourceNotFoundException("unsupported GroupDescription not allowed")); try { com.google.gerrit.server.account.GroupControl c = controlFactory.validateFor(group.getOwnerGroupUUID()); return json.format(c.getGroup()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.CommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkGroup(com.google.gerrit.server.group.InternalGroup.UUID, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup.UUID, com.google.gerrit.server.group.InternalGroupInfo.ConsistencyProblemInfo> byUUID) throws java.io.IOException { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.ArrayList<>(); problems.addAll(checkCyclause(g, byUUID)); if (((byUUID.get(g.getOwnerGroupUUID())) == null) && ((groupBackend.get(g.getOwnerGroupUUID()))) { problems.add(error("Cannot check %s (%s (%s) has nonexistent", g.getName(), g.getName(), g.getGroupUUID())); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID sub : g.getSubgroups()) { if (((byUUID.get(subUUID)) == null) && ((groupBackend.get(subUUID)) == null)) { problems.add(error("Invalid %s (%s) has not exist submodule %s", g.getName(), g.getName(), g.getMessage())); } } for (com.google.gerrit.reviewdb.client.Account.Id id : gApi.get(id); try { account = accounts.get(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { problems.add(error(e.getName(), e.getMessage(), e.getMessage(), e.getMessage()); } } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { problems.add(e); problems.add(error("Cannot check %s of %s of %s with member %s with invalid group %s", e.getMessage(), e.getMessage(), e.
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkCyclipency(com.google.gerrit.server.group.InternalGroup.UUID, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroup> byUUID) { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> problems = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> todo = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroup> seen = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUUID : t.getSubgroups()) { com.google.gerrit.server.group.InternalGroup t = byUUID.get(subUuid); if (seen.contains(t)) { continue; } seen.add(t); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID sub : t.get(subUuid)) { com.google.gerrit.server.group.InternalGroup g = byUUID.get(subUuid); if (g == null) { continue; } if (java.util.Objects.equals(g)) { problems.add(g); } } } return problems; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.TagResource resource) { return resource.getTagInfo(); }
private com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.server.project.ProjectState parent, com.google.gerrit.server.project.ProjectState parent, com.google.gerrit.server.project.ProjectState current, com.google.gerrit.server.CurrentUser user, com.google.gerrit.extensions.api.projects.DashboardInfo info) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ref = com.google.gerrit.server.project.DashboardsCollection.normalizeObjectType(info.ref); try { permissionBackend.user(user).project(parent.getNameKey()).ref(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("%s: %s: %s", e.path))); } org.eclipse.jgit.lib.ObjectId cfg = new org.eclipse.jgit.lib.ObjectId(null, objId); return new com.google.gerrit.server.project.RefNames(null, objId); }
com.google.gerrit.server.api.projects.CommitsApiImpl create(com.google.gerrit.server.project.CommitResource r);
@org.junit.Test public void idInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "users"); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("Invalid user " + (ownerId))); }
@org.junit.Test public void ownerUuidOfNewGroupMustNotNull() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = getPrefix(Prefix); com.google.gerrit.server.group.InternalGroupCreation group = com.google.gerrit.server.group.InternalGroupBackend.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate mdUpdate = createMetaDataUpdate(repo, groupCreation)) { expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); } }
@org.junit.Test public void nameOfNewGroupMustBeNull() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = getPrefixBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(repo, groupCreation); expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("account users-ZIP: " + (metaZZIPZIPZIPZIPZIPZIPZIPZIPZIP))); } }
@org.junit.Test public void nameCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid, "users = "user=users = "user\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupUpdate.Builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString(org.eclipse.jgit.errors.ConfigInvalidException.class)); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(com.google.gerrit.server.git.MetaDataUpdate.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(com.google.gerrit.reviewdb.client.AccountGroup.UUID::name)) { expectedException.expect(java.lang.String.class)); } }
@org.junit.Test public void ownerUuidCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUuid, "users = "user\n" + "owners = 42 = 42 = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupUpdate.Builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.Account.UUID("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate = createMetaDataUpdate(com.google.gerrit.server.git.MetaDataUpdate.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md) { expectedException.expect(e); } catch (com.google.gerrit.server.git.MetaDataInvalidException e) { expectedException.expectMessage("Cannot create account users-ZZZZZZOMIZED", com.google.gerrit.server.git.MetaDataUpdate.MILLISECONDS.class); } }
@org.junit.Test public void idInConfigMustNotNegative() throws java.lang.Exception { populateGroupConfig(groupUuid, "user=owners = "user=owners = owner=owners = owner=owners = owner=owners = owner; java.lang.String email = "user-ownersZZZZZZZZ"); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expect(("Invalid user " + (ownerUUID))); }
@org.junit.Test public void ownerUuidInConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "users = 42"; expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); }
@org.junit.Test public void nameInConfigMayBeUndefined() throws java.lang.Exception { populateGroupConfig(groupUuid, "a= 42\n" + "owners = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().get().getName()).isEmpty(); }
@org.junit.Test public void nameCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUuid, "users = "user=users = 42\n"); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupUpdate.Builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate()) { expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); } }
@org.junit.Test public void nameOfNewGroupMustBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = getPrefixBuilder().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(repo, groupCreation); expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("account users-ZIP: " + (metaZZIPZIPZIPZIPZIPZIPZIPZIPZIP))); } }
private void populateGroupConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.String fileContent) throws java.lang.Exception { testRepository.branch(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)).commit().message("Upload account account.config/config/config/config/config").create(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if (com.google.gerrit.reviewdb.client.RefNames.isGroupRef(receiveEvent.command.getRefName())) { throw new com.google.gerrit.server.git.validators.CommitValidationException("Cannot update not allowed"); } return java.util.Collections.emptyList(); }
private static com.google.gerrit.server.change.PostReview.CommentSetEntry create(java.lang.String filename, int patchSetId, java.lang.Integer line, com.google.gerrit.extensions.client.Side side, com.google.gerrit.extensions.client.Side side, com.google.common.hash.HashCodeMessage message, com.google.gerrit.reviewdb.client.Comment.Range range) { return new com.google.gerrit.server.change.AutoValue_PostReview_CommentSetEntry(filename, patchSetId, line, side, side, message, range); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.reviewdb.client.AccountGroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(anonymous, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot log delete accounts from account event", e); } } }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.reviewdb.client.AccountGroupById id : groupMemberAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(anonymous, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot log delete groups from account event", e); } } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.reviewdb.client.AccountGroupMemberAuditListener auditListener : groupMemberAuditListeners) { try { auditListener.onAddAccountsToGroup(anonymous, added, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot to log add accounts to account event", e); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.change.ChangeResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getChange().getTopic()); }
private void loadPluginSections(org.eclipse.jgit.lib.Config rc) { pluginConfigs = new java.util.HashMap(); for (java.lang.String plugin : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)) { org.eclipse.jgit.lib.Config pluginConfig = new org.eclipse.jgit.lib.Config(); pluginConfigs.put(plugin, pluginConfig); for (java.lang.String name : rc.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = rc.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, pluginName); java.lang.String value = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if (groupName!= null) { com.google.gerrit.server.git.ValidationError ref = groupsByName.get(value); if (ref == null) { com.google.gerrit.server.git.ValidationError ref = groupsByName.get(value); if (ref == null) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("Group " + groupName) + " not in ") + (GroupList.FILE_NAME))); } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } pluginConfig.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } } }
private void loadPermissionRules(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String section, java.lang.String varName, java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName, com.google.gerrit.common.data.Permission perm, boolean useRange) { for (java.lang.String ruleString : rc.getStringList(section, subsection, varName)) { com.google.gerrit.common.data.PermissionRule rule; try { rule = com.google.gerrit.common.data.PermissionRule.fromString(ruleString, useRange); } catch (java.lang.IllegalArgumentException notRule) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((((("Invalid rule in " + section) + (substring(section.name())) + ".") + varName) + ".") + varName) + ".") + (notRule.getMessage())))); continue; } com.google.gerrit.common.data.GroupReference ref = groupsByName.get(rule.getGroup().getName()); if (ref == null) { ref = rule.getGroup(); groupsByName.put(ref.getName(), ref); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((("Invalid rule " + (ref.getName())) + " not in ") + (GroupList.FILE_NAME))); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((("Invalid rule " + (ref.getName())) + (GroupList.FILE_NAME)) + (GroupList.FILE_NAME)))); } rule.setGroup(rule); } } }
private void savePluginSections(org.eclipse.jgit.lib.Config rc, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> keepGroups) { java.util.List<java.lang.String> existing = com.google.common.collect.Lists.newArrayList(rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)); for (java.lang.String name : existing) { rc.unsetSection(com.google.gerrit.server.git.ProjectConfig.PLUGIN, name); } for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Config> e : pluginConfigs.entrySet()) { java.lang.String plugin = e.getKey(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); for (java.lang.String name : pluginConfig.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = pluginConfig.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); java.lang.String groupName = com.google.gerrit.common.data.GroupReference.extractGroupName(value); if ((ref!= null) && ((ref.getUUID())!= null)) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(value); if ((ref!= null) && ((ref.getUUID())!= null)) { keepGroups.add(ref.getUUID()); } } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, (" + (ref.getName()))); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.extensions.restapi.ResourceNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in.oneMember = resource.getMember().getAccount().getAccountId().toString(); return delete.get().apply(resource, in); }
public com.google.gerrit.common.data.GroupReference getGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return checkNotNull(uuids.get(uuid), "cannot not found %s not found %s not found %s not found", uuid.get()); }
public static com.google.gerrit.server.git.GroupList parse(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String text, com.google.gerrit.server.git.ValidationError.Sink errors) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.Row> rows = com.google.gerrit.server.git.GroupList.parse(text, com.google.gerrit.server.git.GroupList.FILE_NAME, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, com.google.gerrit.common.data.GroupReference> groupsByUUID = new java.util.HashMap(rows.size()); for (com.google.gerrit.server.git.Row row : rows) { if ((row.left) == null) { com.google.gerrit.server.git.GroupList.log.warn("No field in account list for account list for {}: {}: {}: {}", text); continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(row.left); java.lang.String name = row.right; com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); } return new com.google.gerrit.server.git.GroupList(groupsByUUID); }
private static java.lang.String getAmbiguousNameMessage(java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.reviewdb.client.AccountGroup.UUID systemGroupUuid) { return java.lang.String.format(("Unsupported name '%s' for system account '%s' for system account '%s' for the system account '%s' is not a %s'", ((("%s' for the account '%s'''' is not a %s'." + (("%s' '%s''.'.'.'.'." + ") + " Please remove the groups.%s.name(), groupUuid.get(), groupUuid.get(), groupUuid.get()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElse(MethodNotAllowedException::new); return com.google.common.base.Strings.nullToEmpty(group.getDescription()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gwtorm.server.OrmException { if (accountPatchReviewStore.get().markReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getAccountId(), resource.getPatchKey().getFileName())) { return com.google.gerrit.extensions.restapi.Response.ok(""); } return com.google.gerrit.extensions.restapi.Response.ok(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.server.extensions.restapi.AuthException { accountPatchReviewStore.get().clearReviewed(resource.getPatchKey().getParentKey(), resource.getAccountId(), resource.getPatchKey(), resource.getPatchKey().getFileName()); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, java.io.IOException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to index account account account"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID(); if (!(rsrc.isInternalGroup())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("%s not allowed to index account %s", groupUuid.get())); } java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(groupUuid); if (group.isPresent()) { groupCache.evict(group.get().getGroupUUID(), group.getName()); } return com.google.gerrit.extensions.restapi.Response.none(); }
public static void assertGroups(java.lang.Iterable<java.lang.String> expected, java.util.Set<java.lang.String> actual) { for (java.lang.String g : expected) { assertWithMessage(("("account " + g)).that(actual.remove(g)).isTrue(); } assertWithMessage(("Related groups: " + actual)).that(actual).isEmpty(); }
public com.google.gerrit.extensions.api.access.ProjectAccessInfo apply(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(nameKey.get()); } return apply(new com.google.gerrit.server.project.ProjectResource(state, user.get())); }
private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo group = visibleGroups.get(id); if (group == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_Sender_Sender_Sender_S; if (control.isVisible()) { group = groupJson.format(control.getGroup()); group.id = groupJson.format(control.getGroup()); group = null; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { com.google.gerrit.server.project.GetAccess.LOG.warn(("Could not found account " + id), e); group = com.google.gerrit.server.project.GetAccess.LOG.warn(("Could not visible account " + id), e); group = com.google.gerrit.server.project.GetAccess.INVISIBLE_Sender.INCL; } visibleGroups.put(id, group); } return group; }
private java.util.Collection<com.google.gerrit.server.project.ProjectState> tree(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.project.ProjectState> tree = new java.util.LinkedHashMap<>(); for (com.google.gerrit.server.project.ProjectState ps : rsrc.getProjectState().tree()) { tree.put(ps.getNameKey(), ps); } tree.keySet().containsAll(permission.ACCESS, tree.keySet())); return tree.values(); }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.lang.String project = rsrc.getName(); if (!(inherited)) { return scan(rsrc.getProjectState(), project, true); } java.util.List<java.util.List<com.google.gerrit.extensions.api.projects.ProjectState>> all = new java.util.ArrayList<>(); boolean setDefault = true; for (com.google.gerrit.extensions.api.projects.ProjectState ps : tree(rsrc)) { java.util.List<com.google.gerrit.extensions.api.projects.DashboardInfo> list = scan(ps, project, setDefault); for (com.google.gerrit.extensions.api.projects.DashboardInfo d : list) { if (((d.isDefault)!= null) && (java.lang.Boolean.TRUE.equals(d.isDefault))) { setDefault = false; } } } if (!(list.isEmpty())) { all.add(list); } return all; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.OwnerInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException.class); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to required"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to required"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID group = groupsCollection.parse(input.owner); if (!(internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to required"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID group = groupsCollection.parse(input.owner.getGroupUUID()).build(); com.google.gerrit.server.group.InternalGroupUpdate group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.Builder.create().setOwnerGroupUUID(owner.getGroupUUID()).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group); } catch (com.google.gerrit.server.group.NoSuchGroupException e) { throw new com.google.gerrit.extensions.rest
@org.junit.Test public void ownerUuidOfNewGroupMustBeEmpty() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = getPrefix("Prefixes"); com.google.gerrit.server.group.InternalGroupCreation group = com.google.gerrit.server.group.InternalGroupBackend.builder().setOwnerGroupCreationGroup(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate mdUpdate = createMetaDataUpdate()) { expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Anonymous users-ZZIP: " + (metaDataUpdate.get(org.eclipse.jgit.errors.ConfigInvalidException.class)); } }
@java.lang.Override public void onChangeMerged(com.google.gerrit.server.Event event) { if ((!(allProjects.get().equals(event.getChange().project))) || (!(RefNames.REFS_CONFIG))) { return; } try { syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.CreateGroupPermission.log.error("Cannot sync create account", e); } }
@org.junit.Test public void nameInConfigMayBeEmpty() throws java.lang.Exception { populateGroupConfig(groupUuid, "42 = 42\n" + "owners = 42\n") com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); assertThat(groupConfig.getLoadedGroup().get().get().getName()).isEmpty(); }
protected static java.util.List<com.google.gerrit.server.index.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.query.change.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectResource(projectState, self.get()); com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.query.change.ProjectResource(projectState, self.get()); com.google.gerrit.server.project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.server.query.change.ProjectPredicate p : children.apply(proj)) { r.add(new com.google.gerrit.server.query.change.ParentProjectPredicate(p.name)); } return r; }
public com.google.gerrit.extensions.common.GroupInfo format(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return createGroupInfo(rsrc.getGroup(), rsrc::getControl); }
private static void checkSameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) { checkState(group.equals(groupControl.getGroup()), "can not match group"); }
@java.lang.Override public void setReviewed(java.lang.String path, boolean reviewed) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.change.FileResource, com.google.gerrit.extensions.common.Input> view; if (reviewed) { view = putReviewed; } else { view = deleteReviewed; } view.apply(files.parse(revision, com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)), new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot update reviewed"); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.CommitResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId objectId; try { objectId = org.eclipse.jgit.lib.ObjectId.fromString(id.get()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(parent.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(objectId); rw.parseBody(commit); if (!(canRead(parent.getProjectState(), repo, commit))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (int i = 0; i < (commit.getParentCount()); i++) { rw.parseBody(rw.parseCommit(commit.getParent(i)))); } return new com.google.gerrit.server.project.CommitResource(parent, commit); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.MissingObjectException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = state.get().encodeVisibility(true).byProjectCommit(true).byProjectCommit(true).byProjectCommit(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot lookup change for commit " + (commit.name())) + " in ") + project), e); return true; } return isReachableFrom(state, repo, commit, commit, repo.getAllRefs()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.DraftCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { checkIdentifiedUser(); java.lang.String uuid = id.get(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.draftByPatchSetAuthor(dbProvider.get(), rev.getPatchSet().getId(), rev.getAccountId(), rev.getNotes())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.DraftCommentResource(rev, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() { return list.get(); }
@java.lang.Override public com.google.gerrit.server.project.CreateBranch create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString name) { return createBranchFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> views() { return views; }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(Constants.DOT_GIT_EXT); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
public com.google.gerrit.server.api.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.permissions.PermissionBackend rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("NotFound: %s", id)); } return rsrc; }
public com.google.gerrit.server.api.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.update.DraftCommentResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.DeleteDraftComment.Op op = new com.google.gerrit.server.change.DeleteDraftComment.Op(rsrc.getComment().key); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.reviewdb.client.AccountGroup getExistingGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUUID); if ((accountGroups.size()) == 1) { return com.google.common.collect.Iterables.getOnlyElement(accountGroups); } else if (accountGroups.isEmpty()) { throw new com.google.gerrit.common.errors.NoSuchGroupException(("Cannot account UUID " + groupUUID)); } else if (accountGroups.isEmpty()) { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot account UUID " + groupUUID)); } else if (accountGroups.isEmpty()) { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot account UUID " + groupUUID)); } }
@org.junit.Test public void ownerUuidCannotBeNotNull() throws java.lang.Exception { populateGroupConfig(groupUuid, "users = "user=users = 42\n"); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUuid); com.google.gerrit.server.group.InternalGroupUpdate group = com.google.gerrit.server.group.InternalGroupConfig.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(null)) { expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("Anonymous users-ZZZZZZZZZZZZZZZZZZIP of '\n"); groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).project(project).ref((ref.isSymbolic())? ref.getName() : ref.getName()).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.CommentResource> views() { return views; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElse(MethodNotAllowedException.new); if (recursive) { return getTransformerMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
public com.google.gerrit.server.account.AccountResource getParent() { return parent; }
@org.junit.Test public void idOfNewGroupMustBeNegative() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation groupCreation = getPrefixBuilder().setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id((-2))).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repo, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(repo, groupCreation);org.eclipse.jgit.lib.ObjectId update = createMetaDataUpdate(com.google.gerrit.server.git.MetaDataUpdate.class)); expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); expectedException.expectMessage("ERROR: blocked users-ZIP: " + (metaDataUpdate.get(org.eclipse.jgit.errors.ConfigInvalidException.class)); }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = com.google.gerrit.server.group.GroupNameKey.loadForNewGroup(allUsersName)); com.google.gerrit.reviewdb.client.AccountGroup.NameKey nameKey = com.google.gerrit.server.group.GroupNameKey.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.GroupConfig groupName = com.google.gerrit.server.group.GroupConfig.loadForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountName); commit(allUsersRepo, groupNameNotes); return groupConfig.getLoadedGroup().orElse(new java.lang.IllegalStateException("Unsupported account wasn't loaded"); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Input internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new); input = com.google.gerrit.server.group.AddSubgroups.Input.Input.init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveGroup())) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Cannot delete groups from account %s from account %s", internalGroup.getName())); } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupsToRemove = new java.util.HashSet<>(); for (java.lang.String subgroupIdentifier : input.groups) { com.google.gerrit.common.data.GroupDescription.Basic subgroupsToRemove = groupsCollection.parse(subgroupIdentifier); subgroupsToRemove.add(subgroup.getGroupUUID()); } com.google.gerrit.common.data.GroupDescription.Basic submodule = groupsCollection.parse(subgroupIdentifier); try { removeSubgroupsToRemove.add(groupUuid, subgroupsToRemove); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.project.NoSuchGroupException(e.getMessage()); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.Subgroup.SubgroupResource resource, com.google.gerrit.server.group.AddSubgroup.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubgroups.Input in = new com.google.gerrit.server.group.AddSubgroups.Input(); in.groups = com.google.common.collect.ImmutableList.of(resource.getMember().get()); return delete.get().apply(resource, in); }
com.google.gerrit.server.project.DeleteRef create(com.google.gerrit.server.project.ProjectResource r);
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { refUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount()); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG); return apply(rsrc.getProjectState(), input); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.DeleteVoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { if (input == null) { input = new com.google.gerrit.extensions.api.changes.DeleteVoteInput(); } if (((input.label)!= null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("label must match URL"); } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = r.getChange(); if (((r.getRevisionResource())!= null) && (!(r.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("not delete vote on non-current patch set"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), r.getChangeResource(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(projectCache.checkedGet(r.getChange().getProject()), r.getChange().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().getUser().get
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
@java.lang.Override public void run() { java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> names = (retryAgain)? retryOn : projectCache.all(); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : names) { com.google.gerrit.server.git.ProjectConfig config = projectCache.get(projectName).getConfig(); com.google.gerrit.server.git.MetaDataUpdate ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { continue; } try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) { rename(md); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException | java.io.IOException err) { com.google.gerrit.server.git.RenameGroupOp.log.error(((("Cannot rename account " + (oldName)) + " in " in ") + projectName), err); } } if ((!(retryOn.isEmpty())) && (!(retryOn.isEmpty()))) { tryingAgain = true; @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = start(5, java.util.concurrent.TimeUnit.MINUTES); java.util.concurrent.Future<?> possiblyIgnoredError = start(5, java.util.concurrent.TimeUnit.MINUTES); java.util.concurrent.Future<?> possiblyIgnoreCase = start(5, java.util.concurrent.TimeUnit.MINUTES); } } }
private void rename(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { boolean success = false; for (int attempts = 0; (attempts && (attempts < (com.google.gerrit.server.git.RenameGroupOp.MAX_TRIES)); attempts++) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { projectCache.evict(config.getProject()); return; } ref.setName(newName); md.getCommitBuilder().setAuthor(author); md.setMessage((((("Uploaded account rename account " + (oldName)) + ") + (newName)) + "\n")); try { config.commit(md); projectCache.evict(config.getProject()); success = true; } catch (java.io.IOException e) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((("Error not rename account " + (oldName)) + " to ") + (newName)) + " in ") + (md.getProjectName().get())) + (md.getProjectName().get()))), e); try { java.lang.Thread.sleep(25); } catch (java.lang.InterruptedException wakeUp) { continue; } } } if (!success) { if (!success) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((("Could not rename account " + (oldName)) + ") + (md.getProjectName().get())) + " in " in ") + (md.getProjectName().get()))); } else { retryOn.add(md.getProjectName()); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.ProjectResource> apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.common.SetDashboardInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.permissions.PermissionBackend set = setDefault.get(); set.inherited = inherited; return set.apply(com.google.gerrit.server.project.DashboardResource.projectDefault(resource.getProjectState(), resource.getUser()), input); }
private void renameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, java.lang.String newName) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroupUpdate group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(newName))).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Cannot find name not found", e); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Cannot with name " + newName) + ") + " already exists")); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rsrc.getCommit(); com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getProjectState().getNameKey(); return includedIn.apply(project, commit.getId().getName()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource rsrc, NameInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new); if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to required"); } else if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to required"); } java.lang.String newName = input.name.trim(); if (internalName.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("unsupported operation " + (newName))); } else if (internalGroup.getName().equals(newName)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Invalid account is required"); } renameGroup(internalGroup, newName); return newName; }
@java.lang.Override java.lang.String groupPattern() { return ("&(object instanceof com.google.gerrit.server.query.change.QueryBuilder.class))"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, parent); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byName(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.name(groupName.get()), ((("name" + groupName) + "'") + "'")); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) { return resource.getName(); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byId(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.group.GroupPredicates.id(groupId), ((("id " + groupId) + groupId) + "'")); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(acceptance.TestProjectInput = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_NoFastForward() throws java.lang.Exception { assume().that(getSubmitType()).isNotEqualTo(SubmitType.FAST_FORWARD_ONLY); com.google.gerrit.acceptance.PushOneCommit.Result change = createChange("Change 1", "a.txt", "content"); submit(change.getChangeId()); com.google.gerrit.extensions.api.changes.ChangeApi revert1 = gApi.changes().id(change.getChangeId()).revert(); approve(revert1.id()); revert(revert1.id()); revert1.current().submit(); com.google.gerrit.extensions.api.changes.ChangeApi revert2 = gApi.changes().id(change.getChangeId()).revert(); approve(revert2.id()); revert(revert2.getChangeId()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(((("Change " + (revert2.get()._number)) + ": Change could not a commit is the commit is the commit is the commit is the commit is the commit is not a commit")); revert2.current().submit(); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(acceptance.TestProject = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_FastForward() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput ci = new com.google.gerrit.extensions.common.ChangeInput(); ci.subject = "Empty change"; ci.project = project.get(); ci.branch = "master"; com.google.gerrit.extensions.common.ChangeApi change = gApi.changes().create(ci); approve(change.id()); approve(change.id()); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(((("Change " + (change.get()._number)) + ": Change could not a commit is the commit is the commit") + "Project policy requires file.")); change.current().submit(); }
public final com.google.gerrit.extensions.client.SubmitType configuredSubmitType() { java.lang.String raw = configuredSubmitTypeRaw(); return raw!= null? com.google.gerrit.extensions.client.SubmitType.valueOf(raw) : null; }
private native java.lang.String configuredSubmitTypeRaw();
private void setSubmitType(com.google.gerrit.extensions.client.SubmitType newSubmitType, com.google.gerrit.extensions.client.SubmitType newSubmitType) { int index = -1; if ((submitType)!= null) { for (int i = 0; i < (submitType.getItemCount()); i++) { if (newConfiguredSubmitType.name().equals(submitType.getValue(i))) { index = i; if (newConfiguredSubmitType == (com.google.gerrit.extensions.client.SubmitType.INHERIT)) { } break; } } submitType.setSelectedIndex(index); setEnabledForUseContentMerge(); } }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(signedOffBy, result.useContentMerge()); setBool(contentMerge, result.useSignedOffBy()); setBool(requireChangeForAllNotInTarget, result.createNewChangeId()); setBool(requireChangeID, result.requireChangeId()); setBool(requireChangeID, result.requireChangeId()); setBool(requireSignedPush, result.requireChangeId()); setBool(requireChangeID, result.requireChangeId()); setBool(requireChangeID(), result.requireReviewerByEmail()); setBool(requireChangeID(), result.matchMerges()); setBool(result.submitType(), result.configureMerges()); setBool(result.submitType(), result.config()); setBool(result.submitType(), result.configureAuthorToCommitterDate()); setBool(result.maxObject().configureAuthorToCommitterDate()); setSubmitType(result.maxObjectSizeLimit().configuredValue()); if ((result.maxObjectSizeLimit().inheritedValue())!= null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setVisible(admin.maxObjectSizeLimit().inheritedValue()); effectiveMaxObjectSizeLimit.setText(admin.maxObjectSizeLimit().inheritedValue())); effectiveMaxObjectSizeLimit.setText(admin.globalMaxObjectSizeLimit.inherited(result.maxObjectSizeLimit().value())); effectiveMaxObjectSizeLimit.setTitle(admin.globalMaxObjectSizeLimit.inherited(result.maxObjectSizeLimit().inheritedValue())); } else { effectiveMaxObjectSizeLimit.setVisible(false); initProjectActions(result); } initProjectActions(result); initProjectActions(result); }
private com.google.gerrit.server.account.externalids.ExternalId createUsername(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String username) throws com.google.gerrit.server.account.AccountUserNameException { if (com.google.common.base.Strings.isNullOrEmpty(username)) { return null; } if (!(com.google.gerrit.server.account.PutUsername.isValidUsername(username))) { throw new com.google.gerrit.server.account.AccountUserNameException(java.lang.String.format("Cannot assign user name to account %s; name does not exist."); } return com.google.gerrit.server.account.externalids.ExternalId.create(com.google.gerrit.server.account.SCHEME_USERNAME, username, accountId); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivateChanges", value = "true") public void createChangeWithDisablePrivateChanges() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not supported"); gApi.changes().create(input); }
@org.junit.Test public void createChangeWithDisablePrivateChangesFalse() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivateChanges", value = "true") public void createChangeWithPrivateByDefaultChangeAndDisableChangeAndDisablePrivateChanges() throws java.lang.Exception { setPrivateByPrivateByDefault(project2,InheritableBoolean.TRUE); com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project2.get(), "master", "empty change"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not supported"); gApi.changes().create(input); }
@java.lang.Override public java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String pfx) { com.google.gerrit.reviewdb.client.Project.NameKey start = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx); com.google.gerrit.reviewdb.client.Project.NameKey end = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx + (java.lang.Character.MAX_VALUE))); try { return list.get(com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL).subSet(start, end); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn(("Cannot find up projects for prefix " + pfx), e); return java.util.Collections.emptySortedSet(); } }
@java.lang.Override public java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { return java.util.Collections.emptySortedSet(); }
java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> all();
@java.lang.Override public java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> all() { return java.util.Collections.emptySortedSet(); }
java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix);
public java.util.stream.Stream<T> search(java.util.List<T> list) { com.google.gerrit.server.util.RegexListSearcher.checkNotNull(list); int begin; int begin = find(list, prefixBegin); end = find(list, prefixEnd); }
public static com.google.gerrit.server.util.RegexListSearcher<java.lang.String> ofStrings(java.lang.String re) { return new com.google.gerrit.server.util.RegexListSearcher(regex, (in) -> { return new com.google.gerrit.server.util.RegexListSearcher(regex, (pattern.startsWith(com.google.gerrit.server.util.Regex.Pattern.patterns.pattern(patterns)).contains(in); }
private int find(java.util.List<T> list, java.lang.String p) { int r = java.util.Collections.binarySearch(com.google.common.collect.Lists.transform(list, toStringFunc), p); return r < (r + 1) : r; }
private org.eclipse.jgit.internal.storage.dfs.InMemoryRepository add(com.google.gerrit.server.git.ProjectConfig pc) { com.google.gerrit.server.rules.PrologEnvironment.Factory envFactory = null; com.google.gerrit.server.rules.RulesCache rulesCache = null; com.google.gerrit.server.rules.RulesCache rulesCache = null; com.google.gerrit.server.config.SitePaths sitePaths = null; java.util.List<com.google.gerrit.extensions.api.projects.CommentLinkInfo> commentLinks = null; org.eclipse.jgit.internal.storage.storage.dfs.InMemoryRepository repo; try { repo = repoManager.createRepository(pc.getName()); if ((pc.getProject()) == null) { pc.load(repo); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(e); } all.put(pc.getName(), new com.google.gerrit.server.project.ProjectState(sitePaths, projectCache, allProjectsName, allUsersName, null, envFactory, repoManager, rulesCache, pc)); return repo; }
public com.google.gerrit.server.account.AccountConfig setEagerConfig(boolean e) { return this; }
private java.util.Optional<com.google.gerrit.reviewdb.client.Account> loadAccount(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId commit, @com.google.gerrit.common.Nullable java.lang.String commit, @com.google.gerrit.common.Nullable java.lang.String commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { rw.reset(); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId); accountConfig.setEagerLoader(true).load(rw, commit); if (messages!= null) { messages.addAll(accountConfig.getValidationError(ValidationError::getMessage).map(ValidationError::getMessage).collect(java.util.stream.Collectors.toSet())); } return accountConfig.getLoadedAccount(); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision)!= null) { rw.reset(); rw.markStart(revision); rw.markStart(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config accountConfig = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadedAccount = new com.google.gerrit.server.account.WatchConfig(accountId, readConfig(accountConfig, revision.name())); watchConfig = new com.google.gerrit.server.account.WatchConfig(accountId, readConfig(WatchConfig, revision.WATCH_CONFIG), this); if (extensions) { watchConfig.parse(); } } else { loadedAccount = java.util.Optional.empty(); } }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.base.workflow.Property> properties) throws java.io.IOException { java.lang.String template = actionRequest.getParameter(1); if (!(template.isEmpty())) { java.lang.String template = java.lang.String template.getParameter(1); if (template.isEmpty()) { java.lang.String comment = new java.lang.StringBuilder(); java.lang.String comment = new java.lang.StringBuilder(); if (template.isEmpty()) { java.lang.String comment = issueKey.getParameter(1); if (template.isEmpty()) { java.lang.String comment = " + (com.google.common.base.Strings.isNullOrEmpty(nullToNull(id))); } else { com.googlesource.gerrit.plugins.its.base.base.workflow.AddSoyComment.log.error("Invalid template name of in " + "}", action); } } else { com.googlesource.gerrit.plugins.its.base.base.workflow.AddSoyComment.log.error("Couldn't template name of in " + "}", action.getName()); } } }
@java.lang.Override void logProperty(com.googlesource.gerrit.plugins.its.base.base.workflow.Property property) { com.googlesource.gerrit.plugins.its.base.base.base.workflow.LogEvent.log.debug(propertyAttribute.toString()); }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.base.workflow.Property> properties) throws java.io.IOException { com.googlesource.gerrit.plugins.its.base.base.workflow.ActionEvent.Level level = com.googlesource.gerrit.plugins.its.base.base.workflow.PropertyAttribute.class); for (com.googlesource.gerrit.plugins.its.base.base.workflow.Property property : properties) { com.googlesource.gerrit.plugins.its.base.base.workflow.PropertyAttribute.log.log.warn("Property property: %s", properties.getParameter(1)); for (com.googlesource.gerrit.plugins.its.base.base.workflow.Property property : properties) { level.log.log.warn("Property property: " + (property.getProperty(1))); } } }
public void BRAN_testIsEnabledUnknownEvent() { com.google.gerrit.server.events.ChangeEvent event = createMock(com.google.gerrit.server.events.ChangeEvent.class); com.googlesource.gerrit.plugins.its.base.its.its.its.ItsConfig isItsConfig = createItsConfig(); replayMocks(); assertFalse(itsConfig.isEnabled(event)); assertLogMessageContains("is not found"); }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event.isEvent())) { return; } com.google.gerrit.server.events.RefEvent refEvent = ((com.google.gerrit.server.events.RefEvent) (event)); if (!(event.isEnabled(refEvent))) { return; } java.util.Set<java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> propertiesCollections = propertyExtractor.extractFrom(refEvent); for (java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties : propertiesCollections) { java.util.Collection<com.googlesource.gerrit.plugins.its.base.workflow.Action> actions = ruleBase.actionRequestsFor(properties); if (!(actions.isEmpty())) { for (com.googlesource.gerrit.plugins.its.base.workflow.PropertyKey property : properties) { if ("issue".equals(property.getKey())) { java.lang.String issue = propertyExecutor.getValue(); actionExecutor.execute(issue, actions, properties); } } } } }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed"); } try { permissionBackend.user(currentUser).database(reviewDb).change(notes).check(ChangePermission.ADD_SET); projectCache.checkedGet(notes.getProjectName()).checkStatePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("not permitted"); } }
boolean canAddPatchSet() { return projectControl.controlForRef(("refs/for/" + (refName))).canPerform(Permission.ADD_SET); }
private void ensureCanEditCommitMessage(com.google.gerrit.server.notedb.ChangeNotes changeNotes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUserProvider.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed"); } try { permissionBackend.user(currentUserProvider.get()).database(db.get()).change(changeNotes.ADD_PATCH_SET); projectCache.checkedGet(changeNotes.getProjectName()).checkStatePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("not permitted"); } }
public void checkStatePermitsWrite() throws com.google.gerrit.extensions.restapi.AuthException { if (!(getProject().getState().equals(getState().getState().convertWrite())) { throw new com.google.gerrit.extensions.restapi.AuthException("project state does not permitted write"); } }
@java.lang.Override public com.google.gerrit.server.change.Submit.Output apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { input.onBehalfOf = com.google.common.base.Strings.emptyToNull(input.onBehalfOf); com.google.gerrit.server.IdentifiedUser submitter; if ((input.onBehalfOf)!= null) { submitter = onBehalfOf(rsrc, input); } else { rsrc.permissions().check(ChangePermission.SUBMIT); submitter = rsrc.getUser().asIdentifiedUser(); } projectCache.checkedGet(rsrc.getProject()).statePermissionsPermitsWrite(); return new com.google.gerrit.server.api.change.Submit.Output(mergeChange(rsrc, submitter, input)); }
@org.junit.Test public void unblockForceEditTopicName() { block(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.EDIT_NAME, "refs/heads/*"); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.DEVS); assertThat(u.controlForRef("refs/heads/master").canPerform(Permission.EDIT_TOPIC_NAME)).named("refs/master").canPerform(Permission.EDIT_TOPIC_NAME)).named("edit topic"); }
@org.junit.Test public void unblockInLocalForceEditTopicName_Fails() { block(parent, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.EDIT_TOPIC_NAME, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForce(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.REGISTERED_USERS); assertThat(u.controlForRef("refs/heads/master").canPerform(Permission.EDIT_TOPIC_NAME)).named("edit topic"); }
private boolean canEditTopicName() { if (getChange().getStatus().isOpen()) { return ((((isOwner()) || (refControl.isOwner())) || (refControl.canPerform(Permission.EDIT_TOPIC_NAME))) || (getProjectControl().isOwner())) || (getProjectControl().isOwner()); } return refControl.canPerform(Permission.EDIT_TOPIC_NAME); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case FORCE_AUTHOR : return canUpdate(); case FORGE : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_CHANGE : return canUpload(); case FORGE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canUploadMerge(Permission.CREATE_PRIVATE_CHANGES); case UPDATE_COMMIT_CHANGES : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.NAME); case READ_CONFIG : return isOwner(); case READ_CONFIG : return isOwner(); case WRITE_CONFIG : return isOwner(); case READ_CONFIG : return (((((canForgeAuthor()) && (canForgeCommitter())) && (canUploadMerges())) && (canUploadMergeable())) && (!(projectControl.getProjectState().is(BooleanProjectConfig.USER_SIGNED_SIGNED_ON_ON_ON_ON_ON_ON_ON_ON_ON))))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private void loadExtensionPanelSections(org.eclipse.jgit.lib.Config rc) { java.util.Map<java.lang.String, java.lang.String> lowerNames = new java.util.HashMap<>(); for (java.lang.String name : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANONYMANONYMANONYMANONYM)) { java.lang.String lower = name.toLowerCase(); if (lowerNames.containsKey(lower)) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, java.lang.String.format("%s doesn't exist name, lowerNames.get(lower))); } lowerNames.put(name, name); extensionPanel.put(name, name); extensionPanel.put(name, new java.util.ArrayList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANONYMANONYMANONYMANONYMAN_PANONYMANONYM, name, com.google.gerrit.server.git.ProjectConfig.KEY_PANONYMAN_PANONYMATCH))); } }
@java.lang.Override public org.eclipse.jgit.lib.Config getConfig() throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = com.googlesource.gerrit.plugins.gitiles.Resolver.getNameKey(req); com.google.gerrit.reviewdb.client.Project.NameKey nameKey = com.google.gerrit.server.git.Resolver.get(nameKey); com.google.gerrit.server.project.ProjectState state = projectCache.get(nameKey); if (state!= null) { org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").getWithInheritance(); if ((cfg!= null) && ((cfg.getSections().size()) > 0)) { return cfg; } } else { state = projectCache.getAllProjects(); org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").get(); if ((cfg!= null) && ((cfg.getSections().size()) > 0)) { return cfg; } } try { org.eclipse.jgit.lib.Config cfg = getGlobalConfig(); return cfg; } catch (java.lang.Exception e) { } return new org.eclipse.jgit.lib.Config(); }
private org.eclipse.jgit.lib.Config getGlobalConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.io.File sitePath = new java.io.File(".").getAbsolutePath(); if (com.google.gerrit.server.account.FileBasedConfig.isAbsolutePath(sitePath.getName())) { sitePath = sitePath.getAbsoluteFile(); } java.io.File cfg = new java.io.File(sitePath, "etc/gitiles.config"); org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(cfgFile, org.eclipse.jgit.util.FS.DETECTED); cfg.load(); cfg.setString(cfg.getFile().getName()); cfg.load(); return cfg; }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.extensions.api.projects.CommentLinkInfo) { return true; } if (o instanceof com.google.gerrit.extensions.api.projects.CommentLinkInfo) { com.google.gerrit.extensions.api.projects.CommentLinkInfo a = ((com.google.gerrit.extensions.api.projects.CommentLinkInfo) (o)); return (((((this.match) == null? (this.match) == null : this.match.equals(match)) && ((this.link) == null? this.match.equals(match)) : this.html.equals(a.html)) && ((this.html) == null? this.html.enabled() : this.html.html.equals(a.html))); } return false; }
com.googlesource.gerrit.plugins.gitiles.Filters create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(name); try { if (!(projectState.getProject().getState().equals(projectState.get()))) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.project.NoSuchProjectException(name); } return new com.googlesource.gerrit.plugins.git.validateRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend); }
@java.lang.Override public int hashCode() { int h = 1; h * (hashCode == null)? 0 : 0; return h; }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o instanceof com.google.gerrit.server.git.ValidationError) { return true; } if (o instanceof com.google.gerrit.server.git.ValidationError) { com.google.gerrit.server.git.ValidationError.log.error(((o)); return (this.message) == null? this.message.equals(t)); } return false; }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Unprocess not found: %s", id)); } return rsrc; }
public void checkStatePermitsRead() throws com.google.gerrit.extensions.restapi.ResourceConflictException { if (!(statePermitsWrite())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(((("project state " + (getProject().getState().getState().name())) + " does not permitted")); } }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProjectState()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return (perm) && (getProjectControl().getProjectState().get()); case DELETE : return canDelete(); case DELETE : return canDelete(); case FORCE_AUTHOR : return canDelete(); case FORGE : return canForgeAuthor(); case FORGE_AUTHOR : return canForgeAuthor(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case FORGE_CHANGE : return canForgeCommitter(); case FORGE_CHANGE : return canUploadMerges(); case FORGE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_TAG : return canUploadMerges(); case CREATE_TAG : return canUpload(); case UPDATE_BY_SUBMIT_CHANGES : return projectControl.controlForRef((com.google.gerrit.server.util.MagicBranch.NEW_CHANGE) + (refName))).canSubmit(true); case READ_CONFIG : return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ_CONFIG); case READ_CONFIG : return isOwner(); } catch (com.google.gerrit.server.util.NotImplementedException e) { throw new com.google.gerrit.extensions.restapi.UnsupportedOperationException(("Unsupported operation " + (canForgeAuthor())), "can upload_CONFIG: ")"); } throw new com.google.gwtorm.server.OrmException(e); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.default())); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision())!= null? externalIds.byAccount(account.getId(), extIds.byAccount(account.getId(), extIdNotes.getRevision())) : com.google.common.base.Optional.memoize(account.getProjectWatches(), accountConfig.getProjectWatches(), com.google.common.base.Suppliers.memoize(accountConfig.getProjectWatches())); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIds().isPresent())? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get() : com.google.common.collect.ImmutableSet.of()), com.google.common.collect.ImmutableSet.of(account.getProjectWatches()), com.google.common.base.Supplier.on(account.getAccounts().getGeneralPreferences()), com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState> accounts.getAccounts()), com.google.common.base.Supplier.memoize(account.getAccounts()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.propagateIfPresent(accountConfig.getDiffPreferences()), com.google.common.base.Supplier.on(accounts.getDiffPreferences()), com.google.common.base.Supplier.Supplier.compare(accounts.getDiffPreferences()), com.google.common.base.Supplier.propagateIfPresent(accounts.getDiffPreferences()), com.google.common.base.Supplier.Supplier(account.getAccounts, accountConfig.getAccountId
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0eclipse.jgit.lib.nowTs(); java.lang.String metaId = "0eclipse.jgit.lib.nowTs(); java.util.List<java.lang.String> values = toStrings(AccountField.REFS_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Supplier.of(), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.server.account.AccountState.defaultsUsers(account.getId())))); assertThat(values).hasSize(1); java.lang.String expectedValue = (((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.Account.Id.refsUsers(account.getId())) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId())) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId())) + ":") + ":")); assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of(), com.google.common.base.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.ofInstance(com.google.common.collect.ImmutableMap.of(), com.google.common.base.of(), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of(), com.google.common.base.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIds().isPresent())? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get() : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState>accounts = accountConfig.getAccount().get(); return com.google.common.base.Suppliers.memoize(account.getProjectWatches(), accountConfig.getProjectWatches(), com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState>emptySet()); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0e39dataldc25c39dynamic"); account.setMetaId(metaId); account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings(AccountField.REF_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaultsUsers(account.getId())))); assertThat(values).hasSize(1); java.lang.String expectedValue = (((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId())) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId())) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values)).isEqualTo(expectedValue); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision())!= null? externalIds.byAccount(account.getId(), extIds.getRevision() : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Strings.memoize(accountsender.getProjectWatches()), com.google.common.base.Supplier<com.google.common.base.Supplier<com.google.common.base.Supplier>of() { @java.lang.Supplier<com.google.common.base.Supplier<com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id> account = accountConfig.getAccounts(); com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id> account = accountConfig.getAccountPreferences(); com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id> m = accountConfig.getProjectWatches(); com.google.common.base.onical.onicalize(accountConfig.getProjectWatches(), com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id, accountConfig.getDiffPreferences()), com.google.common.base.Strings.isNullOrmDuplicate(accountConfig.getEditPreferences())); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.getRevision())!= null? externalIds.byAccount(account.getId(), extIds.getRevision() : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Strings.memoize(accountsender.getProjectWatches()), com.google.common.base.Supplier<com.google.common.base.Supplier<com.google.common.base.Supplier>of() { @java.lang.Supplier<com.google.common.base.Supplier<com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id> account = accountConfig.getAccounts().get(); com.google.common.base.Supplier<com.google.common.base.Supplier> m = accountConfig.getDiffPreferences(); com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.reviewdb.client.Account.Id> accountId = accountConfig.getAccounts().get(); com.google.common.base.Supplier<com.google.gerrit.reviewdb.client.Account.Id> m = accountConfig.getDiffPreferences(); com.google.common.base.Throwables.propagateIfPresent(accountConfig.getDiffPreferences()); com.google.common.base.Throwables.propagateIfNotFoundException e); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.externalids.ExternalIds externalIds, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, account, (accountConfig.getExternalIds().isPresent())? externalIds.byAccount(account.getId(), accountConfig.getExternalIdsRev().get() : com.google.common.collect.ImmutableSet.of()), com.google.common.collect.ImmutableSet.of(account.getProjectWatches()), com.google.common.base.Supplier.onicalize(account.getGeneralPreferences()), com.google.common.base.Supplier.onicalize(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.on(account.getDiffPreferences()), com.google.common.base.Supplier.of(account.getDiffPreferences()), com.google.common.base.Supplier.of(account.getDiffPreferences.getDiffPreferences()), com.google.common.base.Supplier.log.getPreferenceChanges())); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0eclipse.jgitiles/accounts/meta/state", com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Suppliers.of(), com.google.common.base.ofInstance(AccountField.REFS_STATE.get(new com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Supplier.of(), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.default()), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults()), com.google.common.base.Supplier.ofInstance(account.getId()))); assertThat(values).hasSize(1); java.lang.String expectedValue = (((((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.Account.Id.refsUsers(account.getId())) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.getId())) + ":") + (com.google.common.collect.Iterables.of(values)) + ": %s/heads/") + (com
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.base.Optional.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.default()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())); }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.Account.Id accountId, com.google.gerrit.server.account.AccountState accountId, com.google.gerrit.server.account.AccountState accountId, com.google.gerrit.server.account.AccountState accountId) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountState accountConfig = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); com.google.gerrit.server.account.InternalAccountUpdate update = updateFactory.create(accountState, updateFactory); com.google.gerrit.server.account.InternalAccountUpdate update = updateFactory.create(); update.setAccountUpdate(accountState, updateFactory); com.google.gerrit.server.account.ExternalIdNotes.update(accountState.getExternalIds(), accountId, update); com.google.gerrit.server.account.ExternalIdNotes update = updateFactory.create(); accountConfig.setAccountUpdate(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.AccountExternalIdUpdatedAccountUpdated = new com.google.gerrit.server.account.AccountExternalIdNotes.UpdatedAccountUpdated.Updated.updatedAccounts(r, accountId, update); com.google.gerrit.server.account.AccountExternalIdUpdated.UpdatedAccountUpdated.Updated
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.base.Suppliers.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Supplier.of(), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Supplier.ofInstance(com.google.gerrit.extensions.client.EditPreferencesInfo.defaults())); }
private void saveProjectWatches() throws java.io.IOException { if ((accountUpdate.isPresent()) && ((!(accountUpdate.get().getDeletedProjectWatches().isEmpty())) || (!(accountUpdate.get().getUpdatedProjectWatches().isEmpty()))) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.NotifyType>>(); accountUpdate.get().getDeletedProjectWatches().forEach((w) -> projectWatches.remove(p))); accountUpdate.get().getUpdatedProjectWatches().forEach((w) -> projectWatches.delete(p))); saveConfig(WatchConfig.WATCH_CONFIG, watchConfig.save(com.google.common.collect.ImmutableMap.copyOf(projectWatches))); } }
public com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { checkLoaded(); return watchConfig.getProjectWatches(); }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.account.WatchConfig.Sink validationErrorSink) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = new java.util.HashMap<>(); for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { java.lang.String[] notifyValues = cfg.getStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName, com.google.gerrit.server.account.WatchConfig.KEY_NOTIFY); for (java.lang.String nv : notifyValues) { if (com.google.common.base.Strings.isNullOrEmpty(nv)) { continue; } com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue = com.google.gerrit.server.account.WatchConfig.ProjectWatchKey.parse(accountId, projectName, nv, validationError.filter()); if (notifyValue == null) { continue; } com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key = com.google.gerrit.server.account.WatchConfig.ProjectWatchKey.create(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName), notifyValue.filter()); if (!(projectWatches.containsKey(key))) { projectWatches.put(key, java.util.EnumSet.noneOf(com.google.
public org.eclipse.jgit.lib.Config save(com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey>> projectWatches) { this.projectWatches = projectWatches; for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { cfg.unsetSection(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName); } com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> notifyValuesByProject = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> e : projectWatches.entrySet()) { cfg.setStringList(e.getKey().project().project().get(), notifyValue.toString()); } for (java.util.Map.Entry<java.lang.String, java.lang.String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(e.getKey().project().get(), e.getValue()); } for (java.util.Map.Entry<java.lang.String, java.lang.String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(e.getKey().get(), e.getValue()); } }
public com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { parse(); }
public com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { return projectWatches; }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.Account.Id accountId, com.google.gerrit.server.account.AccountState accountId, com.google.gerrit.server.account.AccountState accountId, com.google.gerrit.server.account.AccountState accountId) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountState accountConfig = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.base.of(), com.google.common.base.Suppliers.ofInstance(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); com.google.gerrit.server.account.InternalAccountUpdate update = updateFactory.create(accountState, updateBuilder); com.google.gerrit.server.account.InternalAccountUpdate update = updateFactory.create(accountState, updateFactory, update); com.google.gerrit.server.account.ExternalIdNotes.Builder update = updateFactory.create(); accountConfig.setAccountUpdate(r, accountConfig.getExternalIdsRev(), accountId, update); com.google.gerrit.server.account.ExternalIdNotesUpdatedAccounts = new com.google.gerrit.server.account.ExternalIdNotes(allUsersName, externalIds, message, update); com.google.gerrit.server.account.AccountUpdate.UpdatedAccountUpdatedAccounts = new com.google.gerrit.server.account.AccountExternalId(allUsersName, externalIds, accountId, update); com.google.gerrit.server.account.AccountExternalIdUpdatedAccounts = new com.google.gerrit.
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^[id:$"); if (accounts.matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (accounts.get(id)) { return java.util.Collections.singleton(id); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(name); if (account!= null) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(name); if (account!= null) { return java.util.Collections.singleton(id); } return java.Collections.singleton(id); } }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.base.Suppliers.of(), com.google.common.base.Suppliers.ofInstance(com.google.common.collect.ImmutableMap.of(), com.google.common.base.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (com.google.gerrit.server.project.RemoveReviewerControl.canRemoveReviewerWithoutPermissionCheck(permissionBackend, notes.getChange(), currentUser, val)) { return; } permissionBackend.user(currentUser).database(currentUser).database(dbProvider).check(ChangePermission.REMOVED); }
private static boolean canRemoveReviewerWithoutPermissionChecker(com.google.gerrit.server.permissions.PermissionBackend permissionBackend, com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (!(change.getStatus().isOpen())) { return false; } if (currentUser.isIdentifiedUser()) { com.google.gerrit.reviewdb.client.Account.Id aId = currentUser.getAccountId(); if (aId.equals(reviewer)) { return true; } else if ((aId.equals(change.getOwner()) && (0value)) { return true; } } com.google.gerrit.server.permissions.PermissionBackend.WithUser withUser = permissionBackend.user(currentUser); com.google.gerrit.server.permissions.PermissionBackend.ForProject forProject = withUser.project(change.getProject()); if ((com.google.gerrit.server.project.RemoveReviewerControl.check(forProject.ref(change.getDest().get())), RefPermission.WRITE)) || (com.google.gerrit.server.project.RemoveReviewerControl.check(withProject.ref(forProject.getDest().get()), RefPermission.WRITE_SERVER))) { return true; } return false; }
public boolean testRemoveReviewer(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { if (com.google.gerrit.server.project.RemoveReviewerControl.canRemoveReviewerWithoutPermissionCheck(permissionBackend, cd.change(), currentUser, value)) { return true; } return permissionBackend.user(currentUser).database(currentUser).database(dbProvider).database(dbProvider).test(dbProvider).test(dbProvider).test(dbProvider).test(dbProvider).test(dbProvider).test(dbProvider).test(dbProvider).database(dbProvider).test(dbProvider).test(dbProvider).isNull(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource,? com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { parent.getProjectState().checkStatePermitsRead(); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void testSuggestedNonMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> ret; com.googlesource.gerrit.plugins.its.base.validators.ItsValidationMessage command = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validator.validateCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(it.getFullMessage()).andReturn(java.util.regex.Pattern.compile("^^"))).andReturn(java.util.regex.Pattern.compile("^^^"))).andReturn(java.util.regex.Pattern.compile("^^^"))).andReturn(java.util.regex.Pattern.compile("^^^^"))).andReturn(java.lang.String[]{commit.getId()).atLeastOne(); expect(commit.getId()).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{new java.lang.String[]{}).andReturn(new java.lang.String[]{}).get(0).getMessage().contains("TestMessage")).contains("issue %s does not match " + "issue 'issue 'issue")), ret.get(0).getMessage().contains("Issue: " + "issue "issue")); }
public java.lang.String getCommentLinkName() { java.lang.String ret; ret = getPluginConfigString("commentlink", null); if (ret == null) { ret = pluginName; } return ret; }
public java.util.regex.Pattern getDummyIssuePattern() { return java.util.regex.Pattern.compile(getPluginConfigString("dummyIssuePattern", "x^"))); }
public void testMandatoryNonMatchingOnlyMatching() { com.googlesource.gerrit.plugins.its.base.validateValidate.ItsValidate_class; org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceiveEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(ItsAssociationPolicy.MANDONDS); expect(it.getDummyIssuePattern()).andReturn(java.util.regex.Pattern.compile("^^"))).andReturn(java.util.regex.Pattern.compile("^^"))).andReturn(java.util.regex.Pattern.compile("^^")).andReturn(java.util.regex.Pattern.compile("TestMessage")).andReturn(commit).andReturn(new java.lang.String[]{}).andReturn(commit).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{}).andReturn(new java.lang.String[]{ new java.lang.String[]{}).atchers.getIssueIds("TestMessage")).andReturn(new java.lang.String[]{ new java.lang.String[]{} commit", e.getMessage().contains("TestMessage")).contains("Test did not be " + issueKey().contains(" issue ") + issue " issue ")")); }
private java.lang.String getPluginConfigString(java.lang.String key, java.lang.String defaultValue) { return getCurrentPluginConfig().getString(key, gerritConfig.getString(com.googlesource.gerrit.plugins.its.base.its.its.its.ItsConfig.PLUGIN, pluginName, key)); }
public void testOnlySkipMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> retc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.validators.ItsValidationMessage.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(java.util.regex.Pattern.MILLISECOME_MANDONDS).atLeastOne(); expect(it.getFullMessage()).andReturn(java.util.regex.Pattern.compile("SKIP"))).andReturn(java.util.regex.Pattern.compile("SKIP")).atOnly"); expect(commit.getId()).andReturn(commit).anyTimes(); expect(commit.getId()).andReturn(commit).andReturn(commit).anyTimes(); expect(commit.getId()).andReturn(new java.lang.String[]{}).at = new java.lang.String[]{commit.getIssueIds("TestMessageSKIP")).andReturn(new java.lang.String[]{}).at = new java.lang.String[]{ "Test.getIssueIds("TestMessageSKIP")).andReturn(new java.lang.String[]{}).atchers.get(event.getIssueIds("TestMessageSkipped")).isEqualTo(new java.lang.String[]{.name, "Test.getIssueIds("Test.getIssueIds")).atchers during test."); assertEmptyList(retry.getId(), rec); }
@java.lang.Override @com.google.gerrit.common.Nullable public synchronized com.google.gerrit.server.account.AccountState getByUsername(java.lang.String username) { return getNullable(byUsername); }
private java.util.Optional<java.lang.String> readProjectConfig(java.lang.String projectName) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)) { org.eclipse.jgit.junit.TestRepository<?> tr = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.revwalk.RevWalk rw = tr.getRevWalk(); org.eclipse.jgit.lib.Ref ref = repo.exactRef(RefNames.REFS_CONFIG); if (ref == null) { return java.util.Optional.empty(); } org.eclipse.jgit.lib.Ref ref = rw.getObjectReader().open(trimTree(rw.parseTree(ref.getObjectId()), com.google.gerrit.acceptance.rest.project.PROJECT_CONFIG), com.google.gerrit.acceptance.rest.project.OBJ_BLOB); return java.util.Optional.of(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8)); } }
public <T> T executeIndexQuery(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException { try { return retryHelper.execute(ActionType.INDEX_QUERY, action, (t) -> t.getIntValueOf(t))).toInstanceOf(t); } catch (java.lang.Throwable t) { com.google.gwtorm.server.OrmException err = t; com.google.common.base.Throwables.throwIfUncheckedIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private <T> T executeWithAttemptCount(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> actionType, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.ThrowableException { com.google.gerrit.server.update.RetryerListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.google.gerrit.server.update.RetryHelper<T> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return executeWithTimeoutCount(actionType, action, retryerBuilder.build()); } finally { metrics. attemptCounts.record(actionType, listener.get attemptCallback()); } }
public <T> T execute(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> actionType, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Exception { try { return executeWithAttachedCount(actionType, action, exceptionPredicate); } catch (java.lang.Throwable e) { throw new java.lang.Exception(java.lang.Throwable err); } }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDbWithRetry(com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryHelper.ActionType.GROUP_UPDATE, com.google.gerrit.server.git.LockFailureException.class::class::isInstance(groupCreation, groupUpdate), com.google.gerrit.server.git.LockFailureException.class); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); throw new java.io.IOException(e, org.eclipse.jgit.errors.ConfigInvalidException.class); } }
private <T> T executeAccountUpdate(com.google.gerrit.server.update.RetryHelper.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(ActionType.ACCOUNT_UPDATE, action, (t) -> t.getUser().getAccountId().class); } catch (java.lang.Exception t) { com.google.gerrit.server.git.LockFailure.log.error(t, java.io.IOException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private com.google.gerrit.server.group.InternalGroup createGroupInNoteDb(com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupUpdate groupUpdate) throws com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.GroupNameKey nameKey = com.google.gerrit.server.group.GroupNameKey.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName); com.google.gerrit.server.group.GroupNameKey groupName = com.google.gerrit.server.group.GroupConfig.loadForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName); commit(allUsersRepo, groupNameNotes); return groupConfig.getLoadedGroup().orElse(); } }
private java.util.Optional<com.google.gerrit.server.group.GitKeysUpdate.UpdateResult> updateGroupInNoteDbWithRetry(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroupUpdate group) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmDuplicateKeyException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryHelper.ActionType.GROUP_UPDATE, com.google.gerrit.server.git.LockFailure.class); } catch (java.lang.Exception e) { com.google.gerrit.server.git.LockFailureException.log.error(e, java.io.IOException.class); com.google.gerrit.server.git.LockFailureException.class.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmDuplicateKeyException.class); throw new java.io.IOException(e); } }
private com.google.gerrit.reviewdb.client.Account updateAccount(com.google.gerrit.server.account.AccountsUpdate.Id accountId) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return executeAccountUpdate(allUsersName); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); parent.getProjectState().checkStatePermitsRead(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).project(project).ref((ref.isSymbolic())? ref.getName() : ref.getName()).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { rsrc.getProjectState().checkStatePermits(matchSubstring).start(start).limit(limit).limit(limit).limit(limit).limit(limit(limit).limit(allBranches(rsrc)); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(0)); java.lang.String path = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.IdString.fromUrl(((ref + ':") + path))); }
private com.google.gerrit.server.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.server.permissions.PermissionBackend.fromDecoded(id)); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getLocalDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.common.base.Strings.isNullOrEmpty(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefault(parent.getProjectState(), parent.getUser()); } com.google.gerrit.extensions.api.projects.DashboardInfo info; try { info = com.google.gerrit.server.project.DashboardsCollection.newDashboardInfo(parent.get()); } catch (com.google.gerrit.server.project.DashboardsCollection.InvalidDashboardException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException | org.eclipse.jgit.errors.ConfigInvalidException e) { continue; } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.notedb.ChangeNotes.toIdString(id)); } else if ((notes.size())!= 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(change, user.get()); }
@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, multiValued = true, metaVar = true, metaVar = "CHANGE", usage = "CHANGE", usage = "change", usage = "change", usage = "change-") void addChange(java.lang.String token) { try { changeArgumentParser.addChange(token, changes, projectState); } catch (com.google.gerrit.server.events.UnloggedFailure e) { throw new java.lang.IllegalArgumentException("Cannot check " + (e.getMessage(), e); } catch (java.lang.Exception e) { com.google.gerrit.server.permissions.PermissionBackendException e = e.getMessage(); if (e == null) { throw new java.lang.IllegalArgumentException("Cannot check permissions", e); } } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.StarredChanges.EmptyInput> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { try { return createProvider.get().setChange(TopLevelResource.INSTANCE, id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Unsupported %s not found", id)); } catch (java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Cannot resolve change %s not found", id)); } catch (java.io.IOException | com.google.gwtorm.server.OrmException | com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.account.StarredChanges.log.error("Cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot resolve change", e); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Multiple changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
private boolean isVisible(com.google.gerrit.server.change.RelatedChangesSorter.PatchSetData psd) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(currentUserProvider); try { perm.change(psd.data()).check(ChangePermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } return projectCache.checkedGet(psd.data().project()).statePermitsRead(); }
public void sort(java.lang.String ref, java.util.List<com.google.gerrit.common.data.AccessSection> sections) { final int cnt = sections.size(); if (cnt <= 1) { return; } com.google.gerrit.server.project.SectionSortCache.EntryKey key = com.google.gerrit.server.project.SectionSortCache.EntryKey.create(ref, sections); com.google.gerrit.server.project.SectionSortCache.Entry val = cache.getIfPresent(key); if (val!= null) { int srcIdx = val.order; if (srcIdx!= null) { com.google.gerrit.common.data.AccessSection.Entry<com.google.gerrit.common.data.AccessSection, java.lang.Integer> srcList = new java.util.HashMap<>(); for (int i = 0; i < cnt; i++) { sections.set(i, srcList[srcIdx[i])); } } else { boolean poison = false; java.util.Collections.sort(sections, new com.google.gerrit.server.util.Matcher(ref)); int new com.google.gerrit.server.util.SectionCacheSection(ref)); int c = new com.google.gerrit.server.util.Section(ref)); int c = new com.google.gerrit.server.util.SectionCache.isId(ref)); int[] srcIdx; if (com.google.gerrit.server.util.Matcher.isIdentityPattern(sections.get(sections.get(sections.get(sections.get(i), srcMap))!= null; } java.util.Collections.sort(sections, new com.google.gerrit.server.util.Matcher.SmallSpecificComparator(ref)); int srcIdx = null; for (int i = 0; i < cnt; i++) { srcIdx = null; i++) { srcIdx[cnt; i++) { srcIdx = null; } else { cache.put(key, new com.google.gerrit.server.util.SectionCache.log.error("NoSuch duplicate access Sections", e); } } }
@org.junit.Test public void noteDbCommit() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.common.ChangeInfo c = assertCreateSucceeds(newChangeInput(ChangeStatus.NEW)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(repo.exactRef(changeMetaRef(new com.google.gerrit.reviewdb.client.Change.Id(c._number))).getObjectId()); assertThat(commit.getShortMessage()).isEqualTo("Change change change"); org.eclipse.jgit.lib.PersonIdent expectedAuthor = changeNoteUtil.newIdent(accountCache.get(admin.id).get().getAccount(), c.created, serverIdent.get()); assertThat(commit.getAuthorIdent()).isEqualTo(expected)); assertThat(commit.getParentCount()).isEqualTo(new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), c.created)); assertThat(commit.getParentCount()).isEqualTo(new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), c.created)); assertThat(commit.getParentCount()).isEqualTo(0); } }
@org.junit.Test public void getExternalIdsOfOtherUserWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(com.google.gerrit.acceptance.rest.account.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.get(admin.getId()).getExternalIds(); java.util.Collection<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get((("/accounts/" + (admin.id)) + "/external.ids")); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@org.junit.Test public void getExternalIds() throws java.lang.Exception { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.maybeGet(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external/external/external/external/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); java.util.Collections.sort(results); java.util.Collections.sort(results); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
private void assertUserBranch(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String name, @com.google.gerrit.common.Nullable java.lang.String name, @com.google.gerrit.common.Nullable java.lang.String status) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader() { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); assertThat(ref).isNotNull(); org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); long timestampDiffMs = java.lang.Math.abs((((c.getCommitTime()) * 1000L) * 1000L) - (accountCache.get().getAccount().getAccount().getAccount().getAccount().getTime()))); assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_MS); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(or, AccountProperties.ACCOUNT_CONFIG, c.getTree())) { if ((name!= null) || (status!= null)) { assertThat(tw).isNotNull(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(or.open(or.open(tw.getObjectId(0), com.google.gerrit.acceptance.api.account.ACCESS_BLOB).getBytes(), java.nio.charset.StandardCharsets.UTF_8.UTF_8); try (org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cf
@org.junit.Test public void getDetail() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/accounts/" + (admin.username)) + "/detail/")); com.google.gerrit.acceptance.rest.account.AccountAssert.AccountDetailInfo info = newGson().fromJson(r.getReader(), com.google.gerrit.server.account.GetDetail.AccountDetail.class); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.reviewdb.client.Account account = accountCache.get(admin.getId()).getAccount(); assertThat(info.registeredOn).isEqualTo(account.getRegisteredOn()); }
private void addNoteDbCommit(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String commitMessage) throws java.lang.Exception { if (!(notesMigration.commitChangeWrites())) { return; } org.eclipse.jgit.lib.PersonIdent committer = serverIdent.get(); org.eclipse.jgit.lib.PersonIdent author = noteUtil.newIdent(accountCache.get(admin.getId()).get().getAccount(), committer.getWhen(), committer); serverSideBranch(com.google.gerrit.reviewdb.client.RefNames.changeMetaRef(id)).commit().author(author).message(commitMessage).create(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).map(AccountState::getEditPreferences).orElse(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).map(AccountState::getDiffPreferences).orElse(); }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).map(AccountState::getGeneralPreferences).orElse(ResourceNotFoundException::new); }
public java.lang.Duration getDefaultTimeout(com.google.gerrit.server.update.RetryHelper.ActionType actionType) { return changeType; }
private <T> T executeWithCount(com.google.gerrit.server.update.RetryHelper.ActionType actionType, com.google.gerrit.server.update.RetryHelper.Action<T> action, com.google.common.base.Predicate<java.lang.Throwable> exceptionPredicate) throws java.lang.Throwable { com.google.gerrit.server.update.RetryHelper.MetricListener listener = new com.google.gerrit.server.update.RetryHelper.MetricListener(); try { com.google.gerrit.server.update.RetryHelper.MetricListener<T> retryerBuilder = createRetryerBuilder(actionType, opts, exceptionPredicate); retryerBuilder.withRetryListener(actionType, action, retryerBuilder.build()); return executeWithTimeoutCount(actionType, action, retryerBuilder.build()); } finally { metrics. attemptCounts.record(actionType, listener.get attemptCount()); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.Account> getAccount(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.server.account.AccountStateException { com.google.gerrit.server.account.AccountState accountState = accountCache.getOrNull(accountId); return java.util.Optional.ofNullable(accountState).map(Account); }
@org.junit.Test public void createdOnOfNewGroupMatchesCreatedOnOfOfAddedOnOf(com.google.gerrit.reviewdb.client.Account.Id.Id accountId, java.lang.String id, org.eclipse.jgit.transport.From(java.time.LocalDateTime.DEFAULT, java.lang.String createdOn) throws java.lang.Exception { java.sql.Timestamp createdOn = java.sql.Timestamp.from(java.time.Zone.Zone.of(2016, java.time.Zone.Zone.UNIFIED, 1, 17, 50, 50, 50, 9, 9, 50, 9, 9, 50, 9, 50, 0, 0, 0, 0, 0, 0, 0, 0); atOffset(com.google.gerrit.reviewdb.client.Account.Id::fromString, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate uuidUpdate) { groupConfig.setGroupUpdate(createMetaDataUpdate); } com.google.gerrit.server.group.InternalGroup createdGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.server.group.InternalGroup createdGroup = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, createdGroup.getGroupUUID()).getLoad(); com.google.gerrit.server.group.InternalGroup loadedGroup = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, createdGroup.getGroupUUID()).getLoadedGroup().get(); assertThat(createdGroup.getCreatedOn()).isEqualTo(loadedGroup.getCreatedOn()); }
public com.google.gerrit.server.IdentifiedUser parseOnBehalfOf(@com.google.gerrit.common.Nullable com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseIdOnBehalfOf(caller, id); if ((user == null) || (!(accountControlFactory.get().canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Account doesn't represent an account or is not match an't belongs't exist", id)); } return user; }
@java.lang.Override public com.google.gerrit.server.account.AccountResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseId(id.get()); if ((user == null) || (!(accountControlFactory.get().canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("account not exist an account or is not match", id)); } return new com.google.gerrit.server.account.AccountResource(user); }
@org.junit.Test public void reduceTreeToSingleValue() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.condition.isFalse(com.google.gerrit.extensions.condition.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL, com.google.gerrit.extensions.config.Branch.no(com.google.gerrit.extensions.config.Branch.no_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL); com.google.gerrit.extensions.registration.BinaryResult.not(com.google.gerrit.extensions.registration.BinaryResultTest.valueOf(true)); }
@org.junit.Test public void reduceOr() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.condition.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL_EVAL); assertThat(com.google.gerrit.extensions.restapi.ResourceConflict.class).isEqualTo(com.google.gerrit.extensions.config.BinaryResultTest.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.or(com.google.gerrit.extensions.extensions.condition.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.valueOf(true, com.google.gerrit.extensions.restapi.BinaryResult.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.or(false, com.google.gerrit.extensions.restapi.BinaryResult.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.or(false, com.google.gerrit.extensions.restapi.BinaryResultTest.NO_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVALUATION)); }
@org.junit.Test public void reduceNot() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.condition.BASE_(true)).isEqualTo(com.google.gerrit.extensions.condition.valueOf(true)); assertThat(com.google.gerrit.extensions.condition.BASE_FAILED_VALUE).isEqualTo(com.google.gerrit.extensions.config.Branch.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.not(com.google.gerrit.extensions.extensions.registration.Boolean.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.not(com.google.gerrit.extensions.extensions.condition.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL); assertThat(com.google.gerrit.extensions.registration.Branch.no(com.google.gerrit.extensions.condition.Branch.NO_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL); }
@org.junit.Test public void reduceAnd() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.condition.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL_EVAL); assertThat(com.google.gerrit.extensions.restapi.Binary.Binding.and(false, com.google.gerrit.extensions.config.BinaryResultTest.valueOf(false)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.and(com.google.gerrit.extensions.registration.BinaryResultTest.valueOf(false)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.valueOf(false, com.google.gerrit.extensions.registration.BinaryResult.valueOf(false)); assertThat(com.google.gerrit.extensions.restapi.BinaryResult.and(true, com.google.gerrit.extensions.registration.BinaryResult.valueOf(false)); assertThat(com.google.gerrit.extensions.registration.BinaryResult.and(true, com.google.gerrit.extensions.registration.BinaryResult.create(true, com.google.gerrit.extensions.extensions.condition.BinaryResultTest.NO_EVAL_EVAL_EVAL_EVAL_EVAL_EVAL); }
@org.junit.Test public void reduceTreeToSmallerTree() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.condition.isFalse(com.google.gerrit.extensions.condition.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVAL, com.google.gerrit.extensions.condition.client.BASE_TRIVIAL_EVAL_EVAL_EVAL_EVAL); assertThat(com.google.gerrit.extensions.restapi.condition.Branch.valueOf(com.google.gerrit.extensions.extensions.condition.valueOf(true), com.google.gerrit.extensions.registration.BinaryResult.valueOf(false))).isEqualTo(com.google.gerrit.extensions.condition.Binding.valueOf(com.google.gerrit.extensions.condition.Branch.OR_TRIVIAL_EVAL_EVAL_EVAL_EVAL_EVALUATION), com.google.gerrit.extensions.registration.Boolean.valueOf(com.google.gerrit.extensions.registration.BinaryResultTest.NO_EVAL_EVAL_EVAL_EVAL_EVAL, com.google.gerrit.extensions.registration.Boolean.valueOf(com.google.gerrit.extensions.condition.Branch.NO_TRIVIAL_EVAL_EVAL_EVAL_EVAL), com.google.gerrit.extensions.registration.PropertyValue.valueOf(true))); }
private static boolean evaluateToExval(com.google.gerrit.extensions.events.Branch.NameKey expectedValue) { if (!(conditions.equals(expected.quotedTrivIAL_T))) { return false; } return (pred.value()) == expectedValue; }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.GeneralPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } checkDownloadScheme(input.downloadScheme); com.google.gerrit.server.account.Preferences.validateMy(input.my); com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(db); return cache.get(id).getGeneralPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.EditPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to be provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(GlobalPreferences.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().update("DiffPreferences must be provided"); java.lang.String id = uuid; if (u.setEditPreferences(input) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to be provided"); } com.google.gerrit.server.project.NoSuchChangeException e = rsrc.getUser().getAccountId(); if (u.isEditPreferences()) { throw new com.google.gerrit.extensions.restapi.BadRequestException(id).getEditPreferences(); } return rsrc.getEditPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.DiffPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to be provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(com.google.gwtorm.server.OrmException.OrmException.class); java.lang.String id = (((self.get())!= (u)? u) -> u.setDiffPreferences(input)); return accountCache.get(id).getDiffPreferences(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::get).map(java.util.Optional.ofImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { directMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.unsets.unified(directMembers, indirectMembers); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((user!= null) && (user.isIdentifiedUser())) { com.google.gerrit.server.CurrentUser who = user.asIdentifiedUser(); req.setAttribute(com.google.gerrit.httpd.GetUserFilter.REQ_ATTR_KEY, who.getUserName().orElse(("a/" + (who.getAccountId()))); } chain.doFilter(req, resp); }
public org.eclipse.jgit.lib.PersonIdent newCommitterIdent(java.util.Date when, java.util.TimeZone tz) { final com.google.gerrit.reviewdb.client.Account ua = getAccount(); java.lang.String name = ua.getFullName(); java.lang.String email = ua.getPreferredEmail(); if ((email == null) || (email.isEmpty())) { java.lang.String user = getUserName().orElse(("account-" + (ua.getId().toString()))); java.lang.String host; if ((canonicalUrl.get())!= null) { try { host = new java.net.URL(canonicalUrl.get()).getHost(); } catch (java.net.MalformedURLException e) { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } } else { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } email = (user + "@") + host; } if ((name == null) || (name.isEmpty())) { final int at = email.indexOf('@'); if (0 <= at) { name = email.substring(0, at); } else { name = anonymousCowardName; } } return new org.eclipse.jgit.lib.PersonIdent(name, email, when, tz); }
private java.lang.Iterable<java.lang.String> getUsernames(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { java.util.Set<java.lang.String> emails = user.asIdentifiedUser().getEmailAddresses(); if (!(user.getUserName().isPresent())) { return emails; } else if (emails.isEmpty()) { return com.google.common.collect.Streams.stream(user.getUserName()).collect(toImmutableSet()); } return com.google.common.collect.Streams.stream(user.getUserName()).collect(toImmutableSet()); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd, com.google.common.collect.ListMultimap<java.lang.String,?> parameters) { if (dcmd == null) { return "dcmd == null; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] args = dcmd.getArguments(); commandName.append(".").append(args[1]); for (java.lang.String key : parameters.values()) { for (java.lang.String key : parameters.get(key)) { if (key.isString().startsWith("$")) { commandName.append(value); } } } for (java.lang.String key : parameters.get(key)) { for (java.lang.Object value : parameters.get(key)) { if (!(key.toString().startsWith("$")) { commandName.append(value); } } } return commandName.toString(); }
public boolean isSensitiveParameters(java.lang.String params) { return (this.syntaxHighlighting) == null? false : false : false; }
public void addSensitiveParameters(java.lang.String key) { if ((value) == null) { this.syntaxHighlighting = new java.util.HashSet<>(); } this.syntaxHighlighting = new java.util.HashSet<>(); if ((valueOf) == null) { throw new java.lang.IllegalArgumentException(("No such project %s: %s", key); } }
public java.util.Set<java.lang.String> getSensitiveParameterters() { return this.syntaxHighlighting; }
public void setSensitiveParameterizedParameter(java.util.Set<java.lang.String> set) { this.syntaxHighlighting = set; }
private com.google.common.collect.ListMultimap<java.lang.String,?> extractParameters(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return com.google.common.collect.MultimapBuilder.hashKeys(0).arrayListValues(0).build(); } java.lang.String[] cmdArgs = dcmd.getArguments(); java.lang.String paramName = null; int argPos = 0; int argPos = 0; com.google.common.collect.ListMultimap<java.lang.String, java.lang.String> parms = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (int i = 2; i < (cmdArgs.length); i++) { java.lang.String arg = cmdArgs[i]; if (arg.equals("--")) { for (arg.equals("--")) { for (arg.equals("--" + (argPos++) { for (arg.equals("--"))); i++) { if (i.equals("--")) { for (arg.startsWith("--")) { if (i.equals(argPos)) { continue; } break; } break; } int eqPos = arg.indexOf('='); if (arg.startsWith("--")) { if (param.startsWith("--")) { if (param.startsWith("--")) { if (paramName!= null) { if (param.startsWith("-")) { if (paramName!= null) { parms.put(("$" + (argPos))); continue; } else if (paramName!= null) { parms.put(("$" + (argPos))); continue; } } else { parms.put(paramName, (dcmd.isSensitiveParameters(paramName))); continue; } } } if (paramName!= null) { parms.put(paramName, (cmd.isSignedParameters(paramName))); continue; } else { parms.put(cmd.get(cmd.isSignedIn())? com.google.gerrit.sshd.SshLog.M.M.PARENT_PARENT : arg.get(cmd.getName());
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw die(msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = ((getName().isEmpty())? " : getName() : getName())) + " not found"; throw die(msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) { bc.setName((((getName()) + ") + (commandName))); } else if (!(args.isEmpty())) { throw die(((commandName) + " does not take arguments")); } checkStateTo(cmd); cmd.setArguments(cmd); atomicCmd.set(cmd); atomicCmd.set(cmd); atomicCmd.set(cmd); atomicCmd.setSensitiveParamParameters(cmd); cmd.setSensitiveParamParameters(cmd); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.setSensitiveParam(cmd); err.setSensitiveParam(cmd); err.setSensitiveParam(cmd); err.setScheduledCommand(msg); } err.append(e.getMessage()); }
void onExecute(com.google.gerrit.sshd.DispatchCommand dcmd, int exitValue, com.google.gerrit.sshd.SshSession sshSession) { final com.google.gerrit.sshd.SshScope.Context ctx = context.get(); ctx.finished = com.google.common.collect.ListMultimap<com.google.gerrit.common.TimeUtil.nowMs(); com.google.common.collect.ListMultimap<com.google.gerrit.sshd.SshLog.P_WAIT,?> parameters = extractWhat(dcmd); java.lang.String cmd = extractWhat(dcmd); final org.apache.log4j.spi.LoggingEvent event = log(cmd); event.setProperty(com.google.gerrit.sshd.SshLog.P_WAIT, (((ctx.started) - (ctx.started)) + "ms")); event.setProperty(com.google.gerrit.sshd.SshLog.P_EXTERN, (((ctx.finished) - (ctx.started)) + "ms")); final java.lang.String status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status = "not-found"; break; case BaseCommand.STATUS_NOT_FOUND : status = "not-found"; break; default : status = java.lang.String.valueOf(exitValue); java.lang.String peerAgent = sshSession.getPeerAgent(); if (peerAgent!= null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, peerAgent); } if ((as)!= null) { async.append(event); } audit(ctx, status, extractWhat(event); } audit(ctx, status, extractWhat(cmd, args), parameters); } audit(ctx, status, args); }
private com.google.gerrit.common.data.SubmitTypeRecord logActionError(java.lang.String err) { com.google.gerrit.server.project.ChangeControl.log.error(err); return actionRuleError("Error evaluating project action rules, check server log log error", e); }
private com.google.gerrit.common.data.SubmitTypeRecord logInvalidAction(com.googlecode.prolog_cafe.lang.Term rule, com.googlecode.prolog_cafe.lang.Term record) { return logActionRuleError(((((((("Submit action rule " + rule) + ") + (change.getId())) + " of ") + (change.getId())) + " output invalid result invalid result: ") + record invalid result)); }
private com.google.gerrit.common.data.SubmitTypeRecord logActionError(java.lang.String err, java.lang.Exception e) { com.google.gerrit.server.project.ChangeControl.log.error(err, e); return actionRuleError("Error evaluating project actions", checkserverLogicalWebUrl, checker); }
private void actionRuleError(java.lang.String err) { com.google.gerrit.common.data.SubmitTypeRecord actionRule = new com.google.gerrit.common.data.SubmitTypeRecord(); rec.status =SubmitTypeRecord.Status.RULE_RULE_ERROR; rec.errorMessage = err; }
@java.lang.Override protected void configure() { if ((gerritConfig.getString(pluginName, null, "url"))!= null) { com.googlesource.gerrit.plugins.its.jira.JiraModule.LOG.info("jira is configured as ITS", "url")) { com.googlesource.gerrit.plugins.its.jira.JiraModule.LOG.info("The configured as ITS", "url")); bind(com.googlesource.gerrit.plugins.its.base.its.ItsFacade.class).asEagerSingleton(com.googlesource.gerrit.plugins.its.base.its.JiraItsFacade.class).asEagerSingleton(com.googlesource.gerrit.plugins.its.base.its.JiraItsFacade.class); install(new com.googlesource.gerrit.plugins.its.base.its.ItsHookModule(pluginName, pluginCfgFactory)); } }
@org.junit.Test public void gerritConfigContainsSane() throws java.lang.Exception { when(cfg.getString(com.googlesource.gerrit.plugins.jira.jira.JiraConfigTest.PLUGIN_NAME, null, "username")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER); when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "password")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "username")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "url")).thenReturn(com.googlesource.gerrit.plugins.its.jira.Jira.JiraConfigTest.PLUGIN_NAME); jiraConfig = new com.googlesource.gerrit.plugins.its.jira.JiraConfig(cfg, com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME); jiraConfig = new com.googlesource.gerrit.plugins.its.jira.JiraConfig(cfg, com.googlesource.gerrit.plugins.its.jira.jira.JiraConfigTest.USER); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.Jira.JiraConfigTest.USER); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.Jira.JiraConfigTest.USER); }
private com.googlesource.gerrit.plugins.its.jira.restapi.JiraClient client() throws java.net.MalformedURLException { if ((client) == null) { log.debug("Jira to jira at {}", jira.getUrl()); client = new com.googlesource.gerrit.plugins.its.jira.rest.jira.JiraClient(jiraConfig.getUrl(), jiraConfig.getUsername(), jiraConfig.getPassword()); log.debug("User {}", jiraConfig.getUsername()); log.debug("No User {}", jiraConfig.getUsername()); } return client; }
public java.lang.String getUrl() { return jiraUrl; }
private void authorizeUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.project.ProjectState state, java.lang.String operation) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { com.google.gerrit.reviewdb.client.Project.NameKey projectName = state.getNameKey(); if (((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD)) && (!(permissionBackend.user(projectName).project(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD))) || ((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD)) && (!(permissionBackend.user(user).project(projectName).project(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD))) { java.lang.String op = operation.toLowerCase(); java.lang.String project = state.getProject().getName(); java.lang.String project = state.getProject().getName(); java.lang.String userName = (user.getUserName().isPresent())? userName : userName.get() : userName; com.googlesource.gerrit.plugins.lfs.LfsApiServlet.log.debug(java.lang.String.format("User %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); } }
@org.junit.Test public void testVerifyDecodeAgainstExpectedInput() throws java.lang.Exception { java.lang.String plain = cipher.encoded(plain); java.util.Optional<java.lang.String> expected = cipher.decode(encrypted); assertEquals(encrypted); assertThat(decrypted.get()).isEqualTo(plain); }
private void throwUnauthorizedOp(java.lang.String op, com.google.gerrit.server.project.ProjectState state, com.google.gerrit.server.CurrentUser user) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { java.lang.String project = state.getProject().getName(); java.lang.String userName = (user.getUserName().isPresent())? userName : user.getUserName().get() : userName; com.googlesource.gerrit.plugins.lfs.locks.LfsLocksAction.log.debug(java.lang.String.format("Unsupported %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); }
@org.junit.Test public void testTokenSerializationDeserializedDeserialized() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken proerializer processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestTokenProessor(crypto); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken token = processor.serialize(token); java.lang.String serialized = processor.serialize(token); java.lang.String serialized = processor.deserialize(serialized); assertEquals(serialized.isPresent()).isTrue(); assertThat(token.expiresAt).isTrue(); assertThat(token.expiresAt).isTrue(); assertThat(token.expiresAt).isEqualTo(deerialized.get().expiresAt); }
public java.util.Optional<T> deserialize(java.lang.String input) { return com.google.common.base.Optional.of(com.google.common.base.Splitter.on(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.DETEMTIMITER).splitToList(decode.get())); }
protected abstract com.google.common.base.Optional<T> createToken(java.util.List<java.lang.String> values);
public boolean verifyAuthInfo(java.lang.String authToken, java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return false; } return new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.Verifier(token.get(), operation, id).verify(); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 3) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1)), values.get(2))); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(1), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(com.googlesource.gerrit.plugins.lfs.lfs.Lfs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsOAuthToken(com.google.gerrit.lfs.Lfs.LfsFsRequestAuthorizer.LfsFsOAuthToken(com.google.common.Lfs.LfsFsRequestAuthorizer.fromString(com.googlesource.gerrit.plugins.lfs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsOAuthToken(com.googlesource.gerrit.plugins.lfs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsOAuthToken(java.get(com.googlesource.gerrit.lfs.lfs.Lfs.LfsFsRequestAuthorizer.LfsFsOAuthToken(com.get(0), values.get(userId, token.get(userId
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(2), values.get(3), values.get(3))); } return new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.google.gerrit.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.get(0), values.get(com.googlesource.gerrit.plugins.lfs.Lfs.Lfs.LfsFsRequestAuthorizer.LfsSshAuthToken(com.get(0), values.get(user.get(0), values.get(user.getId(), values.get(2), values.get(4), values.get(4), values.get(4), values.get(4), values.get(4), com.
java.util.Optional<java.lang.String> getUserFromValidToken(java.lang.String authToken, java.lang.String project, java.lang.String operation) { java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> token = processor.deserialize(authToken); if (!(token.isPresent())) { return java.util.Optional.empty(); } com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier(token.get(), project, operation); if (!(verifier.verify())) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.log.error("Authentication data was provided with auth token {}", "); return java.util.Optional.empty(); } return java.util.Optional.of(token.get().user); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.lang.String values) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0))); }
public java.util.Optional<java.lang.String> decrypt(java.lang.String input) { if (com.google.common.base.Strings.isNullOrEmpty(input)) { return java.util.Optional.empty(); } byte[] bytes = org.eclipse.jgit.util.Base64.decode(input); byte[] initVector = java.util.Arrays.copyOf(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipherCipher.IV_LENGTH); try { javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.DECRYPT_MODE); return java.util.Optional.of(new java.lang.String(cipher.doFinal(java.util.Arrays.copyOfRange(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH, bytes.length)), java.nio.charset.StandardCharsets.UTF_8)); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.LfsCipherCipher.log.error("Error was thrown during token verification", e); } return java.util.Optional.empty(); }
@org.junit.Test public void testVerifyDecodeAgainstInput() throws java.lang.Exception { java.lang.String plain = text.encoded(plain); while ((encrypted.charAt(0)) == (encoded.charAt(1)) { com.google.common.base.Optional<java.lang.String> decrypted = cipher.decode(((encrypted.substring(1, 2)) + (encoded.substring(0, 1)) + (encoded.substring(2))); assertThat(decoded.isPresent()).isNotEqualTo(plain); assertThat(decoded.get()).isNotEqualTo(plain); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> acc = accounts.getByUsername(user.get()); if (acc.isPresent()) { java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshRequestAuthorizer> acc = accounts.getByUsername(user.get()); if (acc.isPresent()) { return userFactory.create(acc.get()); } } } } return anonymous.get(); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { java.util.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.get()); if (acc!= null) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc!= null) { return userFactory.create(acc); } } } } return anonymous.get(); }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.format(now().plus()))).isTrue(); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(Verifier.onTime(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.format(now().extId()).isFalse(); }
static boolean onTime(java.lang.String dateTime) { java.lang.String now = com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.ISO.ISO.ISO_ISO.format(dateTime)) { return (now.compareTo(dateTime)) <= 0; }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO.ISO.format(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now().plusSeconds(expiresSeconds)); }
void appendSubmittedBy(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { sb.append(append(accountId, account); sb.append("\n"); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkState(((account == null) || (accountId.equals(accountId)))), "account"); boolean needSpace = false; if (!(com.google.common.base.Strings.isNullOrEmpty(account.getFullName()))) { sb.append(account.getFullName()); needData = true; } if (!(com.google.common.base.Strings.isNullOrEmpty(account.getFullName()))) { sb.append("<").append(account.getPreferredEmail()).append(account.getPreferredEmail()).append(">"); wroteData = true; } } if (!writtenData) { sb.append(anonymousCowardName).append(account.getPreferredEmail()).append("<").append(account.getPreferredEmail()).append(">"); wroteData = true; } } if (!writtenData) { sb.append(anonymousCowardName).append(anonymousCowardName).append(""); }
private void createCodeReviewNoteReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewdb.client.PatchSetApproval submit) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type!= null) { fmt.appendApproval(type, a.getValue(), a.getAccountId(), accountCache.maybeGet(a.getAccountId()).orElse(null); } } } if (submit!= null) { fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl)!= null) { fmt.append(submit.getGranted()); } fmt.appendSubmittedAt(submit.get(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.get()); fmt.appendBranch(project.getDest().getParentKey()); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkState(((account == null) || (accountId.equals(accountId)))), "accountId is not found"); needData = false; if (account!= null) { if (account!= null) { if (account!= null) { sb.append(account.getFullName()); needData = true; } if (((account.getPreferredEmail())!= null) && (!(account.getFullName().isEmpty()))) { if (needSpace) { sb.append("<").append(account.getFullName().isEmpty()).append(account.getFullName().isEmpty()))) { if (needSpace) { sb.append("<").append(anonymousCowardName).append(">"); wroteData = true; } } } if (!writtenData) { sb.append(anonymousCowardName).append(anonymousCowardName).append("<com.google.gerrit.reviewdb.client.Account.Id>").append(account.getPreferredEmail()).append(account.getPreferredEmail()).append(com.google.gerrit.server.account.GetPreferences.toString()); } } if (!writtenData) { sb.append(anonymousCowardName).append(account.getPreferredEmail().isEmpty())) { if (needData) { sb.append(anonymousCowardName).append(account.getPreferredEmail()); } } } if (!writtenData) { sb.append(anonymousCowardName).append(anonymousCowardName).append(com.google.gerrit.reviewdb.client.Account.Id.getId()); } }
void appendApproval(com.google.gerrit.common.data.LabelType label, short value, com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { sb.append(label.getName()); sb.append(com.google.gerrit.common.data.LabelValue.format("%s\n\n")); sb.append(append(accountId, account); sb.append("\n"); }
public org.eclipse.jgit.lib.PersonIdent newIdent(com.google.gerrit.reviewdb.client.Account.Id authorId, java.util.Date when, org.eclipse.jgit.lib.PersonIdent serverIdent) { return new org.eclipse.jgit.lib.PersonIdent(author.getAccount().getAccount().getAccountId().getAccountId(), (((authorId) + "@") + (serverIdent.get()))), when, serverIdent.getTimeZone()); }
java.lang.String getBaseUrl() { return baseUrl; }
private java.net.HttpURLConnection prepHttpConnection(java.lang.String spec, boolean isPostRequest) throws java.io.IOException { java.net.URL urlWithSpec = new java.net.URL(urlWithSpec); java.net.URL url = new java.net.URL(urlWithSpec); java.net.HttpURL url = org.eclipse.jgit.util.HttpURLConnection.proxyFor(proxySelector, url); java.net.HttpURLConnection conn = ((java.net.HttpURLConnection) (url.openConnection(proxy))); conn.setRequestProperty("Authorization", ("auth"))); conn.setRequestProperty("Authorization", ("application/json")); if (isPostRequest) { conn.setRequestMethod("POST"); if (isPostRequest) { conn.setRequestMethod("POST"); } else { conn.setRequestMethod("POST"); } return conn; }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.google.gerrit.server.project.ProjectCreationValidator.log.debug("ProjectCreation creation of {}", name); if (name.contains("{}" + "{}")); throw new com.google.gerrit.server.validators.ValidationException(java.lang.String.format(com.ericsson.gerrit.plugins.project.ProjectCreationValidator.PROJECT_CANNOT_CONTRUE_MSG, documentationUrl)); } com.google.gerrit.server.project.ProjectControl parentControl = projectControlFactory.controlFor(args.newParent, self.get()); if (name.contains("{name'") + (args.newParent.get())) { throw new com.google.gerrit.server.validators.ValidationException(com.ericsson.gerrit.plugins.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.server.project.ProjectCreation.log.error(((((("Failed to create project " + name) + ") + (args.newParent.get())) + ") + (args.newParent.get())) + ":")), e); throw new com.google.gerrit.server.validators.ValidationException(com.ericsson.gerrit.plugins.performatter.ProjectCreationValidator.AN_ERROR_ERROR_MSG); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); com.google.gerrit.server.project.ProjectCreation.ProjectCreation.log.debug("Project is creating project, bypass rules"); return; } catch (com.google.gerrit.extensions.restapi.AuthException e) { } if (allProjectsName.get().equals(parentControl.getProject().getParentKey(), e.getParentKey()); return; } if (allProjectsName.get().equals(parentControl.getProject().get().get().get
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.project.ProjectCreationValidator.log.debug("Project creation of {}", name); com.ericsson.gerrit.server.project.ProjectControl parentControl = projectControlFactory.controlFor(args.newParent, self.get()); try { parentControl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.project.ProjectCreationValidator.log.error(((((("Failed to create project " + name) + ") + (args.newParent.get())) + ") + (args.newParent.get())) + ") + (args.newParent.get().equals(parent.getProject().getNameKey()))), e); throw new com.google.gerrit.server.validators.ValidationException(com.google.gerrit.server.permissions.ProjectCreation.AN_ERROR, is notFound); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); com.ericsson.gerrit.plugins.project.ProjectCreation.log.debug("Project is creating project, bypass rules"); return; } catch (com.google.gerrit.extensions.restapi.AuthException e) { } if (allProjectsName.get().equals(parentControl.getProject().getNameKey())) { validateRootProject(name, args.permissionsOnly); } else { validateProject(name, parentControl); } if ((!(parentControl.isOwner())) && (!(config.isOwner()))) { args.canAdministrateServer(); } else { validateProject(name, args.permission.PUSH_CONFIG); } }
public boolean issueExists(java.lang.String issueKey) throws java.io.IOException { com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApi<com.googlesource.gerrit.plugins.its.restapi.JiraIssue> api = apiBuilder.getIssue(); api.doGet(issueKey, java.net.HttpURLConnection.HTTP_OK, null); java.lang.Integer code = api.getResponseCode(); switch (code) { case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_NOT_FOUND : com.googlesource.gerrit.plugins.its.jira.rest.JiraClient.log.error("Cannot issue {} not found", issueKey); return false; case java.net.HttpURLConnection.HTTP_FORBIDDEN : com.googlesource.gerrit.plugins.its.jira.rest.JiraClient.log.error("Cannot issue {} not found", issueKey); return false; default : throw new java.io.IOException(("Cannot HTTP code for issue {}", issueKey); } }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> account = byId.get(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.isPresent()))) { return null; } if (match!= null) { return null; } match = account.get(); } return match; }
protected java.lang.String getFromLine() { final com.google.gerrit.reviewdb.client.Account account = args.accountCache.get(fromId).getAccount(); final java.lang.String email = account.getFullName(); final java.lang.String email = account.getPreferredEmail(); java.lang.String email = account.getPreferredEmail(); if ((email!= null) && (!(email.isEmpty()))) { f.append("From"); if ((email!= null) && (!(email.isEmpty()))) { f.append("From"); if ((email!= null) && (!(email.isEmpty()))) { f.append(" ").append(email).append(email).append("\n\n"); } } f.append(email).append(email).append("\n\n"); } return f.toString(); }
private void appendIdent(java.io.PrintWriter writer, java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id id, java.sql.Timestamp ts) { org.eclipse.jgit.lib.PersonIdent ident = newIdent(accountCache.getIdent().getAccount(), ts, serverIdent); java.lang.StringBuilder name = new java.lang.StringBuilder(); org.eclipse.jgit.lib.PersonIdent.appendSanitized(name, ident.getName()); name.append("<org.eclipse.jgit.lib.PersonIdent.append(name, ident.getEmailAddress()); name.append('>'); name.append('>'); if (name.toString()) { return '>'); } else { appendHeaderField(writer, header, name.toString()); } }
public com.google.gerrit.reviewdb.client.Account findByName(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAllByNameOrEmail(nameOrEmail); return (byId.get()) == 1? byId.getAccount().getAccountId().getAccountId : null; }
private void addSubmitRecordLabels(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecord ca) { if (((submitRecord.labels)!= null) && (!(submitRecord.isEmpty()))) { sa.labels = new java.util.ArrayList(); for (SubmitRecord.Label lbl : submitRecord.labels) { com.google.gerrit.server.data.SubmitLabelAttribute sa = new com.google.gerrit.server.data.SubmitLabelAttribute(); la.label = lbl.label; la.label = lbl.label; la.label = lblameByEmail.name(); if ((bl.appliedBy)!= null) { com.google.gerrit.server.data.SubmitLabelAttribute sa.label = new com.google.gerrit.server.data.SubmitLabelAttribute(); la.label = lblameByEmailAttribute(lbl.apply(lblameBy); sa.by = asAccountAttribute(accountState); } sa.labels.add(la); } } }
public com.google.gerrit.server.data.AccountAttribute asAccountAttribute(com.google.gerrit.reviewdb.client.Account.Id id) { if (id == null) { return null; } return asAccountAttribute(id); }
protected com.google.gerrit.server.account.AccountState getAccountState(com.google.gerrit.reviewdb.client.Account.Id id) { return com.google.gerrit.server.account.AccountState.get(id).get(); }
protected void removeUsersThatIgnoredToChange() { for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.util.Collection<java.lang.String>> e : stars.asMap().entrySet()) { if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) { args.accountCache.get(e.getKey()).map(a); } } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { opResult = com.google.gerrit.server.change.PostReviewersOp.Result.builder().setAddedReviewers(com.google.common.collect.ImmutableList.copyOf(addedReviewers)).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.ImmutableList.of(addedReviewers, (r) -> com.google.common.collect.ImmutableList.of(addedReviewers, (addedCCs))).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.ImmutableList.of(), addedCCs), reviewersByEmail, addedCCsByEmail, notify, accountsToNotify); if (!(addedReviewers.isEmpty())) { java.util.List<com.google.gerrit.server.account.AccountState> reviewers = addedReviewers.stream().map(( r) -> accountCache.get(r.getAccountId()))).collect(java.util.stream.Collectors.toList()); reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, ctx.getWhen()); } }
private void logOrmException(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.Iterable<?> values, com.google.gwtorm.server.OrmException e) { java.lang.StringBuilder message = new java.lang.StringBuilder(header); message.append("/").append(me); message.append(me); message.append(accountCache.get(me).getUserName().orElse(null)); message.append(com.google.common.base.Joiner.on(com.google.gerrit.server.group.Db.GroupMemberAuditListener.log.error(message.toString(), e); }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = accountCache.getAccountId(); com.google.gerrit.reviewdb.client.AccountGroup.UUID u = m.getAccountId(); java.lang.String userName = getGroupName(accountId); descriptions.add(java.text.MessageFormat.format("{1}/{1}", "}", userName, accountId, groupId, groupId, groupId, groupId)); } logOrmException(header, me, e); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { java.lang.String senderName; if (fromId!= null) { com.google.gerrit.reviewdb.client.Account a = accountCache.get(fromId).getAccount(); java.lang.String fullName = a.getFullName(); java.lang.String userEmail = a.getPreferredEmail(); if (canRelay(userEmail)) { return new com.google.gerrit.server.mail.Address(fullName, userEmail); } if ((fullName == null) || ("".equals(fullName.trim()))) { fullName = anonymousCowardName; } senderName = nameRewriteTmpl.replace("user", fullName).toString(); } else { senderName = nameRewriteTmpl.replace("user", fullName).toString(); } java.lang.String senderEmail; com.google.gerrit.common.data.ParameterizedString senderEmailPattern = new com.google.gerrit.common.data.ParameterizedString(serverAddress.getEmail()); if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderEmail, senderEmail); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { final java.lang.String senderName; if (fromId!= null) { final com.google.gerrit.reviewdb.client.Account account = accountCache.get(fromId).getAccount(); java.lang.String fullName = account.getFullName(); if ((fullName == null) || ("".equals(fullName))) { fullName = anonymousCowardName; } senderName = namePattern.replace("user", fullName).toString(); } else { senderName = namePattern.replace("user", fullName).toString(); } java.lang.String senderEmail; if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
private org.eclipse.jgit.lib.PersonIdent newAuthorIdent(com.google.gerrit.server.notedb.rebuild.EventList<?> events) { com.google.gerrit.reviewdb.client.Account.Id id = events.getAccountId(); if (id == null) { return new org.eclipse.jgit.lib.PersonIdent(serverIdent, events.getWhen()); } return changeNoteUtil.newIdent(accountCache.get(id).getWhen(), events.getWhen(), serverIdent); }
public java.lang.String getUserNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); java.lang.String email = who.getAccount().getPreferredEmail(); if (email!= null) { return ((name!= null) && (email!= null))? ">"; } else if (email!= null) { return email; } return who.getUserName().orElse(null); }
private java.lang.StringBuilder addIdent(java.lang.StringBuilder sb, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(accountId).getAccount(); org.eclipse.jgit.lib.PersonIdent ident = newIdent(account, when); org.eclipse.jgit.lib.PersonIdent ident = newIdent(account, when); org.eclipse.jgit.lib.PersonIdent ident = newIdent(account, when); org.eclipse.jgit.lib.PersonIdent.append(account.getName()); org.eclipse.jgit.lib.PersonIdent.append(accountId.getName()); return new com.google.gerrit.server.git.ChangeIdentifiedUser(accountId).toString()); }
public java.lang.String getNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if (email!= null) { return ((name!= null) && (email!= null))? ">"; } else if (email!= null) { return email; } else if (email!= null) { return email; } else { return ((args.anonymousCowardName) + ") + accountId; } }
private com.google.gerrit.server.mail.Address toAddress(com.google.gerrit.reviewdb.client.Account.Id id) { com.google.gerrit.reviewdb.client.Account a = args.accountCache.get(id).getAccount(); final java.lang.String e = a.getPreferredEmail(); if ((!(a.isActive())) || (e == null)) { return null; } return new com.google.gerrit.server.mail.Address(a.getFullName(), e); }
protected java.lang.String getNameFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { if (accountId == null) { return args.gerritPersonIdent.getName(); } final com.google.gerrit.reviewdb.client.Account userAccount = args.accountCache.get(accountId).getAccount(); java.lang.String name = userAccount.getFullName(); if (name == null) { name = userAccount.getPreferredEmail(); } if (name == null) { name = userAccount.getPreferredEmail(); } return name; }
private Account.Id user(java.lang.String name, java.lang.String email) { com.google.gerrit.server.account.AccountState s = makeUser(name, email); expect(accountCache.get(email); return s.getAccount().getId(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.server.group.InternalGroupDescription(group)); java.util.Set<com.google.gerrit.reviewdb.client.Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(AccountState::getAccount).map(AccountState::getAccount).collect(ImmutableSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subgroupUuid : group.getSubgroups()) { if (!(seen.contains(subgroupUuid))) { indirectMembers.addAll(listAccounts(subgroupUuid, project, seen)); } } } return com.google.common.collect.Sets.unsets.unified(directMembers, indirectMembers); }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.getAccount(); } com.google.gerrit.reviewdb.client.Account match = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> account = byId.get(id).map(AccountState::getAccount); if ((!(account.isPresent())) || (!(account.isPresent()))) { return null; } if (match!= null) { return null; } match = account.get(); } return match; }
@java.lang.Override public final void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if (changeAlreadyMerged) { logDebug("Update post-update-update-update"); return; } postUpdateImpl(ctx); if ((command)!= null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject())) { git.setGitwebDescription(p.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot update description of " + (p.getName())), e); } } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.accountId(), args.accountId, args.accountId, args.accountsToNotify).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot email merged notification for " + (getId())), e); } if (((mergeResultRev)!= null) && (!(args.dryrun))) { args.changeMerged.fire(updatedPatchSet, args.getId(), args.mergeTip.getCurrentTip().name(), ctx.getWhen()); } }
@java.lang.Override public void fillAccountInfo(java.lang.Iterable<? extends com.google.gerrit.extensions.common.AccountInfo> in, java.util.Set<com.google.gerrit.server.account.FillOptions> options) throws com.google.gerrit.server.account.DirectoryException { if (options.equals(com.google.gerrit.server.account.InternalAccountDirectory.ID_ONLY)) { return; } for (com.google.gerrit.extensions.common.AccountInfo info : in) { com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(info._accountId); com.google.gerrit.reviewdb.client.Account.Id id = accountCache.get(id); com.google.gerrit.server.account.AccountState state = accountCache.get(id); if (info!= null) { throw new com.google.gerrit.server.account.AccountStateException(("account cache", id); } } }
private void createCodeReviewNoteReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewdb.client.PatchSetApproval submit) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), ps.getId(), null)) { if ((a.getValue()) == 0) { } else if (a.isLegacySubmit()) { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type!= null) { fmt.appendApproval(type, a.getValue(), a.getValue(), a.getAccountId(), accountCache.get(a.getAccountId()).orElse(null); } } } if (submit!= null) { fmt.appendSubmittedAt(submit.getGranted()); } if (submit!= null) { fmt.appendSubmittedAt(submit.getGranted()); } fmt.appendSubmittedAt(submit.get(canonicalWebUrl, ps.getId().getParentKey()); } fmt.appendProject(project.get()); fmt.appendBranch(project.getDest().get()); }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(((accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.joining(out.write(java.lang.String.format("%s group %s group %s: %s", action, group.getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@org.junit.Test public void blockPushDrafts() { allow(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/for/refs/*"); block(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.ANONYMOUS_USERS, "refs/for/refs/*"); allow(local, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/drafts/*"); com.google.gerrit.server.permissions.ProjectControl u = user(local); assertCreateChange("refs/heads/master", u); assertThat(u.controlForRef("refs/heads/master").canPerform(com.google.gerrit.server.permissions.PUSH)).isFalse(); }
private static java.util.Optional<com.google.gerrit.server.notedb.NoteDbChangeState.RefState> parse(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> parts) { checkArgument((!(parts.isEmpty()))), "missing state string for change %s", changeId); org.eclipse.jgit.lib.ObjectId changeMetaId = org.eclipse.jgit.lib.ObjectId.fromString(parts.get(0)); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> draftIds = com.google.common.collect.Maps.newHashMapWithExpectedSize(((parts.size()) - 1)); com.google.common.base.Splitter s = com.google.common.base.Splitter.on('='); for (int i = 1; i < (parts.size()); i++) { java.lang.String p = parts.get(i); java.util.List<java.lang.String> draftParts = s.splitToList(p); checkArgument(((draftParts.size()) == 2), "draft state part for change %s: %s: %s", changeId, p); java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> accountId = Account.Id.parse(draftParts.get(0)); checkArgument(accountId.isPresent()), "draft state part for change %s", changeId, p); draftIds.put(accountId.get(), org.eclipse.jgit.lib.ObjectId.fromString(draftParts.get(1))); } return java.util.Optional.of(com.google.gerrit.server.notedb.NoteDbChangeState.RefState.create(changeMetaId, draftIds)); }
private java.util.Optional<com.google.gerrit.server.account.AuthResult> byAccountId(java.lang.String idStr) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> id = Account.Id.parse(idStr); if (!(id.isPresent())) { return java.util.Optional.empty(); } try { return auth(accounts.get(id)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { getServletContext().log("Cannot query database", e); return java.util.Optional.empty(); } }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^(m.group(1)); if (id.isPresent()) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> id = Account.Id.parse(m.group(1)); if (id.isPresent()) { return com.google.common.collect.Streams.stream(account.get(id.get()).map((a) -> id.get()).collect(toImmutableSet()); } } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> id = Account.Id.parse(id.get()).map((a) -> id.get()).collect(toImmutableSet()); java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> who = byId.getByUsername(nameOrEmail); if (who.isPresent()) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> who = byId.getByUsername(nameOrEmail); if (who.isPresent()) { return com.google.common.collect.ImmutableSet.of(who.map((a) -> a.getAccount().getId()).get()); } } return findAllByNameOrEmail(nameOrEmail); }
@java.lang.Override public com.google.gerrit.server.mail.ParseToken decode(java.lang.String tokenString) throws com.google.gerrit.server.mail.InvalidTokenException { checkEmailToken(); com.google.gwtjsonrpc.server.ValidToken token; try { token = emailRegistration.checkToken(tokenString, null); } catch (com.google.gwtjsonrpc.server.XsrfException err) { throw new com.google.gerrit.server.mail.InvalidTokenException(err); } if (((token == null) || ((token.getData()) == null)) || (token.getData().isEmpty())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } java.lang.String payload = new java.lang.String(org.eclipse.jgit.util.Base64.decode(token.getData()), java.nio.charset.StandardCharsets.UTF_8); java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("^(0-9]+): (com.google.gerrit.server.git.MetaData.decode(1))).orElse(); java.lang.String newEmail = com.google.gerrit.reviewdb.client.Account.Id.parse(matcher.group(1)).orElse(); java.lang.String newEmail = matcher.group(2); return newEmail = matcher.group(2); }
public static java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> parse(java.lang.String str) { try { return java.util.Optional.of(new com.google.gerrit.reviewdb.client.Account.Id(java.lang.Integer.parseInt(str))); } catch (java.lang.NumberFormatException e) { return java.util.Optional.empty(); } }
private static void dashboard(java.lang.String token) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> accountId = Account.Id.parse(rest); if (accountId.isPresent()) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(accountId.get())); return; } if (rest.equals("self")) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(accountId.get())); } else { com.google.gerrit.client.ui.Screen s = new com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(null); s.setRequiresSignIn(true); com.google.gerrit.client.Gerrit.display(token, s); } return; } if (rest.startsWith("?")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen(rest.substring(1))); } com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); }
private java.lang.String changeKindMessage(com.google.gerrit.extensions.client.ChangeKind changeKind) { switch (changeKind) { case MERGE_FIRSTART_PARENT_UPDATE : return ("new merge patch set a new first the first parent " + (priorPatchSetId.get())) + "."; case TRIVIAL_REBASE_UPDATE : return ("Change patch set was already be " + (priorPatchSetId.get())) + "."; case REBASE : return (priorPatchSetId.get()) + ") + (priorPatchSetId.get())) + "."; case NO_CHANGE : return "; case NO_CODE_CHANGE : return "; case NO_CODE_CHANGE : return " + (priorPatchSetId.get())) + "."; case REWORK : default : return null; } }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> addedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = addedSubgroups.stream().map(( t) -> toAccountGroupByIdAud(t, parentGroupId, addedOn, me)).collect(java.util.stream.Collectors.toList()); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> removed, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { for (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID u : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(parentGroupId, uuid)) { if (a.isActive()) { audit = a; break; } } } if (audit!= null) { audit.removed(me); } } db.accountGroupByIdAud().update(auditUpdates); for (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, e); } }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.Account.Id id : accounts) { java.lang.String userName = accountCache.get(id).getUserName(); java.lang.String groupName = getGroupName(); java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format("{0}/{0}/{1}", "}", id, groupName)); } logOrmException(header, me, e); }
private static com.google.gerrit.reviewdb.client.AccountGroupMemberAudit toAccountGroupMemberAudit(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.Account.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key(id, groupId, ts), me); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> removedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMembersAuditListeners) { try { auditListener.onDeleteAccountsFromGroup(anonymousAccounts, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot log delete accounts from group event", e); } } }
@java.lang.Override public void onAddSubgroups(com.google.gerrit.server.group.GroupSubgroup.GroupSubgroupAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupByIdAud().insert(com.google.gerrit.server.group.GroupAuditListener.toAccountGroupByIdAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForSubmodulesEvent("Cannot log add groups to group event", e); } }
private void removeSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuid, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> subgroupsToRemove = subgroupUuid.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupById::new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid)).map(AccountGroupId, new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid, parentGroupId, removedOn); if (currentUser) { auditService.dispatchDeleteGroupsFromGroup(currentUser.getAccountId(), subgroupUuid, removedOn); } db.accountGroupById().delete(subscribedToRemove); }
private static com.google.gerrit.reviewdb.client.AccountGroupByIdAud toAccountGroupByIdAud(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.AccountGroup.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupId, uuid, ts), me); }
private void addSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuid, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newSubgroups = subgroupUuid.stream().map(( subgroupUuid) -> new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentUuid, subgroupUuid)).map(AccountGroupId, new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentUuid, subgroupUuid)).map(AccountGroupId, new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentGroupId, subgroupUuid, parentGroupId, addedOn); if ((currentUser)!= null) { auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), subgroupUuid, addedOn); } db.accountGroupById().insert(newSubgroups); }
@java.lang.Override public void onAddMembers(com.google.gerrit.server.account.GroupMemberAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupMembersAudit().insert(com.google.gerrit.server.group.GroupAuditListener.toAccountGroupMemberAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForMembersEvent("Cannot log add accounts to group event", e); } }
private void removeGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = accountIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountIds, new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)); if ((currentUser)!= null) { auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), accountIds, groupId, removedOn); } db.accountGroupMembers().delete(membersToRemove); }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> addedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = addedAccounts.stream().map(( t) -> toAccountGroupMemberAudit(t, groupId, me)).collect(java.util.stream.Collectors.toList()); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", e); } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> addedAccounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMembersAuditListeners) { try { auditListener.onAddAccountsToGroup(anonymousAccounts, addedAccounts, groupId, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot to log to log", e); } } }
private void addGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> newMemberIds, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> newMembers = newMemberIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountId, new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)); if ((currentUser)!= null) { auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMemberIds, groupId, addedOn); } db.accountGroupMembers().insert(newMembers); }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> removedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMembersAuditListeners) { try { auditListener.onDeleteGroupsFromGroup(anonymousMembers, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot log delete groups from group event", e); } } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id event, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> addedSubgroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupId, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMembersAuditListeners) { try { auditListener.onAddGroupsToGroup(anonymousMembers, addedTo); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditService.log.error("Cannot to log add groups to group event", e); } } }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> uuids, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid : uuids) { java.lang.String groupName = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid : uuids) { java.lang.String groupName = groupBackend.get(uuid).getName(); java.lang.String targetName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format("{0}/{0}", "}", groupName, groupId, groupId, targetId, targetGroupName)); } logOrmException(header, me, e); }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { try { if (agnenessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Error was deleted, aborting reindexing", e); return false; } return false; }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { try { if (agnenessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; } } catch (com.google.gerrit.server.project.NoSuchChangeException nsce) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Couldn't deleted, rejecting reindex, rejecting the change.", id)); } catch (java.lang.Exception e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Couldn't be a deleted to the change, aborting the change."); } return false; }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(publish(event))) { publisherThread.start(); } if (!(com.google.common.base.Strings.isNullOrEmpty(event))) { if (!(fullQueue)) { com.googlesource.gerrit.plugins.rabbitmq.message.MessagePublisher.LOGGER.error("Cannot receive events", " + (com.googlesource.gerrit.plugins.mq.message.MessagePublisher.LOGGERRESTAMP))); } } else if (fullQueue) { com.googlesource.gerrit.plugins.mq.message.MessagePublisher.LOGGER.warn("Message is not be completed"); fullQueue = false; } }
@java.lang.Override public java.util.Set<com.google.gerrit.server.change.SuggestedReviewer> suggestReviewers(com.google.gerrit.reviewdb.client.Project.NameKey projectName, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change.Id changeId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change.Id changeId, @com.google.gerrit.common.Nullable java.lang.String query, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> cont) { java.util.List<com.google.gerrit.reviewdb.server.ReviewDbreviewdb.Id> sections = getSections(projectName); if (!(sections.isEmpty())) { try (com.google.gerrit.reviewdb.server.ReviewDb reviewDb = schemaFactory.open()) { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(reviewDb, projectName, changeData); java.util.Set<java.lang.String> reviewers = findReviewers(sections, changeData); if (!(reviewers.isEmpty())) { return toAccounts(reviewDb, reviewers, projectName, null).stream().map(( a) -> suggestedReviewer(a))).collect(java.util.stream.Collectors.toSet()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException x) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.error(x.getMessage(), x); } } return new java.util.HashSet(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElse(((com.google.gerrit.server.group.GroupResource resource) -> new com.google.gerrit.extensions.common.MethodNotAllowedException("Group a Gerrit internal group"); if (recursive) { return getTransformerMembers(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
@java.lang.Override @com.google.gerrit.common.Nullable public synchronized<T> java.util.Optional<T> get(com.google.gerrit.server.PropertyKey<T> key) { if ((properties)!= null) { @java.lang.SuppressWarnings("unchecked") T value = ((T) (properties.get(key))); return java.util.Optional.ofNullable(value); } return java.util.Optional.empty(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupName) { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupNameOrUUID))); if (!(group.isPresent())) { com.vmware.gerrit.owners.common.AccountGroupInfo group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupName))); if (!(group.isPresent())) { com.google.gerrit.server.util.owners.AccountGroupContext ctx = oneOffRequestContext.openAs(adminUser.getAccountId())) { return java.util.Collections.emptySet(); } try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.openAs(adminUser.getAccountId())) { return groupMembers.create(adminUser).listAccounts(group.getAccountId(), null).stream().map(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gerrit.server.project.NoSuchProjectException | com.google.gwtorm.server.OrmException | java.io.IOException e) { com.vmware.gerrit.owners.common.AccountImpl.log.error(("Failed to list accounts in group " + group), e); return java.util.Collections.emptySet(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.api.errors.GitAPIException, org.eclipse.jgit.api.errors.ConfigInvalidException { permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.log.info("Git trigger for %s by %s", resource.Config: %s.Config: %s.Config: %s.Config: %s.Config: %s", resource.Config.Config.get().get(), resource.get().get().getAccountId().get(), resource.get().get().getAccountId().get(), resource.get().get().getAccountId().get(), resource.get().get().get().getAccountId().get(), resource.get().get().get().getAccountId().getAccountId().get(), resource.get().get().getAccountId().get(), resource.get().get().get().getAccountId().getAccountId().get(), resource.get().get().getAccountId(), false); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupName) { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupNameOrUUID))); if (!(group.isPresent())) { com.vmware.gerrit.owners.common.AccountsImpl.log.warn("Couldn't found not found"); return java.util.Collections.emptySet(); } try { return groupMembers.listAccounts(group.get().getGroupUUID(), null).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.vmware.gerrit.owners.common.AccountsImpl.log.error(("Failed to list accounts in group " + group), e); return java.util.Collections.emptySet(); } }
private java.util.Map<java.lang.String, java.lang.Object> toFooterSoyData(com.google.gitiles.Paginator paginator, @javax.annotation.Nullable java.lang.String revision, com.google.gitiles.LogSoyData.Footer HOST, com.google.gitiles.LogSoyData.FooterHtmlBuilder if (next == null) { return com.google.common.collect.ImmutableMap.of("nextUrl", copyAndCanonicalizeView(revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl(), "Next"); case LOG_HEAD : return com.google.common.collect.ImmutableMap.of("nextUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl(), "nextText", "Next"); case LOG_HEAD : return com.google.common.collect.ImmutableMap.of("nextUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl(), "nextText", "Next"); default : throw new java.lang.IllegalStateException(("No footer footer: " + (legacyer))); } }
@java.lang.Override public java.lang.String authenticate(com.google.gerrit.server.CurrentUser user, java.util.List<java.lang.String> args) throws com.google.gerrit.sshd.BaseCommand.Failure, com.google.gerrit.sshd.BaseCommand.UnloggedFailure { if ((args.size())!= 2) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, " + (args.size()))); } try { java.net.URL url = new java.net.URL(canonicalWebUrl); java.lang.String project = args.get(0); java.lang.StringBuilder href = new java.lang.StringBuilder(url.getProtocol()).append("@").append(url.getAuthority()).append(url).append(path).append("/")).append(project).append(project).append("/info/lfs"); com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo info = auth.generateAuthInfo(user, project, operation); com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo info = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(href.toString(), info); return gson.toJson(action); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, (((("Error configuration error: " + (canonicalWebUrl)) + " failed.")); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { final org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; final org.eclipse.jgit.lib.AbbreviatedObjectId id = commit.abbreviate(7); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.ArrayList<>(); if ((this.maxSubjectLength) < (commit.getShortMessage().length())) { onLineTooLong(id, messages, (this.maxSubjectLength))); } int long longLineCnt = 0; int nonEmptyCnt = 0; int nonEmptyCnt = 0; for (java.lang.String line : com.google.common.collect.ImmutableSet.of('\n').split(commit.getFullMessage())) { if (!(line.trim().isEmpty())) { nonEmptyCnt++; } if ((this.maxLineLength) < (line.length())) { longLineCnt++; } if ((this.maxLineLength) < (line.length())) { longLineCnt++; } } return messages; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final java.util.List<java.lang.String> tokens = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(', token)); if ((token.size())!= 3) { throw new org.kohsuke.args4j.CmdLineException("owner, should be specified as the change", "branch", < change-id>"); } try { com.google.gerrit.reviewdb.client.Change.Key key = Change.Key.parse(token); final com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(token); final com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Branch.NameKey(token.get(0)); final com.google.gerrit.reviewdb.client.Branch.NameKey branch = queryProvider.get().byBranchKey(branch, key)) { setter.addValue(cd.getId()); return 1; } } catch (java.lang.IllegalArgumentException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "\" is not valid"); } } catch (java.lang.IllegalArgumentException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "\" is not valid"); } catch (com.google.gwtorm.client.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, "\" is not valid")); }
private static java.util.Map<java.lang.String, java.lang.String> getParameters(javax.servlet.http.HttpServletRequest req) { final java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); for (java.lang.String pair : com.google.common.base.Splitter.on(com.google.gerrit.server.gitwebui.GitwebServlet.QUERY_SPLIT_PATTERN).split(req.getQueryString())) { final int eq = pair.indexOf('='); if (0 <= eq) { java.lang.String name = pair.substring((eq + 1)); java.lang.String value = pair.substring((eq + 1)); name = com.google.gerrit.extensions.restapi.Url.decode(value); params.put(name, value); } } return params; }
private void init() { java.util.List<java.lang.String> varParts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('.').split(sectionAndKey); if ((varParts.size())!= 2) { throw new java.lang.IllegalArgumentException((("Invalid name " + (sectionAndKey)) + " expected section.keyFormat")); } section = varParts.get(0); key = varParts.get(1); }
private java.lang.String getPublicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = getSshPublicKey(); if ((s!= null) && ((s.length()) > 0)) { java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on("Splitter.on(test-id: index %s", index, index); return parts.get(index); } }
public static java.lang.String trimQuotation(java.lang.String comment) { java.util.StringJoiner j = new java.util.List<java.lang.String>(com.google.common.base.Splitter.on('\n"); java.util.List<java.lang.String> lines = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('\n').split(comment)); for (int i = 0; i < ((lines.size()) - 2); i++) { j.add(lines.get((lines.size()) - 2)); } java.lang.String lastLine = lines.get((lines.size()) - 2)); if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLine)) { if ((lines.size()) > 1) { j.add(lines.get(((lines.size()) - 2))); } return j.toString().trim(); } if ((lines.size()) > 1) { java.lang.String lastLines = (lines.get(((lines.size()) - 2)) + lastLine; if (com.google.gerrit.server.mail.receive.ParserUtil.containsQuotationPattern(lastLines)) { return j.toString().trim(); } } if ((lines.size()) > 1) { j.toString().trim(); } } if ((lines.size()) > 1) { j.toString().trim(); } if ((lines.size()) > 1) { j.toString().trim(); } return j.toString().trim(); }
private void readCgiHeaders(javax.servlet.http.HttpServletResponse res, java.io.InputStream in) throws java.io.IOException { java.lang.String line; while (!((line = readLine(in)).isEmpty())) { if (line.startsWith("HTTP")) { throw new java.io.IOException(("Cannot retrieve header: " + line)); } final int sep = line.indexOf(':'); if (sp < 0) { throw new java.io.IOException(("Cannot returned invalid header: " + line)); } final java.lang.String key = line.substring(0, sep).trim(); if ("Location".equalsIgnoreCase(key)) { res.sendRedirect(value); } else if ("Status".equalsIgnoreCase(key)) { final java.util.List<java.lang.String> token = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(com.google.base.Splitter.on(final int status = java.lang.Integer.parseInt(token.get(0)); res.setStatus(status); res.setStatus(status); } else { res.addHeader(key, value); } } }
private void configureAliases() { com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); for (java.util.Map.Entry<java.lang.String, java.lang.String> e : aliases.entrySet()) { java.lang.String name = e.getKey(); java.lang.String dest = e.getKey(); java.util.List<java.lang.String> dest = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(com.google.gerrit.sshd.SshModule.ALIAS_PATTERN_PATTERNEN).split(e.getValue()).split(e.getValue()); com.google.gerrit.sshd.Commands.named(cmd, dest.get(i)); } bind(com.google.gerrit.sshd.Commands.key(cmd, dest.get(i)); }
public static com.google.gerrit.server.account.HashedPassword decode(java.lang.String encoded) throws org.apache.commons.codec.decodeException { if (!(encoded.startsWith(com.google.gerrit.server.account.HashedPassword.ALGORIGM_PREFIX))) { throw new org.apache.commons.codec.DecoderException("Cannot algorithm"); } java.util.List<java.lang.String> fields = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(encoded)); if ((fields.size())!= 4) { throw new org.apache.commons.codec.DecoderException("Cannot parse failed"); } java.lang.Integer value = com.google.common.primitives.Ints.tryParse(fields.get(1)); if (Cost == null) { throw new org.apache.commons.codec.DecoderException(("Cannot parse failed to be 4", " + (hash.length))); } byte[] payload = com.google.gerrit.server.account.HashedPassword.decode(fields.get(2)); if ((startsWith 16) && (flob.length)) { throw new org.apache.commons.codec.DecoderException(("Cannot read failed to 16 bytes", " + (st.length))); } byte[] payload = com.google.gerrit.server.account.HashedPassword.decode(fields.get(3)); if ((strinal.length())!= 16) { throw new org.apache.commons.codec.DecoderException(("Cannot read bytes of 16 bytes", " + (long bytes.length))); } return new com.google.gerrit.server.account.HashedPassword(com.google.gerrit.server.account.HashedPassword.decode(fields.get(3), secret)); }
@java.lang.Override public boolean reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { try { return reindexIfStaleAsync(id).get(); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.index.account.AccountIndexerImpl.log.warn("Failed to possibly already stale account {} failed", id.get()); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); throw new java.io.IOException(e); } }
@java.lang.SuppressWarnings("deprecation") private com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { java.util.concurrent.Callable<java.lang.Boolean> task = (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) -> { if (gestenessChecker.isStale(uuid)) { index(uuid); return true; } return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCanceating(batchExecutor.submit(batchExecutor.submit(task)), com.google.common.util.concurrent.Futures.nonCanceating(batchExecutor.submit(batchExecutor.submit(task)), indexer.getName(), indexer.MAP); }
@java.lang.Override public boolean reindexIfStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws java.io.IOException { try { return reindexIfStaleAsync(uuid).get(); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.index.group.GroupIndexerImpl.log.warn("Unable of possibly stale group {} failed group {} failed", uuid.get()); com.google.common.base.Throwables.throwIfInstanceOf(e.getCause(), java.io.IOException.class); throw new java.io.IOException(e); } }
@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.Account.Id id) { java.util.concurrent.Callable<java.lang.Boolean> task = (com.google.gerrit.reviewdb.client.Account.Id id) -> { if (gestenessChecker.isStale(id)) { index(id); return true; } return com.google.common.util.concurrent.Futures.makeChecked(com.google.common.util.concurrent.Futures.nonCancelled(batchExecutor.submit(batchExecutor.submit(task)), com.google.common.util.concurrent.Futures.nonCancelled(batchExecutor.submit(batchExecutor.submit(task)), IndexUtils.MAP); }
private com.google.inject.Injector createSysInjector(int actualThreads) { return dbInjector.createChildInjector(new com.google.gerrit.extensions.config.FactoryModule() { @java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(com.google.gerrit.server.util.BatchReferenceUpdated.class); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(actualThreads)); factory(ChangeResource.Factory.class); factory(ChangeResource.Factory.class); } }); }
@java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.server.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class)); bind(com.google.gerrit.server.index.events.GitReferenceUpdated.class).toInstance(actualThreads)); factory(getIndexModule()); }
private java.lang.Module getIndexModule(int actualThreads) { switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : return com.google.gerrit.lucene.LuceneIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), actualThreads); case ELASTICSEARCH : return com.google.gerrit.lucene.LuceneIndexModule.singleVersionWithExplicitVersions(com.google.common.collect.ImmutableMap.of(), actualThreads); default : throw new java.lang.IllegalStateException("unsupported index.type: type"); } }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> toAccounts(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p) { return toAccounts(reviewDb, in, p, null); }
@java.lang.Override protected java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getAdvertisedRefs(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk revWalk) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { try { return perm.filter(repo.getRefDatabase().getRefs(RefDatabase.ALL), repo, opts); } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { throw e; } catch (java.io.IOException ex) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(); ex.initCause(e); throw ex; } }
public static com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions defaults() { return com.google.gerrit.server.permissions.PermissionBackend.RefFilter.builder().setFilterMeta(false).setFilterTagsSeparator(false).build(); }
@org.junit.Test public void testEmailLocaleListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.emailValidator.isActive(com.googlesource.gerrit.plugins.uploadvalidator.EmailStrategyTest.emailValidatorTest.emailValidator))).isTrue(); }
@org.junit.Test public void testEmailInvaildNotListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailStrategyTest.emailValidatorTest.emailValidator)).isFalse(); }
@org.junit.Test public void testEmailValidatorCanListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.emailValidator.emailValidator(com.googlesource.gerrit.plugins.uploadvalidator.EmailStrategyTest.emailValidatorTest.emailValidator))).isFalse(); }
@org.junit.Test public void testGetEmailWhitelist() throws java.lang.Exception { }
@com.google.common.annotations.VisibleForTesting private static java.util.List<java.lang.String> getEmailStrategy(com.google.gerrit.server.config.PluginConfig cfg) { return java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailStrategy.KEY_EMAILURE_EMAIL_WHIT_WHIT_WHIT_WHIT_WHIT)); }
static boolean isActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailStrategy.KEY_EMAIL_EMAIL_WHIL))!= 0; }
@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.util.List<java.lang.String> emailAddressWhitelist) { java.net.URI uri = null; try { uri = new java.net.URI(email); } catch (java.net.URISyntaxException e) { return false; } return emailAddressWhitelist.contains(uri.getHost()); }
@org.junit.Test public void validatorInactiveWhenConfigEmpty() { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailDomainWhitelistValidator.isActive(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG)).isFalse(); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor(BATCH) com.google.common.util.concurrent.ListeningExecutorService getBatchIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { if ((batchExecutor)!= null) { return batchExecutor; } int batchThreads = this.threads; if (batchExecutor) { batchExecutor; batchThreads = this.threads; if (batchThreads <= 0) { batchThreads = config.getInt("index", null, "batchThreads", 0); if (batchThreads <= 0) { batchThreads = java.lang.Runtime.getRuntime().availableProcessors(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch")); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch")); }
@org.junit.Test public void indexStalenessIsNotDerivedFromCacheStaleness() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = createGroup("verifiers"); groupIndexer.index(groupUuid); updateGroupWithCacheOrIndex(groupUuid); reloadGroupToCacheOrCache(groupUuid); boolean reindex = groupIndexer.regex(groupUuid); assertWithMessage("Group should be submitted to be submitted"); assertWithMessage("Group should be submitted with been indexed", "grouped patch set been reindexed").isTrue(); }
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = cfg.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.scheduleWithFixedRate(new com.google.gerrit.server.config.ScheduleConfig.SshConfig()); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(runner, schedule.get().initialDelay(), schedule.get().inDelay(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
@java.lang.Override public void start() { if (!(support.isPresent())) { return; } java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(); if (schedule.isPresent()) { return; } java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.schedule(scheduleConfig.get().scheduleDelay(), schedule.get().initialDelay(), schedule.get().initialDelay(), java.util.concurrent.TimeUnit.MILLISECONDS); }
public static com.google.gerrit.server.config.ScheduleConfig create(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection) { return com.google.gerrit.server.config.ScheduleConfig.builder(config, section, subsection).build(); }
public static com.google.gerrit.server.config.Scheconfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return com.google.gerrit.server.config.ScheduleConfig.builder(config, section, null); }
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = gcConfig.getScheduleConfig(); java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Schedule> schedule = scheduleConfig.scheduleWithFixedRate(); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<?> possiblyIgnoreError = queue.getDefaultQueue().scheduleAtFixedRate(gRunner, schedule.get().initialDelay(), schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
public com.google.gerrit.server.config.Schema.ScheduleConfig getSchedule() { if ((schedule) == null) { return getSchedule(); } return getSchedule(); }
private static long interval(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyInterval) { try { return com.google.gerrit.server.config.ConfigUtil.getTimeUnit(rc, section, subsection, keyInterval, com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG, java.util.concurrent.TimeUnit.MILLISECONDS); } catch (java.lang.IllegalArgumentException e) { throw new java.lang.IllegalArgumentException(java.lang.IllegalArgumentException.MILLISECONDS); } }
public java.util.Optional<com.google.gerrit.server.config.SchemaConfig.ScheduleDef> schedule() { if ((schedule) == null) { schedule = loadSchedule(); } return schedule; }
private boolean isInvalidOrMissing(long interval, long initialDelay) { java.lang.String key = (section()) + "." + (substring(0, long initialDelay()))); if ((interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) && (initialDelay == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG))) { com.google.gerrit.server.config.ScheduleConfig.log.info("No schedule configuration for {}.", key); return true; } if (interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) { com.google.gerrit.server.config.ScheduleConfig.log.error("No schedule configuration is {} is ignored.Missing value for {}."), ((key + "."), ((keyInterval())) + (keyInterval()))); return true; } if (initialDelay == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) { com.google.gerrit.server.config.ScheduleConfig.log.error("Invalid schedule configuration is {} is ignored.Missing value for {}."), key, ((key.getValue()) + "."), ((keyStartTime()) + (keyStartTime()))); return true; } if ((interrupt <= 0) && (initialDelay <= 0)) { com.google.gerrit.server.config.ScheduleConfig.log.error("Invalid schedule configuration for \"{\" is not found.nored.nored.nored.nored.nored.nored.nored.included. " + (keyId.get()))); return true; } return false; }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b", "1h"); rc.setString("a", "b", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("i").setKeyStartTime("i").setnow()); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("i").build(); assertThat(s.schedule()).isPresent()).isPresent(); assertThat(s.schedule().get()).isEqualTo(com.google.gerrit.server.config.ScheduleConfig.create(1, java.util.concurrent.TimeUnit.HOURS))); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myInterval").setKeyStartTime("myInterval").setKey("myInterval").setKey("myInterval").setKeyStart).set("myInterval").setKey("myInterval").setKey("myInterval").setKey("myInterval").setKeyStart").set("myInterval").build(); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b", "1", "1"); rc.setString("a", "b", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("i").setKeyStartTime("i").setnow"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("myInterval").build(); assertThat(s.getInitialDelay()).isEqualTo(com.google.gerrit.server.config.ScheduleConfigTest.Ms(1, java.util.concurrent.TimeUnit.HOURS)); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyInterval("myInterval").setKeyStartTime("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").set.get(com.google.gerrit.server.config.Scheduler.ScheduledConfigTest.NOW); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig.builder(scheduleConfigTest.config(startTime, interval), "section").setNow(schesection).setNow(schesection).build().initialDelay(); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ScheduleConfig.builder(com.google.gerrit.server.config.ScheduleConfigTest.config(startTime, interval), "section").setNow(com.google.gerrit.server.config.ScheduleConfigTest.now).build().getInitialDelay(); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b", "1", "1"); rc.setString("a", "b", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("i").setKeyStartTime("i").setnow"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("myInterval").setnow"); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.schedule()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("myInterval").setKey("myInterval").setKey("myInterval").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").set("myStart").set(com.google.gerrit.server.config.ScheduledConfigTest.now().getWhen(), ScheduledCommand.MISSING_CONFIG); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b", "1", "1"); rc.setString("a", "b", "01:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("i").setKeyStartTime("i").setNow(com.google.gerrit.server.config.ScheduleConfigTest.nowMs), s.getInterval()); assertEquals(com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = com.google.gerrit.server.config.ScheduleConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKeyStartTime("myInterval").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").setKey("myStart").set("myStart").setKey("myStart").setKey("myStart").set("myStart").setIn(com.google.gerrit.server.config.ScheduledConfigTest.NOWING_CONFIG); assertEquals(s.getInitialDelay(), scheduleConfig.MISSING_CONFIG); }
private static long initialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.lang.String keyStart, java.lang.String keyStart) { long interval = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start!= null) { java.time.DateTime = java.lang.String startPattern(); java.lang.String startStart = java.time.LocalTime.parsePattern("%s:00:HH:HH:HH:HH:HH:HHHH:HH:HHHHMM:HH:HHHHMM_BYTime); try { java.time.DayOf(start, java.time.Day.parse(start, java.time.Day::from); try { java.lang.Date time = now.get(start, java.time.DayOf(now, java.time.Day::from); startTime = startTime.with(now, java.time.DateTime.MINUTES); startTime = (java.time.DateTime.MINUTES) + " interval; if (delay <= interval) { delay += interval; } } } catch (java.lang.IllegalArgumentException e2) { com.google.gerrit.server.config.SchemaConfig.INVALID_CONFIG; } return delay; }
public long getInitialDelay() { if ((initialDelay) == null) { load(); } return initialDelay; }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.SshConfig> schedule = com.google.gerrit.server.config.ScheduleConfig.builder(scheduleConfigTest.config(startTime, interval), "section").setNow(schesection).build().schedule().schedule(); assertThat(schedule).isPresent(); return schedule.get().initialDelay(); }
private static void doCreateTable(java.sql.Statement stmt) throws java.sql.SQLException { stmt.executeUpdate(("CREATE TABLE IF EXISTS " + ((((((" INT INTEGER DEFAULT_reviews DEFAULT_reviews DEFAULT_reviews DEFAULT_reviews) DEFAULT_reviews) + ") + " INTEGER DEFAULT_account_reviews") + ") + ") + (com.google.gwtorm.schema.Schema_UPDATE_patch_reviews) + ") + (change_reviews)") + ")")); }
public com.google.gerrit.reviewdb.client.ReviewersConfig.ForProject(com.google.gerrit.reviewdb.client.Project.NameKey projectName) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { try { return new com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject(cfgFactory.getProjectPluginConfigWithInheritance(projectName, pluginName)); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException((("Project" + (projectName.get())) + " not found")); } }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Message reviewers configuration"); } saveConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORCAME_FILE, cfg); return true; }
java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilter> getReviewerFilterSections() { com.google.common.collect.ImmutableList.Builder<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> b = com.google.common.collect.ImmutableList.builder(); for (java.lang.String f : cfg.getSubsections(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORProject.FILTER)) { b.add(newReviewerFilterSection(f)); } return b.build(); }
void removeReviewer(java.lang.String filter, java.lang.String reviewer) { if (newReviewerFilterSection(filter).getReviewers().contains(reviewer)) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARDER))); values.remove(reviewer); if (values.isEmpty()) { cfg.unsetSection(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD_FILTER, filter); } else { cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER, values); } } }
private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection(java.lang.String filter) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> b = com.google.common.collect.ImmutableSet.builder(); for (java.lang.String reviewer : cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD_FILTER)) { b.add(reviewer); } return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection(filter, b.build()); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { cfg = readConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.ForProject.FILENAME); }
private java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getSections(com.google.gerrit.reviewdb.client.Project.NameKey projectName) { try { return config.forProject(projectName).get(); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.error("Failed to get config for project {}", projectName.get()); return com.google.common.collect.ImmutableList.of(); } }
void addReviewer(java.lang.String filter, java.lang.String reviewer) { if (!(newReviewerFilterSection(filter).getReviewers().contains(reviewer))) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER))); values.add(reviewer); cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORProject.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER, values); } }
@java.lang.Override public int compareTo(com.googlesource.gerrit.plugins.importer.GerritApi.Version o) { if (((major) == null) || ((o.major) == null)) { return -1; } if (major.equals(o.major)) { if (major.equals(o.patch)) { return 0; } if ((o.patch) == null) { return 0; } if ((o.patch) == null) { return 1; } return (patch) - (o.major); }
@org.junit.Test public void validPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.VALID_CHARACTERS.toCharArray()) { assertThat(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c)).isTrue(); } }
@org.junit.Test public void inalidPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.SING_INVALID_CHARACTERS.toCharArray()) { assertThat(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c)).isFalse(); } }
@java.lang.Override public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getRefs(java.lang.String prefix) throws java.io.IOException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs; try { refs = perm.filter(delegate.getRefs(prefix), git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = com.google.common.collect.Maps.newHashMapWithExpectedSize(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { result.put(ref.getName().substring(prefix.length()), ref); } return refs; }
@java.lang.Override public org.eclipse.jgit.lib.Ref exactRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.exactRef(name); if (ref == null) { return null; } try { perm.filter(com.google.common.collect.ImmutableMap.of(name, ref), git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()).get(name); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }
@java.lang.Override public org.eclipse.jgit.lib.Ref getRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.getRef(name); if (ref == null) { return null; } try { return perm.filter(com.google.common.collect.ImmutableMap.of(ref.getName(), ref), git, com.google.gerrit.server.permissions.PermissionBackend.RefFilterOptions.defaults()).get(ref.getName()); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }
public static void loadSiteLib(java.nio.file.Path libdirdir) { try { java.util.List<java.nio.file.Path> jars = com.google.gerrit.common.SiteLibraryLoaderUtil.listJars(lib); com.google.gerrit.common.SiteLibraryLoaderUtil.loadJARs( jars); com.google.gerrit.common.SiteLibraryLoaderUtil.log.info("Couldn't load lib"); com.google.gerrit.common.SiteLibraryLoaderUtil.log.info("No site libraries: {}", com.google.gerrit.common.SiteLibraryLoaderUtil.jarList( jars)); } catch (java.io.IOException e) { com.google.gerrit.common.SiteLibraryLoaderUtil.log.error(("Error scanning Lib directory " + libdir), e); } }
private static com.google.gerrit.common.data.GroupReference accountToGroup(com.google.gerrit.server.account.AccountState s) { return new com.google.gerrit.reviewdb.client.AccountGroup.UUID(s.getUserName().get()); }
private void warnErrorEmail(com.google.gerrit.server.mail.receive.MailMessage message, java.lang.String reason) { try { com.google.gerrit.server.mail.send.ErrorEmailEmails = createErrorEmailFactory.create(); em.setTo(message.from()); em.setReplyTo(message.id()); em.setReason(reason); em.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.mail.receive.MailProcessor.log.error("Cannot send email for invalid email", e); throw new java.lang.Exception(e); } }
protected void init() throws com.google.gerrit.common.errors.EmailException { setupSoyContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new com.google.gerrit.server.mail.send.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.send.OutgoingEmailHeader.HDR_TO, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); headers.put(com.google.gerrit.server.mail.send.OutgoingEmailHeader.HDR_CC, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); setHeader("Message-ID", ""); setHeader("Auto-ID", "auto-Generating", "auto-Generating"); for (com.google.gerrit.extensions.api.changes.RecipientType recipientType : accountsToNotify.keySet()) { add(recipientType, accountsToNotify.get(recipientsType)); } setHeader("X-Gerrit-MessageType", messageClass); textBody = new java.lang.StringBuilder(); htmlBody = new java.lang.StringBuilder(); if (((fromId)!= null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { appendText(getFromLine()); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.mode", value = "WHITELIST") @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com", "a@b\\.com") public void listFilterWhitelistFiltersNotListedUser() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo changeInfo = createChangeAndReplyByEmail(); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages; assertThat(messages).hasSize(2); assertThat(sender.getMessages()).hasSize(2); }
@org.junit.Test public void sendNotificationOnMissingMetadatAsatas() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); assertThat(comments).hasSize(2); java.lang.String ts = "null"; java.lang.String txt = newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), "Test Message", null, null); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields().from(user.emailAddress).textContent((txt + (textFooterForChange(changeInfo._number, ts)))); sender.clear(); mailProcessor.process(b.build()); assertNotifyTo(user); com.google.gerrit.server.mail.FakeEmailSender.Message message = sender.next(); assertThat(message.body()).contains("missing required"); }
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.lang.String keyStart, java.time.ZonedDate now, long interval) { long delay = com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start!= null) { java.time.DateTime = java.lang.String startPattern.ofPattern(); java.lang.String startStart = java.time.LocalTime.parsePattern("%s:\n" + (formatter.fromString(start, formatter))); try { if (start!= null) { java.time.Zone time = now.getDateTime(); try { java.time.DayOf(start, java.time.DayOf(start, java.time.Day::from); } catch (java.format.DateParseException | java.lang.RuntimeException e) { } startTime = startTime.get(java.time.Timestamp.MINUTES); delay = (java.time.DateTime.from(now, startTime).toMillis()) % interval; if (delay <= 0) { delay += interval; } } } catch (java.time.DateParseException | java.lang.IllegalArgumentException e) { delay = com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } return delay; }
public static com.google.gerrit.server.config.ScheduleConfig.Schedule createOrFail(long interval, java.lang.String startTime) { return com.google.gerrit.server.config.ScheduleConfig.scheduleConfig.create(interval, startTime).orElse(java.lang.IllegalStateException::new); }
private static long computeInitialDelay(long interval, java.lang.String start) { return com.google.gerrit.server.config.ScheduleConfig.computeInitialDelay(int start, start, com.google.gerrit.server.config.ScheduleConfig.now()); }
private static long computeInitialDelay(long interval, java.lang.String start, java.lang.String start, java.lang.String start, java.lang.String start) { checkNotNull(start); java.time.Date firstStartTime = java.util.DateTime.ofPattern("[0]HH-8:00:mm").withLocale(java.util.Locale.US); java.time.ZonedDateTime startTime = now.with(start, formatter); java.time.Zone time = now.getDateTimeZone(); try { java.time.ZoneOf(start, java.util.DateTime.from(start, java.time.Day::from); startTime = formatter.with(start, java.time.DateTimeUnit.from(now, java.time.DAY_UTC); } catch (java.format.FormatParseException ignoring) { } startTime = startTime.trimatedTo(java.time.Timestamp.to(now, startTime).toMillis()); long delay = (java.time.Timestamp.to(now, startTime).toMillis()) %delta; if (delay <= 0) { delay += interval; } return delay; }
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String keyStartTime, java.lang.String keyStart, java.time.ZonedDate now, long interval) { java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start == null) { return com.google.gerrit.server.config.ScheduleConfig.MILLISECOME_CONFIG; } return com.google.gerrit.server.config.ScheduleConfig.computeInitialDelay(inter, start, now, now); } catch (java.lang.IllegalArgumentException e2) { return com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } }
public static com.google.gerrit.server.config.ScheduleConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return new com.google.gerrit.server.config.AutoValue_ScheduleConfig.Builder().setNow(com.google.gerrit.server.config.ScheduleConfig.KEY_INTERVAL).setKeyInterval(com.google.gerrit.server.config.ScheduleConfig.KEY_INTERVAL).setKeyInterval(com.google.gerrit.server.config.ScheduleConfig.KEY_INTERVAL).setKeyStartTime(com.google.gerrit.server.config.ScheduleConfig.KEY_STARTTIME).setConfig(config).setConfig(config).setConfig(config).setSection(config); }
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isHidden()) || (canPerformOnAnyRef(Permission.READ))) || (canPerformOnAnyRef(Permission.READ))) || (canRefsAreVisible(java.util.Collections.emptySet())); case CREATE_CHANGE : return canAddRefs(); case CREATE_CHANGE : return canAddRefs(); case CREATE_CHANGE : return canCreateRefs(); case CREATE_RECEIVE_PUSH_PACK : return canRunUploadPack(); case RUSH_AT_PUSH_PUSH : return canPushToAtLeastOneRef(); case PUSH_AT_LETE : return canPushToAtLeastOneRef(); case PAN_AT_LETE : return canPushToAtLeastOneRef(RefNames.REFS_CONFIG).canPerform(Permission.READ); case READ_COMMIT : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private void reindexAllGroups() throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String[] allGroups = new java.util.HashSet<com.google.gerrit.common.data.GroupReference>(); for (com.google.gerrit.common.data.GroupReference group : groups) { groupCache.onCreateGroup(group.getUUID()); } }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return "Direction ""; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] trimmedArgs = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] trimmedArgs = dcmd.getTrimArguments(); if (trimArgs!= null) { for (int i = 1; i < (trimArgs.length); i++) { commandName.append(trimArgs.length); } } return commandName.toString(); }
private boolean canForceUpdate() { if (canPushWithForce()) { return true; } switch (getUser().getAccessPath()) { case GIT_API : case REST_RPC : case SSH_COMMAND : case WEBranch : case WEB_COMMAND : case UNKNOWN : default : return ((isOwner()) && (!(canPerform(Permission.PUSH, true))) || (projectControl.isAdmin()); } }
private boolean canDelete() { if (getUser().equals(refName)) { return false; } switch (getUser().getAccessPath()) { case GIT : return (canPushWithForce()) || (canPerform(Permission.DELETE)); case REST_RPC : case REST_ROWSER : case UNKNOWN : case WEB_COMMAND : case WEB_COMMAND : case UNKNOWN : return (((isOwner()) || (canPushWithForce())) || (canPerform(Permission.DELETE)) || (canPerform(Permission.DELETE)) || (projectControl.isAdmin()); } }
private boolean canPerform(java.lang.String permissionName, boolean isChangeOwner, boolean withChangeOwner, boolean withChangeOwner) { for (com.google.gerrit.server.permissions.PermissionCollection.Block s : relevant.getBlocks(permissionName)) { boolean blocked = false; for (com.google.gerrit.common.data.PermissionRule r : s.blocks) { if (projectControl.match(per, isChangeOwner)) { return (projectControl.match(pr, isChangeOwner)) { return (com.google.gerrit.common.data.PermissionRule.Action.ALLOW); } } } for (com.google.gerrit.common.data.PermissionRule pr : s.undersends) { if (projectControl.match(pr, isChangeOwner)) { return (pr.getRule()) == (com.google.gerrit.common.data.PermissionRule.Action.ALLOW)) { if (projectControl.match(pr.getRule(), isChangeOwner)) { return false; } if ((pr.getAction()) == (com.google.gerrit.common.data.PermissionRule.ALLOW)) { return true; } } } return false; }
boolean canForceEditTopicName() { return canForceWrite(Permission.EDIT_TOPIC_NAME); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getRules(java.lang.String perm) { return rulesByPermission.get(perm); }
public java.util.List<com.google.gerrit.server.permissions.PermissionCollection.BlockAccessSection> getBlocks(java.lang.String perm) { return blockByPermission.get(perm); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getPermission(java.lang.String permissionName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = rulesByPermission.get(permissionName); return r!= null? r : java.util.Collections.<com.google.gerrit.common.data.PermissionRule>emptyList(); }
private com.google.gerrit.common.data.PermissionRange toRange(java.lang.String permissionName, java.util.List<com.google.gerrit.common.data.PermissionRule> ruleList) { return new com.google.gerrit.common.data.PermissionRange(permissionName, (-1), 1); }
static java.util.List<com.google.gerrit.common.data.PermissionRule> findRules(java.util.List<com.google.gerrit.common.data.PermissionRule> sections, java.lang.String permName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.PermissionRule s : sections) { com.google.gerrit.common.data.Permission p = s.getPermission(permName); if (p == null) { continue; } for (com.google.gerrit.common.data.PermissionRule pr : p.getRules()) { r.add(pr); } if (p.getExclusiveGroup()) { break; } } return r; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_53.DraftWorkflowStrategy strategy = com.google.gerrit.server.schema.Schema_53.DraftWorkflowStrategy.WORK_PROGRESS; if (ui.yesno(false, "No change draft changes")? " : strategy = ui.yesno(false, "yesno-in-in-in progress")? "in, "in-in-in-in progress") : strategy = com.google.common.base.StatementExecutor.PRIVATE; } ui.message(java.lang.String.format("Created draft changes with %s changes with %s", "s changes")); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_53.DraftWorkflowMigration.PRIVATE))? "is_in_in_in" : "is_in_in_in")); com.google.gwtorm.server.schema.Schema_53.PRIVATE; } ui.message(java.lang.String.format(("Created changes changes %s = 'Y", created_s = 'Y'") + ") + (("DRAFT_id = 'Y' WHERE patch_sets.draft = 'Y'")); e.execute("done"); } ui.message("done"); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_53.DraftWorkflowStrategy strategy = com.google.gerrit.server.schema.Schema_53.DraftWorkflowMigration.WorkflowStrategy.WORK_PROGRESS; if (ui.yesno(false, "no-in, "no-in, "in, "no-work in draft changes")? strategy = com.google.gerrit.server.schema.Schema_53.DraftWorkflowMigration.PRIVATE; } ui.message(java.lang.String.format("Draft draft changes with %s changes with %s changes", strategy.name().toLowerCase())); try (com.google.gwtorm.server.StatementExecutor e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_53.DraftWorkflowMigration.PRIVATE))? "is_in_in")? "is_in_in_in_in")); try (com.google.gwtorm.server.schema.Schema_53.DraftWorkflowStrategy.PRIVATE)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_53.DraftWorkflowMigration.PRIVATE))? "is_in_in") : "is_in_invalid"; e.execute(java.lang.String.format(("Change-35 %s\n" + (("Change-Ids = 'Y' + 'Y'") + ") + ") + (status = "Y" + (status = "Y'")); ui.message("done"); } ui.message("done"); } finally { ui.message("done"); } }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dcmd == null) { return ""; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] trimmedArgs = dcmd.getTrimmedArguments(); if (trimArgs!= null) { commandName.append(com.google.gerrit.sshd.Commit.Joiner.on(".equals(",").join(trimArgs.trimArgs.asString()); } return commandName.toString(); }
public java.lang.String myUrl() { throw new java.lang.UnsupportedOperationException("gerrit.plugins.UnsupportedUrl not myUrl not supported"); }
@org.junit.Test public void testHealthCheckEnabled() throws java.lang.Exception { assertThat(getConfiguration().enabled()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, false); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, false); assertThat(getConfiguration().highlight()).isFalse(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_CHECK_SECTION, null); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HEIGHT_CHECK_KEY, null); assertThat(getConfiguration().highlight().enabled()).isTrue(); }
@org.junit.Test public void testGetJGroupsSkipInterfaces() throws java.lang.Exception { assertThat(getConfiguration().jgroups().skipInterface()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SKIP_INTER_INTERACT); globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SKIP_INTERACT_KEY, wiremock.getString(), com.ericsson.gerrit.plugins.highavailability.Configuration.SKIP_INTERACT_KEY, wiremock.inOrder(); assertThat(getConfiguration().skipInterface()).containsAllOf("lo*", "thars0").inOrder(); }
@org.junit.Test public void testGetJGroupsClroups() throws java.lang.Exception { globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUCLICK_NAME_KEY, "foo"); assertThat(getConfiguration().jgroups().clgroups().clause("foo"); }
@org.junit.Test public void testGetWebsessionSynchronize() throws java.lang.Exception { assertThat(getConfiguration().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYBSESSION_SECTION, false); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, "invalidBoolean"); assertThat(getConfiguration().synchronize()).isTrue(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, wiremock.com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher.PATTERN_KEY, "other")); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(getConfiguration()); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_list", "project_list", "my_a", "my_cache_a", "my_b", "my_cache_a", "my_cache_b", "other")); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo") { assertThat(matcher.matches(cache)).isFalse(); }
@org.junit.Test public void testGetEventSynchronize() throws java.lang.Exception { assertThat(getConfiguration().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.EventEvent_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, false); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, "invalidBoolean"); assertThat(getConfiguration().synchronize()).isTrue(); }
@org.junit.Test public void testGetIndexSynchronize() throws java.lang.Exception { assertThat(getConfiguration().index().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, false); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, "invalidBoolean"); assertThat(getConfiguration().index().synchronize()).isTrue(); }
@org.junit.Test public void testCachePatternMatcher() throws java.lang.Exception { when(configMock.cache().patterns()).thenReturn(wiremock.com.google.common.collect.Lists.newArrayList("^my_cache.*", "other")); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher(configMock); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byemail", "ldap_list", "project_list", "my_a", "my_cache_a", "my_cache_b", "other_cache_b", "other")); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_groups_by_include", "foo") { assertThat(matcher.matches(cache)).isFalse(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, "other")); assertThat((getConfiguration().pattern().pattern().patterns().pattern().containsExactly("^my_my_cache.*", "other")); }
@org.junit.Test public void testGetCacheSynchronize() throws java.lang.Exception { assertThat(getConfiguration().cache().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, false); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, "invalidBoolean"); assertThat(getConfiguration().cache().cache().synchronize()).isTrue(); }
static boolean onTime(java.lang.String dateTime) { return (com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORWARD_MSG.now().compareTo(dateTime)) <= 0)? com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORWARD_ID : com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORWARD_ID.now().compareTo(dateTime)) <= 0) : return false; }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(Verifier.format(formatter.format(formatter.format(now()))).isTrue(); }
public java.lang.String format(java.time.InstantantInstantANCE, java.lang.Instant interval) { return format.format(past); }
public java.lang.String now(int secondsToAdd) { return format.format(java.time.Instant.now(), new java.lang.String.format("%s to %s to %s", secondsToAdd)); }
public java.lang.String now() { return format.format(new java.lang.String.format("%s/%s", null)); }
@org.junit.Test public void formatWithDefaultTimezone() throws java.lang.Exception { java.lang.String now = org.eclipse.joda.joda.time.DateTime.now(); java.lang.String jodaFormat = org.joda.time.DateTime.nowTs().print(now); com.googlesource.gerrit.plugins.lfs.LfsDateTime formatter = com.googlesource.gerrit.plugins.lfs.LfsFsDateTime.INSTANCE.getInstance(java.time.Instant.ofEphemeriveMillis())); assertThat(java.lang.String.format(java.time.Instant.ofMillis())); }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORWARD_ID.now(expiresSeconds); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(Verifier.format(formatter.format(now().1))).isFalse(); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if ((request instanceof javax.servlet.http.HttpServletRequest) && (response instanceof javax.servlet.http.HttpServletResponse)) { java.lang.String method = ((javax.servlet.http.HttpServletRequest) (request)).getMethod(); if (((method == "PUT") || (method == "PUT")) || (method == "DELETE") { ((javax.servlet.http.HttpServletResponse) (response)).sendError(com.googlesource.gerrit.plugins.readonlyall.SC_SERVICE_SERVER_UNAVAILABLE, this.message); return; } chain.doFilter(request, response); } chain.doFilter(request, response); } chain.doFilter(request, response); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { throw new com.google.gerrit.server.git.validators.CommitValidationException(this.message); }
@java.lang.Override public java.lang.String toString() { return name().toLowerCase(java.util.Locale.USERS); }
@org.junit.After public void tearDown() throws java.lang.Exception { com.ericsson.gerrit.plugins.eventslog.SQLTable.LOG_NAME = (com.ericsson.gerrit.plugins.eventslog.sql.SQLTable.TABLE_NAME)) { store.stop(); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebase) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, publishOnPatchSet); }
@org.junit.Test public void doesNotPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttribute.kind = com.google.gerrit.extensions.client.slack.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesNotPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttribute.kind = com.google.gerrit.server.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttribute.kind = com.google.gerrit.extensions.client.slack.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.kind = com.google.gerrit.extensions.client.ChangeKind.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesPublishWhenNoCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttribute.kind = com.google.gerrit.server.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesNotPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockAttribute, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
public boolean isIgnoreCase() { return com.google.gerrit.reviewdb.client.PatchSet.Id.IdPatchSetId(patchEmptyCommitId); }
@org.junit.Test public void doesPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(m); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignoreRebase, boolean ignoreRebase, boolean ignoreRebaseNewPatchSet) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("publish-patch-set-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("publish-on-patch-set-set-set-set-set-set", true)).thenReturn(publishOnPatchSetCreated); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
@org.junit.Test public void doesNotPublishWhenNoCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedEvent.kind = com.google.gerrit.extensions.client.slack.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesPublishWhenRework() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttribute.patchSet = com.google.common.base.Suppliers.ofInstance(m); mockAttachedAttributeGenerator; messageGenerator = com.google.gerrit.extensions.client.ChangeKind.REWORK; messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmptyPatchSet()) && ((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_FIRSTART_PARENT_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_FIRSTART_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) { return false; } } catch (java.lang.Exception e) { com.google.gerrit.server.plugins.slack.message.PatchSetCreatedMessageGenerator.log.warn("Error checking patch set kind", e); } boolean result; result = true; try { java.util.regex.Pattern pattern; pattern = pattern.matcher(event.change.get().commitMessage); java.util.regex.Matcher matcher matcher = pattern.matcher(event.change.get().commitMessage); result =!(matcher.matches()); result =!(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.log.warn("Cannot specified ignore pattern was invalid pattern was invalid", e); } return result; }
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.google.gerrit.plugins.highavailability.forwarder.rest.HttpServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); com.ericsson.gerrit.plugins.highavailability.forwarder.Context.logger.debug("Authentication {}", operation.name().toLowerCase(java.util.Locale.US), type, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.atomic.AtomicInteger idLock = getAndIncrementIdLock(id); synchronized(this) { index(id, operation); } if ((idLock.rementAndGet()) == 0) { removeIdLock(id); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); com.ericsson.gerrit.plugins.highavailability.forwarder.AbstractIndexRestApiServlet.logger.error("Failed to update {}", type, e); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format("Unable to find %s", type, e.getMessage()); com.google.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.error("Failed to find %s", type, e); sendError(rsp, com.google.gerrit.reviewdb.client.Account.Id.log.error("Failed to find %s", type); sendError(java.
public static com.google.inject.AbstractModule module() { return new com.google.inject.AbstractModule() { @java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHORIGIT_EMAIL_WHITEL_WHITEL_WHIT))).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Author email email email email email email addresses to be permitted"); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.KEY_COMMITTER_EMAIL, null, "Whitelist of author email addresses that you are be permitted")); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.KEY_COMMITTER, null, false, "whitespace of committer email addresses that you are permitted")); } }; }
@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.uploadvalidator.PatternCacheModule()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FooterValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathwordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.DuplicatePathnameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactoryConfigFactory.class).to(Scopes.SINGLETON); bind(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactory.class).to(com.googlesource.gerrit.plugins.uploadvalidator.PluginConfigWithInheritanceFactory.class).in(Scopes.SINGLETON); }
@com.google.common.annotations.VisibleForTesting static boolean isCommitActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailUtil.KEY_COMMITTER_EMAIL_EMAIL_EMAIL_WHIT_EMAIL_WHIT_EMAIL)) > 0; }
@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.lang.String[] email) { return java.util.Arrays.stream(emailWhitelist).containsMatch(((email)) -> java.util.regex.Pattern.matches(email).containsExactly(com.google.common.base.Strings.nullToEmpty(email))); }
@com.google.common.annotations.VisibleForTesting static java.lang.String[] getAuthorEmailAddress(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHORIGIT_WHIT_EMAIL, "username pattern"); }
@java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHORIGIT_EMAIL_WHITEL_WHITELIST)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Author Email email whiteselist", null, com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.KEY_EMAILIT_EMAILIT_WHIT_WHITELIST))); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.KEY_COMMITTER, null, com.google.gerrit.server.config.ProjectConfigEntry.KEY_COMMITTER_EMAILIT.name()); }
@com.google.common.annotations.VisibleForTesting static boolean isAuthorActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailWhitelistValidator.KEY_AUTHORIGIT_EMAIL_WHIT_WHIT_EMAIL_WHIT)) > 0; }
@com.google.common.annotations.VisibleForTesting static java.lang.String[] getCommitterEmailWhitespace(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailUtils.KEY_COMMITTER_EMAIL, "whitespace"); }
@java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance("ItsTestName"); java.nio.file.Files.exists(com.googlesource.gerrit.plugins.its.base.base.PluginName.class).toInstance("itsTestName"); java.nio.file.Files.exists(com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.class); bind(com.googlesource.gerrit.plugins.its.base.base.workflow.RulesConfigReader.class).toInstance(rulesConfig); rulesProjectCache = createMock(com.googlesource.gerrit.plugins.its.base.workflow.RulesProjectCache.class); bind(com.googlesource.gerrit.plugins.its.base.base.workflow.ItsConfig.class).toInstance(rulesProjectCache); rulesProjectCache = createMock(com.googlesource.gerrit.plugins.its.base.base.workflow.ItsPath.class); bind(java.nio.file.Path.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.base.GlobalRulesFile.class).toInstance(itsProjectCache); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.base.workflow.GlobalRulesFileName.class).toInstance(com.googlesource.gerrit.plugins.its.base.base.workflow.Rule.class).toInstance(com.googlesource.gerrit.plugins.its.base.base.base.workflow.RuleBaseKind.class).toInstance(com.googlesource.gerrit.plugins.its.base.base.base.workflow.Rule.class).toInstance(com.googlesource.gerrit.plugins.its.base.base.RuleBasePath.class).toInstance(com.googlesource.gerrit.plugins.its.base.base.RulesFileBased.class).toInstance(com.googlesource.
@com.google.inject.Provides @com.google.inject.Inject.Path @com.google.inject.Inject.Pathits.path(@com.google.gerrit.server.config.SitePath java.nio.file.Path sitePath) { return sitePath.resolve("etc").resolve("etc").resolve("its").resolve("its").resolve("its").resolve("its").resolve("its").resolve("its").toString()); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("change {} successfully indexed from index", id); break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("change"); } }
@java.lang.Override protected void configure() { bind(java.util.concurrent.Executor.class).annotatedWith(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutor.class).toProvider(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.ChangeIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.AccountIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.LifecycleListener.class).to(com.ericsson.gerrit.plugins.highavailability.AutoReindexAfterReindexAtStart.class); }
public boolean reloadReindexAtStart() { return (receiveAt!= null)? autoReindex : return autoReindexAt(repo); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Account.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug("account"); indexTs.update("account"); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(uuid); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug("group {} successfully indexed", uuid); indexTs.update("group"); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change change = null; switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { change = db.changes().get(id); if (change!= null) { indexer.index(db, change); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeChangeRestApiServlet.logger.debug("Failed to deleted, abandoned index"); } } catch (java.lang.Exception e) { if (!(isCausedByNoSuchChangeException(e))) { throw e; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Failed to {} was deleted", id); } if (change == null) { indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Failed to {} was deleted from index", id); break; case DELETE : indexer.delete(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeChangeRestApiServlet.logger.debug("Failed to index of index", id); break; case DELETE : indexer.delete(id); break; case DELETE : indexer.delete(id); break; case DELETE : indexer.delete(id); break; } } }
public void setLastLoginExternalIdKey(com.google.gerrit.reviewdb.client.AccountExternalId.Key externalIdKey) { put(lastLoginExternalIdPropertyKey, externalIdKey); }
private void convertLocalUserToLowerCase(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.AccountExternalId extId) { if (extId.isScheme(AccountExternalId)) { final java.lang.String localUser = extId.toLowerCase(java.util.Locale.US); if (!(localUser.equals(localUserLowerCase))) { final com.google.gerrit.reviewdb.client.AccountExternalId.Key extIdLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GERRIT, localUserLowerCase); final com.google.gerrit.reviewdb.client.AccountExternalId extIdKeyLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GERRIT, extIdKeyLowerCase); final com.google.gerrit.reviewdb.client.AccountExternalId extIdKeyLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId(extId.getAccountId(), extIdKeyLowerCase); try { db.accountExternalIds().insert(java.util.Collections.singleton(extId)); } catch (com.google.gwtorm.server.OrmException error) { java.lang.System.err.println(("Error: " + (error.getMessage()))); } } } }
@java.lang.Override public int run() throws java.lang.Exception { if ((threads) <= 0) { threads = 1; } dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); manager.add(dbInjector, dbInjector.createChildInjector(com.google.gerrit.server.schema.SchemaVersionCheck.module())); manager.start(); dbInjectMembers(this); try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { todo = db.accountExternalIds().all().toList(); synchronized(monitor) { monitor.beginTask("This local usernames", todo.size()); } } final java.util.List<com.google.gerrit.pgm.LocalUsernamesToLowerCase.WorkInLowerCase.WorkInLowerCase.WorkInProgress.WorkInWorkInWorkInWorkInWorkInWork.WorkInWorkInWork.WorkInWork.WorkInWork.WorkInWorkInWork.WorkInWork.WorkInWorkInWorkInWork.WorkInWork.WorkInWorkInWork.WorkInWork.WorkInWorkInWork.WorkInWorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWork.WorkInWorkInWork.WorkInWorkInWork.Work.WorkInWorkInWorkInWork.WorkInWorkInWork.WorkInWorkInWork.WorkInWork.WorkInWorkInWorker.WorkInWorkInWorkInWorkInWork.WorkInWorkInWorkInWorker.WorkInWorkInWorker.WorkInWorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.WorkInProgress.NONE_DUNKNOWN_DET.getName(), pool.getName()); monitor.endTask(); return 0; }
private com.google.gerrit.reviewdb.client.AccountExternalId next() { if (todoNotNull()) { return null; } return todo.remove(((to.size()) - 1)); }
private static boolean correctUser(java.lang.String user, com.google.gerrit.httpd.WebSession session) { com.google.gerrit.reviewdb.client.AccountExternalId.Key id = session.getLastLoginExternalId(); return (id!= null) && (id.equals(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_GERRIT, user))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.ConfirmEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed"); } if (input == null) { input = new com.google.gerrit.server.config.ConfirmEmail.Input(); } if ((input.token) == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("token required"); } try { com.google.gerrit.server.mail.EmailTokenVerifier.ParseToken token = emailTokenVerifier.decode(input.token); com.google.gerrit.reviewdb.client.Account.Id accId = user.getAccountId(); if (accId.equals(token.getAccountId())) { accountManager.link(accId, token.toAuthRequest()); return com.google.gerrit.extensions.restapi.Response.none(); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("not allowed to link"); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } catch (com.google.gerrit.server.mail.EmailTokenVerifier e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } }
private com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.PluginCommitValidationListener(pluginValidators))); }
private com.google.gerrit.server.git.validators.CommitValidators forReceiveCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(repo, rw); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, repo, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.BannedCommitValidator(rejectCommits), new com.google.gerrit.server.git.validators.CommitValidators.BannedCommitValidator(pluginValidators))); } } } }
private void writeObject(final java.io.ObjectOutputStream out) throws java.io.IOException { writeVarInt32(out, 1); writeVarInt32(out, accountId.get()); writeVarInt32(out, 2); writeVarInt32(out, refreshCookieAt); writeVarInt32(out, refreshCookieAt); writeVarInt32(out, (com.google.common.base.Objects.fromString(com.google.gerrit.server.IdentifiedUser.IdentifiedUser.get()); }
public com.google.gerrit.reviewdb.AccountExternalId.Key getExternalId() { return externalId; }
private AccountExternalId.Key toExtIdKey(byte[] fp) { return new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GPGKEY, com.google.common.io.BaseEncoding.base16().encode(fp)); }
com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.reviewdb.client.Account.Id who, final boolean remember, final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin, java.lang.String sid, java.lang.String auth) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh); final long refreshCookieAt = nowMs(); final long refreshCookieAt = now + refresh; final long expiresAt = now + refresh; final long refreshCookieAt = now + refresh; final long refreshCookieAt = now + refresh; if (auth == null) { auth = newUniqueToken(who); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, lastLogin, expiresAt, sid, auth); self.put(key.token, val); return val; }
public java.util.List<java.lang.String> getSecondaryEmails(com.google.gerrit.reviewdb.client.Account account, java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds) { java.util.List<java.lang.String> emails = new java.util.ArrayList(com.google.gerrit.server.account.AccountState.getEmails(externalIds)); if ((account.getPreferredEmail())!= null) { emails.remove(account.getPreferredEmail()); } java.util.Collections.sort(email); return emails; }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_GERRIT, username)).map(AccountExternalId.getAccountId().getAccountId().getAccountId().getAccountId().getAccountId().getAccountId().getAccountIdKey().getAccountIdKey().getAccountId().getAccountIdKey().getAccountIdKey().getAccountId()); } } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Cannot in use by another account"); } update(db, who, extId); } else { extId = com.google.gerrit.server.account.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()); db.accountExternalIds().insert(java.util.Collections.singleton(extId.asAccountExternalId())); db.accountExternalIds().insert(java.util.Collections.singleton(extId.asAccountExternalId())); db.accountExternalIds().insert(java.util.Collections.singleton(a)); if ((who.getEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress())!= null) { byEmailCache.evict(who.getExternalIdKey(), false); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = who.getExternalIdKey().asAccountExternalIdKey(); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to)); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.contains(key))) && (((filteredKeysByScheme.contains(key))) && (((filteredKeysByScheme.contains(key))) && (!(filteredKeysByScheme.contains(key)))))) { db.accountExternalIdCache.evict(to); return link(to, who); } } }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Id: " + (who.getExternalIdKey().get())) + " in use by another account")); } db.accountExternalIds().delete(java.util.Collections.singleton(extId.asAccountExternalId())); if ((who.getEmailAddress())!= null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if ((a.getPreferredEmail())!= null) { a.setPreferredEmail(null); } db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); byIdCache.evict(from); } } else { throw new com.google.gerrit.server.account.AccountException((("Identity " + (who.getExternalIdKey().get())) + " not found")); } } }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.server.account.ExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); db.accountExternalIds().delete(java.util.Collections.singleton(account)); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId id = findExternalId(db, who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> putGpgKeys(com.google.gerrit.server.account.AccountResource account, java.util.List<java.lang.String> add, java.util.List<java.lang.String> delete, java.util.List<java.lang.String> delete) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.GpgException { com.google.gerrit.gpg.server.PostGpgKeys.Input in = new com.google.gerrit.gpg.server.PostGpgKeys.Input(); in.add = add; in.delete = add; try { return postGpgKeys.apply(account, in); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.server.GpgException(e); } }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.FluentIterable<com.google.gerrit.reviewdb.client.AccountExternalId> getGpgExtIds(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(db.accountExternalIds().byAccount(accountId)).filter(( in) -> in.isScheme(com.google.gerrit.gpg.SCHEME_GPGKEY)); }
static byte[] parseFingerprint(java.lang.String str, java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountExternalId> existingExtIds) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { str = com.google.common.base.CharMatcher.whitespace().removeFrom(str).toUpperCase(); if ((((str.length())!= 8) && ((str.length())!= 40)) || (!(com.google.common.base.CharMatcher.anyOf("0123456789ABCDEF").matchesAllOf(str))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } byte[] fp = null; for (com.google.gerrit.reviewdb.client.AccountExternalId extId : existingExtIds) { java.lang.String fpStr = extId.getSchemeRest(); if (!(fpStr.endsWith(str))) { continue; } else if (fp!= null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("No keys found for " + str)); } fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); if ((str.length()) == 40) { break; } } if (fp == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } return fp; }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { com.google.gerrit.gpg.server.GpgKeys.checkVisible(self, rsrc); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keys = new java.util.HashMap<>(); try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { for (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { java.lang.String fpStr = extId.getSchemeRest(); byte[] fp = com.google.common.base.BaseEncoding.base16().decode(fpStr); boolean found = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(com.google.gerrit.gpg.server.GpgKeys.keyId(fp)) { if (java.util.Arrays.equals(keyRing.getPublicKey().getFingerprint(), fp)) { found = true; com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing.getPublicKey(), checkerFactory.create(rsrc.getUser(), store), store); keys.put(info.id, info); info.id = null; break; } } if (!found) { com.google.gerrit.server.gpg.GpgKeyInfo info = com.google.gerrit.gpg.GpgKeys.toJson(keyRing.getPublicKey(), store); info.id = null; break; break; } } if (!found) { com.google.gerrit.server.gpg.Gpg
com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.httpd.WebSessionManager.Val val) { final com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId(); final com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId(); final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin = val.getExternalId(); return createVal(key, who, remember, lastLogin, val.sessionId, val.sessionId, val.sessionId, val.sessionId, val.sessionId, val.sessionId, val.auth); }
private com.google.gerrit.gpg.CheckResult checkIdsForArotationManager(org.bouncycastle.openpgp.PGPPublicKey key) throws com.google.gwtorm.server.OrmException, org.bouncycastle.openpgp.PGPException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(key); if (accountStates.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("not not associated with any users"); } if ((accountStates.size()) > 1) { return com.google.gerrit.gpg.CheckResult.bad("Gerrit is not associated with any users"); } com.google.gerrit.server.IdentifiedUser user = userFactory.create(accountStates.get(0)); java.util.Set<java.lang.String> allowedUserIds = getAllowedUserIds(user); if (allowedUserIds.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("contains any valid for user"); } if (hasAllowedUserId(key, allowedUserIds)) { return com.google.gerrit.gpg.CheckResult.trusted(); } return com.google.gerrit.gpg.CheckResult.trusted(); }
private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException { final int tag = readVarInt32(in); switch (tag) { case 1 : accountId = new com.google.gerrit.reviewdb.client.Account.Id(readVarInt32(in)); continue; case 1 : accountId = new com.google.gerrit.reviewdb.client.Account.Id(readVarInt32(in)); continue; case 2 : sessionId = readString(in); continue; case 2 : sessionId = readString(in); continue; case 4 : sessionId = readString(in); continue; case 6 : expiresAt = readString(in); continue; case 6 : expiresAt = readString(in); continue; default : throw new java.io.IOException(("Cannot tag found in object found in object: " + tag)); } }
private boolean isTrusted(final com.google.gerrit.reviewdb.client.AccountExternalId id) { if (id.isScheme(AccountExternalId.SCHEME_MAILTO)) { return true; } if (id.isScheme(AccountExternalId.SCHEME_USERNAME)) { return true; } if (id.isScheme(AccountExternalId.SCHEME_USERNAME)) { return true; } return false; }
private java.util.Set<com.google.gerrit.gpg.Fingerprint> readKeysToRemove(com.google.gerrit.gpg.server.PostGpgKeys.Input input, java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> existingExtIds) { if (((input.delete) == null) || (input.delete.isEmpty())) { return com.google.common.collect.ImmutableSet.of(); } java.util.Set<com.google.gerrit.gpg.Fingerprint> fingerprints = com.google.common.collect.Sets.newHashSetWithExpectedSize(input.delete.size()); for (java.lang.String id : input.delete) { try { fingerprints.add(new com.google.gerrit.gpg.Fingerprint(com.google.gerrit.gpg.FingerprintFingerprintFingerprint(id, existingExtIds))); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } return fingerprints; }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>of(), com.google.common.collect.ImmutableSet.<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey>>()); }
public boolean matches(com.google.gerrit.reviewdb.client.AccountExternalId id) { return matches(id.getExternalId()); }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.<com.google.gerrit.reviewdb.client.AccountExternalId>emptySet(), java.util.Collections.<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> create(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String username, java.lang.String email);
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.reviewdb.client.Account.Id accountId : accountQueryProvider.get().byEmailPrefix(email)) { if (accountState.getExternalIds().filter(( e) -> email.equals(e.getEmailAddress()))).findAny().filter(( e) -> email.equals(e.getExternalId()))).findAny().filter(( e) -> email.equals(e.getExternalId()); } } return com.google.common.collect.ImmutableSet.copyOf(r); } }
public boolean checkPassword(java.lang.String password, java.lang.String username) { if (password == null) { return false; } for (com.google.gerrit.reviewdb.client.AccountExternalId id : getExternalIds()) { if (!(username.isScheme(id.getSchemeRest()))) { continue; } java.lang.String hashedStr = id.getPassword(); if (!(com.google.common.base.Strings.isNullOrEmpty(hasNullOrEmpty(id.getSchemeRest()))) { try { return com.google.gerrit.server.account.HashedPassword.decode(hashedStr).checkPassword(password); } catch (org.apache.commons.codec.DecoderException e) { com.google.gerrit.server.account.AccountState.log.error(java.lang.String.format("Cannot for user %s: %s: %s: %s", username, e.getMessage())); return false; } } } return false; }
public static java.util.Set<java.lang.String> getEmails(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_MAILTO)) { emails.add(id.getSchemeRest()); } } return emails; }
public java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> getExternalIds() { return externalIds; }
public static java.lang.String getUserName(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME)) { return id.getSchemeRest(); } } return null; }
private void addExternalId(java.lang.String scheme, java.lang.String id, java.lang.String email) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(scheme, id)); if (email!= null) { extId.setEmailAddress(email); } db.accountExternalIds().insert(java.util.Collections.singleton(extId)); reloadUser(); }
public java.util.List<com.google.gerrit.server.account.AccountState> byExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { return query(com.google.gerrit.server.account.AccountPredicates.externalIds().externalId(externalId)); }
public com.google.gerrit.server.account.AccountState oneByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = byExternalId(externalId); if ((accountStates.size()) == 1) { return accountStates.get(0); } else if ((accountStates.size()) > 0) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("External ID ").append(externalId).append(" for accounts: for accounts: for accounts: for accounts: %s", com.google.common.base.Joiner.on(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); com.google.gerrit.server.query.account.InternalAccountQuery.log.warn(msg.toString()); } return null; }
@java.lang.Override public void addEmail(com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), input.email); try { createEmailFactory.create(input.email).apply(rsrc, input); } catch (com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add email", e); } }
private void addExternalIdEmail(com.google.gerrit.acceptance.TestAccount account, java.lang.String email) throws java.lang.Exception { checkNotNull(email); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(account.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(name("test"), email)); extId.setEmailAddress(email); db.accountExternalIds().insert(account); db.accountExternalIds().insert(account); setApiUser(account); }
@org.junit.Before public void saveExternalIds() throws java.lang.Exception { savedExternalIds = new java.util.ArrayList<java.lang.String>(); savedExternalIds.addAll(getExternalIds(admin)); }
@org.junit.Test public void deleteEmailFromCustomIdScheme() throws java.lang.Exception { java.lang.String email = "foo:bar@example.com"; java.lang.String extId1 = "foo:bar"; java.lang.String extId2 = "foo:bar"; java.lang.String extId2 = "foo:bar:baz"; db.accounts().insert(com.google.common.collect.ImmutableList.of(createExternalIdWithEmail(extId1, email), createExternalIdWithEmail(extId2, email))); accountCache.evict(admin.id); assertThat(gApi.accounts().self().getExternalIds().map(( e) -> e.identity()).containsExactly(extId2, extId2); resetCurrentApiUser(); assertThat(getEmails()).contains(email); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identical().map(( e) -> e.identity()))).containsExactly(extId2); }
private java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> getExternalIds(com.google.gerrit.acceptance.TestAccount account) throws java.lang.Exception { return com.google.common.collect.ImmutableList.of(account.getId()).getExternalIds(); }
@org.junit.Test public void noExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(db.accountExternalIds().byAccount(user.getAccountId())); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, Status.BAD, "No identities found for user; check http://check http://test/#/heads/"); checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), com.google.gerrit.gpg.client.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey())))); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user"); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if ((self.get())!= (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get external IDs"); } java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = db.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList(); if (ids.isEmpty()) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(ids.size()); for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.getExternalId(); info.trusted = id.getExternalId(); info.trusted = com.google.gerrit.server.account.GetExternalIds.toBoolean(authConfig.isIdentityTrustable(java.util.Collections.singleton(id))); if (!(id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME))) { com.google.gerrit.reviewdb.client.AccountExternalId.Key last = resource.getUser().getLastLoginExternalIdKey(); info.canDelete = resource.getUser().getLastLoginExternalIdKey(); info.canDelete = resource.getUser().getLastLoginExternalIdKey(); info.canDelete = resource.canDeleteLoginExternalId(); info.canDelete = resource.getUser().getLastLoginId(); info.canDelete = resource.getUser().getUser().getLastLoginId();
@org.junit.Test public void addOtherUsersGpgKey_Conflict() throws java.lang.Exception { addExternalIdEmail(admin, "test5@example.com"); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key("foo:myId")); accountCache.evict(user.getId()); accountCache.evict(user.getId()); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); addGpgKey(key.getPublicKeyArmored()); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Cannot key already associated with another account already associated with another account")); }
@org.junit.After public void restoreExternalIds() throws java.lang.Exception { if ((savedExternalIds)!= null) { db.accountExternalIds().delete(getExternalIds(admin)); db.accountExternalIds().delete(getExternalIds(admin)); db.accountExternalIds().insert(getExternalIds(user)); db.accountExternalIds().insert(s); } accountCache.evict(admin.getId()); accountCache.evict(user.getId()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutUsername.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set username"); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing username"); } if (input == null) { input = new com.google.gerrit.server.account.PutUsername.Input(); } try { changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call(); } catch (java.lang.IllegalStateException e) { if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(e.getMessage()); } throw e; } catch (com.google.gerrit.server.account.InvalidUserNameException e) { throw e; } catch (com.google.gerrit.server.account.InvalidUserNameException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot already used"); } return input.username; }
private com.google.gerrit.server.account.AuthResult auth(final com.google.gerrit.reviewdb.client.AccountExternalId account) { if (account!= null) { return new com.google.gerrit.server.account.AuthResult(account.getAccountId(), null, false); } return null; }
private com.google.gerrit.server.account.AuthResult byUserName(final java.lang.String userName) { try { com.google.gerrit.reviewdb.client.AccountExternalId.Key extKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, userName); java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQuery.byExternalId(extId); if (accountStates.isEmpty()) { getServletContext().log((("Account accounts with username " + userName) + " found")); return null; } if ((accountStates.size()) > 1) { getServletContext().log((("User accounts with username " + userName) + " found")); return null; } return auth(new com.google.gerrit.reviewdb.client.AccountExternalId(accountStates.get(0).getAccount().getId(), extKey)); } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log("Cannot query account index", e); return null; } }
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertEmail(byEmailCache.get(admin.email), admin); java.lang.String email = "foo.bar@example.com"; db.google.common.collect.ImmutableList<com.google.common.collect.ImmutableList> db = com.google.common.collect.ImmutableList.of(createExternalIdWithEmail("foo:bar:bar:bar", email))); accountCache.evict(admin.id); assertEmail(byEmailCache.get(email), admin); assertThat(byEmailCache.get(email.substring(0, admin.email.indexOf('@'))).isEmpty(); assertThat(byEmailCache.get(admin.email.substring(0, admin.email.indexOf('@'))).isEmpty(); assertThat(byEmailCache.get(admin.substring(0, admin.email.indexOf('@'))).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.Email rsrc, com.google.gerrit.server.account.DeleteEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete email address"); } return apply(rsrc.getUser(), rsrc.getEmail()); }
AccountExternalId.Key getLastLoginExternalId();
private void assertKeys(java.lang.Iterable<com.google.gerrit.gpg.testutil.TestKey> expectedKeys) throws java.lang.Exception { com.google.common.collect.FluentIterable<com.google.gerrit.gpg.testutil.TestKey> expected = com.google.common.collect.FluentIterable.from(expectedKeys); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keyMap = com.google.common.collect.FluentIterable.from(expectedKeys); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keyMap = gApi.accounts().self().listGpgKeys(); assertThat(keyMap.keySet()).named("key").listen("id").listen("listentries").list(listGpgKeysIntsigKeys()); for (com.google.gerrit.gpg.testutil.TestKey key : expected) { com.google.gerrit.acceptance.api.account.AccountId currAccountId = atrScope.get().self().gpgKey(key, com.google.gerrit.gpg.Fingerprint.toString(key.getPublicKey().getFingerprint()).get()); com.google.gerrit.reviewdb.client.Account.Id currAccountId = atrScope.get().getUser().getAccountId(); java.lang.Iterable<java.lang.String> expectedFpsId = expected.transform((k) -> com.google.common.base.BaseEncoding.base16().encode(k.getPublicKey().getFingerprint())); java.lang.Iterable<java.lang.String> actualFails = com.google.common.base.BaseEncoding.base16().encode(k.getPublicKey().getFingerprint()).transform(com.google.gerrit.server.gpg.GpgKeys.getGpgExtIds(db, curr.getPublicKey().getFingerprint())); java.lang.Iterable<java.lang.String> actualFmt = com.google.gerrit.gwtorm
public boolean isIdentityTrustable(final java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { switch (getAuthType()) { case DEVELOPMENT_BECOME_ANY_ACCOUNT : case HTTP_BECOME_BECOME_ANY_BECOME_ANY_ACCOUNT : return true; case OPENID_SSO : return true; case OPENID_SSO : return true; case OPENID_SSO : return true; case OPENID_SSO : return true; case OPENID_SSO : return false; default : return false; default : return false; } }
private com.google.gerrit.reviewdb.client.Account getAccountByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(externalId); if (accountStates.isEmpty()) { return null; } if ((accountStates.size()) > 1) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Key key ").append(externalId).append(" associated with multiple accounts: associated with multiple accounts: "); com.google.common.base.Joiner.on(com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); log.error(msg.toString()); throw new java.lang.IllegalStateException(msg.toString()); } return accountStates.get(0).getAccount(); }
@java.lang.Override public void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), email); try { deleteEmail.apply(rsrc, null); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete email", e); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME, username); com.google.gerrit.server.account.AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get()); return java.util.Optional.ofNullable(accountState).map((s) -> s.getAccount().getId()); }
private static com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = com.google.common.collect.ImmutableSet.of(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> anon = com.google.common.collect.ImmutableSet.of(); return new com.google.gerrit.server.account.AccountState(account, anon, ids, new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private java.util.Optional<com.google.gerrit.server.account.AccountState> load(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = db.accounts().get(who); if (account == null) { return java.util.Optional.empty(); } java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds = java.util.Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> internalGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember g : db.accountGroupMembers().byAccount(who)) { final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if ((group!= null) && ((group.getGroupUUID())!= null)) { internalGroups.add(group.getGroupUUID()); } } internalGroups = java.util.Collections.unmodifiableSet(loader.load(who)); try { account.setGeneralPreferences(loader.load(who)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.AccountCacheImpl.log.warn((("Cannot load GeneralPreferences for " + who) + (using default) + (("using default) + (using default) + (using default)")); } account.setGeneralPreferences(com.google.gerrit.server.account.AccountCacheImpl.log.warn
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key((ExternalId.SCHEME_USERNAME) + ":") + username))).map(AccountExternalId::getAccountId); } }
@java.lang.Override public boolean hasEmailAddress(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) { for (com.google.gerrit.reviewdb.client.AccountExternalId ext : user.state().getExternalIds()) { if ((email!= null) && (email.equalsIgnoreCase(ext.getEmailAddress()))) { return true; } } return false; }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { delete.apply(rsrc, new com.google.gerrit.server.git.DeleteGpgKey.Input()); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete GPG key", e); } }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.extensions.common.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.extensions.common.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.extensions.common.EmailInfo(user, e.email), new com.google.gerrit.server.account.DeleteEmail.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }
private void addEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput(); in.email = email; in.noConfirmation = true; try { createEmailFactory.create(email).apply(rsrc, in); } catch (com.google.gerrit.common.errors.EmailException e) { throw die(e.getMessage()); } }
@java.lang.Override public java.util.Set<java.lang.String> getEmailAddresses(com.google.gerrit.server.IdentifiedUser user) { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = user.state().getExternalIds(); java.util.Set<java.lang.String> emails = com.google.common.collect.Sets.newHashSetWithExpectedSize(ids.size()); for (com.google.gerrit.reviewdb.client.AccountExternalId ext : ids) { if (!(com.google.common.base.Strings.isNullOrEmpty(ext.getEmailAddress()))) { emails.add(ext.getEmailAddress()); } } return emails; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.extensions.api.account.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } if ((input.noConfirmation) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (input.generate) { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "AdministrateServer permission permission")); } newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Authentication must be set"); } com.google.gerrit.reviewdb.client.AccountExternalId id = dbProvider.get().accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, user.getUserName())); if (id == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } id.setPassword(com.google.gerrit.server.account.HashedPassword.fromPassword(newPassword).en()); dbProvider.get().accountExternalIds().update(java.util.Collections.singleton(id)); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, username); com.google.gerrit.reviewdb.client.AccountExternalId user = db.accountExternalIds().get(key); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) { if (kl.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
@org.junit.Test public void getExternalIDs() throws java.lang.Exception { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId id : expectedIds) { id.setCanDelete((!(id.getExternalId().equals(("username:" + (user.username))))) + " not trusted")); expectedIdInfos.add(true); expectedIdInfos.add(com.google.gerrit.acceptance.rest.account.ExternalIdIT.toInfo(id)); } com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external/external/external/external/external/external.ids"); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@java.lang.Override public void deleteExternalIds(java.util.List<java.lang.String> externalIds) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteExternalIds.apply(account, externalIds); } catch (java.lang.Exception e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete external IDs", e); } }
@java.lang.Override public void login(final com.google.gerrit.server.account.AuthResult res, final boolean rememberMe) { final com.google.gerrit.reviewdb.client.Account.Id id = res.getAccountId(); final com.google.gerrit.reviewdb.client.Account.Id id = res.getExternalId(); final com.google.gerrit.reviewdb.client.AccountExternalId.Key identity = res.getExternalId().asAccountExternalIdKey(); if ((val)!= null) { manager.destroy(key); } key = manager.createKey(id); val = manager.createVal(key, id, rememberMe, identity, null); saveCookie(); user = identified.create(val.getAccountId()); }
private java.lang.String readResponse(java.io.InputStream responseStream) { return scanner.next(); }
private void addSubmitRecordRequiresRecord(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecord sa) { if (((submitRecord.equals(submitRecord.rules)!= null)) && (!(submitRecord.isEmpty()))) { sa.records = new java.util.ArrayList(); for (com.google.gerrit.common.data.SubmitRequest req : submitRecord.values()) { com.google.gerrit.server.data.SubmitRequireChangeRequireReason re = new com.google.gerrit.server.data.SubmitRequireChangeRequireChange(); re.short) { com.google.gerrit.server.data.SubmitRequireReasonAttribute re = new com.google.gerrit.server.data.SubmitRequireChangeRequireChange(new com.google.gerrit.server.data.SubmitRequest.SubmitRequest()); re.short) { re.add(req.label()); su.label = req.label(); sa.size(); } } } }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() { if ((submitTypeRecord) == null) { submitTypeRecord = submitTypeRecordEvaluatorFactory.create(com.google.gerrit.server.query.change.DEFAULT_OPTIONS).getSubmitType(this); } return submitTypeRecord; }
private com.google.gerrit.server.project.SubmitRuleEvaluator createEvaluator() { com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey("project"); com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData(project, new com.google.gerrit.reviewdb.client.Change.Id(1), 1); cd.setChange(com.google.gerrit.reviewdb.client.Change.Id(1), 1); return evaluatorFactory.create(cd); }
@org.junit.Test public void convertPrologToSubmitRecord() { com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = makeEvaluator(); java.util.List<com.googlecode.prolog_cafe.lang.Term> terms = makeLabel("Verified", "may"); com.googlecode.prolog_cafe.lang.StructureTerm verifiedLabel = makeLabel("Verified", "may"); com.googlecode.prolog_cafe.lang.StructureTerm labels = new com.googlecode.prolog_cafe.lang.StructureTerm("label", verifiedLabel); terms.add(makeTerm("ok", labels)); java.util.Collection<com.googlecode.gerrit.common.data.SubmitRecord> records = evaluatorToSubmitRecord(null, terms); assertThat(recuator).hasSize(1); }
private com.googlecode.prolog_cafe.lang.Term makeTerm(java.lang.String status, com.googlecode.prolog_cafe.lang.StructureTerm labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm(status, labels); }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at!= null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps!= null) { for (com.google.gerrit.common.data.SubmitRecord rec : submitRuleEvaluatorFactory.byLabel(cd)) { java.lang.String name = label.label; com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(name); if (((out.approvals.containsKey(name)) && (type!= null)) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type))) { for (com.google.gerrit.server.permissions.LabelPermission rule : rec.labels) { if (((out.approvals) (0)) && (type!= null)) { out.approvals.put(name, formatValue(((short) (0))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } } return out; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.reviewdb.client.Change change; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException("NoSuch change found"); } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchProjectException e) { return ruleError(("Error looking up change " + (cd.getId()), e); } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit", "can_submit", cd, projectState); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError(java.lang.String.format("%s' for change %s' for change %s of %s has no solution."), " + (project.getSubmitRule.getSubmitRule(), e); } if (results.isEmpty()) { return ruleError(java.lang.String.format("RuleEval of change %s' for change %s of %s of %s has no solution."), " + (result.getSubmitRule(), e); } }
public abstract java.lang.String fullReason();
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status) { return new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status)); }
public abstract java.lang.String short reason();
public static com.google.gerrit.server.project.SubmitRuleOptions.Builder builder() { return com.google.gerrit.server.project.SubmitRuleOptions.toBuilder(); }
public abstract com.google.gerrit.common.data.SubmitRequireChangeWithSubmit();
public abstract java.lang.String label();
public abstract com.google.gerrit.common.data.SubmitRequireChangeData setLabel(@com.google.gerrit.common.Nullable java.lang.String label);
public abstract com.google.gerrit.common.data.SubmitRequestBuilder setFullReason(java.lang.String fullReason);
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd); if ((rec.status)!= (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("No type rule failed: " + rec)); } return rec.type; }
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabels(com.googlecode.prolog_cafe.lang.StructureTerm... labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm(label, labels); }
public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.server.project.ProjectState projectState; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException("NoSuchChangeException"); } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchProjectException e) { return ruleError(("Error looking up change " + (cd.getId())), e); } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } return prologRule.evaluate(cd, opts); }
@java.lang.Override public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.server.project.SubmitRuleOptions opts) { return getValue().evaluate(); }
public static void checkSubmitRule(com.google.gerrit.server.query.change.ChangeData cd, boolean allowClosed) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet patchSet = cd.currentPatchSet(); if (patchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Cannot current patch set for change " + (cd.getId()))); } java.util.List<com.google.gerrit.common.data.SubmitRecord> results = com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd, allowClosed); if (com.google.gerrit.common.data.SubmitRecord.canBeSubmitted(results)) { return; } else if (results.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format("Submit for change %s returned empty list for change %s", cd.getId(), cd.change().getProject().get())); } for (com.google.gerrit.common.data.SubmitRecord record : results) { switch (record.status) { case CLOSED : break; case CLOSED : throw new com.google.gerrit.extensions.restapi.ResourceConflictException("SubmitRecord status"); case OK : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Cannot submit %s of change %s", (record.errorMessage))); case NOT_READY : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(com.google.gerrit.server.git.MergeOp.describeLabels(cd, record.labels)); case FORCED : throw new java.lang.IllegalStateException(java.lang.String.format("SubmitRecord status %s for %s for %s in %s", cd.change().getId(), cd.change().getId(), cd.getId().get())); case NOT_READY : throw new java.lang.IllegalStateException(java.lang.String.format("Unable to for %
private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) { return com.google.gerrit.common.data.SubmitRecord.canBeSubmittedTo(cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)); }
public boolean canBeSubmitted(java.util.List<com.google.gerrit.common.data.SubmitRecord> in) { if ((in == null) || (in.isEmpty())) { return true; } if (in.stream().noneMatch(( r) -> (r.status) == (com.google.gerrit.common.data.SubmitRecord.Status.OK)) { return false; } return in.stream().noneMatch(( r) -> (r.status) == (com.google.gerrit.common.data.SubmitRecord.Status.OK))); }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd).getSubmitType(); if ((rec.status)!= (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Submit type rule failed: " + rec)); } return rec.type; }
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status, com.google.gerrit.reviewdb.client.Account.Id account) { com.googlecode.prolog_cafe.lang.StructureTerm user = new com.googlecode.prolog_cafe.lang.StructureTerm(account.get())); return new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status, user)); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels)!= null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord(); srl.label = new com.google.gerrit.common.data.SubmitRecord(); srl.label = new com.google.gerrit.common.data.SubmitRecord(); srl.label = new com.google.gerrit.common.data.SubmitRecord(); srl.label = label.label; srl.add(com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredSubmitRecord.StoredSubmitRecord.StoredSubmitRecord.StoredSubmitRecord(label.allReason); rec.labels.add(srl); rec.add(srl); } } if ((records)!= null) { rec.equals(srb.build()); } return rec; }
@java.lang.Override protected void configure() { install(new com.google.gerrit.server.rules.PrologModuleModuleModule()); bind(PrologEnvironment.Args.class); bind(PrologEnvironment.Args.class); }
public boolean getIgnoreWhipboard() { return ignoreWorkInProgress; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded) throws java.lang.Exception { return getConfig(publishOnReviewerAdded, true); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignoreWhipEmptyPatchSet, boolean ignoreWipboard) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("publish-patch-set-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("publish-patch-set-set-set-set-set-set-set", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("publish-on-patch-set-set", true)).thenReturn(publishOnPatchSet); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded, boolean ignoreWipPrivate) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("publish", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("publish-on-added", true)).thenReturn(publishOnReviewerAdded); when(mockPluginConfig.getBoolean("publish-on-added", true)).thenReturn(publishOnReviewerAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); }
@org.junit.Test public void publishedWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; mockChange.isPrivate = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore) throws java.lang.Exception { return getConfig(ignore, true, true); }
@org.junit.Test public void publishWhenInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; mockChange.isPrivate = false; mockChange.isPrivate = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig("^WIP.*", true, true, true); }
@org.junit.Test public void publishesWhenExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.isEnabled()))) { return false; } try { if ((config.getIgnoreWhipboard()) && ((event.change.get().isPrivate)) && ((event.change.get().isPrivate)) || (event.change.get().isPrivate)) { return false; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGenerator.LOGGER.warn("Error checking private private private private check work and work in workInProgress status", e); return true; } return true; }
@org.junit.Test public void doesPublishWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet; patchSet = event.patchSet.get(); if (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_FIRSTART_PARENT_PARENT_UPDATE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRSTART_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CODE_PARENT_UPDATE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE))) { return false; } } catch (java.lang.Exception e) { com.google.gerrit.server.plugins.slack.message.PatchSetCreatedMessageGenerator.log.warn("Cannot check patch set kind", e); } try { if ((config.getIgnoreWhipboard()) && ((event.change.get().isPrivate)) { return false; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.log.warn("Cannot check patch set work in work in work in work-in-in progress status", e); } boolean result = true; try { java.util.regex.Pattern pattern; pattern = pattern.matcher(event.change.get().commitMessage); result =!(matcher.matcher.matcher(event.change.get().commitMessage); result =!(matcher.matches()); } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.cisco.cisco.gerrit.slack.message.ChangeMessageGenerator.LOGGER.warn("Cannot check private status", e); } catch (java.lang.Exception e) { com.cisco.gerrit.cisco.gerrit.plugins.cisco.c
@org.junit.Test public void publishesWhenExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.workInProgress; messageGenerator = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.isEnabled()))) { return false; } try { if ((config.getIgnoreWhipboard()) && ((event.change.get().isPrivate)) && ((event.change.get().isPrivate)) || (event.change.get().isPrivate)) { return false; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGenerator.LOGGER.warn("Error checking private private private private check workInProgress", e); return true; } return true; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded) throws java.lang.Exception { return getConfig(publishOnCommentAdded, true); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnWipReady()))) { return false; } if (event.change.get().workInProgress()) { return false; } return true; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded, boolean ignoreWipPrivate) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("publish", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("publish-comment-added", true)).thenReturn(publishOnCommentAdded); when(mockPluginConfig.getBoolean("publish-on-comment-added", true)).thenReturn(publishOnCommentAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPrivate()))) { return false; } if (event.change.get().isPrivate()) { return false; } return true; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebase) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, publishOnPatchSet, ignoreWhip); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, publishOnPatchSetCreated, true); }
@org.junit.Test public void doesPublishWhenInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.workInProgress; messageGenerator = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebase) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, publishOnPatchSet, ignoreRebase); }
public static void useFixedClockAt(java.lang.Instant moment, java.lang.String ident) { com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.FileBasedWebSession.clock = java.lang.System.fixed(Instant, java.lang.System.systemDefault()); }
public static void useSystemZoneClock() { com.ericsson.gerrit.plugins.highavailability.forwarder.file.FileBasedWebSession.clock = java.lang.System.systemSession.systemSessionCache.systemDefaultZone(); }
public static java.lang.Instant now() { return java.lang.System.now(com.ericsson.gerrit.plugins.highavailability.weavailability.web.file.FileBasedWebWebsession.TimeMachine()); }
@java.lang.Override public void run() throws java.io.IOException { com.google.gerrit.server.index.IndexModule.IndexType type = com.google.gerrit.server.index.IndexModule.IndexType.LUCENE; if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) > 1) { ui.header("Index"); type = index.select("Type", "type", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.ELASTICSEARCH)) { java.lang.String name = index.select("Type", "name", "gerrit"); com.google.gerrit.pgm.init.api.Section elasticsearch = sections.get("elasticsearch", name); elasticsearch.select("elasticsearch", "name", "gerrit"); com.google.gerrit.pgm.init.Section elasticsearch = sections.get("elasticsearch", name); elasticsearch.select("Hostname", "port", "port", "localhost"); elasticsearch.string("Port", "port", "localhost"); } if (((site.isNew) || (isEmptySite())) && (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { for (com.google.gerrit.server.index.IndexModule.IndexModule.ALL_SCHEMA_DEFS) { com.google.gerrit.server.index.IndexModule.setReady(site, def.getName(), def.getLatest().getVersion(), true); } } else if ((com.google.gerrit.server.index.IndexModule.IndexType.values().values().length) <= 1) { for (com.google.gerrit.server.index.IndexModule.IndexType.values().length) { com.google.gerrit.server.index.IndexModule.setReady(site, def.getName(), def.getLatest().getVersion(), true); } } else { if ((com.google.gerrit.server.index.IndexModule.IndexType.values().values().length()) <= 1) { ui.header("Index"); } } }
protected static void setContentAndEncoding(javax.servlet.http.HttpServletResponse rsp) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); }
private void process(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp, com.google.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring((path.lastIndexOf('/')) + 1))); logger.debug("Connected event {}", operation, indexName, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.util.concurrent.LockId idLock = idLocks.get(id); idLock.lock(); try { index(idLocks.get(id); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } } rsp.unsetStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); logger.error("Unable to update {}", e); return; } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format("Unlogged trying to find %s", e.getMessage()); sendError(msg, com.ericsson.gerrit.plugins.highavailability.forwarder.SC_NOT_FOUND, msg); logger.debug(msg, e); } finally { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.unsetForwardedEvent(); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { setContentAndEncoding(rsp); try { java.util.List<java.lang.String> params = com.google.common.base.Splitter.on('/').splitToList(req.getPathInfo()); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.CACENAME_INDEX); java.lang.String json = req.getReader().readLine(); java.lang.String json = req.getReader().readLine(); java.lang.String json = req.getReader().readLine(); if (com.ericsson.gerrit.plugins.highavailability.forwarder.CacheNotFoundException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheNotFoundException.evictionHandler.evictionHandler.evictionHandler.eviction(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheEntry.fromJson(cacheName, json))); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheNotFoundException e) { logger.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } catch (java.io.IOException e) { logger.error("Error to process eviction request: {}", e.getMessage()); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_BAD_REQUEST, e.getMessage()); } } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { setContentAndEncoding(rsp); try { if (!(com.google.common.net.MediaType.parse(req.getContentType()).is(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8))) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_UNSUPPORTED_MEDIA_TYPE, (("CONTENT " + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8.toString())) + "content type type type type")); return; } } catch (com.google.gwtorm.server.OrmException e) { logger.debug("Error trying to find a change", e); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_FOUND); } catch (com.google.gwtorm.server.OrmException e) { logger.debug("Failed to find a change", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, e); } }
@org.junit.Test public void indexUpdatesAndIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String preferredEmail = "foo@example.com"; updateAccountWithoutCacheOrIndexOrIndexOrIndexOrIndexOrIndexOrIndex(accountId, com.google.gerrit.acceptance.api.account.AccountIndexerIT.newAccountId(accountId, AccountId, com.google.gerrit.acceptance.api.account.AccountIndexerIT.newAccountUpdate().setPreferredEmail(prefs.google.gerrit.acceptance.account.AccountStateIT.newAccountUpdate().setPreferredEmail(prefs.google.gerrit.acceptance.account.AccountState.create().setPreferredEmail(prefs.google.gerrit.acceptance.rest.account.AccountState.class).isEqualTo(prefs.getAccount().getId()).isEqualTo(accountId); assertThat(matchedAccountSets.get(0).isEmpty(); }
private void updateAccountWithoutCacheOrIndex(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.InternalAccountUpdate acOUNT, com.google.gerrit.server.account.InternalAccountUpdate account) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, allUsersName, allUsersRepo)) { org.eclipse.jgit.lib.PersonIdent ident = serverIdent.get(); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId, allUsersName); accountConfig.setAccountUpdate(accountId); accountConfig.setAccountUpdate(accountId); accountConfig.setAccountUpdate(accountUpdate); accountConfig.setAccountUpdate(accountId); accountConfig.setAccountUpdate(md); } }
@org.junit.Test public void accountEvictionFromAccountCreatorIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createNiceMock(com.google.gerrit.acceptance.TestProjectCreator.class); com.google.gerrit.acceptance.AccountCreator accountCreator = org.easymock.EasyMock.createNiceMock(com.google.common.collect.ImmutableSet.of(accountId)); org.easymock.EasyMock.replay(accountCreator); try (com.google.gerrit.acceptance.ProjectResolver.createNiceMock(accountId)); org.easymock.EasyMock.replay(accountCreator, null, null).reset(allUsersRepo, null).reset(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); } org.easymock.EasyMock.verify(accountCreator); }
@org.junit.Test public void accountEvictionIfUserBranchIsNotReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createRepository(allUsers); org.eclipse.jgit.lib.Ref userBranch = createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); com.google.gerrit.server.account.AccountCache accountCache = org.eclipse.jgit.lib.RefNames.createNiceMock(com.google.gerrit.server.index.account.AccountIndexer.class); accountIndexer.evock.replay(accountId); org.eclipse.jgit.lib.Ref refIndex = createRef(accountId); org.eclipse.jgit.lib.Ref nonUserBranch = createRef(com.google.gerrit.reviewdb.client.Account.Id(new com.google.gerrit.reviewdb.client.Account.Id(2))); try (com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.RefNames.refsUsers(2))); try (com.google.gerrit.acceptance.ProjectResolver.refsUsedBranch(new com.google.gerrit.acceptance.ProjectResolver.RefNames(2)) { try (com.google.gerrit.acceptance.ProjectResolver.REFS_CONFIG)) { com.google.gerrit.acceptance.ProjectResolver resetProject(null, accountCache, accountCache, accountCache, null).reset(allUsers); } } catch (com.google.gerrit.accept
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createNiceMock(project2); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.easymock.EasyMock.replay(projectCache); try (com.google.gerrit.acceptance.ProjectResolver.class notFireCall() { try (com.google.gerrit.acceptance.ProjectResolver.class); try (com.google.gerrit.acceptance.ProjectResolver.class, null, null, projectCache.REFS_CONFIG); createRef(repo2, null, projectCache.REFS_CONFIG); createRef(repo2, RefNames.REFS_CONFIG); } org.easymock.EasyMock.verify(projectCache); }
@org.junit.Test public void accountEvictionIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository allUsersRepo = repoManager.createNiceMock(allUsers); com.google.gerrit.server.account.AccountCache accountCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.index.AccountCache.class); accountCache.evict(accountId); org.easymock.EasyMock.replay(accountCache); com.google.gerrit.server.index.AccountIndexer resetWithCall(); try (com.google.gerrit.acceptance.project.AccountResolver.class); com.google.gerrit.server.index.account.AccountIndexer resetProject(accountCache, accountIndexer, accountIndexer, null).reset(project).reset(allUsers).build())) { createRef(com.google.gerrit.acceptance.ProjectResolver.refsUpdate(new com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(new com.google.gerrit.reviewdb.client.Account.Id(2))); } org.easymock.Verified.verify(accountCache); }
@org.junit.Test public void reindexingAccountUpdatesAndIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String preferredEmail = "foo@example.com"; updateAccountWithoutCacheOrIndexOrIndexOrIndexOrIndex(accountId, com.google.gerrit.acceptance.api.account.AccountIndexerIT.newAccountUpdate().setPreferredEmail(prefs.com.google.gerrit.acceptance.api.account.AccountIndexerIT.newAccountUpdate().setPreferredEmail(prefs.google.gerrit.acceptance.account.AccountStateIT.newAccountUpdate().setPreferredEmail(prefs.google.gerrit.acceptance.account.AccountState.newAccountId(prefs.google.gerrit.acceptance.account.AccountStateIT.name_NAME))).isEmpty(); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(prefs.getAccount().getId()); assertThat(matchs).hasSize(1); assertThat(migration.get(0).hasSize(1); assertThat(muteAccountSets.get(0).getAccount().getId()).isEqualTo(accountId); }
public com.google.gerrit.acceptance.ProjectResolver build() throws java.io.IOException { return new com.google.gerrit.acceptance.ProjectResolver(repoManager, allUsersName, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, accountCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, projectCache, refsByProject, refsByProject); }
@org.junit.Test public void projectEvictionIfRefsMetaConfigIsReset() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project2 = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo2 = repoManager.createRepository(project2); org.eclipse.jgit.lib.Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG); com.google.gerrit.server.project.ProjectCache projectCache = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(project2); org.eclipse.jgit.lib.Ref nonMetaConfig = createRef("refs/heads/master"); try (com.google.gerrit.acceptance.ProjectResolver.class) { createRef("refs/heads/master"); com.google.gerrit.acceptance.ProjectResolver resetRef(null, null, null, projectCache).reset(project).reset(project).reset()).reset(repoConfig); updateRef(repo, metaConfig); } org.easymock.EasyMock.verify(projectCache); }
@org.junit.Test public void indexCannotBeBeTrue() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); loadAccountToCache(accountId); java.lang.String preferredEmail = "foo@example.com"; updateAccounts.com.google.gerrit.acceptance.api.account.AccountIndexerIT.newAccountId(accountId, com.google.gerrit.acceptance.api.account.AccountStateIT.newAccountUpdate().setPreferredEmail(prefs.com.google.gerrit.acceptance.account.AccountStateIT.newAccountUpdate().setPreferredEmail(prefs.google.gerrit.acceptance.api.account.AccountStateIT.newAccountId(accountId, preferredEmail))); assertThat(accounts).hasSize(1); assertThat(migration.get(0).getAccount().getId()).isEqualTo(accountId); }
@org.junit.Test public void missingPatchSetCommitOmitsCommentsOnParentSide() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); com.google.gerrit.extensions.common.CommentInfo draftInfo = putDraft(id, id, 1, "draft comment", null, Side.PARENT); com.google.gerrit.extensions.common.CommentInfo commentInfo = gApi.changes().id(id.get()).comments().stream().flatMap(java.util.List::stream.stream.stream().stream().stream().stream().map(((java.util.List.stream.Stream.stream.Stream(ps)); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId("deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef"); db.patchSets().update(java.util.Collections.singleton(ps)); try { patchListCache.getOldId(db.changes().get(id), ps, null); assert_().fail("Expected patch set " + (com.google.gerrit.acceptance.rest.patch.PatchListNotAvailableException e) + ") + (com.google.gerrit.acceptance.PushOneCommit.FILE_NAME)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + (draftInfo.id)) + ") + ") + (drafts) + ") + (draftInfo.id)) + ") + ") + (draft.id)) + ") + ") + ") + (
public void rebuildAndCheckChange(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> expectedDiff) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeNotesTest.Builder b = com.google.common.collect.ImmutableListMultimap.builder(); b.putAll(changeId, expectedDiff); rebuildAndCheckChanges(java.util.stream.Collectors.of(changeId), b.build()); }
@org.junit.Test public void deleteItems() throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId oldMetaId = metaRef(accountId); com.google.common.collect.ImmutableSet<java.lang.String> defaultNames = myMenusFromApiFromApi(accountId); GeneralPreferencesInfo prefs = gApi.accounts().id(accountId); GeneralPreferencesInfo prefs = gApi.accounts().id(accountId); prefs.my.add(0, new com.google.gerrit.extensions.client.MenuItem((com.google.gerrit.server.schema.Schema_TABLE.DEFAULT_DRAFT_TIONS.size()) + " is:mergeable")); for (int i = 0; i < (com.google.gerrit.server.schema.Schema_TABLE.DEFAULT_DRAFT_TIMITEM_ITEMElements.size()); i++) { prefs.my.add(new com.google.gerrit.extensions.client.MenuItem(((com.google.gerrit.server.schema.Schema_TABLE.DEFAULT_DRAFT_DRAFT_ITELS.size()) + ").add("draft entry 1")); } gApi.accounts().id(accountId.get()).setPreferences(prefs); java.util.List<java.lang.String> oldNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add("new com.google.gerrit.reviewdb.client.Account.Id>(entry + ").addAll(accountId)).add("Draft entry 1 ").add("Draft entry 1 ").add("Draft entry 1 ").add("Draft entry 3", 3").add("Draft entry 3").add("Draft entry 3", 3).add("No Change entry3"); }
private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers groupMembers, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::getId).filter(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.server.project.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {} of project {}: reviewer {} is not a group."); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.warn("For the change {}: failed to list accounts for group {}", p); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("For the change {}: failed to list accounts for group {}", p); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.warn("For the change {} failed to list accounts for group {}", changeNumber, p); } }
private boolean resolveAccount(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(reviewDb, r); if ((account!= null) || ((uploader._accountId)!= (account.getId().get()))) { reviewers.add(accountId); } return true; } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.error("For the change {} of project {}: failed to resolve account {}.", p); return true; } return false; }
java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> resolve(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account.Id uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); com.google.gerrit.server.account.GroupMembers groupMembers = null; for (java.lang.String r : in) { if (resolveAccount(reviewDb, p, changeNumber, uploader, r)) { continue; } if ((groupMembers == null) && (uploader!= null)) { groupMembers = createGroupMembers(reviewDb, p, uploader, reviewer, reviewer, groupMembers, r); } if (groupMembers!= null) { resolveGroup(p, changeNumber, reviewer.email); } else { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("Couldn't the change {} failed to list accounts for group {}", p); } else { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("Couldn't find the change {} failed to list accounts for group {}", p, uploader.email); } } return reviewers; }
private com.google.gerrit.server.account.GroupMembers createGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { java.lang.String uploaderNameEmail = java.lang.String.format("%s<%s>", com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { java.lang.String uploaderNameEmail = java.lang.String.format("%s<%s>", uploader.name, uploader.email); try { com.google.gerrit.reviewdb.client.Account uploaderAccount = accountResolver.find(uploader.getId()); if (uploaderAccount!= null) { return groupMembersFactory.create(identifiedUserFactory.create(uploader.getId())); } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.warn("For the change {} failed to list accounts for group {}", e); } return null; }
private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers groupMembers, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p).stream().filter(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("No change {} of project {}: {}: {} is not a group."), p); } catch (com.google.gerrit.server.project.NoSuchProjectException | com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.common.errors.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("Couldn't the project {}: {}: {}: failed to list accounts for group {}", p); } }
private void run(java.util.Function<java.lang.String> logOneLine, @com.google.gerrit.common.Nullable java.io.PrintWriter progressWriter) { if (!(repoManager) { logOneLine.acceptance(("Login GC of " + (allUsers)) + " not a local disk repo repo repo"); return; } if (!(enableAutoGc(logManager)) { logOneLine.acceptance(java.lang.String.format(((("Error of " + (allUsers)) + (config.getUser())) + ".")) + (config_Key_Key_AUTO)) + ".")) + (config_key_Key_AUTO))); return; } if (progressWriter == null) { logOneLine.accept((("No loading accounts for " + (allUsers)) + (allUsers)) + "\"")); return; } com.google.gerrit.common.data.GarbageCollectionResult result = gcFactory.create().run(com.google.common.collect.ImmutableList.of(allUsers), progressWriter); if (!(result.hasErrors())) { return; } for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case GC_ALREADY_ALREADY : logOneLine.accept(("ALREADY already scheduled for " + (e.getProjectName()))); break; case GC_FAILED : logOneLine.acceptanceled(("Error already scheduled for " + (e.getProjectName()))); break; case REPOSITORY_NOT_FOUND : logOneLine.acceptanceled(("Project failed for " + (e.getProjectName())) + ") + (e.getType())), e.getType()))); break; case REPOSITORY_NOT_FOUND : logOneLine.accept(((e.getProjectName()) + ") + (e.getType()))); break; default : log.error("Error: failed: " + (e.getType()) + (e.getType()))); break; } } } }
public java.util.Set<java.lang.String> getUpstreamBranches(java.lang.String toBranch, java.lang.String project) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<java.lang.String> upstreamBranches = new java.util.HashSet<java.lang.String>(); java.util.Set<java.lang.String> subsection = getConfig().getSubsections(pluginName); for (java.lang.String subsection : subsection) { java.util.List<java.lang.String> branchPair = getConfig().getSubsections(pluginName); for (java.lang.String subsection : subsection) { java.util.List<java.lang.String> branchPair = com.google.common.base.Splitter.on(com.googlesource.gerrit.plugins.automerger.ConfigLoader.BRANCH_DEL_DELITER).trimResults().splitToList(substring(0))); if (toBranch.equals(branchPair.get(1)) { java.util.Set<java.lang.String> projectsInScope = getProjectsInScope(branchPair.get(0), branchPair.get(1)); if (projectsInScope.contains(project)) { upstreamBranches.add(branchPair.get(project)); } } } return upstreamBranches; }
@org.junit.Test public void basicGroupProperties() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups().create(name("group")).get(); com.google.gerrit.server.group.GroupInfo createdGroup = groups.getGroup(db, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(createdGroup.id)).get(); deleteGroupRefs(reviewDbGroup); assertThat(com.google.gerrit.acceptance.api.group.GroupRebuilderIT.removeRefState(rebuild(reviewDbGroup))).isEqualTo(roundToSecond(reviewDbGroup)); }
private com.google.gerrit.server.group.InternalGroup createGroupInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupCreation groupUpdate) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroupName gn = new com.google.gerrit.reviewdb.client.AccountGroupName(groupCreation.getNameKey(), groupCreation.getId()); db.accountGroupNames().insert(com.google.common.collect.ImmutableList.of(gn)); db.accountGroupNames().insert(com.google.common.collect.ImmutableList.of(gn)); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupsUpdate.createAccountGroup(groupCreation); com.google.gerrit.server.group.InternalGroup.Update.Update.UpdateResult updateResult = updateGroupInReviewDb(groupCreation); com.google.gerrit.server.group.InternalGroup.Create(group, updateGroupInReviewDb(db, group, group); return com.google.gerrit.server.group.InternalGroup.create(group, updateResult.getModifiedMembers(), updateResult.getModifiedMembers(), updateResult.getRefState()); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(3); values.add(token.id.getName()); values.add(token.id.getName()); values.add(token.id.getName()); values.add(java.lang.String.valueOf(token.expiresAt)); return values; }
@org.junit.Test public void testTokenSerializationDeserializedDeserialized() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken proerializer processor = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestTokenProessor(crypto); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken token = processor.serialize(token); java.lang.String serialized = processor.serialize(token); assertEquals(serialized).isNotEmpty(); java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.Test.TestToken> deserialized = processor.deserialize(serialized); assertThat(serialized.isPresent()).isTrue(); assertThat(token.expiresAt(reserialized.get().expiresAt()); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(0), org.eclipse.jgit.lfs.lib.LongObjectId.fromString(values.get(1), com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(1), com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(values.get(1), com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.class), com.google.gerrit.reviewdb.client.AccountAuthorizer.UUID.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer.class, null); } return new com.google.common.Optional.Optional.of(new com.googles
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(4); values.add(token.user); values.add(token.project); values.add(token.expiresAt()); values.add(token.expiresAt()); values.add(java.lang.String.valueOf(token.expiresAt)); return values; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values.get(0), values.get(1), values.get(2), values.get(4), java.lang.Integer.valueOf(4), com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.googlesource.gerrit.plugins.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.google.gerrit.lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.get(4), values.get(com.googlesource.gerrit.plugins.lfs.Lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(com.get(4), values.get(com.googlesource.gerrit.plugins.lfs.lfs.Lfs.Lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(ps.get(com.get(4), null)); }
com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorInfo generateAuthInfo(com.google.gerrit.server.CurrentUser user, java.lang.String project, java.lang.String operation) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(user.getUserName(), project, java.lang.String operation, java.lang.String operation) { return new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(processor.serialize(token), token.expiresAt); }
public com.googlesource.gerrit.plugins.lfs.AuthInfo generateAuthInfo(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id, java.lang.Instant now, int expiresIn) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token = new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(operation, id, expiresIn); return new com.googlesource.gerrit.plugins.lfs.AuthInfo(processor.serialize(processor.serialize(token), token.expiresAt); }
public boolean onTime(java.time.Instantied when) { return when.isBefore(token.expiresAt); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken> createToken(java.lang.String values) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values.get(0), java.lang.Integer.valueOf(1))); }
@org.junit.Test public void testTokenOnTime() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(when, 1000); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier(token); assertThat(verifier.onTime(when.expiresAt(9))).isTrue(); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(2); values.add(token.expiresAt()); values.add(java.lang.String.valueOf(token.expiresIn)); return values; }
@org.junit.Test public void testTokenExpired() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(when, 1000); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier(token); assertThat(verifier.onTime(when.expiresAt(10011))).isFalse(); }
@org.junit.Test public void testVerifyAuthInfo() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), java.time.now(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "o", zeroId())).isTrue(); }
@org.junit.Test public void testVerifyAgainstDifferentOperation() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), java.time.now(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse(); }
@org.junit.Test public void testVerifyAgainstDifferentObjectId() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.AuthInfo info = auth.generateAuthInfo("o", zeroId(), java.time.now(), 1); assertThat(auth.verifyAuthInfo(info.authToken, "o", org.eclipse.jgit.lfs.lib.LongObjectId.fromString(("user4567896789" + "1234abandonAuthInfo")))).isFalse(); }
private boolean isRecoverable(java.lang.Exception e) { return (!(eclipse.jgit.internal.SshLfsLifests.isSshKey())) && (!(eclipse.jgit.internal.SshApiException))) && (!(e instanceof java.io.IOException); }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.EventProcessor.Request> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug(content.Webhook[0, ("Content: {} skipped.remote.remote.getUrl()); return; } (execCnt)++; com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.get().post(remote, content.get()); if ((!(result.success)) && ((exec(result.success)) < (remoteCnt)))) { logRetry(result.message); reschedule(); } } catch (java.lang.RuntimeException e) { if ((isRecoverable(e)) && ((execCnt) < (remoteCnt) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", toString(), e); reschedule(); } } }
private void createRepository() { if (pool.isCreateMissingRepos()) { try { org.eclipse.jgit.lib.Ref head = git.exactRef(Constants.HEAD); if (replicateQueue.createProject(projectName, (head!= null? head.getName() : null)) { com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event = new com.google.gerrit.extensions.events.NewProjectCreatedListener.Event() { @java.lang.Override public java.lang.String getProjectName() { return projectName.get(); } @java.lang.Override public com.google.gerrit.extensions.api.changes.NotifyHandling getNotify() { return com.google.gerrit.extensions.api.changes.NotifyHandling.NONE; } }); replicationQueue.onNewProjectCreated(event); pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(("Cannot create " + (uri)) + " for the change ") + ((" Only replication to create missing repositories or ") + ") + ") + (adminUrl.config.config.getName()); uri.error((("Cannot replicate to " + (uri)) + ") + ": ") + (adminUrl.config.config.getName()); } } else { stateLog.error((("Cannot replicate to " + (uri)) + " failed to create missing repository not found")); } } else { stateLog.error((("Cannot replicate to " + (uri)) + " repository not found") + " repository not found")); } }
private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupById> readAccountGroupSubgroupsFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery((("SELECT include_uuid" + " FROM account_group_id" + " WHERE group_id = '" + " WHERE group_id = '") + (groupId.get())) + "'") + "'") + "'"))) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroups = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID includeGroupUuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroupById(rs.getString(1)); subgroups.add(new com.google.gerrit.reviewdb.client.AccountGroupById(new com.google.gerrit.reviewdb.client.AccountGroupById(groupId, includeId))); } return subgroups; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read subgroups of account group %s from account %s from ReviewDb", groupId.get()), e); } } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read subgroups of account group %s", e); }
private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> readAccountGroupMembersFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery((("SELECT account_id" + " FROM account_group_members") + " WHERE group_id = ') + (groupId.get())) + "'") + "'") + "'"))"));java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> members = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)); members.add(new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId))); } return members; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read members of account %s from ReviewDb", groupId.get()), e); } }
public static com.google.gerrit.server.group.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupBundle.Factory.createAccountGroupFromReviewDb(db, groupUuid); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupBundle.Factory.create(db, groupUuid); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); return com.google.gerrit.server.group.GroupBundle.create(com.google.gerrit.server.group.GroupBundle.Source.Source.REVIEW_DB, group, com.google.gerrit.server.group.GroupBundle.Factory.create(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.create(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.Factory.createAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.Factory.Factory.createAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.Factory.Factory.Factory.createAccountGroupSubgroupIncludedAuditsFromReviewDb(db, groupId)); }
public com.google.gerrit.server.group.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupBundle.Factory.create(db, groupId); return com.google.gerrit.server.group.GroupBundle.create(com.google.gerrit.server.group.GroupBundle.Source.Input.REVIEW_DB, group, com.google.gerrit.server.group.GroupBundle.Input.Input.readAccountGroupMembersFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.create(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.create(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.createAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.Factory.Factory.createAccountGroupMemberAuditsFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.Factory.Factory.Factory.Factory.createAccountGroupSubgroupIncludedAuditsFromReviewDb(db, groupId)); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextEquals() throws java.lang.Exception { doAccepted(com.google.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isTrue(); throw new java.io.IOException("someMessage"); }
@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expect(java.lang.UnsupportedOperationException.class); exception.expectMessage("Delete from index not supported"); }
@org.junit.Before public void setUp() throws java.lang.Exception { handler = new com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexAccountHandler(indexerMock); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextEquals() throws java.lang.Exception { doAccepted(com.google.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isTrue(); }
@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expect(java.lang.UnsupportedOperationException.class); exception.expectMessage("Delete from index not supported"); }
@org.junit.Before public void setUp() throws java.lang.Exception { handler = new com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexHandler(indexerMock); }
@org.junit.Test public void changeToIndexDoNotExisting() throws java.lang.Exception { setupChangeAccessRelatedMocks(com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexChangeHandlerTest.CHANGE_DO_NOT_EX); handler.index(id, Operation.INDEX); verify(indexerMock, times(1)).delete(id); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextEquals() throws java.lang.Exception { setupChangeAccessRelatedMocks(com.ericsson.gerrit.plugins.highavailability.forwarder.ForwardedIndexChangeHandlerTest.CHANGE_EX); doApi(((org.mock.mock.solrabbitmock.Context.isForwardedEvent()) ((com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent())).isTrue(); throw new java.io.IOException("someMessage"); })).then(indexerMock).index(dbMock, change); assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); try { handler.index(id, operation.INDEX); fail("should have throw new org.eclipse.jgit.errors.ConfigException")); } catch (java.io.IOException e) { assertThat(e.getMessage()).isEqualTo("some message"); } assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isEqualTo("someMessage"); }
private void setupChangeAccessRelatedMocks(boolean changeExist, boolean ormException, boolean ormException) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (ormException) { doThrow(new com.google.gwtorm.server.OrmException("")).when(schemaFactoryMock).open(); } else { when(schemaFactoryMock.open()).thenReturn(dbMock); com.google.gerrit.reviewdb.server.ReviewDb db = mock(com.google.gerrit.reviewdb.server.ChangeAccess.class); when(dbMock.changes()).thenReturn(ca); if (changeExist) { when(ca.get(id)).thenReturn(change); if (ioException) { doThrow(new java.io.IOException("IOException")).index(indexerMock).index(dbMock).index(dbMock, change); } } else { when(new java.io.IOException("IOException")).thenReturn(null); } }
@org.junit.Before public void setUp() throws java.lang.Exception { when(schemaFactoryMock.open()).thenReturn(dbMock); when(dbMock.changes()).thenReturn(changeAccessMock); change = new com.google.gerrit.reviewdb.client.Change(null, id, null, null, com.google.gerrit.common.TimeUtil.nowTs()); handler = new com.google.gerrit.reviewdb.client.Account.Id(id, id, null, null, null, null, com.google.gerrit.common.TimeUtil.nowTs()); }
@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); java.lang.String projectName = branch.getParentKey().get(); soyContext.put("projectName", projectName); soyContext.put("projectName", projectName); soyContext.put("shortProjectName", projectName.replaceAll("/", "...")); soyContext.put("instanceAndProjectName", (name.replaceAll("/projectName")))); soyContext.put("sshHost", getSshHost()); java.util.Map<java.lang.String, java.lang.String> branchData = new java.util.HashMap<>(); branchData.put("sshHost", branch.getShortName()); soyContext.put("sshHost", getSshHost()); soyContext.put("branch", getSshHost()); soyContext.put("branch", branchData); footers.add(((MailHeader.PROJECT.withDelimiter()) + (branch.getParentKey().get()))); footers.add(("" + (branch.getParentKey().get()))); footers.add(("UploadHeader.PROJECT.withDelimiter() + (branch.getParentKey().get()))); }
private static java.lang.String getInstanceName(@com.google.gerrit.server.config.PluginConfig config, @com.google.gerrit.common.Nullable com.google.inject.Provider<java.lang.String> canonicalUrl, com.google.common.base.Optional<com.google.gerrit.extensions.client.WebLinkInfo> canonicalUrlProvider) { return new com.google.common.base.Optional<com.google.gerrit.extensions.client.AccountInfo>() { @java.lang.Override public java.lang.String getString getString() { return com.google.common.base.Optional.of(com.google.gerrit.server.config.SitePaths.class).toInstance(com.google.gerrit.server.project.GetPrefix(name, ").toString(); } @java.lang.Override public java.lang.String getString() { return new com.google.inject.Type(com.google.gerrit.server.PluginConfig.class).toString(); } @java.lang.Override public java.lang.String getString() { return com.google.common.base.Strings.isNullableToNullable(com.google.common.base.Strings.isNullable.isNullable(url)); } }
private java.lang.System.println(java.lang.System.class, java.lang.System.println(java.lang.System.nameProvider<java.lang.String> pluginName) { java.lang.System.println(java.lang.System.println(nameProvider.get())); return java.lang.System.println(java.lang.System.println(nameProvider.get())); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in " + (com.google.gerrit.reviewdb.client.ChangeUtil.status(change)))); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not allowed to set work in progress"); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not allowed to already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for review"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { if (!(permissionBackend.user(self).test(GlobalPermission.ADMINISTRATE_SERVER))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for " + (com.google.gerrit.reviewdb.client.ChangeUtil.status(change))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not allowed to set ready for " + (com.google.gerrit.reviewdb.client.ChangeUtil.status(change))); } if (!(change.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(""); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
protected <T> org.elasticsearch.query.QueryBuilder toQueryBuilder(com.google.gerrit.server.query.Predicate<T> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<T>) (p))); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return org.apache.elasticsearch.QueryBuilder.matchAllQuery(); } else { throw new com.google.gerrit.server.query.QueryParseException(("Cannot create query for index: " + p)); } }
public org.apache.lucene.search.Query toQuery(com.google.gerrit.server.query.Predicate<V> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return and(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.OrPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return fieldQuery(((com.google.gerrit.server.index.IndexPredicate<V>) (p))); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return new org.apache.lucene.search.MatchAllDocsQuery(); } else if (p instanceof com.google.gerrit.server.index.AnyPredicate) { throw new com.google.gerrit.server.query.QueryParseException(("Cannot create query for index: " + p)); } }
@java.lang.Override public boolean match(com.google.gerrit.server.account.AccountState accountState) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.account.AccountState> pred = getChild(0); checkState(pred.isMatchable(), ("match invoked, but child predicate %s " + "doesn't implement %s"), pred, com.google.gerrit.server.query.Matchable.class.getName()); return pred.asMatchable().match(accountState); }
private boolean canRead(org.eclipse.jgit.lib.ObjectId revId) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); checkNotNull(projectState, "load project %s", projectName); projectState.checkStatePermitsRead(); permissionBackend.user(user).project(projectName).check(ProjectPermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.extensions.restapi.ResourceConflictException e) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(revId); return commits.canRead(projectState, repo, commit); } } }
@org.junit.Test public void checkMaxIsEnabled() { com.google.gerrit.common.data.LabelFunctionTest.checkMaxIsEnforced(LabelFunction.MAX_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkMaxIsEnum(LabelFunction.MAX_BLOCK); checkMaxValidatesThat(LabelFunction.MAX_WITH_BLOCK); checkMaxValidatesThat(labelFunction.MAX_WITH_BLOCK); }
private static void checkLabelIsRequired(com.google.gerrit.common.data.LabelFunction function) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.Verified_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.NEW); assertThat(myLabel.appliedBy).isNull(); }
private static void checkMaxIsEnforced(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.APPROVAL_1, com.google.gerrit.common.data.LabelFunctionTest.AP_1); com.google.gerrit.common.data.SubmitRecord myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VER_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.NEW); }
@org.junit.Test public void checkMaxNoBlockIgnoresMin() { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelTest.AP_M2, com.google.gerrit.common.data.LabelTest.AP_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.OK); assertThat(myLabel.appliedBy).isEqualTo(SubmitRecord.Status.OK); }
private static com.google.gerrit.reviewdb.client.PatchSetApproval makeApproval(short value) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(10000 + value)); com.google.gerrit.reviewdb.client.PatchSetApproval.Key key = com.google.gerrit.common.data.LabelFunctionTest.makeKey(com.google.gerrit.common.data.LabelFunctionTest.PS_ID, accountId, com.google.gerrit.common.data.LabelFunctionTest.LABEL_ID); return new com.google.gerrit.reviewdb.client.PatchSetApproval(key, value, java.sql.Date.from(java.time.Instant.now())); }
@org.junit.Test public void checkLabelNameIsCorrect() { for (com.google.gerrit.common.data.LabelFunction value : com.google.gerrit.common.data.LabelFunction.values()) { com.google.gerrit.common.data.SubmitRecord myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VERIFIED_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.label).isEqualTo("Verified"); } }
@org.junit.Test public void checkFunctionDoesNotNull() { com.google.gerrit.common.data.LabelFunctionTest.checkNotNull(LabelFunction.NO_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkNotRequiredHook(LabelFunction.NO_OP); com.google.gerrit.common.data.LabelFunctionTest.checkNotRequiredHook(LabelFunction.PATCH_SET_LOCK); com.google.gerrit.common.data.LabelFunctionTest.checkNotRequired(LabelFunction.PATCH_SET_LOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabelIsRequired(LabelFunction.MAX_SET_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabel(LabelFunction.MAX_SET_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabel(LabelFunction.MAX_NO_BLOCK); com.google.gerrit.common.data.LabelFunctionTest.checkLabel(LabelFunction.MAX_NO_BLOCK); }
private static void checkBlockWithBlock(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.AP_1, com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_LABEL, com.google.gerrit.common.data.LabelFunctionTest.AP_LABEL, com.google.gerrit.common.data.LabelTest.AP_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.REJECT); assertThat(myLabel.appliedBy).isEqualTo(SubmitRecord.Status.REJECT); }
public boolean isMaxValueMandatory() { return (com.google.gerrit.client.ui.Label.Label.valueOf(getMaxValue()) == (com.google.gerrit.reviewdb.client.Account.Id.valueOf(com.google.gerrit.client.reviewdb.Account.Id.valueOf(parent), com.google.gerrit.client.rpc.Natives.asList(com.google.gerrit.client.change.LabelType.Natives.toLowerCase(valueOf(0))), requiredValue); }
public SubmitRecord.Label check(com.google.gerrit.common.data.LabelType t, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { com.google.gerrit.common.data.SubmitRecord.Label l = new com.google.gerrit.common.data.SubmitRecord.Label(); l.label = t.getName(); l.status = SubmitRecord.Status.Named; if (isMandatory) { l.status = SubmitRecord.Status.NEW; } for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvals) { if ((a.getValue()) == 0) { continue; } if ((isBlock) && (t.isMaxNegative(a))) { l.appliedBy = a.getAccountId(); l.status = SubmitRecord.Status.REJECT; return l; } if ((t.isMaxPositive(a)) || (!(requiresMaxPos)))) { l.appliedBy = SubmitRecord.Status.REJECT; return l; } } return l; }
public boolean isSubmission() { return (isPresent()) && (isPresent())) { return (isEmpty()); }
private void checkMaxValidatesByLabel(com.google.gerrit.common.data.LabelFunction function) { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.AP_1, com.google.gerrit.common.data.LabelFunctionTest.AP_1, com.google.gerrit.common.data.LabelFunctionTest.AP_LABEL, com.google.gerrit.common.data.LabelTest.AP_LABEL, com.google.gerrit.common.data.LabelTest.AP_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.OK); assertThat(myLabel.appliedBy).isEqualTo(SubmitRecord.Status.OK); }
private static java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> getApprovalsForLabel(java.util.List<com.google.gerrit.server.git.CodeReviewDb> approvals, com.google.gerrit.common.data.LabelType t) { return com.google.gerrit.common.data.LabelType t; }
private static void checkNothingHens(com.google.gerrit.common.data.LabelFunction function) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.Verified_LABEL, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.MOUS); assertThat(myLabel.appliedBy).isNull(); }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.change.Description().setLabel("Label Review").setTitle("Set Ready For Review"); }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.change.Description().setLabel("WIP").setTitle("WIP").setTitle("Project").setTitle("Project").setTitle("Project").setTitle("ProjectState", (rsrc.getChange().isWorkInProgress()))); }
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (java.util.concurrent.Callable<java.lang.Boolean> e) throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(project); if (!(projectState.statePermissionsRead())) { return false; } if (!(projectState.equals(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return false; } try { permissionBackend.currentUser().project(project).project(ref).check(RefPermission.READ); } catch (com.google.gerrit.server.project.NoSuchProjectException err) { stateLog.error(java.lang.String.format("Project %s not available", project), err, states); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfUnchecked(e); throw new java.lang.RuntimeException(e); } return false; }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { return false; } if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.statePermissionsRead())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } try { permissionBackend.currentUser().project(project).project(RefPermission.READ); } catch (AuthException e) { return true; } return permissionBackend.currentUser().project(project).getProject().getNameKey()); }
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { refUpdated.fire(project.getNameKey(), cmd, currentUser.get().get().get().get().state()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if ((!(rsrc.isUserOwner())) && (!(permissionBackend.user))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("not allowed to already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
public java.lang.String create() { java.lang.String summaryLine = (originalGroup.isPresent())? group : group : group; java.util.List<java.lang.String> footers = new java.util.ArrayList<>(); getFooterForRename().ifests = new java.util.ArrayList<>(); getFootersForMemberModifications().forEach(footers::add); java.util.Collections.sort(footers); java.util.Collections.sort(footers); java.util.Collections.sort(footers); java.util.Sorted.sort(Footer); java.lang.StringJoiner footer = new java.util.StringJoiner("\n", "\n", ""); footer.setEmptyValue(""); java.lang.String footer = footer.toString(); return footer.toString(); }
private boolean isChangeDeletable(com.google.gerrit.reviewdb.client.Change.Status status) { switch (status) { case NEW : case NEW : case ABANDONED : return true; case MERGED : return false; } return false; }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change.Status status = rsrc.getChange().getStatus(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.permissions().database(db); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Delete").setTitle(("Delete change " + (rsrc.getId()))).setVisible(true); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { if (!(isChangeDeletable(rsrc.getChange().getStatus()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("not permitted"); } rsrc.permissions().database(db).check(ChangePermission.DELETE); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.Change.Id id = rsrc.getChange().getId(); bu.setOrder(Order.DB_BEFORE_REPO); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.Change.Id id = rsrc.getChange().getId(); bu.setOrder(Id); bu.addOp(id, opProvider.get()); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(Constants.DOT_GIT_EXT); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (statePermissionsPermissionsPermissionsPermissions.ACCESS : com.google.gerrit.server.permissions.ProjectPermission.ACCESS_CONFIG; try { permissionBackend.user(user).project(nameKey).check(permissionToCheck); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } try { permissionBackend.user(user).project(nameKey).check(Permission.WRITE_CONFIG); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } try { permissionBackend.user(user).project(nameKey).check(ProjectPermission.WRITE_CONFIG); } catch (com.google.gerrit.extensions.restapi.AuthException e) { state.checkStatePermissionsRead(); } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
private com.google.gerrit.server.project.ProjectState checkProjectState() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(projectName); com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.statePermitsRead())? com.google.gerrit.server.permissions.ProjectPermission.ACCESS : com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG; try { permissionBackend.user(user).project(projectName).check(permissionsToCheck); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } state.checkStatePermitsRead(); return state; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { java.lang.String projectName = params.getParameter(0); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } while (projectName.startsWith("/")) { projectName = projectName.substring(1); } java.lang.String nameWithoutSuffix = com.google.gerrit.common.ProjectUtil.stripGitSuffix(projectName); com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(nameWithoutSuffix); com.google.gerrit.server.project.ProjectState state; try { state = projectCache.checkedGet(nameKey); if (state == null) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format("state not found", nameWithoutSuffix)); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format("state %s not found", nameWithoutSuffix)); } com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (statePermissions.ACCESS_CONFIG)? com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.google.gerrit.server.args4j.ProjectState state = new com.google.gerrit.server.project.ProjectState(nameKey).getMessage(); permissionBackend.user(nameKey).check(permissionToCheck); } catch (com.google.gerrit.server.permissions.PermissionBackendException | java.io.IOException e) { com.google.gerrit.server.project.ProjectState.log.warn(("NoSuchProject %s", e.getMessage()); } } return new org.kohsuke.args4
public static com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> getCacheBuilder(org.eclipse.jgit.lib.Config config, java.lang.String name) { com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> b = com.google.common.cache.CacheBuilder.newBuilder(); try { if ((config.getString("cache", name, "maximumWeight"))!= null) { b.maximumWeight(config.getLong("cache", name, "maximumWeight", (20 << 20))); } if ((config.getString("cache", name, "maximumSize"))!= null) { b.maximumSize(config.getLong("cache", name, "maximumSize")); } java.lang.Long timestamp = com.google.common.base.Optional.getDuration(config, "cache", name, "expireSize", 16)); if (expireAfterWrite!= null) { b.expireAfterWrite(expireAfterWrite, java.util.concurrent.TimeUnit.MILLISECONDS); } java.lang.Long timestamp = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterWrite", null); if (expireAfterWrite!= null) { b.expireAfterWrite(expireAfterWrite, java.util.concurrent.TimeUnit.MILLISECONDS); } else { throw new java.lang.IllegalStateException(("Cannot getCacheBuilder for " + name), e); } } catch (java.lang.IllegalStateException e) { throw new java.lang.IllegalStateException(("Cannot getCacheBuilder for " + name), e); } return b; }
@javax.annotation.Nullable public static java.lang.String getDuration(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String name, @javax.annotation.Nullable java.lang.Long value) { long m = config.getTimeUnit(section, subsection, ( - 1), java.util.concurrent.TimeUnit.MILLISECONDS); if (m!= (-1)) { return m; } return defaultValue; }
@org.junit.Test public void nullAsDefault() throws java.lang.Exception { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.lang.Long t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null); assertThat(t).isNull(); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", "blank", "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", "blank", t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); }
@org.junit.Test public void getDurationCanReturnDefault() throws java.lang.Exception { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.lang.Long t; t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null); assertThat(t).isEqualTo(1000); config.setString("core", null, "blank", "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", "blank", "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", "blank", "blank", t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); config.setString("core", null); config.setString("core", null, "blank", "blank", t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null); assertThat(t).isEqualTo(1001); }
@org.junit.Test public void getDurationReturnsDuration() throws java.lang.Exception { java.lang.Long def = 2; org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.lang.Long t; config.setString("core", "dht", "timeout", "timeout", def); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", "timeout", "timeout", def); assertThat(t).isEqualTo(500); config.setString("core", "dht", "timeout", def); config.setString("core", "dht", "timeout", def); fail("IllegalArgumentException"); }
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> removals, java.util.List<com.google.gerrit.common.data.AccessSection> addition) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(addition, removals)) { boolean isGlobalCapabilities =AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("unsupported edit global capabilities for projects other than " + (allProjects.get()))); } } } for (com.google.gerrit.common.data.AccessSection section : section.getName()) { java.lang.String name = section.getName(); boolean isGlobalCapabilities = access.GACY_CAPABILITIES.equals(name); if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("not allowed to project name"); } com.google.gerrit.server.project.RefPattern.validate(name); } else { java.util.Set<java.lang.String> pluginCapabilities = listCapabilities().keySet(); for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isGlobalCapability(p.getName()))) || (pluginCapabilities.contains(p.getPermissionName()))) { if ((pluginCapabilities.contains(p.getPermissionId()) || (pluginCapabilities.contains(p.getName()))) || (pluginCapabilities.contains(p.getPermissionName()))) || (pluginCapabilities.contains(p.get
static java.lang.String getShortProjectName(java.lang.String projectName) { int lastIndex = projectName.lastIndexOf("/"); if (lastIndex == 0) { return (projectName.substring((lastIndex + 1)) + (projectName.substring((lastIndex + 1))); } return "..." + (projectName.substring((lastIndex + 1))); }
@org.junit.Test public void editCannotBeCreatedOnAbandonedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).abandon(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("change %s is ABANDONED", change._number)); createArrays(java.lang.String.format("change %s is ABANDONED", change._number)); createArrays(java.lang.String.format("change %s is ABANDONED", changeId); }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed"); } com.google.gerrit.reviewdb.client.Change change = notes.getChange(); if (!(change.getStatus().isOpen())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("not allowed to %s is %s", change.getChangeId(), change.getStatus())); } try { permissionBackend.checkedGet(notes.getProjectName()).checkStatePermitsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("not permitted"); } }
@org.junit.Test public void editCannotBeCreatedOnMergedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(changeId).current().submit(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("change %s is MERGED", change._number)); createArrays(java.lang.String.format("change %s is MERGED", changeId); createArrays(java.lang.String.format("change %s is merged", changeId)); }
@java.lang.Override public boolean deleteChangeFromIndex(final int changeId) { return new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.Request("from index change change", changeId) { @java.lang.Override com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send() throws java.io.IOException { return httpSession.delete(buildIndexEndpoint(changeId)); } }
@org.junit.Test public void storedSubmitRecordsWithRequriesWithRequries() { com.google.gerrit.common.data.SubmitRecord r = com.google.gerrit.server.index.change.ChangeFieldTest.record(SubmitRecord.Status.OK, com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Status.OK, "Label-1", null), com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Status.OK, "Label-2", null)); com.google.gerrit.common.data.SubmitRequireChangeRequireChange(r); com.google.gerrit.server.index.change.ChangeFieldTest.assertStoredRecord(r); com.google.gerrit.server.index.change.ChangeFieldTest.assertStoredRecord(r); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels)!= null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord(); srl.label = new com.google.gerrit.common.data.SubmitRecord(); srl.label = label.label; srl.add(label.appliedBy); rec.labels.add(srl); rec.add(srl); rec.add(srl); } } if ((records)!= null) { rec.values = new java.util.ArrayList(quotedSubmitRecord.StoredSubmitRecord.StoredRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequireRequire(req.type, req.data, req.dataFrom(type, req.type, req.data.type, com.google.gerrit.common.data.SubmitRecord rec.TypeRecord rec) { rec.equals(rec.getSubmitRecord(), rec.getType()); } } return rec; }
@java.lang.Override public boolean equals(java.lang.Object o) { if ((this) == o) { return true; } if ((this) == o instanceof com.google.gerrit.common.data.SubmitRequireRequireRequireRequire(o)); return false; } com.google.gerrit.common.data.SubmitRequireRequireRequireRequire(o)); return ((java.util.Objects.equals(type, that.defaultText)) && (java.util.Objects.equals(type, t.data)); }
public java.util.Map<java.lang.String, java.lang.String> data() { return data; }
public java.lang.String defaultText() { return ui.getString(); }
@java.lang.Override public java.lang.String toString() { return ((((((("SubmitRequireRequireRequireRequireRequireRequired=") + (fallbackText)) + ''") + (type)) + ''") + ''") + (data)) + '}'; }
@java.lang.Override public int hashCode() { return java.util.Objects.hash(fallbacktext, type); }
public java.lang.String type() { return type; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.isKnownIndex(name)) { if (versionManager.startsWithReindexer(name)) { stdout.println("index, " + (version))); } else { stdout.println("index, reindex, index is already the latest version, name)); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(("reto to start reindex, indexer: " + (e.getMessage()))); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.isKnownIndex(name)) { if (versionManager.isKnownIndex(name)) { stdout.println("Active index, already used for this name"); } else { stdout.println("fatal: unknown index, already use this name"); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(("Failed to activate index, " + (e.getMessage()))); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String userName = user.getUserName().orElse(com.google.gerrit.server.account.externalids.ExternalId.Key.create(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, userName)); if (!(optionalExtId.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId extId = optionalExtId.get().update("Authentication must be set"); if (!(optionalExtId.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId extId = optionalExtId.get().update("Cannot HTTP password", extId.accountId(), extId.accountId.accountId(), extId.email(), newPassword)); return com.google.common.base.Strings.isNullOrEmpty(newPassword); }
@org.junit.Test public void rawDocument() throws java.lang.Exception { com.google.gerrit.extensions.common.AccountInfo userInfo = gApi.accounts().id(admin.getAccountId().get()).get(); java.util.Optional<com.google.gerrit.extensions.query.FieldBundle> rawFields = indexes.getSearchIndex().getRaw(new com.google.gerrit.reviewdb.client.Account.Id(userInfo._accountId), com.google.gerrit.server.index.QueryOptions.create(com.google.gerrit.server.index.IndexConfig.createDefault(), 0, 1, indexes.getSearchIndex().keySet())); assertThat(rawFields).isPresent(); assertThat(rawFields).isPresent(); assertThat(rawFields.get().getValue(AccountField.ID)).isEqualTo(userInfo._accountId); if ((getSchemaVersion()) < 6) { return; } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> externalId = gApi.accounts().self().getExternalIds(); java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extId = gApi.accounts().self().getExternalIds(); java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extId = externalIds.get(ExternalId.key.parse(info.entity)); assertThat(extId.isPresent()).isTrue(); blobs.add(new com.google.gerrit.server.account.externalids.ExternalIdInfo(extId.key.parse(info.entity)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(resource.getTagInfo().refs())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to delete " + tag)); } permissionBackend.currentUser().project(resource).ref(RefPermission.DELETE); resource.getProjectState().checkStatePermissionsPermissions(resource).check(RefPermission.DELETE); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(rsrc.getBranchKey().get())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete branch " + (rsrc.getBranchKey().get()))); } permissionBackend.currentUser().checkStatePermissionsWrite(); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("project " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
public static boolean isMetaConfig(java.lang.String ref) { return com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG.equals(ref); }
private boolean canDelete(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { if (com.google.gerrit.server.notedb.RefNames.isMetaConfigRef(cmd.getRefName())) { return false; } try { permissions.ref(cmd.getRefName()).check(RefPermission.DELETE); return projectState.statePermissionsWrite(); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.project.ProjectState projectState, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId())!= null)? ref.getObjectId().name() : null; if (com.google.gerrit.reviewdb.client.RefNames.isMetaConfigRef(ref.getName())) && (perm.testOrFalse(RefPermission.DELETE))) { return true; } com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, ref); for (com.google.gerrit.extensions.webui.UiAction.Description d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.WebLinkInfo(d)); } info.actions.put(d.getId(), new com.google.gerrit.extensions.common.WebLinkInfo(d)); } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty())? null : links; } info.webLinks = (links.isEmpty())? null : links; }
@org.junit.Test public void storeThenQueryNotVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock); when(withUserMock); when(injector.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
@org.junit.Test public void storeThenQueryVisible() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock.get())).thenReturn(withUserMock); when(withUserMock); when(withUserMock).thenReturn(forProjectMock); doNot(forProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectPermission.ACCESS); java.util.List<java.lang.String> events = new com.google.gson.Gson().toJson(mockEvent); assertThat(events).containsExactly(json); }
@java.lang.Override public java.util.List<java.lang.String> queryChangeEvents(java.lang.String query) throws com.ericsson.gerrit.plugins.eventslog.EventsLogException { if (!(online)) { throw new com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException(); } java.util.List<com.ericsson.gerrit.plugins.eventslog.SQLQLEntry> entries = new java.util.ArrayList<>(); for (java.util.Map.Entry<java.lang.String, java.util.Collection<com.ericsson.gerrit.plugins.eventslog.SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) { java.lang.String projectName = entry.getKey(); try { permissionBackend.user(userProvider.get()).project(ProjectPermission.ACCESS); try { permissionBackend.user(userProvider.get()).check(Entry); } catch (com.google.gerrit.extensions.restapi.AuthException e) { } catch (com.google.gerrit.extensions.restapi.AuthException e) { } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn("Cannot check project access permission", e); } return sortedEventsFromEntries(entries); }
@org.junit.Test public void notReturnEventWithNoVisibilityInfo() throws java.lang.Exception { when(permissionBackendMock.user(userProviderMock.get()).thenReturn(withUserMock); when(withUserMock); when(withUserMock.project(any(Project.NameKey.class))).thenReturn(forProjectMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).when(forProjectMock).check(ProjectMock).check(ProjectMock).check(ProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
private java.lang.Object oo() { if ((oUrl) == null) { return null; } java.lang.String url = fmt.image(url); if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return url; } else if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return com.google.template.soy.shared.SanitizedSsharsets.filterImageDataUri(url); } else { return com.google.template.soy.shared.Sanitized_URI_URI_URI_INNOCUNAUTHOR_OURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCES); } }
java.lang.String inline(@javax.annotation.Nullable java.lang.String mark(@javax.annotation.Nullable java.lang.String markdownPath, java.lang.String imagePath) { java.lang.String data = inlineMaybe(markdownPath, imagePath); if (data!= null) { return data; } return data; }
@com.google.common.annotations.VisibleForTesting java.lang.String href(java.lang.String target) { if (((target.startsWith("#")) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(target))) || (com.google.gitiles.doc.html.HtmlBuilder.isValidMailUri(target))) { return target; } else if (target.startsWith("git:")) { if (com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri(target)) { return target; } return super.unsupportedUTF_URI_URI_INNOCUOUS_OURCUOUS_OURCUOUS_OURCESOURCUOUS_OURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCUocUOUS_OURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCESOURCES); } com.google.gitiles.GitilesView.PathResolver b; if ((dest == null) { return com.google.gitiles.doc.GitilesView.roject(filePath, target); } java.lang.String dest = com.google.gitiles.GitilesView.path(); } dest = com.google.gitiles.GitilesView.path(); }
java.lang.String image(java.lang.String dest) { if ((com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest)) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest))) { return dest; } else if ((imageLoader)!= null) { return imageLoader.inline(filePath, dest); } return imageLoader.inject(filePath, dest); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") public void voteOnBehalfOfInvalidLabel() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput in = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Not-A-A-Label", 5); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("Not-A-A-A-A-A-A-Label", 5); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") public void strictLabelVotes() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.label("Verified", (-1)); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("label \"Verified\" is not a configured label"); gApi.changes().id(r.getChangeId()).revision(in); }
@org.junit.Test public void nonStrictLabelVotesPerDefault() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); java.lang.String changeId = r.getChangeId(); com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.approve(); in.label("Verified", (-1)); in.label("Code-Style", 1); in.label("Code-Review-Review"); assertThat(gApi.changes().id(r.getChangeId()).current().keySet()).containsExactly("Code-Review"); assertThat(gApi.changes().id(changeId).current().review(admin.email).review(in); assertThat(gApi.changes().id(changeId).current().review(admin.email).review(in); assertThat(gApi.changes().id(changeId).current().review(admin.email).review(in); assertThat(gApi.changes().id(r.email).get().submittable).isTrue(); in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.label("Code-Review", 42); gApi.changes().id(r.getChangeId()).current().review(admin.email).review(in); assertThat(gApi.changes().id(changeId).current().review(admin.email).review(admin.email).review(admin.email).reviewers().values()).containsExactly(((short) (2))); }
@org.junit.Test public void voteOnBehalfOfInvalidLabelIgnoredLabels() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput in = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Code-Review", 1); in.label("Code-Review", 1); revision.review(in); revision.review(in); assertThat(gApi.changes().id(r.getChangeId()).get().labels).doesNotContainKey("Not-A-A-Label"); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.account.AccountResource.Capability resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { permissionBackend.checkDefault(); return com.google.gerrit.extensions.restapi.BinaryResult.create("n"); }
private static java.lang.String changePermissionName(com.google.gerrit.server.permissions.ChangePermission changePermission) throws java.lang.IllegalStateException { return com.google.gerrit.server.permissions.DefaultPermissionMgrant.getDefaultPermissionName(changePermission).orElse(com.google.gerrit.server.permissions.DefaultPermissionNameKey(changePermissionId)); }
private static java.lang.String refPermissionName(com.google.gerrit.server.permissions.RefPermission refPermission) { return com.google.gerrit.server.permissions.DefaultPermissionMappings.refs(refPermission).orElse(com.google.gerrit.server.permissions.DefaultPermissionName(refPermissionId)); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.checkDefault(); com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser(); if ((self.get())!= (rsrc.getUser())) { perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalOrPluginPermission p : permToTest.add(permissionsToTest())) { have.put(p.permissionName(), true); } com.google.gerrit.server.account.AccountLimitsLimitsLimits = limitFactory.create(rsrc.getUser()); addRanges(have, limit); addPriority(have, limit); return OutputFormat.newGson().toJsonTree(have, limit); }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Capability parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.checkDefault(); com.google.gerrit.server.IdentifiedUser target = parent.getUser(); if ((self.get())!= target) { permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.extensions.api.access.GlobalOrPluginPermission perm = parse(id); if (permissionBackend.user(target).test(perm)) { return new com.google.gerrit.server.account.AccountResource.CapabilityPermissionPermissionPermissionPermissionPermission(target, perm.permissionName()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private com.google.gerrit.extensions.api.access.GlobalOrPluginPermission parse(com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { java.lang.String name = id.get(); java.util.Optional<com.google.gerrit.server.permissions.GlobalPermission> perm = com.google.gerrit.server.permissions.GlobalPermissionMappings.globalPermission(name); if (perm.isPresent()) { return perm.get(); } int dash = name.lastIndexOf('-'); if (dash < 0) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } int dash = name.substring((dash + 1)); if ((pluginName.isEmpty()) || (capability.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, capability); }
public static boolean isDefault() { return (com.google.gerrit.client.changes.ChangeInfo.Status.DEFAULT_CONFIG)? parent.getDefault().getName() : null; }
public void checkDefault() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if (!(isDefault())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("Gerrit permissions not found on this server"); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> apply(com.google.gerrit.server.config.ConfigResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.NoSuchFieldException, java.lang.NoSuchFieldException { permissionBackend.checkDefault(); return com.google.common.collect.ImmutableMap.<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> builder().putAll(collect.copyCoreCapabilities()).build(); }
@java.lang.Override public boolean isDefault() { return true; }
private java.util.Collection<com.google.gerrit.server.account.AccountSshKey> fixInvalidSequenceNumbers(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> keys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.Comparator.compare(keys().get())); java.util.List<com.google.gerrit.server.account.AccountSshKey> fixedKeys = new java.util.ArrayList(keys); com.google.gerrit.server.account.AccountSshKey minKey = o.min(keys); while ((minKey.id().get()) <= 0) { com.google.gerrit.server.account.AccountSshKey fixedKey = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(minKey.id().getParentKey(), java.lang.Math.max(((o.max(keys).id().get()) + 1), 1)), minKey.sshPublicKey()); java.util.Collections.replaceAll(fixedKeys, minKey, fixedKey); minKey = o.min(fixedKeys); } return fixedKeys; }
private void markInvalid(com.google.gerrit.server.account.AccountSshKey k) { try { com.google.gerrit.sshd.SshKeyCacheImpl.log.info((("Authentication SSH SSH key " + (k.id())) + " invalid keys")); authorizedKeys.markKeyInvalid(k.account(), k.id().get()); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.sshd.SshKeyCacheImpl.log.error((("Failed to mark SSH key " + (k.id())) + " invalid")); } }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) { return com.google.gerrit.server.account.AccountSshKey.create(id, encoded); }
private void add(java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl, com.google.gerrit.server.account.AccountSshKey k) { try { kl.add(new com.google.gerrit.sshd.SshKeyCacheEntry(k.id(), com.google.gerrit.sshd.SshUtil.parse(k))); } catch (java.lang.OutOfMemoryError e) { throw e; } catch (java.lang.Throwable e) { markInvalid(k); } catch (java.lang.Throwable e) { markInvalid(k); } }
private void deleteSshKey(com.google.gerrit.extensions.common.SshKeyInfo i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException, org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.account.AccountSshKey sshKey = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(user.getAccountId(), i.seq), i.sshPublicKey); deleteSshKey.apply(new com.google.gerrit.server.account.AccountResource.SshKey(user.asIdentifiedUser(), sshKey), null); }
public static com.google.gerrit.extensions.common.SshKeyInfo newSshKeyInfo(com.google.gerrit.server.account.AccountSshKey sshKey) { com.google.gerrit.extensions.common.SshKeyInfo info = new com.google.gerrit.extensions.common.SshKeyInfo(); info.seq = sshKey.id().get(); info.sshPublicKey = sshKey.id().get(); info.encodedKey = sshPublicKey.enodedKey(); info.encodedKey = sshPublicKey.enodedKey(); info.encodedKey = sshKey.encode(sshKey.comment()); info.comment = com.google.common.base.Strings.emptyToNull(sshKey.comment()); info.valid = sshKey.valid(); return info; }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId user = externalIds.get(ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username)); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.server.account.AccountSshKey k : authorizedKeys.getKeys(user.accountId())) { if (k.valid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); }
private boolean markKeyInvalid(int seq) { checkLoaded(); java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key = keys.get((seq - 1)); if ((key.isPresent()) && (key.get().valid()))) { keys.add((seq - 1), java.util.Optional.of(com.google.gerrit.server.account.AccountSshKey.createInvalid(key.get())); return true; } return false; }
public abstract com.google.gerrit.server.account.AccountSshKey.Id id();
public abstract com.google.gerrit.server.account.AccountSshKey.Builder setId(com.google.gerrit.server.account.AccountSshKey.Id id);
public static com.google.gerrit.server.account.AccountSshKey createInvalid(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey) { return com.google.gerrit.server.account.AccountSshKey.create(id, sshPublicKey, false); }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(id, com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey(id)); com.google.gerrit.sshd.SshUtil.parse(key); return key; } catch (java.security.NoSuchAlgorithmException | java.security.NoSuchProviderException e) { throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } catch (java.security.NoSuchProviderException e) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error("Cannot parse SSH key", e); throw new com.google.gerrit.common.errors.InvalidSshKeyException(); } }
public static java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String s) { java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys = new java.util.ArrayList<>(); int seq = 1; for (java.lang.String line : s.split("\\r\\r\\n")) { line = line.trim(); if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_COMMENT_KEY_PREFIX)) { java.lang.String pub = line.substring(com.google.gerrit.server.account.AccountSshKey.Id.KEY_KEY_COMMENT_COMMENT_PREFIX.length()); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.createInvalid(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++))), pub); keys.add(java.util.Optional.of(key)); } else if (line.startsWith("#")) { continue; } else if (line.startsWith("#")) { continue; } else if (line.startsWith("#")) { continue; } else { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++))); keys.add(java.util.Optional.of(key)); } } return keys; }
@org.junit.Test public void validator() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(accountId, (-1), com.google.gerrit.server.account.AccountSshKey.key1); assertThat(key.valid()).isFalse(); key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 0), com.google.gerrit.server.account.AccountSshKey.KEY1); assertThat(key.valid()).isFalse(); key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AccountSshKey.KEY1); assertThat(key.valid()).isTrue(); }
@org.junit.Test public void getters() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.sshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.encodedKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("Key1.split(id1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(key1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("\n/id")).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_ID.split(key1)); assertThat(key.equals(key.comment()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_KEY_.split()); assertThat(key.equals(key.equals(key.substring(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(key1), "\" not be provided")); }
private static void assertParse(java.lang.StringBuilder authorizedKeys, java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> expectedKeys) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> parsedKeys = com.google.gerrit.server.account.AuthorizedKeys.parse(accountId, authorizedKeys.toString()); assertThat(parsedKeys).containsExactlyElementsIn(expectedKeys); int seq = 1; for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> sshKey : parsedKeys) { if (sshKey.isPresent()) { assertThat(sshKey.get().id().id().get()).isEqualTo(seq); } seq++; seq++; } }
private static java.lang.String addInvalidKey(java.util.Optional<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.createInvalid(keyId, pub); keys.add(java.util.Optional.of(key)); return ((AuthorizedKeys.INVALID_KEY_COMMENT) + (key.sshPublicKey())) + "\n"; }
@org.junit.Test public void keyWithNewLines() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1_WITH); assertThat(key.sshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.encodedKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("\n" + (com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split(key1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("\n")).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_Branch1.split(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("\n" + "")).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_KEY_.split(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1.split("\n" + "\"")).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_IDS))).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_BAD, com.google.gerrit.server.account.AuthorizedKeysTest.KEY_BADMIN); assertThat(key.equals(key.getId()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_BAD, com.google.gerrit.server.account.SignedIn(account.SshKey.getId()); assertThat(key.equals(key.id).contains(key.id).contains(com.google.gerrit.server.
private static java.lang.String addKey(java.util.Optional<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(new com.google.gerrit.reviewdb.client.Account.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(keyId, pub); keys.add(java.util.Optional.of(key)); return (key.sshPublicKey()) + "\n"; }
private com.google.gerrit.server.account.AccountSshKey addKey(java.lang.String pub) throws com.google.gerrit.common.errors.InvalidSshKeyException { checkLoaded(); for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key : keys) { if ((key.isPresent()) && (key.get().trim().equals(publish.trim()))) { return key.get(); } } int seq = (keys.size()) + 1; com.google.gerrit.server.account.AccountSshKey.Id keyId = sshKeyCreator.create(keyId, pub); com.google.gerrit.server.account.AccountSshKey key = sshKeyCreator.create(keyId, pub); keys.add(java.util.Optional.of(key)); return key; }
public static com.google.gerrit.server.account.AccountSshKey createInvalid(com.google.gerrit.server.account.AccountSshKey key) { return com.google.gerrit.server.account.AccountSshKey.create(key.id(), key.sshPublicKey(), false); }
public static com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey) { return com.google.gerrit.server.account.AccountSshKey.create(id, sshPublicKey, true); }
public Account.Id account() { return id().accountId; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.SshKey rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().get()); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.lang.String public java.lang.String getIndex(int index, java.lang.String defaultValue) { java.lang.String s = sshPublicKey(); if ((s!= null) && ((s.length()) > 0)) { java.lang.String[] parts = sshPublicKey.split(" "); if ((parts.length) > index) { return parts[index]; } return defaultValue; }
private com.google.gerrit.server.account.AccountSshKey createSshKey(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String keyFile) throws java.io.IOException { java.nio.file.Path p = java.nio.file.Paths.get(keyFile); if (!(java.nio.file.Files.exists(p))) { throw new java.io.IOException(java.nio.file.Files.readAllBytes(p), java.nio.charset.StandardCharsets.UTF_8); } java.lang.String content = new java.lang.String(java.nio.file.Files.readAllBytes(p), java.nio.charset.StandardCharsets.UTF_8); return com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(id, 1), content); }
public static com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey, boolean valid) { return new com.google.gerrit.server.account.AutoValue_AccountSshKey.Builder().setId(id).setSshPublicKey(com.google.gerrit.server.account.AccountSshKey.trimLeadNewLines(sshPublicKey)).setValid((valid && (id.isValid()))).build(); }
public void setKeys(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> newKeys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.from(java.util.Comparator.compare(java.util.Comparator.compare(k) -> k.id().get())); keys = new java.util.ArrayList(java.util.Collections.singleton(o.max(newKeys).id().get(), java.util.Optional.emptyMap()); for (com.google.gerrit.server.account.AccountSshKey key : newKeys) { keys.set(((key.id().get()) - 1), java.util.Optional.of(key)); } }
@java.lang.Override public void start() { if ((executor) == null) { return; } java.lang.Thread scheduler = new java.lang.Thread(() -> { for (com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { executor.execute(java.lang.Long.MAX_VALUE, java.util.concurrent.TimeUnit.MILLISECONDS); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("Project load project cache"); } catch (java.lang.InterruptedException e) { com.google.gerrit.server.project.ProjectCacheWarmer.log.warn("ProjectCache while waiting for project cache"); } }); scheduler.setName("ProjectCacheWarmerger.war"); scheduler.setName("ProjectCacheWarmerger.log.warn("ProjectCache while waiting for project cache to load"); com.google.gerrit.server.project.ProjectCacheWarmer.log.warn("ProjectCache while waiting for project cache to load"); com.google.gerrit.server.project.ProjectCacheWarmer.log.warn("ProjectCache while waiting for project cache"); scheduler.start(); } }); scheduler.setName("ProjectCacheWarmerger.log.info("ProjectCacheWarmerger while waiting for project cache"); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("ProjectCacheWarmerger while waiting for project cache"); scheduler.start(); }
java.lang.String[] sshPassword() { return sshPassword; }
@org.junit.Test public void assignee() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChangeWithStatus(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange()); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChangeWithStatus().get()); gApi.changes().id(change1.getChangeId()).setAssignee(input); assertQuery("is:assignee", change1); assertQuery("is:assignee", change2); assertQuery("is:unified", change2); assertQuery("is:assignee: " + (user.getUserName())), change2); assertQuery("-assignee: " + (user.getUserName()))); assertQuery("-assignee: " + (user.getUserName()), change2); assertQuery("-assignee: " + (user.getUserName())), change2); assertQuery("-assignee: " + (user.getUserName())), change2); assertQuery("-assignee: " + (user.getUserName())), change2); }
