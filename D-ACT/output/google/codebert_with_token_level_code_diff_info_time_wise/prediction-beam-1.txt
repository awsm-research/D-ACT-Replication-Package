@java.lang.Override protected com.google.gerrit.server.group.InternalGroup fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gson.JsonElement source = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(source.getAsJsonObject().get(GroupField.UUID.UUID.get()).getAsString()); return groupCache.get(uuid).orElseNull(); }
@java.lang.Override protected com.google.gerrit.server.project.ProjectData fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gson.JsonElement sourceKey = new com.google.gerrit.reviewdb.client.Project.NameKey(source.getAsJsonObject().getName()); return projectCache.get(nameKey).toProjectData(); }
protected abstract com.google.gson.JsonObject doc(com.google.gson.JsonDocument doc, java.util.Set<java.lang.String> fields);
@java.lang.Override protected com.google.gerrit.server.account.AccountState fromDoc(com.google.gson.JsonObject json, java.util.Set<java.lang.String> fields) { com.google.gson.JsonElement source = json.get("_source"); if (source == null) { source = json.getAsJsonObject().get("fields"); } com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(source.getAsJsonObject().get(com.google.gerrit.reviewdb.client.ID.getName()).getAsInt()); return accountCache.get().get(id); }
@java.lang.Override public com.google.gwtorm.server.ResultSet<Void> read() throws com.google.gwtorm.server.OrmException { org.eclipse.jgit.lib.Repository repo = read(); return readDoc(doc, doc); }
@java.lang.Override public com.google.gerrit.reviewdb.server.ReviewDb open() throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = delegate.open(); if (migration.readChanges()) { db = new com.google.gerrit.server.schema.NoChangesReviewDbWrapper(db); } db = new com.google.gerrit.reviewdb.server.ReviewDbWrapper(db); if (migration.disableChangeReviewDb()) { if (groupsMigration.disableChangeReviewDb()) { if (groupsMigration.disableGroupReviewDb()) { db = new com.google.gerrit.server.schema.NoGroups(db); } } return db; }
static java.lang.String getGroupName(com.google.gerrit.server.account.GroupCache groupCache, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { java.lang.String uuid = groupUUID.get(); java.lang.String name = groupCache.get(groupUUID).map(InternalGroup::getName).orElse(uuid); return com.google.gerrit.server.group.GroupsUpdate.format(name, uuid, uuid); }
@org.junit.Test public void includeExternalGroup() throws java.lang.Exception { java.lang.String g = createGroup("group"); java.lang.String subgroupUuid = System.get(); gApi.groups().id(g).addGroups(g).addGroups(subgroupUUID); java.util.List<com.google.gerrit.extensions.common.GroupInfo> subgroups = gApi.groups().id(g).includedGroups(); assertThat(subgroups).hasSize(1); assertThat(subgroups.get(0).isEqualTo(substring.replace(":", %3Api.replace(", %3Api.get().id), %3Api.get().id); if (groupsMigration.writeToNoteDb()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.server.group.GroupTestUtil.log.warn(("Migration-User: " + "%3A")); assertThat(log).hasSize(2); assertThat(log.get(0).message).isEqualTo("Create group"); } java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> log = com.google.gerrit.server.group.GroupTestUtil.log.warn(("Cannot log group\n\n\n\n\n\n"); assertThat(log).hasSize(2); assertThat(log.get(1).message).isEqualTo("Update group: %s\n\n\n"); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAudit> audit = groups.get(db, uuid); assertThat(audit).hasSize(1); assertThat(audit.get(0).getIncludeUUID()).isEqualTo(SystemGroupBackend.REGISTERED_USERS); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.extensions.config.CapabilityDefinition.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(Monitor.ID)).to(com.googlesource.gerrit.plugins.xdocs.Monitor.class); if (cfg.getBoolean("allowTopMenu", true)) { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.webui.TopMenu.class).toBoolean("allowTopMenu", true); } else if ((java.lang.System.exists()) && ((java.nio.file.Files.exists(directoryName)) && (java.nio.file.Files.exists(directoryName))) { storagePath = directory; } else { storageDir = tmpDir.resolve(pluginName); } if ((java.lang.System.exists())!= null) { java.lang.System.setProperty(((pluginName) + ".storage-directory")); } else { storageDir = tmpDir.resolve(pluginName); } if ((java.lang.System.getProperty(((pluginName) + ".storage") + ".storage") == null) { java.lang.System.setProperty(((pluginName) + ".storage-directory", storagePath.toString())); } }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = com.googlesource.gerrit.plugins.javax.servlet.httpd.GerritRequestFilter.JAVMONITORY_LOCATION_DOTORARY.resolve(com.googlesource.gerrit.plugins.javax.servlet.httpd.GerritJavax.Javax.namingFilter.JAVAUTHORIZATION_PREFIX); if (java.nio.file.Files.isDirectory(tmp)) { return tmp.toString(); } if (!(java.nio.file.Files.isDirectory())) { try { java.nio.file.Files.createDirectories(defaultDataDir); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javax.servlet.http.GerritRequestFilter.log.error("Creation data dir data dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir", e); throw new java.lang.RuntimeException(e); } } return defaultDataDir.toString(); }
private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage) throws java.io.IOException { return createCommit(repo, commitMessage, null); }
private org.eclipse.jgit.lib.ObjectId createCommit(org.eclipse.jgit.lib.Repository repo, java.lang.String commitMessage, @com.google.gerrit.common.Nullable org.eclipse.jgit.lib.ObjectId treeId) throws java.io.IOException { try (org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter()) { if (treeId == null) { treeId = oi.insert(Constants.OBJ_TREE, new byte[]{ }); } org.eclipse.jgit.lib.CommitBuilder cb = new org.eclipse.jgit.lib.CommitBuilder(); cb.setTreeId(treeId); cb.setCommitter(ident); cb.setCommitter(ident); cb.setAuthor(ident); cb.setMessage(commitMessage); return commit; } finally { oi.flush(); } }
@org.junit.Test public void pushToDeletedGroupBranchRefsRejectedForAllUsersRepo() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.AccountGroup.UUID.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushTo(allUsers, groupRef, true, "group not allowed"); }
@org.junit.Test public void cannotDeleteGroupBranch() throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); com.google.gerrit.server.group.InternalGroupAdmin adminGroup = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("Administrators")).orNull(null); assertThat(adminGroup).isNotNull(); testCannot deleteCannot deleteGroupBranch(adminGroup.getGroupUUID()).toDelete(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.project.getRefName().startsWith(MagicBranch)) { return java.util.Collections.emptyList(); } if ((receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGES)) || (receiveEvent.command.getRefName().startsWith(RefNames.REFS_DATTERN))) { throw new com.google.gerrit.server.git.validators.CommitValidationException("not allowed to update not allowed"); } return java.util.Collections.emptyList(); }
private void createBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, java.lang.String commitMessage) throws java.io.IOException { try (org.eclipse.jgit.lib.Repository rw = repoManager.openRepository(project);org.eclipse.jgit.lib.ObjectInserter oi = repoManager.newObjectInserter();org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(r)) { org.eclipse.jgit.lib.ObjectId emptyCommit = createCommit(r, commitMessage); org.eclipse.jgit.lib.ObjectId emptyCommit = rw.parseCommit(ref); updateRef.setExpectedOldObjectId(org.eclipse.jgit.lib.ObjectId.zeroId()); updateRef.setNewObjectId(emptyCommit); assertThat(updateRefUpdate.Result.NEW); } }
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || (!(destBranch.get().equals(RefNames.REFS_DEFS))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException("Not allowed to update not allowed to update not allowed"); }
@org.junit.Test public void pushToDeletedGitBranchForNonAllUsersRepo() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project = null; java.lang.String groupRef = com.google.gerrit.reviewdb.client.AccountGroup.UUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("fo")).get().id)); assertPushToGroup(groupRef, groupRef, null, null); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = rw.commit("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))).add("groups", ((("" + "\"]\n") + " from\n") + "\n") + "\n") + "\n")).create(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationError()).hasSize(1); assertThat(cfg.getValidationError()).hasSize(1); }
@org.junit.Test public void readConfigLabelScores() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = commit.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))).add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developer).add("Projects/config", (("" + "Projects/config")).create(); com.google.gerrit.server.git.ProjectConfig cfg = read(rev.getLabelSections(); java.util.Map<java.lang.String, com.google.gerrit.common.data.LabelType> labels = cfg.getLabelSections(); assertThat(type.isCopyMinScore()).isNotEqualTo(LabelType.DEFAULT_CODE_MAX_MAX_PRIVIAL_SC_MAX); assertThat(type.isCopyMaxScore()).isNotEqualTo(LabelType.DEFAULT_MAX_MAX_PRIVIAL_MAX); assertThat(type.isCopyMaxScore()).isNotEqualTo(LabelType.DELETE_MAX_PRIVIAL_PICK); assertThat(type.isCopyAllScoresOnRebaseChange()).isNotEqualTo(LabelType.DEFAULT); assertThat(type.isCopyAllScoresOnResizeAllScoresOnChange()).isNotEqualTo(LabelType.DEFAULT); assertThat(type.isCopyAllScoresIfNoCodeChange()).isNotEqualTo(labelType); }
@org.junit.Test public void editPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = commit.commit(developers).add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers))).add("groups", ((("" + "Project.name = " + (("[user\n") + " subject\n") + "\n") + "\n") + "\n")).create(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig cfg = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); pluginCfg = commit(cfg); assertThat(config.getGroupReference("key1")).isEqualTo(user1); rev = commit(cfg); assertThat(text(rev, " + (staff.toConfigValue()))).isEqualTo((((("\n" + "\n") + "Project: ") + (staff.getName())) + "\n")); assertThat(text(rev, "groups")).isEqualTo(((((("\n" + "\n") + "Project Name \"") + ") + (staff.getName())) + "\n") + "\n")); }
@org.junit.Test public void readPluginConfigGroupReference() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = commit.commit(com.google.gerrit.server.git.ProjectConfigTest.group(developers))).add("groups", ((("" + (("[args.project\\n" + "\"]\n") + " subject\n") + "\n") + "\n") + "\n")).create(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.server.config.PluginConfig pluginConfig = cfg.getPluginConfig("somePlugin"); assertThat(pluginCfg.getNames().size()).isEqualTo(1); assertThat(pluginCfg.getGroupReference("key1")).isEqualTo(reviewers); }
private java.lang.String getStorageDir() { final java.nio.file.Path tmp = java.nio.file.Paths.get(java.lang.System.getProperty("javax.servlet.http.System.getProperty("temp"))).resolve(com.googlesource.gerrit.plugins.javax.servlet.http.GerritJavax.Javax.servlet.Javax.servlet.Filter.JAVAUTH_DIR); if (java.nio.file.Files.isDirectory(tmp)) { return java.nio.file.Path storageDir; } java.nio.file.Path storageDir = java.nio.file.Paths.get(com.googlesource.gerrit.plugins.javax.naming.directory.JsonFilter.JsonData).map((path) -> path) -> { if (path == null) { return defaultDataDir; } return java.nio.file.Files.createDirectories(path); } catch (java.io.IOException e) { com.googlesource.gerrit.plugins.javax.servlet.GerritRequest.log.error("Couldn't find javax.naming.JsonData dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir dir", e); throw new java.lang.RuntimeException(e); } return storageDir.toString(); }
@java.lang.Override public com.google.gerrit.extensions.api.config.ConsistencyCheckInfo apply(com.google.gerrit.server.config.ConfigResource resource, com.google.gerrit.extensions.api.config.ConsistencyCheckInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { permissionBackend.user(user).check(GlobalPermission.ACCESS_DATABASE); if ((input == null) || (((input.checkAccounts) == null) && ((input.checkAccounts) == null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("accounts required"); } com.google.gerrit.extensions.api.config.ConsistencyCheckInfo consistencyCheckInfo = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(); if ((input.checkAccounts)!= null) { consistencyCheckAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckAccountsResultInfo(accountsConsistencyChecker.check()); } if ((input.checkAccounts)!= null) { consistencyCheckInfo.checkAccountsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.CheckInfo(externalIdsConsistencyChecker.check()); } if ((input.checkGroups)!= null) { consistencyCheckInfo.checkGroupsResult = new com.google.gerrit.extensions.api.config.ConsistencyCheckInfo(groupsConsistencyChecker.check()); } return consistencyCheckInfo; }
void setAllowEmptyName(boolean allowSaveEmpty) { this.allowSaveEmpty = new com.google.gerrit.reviewdb.client.AccountGroup.Name(allowSaveEmpty); }
private Group.Builder newBundle() { java.sql.Timestamp ts = new java.sql.Timestamp(Test.toInstantMillis, new java.sql.Timestamp(1, new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("group-1"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("group-1"), new com.google.gerrit.reviewdb.client.AccountGroupMember.UUID("group-1"), ts); com.google.gerrit.reviewdb.client.AccountGroupMemberAuditMemberAuditMemberAudit memberAudit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(new com.google.gerrit.reviewdb.client.AccountGroup.Id(1000), ts); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit ownerId = new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(member, new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit.Key(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroupById("subgroup"))); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(group).memberAudit(memberAudit).memberAudit(memberAudit).byIdAudit(memberAudit).byIdAudit(toId)); return com.google.gerrit.server.group.GroupBatch(group).merge(memberAudit).byId); }
private static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_8)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.GroupNameKeys.SECTION_NAME, null, com.google.gerrit.server.group.GroupNameKeys.toString(com.google.gerrit.server.group.GroupNameKey.parse(com.google.gerrit.server.group.GroupName.SECTION_NAME), null); return new com.google.gerrit.common.data.GroupReference(java.lang.String.format("%s'", name, com.google.gerrit.server.group.GroupDescription.NAME_PARENT_PARAM)); }
@java.lang.Override public int hashCode() { return java.lang.System.identityHashCode(this); }
private java.util.Optional<java.lang.String> getNewName() { if (groupUpdate.isPresent()) { return group.get().getName().map((n) -> n) -> { return com.google.common.base.Strings.nullToEmpty(n.get().getNameKey().get())); } return com.google.common.base.Optional.of(com.google.gerrit.server.change.String.get().nullToEmpty(groupCreation.getNameKey().get())); }
default boolean accToRealm(@java.lang.SuppressWarnings("unused") java.lang.Iterable<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { return false; }
@java.lang.Override public boolean accToRealm(java.util.Collection<com.google.gerrit.server.account.ExternalId> extIds) { java.lang.String host = externalIds.getRealm(); if (id.isScheme(com.google.gerrit.server.auth.ldap.SCHEME_GERRIT)) { return true; } return false; }
@java.lang.Override public boolean accToRealm(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> externalIds) { java.lang.String host = externalIds.toLowerCase(); if (id.isPresent()) { return com.google.gerrit.server.account.ExternalIds.toAccountExternalIds(externalIds); } return false; }
private boolean processAccount(com.google.gerrit.server.account.AccountState account) { com.google.gerrit.server.account.AccountDeleted.log.debug("Account " + (account.getUserName()))); try { if (((account.getUserName())!= null) && (!(realm.isActive(Account))) { java.util.Collection<com.google.gerrit.server.account.ExternalId> ids = externalIds.byAccount(account.getAccountId()); if (realm.hasActive(account.getAccountId())) { return true; } if (realm.contains(account.getAccountId())) { s.deactivate(account.getAccount().getId()); com.google.gerrit.server.account.AccountDeactivateAccount(true); return true; } } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { com.google.gerrit.server.account.AccountDeletedListener.log.error("Cannot delete account: {}", e); throw new com.google.gerrit.server.account.AccountDeletedHookException("Account {} successfully already been successfully.", e); } } catch (com.google.gerrit.server.account.AccountException e) { com.google.gerrit.server.account.AccountDeleted.log.error("Cannot delete account: {}", e); return false; } return false; }
private static boolean isIndividuallyAndEqualToAudits(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroupByIdAudit> reviewDb, com.google.gerrit.reviewdb.client.AccountGroupByIdAudit> reviewDb, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupByIdAudit> noteDb) { com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBranch.AuditBuilder<java.lang.String, com.google.gerrit.server.group.GroupBundle>> reviewDb = com.google.gerrit.server.group.GroupBranch.toByIdAuditEntriesById(reviewDb); com.google.gerrit.server.group.GroupBatchUpdate.Ordering<java.lang.String, com.google.gerrit.reviewdb.client.AccountBranch.Id, com.google.gerrit.server.group.GroupBatchUpdate> noteDb = com.google.gerrit.server.group.GroupBundle.toByIdAuditByIdAudits(noteDbByIdAudit); return com.google.gerrit.server.group.GroupBatch.isConsistency(reviewDb); }
private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBranch.AuditMemberAudit> toMemberAuditCreation(com.google.common.collect.ImmutableSetMultimap<com.google.gerrit.reviewdb.client.AccountGroup.Id, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> memberAudits) { return memberAudits.stream().flatMap(com.google.gerrit.server.group.GroupBranch.Audit::findAuditCreation, java.util.LinkedHashMap.Entry.class).collect(java.util.stream.Collectors.toSet()); }
private static boolean isMemberAuditsEnum(com.google.common.collect.ImmutableSetMultimap<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDb, com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> reviewDb) { com.google.common.collect.SortedSetMultimap<com.google.gerrit.server.group.GroupMemberAudit, com.google.gerrit.server.group.GroupBranch.AuditKey> reviewDbByMemberAuditsByMemberId = com.google.gerrit.server.group.GroupBranch.toMemberAuditEntry(reviewDb); com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBundle.AuditKey, com.google.gerrit.server.group.GroupBundle.ToMemberAuditEntry> byDbIncludedMemberIdByMemberId(noteDb); return com.google.common.collect.Sets.newLinkedHashSet(reviewdb.toMemberAudit()); }
private static boolean isConsistOrganisedEqualToMember(com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBatchMemberAudit> reviewDbByMemberId, com.google.gerrit.server.group.GroupBatchUpdate.AuditEntry> reviewDbByMemberId) { for (java.lang.String memberId : reviewDbMemberAuditCreation) { java.util.List<com.google.gerrit.server.group.GroupBatchMemberAudit> reviewDb = com.google.common.collect.ImmutableSet.copyOf(reviewdb.accountGroup.auditKey.getMemberIdKey()); java.util.List<com.google.gerrit.server.group.GroupBatchMemberAuditEntry> reviewDb = com.google.common.collect.ImmutableSet.copyOf(reviewdb.google.gerrit.server.group.GroupBatchMemberAuditKey.getMemberIdKey()).collect(java.util.stream.Collectors.toSet()); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> noteDb = noteDb.get(reviewDb); for (com.google.gerrit.server.group.GroupBatchEntry noteDb : noteDbAuditAudit) { java.util.Set<com.google.gerrit.reviewdb.client.AccountBatch.Id> reviewerAudit = new java.util.HashSet<>(); while (reviewDbAdd.size()) { com.google.gerrit.server.group.GroupBatchEntry<com.google.gerrit.server.group.GroupBatchBatchBatchUpdate> entry = reviewDb.get(reviewDb); if (!(reviewDb.isAction())) { com.google.gerrit.server.group.GroupBatchEntry reviewDb = reviewDb.get(reviewDb); if (!(reviewDb.entrySet())) { throw new com.google.gerrit.server.group.GroupBatchException(reviewdb, reviewerDb); } } if (!(reviewDb.isEmpty())) { return false; } } if (reviewDb.isEmpty()) { return false; } return true; }
private static com.google.common.collect.SortedSetMultimap<java.lang.String, com.google.gerrit.server.group.GroupBranch.AuditBuilder> toByIdAuditEntriesById(com.google.gerrit.reviewdb.client.AccountGroupByIdAuditAuditAuditAuditAudit byIdAudits) { return byIds.stream().flatMap(com.google.gerrit.server.group.GroupBranch.OBJson::toAuditValues).collect(java.util.stream.Collectors.toSet(), java.util.Collectors.toSet()); }
public java.lang.String getName() { if ((fullName)!= null) { return fullName; } if ((preferredEmail)!= null) { return fullName; } return "PreferredEmail; }
private static org.eclipse.jgit.lib.PersonIdent ident(com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String anonymousCowardName, com.google.gerrit.server.CurrentUser u, java.util.Date when) { com.google.gerrit.server.notedb.AbstractChangeUpdate.checkUserType(u); if (u instanceof com.google.gerrit.server.IdentifiedUser) { return noteUtil.newIdent(u.asIdentifiedUser().getAccount(), when, serverIdent); } else if (u instanceof com.google.gerrit.server.IdentifiedUser) { return serverIdent; } throw new java.lang.IllegalStateException(); }
public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check(org.eclipse.jgit.lib.Repository repo, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroupInfo> byUUID) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (!(groupsMigration.writeToNoteDb())) { return new java.util.ArrayList<>(); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = repo.getAllRefs(); java.util.List<com.google.gerrit.reviewdb.client.Account.UUID> problems = new java.util.ArrayList<>(); com.google.common.collect.Maps.create(); readGroups(repo, refs, problems, byUUID); readGroupNames(repo, refs, problems); if (!(problems.isEmpty())) { return problems; } java.util.HashMap<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> nameKeys = com.google.common.collect.HashMap.create(); try { checkNotNull(repo, refs, nameKey); if (!(problems.isEmpty())) { return problems; } return problems; }
public java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> check() throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroupInfo> problems = new java.util.HashMap<>(); java.util.List<com.google.gerrit.extensions.client.info.ConsistencyProblemInfo> problems = com.google.gerrit.server.git.validators.ConsistencyChecker.check(repo, groups); if (!(problems.isEmpty())) { return problems.addAll(checkGroup(g, groups)); } for (com.google.gerrit.server.group.InternalGroupInfo group : groups.values()) { problems.addAll(checkGroup(g, groups)); } return problems; } }
@com.google.gerrit.common.Nullable public com.google.gerrit.server.group.GroupsCheckResult check(org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { com.google.gerrit.server.group.GitJson.Result r = doCheckNote(repo); if (!(r.problemsToGroupMap.isEmpty())) { r.uuidToGroupMap = null; } return r; }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (raw) { rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.Configuration.SC_OK); } else { try { rsp.sendError(com.ericsson.gerrit.plugins.highavailability.Configuration.SC_INTERNAL_SERVER_ERROR); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.Configuration.log.error("Failed to send error", e); } } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { this.draft = true; }
@org.junit.Before public void setUp() throws java.lang.Exception { when(currentUserMockMockMockMockMockMock); when(currentUserMock.getCapabilities()).thenReturn(capabilityControlMock); when(capUserMock.canAdministrateServer()).thenReturn(true); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.Configuration rsp) { if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_FORBIDDEN); return; } try { setUnavailable(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.cnucene.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.rest.Resource.log.error("Failed to set invalid send invalid", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_INTERNAL_ERROR); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.Configuration rsp) { if (!(currentUserProvider.get().getCapabilities().canAdministrateServer())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.cnucene.SC_NO_FORBIDDEN); return; } try { setHealth(rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.cnucene.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.rest.Resource.log.error("Failed to set successfully", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_INTERNAL_ERROR); } }
private void sendError(com.ericsson.gerrit.plugins.highavailability.Configuration rsp, int statusCode) { try { rsp.sendError(statusCode); } catch (java.io.IOException e) { rsp.sendError(HttpServlet.SC_INTERNAL_SERVER_ERROR); com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.rest.SC_INTERNAL_ERROR); com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.rest.SC_INTERNAL_ERROR; com.ericsson.gerrit.plugins.highavailability.highavailability.forwarder.rest.ResourceServlet.log.error("Failed to send error", e); } }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpServletResponse rsp) { if (uncheckedFile.exists()) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.SC_SERVisibleCache.SUCCESS_UNAVAILABLE); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) throws java.io.IOException { com.google.gerrit.server.IdentifiedUser rsp = new com.google.gerrit.server.IdentifiedUserInfo(); rp.setUserName(s); if ((s.getAccountId())!= null) { rsp.setMessages(false); } else { rp.setMessages(false); } }
private static int getInt(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, int defaultValue) { try { return cfg.getInt(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error("Could not found for key: {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug(("Failed to retrieve abstract value: " + (e.getMessage())), e); return defaultValue; } }
private static boolean getBoolean(org.eclipse.jgit.lib.Config cfg, java.lang.String section, java.lang.String name, boolean defaultValue) { try { return cfg.getBoolean(section, name, defaultValue); } catch (java.lang.IllegalArgumentException e) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error("Configuration value for {}: {}", name, defaultValue); com.ericsson.gerrit.plugins.highavailability.Configuration.log.error("Failed to retrieve boolean value: " + (e.getMessage())), e); return defaultValue; } }
private void evictCache(com.google.common.cache.Cache<?,?> cache, java.lang.String cacheName, java.lang.Object key) { if (Constants.PROJECT_LIST.equals(cacheName)) { cache.invalidateAll(); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug("{} cache {} cache", cacheName); } else { cache.invalidate(key); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.logger.debug("{}}} from {}", cacheName); } }
public java.lang.String[] getIssueIds(java.lang.String haystack) { java.util.regex.Pattern pattern = itsConfig.getIssuePattern(); if (pattern == null) return new java.lang.String[]{ }; com.googlesource.gerrit.plugins.its.base.ItsExtractor.log.debug("Comment '{}' }, haystack, haystack, haystack), pattern.pattern(("{ '{}'"), pattern.pattern(matcher); java.util.Set<java.lang.String> issues = pattern.matcher(haystack); int groupIdx = matcher.getIssuePattern(); while (matcher.find()) { java.lang.String issueId = matcher.group(groupIdx); if (!(com.google.common.base.Strings.isNullOrEmpty(issueId))) { issues.add(issueId); } } return issues.toArray(new java.lang.String[issues.size()]); }
public boolean isEnabled(com.google.gerrit.reviewdb.client.Project.NameKey projectName, java.lang.String refName) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); if (projectState == null) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig.log.error("Checking to check if (pluginConfig.get())) { com.googlesource.gerrit.plugins.its.base.its.its.itsConfig.log.error("Cannot check if plugin {}", pluginName, projectName, projectName); return false; } return (!("false".equals(refName, projectState)) && (isEnum(pluginCfgFactory.getFromInheritance(projectState, pluginName))) && (isEnabledForBranch(false)); } return (!("false".equals(projectState, refName, refName))) && (isEnabledForBranch(projectState, refName)); }
@org.junit.Test public void rebuild() throws java.lang.Exception { assume().that(groupsMigration.writeToNoteDb()).isTrue(); assume().that(groupsMigration.readFromNoteDb()).isFalse(); com.google.gerrit.extensions.common.GroupInfo gApi = gApi.groups().create(name("group")).get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g.id); java.lang.String refName = com.google.gerrit.reviewdb.client.AccountGroup.UUID(g.id); org.eclipse.jgit.lib.ObjectId oldId; try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { oldBundle = repo.openRepository(refName).getObjectId(); oldBranch = repo.exactRef(refName); newBranch = bundleFactory.create(refName); } assertThat(adminRestSession.postOK((("/groups/" + uuid) + "/rebuild"), "rebuild"), new org.eclipse.jgit.lib.Repository<com.google.gerrit.reviewdb.client.Repository>() { @java.lang.Override public void run() throws java.lang.Exception { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers); assertThat(ref).isNotNull(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); assertThat(ref).isNotEqualTo(oldId); com.google.gerrit.server.group.GroupBundle newBundle = bundleFactory.fromNoteDb(repo, uuid); assertThat(ref).isNotEqualTo(oldBranch.memberAudit); assertThat(newBranch.memberAudit.memberAudit()).isEqualTo(oldBranch.memberAudit()); assertThat(newBranch.memberAudit()).isEqualTo(
private java.lang.String getCommentEventChangeEvent(java.lang.String action, java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = ""; java.lang.String changeNumber = com.google.common.base.Strings.nullToEmpty(map.get(("change "change "change " + action)); if (!(changeNumber.isEmpty())) { changeNumber += " "Change-Id: " + action; } java.lang.String subject = formatPerson(prefix, map); if (!(submitter.isEmpty())) { ret += "By "\n"; } java.lang.String subject = com.google.common.base.Strings.nullToEmpty(prefix, map); if (!(subject.isEmpty())) { ret += "\n\n"; } java.lang.String subject = com.google.common.base.Strings.nullToEmpty(map.get(prefix))); if (!(subject.isEmpty())) { return "\n\n\n\n"; } java.lang.String url = com.google.common.base.Strings.nullToEmpty(map.get(url)); if (!(url.isEmpty())) { url += "\n\n\n"; } return url; }
private java.lang.String formatPerson(java.lang.String prefix, java.util.Map<java.lang.String, java.lang.String> map) { java.lang.String ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Name")); if (ret.isEmpty()) { ret = com.google.common.base.Strings.nullToEmpty(map.get((prefix + "Username")); } return ret; }
static java.lang.String getOwnersFileName(com.google.gerrit.server.project.ProjectState projectState, com.googlesource.gerrit.plugins.query.change.ChangeData c) { if (((com.googlesource.gerrit.plugins.findowners.Config.config)!= null) && ((projectState.getFromProjectConfig().getString(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME))) && (projectState.trim().equals(""))))) { java.lang.String name = com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(project, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME, com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME); if (name.trim().equals("")) { java.lang.String name = (((((c.project()) + " has wrong ") + (com.googlesource.gerrit.plugins.findowners.Config.OWNERS_FILE_NAME)) + " for ") + name)); return com.googlesource.gerrit.plugins.findowners.Config.OWNERS; } return name; } return name; }
private boolean shouldReplicate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { projectState = projectCache.checkedGet(project); } catch (java.io.IOException e) { return false; } return false; }
public java.util.regex.Pattern getIssuePattern() { java.util.Optional<java.lang.String> match = com.googlesource.gerrit.plugins.its.base.base.its.FetchInfo.from(getCommentLinkName())).filter(new com.google.base.base.Function<com.google.gerrit.extensions.api.projects.CommentLinkInfo>() { @java.lang.Override public boolean apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return ((input.match)!= null) && (!(input.match.trim().isEmpty())); } }).transform(new com.google.gerrit.extensions.api.projects.CommentLinkInfo, java.lang.String.value() { @java.lang.Override public java.lang.String apply(com.google.gerrit.extensions.api.projects.CommentLinkInfo input) { return input.match; }).last(); }).last(); java.lang.String def = gerritConfig.getString("commentlink", getCommentLinkName(), "match"); return gritConfig.getString(); }
public java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> extractFrom(PatchSetAttribute patchSetAttribute) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties = com.google.common.collect.Sets.newHashSet(); properties.add(propertyFactory.create("revision", patchSetAttribute.revision)); properties.add(propertyFactory.create("patch-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("patch-number", java.lang.String.valueOf(patchSetAttribute.number))); properties.add(propertyFactory.create("ref", patchSetAttribute.ref)); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString())); properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.createdOn.toString())); properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString())); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(propertyFactory.create("deletions", java.lang.Integer.toString(patchSetAttribute.sizeInsertions))); properties.add(extractFrom(patchSetAttribute.uploader, "author")); properties.addAll(extractFrom(patchSetAttribute.author, "author")); }
public static com.google.common.collect.ImmutableList<java.lang.String, com.google.gerrit.server.group.GroupBundle> compare(com.google.gerrit.server.group.GroupBundle reviewDb, com.google.gerrit.server.group.GroupBundle bundleDbBundle, boolean isRun) { return com.google.gerrit.server.group.GroupBundle.compareTo(reviewDbBundle, noteDbBundle, true); }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException { if (canRemoveReviewer(notes.getChange(), currentUser, val)) { return; } permissionBackend.user(dbProvider).database(dbProvider).check(reviewerProvider.get(), notes)); }
public void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException { checkRemoveReviewer(notes, currentUser, null); }
@org.junit.Test public void testGetHealthCheckEnabled() throws java.lang.Exception { when(configMock.getBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_THREAD_CHECK, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_HE_HE_CHECK)).thenReturn(false); initializeConfiguration(); assertThat(configuration.mysql().enabled()).isFalse(); }
@java.lang.Override public org.junit.runners.model.Statement apply(org.junit.runners.model.Statement base, org.junit.runner.Description description) { return new org.junit.runners.model.Statement() { @java.lang.Override public void evaluate() throws java.lang.Throwable { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest(description)) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); com.google.gerrit.acceptance.AbstractDaemon.mergeConfig ci = resetProjects(allProjects, allUsers); try { base.evaluate(); } finally { base.evaluate(); } } }; }
protected com.google.gerrit.acceptance.ProjectConfigResolver resetProjects(com.google.gerrit.reviewdb.client.Project... projects) throws java.lang.Exception { return new com.google.gerrit.acceptance.ProjectConfig(repoManager, metaDataUpdateFactory, projectCache, projectCache); }
@java.lang.Override public void evaluate() throws java.lang.ThrowableException { if ((com.google.gerrit.acceptance.AbstractDaemonTest.firstTest) == null) { com.google.gerrit.acceptance.AbstractDaemonTest.firstTest = description; } beforeTest(description); com.google.gerrit.acceptance.AbstractProjectConfig resetProjects = resetProjects(allProjects, allUsers); try { base.evaluate(); } finally { base.evaluate(); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPS); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository)) { org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, notes); com.google.common.collect.ImmutableSet.Builder<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> uuidMap = new java.util.HashSet<>(); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, java.lang.String> uuidMap = new java.util.HashMap<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.server.group.GroupReference groupReference = com.google.gerrit.server.group.GroupReference.getGroupReference(reader, noteMap.getData()); groupMap.add(groupReference, uuid); } return groupReferences; }
public static com.google.gerrit.server.group.GroupConfig createForNewGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.server.group.InternalGroupCreation groupCreation) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupCreation.getGroupUUID(), repository); groupConfig.load(repository); return groupConfig; }
public static com.google.gerrit.server.group.GroupConfig loadForGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupUUID, repository); groupConfig.load(repository); return groupConfig; }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> getLoadedGroup() { checkLoaded(); loadGroupId(t) { loadGroup(); return loadConsistency; }
public static com.google.gerrit.server.group.GroupConfig loadForGroup(org.eclipse.jgit.lib.Repository repository, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, org.eclipse.jgit.lib.ObjectId commitId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = new com.google.gerrit.server.group.GroupConfig(groupUUID, repository); groupConfig.load(repository, commitId); return groupConfig; }
private java.util.Optional<com.google.gerrit.common.data.GroupDescription.Internal> loadGroup(com.google.gerrit.common.data.GroupReference groupReference) { java.util.Optional<com.google.gerrit.common.data.GroupDescription> group = groupCache.get(groupReference.getUUID()).map((group.isPresent()? " : group refs")); if (!(group.isPresent())) { com.google.gerrit.server.group.GroupsCheckResultChecker.log.warn("Cannot load from group name for group ref %s", notes.getGroupDescription(), notes); } return group; }
private java.util.List<com.google.gerrit.extensions.common.GroupInfo> suggestGroups() throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException { if (conflictingChanges.isEmpty()) { throw new com.google.gerrit.extensions.restapi.BadRequestException("project not have no longer than one or more than " + (limitToProject))); } java.util.List<com.google.gerrit.common.data.GroupReference> groupRefs = com.google.common.collect.Lists.newArrayList(groupBackend.suggest(suggest(suggest, projects.stream().findFirst()), ((limit) <= 10)? 10 : java.lang.Math.min(limit, 10)))); java.util.List<com.google.gerrit.extensions.common.GroupInfo> groupInfos = com.google.common.collect.Lists.newArrayListWithCapacity(groupBackend.size()); for (com.google.gerrit.common.data.GroupReference ref : groupRefs) { com.google.gerrit.common.data.GroupDescription.Basic descs = groupBackend.get(ref.getUUID()); if (desc!= null) { groupInfos.add(json.addOptions(desc)); } else if ((group) instanceof com.google.gerrit.server.account.InternalGroupBackend.log.warn(java.lang.String.format("Failed to load %s (%s) from group %s (%s) from group %s), results.getUUID(), ref.getUUID())); } return groupInfos; }
int findApproval(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.server.account.Emails.Emails.isExceedateFromOwner(changeData) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (com.googlesource.gerrit.plugins.findowners.Checker.isExpectedFromOwner(changeData, accountCache)) { return 0; } com.googlesource.gerrit.plugins.findowners.Config db = com.googlesource.gerrit.plugins.findowners.Cache.getInstance().get(projectState, accountCache, email, changeData); if ((db.get()) <= 0) { return 0; } if ((minVote) <= 0) { return 0; } com.googlesource.gerrit.plugins.findowners.Checker.log.warn(("Account " + (db.get().getKey()))); return findApproval(accountCache, db); }
static int getMinOwnerVote(com.google.gerrit.server.project.ProjectState projectState) throws com.google.gwtorm.server.OrmException { return ((com.googlesource.gerrit.plugins.findowners.Config.config) == null? com.googlesource.gerrit.plugins.findowners.Config.configureOwnerVoteVote((projectState) == null? com.googlesource.gerrit.plugins.findowners.Config.config.getFromProjectConfigWithInheritance(projectState, com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_NAME).getInt(com.googlesource.gerrit.plugins.findowners.Config.PLUGIN_OWNER).getInt(com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER, com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER).getInt(com.googlesource.gerrit.plugins.findowners.Config.MIN_OWNER, com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteVoteVoteGroup, com.googlesource.gerrit.plugins.findowners.Config.minOwnerVoteVote) { }
public static com.google.gerrit.extensions.api.projects.TagInfo createTagInfo(com.google.gerrit.server.permissions.PermissionBackend.ForRef perm, org.eclipse.jgit.lib.Ref ref, org.eclipse.jgit.revwalk.RevWalk rw, com.google.gerrit.server.project.ProjectControl refName, com.google.gerrit.server.CurrentWebLinks.filter.Create(ref.getObjectId()); boolean canDelete = perm.testOrFalse(ref.getObjectId()); boolean canDelete = perm.testOrFalse(RefPermission.DELETE); java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> webLinks = links.getTagLinks(projectName.get(), ref.getName()); if (object instanceof org.eclipse.jgit.revwalk.RevTag) { org.eclipse.jgit.revwalk.RevTag tag = ((org.eclipse.jgit.revwalk.RevTag) (object)); org.eclipse.jgit.lib.PersonIdent tagger = tag.getTaggerIdent(); return new com.google.gerrit.extensions.api.projects.TagInfo(tag.getName(), tag.getObject().trim(), tag.getFullMessage(), tag.getFullMessage().trim(), tag.getFullMessage(), tag.getFullMessage().trim(), (tagger!= null? com.google.gerrit.server.IdentifiedUser) : null), canDelete, (object!= null? new java.sql.Timestamp(((org.eclipse.jgit.revwalk.RevCommit) (object)).getCommitterIdent().getTime()) : null), ((com.google.gerrit.server.IdentifiedUser) (object)), java.sql.Timestamp (((object) (object)).getCommitterIdent().getTime())!= null? null : null; return new com.google.gerrit.server.project.NoSshCommit(tag).getCommitterIdent().getWhen().getTime())).getTime(); }
@org.junit.Test public void lightweightTag() throws java.lang.Exception { grantTagPermissions(); com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo); com.google.gerrit.acceptance.PushOneCommit.Result r = push.to("refs/heads/master"); r.assertOkStatus(); com.google.gerrit.extensions.api.projects.TagInput input = new com.google.gerrit.extensions.api.projects.TagInput(); input.ref = r.getCommit().getName(); com.google.gerrit.extensions.api.projects.TagInfo result = tag(input.ref).create(input).get(); assertThat(result.ref).isEqualTo(((R_TAGS) + (input.ref))); assertThat(result.revision).isEqualTo(((R_TAGS) + (input.ref))); assertThat(result.revision).isEqualTo(input.revision); input.ref = "refs/tags/tags/v2.0"; result = tag(input.revision); result.ref = tag(input.ref).create(input).get(); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.revision).isEqualTo(input.revision); assertThat(result.created).isEqualTo(input.revision); eventRecorder.assertRefUpdatedEvents(project, result.get(), result.revision); }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.loaded = java.util.Optional.of(account); this.registeredOn = account.getRegistered(); }
@com.google.gerrit.common.Nullable public java.util.Optional<com.google.gerrit.reviewdb.client.Account> getLoadedAccount() { checkLoaded(); return loadedAccount; }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision)!= null) { rw.reset(); rw.reset(); rw.sort(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); loadAccount = java.util.Optional.of(cfg.getWhen().getCommitTime()) { loadAccount = true; } isLoaded = true; }
private java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.notedb.ChangeNotes> openChangesByBranch(com.google.gerrit.reviewdb.client.Branch.NameKey branch) throws com.google.gwtorm.server.OrmException { java.util.Map<com.google.gerrit.reviewdb.client.Change.Id, com.google.gerrit.server.query.change.ChangeData> r = new java.util.HashMap<>(); for (com.google.gerrit.server.query.change.ChangeData cd : queryProvider.get().byBranchOpen(branch)) { r.put(cd.change().getId(), cd.notes()); } return r; }
@org.junit.Test public void testErrorDuringTransitionToHeken() throws java.io.IOException { java.nio.file.Files.createFile(tempFolder.newFolder("unchecked")); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doPost(null, responseMock); verify(responseMock); }
@java.lang.Override protected void doGet(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { if (!(raw/${Unavailable())) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.SC_SERVisibleFile.SC_UNAVAIL); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.Configuration.SC_NO_CONTENT); }
@org.junit.Test public void testErrorDuringTransitionToUnprocess() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock); }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setHealth(); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.Configuration.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HealthServlet.log.error("Error to set not set private", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_INTERNAL_ERROR); } }
@org.junit.Before public void setUp() throws java.lang.Exception { servlet = new com.ericsson.gerrit.plugins.highavailability.HealthServlet(tempFolder.getRoot().toPath()); }
@java.lang.Override protected void doDelete(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT; rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HealthServlet.log.error("Error to set invalid", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_INTERNAL_ERROR); } }
@java.lang.Override public com.google.gerrit.extensions.common.RawInput pureRevert(@com.google.gerrit.common.Nullable java.lang.String claimed) throws com.google.gerrit.extensions.restapi.RestApiException { try { return calculateRaw("revert", change.getNotes(), claimedOriginal); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot compute revert", e); } }
@com.google.gerrit.common.Nullable public java.lang.Boolean isTrue() throws com.google.gwtorm.server.OrmException { if ((change().getRevertOf()) == null) { return null; } try { return pureRevert.getRaw(notesMirty).isTrue(); } catch (java.io.IOException | com.google.gerrit.extensions.restapi.BadRequestException e) { throw new com.google.gwtorm.server.OrmException("Cannot compute revert", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.RawInfo apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { return com.google.gerrit.server.change.PostReviewInput.getRaw(rsrc.getNotes(), rsrc.getNotes()); }
private void setUp(java.lang.Object target) throws java.lang.Exception { injector = com.google.inject.Guice.createInjector(new com.google.gerrit.server.InMemoryModule()); injector.injectMembers(this); lifecycle.add(injector); lifecycle = new com.google.gerrit.reviewdb.server.ReviewDb(); lifecycle.add(inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); setApiUser(accountManager); setApiUser(accountManager.authenticate(accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId()); in.injectMembers(target); }
@org.junit.Test public void testErrorDuringTransitionToUnprocessable() throws java.io.IOException { tempFolder.delete(); javax.servlet.http.HttpServletResponse responseMock = mock(javax.servlet.http.HttpServletResponse.class); servlet.doDelete(null, responseMock); verify(responseMock); verify(responseMock); }
private java.lang.String getProtocol(org.eclipse.jgit.lib.Config cfg, SitePaths site) { java.lang.String sitePath = cfg.getString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PROCOL_KEY); if (location == null) { return null; } java.nio.file.Path p = java.nio.file.Paths.get(location); if (p.isAbsolute()) { return site.etc_dir.resolve(site).toString(); } return site.etc_dir.resolve(site).toString(); }
public java.lang.String getMessage() { return protocolFromIndex; }
private org.junit.Json getChannel() { java.lang.String protocol = ""; try { protocol = javax.junit.JsonHelper.protocol() { return protocolStackTrace(); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.j.junit.JSchPeerPeerInfoProvider.log.error("Unable to create a new channel with new channel", e); return null; } } }
public void connect() { try { channel = getChannel(); java.util.Optional<com.ericsson.gerrit.plugins.highavailability.forwarder.Inet.InetAddress> address = findAddress(); if (address.isPresent()) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JsonPeerInfoProvider.log.debug(("Throwable to {}: " + (channel.getProtocol()))); } else { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JGroupsClientProvider.log.debug("Debug not found: {} address: {}", address.get()); } channel.setReceivePack(this); channel.setReceiveOwners(this); channel.setDiscardOwners(this); channel.setDiscardOwners(true); channel.setListeners(this); channel.setBarn(jroupsConfig.clientsConfig(this); channel.connectAllMessages(true); } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JGroupsPeerProvider.log.error("Cannot create {} failed", failed, failedCaches.getName(), e); } }
protected void setUseSignedOffBy(com.google.gerrit.extensions.client.InheritableBoolean value) throws java.lang.Exception { try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(project)) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); config.getProject().setBoolean(Boolean.SIGNED_OFF, value); config.commit(md); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(state.isUseSignedOffBy())) { return java.util.Collections.emptyList(); } org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; org.eclipse.jgit.lib.PersonIdent committer = commit.getCommitterIdent(); org.eclipse.jgit.lib.PersonIdent committer = commit.getAuthorIdent(); boolean sboMe = false; for (org.eclipse.jgit.revwalk.FooterLine footer : commit.getFooterLines()) { if (footer.matches(FooterKey.SIGNED_OFF_BY)) { java.lang.String e = footer.getEmailAddress(); if (e!= null) { sboAuthor |= author.getEmailAddress().equals(e); sboMe |= committer |= committer.hasEmailAddress(e); sboMe |= user.hasEmailAddress(e); } } } if (!(!sboAuthor)) { try { perm.check(RefPermission.FORGE_COMMIT_COMMITTER); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.server.git.validators.CommitValidationException("Cannot check FORGE", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.validators.CommitValidationException denied = "fatal: check FORGE", e); throw new com.google.gerrit.server.git.validators.CommitValidationException("Cannot check FORGE_COMMITTER", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.git.validators.CommitValidationException("Cannot check FOR
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canDelete(); case FORCE_HEADER : return canDelete(); case FORCE_HEADER : return canDelete(); case FORGE_HEADER : return canForgeCommitter(); case FORGE_AUTHOR : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeAuthor(); case FORGE_SUBMIT : return canForgeCommitter(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerges(); case CREATE_CHANGE : return canForgeCommitBuilder().canPerform(RefNames.REFS_CONFIG).canUploadMerge(); case WRITE_CONFIG : return isOwner(); case READ_CONFIG : return ((((canForgeCommitter()) && (canForgeCommitter())) && (canUploadMerge())) && (canUploadMerge())) && (canUploadMerges())) && (!(projectControl.getProjectState().isOwner()))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
@org.junit.Test public void createProjectWithProperties() throws java.lang.Exception { java.lang.String newProjectName = name("newProject"); com.google.gerrit.extensions.api.projects.ProjectInput in = newProjectName; in.description = "Test description"; in.submitType = com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.SubmitType.CHERRY_PICK; in.useContributorAgreements = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.useContentMerge = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.requireChangeId = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; in.requireChangeId = com.google.gerrit.extensions.client.InheritableBoolean.TRUE; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects().create(in).get(); assertThat(p.name).isEqualTo(newProjectName); com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo(project, p); assertThat(p.name).isEqualTo(in.description); assertThat(project.getSubmitType()).isEqualTo(in.description); assertThat(project.getSubmitType()).isEqualTo(in.submitType); assertThat(project.getBoolean(Boolean.useContributorAgreements).isEqualTo(in.useContributorAgreements); assertThat(project.getBoolean(Boolean.requireChangeID_SIGNED_SIGNED_OFF_OFF_OFF, in.useSignedOffBy)); assertThat(project.getBoolean(InheritableBoolean.requireChangeID_SIGNED_SignedOffBy()).isEqualTo(in.useSignedOffBy); assertThat(project.getBoolean(InheritableBoolean.requireChangeForMergeProjectConfig(Boolean.requireChangeID_CONFIG_CONFIG_S)); }
private java.util.Map<java.lang.String, com.google.gerrit.server.schema.Schema_105.AccountSet<com.google.gerrit.reviewdb.server.ReviewDb> getFields(com.google.gerrit.reviewdb.server.ReviewDb db) throws java.sql.SQLException { com.google.gwtorm.jdbc.JdbcSchema schema = ((com.google.gwtorm.jdbc.JdbcSchema) (db)); java.sql.Connection connection = schema.getConnection().listColumns(connection, com.google.gerrit.server.schema.Schema_105.TABLE); return java.util.Collections.emptySet().stream().filter(( e) -> columns.contains(e.getKey())).filter(( e) -> columns.contains(e.getKey())).collect(java.util.stream.Collectors.toSet()); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account> scanAccounts(com.google.gerrit.reviewdb.server.ReviewDb db, org.eclipse.jgit.lib.ProgressMonitor pm) throws java.sql.SQLException { java.util.Set<java.lang.String> fields = getFields(db); if (fields.isEmpty()) { return java.util.Collections.emptySet(); } java.lang.String query = fields.stream().map((f) -> f.getKey()).collect(java.util.stream.Collectors.joining(db)); try (java.sql.Statement stmt = newStatement(db);java.sql.ResultSet rs = stmt.executeQuery(db);java.sql.ResultSet rs = stmt.executeQuery(db);java.sql.ResultSet rs = new java.sql.ResultSet<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)), rs.getTimestamp(2)); rs.getValue().set(a.getTime()); } for (java.sql.Timestamp field : fields) { if (rs.next()) { com.google.gerrit.reviewdb.client.Account a = new com.google.gerrit.reviewdb.client.Account.Id(rs.getInt(1)), rs.getValue()); rs.getValue().set(a.getValue()); } s.add(a); pm.update(1); } return s; }
private boolean isRest(javax.servlet.ServletRequest req) { return resturi.matches(); }
public boolean inGracePermission() { if ((granted) < 0) { return 0; } return ((grants.readGranted()) > 0) { }
private final com.googlesource.gerrit.plugins.quota.Module.Holder createWithQuota(com.google.gerrit.reviewdb.client.Account.Id key) throws java.lang.Exception { return createWithSpecyCast("maysearator", limit); }
@java.lang.Override protected void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.httpd.AllRequestFilter.class).to(com.googlesource.gerrit.plugins.quota.AllRequestFilter.class); cache(com.googlesource.gerrit.plugins.quota.HttpModule.CACHE_NAME_ACCOUNT_ACCOUNT_ACCOUNT_ACCOUNT, Account.Id.class, Account.Id.class).loader(com.googlesource.gerrit.plugins.quota.HttpModule.class); cache(com.googlesource.gerrit.plugins.quota.CACHE_NAME_RENDENCY_REMOTE_RENDINGLETON, java.lang.String.class, java.lang.String.class).loader(com.googlesource.gerrit.plugins.quota.HttpModule.RIT_RESOURCESSAGE_RESOURCES_RESOURCES_REGISTERED_REGEX_REGEX_REGEX_REGEX).to(RITORY_MSGitHubModule()); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse res, final javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if (isRest(req)) { com.googlesource.gerrit.plugins.quota.Module.Holder holder = null; com.google.gerrit.server.CurrentUser userId = null; com.google.gerrit.reviewdb.client.Account.Id accountId = null; if (u.isIdentifiedUser()) { accountId = u.asIdentifiedUser().getAccountId(); try { accountId = u.asIdentifiedUser().getAccountId(); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.lang.String.format("Cannot get account %s for account %s", accountId); com.googlesource.gerrit.plugins.quota.RestApiServlet.log.warn(msg, e); } } try { try { rateHolder = queuesPerRequest.get(req.getRemoteHost()); } catch (java.util.concurrent.ExecutionException e) { java.lang.String msg = java.util.concurrent.ExecutionException.get(msg.getRemoteHost()); com.googlesource.gerrit.plugins.quota.RestApiServletRequestScopePropagator.log.warn(msg, e); } } if (((!(wantGrantedPerformPermissionPermission())) && (!(rateControl.isGranted()))) { java.lang.String msg = java.lang.String.format("Cannot get rate of %s", req.get().getAccount()); com.googlesource.gerrit.plugins.quota.RestApiServlet.log.warn(msgExpectedSize, ((com.googlesource.gerrit.plugins.quota.RestApiServlet.get().get().getRate()) * (com.googlesource.gerrit.plugins.quota.RestApiServlet.SECONDS_HOST_HOST_PERMITTED)), state.get().rate()); } }
private final com.googlesource.gerrit.plugins.quota.Module.Holder createWithWithUrls(com.google.common.base.Optional<com.googlesource.gerrit.plugins.quota.AccountLimitsConfig.RateLimit> limit) { return com.googlesource.gerrit.plugins.quota.Module.Holder.createWithHasWithBanner(limit); }
@java.lang.Override public final com.googlesource.gerrit.plugins.quota.Module load(Key) throws java.lang.Exception { if (((kind) == (com.googlesource.gerrit.plugins.quota.ModuleCache.Loader.Loader.anonymousCowOM_ONYMOUS)) && (key instanceof java.lang.String)) { return createWithAncestor(com.googlesource.gerrit.plugins.quota.ModuleCache.Loader.Loader.class); } return com.googlesource.gerrit.plugins.quota.Cache.AbstractModule.AbstractCache.Loader.loadWithAnnotation(com.google.gerrit.reviewdb.client.Account.Id.class); }
public <T> void execute(com.google.gerrit.server.update.BatchUpdate.Factory<T> action) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (action) { return execute(action, default); } return execute(action, default); }
@java.lang.Override protected boolean retryOn(java.lang.Throwable t) { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = t.getCause(); } return t instanceof com.google.gerrit.server.git.UpdateFailureException; }
public <T> T call(com.google.gerrit.server.update.BatchUpdate.Factory<T> T> action, com.google.gerrit.server.update.BatchUpdate.Factory<T> action, com.google.gerrit.server.update.BatchUpdate.Options opts) throws com.google.gerrit.server.patch.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(migration.disableChangeReviewDb())) { return doExecute(updateFactory, action, com.google.gerrit.server.change.RetryRunnable.class); } return doExecute(updateFactory, action, opts); }
private com.google.gerrit.server.account.ExternalIdsUpdate.RefUpdate updateNoteMap(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.ExternalIdUpdate.ExternalIdUpdateUpdatesUpdaterUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return retryUpdater.execute(uperter, repo); }
public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> recursiveChildProjects(com.google.gerrit.reviewdb.client.Project.NameKey parent) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project> projects = readAllProjects(); com.google.common.collect.Multimap<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.reviewdb.client.Project.NameKey> children = parentToChildren(projects); com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(user); java.util.List<com.google.gerrit.extensions.common.ProjectInfo> results = new java.util.ArrayList<>(); depthFirstFormat(results, children, children, children, parent); return results; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return childProjects.recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, changeDataFactory, notesFactory, changeDataFactory, changeDataFactory, accountResolver, groupBackend, allProjectsName, allProjectsName, allUsersName, patchListCache, listMembers, starredChangesUtil, accountCache, allowsDrafts, allowsDrafts, notesMigration); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> parentproject(java.lang.String name) { return new com.google.gerrit.server.query.change.ParentProjectPredicate(args.projectCache, args.child, args.self, name); }
public boolean isReachableFrom(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { refs = refFilter.create(state, repo).filter(refs, true); return com.google.gerrit.server.change.IncludedInResolver.includedInResolver.includedInAny(repo, rw, commit, refs.values()); } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), state.getNameKey()), e); return false; } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectVisibility(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitCollection.log.error(((("Cannot find change for commit " + (commit.name())) + " in " in ") + project), e); return true; } return possible.isReachableFrom(state, repo, commit, repo, commit, repo.getAllRefs()); }
boolean isReachableFromHeadsOrTags(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { try { org.eclipse.jgit.lib.Ref refdb = repo.getRefDatabase(); java.util.Collection<org.eclipse.jgit.lib.Ref> heads = refdb.getRefs(Constants.R_HEADS).values(); java.util.Collection<org.eclipse.jgit.lib.Ref> tags = refs.getRefs(Constants.R_TAGS).values(); java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs = com.google.common.collect.Iterables.concat(heads, tags)) { for (org.eclipse.jgit.lib.Ref r : com.google.common.collect.Iterables.concat(heads, tags)) { refs.put(r.getName(), r); } return visibleTo(r.getName(), r); } catch (java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(java.lang.String.format("Cannot verify permissions to commit object %s in repository %s in repository %s", commit.name(), getProject().getNameKey()), e); return false; } }
protected static java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.gerrit.server.project.ChildProjectCache childProjectLists, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.gerrit.reviewdb.client.Project.NameKey(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState.getName())); try { com.google.gerrit.server.project.ProjectResource proj = new com.google.gerrit.server.project.ProjectResource(projectState, self.get()); for (com.google.gerrit.extensions.common.ProjectInfo p : childProjectLines.recursive(proj.getNameKey())) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn("Cannot check permissions to expand child projects", e); } return r; }
public void fire(com.google.gerrit.reviewdb.client.Change change, com.google.gerrit.reviewdb.client.Account account, java.sql.Timestamp when, boolean isPrivate) { try { com.google.gerrit.server.extensions.events.PrivateState.Event event = new com.google.gerrit.server.extensions.events.PrivateState.Event(util.singleton(change), util.accountInfo(account), when); for (com.google.gerrit.extensions.events.PrivateStateListener l : listeners) { try { l.onPrivate(event); } catch (java.lang.Exception e) { com.google.gerrit.server.extensions.events.PrivateEventListener.log.error(event, e, e); } } catch (java.lang.Exception e) { com.google.gerrit.server.events.PrivateEventListener.log.error("Couldn't fire event", e); } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { changeState = ctx.getAccount(); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canDeletePrivate())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to unmark private"); } if (!(canDeletePrivate())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to unmark private"); } com.google.gerrit.server.change.SetPrivateOp op = setPrivateOpFactory.create(cmUtil, false, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.server.data.ChangeAttribute asChangeAttribute(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Change change) { com.google.gerrit.server.data.ChangeAttribute a = new com.google.gerrit.server.data.ChangeAttribute(); a.project = change.getProject().get(); a.branch = change.getDest().getShortName(); a.topic = change.getTopic(); a.topic = change.getKey().get(); a.number = change.getId().get(); a.number = change.getId().get(); try { a.commitMessage = change.getSubject(); } catch (java.lang.Exception e) { com.google.gerrit.server.events.EventFactory.log.error(("Failed to get full commit message for change " + (a.number))); } a.url = getChangeUrl(change); a.owner = asAccountAttribute(change.getOwner()); a.status = change.getStatus(); a.status = change.isWorkInProgress(); a.status = (change.isWorkInProgress())? true : null; a.createdOn = (change.isWorkInProgress())? true : null; a.isWorkInProgress = (change.isWorkInProgress())? true : null; a.isWorkInProgress = (change.isWorkInProgress())? true : null; a.isWorkInProgress(); return a; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.SetPrivateOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { if (!(canSetPrivate())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to mark private"); } if (!(canCreatePrivate())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to mark private"); } com.google.gerrit.server.change.SetPrivateOp op = setPrivateOpFactory.create(cmUtil, true, input); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.addOp(rsrc.getId(), op).execute(); } return com.google.gerrit.extensions.restapi.Response.created(""); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternal(resource.getControl()); if (recursive) { return groupMembers.getDirections(group, resource.getControl()); } return groupMembers.getDirectors().get(group, resource.getControl()); }
private void addInternalDetails(com.google.gerrit.extensions.common.GroupInfo info, com.google.gerrit.server.group.GroupDescription.Internal internalGroup, java.util.Collection<com.google.gerrit.server.account.GroupControl> groupControl) throws com.google.gwtorm.server.OrmException { info.description = com.google.common.base.Strings.emptyToNull(internalGroup.getDescription()); info.groupId = internalGroup.getId().get(); com.google.gerrit.reviewdb.client.AccountGroup.UUID ownerGroupUUID = internalGroup.getOwnerGroupUUID(); if (ownerGroupUUID!= null) { info.ownerId = com.google.gerrit.extensions.restapi.Url.encode(ownerGroupUUID.get()); com.google.gerrit.common.data.GroupDescription.Basic o = groupBackend.get(ownerGroupUUID); if (o!= null) { info.owner = o.getName(); } } info.createdOn = internalGroup.getCreatedOn(); if (options.contains(com.google.gerrit.server.group.MEMBERS)) { info.members = groupMembers.get(internalGroup, groupControlFactory.get()); } if (options.contains(com.google.gerrit.server.group.INCLUDED)) { info.includes.addMembers(internalGroup, groupControl.get().getDirections(internalGroup, groupControl(), groupControl.get()); } }
com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments asUser(com.google.gerrit.server.CurrentUser otherUser) { return new com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, com.google.inject.util.Providers.of(otherUser), permissionBackend, changeDataFactory, notesFactory, changeDataFactory, changeDataFactory, accountResolver, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChangesOption, submitDryRun, conflictsCache, index, index, index, index, notesMigration); }
void display(java.io.PrintWriter writer) throws com.google.gwtorm.server.OrmException { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(name)); java.lang.String errorText = "Group"; if (!(group.isPresent())) { writer.write(errorMessage); writer.flush(); return; } java.util.List<com.google.gerrit.extensions.common.AccountInfo> members = groupMembers.getDirectMembers(group.get()); com.google.gerrit.server.ioutil.ColumnFormatter formatter = new com.google.gerrit.server.ioutil.ColumnFormatter(writer, '\t'); formatter.addColumn("id"); formatter.addColumn("Id"); formatter.addColumn("Email"); formatter.addColumn("email"); formatter.addColumn("Email"); formatter.addColumn(java.lang.String.format(member._accountId)); formatter.addColumn(java.lang.Integer.toString(member._accountId)); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member._accountId, "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.name, "n/a/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.name, "n/a")); formatter.addColumn(com.google.common.base.MoreObjects.firstNonNull(member.name), "n/a")); formatter.nextLine(); } formatter.finish(); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.allowedId", values = { "-PROJECT_NUMER", "NUMER_ID", "NUMER_USERS") }) public void restoreChangeIdReturnsBadRequest() throws java.lang.Exception { com.google.gerrit.extensions.api.changes.ChangeApi cApi = gApi.changes().id(project.get(), changeInfo._number); assertThat(cApi.get().changeId).isEqualTo(changeInfo.number); com.google.gerrit.extensions.common.ChangeInfo cApi = gApi.changes().id(changeInfo._number); assertThat(cApi.get().changeId).isEqualTo(changeInfo.changeId); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage((("The change number " + (ci.changeId)) + " is revoked.")); gApi.changes().id(ci.changeId).get(); }
private void checkIdType(com.google.gerrit.server.change.ChangeFinder.ChangeId type, boolean enforceDeprecation, java.lang.String val) throws com.google.gerrit.extensions.restapi.BadRequestException { if (enforceId && (!(allowedId.contains(type)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("The change number %s is revoked", type)); } changeId.increment(type); }
public java.util.List<com.google.gerrit.server.notedb.ChangeNotes> find(java.lang.String id) throws com.google.gwtorm.server.OrmException { try { return find(id, false); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { return com.google.common.collect.ImmutableList.of(); } }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Starred(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); java.util.Set<java.lang.String> labels = starredChangesUtil.getLabels(user.getAccountId(), id); return new com.google.gerrit.server.account.AccountResource.StarredChanges(user, change, labels); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.AccountResource> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.extensions.restapi.UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Not found %s not found", id.get())); } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.StarredChanges.log.error("Cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot resolve change", e); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size())!= 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("No changes found for " + id)); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
@java.lang.Override public AccountResource.StarredChange parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = parent.getUser(); com.google.gerrit.server.change.ChangeResource change = changes.parse(TopLevelResource.INSTANCE, id); if (starredChangesUtil.getLabels(user.getAccountId(), change.getId())) { return new com.google.gerrit.server.account.AccountResource.StarredChange(user, change); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void delete(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMap.add(r, n); for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { removeExtIds.add(o, extId); } }); cacheUpdates.onRemove(o, n); cacheUpdates.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); }
private void addExtId(org.eclipse.jgit.junit.TestRepository<?> testRepo, com.google.gerrit.server.account.externalids.ExternalId... extIds) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.externalids.ExternalId extId = externalIdKeysFactory.create(testRepo.getRepository()); extIdNotes.insert(java.util.Arrays.asList(extIds)); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, null, testRepo.getRepository())) { metaDataUpdate.commit(admin.getIdent()); metaDataUpdate.commit(admin.getIdent()); } catch (com.google.gerrit.server.git.IntegrationException e) { metaDataUpdate.commit(e.getIdent()); } }
@org.junit.Test public void retryOnLockFailure() throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId.Key fooId = ExternalId.Key.create("foo", "foo"); com.google.gerrit.server.account.externalids.ExternalId.Key barId = ExternalId.Key.Key.create("bar", "bar"); final java.util.concurrent.atomic.AtomicBoolean update = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.server.account.externalids.ExternalIdsUpdate update = new com.google.gerrit.server.account.externalids.ExternalIdsUpdate(repoManager, updateCache, allUsersRepoManager, accountCache, allUsers, metricMaker, new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.DisabledExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache(), new com.google.gerrit.server.account.externalids.ExternalIdCache, null, null, r.getWhen()); }
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.externalids.ExternalId get(com.google.gerrit.server.account.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadOnlyEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.ExternalIdsUpdate.load(repo).get(key); } }
private void updateNoteMap(com.google.gerrit.server.account.externalids.ExternalId update) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { retryer.execute(upid); execute(uperter, updateUserRepo, upToNoteDb).load(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.externalids.ExternalId extId = new com.google.gerrit.server.account.externalids.ExternalId(externalIdCache, accountId).setAfterReadRevision(afterReadRev); i.update(extId); } finally { updateNotes.increment(); } }
public void upsert(com.google.gerrit.server.account.externalids.ExternalId extId) throws com.google.gwtorm.server.OrmException { upsert(java.util.Collections.singleton(extId)); }
public java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> all() throws java.io.IOException { checkLoaded(); try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.HashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { byte[] raw = com.google.gerrit.server.account.externalids.ExternalId.readNoteData(rw, note.getData()); try { extIds.add(com.google.gerrit.server.account.externalids.ExternalId.parse(note.getName(), raw, note.getData())); } catch (java.lang.Exception e) { com.google.gerrit.server.account.externalids.ExternalIds.log.error(java.lang.String.format("Ignoring invalid external ID note %s", note.getName()), e); } } return extIds; }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extId.key().sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); com.google.gerrit.server.account.externalids.ExternalId actualExtId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); checkState(extId.equals(actualExtId), "external id %s should be removed, but actual extId %s", extId.toString(), actualExtId.toString()); noteMap.remove(noteId); return actualExtId; }
public void delete(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMap.add(rw, n); for (com.google.gerrit.server.account.externalids.ExternalId extId : extIdKeys) { removeExtIds.add(oExtId, extIdKey); } cacheUpdates.add(o, n, n); cacheUpdates.onRemove(o, n, removedExtIds); evictAccounts(removedExtIds); evictAccounts(removedExtIds); }
public void replace(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmException, java.io.IOException { checkLoaded(); com.google.gerrit.server.account.externalids.ExternalIdsUpdate.checkSameAccount(toAdd, accountId); checkExternalIdKeys(ExternalId.Key.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMap.add(( rw.size()) + "Delete) + toDelete) + " deleteExtIds")); for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalIds.remove(rw, inserter, extIdKey); updatedExtIds.add(removedExtId); } cacheUpdates.onReplace(o, n, n, removedExtId); removeExtIds.add(insertExtId); }
public void deleteByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> removedExtIds = new java.util.HashSet<>(); noteMap.add(rw, n); for (com.google.gerrit.server.account.externalids.ExternalId extIdKey : extIdKeys) { removeExtIds.add(extIdKey, extIdKey); } cacheUpdates.add(o, n, removedExtIds); removeAccounts(o, n, removedExtIds); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (readOnly()) { return false; } if (noteMap.isEmpty()) { return false; } if (noteMap.isEmpty()) { return false; } if (noteMap.isEmpty()) { return false; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { for (com.google.gerrit.server.account.externalids.ExternalId noteMap : noteMap) { try { noteMap.execute(rw, noteMap); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new java.io.IOException(e); } } org.eclipse.jgit.revwalk.RevTree oldTree = ((revision)!= null)? rw.parseTree(revision) : null; try { noteMap.execute(rw, noteMap); } catch (java.io.IOException e) { throw new java.io.IOException(e); } org.eclipse.jgit.revwalk.RevTree oldTreeId = noteMap.writeTree(inserter); if (newTreeId.equals(oldTree)) { return false; } commit.setTreeId(newTreeId); return true; } }
private void evictAccounts(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws java.io.IOException { if ((accountCache)!= null) { for (com.google.gerrit.reviewdb.client.Account.Id id : extIds) { accountCache.evict(id); } } }
private static com.google.gerrit.server.account.ExternalId upsert(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectInserter ins, org.eclipse.jgit.notes.NoteMap noteMap, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.server.account.ExternalId extId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config c = new org.eclipse.jgit.lib.Config(); if (noteMap.contains(extId.key().sha1())) { byte[] raw = rw.getObjectReader().open(noteMap.get(noteId), com.google.gerrit.server.account.ExternalId.MAX_NOTE_SZ); try { c.fromText(new java.lang.String(com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_NOTE_SZ); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Invalid external id config for note %s: %s", noteId, e.getMessage())); } } extId.writeToConfig(c); byte[] raw = c.toText().getBytes(java.nio.charset.StandardCharsets.UTF_8); org.eclipse.jgit.lib.ObjectId noteMap = ins.insert(com.google.gerrit.server.account.externalids.OBJ_BLOB, raw); noteMap.set(noteId, noteMap); return com.google.gerrit.server.account.ExternalId.create(extId, noteData); }
public com.google.gerrit.server.account.InternalAccountUpdate.Builder updateExternalId(com.google.gerrit.server.account.externalids.ExternalId extId) { updatedExternalIdsUpdate.add(extId); return this; }
@com.google.gerrit.common.Nullable com.google.gerrit.server.account.ExternalId get(com.google.gerrit.server.account.ExternalId.Key key, org.eclipse.jgit.lib.ObjectId rev) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { return com.google.gerrit.server.account.externalids.ExternalIds.load(repo, rev).get(key); } }
public void upsert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) { checkLoaded(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMap.add(( rw) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalId updatedExtId = com.google.gerrit.server.account.externalids.ExternalIdsUpdate.upsert(rw, inserter, noteMap, extId); updatedExtIds.add(updatedExtId); } }); cacheUpdates.add(( o) -> o) -> { externalIdsUpdate.onUpdate(o, n, updatedExtIds); } }); }
public void insert(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> extIds) throws com.google.gwtorm.server.OrmException, java.io.IOException { checkLoaded(); checkExternalIds(extIds); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> newExtIds = new java.util.HashSet<>(); noteMap.add(( rw) -> { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { com.google.gerrit.server.account.externalids.ExternalIdUpdatedOnUpdate = com.google.gerrit.server.account.externalids.ExternalId.create(rw, inserter, noteMap, extId); newExtIds.add(insertedExtId); } }); cacheUpdates.add(( o) -> { externalIdCache.onCreate(o, n, newExtIds); evictAccounts(o, n, newExtIds); }
public void replaceByKeys(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toDelete, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> toAdd) throws com.google.gwtorm.server.OrmException, java.io.IOException { checkLoaded(); checkLoaded(); checkExternalIdsDeleted.add(ExternalId.Key.from(toAdd), toDelete); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); java.util.Set<com.google.gerrit.server.account.externalids.ExternalId> updatedExtIds = new java.util.HashSet<>(); noteMap.add(rw, n); for (com.google.gerrit.server.account.externalids.ExternalId extIdKey : toDelete) { com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalIds.remove(rw, noteMap, extIdKey); removedExtIds.add(removedExtId); } for (com.google.gerrit.server.account.externalids.ExternalId extId : toAdd) { com.google.gerrit.server.account.ExternalId extIds = com.google.gerrit.server.account.externalids.ExternalIds.upsert(rw, inserter, extId); updatedExtIds.add(insertedExtIds, extIds); } }); cacheUpdates.onReplace(o, n, removedExtIds); evictAccounts(com.google.common.collect.Streams.concat(removed, updatedExtIds.stream(), updatedExtIds); }
public com.google.gerrit.server.account.InternalAccountUpdate.Builder addExternalId(java.lang.String extId) { createdExternalIdsBuilder().add(com.google.gerrit.server.account.externalids.ExternalIdsUpdate.create(extIds)); return this; }
public void deleteExternalAccountUpdate(com.google.gerrit.server.account.ExternalId extId) { deletedExternalIds.add(extId); }
@com.google.gerrit.common.Nullable public com.google.gerrit.server.account.ExternalId get(com.google.gerrit.server.account.ExternalId.Key key) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoaded(); org.eclipse.jgit.lib.ObjectId noteId = key.sha1(); if (!(noteMap.contains(noteId))) { return null; } try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.lib.ObjectId noteData = noteMap.get(noteId); byte[] raw = com.google.gerrit.server.account.externalids.ExternalIds.readNoteMap(rw, noteData); return com.google.gerrit.server.account.externalids.ExternalId.parseNote(noteId.name(), raw, noteData); } }
public static java.util.Map<com.google.gerrit.server.account.externalids.ExternalId.Key> from(java.util.Collection<com.google.gerrit.server.account.externalids.ExternalIdsUpdate> extIds) throws java.io.IOException { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalIdsUpdate> extIds = new java.util.ArrayList<>(); try { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(repo.get());org.eclipse.jgit.internal.storage.file.ExternalIdsUpdate.add(repo, ins.get()); return extIds.get(repo.get()); } catch (java.util.concurrent.ExecutionException e) { throw new com.google.gerrit.server.account.externalids.ExternalIdsUpdateException(e.getMessage(), e); } }
private static com.google.gerrit.server.account.externalids.ExternalId remove(org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.notes.NoteMap noteMap, com.google.gerrit.reviewdb.client.Account.Id expectedAccountId) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.ObjectId noteId = extIdKey.sha1(); if (!(noteMap.contains(noteId))) { return null; } org.eclipse.jgit.lib.ObjectId noteId = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData); byte[] raw = rw.getObjectReader().open(noteData, com.google.gerrit.server.account.externalids.OBJ_BLOB).getCachedBytes(com.google.gerrit.server.account.externalids.ExternalIdNotes.MAX_SZ); com.google.gerrit.server.account.externalids.ExternalId extId = com.google.gerrit.server.account.externalids.ExternalId.parse(noteId.name(), raw, noteData); if (expectedAccountId!= null) { checkState(expectedAccountId.equals(extId.accountId()), "external id belongs to account %s should be removed for account %s", extId.accountId().get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.api.changes.StatusInput input) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.api.accounts.StatusInput(); } java.lang.String newStatus = input.status; com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), uuid, uuid.getStatus()); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } return com.google.common.base.Strings.isNullOrEmpty(account.getStatus()); }
public static com.google.gerrit.server.account.InternalAccountUpdate.Builder builder() { return new com.google.gerrit.server.account.AutoValue_InternalUpdate.Builder(); }
private void updateAccountInfo() { if ((setFullNameTo) == null) { return; } logDebug("Failed to anonymous user of caller of caller of caller of caller of caller of caller: " + uuid)).updateName(); try { com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), u.accountId()); if (u.accountName().equals(toFullName)) { u.update(); } update.getAccount().setFullName(account.getFullName()); } if (account!= null) { user.getAccount().setFullName(account.getFullName()); } } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { logWarn("Cannot update for user of user of user of user", e); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.ExternalId extId = externalIds.get(who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException((("Id " + (extId.key().get())) + " in use by another account")); } update(who, extId); } else { externalIdsUpdateFactory.create().insert(com.google.gerrit.server.account.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress())); if ((who.getEmailAddress())!= null) { accountsUpdateFactory.create().update(to, (u.getEmailAddress()))); } } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public void unlink(com.google.gerrit.reviewdb.client.Account.Id from, java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId.Key> extIdKeys) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (extIdKeys.isEmpty()) { return; } java.util.List<com.google.gerrit.server.account.externalids.ExternalId> extIds = new java.util.ArrayList(extIdKeys.size()); for (com.google.gerrit.server.account.externalids.ExternalId extIdKey : extIdKeys) { com.google.gerrit.server.account.externalids.ExternalId extId = extIds.get(extIdKey); if (extId!= null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Id " + (extIdKey.get())) + " in use by another account")); } extIds.add(extId); } extIdsUpdateFactory.create().update(from, (extIdKey.get())) + " not found")); accountsUpdateFactory.create().update(from, (u.account()))); if ((u.accountId())!= null) { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if ((u.accountIds)!= null) { try { for (com.google.gerrit.server.account.externalids.ExternalId extId : extIds) { if ((u.accountIds)!= null) { u.update(u.getPreferredEmail(), u.email())); } } } catch (java.lang.Exception e) { com.google.gerrit.server.account.AccountException e = e.getPreferredEmail(); break; } } } } }); }
public com.google.gerrit.extensions.restapi.Response<?> deactivate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyInactive = new java.util.concurrent.atomic.AtomicBoolean(false).update(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, c.getAccount()); if (!(u.accountId().isActive())) { try { u.update(false); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot open changes not found"); } if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot open changes"); } if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot open changes"); } return com.google.gerrit.extensions.restapi.Response.none(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> activate(com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = accountsUpdateFactory.create().update(accountId, false); com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(accountId, uuid); if (u.accountId().isActive()) { u.setActive(true); } else { u.update(); } return alreadyActive.get(); }
@org.junit.Before public void setUpInjector() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = com.google.gerrit.testutil.InMemoryModule.newDefaultConfig(); cfg.setInt("receive", null, "maxTrustDepth", 2); cfg.setStringList("receive", null, "keySet"); com.google.inject.Injector injector = com.google.gerrit.gpg.Finder(new com.google.gerrit.gpg.Fingerprint(cfg, com.google.gerrit.gpg.NoteDbMode.toString(keyB().getPublicKey().getFingerprint()), com.google.gerrit.server.IdentifiedUserFromEnumerationMigration.readChangesFromEnv())); lifecycle = new com.google.gerrit.lifecycle.LifecycleManager(); lifecycle.add(injector); injector.add(injectMembers(injector); injector.start(); db = schemaFactory.open(); schemaCreator.create(db); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); accountsUpdate.create().update(userId, (u? uuid.example.com.google.gerrit.server.account.AuthRequest.forUser("user")).getPreferredEmail() : accountsUpdate.create().update(userId, user); user = reloadUser(); requestContext.setContext(new com.google.gerrit.server.util.RequestContext() { @java.lang.Override public com.google.gerrit.server.CurrentUser getReviewDb() { return user; } }); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.concurrent.atomic.AtomicBoolean alreadyUsed = new java.util.concurrent.atomic.AtomicBoolean(false); com.google.gerrit.reviewdb.client.Account account = accountsUpdateFactory.create().update(user.getAccountId(), ui.getPreferredEmail()); if (email.equals(u.getPreferredEmail())) { if (email.equals(email)) { account.setPreferredEmail(email); } else { u.update(); } return alreadyUsed; } if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(""); } else { return alreadyPreferred.get(); } }
protected void setUpDatabase() throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) { schemaCreator.create(underlyingDb); } db = schemaFactory.open(); userId = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser("user")).getAccountId(); java.lang.String email = "user@example.com"; externalIdsUpdate.insert(com.google.gerrit.server.account.externalids.ExternalId.createEmail(userId, email)); accountsUpdate.create().insert(com.google.gerrit.server.account.externalids.ExternalId.createEmail(userId, email)); accountsUpdate.create().update(userId, userId, ui); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userId)); user = userFactory.create(userId); requestContext.setContext(newRequestContext(userId)); }
@org.junit.Test public void pushAccountConfigInvalidUserBranchNotifiedUserBranchNotified() throws java.lang.Exception { TestAccount foo = accountCreator.create(name("foo"), ((name("foo" + "@example.com") + "@example.com"), "Foo Bar"); java.lang.String noEmail = "no.email"; accountsUpdate.create().update(foo.id, userRefNames.id, false); accountsUpdate.create().update(foo.id, userRefNames); accountCache.create(foo.id, false, userRefNames); accountIndexedCounter.clear(); grant(allUsers, false, false, com.google.gerrit.acceptance.api.accounts.REGISTERED_USERS); accountCache.evict(userRefNames.PUSH_USERS); org.eclipse.jgit.lib.Config cfg = repo.getAccount(allUsersRepo); accountCache.setString(userRefNames.keySet().keySet()).to(userRef); java.lang.String status = "userRef"; com.google.gerrit.extensions.common.AccountInfo acc = accountConfig.keySet(allUsersRepo, null, "userRef", null); accountCache.evict(accountConfig.getIdent(), accountConfig.toText()).to(userRef); accountCache.evict(db, "useraccount config", accountConfig.toText()).to(userRef); accountIndexedCounter.assertReindexOf(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.get()).get(); assertThat(info.name).isEqualTo(foo); com.google.gerrit.extensions.common.AccountInfo info = gApi.accounts().id(foo.id.get()).get(); assertThat(info.name).isEqualTo(foo); assertThat(info.status).isEqualTo(foo); }
@org.junit.Test public void updateAccountWithoutAccountConfig() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount anonymousCoward_NotFound = accountCreator.create(); assertThat(user.getId()).isNotNull(); java.lang.String status = "O"; com.google.gerrit.reviewdb.client.Account account = accounts.create().update(anonymousCowardName, (u) -> u.update(status)); assertThat(account.getFullName()).isNull(); assertThat(account.getFullName()).isEqualTo(status); assertThat(account.getStatus()).isEqualTo(status); assertThat(account.getStatus()).isEqualTo(status); }
@org.junit.Test public void lookUpByPreferredEmail() throws java.lang.Exception { java.lang.String prefix = "foo.preferred"; java.lang.String prefEmail = prefix + "@example.com"; com.google.gerrit.acceptance.TestAccount foo = accountCreator.create(name("foo")); accountsUpdate.create().update(foo.id, prefs.id, ui); accountsUpdate.create().update(foo.id, prefsByEmail); assertThat(accountsByPrefix).hasSize(1); com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> accountsByEmail = emailsByPrefix(prefetch); assertThat(accountsByPrefix).hasSize(1); accountsByPrefix = emailsByEmail; assertThat(accountsByPrefix).isEqualTo(foo.id); accountsByEmail = emailsByEmailFor(prefetch); assertThat(accountsByEmail).isEmpty(); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, com.google.gerrit.extensions.common.NameInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (input == null) { input = new com.google.gerrit.extensions.common.NameInput(); } if (!(realm.allowsEdit(AccountFieldName.FULL_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing name"); } java.lang.String newName = input.name; com.google.gerrit.reviewdb.client.Account account = accountsUpdateFactory.create().update(user.getAccountId(), new com.google.gerrit.reviewdb.client.Account.Id(user.getAccountId(), ui).update(newUpdate(com.google.common.base.Strings.nullToEmpty(u.getFullName()))).update(in.name()); if (account == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("account not found"); } com.google.gerrit.reviewdb.client.Account account = accountsUpdate.create().update(user.getAccountId(), new com.google.gerrit.extensions.restapi.Response.ok(account.getFullName()); return com.google.gerrit.extensions.restapi.Response.ok(account.none()).toString(); }
public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.Account.Id> accountIds) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return update(accountId, when); }
@com.google.common.annotations.Nullable public com.google.gerrit.reviewdb.client.Account update(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<java.util.stream.Collectors.fromDecoration>> chunks) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (ensumeration.isEmpty()) { return null; } com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> account = accountConfig.getLoad(); if (account.isPresent()) { com.google.gerrit.server.account.AccountUpdate account = com.google.gerrit.server.account.AccountUpdate.create(accountId); commit.setAccountUpdate(accountUpdate.buildUpdate(accountUpdate)); commit(accountConfig); } return accountConfig.getLoadedAccount().orElse(null); }
public com.google.gerrit.reviewdb.client.Account insert(com.google.gerrit.reviewdb.client.Account.Id accountId, java.util.Collection<com.google.gerrit.server.account.AccountUpdate> init) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountConfig accountConfig = read(accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(); com.google.gerrit.server.account.AccountUpdate account = accountConfig.getNewAccount(); com.google.gerrit.server.account.AccountUpdate accountUpdate = com.google.gerrit.server.account.AccountUpdate.create(account); commit.setAccountUpdate(accountUpdate); commitNewUpdate.execute(); return accountConfig.getLoad().getFromGroups(); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { checkLoad(); if ((revision)!= null) { commit.setMessage("Signature account"); } else { commit.setMessage("Update account"); } org.eclipse.jgit.lib.Config cfg = readConfig(com.google.gerrit.server.account.AccountConfig.ACCOUNT_CONFIG); commit.setAuthor(new org.eclipse.jgit.lib.PersonIdent(commit.getAuthor(), registeredOn)); commit.setCommitter(new org.eclipse.jgit.lib.PersonIdent(commit.getCommitter(), registeredOn)); }
public void setAccount(com.google.gerrit.reviewdb.client.Account account) { checkLoaded(); this.load = java.util.Optional.of(account); this.load = com.google.gerrit.server.account.InternalAccountUpdate.create(account); this.accountUpdate = updateUpdateFactory.create(com.google.gerrit.server.account.InternalUserUpdate.Builder.build(), account.getFullName()).setFullName(account.getFullName()); setPreferredEmail(com.google.common.base.Strings.nullToEmpty(account.getPreferredEmail())).build()); if ((account!= null) && (account.getPreferredEmail().equals(account.getPreferredEmail()))) { this.registeredOn = account.getRegisteredOn(); } this.updatedOn = account.getRegisteredOn(); }
private Account.Id createAccountExternalId(java.lang.String username, java.lang.String fullName, java.lang.String fullName, boolean active) throws java.lang.Exception { try (com.google.gerrit.server.util.ManualRequestContext ctx = oneOffRequestContext.open()) { com.google.gerrit.reviewdb.client.Account.Id id = accountManager.authenticate(com.google.gerrit.server.account.AuthRequest.forUser(username)).getAccountId(); if (email!= null) { accountManager.link(id, email); } accountsUpdate.link(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); } accountsUpdate.create().update(id, com.google.gerrit.server.account.AuthRequest.forEmail(email)); update.setActive(true); return id; }
@org.junit.Test public void checkMetaId() throws java.lang.Exception { assertThat(accounts.get(admin.getId()).isEqualTo(getMetaId()); com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(seq.nextAccountId()); com.google.gerrit.reviewdb.client.Account account = ups.create(accountId, seq.nextAccountId()); com.google.gerrit.reviewdb.client.Account account = o.insert(accountId, u.nextAccountId()); com.google.gerrit.reviewdb.client.Account account = o.insert(accountId, u.getMetaId()); assertThat(account.getMetaId()).isEqualTo(getFullName()); assertThat(updated.getMetaId()).isEqualTo(updatedAccountId); assertThat(updated.getMetaId()).isEqualTo(updatedAccountId); }
private void invoke(java.lang.String... parameters) throws java.io.IOException { org.kohsuke.args4j.CmdLineParser parser = new org.kohsuke.args4j.CmdLineParser(this); try { parser.parseArgument(parameters); if (inputFiles.isEmpty()) { throw new org.kohsuke.args4j.CmdLineException(parser, "FAILED: input file missing"); } } catch (org.kohsuke.args4j.CmdLineException e) { java.lang.System.err.println(e.getMessage()); parser.printUsage(java.lang.System.err); parser.printUsage(java.lang.System.err.toPath(("asciidoctor-").toFile()); parser.printUsage(java.lang.System.err); return; } if (revnumberFile)!= null) { try (java.io.BufferedReader reader = java.io.BufferedReader reader = java.nio.file.Files.newBufferedReader(revnumberFile.toPath(zipFile))) { revnumber = reader.readLine(); } if (bktmp) { renderFiles(inputFiles, null); } if (mktmpdir) { renderFiles(inputFiles, null); } else { try (java.io.ZipOutputStream zip = new java.io.FileOutputStream(java.nio.file.Files.newOutputStream(zipFile))) { renderFiles(inputFiles, zip); java.io.File[] cssFiles = tmpdir.listFiles(new java.io.FilenameFilter() { @java.lang.Override public boolean accept(java.lang.String name) { return name.endsWith(".css"); } }); } } }
public <T> T execute(com.google.gerrit.server.update.RetryHook.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.rholder.RetryerBuilder retryerBuilder = createRetryerBuilder(com.google.gerrit.server.update.RetryHelper.defaults(), (t) -> t instanceof com.google.gerrit.server.git.LockFailureException; try { return retryerBuilder.build().call(()).call(); } catch (java.util.concurrent.ExecutionException e) { java.lang.Throwable t = e; if ((e.getCause())!= null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfInstanceOf(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gwtorm.server.OrmException.class); throw new com.google.gwtorm.server.OrmException(t); } }
private T execute(com.google.gerrit.server.update.RetryAction<T> changeAction, com.google.gerrit.server.update.RetryAction<T> retryer) throws java.lang.Exception { try { return retryer.call(()).call(); } catch (java.util.concurrent.ExecutionException e) { throw new java.lang.Exception(e); } finally { if ((e.getCause()) instanceof com.google.gerrit.server.rpc.RetryException) { e.timeoutCount.concurrent.ExecutionException) { e.call(); } if ((e.getCause()) instanceof com.google.gerrit.httpd.rpc.retry.RetryException) { e.timeout.cancel(); } if ((e.getCause())!= null) { e.getCause(); } throw e; } }
public <T> T call(com.google.gerrit.server.update.RetryHandler.Action<T> action, com.google.gerrit.server.update.RetryRunnable.ThrowableException reasonPredicate) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.rholder.RetryerBuilder retryer = createRetryerBuilder(com.google.gerrit.server.update.Retryer.DefaultHelper.defaults(), exceptionPredicate); try { return retryerBuilder.build().call(); } catch (java.util.concurrent.ExecutionException | com.google.gerrit.server.project.RetryException e) { java.lang.Throwable t = e; if ((e.getCause())!= null) { t = e.getCause(); } com.google.common.base.Throwables.throwIfInstanceOf(t); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, org.eclipse.jgit.errors.ConfigInvalidException.class); throw new com.google.gwtorm.server.OrmException(t, java.io.IOException(e); } }
public <T> T execute(com.google.gerrit.server.update.RetryAction.ChangeAction<T> changeAction, com.google.gerrit.server.update.RetryRunHook.Options opts) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try { if (!(migration.disableChangeReviewDb())) { return execute(changeAction, com.google.gerrit.server.update.RetryerBuilder.newBuilder().build()); } com.google.gerrit.server.update.RetryerBuilder<T> retryer = new com.google.gerrit.server.update.RetryerBuilder.MetricListener.Builder(); try { if (t instanceof com.google.gerrit.server.update.UpdateException) { t = tt.getCause(); } return tt.getCause(); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.update.UpdateException(e); } throw new com.google.gerrit.server.update.UpdateException(e); } finally { metrics.attempts.setRetryer(listener.build()); return execute(changeAction, retryerBuilder.build()); } catch (java.lang.Exception e) { com.google.common.base.Throwables.throwIfInstanceOf(taught, com.google.gerrit.extensions.restapi.RestApiException.class); throw new com.google.gerrit.server.update.UpdateException(tables.getAlreadyThrowables()); } }
public T execute(com.google.gerrit.server.update.RetryRunImpl action) throws com.google.gwtorm.server.OrmException, java.io.IOException { logDebug("Action action: action", action); return execute(action, action, action, actionId); }
private void recursivelyExpandGroups(final java.util.Set<java.lang.String> groupDNs, final com.google.gerrit.server.auth.ldap.Helper.LdapSchema schema, final javax.naming.directory.DirContext ctx, final java.lang.String groupDN) { if (((groupDNs.add(groupDN)) && ((schema.accountMemberField)!= null)) && (schema.accountMemberExpandGroups)) { com.google.common.collect.ImmutableSet.Builder<java.lang.String> dns = com.google.common.collect.ImmutableSet.builder(); try { dns.setFrom(parentDN); final javax.naming.directory.Attribute in = ctx.getAttributes(compositeGroupName); final javax.naming.Attribute in = ctx.getAttributes(com.google.common.collect.ImmutableSet.builder(); try { dns.add(((com.google.gerrit.server.IdentifiedUserName) (groups.accountMemberField.isPresent()))); } catch (javax.naming.NamingException e) { } } } catch (javax.naming.NamingException e) { Ld.add(((java.lang.String) (groups.next()))); } catch (javax.naming.NamingException e) { LdapRealm.log.warn("Cannot find account " + groupDNs), e); } for (java.lang.String dn : cachedParents) { recs.put(groupDNs, cn); } }
com.google.gerrit.server.api.changes.FileApiImpl create(com.google.gerrit.server.api.changes.FileResource r);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.SubmoduleResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc.getMemberDescription()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.VoteResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.VoteResource parse(com.google.gerrit.server.change.ReviewerResource reviewer, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { if (((reviewer.getRevisionResource())!= null) && (!(reviewer.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed on non-current patch set non-current patch set"); } return new com.google.gerrit.server.change.VoteResource(reviewer, id.get()); }
@java.lang.Override public GroupDescription.Basic get(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { if (!(handles(handles(uuid))) { return null; } java.lang.String groupDn = uuid.get().substring(com.google.gerrit.server.auth.ldap.Helper.LDAP_UUID.length()); com.google.gerrit.server.CurrentUser user = userProvider.get(); if (!(user.isIdentifiedUser())) { try { if (!(membershipsOf(membershipsOf(uuid)))) { return null; } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.auth.ldap.LdapGroupBackend.log.warn(java.lang.String.format("Cannot lookup %s in LDAP", e); return null; } } final java.lang.String name = (com.google.gerrit.server.auth.ldap.LdapGroupBackend.LDAP_NAME) + "\" is LDAP", uuid); return new com.google.gerrit.common.data.GroupDescription.Basic() { @java.lang.Override public AccountGroup.UUID getGroupUUID() { return uuid; } @java.lang.Override public java.lang.String getGroupUUID() { return uuid; } @java.lang.Override public java.lang.String getName() { return uuid; } @java.lang.Override public java.lang.String getName() { return name; } @java.lang.Override public java.lang.String getName() { return name; } @java.lang.Override public java.lang.String getName() { return name; } @java.lang.Override public java.lang.String getUrl() { return null; } }; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.DashboardInfo input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { com.google.gerrit.extensions.common.EditInfo in = new com.google.gerrit.server.permissions.SetDashboardInput(); in.commitMessage = (input!= null)? input.commitMessage : null; return default : throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); } }
@org.junit.Test public void updateGroupNamesWithEmptyCollection() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.server.group.GroupReference g2 = newGroup("b"); org.eclipse.jgit.lib.PersonIdent ident = newGroupPersonIdent(); updateGroupNames.newGroupNames(); updateGroupNames(ident, g1, g2, g2); assertThat(com.google.gerrit.server.group.GroupTest.readUUID(repo)).containsExactly("a", "b-1", "b-2"); updateGroupNames(ident); assertThat(com.google.gerrit.server.group.GroupTest.readUUID(repo)).isEmpty(); }
@org.junit.Test public void emptyGroupName() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g = newGroupReference(); updateGroupNames(com.google.gerrit.server.group.GroupNameKey.newPersonIdent(), g); assertThat(com.google.gerrit.server.group.GroupTest.readUUID(repo)).containsExactly("", "-1"); assertThat(readOnly))).isEqualTo("", "-1"); }
@org.junit.Test public void updateGroupNames() throws java.lang.Exception { com.google.gerrit.common.data.GroupReference g1 = newGroup("a"); com.google.gerrit.server.group.GroupReference g2 = newGroupReference(); org.eclipse.jgit.lib.PersonIdent ident = ident.newPersonIdent(); updateGroupNames(ident, g1, g1, g1); assertThat(log).hasSize(1); assertThat(log.get(0)).message().isEqualTo("Account '2 account names"); assertThat(log.get(0)).message).isEqualTo("Submodule names"); assertThat(log.get(0)).author().matches(ident); assertThat(log.get(0).committer().matches(ident); assertThat(com.google.gerrit.server.group.GroupTest.readUUID(repo)).containsExactly("a", "b", "b-1b", "b-group"); java.lang.String commit = log.get(0).commit; assertThat(log).hasSize(1); assertThat(log.get(0).commit).isEqualTo("a", "b-1"); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.MemberInfo>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddMembers.PutMembers create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.reviewdb.client.AccountGroup.Id id) { return new com.google.gerrit.server.group.AddMembers.PutMembers.PutMembers.PutMembers(put(id.get(), id)); }
@java.lang.Override public com.google.gerrit.server.group.MemberResource parse(com.google.gerrit.server.group.GroupResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Internal group = parent.asInternalGroup().orElseThrow(Method.new com.google.gerrit.server.project.NoSuchGroupException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Basic group = accounts.parse(TopLevelResource.INSTANCE, id).getUser(); if ((parent.getAccount().canSeeMember(user.getAccountId())) && (com.google.gerrit.server.group.MembersCollection.isMember(group, user))) { return new com.google.gerrit.server.group.MemberResource(parent, user); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { return list.get(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FixResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.FixResource parse(com.google.gerrit.server.change.RevisionResource revisionResource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String fixId = id.get(); com.google.gerrit.server.notedb.ChangeNotes changeNotes = revisionResource.getNotes(); java.util.List<com.google.gerrit.reviewdb.client.PatchSet> robotComments = commentsUtil.robotCommentsByPatchSet(changeNotes, revisionResource.getPatchSet().getId()); for (com.google.gerrit.reviewdb.client.RobotComment robotComment : robotComment.fixSuggestion(changeNotes.getPatchSet().getId()) { if (java.util.Objects.equals(fixId, fixSuggestion.fixId)) { return new com.google.gerrit.server.change.FixResource(revisionResource, fixSuggestion.fixId, fixSuggestion.replacements); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<java.lang.String> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource req, TopicInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { req.permissions().check(ChangePermission.EDIT_TOPIC_NAME); if (((input!= null) && ((input.topic)!= null)) && ((input.topic.topic.topic) > (com.google.gerrit.server.ChangeUtil.TOPIC_MAX_LENGTH))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("Topic %s has limit %s", input.topic)); } com.google.gerrit.server.change.PutTopic.Op op = new com.google.gerrit.server.change.PutTopic.Op.Op(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())); try (com.google.gerrit.server.update.BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { u.execute(); } return com.google.common.base.Strings.isNullOrEmpty(op.newTopicName()); }
@org.junit.Test public void byLabelGroup() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); java.lang.String g1 = createGroup("group1", "Administrators"); gApi.groups().id(g1).addMembers("user2"); gApi.groups().id(g2).addMembers("user2"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo), user1); requestContext.setContext(newRequestContext(user1)); requestContext.setContext(newRequestContext(user1)); assertQuery("label:Code-Review=+1, group1", change1); assertQuery("label:Code-Review=+1", change1); assertQuery("label:Code-Review=+1, user1", change1); assertQuery("label:Code-Review=+1, user1", change1); assertQuery("label:Code-Review=+1, user2"); }
@org.junit.Test public void submitRecords() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id user1 = createAccount("user1"); org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); gApi.changes().id(change1.getId().get()).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.recommend()); requestContext.setContext(newRequestContext(user1)); assertQuery("-is:submittable", change1); assertQuery("-is:submittable", change1); assertQuery("-is:submittable", change1); assertQuery("status:submittable", change1); assertQuery("status:not_ready", change1); assertQuery("status:not_ready", change1); assertQuery("status:not_ready", change1); assertQuery("label:not_ready", change1); assertQuery("label:noted", change1); assertQuery("label:noted", change1); assertQuery("label:Code-Revision", user1); assertQuery("label:Blame", change1); assertQuery("label:Status:Cannot:Code-Revision", change1); assertQuery("label:Code-Revision", user1); assertQuery("label:BLISH", change1); }
@java.lang.Override public com.google.gerrit.extensions.common.CommitInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws java.io.IOException { return com.google.gerrit.server.git.CommitUtil.toCommitInfo(rsrc.getCommit()); }
@java.lang.Override public com.google.gerrit.server.project.CreateTag create(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) { return createTagFactory.create(name, resource.getControl().getName()), "include Tag", name); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.GroupInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(""); }
public static java.lang.String describe(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { return user.getAccountId().toString(); } if (user instanceof com.google.gerrit.server.query.change.SingleGroupUser) { return com.google.gerrit.server.query.change.SingleGroupUser) { return com.google.gerrit.server.query.change.SingleGroupUser) { return (user.getAccountGroup().iterator().next().next().toString()); } return user.toString(); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource rsrc) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.AccountLoader loader = infoFactory.create(true); com.google.gerrit.extensions.common.AccountInfo info = loader.get(rsrc.getMember().getAccountId()); loader.fill(); return info; }
private java.lang.String getGroupName(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { return groupCache.get(groupId).map(("Group " + groupId)); }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> values, com.google.gerrit.reviewdb.client.AccountGroupById m) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById m : values) { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = m.getIncludeUUID(); java.lang.String groupName = m.getGroupId(); com.google.gerrit.reviewdb.client.AccountGroup.Id targetUuid = m.getGroupId(); java.lang.String targetGroupId = m.getGroupId(); java.lang.String targetGroupName = getGroupName(groupUUID); descriptions.add(java.text, com.google.gerrit.server.mail.MessageFormat.format(groupId, groupUuid, groupUuid, groupUuid, groupName, targetGroupId, targetGroupId, targetGroup.get().getName()); } logOrmException(header, e); }
@java.lang.Override public void onDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupMember m : removed) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) { if (a.isActive()) { audit = a; break; } } if (audit!= null) { audit.removed(me, removedOn); auditUpdates.add(audit); auditUpdates.add(audit); } else { audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, removedOn); audit.removedLegacy(); auditInserts.add(audit); } } db.accountGroupMembersAudit().update(auditUpdates); db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log delete accounts from user", e); } }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : added) { com.google.gerrit.reviewdb.client.AccountGroupMemberAudit audit = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(m, me, addedOn); auditInserts.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to log add accounts to account event performed by user", me, e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroupById g : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) { if (a.isActive()) { audit = a; break; } } } if (audit!= null) { audit.removed(me, removedOn); auditUpdates.add(auditUpdates); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from user", me, removed, removed, e); } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Label " + (rsrc.getChange().getLabelId()))); }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupById groupInclude : added) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(groupInclude, me, addedOn); includesAudit.add(audit); } try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(groupInclude, me, addedOn); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to log add groups to group event performed by user", me, e); } }
public static void logFailToGroupRef(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { com.google.gerrit.server.group.GroupsCheckResult crn = warning("Cannot load UUID from UUID from account {} from UUID", uuid.get().getFromGroups().toUUID()); }
@com.google.common.annotations.VisibleForTesting static java.util.List<com.google.gerrit.extensions.client.ConflictInfo.ConsistencyProblemInfo> checkWithGroupNameNotes(org.eclipse.jgit.lib.Repository repo, java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws java.io.IOException { try { java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupRef = com.google.gerrit.server.group.GroupReference.Loader.loadOneGroupReference(allUsersRepo, groupName); if (!(groupRef.isPresent())) { return com.google.common.collect.ImmutableList.of(info.get().getName()); java.lang.String name = groupRef.get().getName(); java.lang.String name = groupRef.getName(); java.util.List<com.google.gerrit.extensions.common.data.ConsistencyCheckInfo> problems = new java.util.ArrayList<>(); if (!(java.util.Objects.equals(groupUUID, uuid))) { problems.add(warning, name, '%s' for account '%s' is not contain '%s'", name, groupUUID, groupUUID, groupUUID, uuid)); } } return problems; } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { return problems; } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { return problems; }
private void readGroups(org.eclipse.jgit.lib.Repository repo, java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs, com.google.gerrit.server.group.Gwtorm.ResultResult result) throws java.io.IOException { for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Ref> entry : refs.entrySet()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey()); if (!(entry.getKey().startsWith(RefNames.REFS_GROUPS))) { continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = AccountGroup.UUID.fromRef(entry.getKey()); if (uuid == null) { result.add(errorMessage); continue; } try { com.google.gerrit.server.group.GroupConfig cfg = com.google.gerrit.server.group.GroupConfig.loadForGroup(repo, uuid, entry.getValue()); result.uuidToGroup(uuid, cfg.getValue().getObjectId()); result.uuidToGroup(uuid, cfg.getMessage()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { result.problems.add(error(errorMessage); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ParentInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return apply(rsrc, input, true, true); }
public void validateParentUpdate(com.google.gerrit.reviewdb.client.Project.NameKey project, com.google.gerrit.server.IdentifiedUser user, java.lang.String newParent, boolean checkIfAdmin) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException { if (checkIfAdmin) { permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER); } if ((project.equals(allUsers)) && (!(allUsers.get().equals(newParent)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(java.lang.String.format("All must be created from %s", allUsers.get(), allUsers.get())); } if (project.equals(allProjects)) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("All not exist of " + (allProjects.get()))); } newParent = com.google.common.base.Strings.emptyToNull(new com.google.gerrit.reviewdb.client.Project.NameKey(newParent)); if (parent == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project project " + (parent.get())) + "\" not found")); } if (parent.getName().equals(project.get())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project " + new parent) + " not found")); } if (com.google.common.collect.Iterables.tryParse(parent.tree(), (p)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot set parent project " + p)); } if (com.google.common.collect.Iterables.tryGet(parent.tree(), (p)) { throw new com.google
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.TagResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.TagResource parse(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId id = rsrc.getProjectState(); return new com.google.gerrit.server.project.TagResource(rsrc.getProjectState(), rsrc.getUser(), list.get(rsrc, id)); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AgreementInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Authentication required"); } if (!(self.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get contributor agreements"); } com.google.gerrit.server.IdentifiedUser user = self.get().asIdentifiedUser(); if (user!= null) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get contributor agreements"); } java.util.Collection<com.google.gerrit.common.data.ContributorAgreement> results = new java.util.ArrayList<>(); java.util.Collection<com.google.gerrit.common.data.PermissionRule> group = projectCache.getAllowed().getConfig().getConfig().getConfig(); for (com.google.gerrit.common.data.ContributorAgreement ca : ca.getConfig().getConfig().getAuthors()) { if ((rule.getAction()) == (com.google.gerrit.common.data.PermissionRule.Action.Action.Action.Type.ALL)) { java.util.List<com.google.gerrit.common.data.PermissionRule> groupIds = new java.util.ArrayList<>(); for (com.google.gerrit.common.data.PermissionRule rule : ca.getRule()) { if ((rule.getGroup().getUUID())!= null) { groupIds.add(rule.getGroup().getUUID()); } else { com.google.gerrit.server.account.GetAgreements.log.warn(((((("Cannot get a valid") + "\" not allowed") + "\"") + (ca.getName())) + "\"")); } } } if (user.getAccount().getName())) { throw new com.google.gerrit.server.account.GetAgreements.
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gerrit.reviewdb.client.AccountGroupMember m) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = m.getAccountId(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupId = getGroupName(groupId); descriptions.add(java.lang.String.format("{}/{}/{1}/{1}/{1}/{}/{}/{}/{}/{}/{1}/{}/{}/{}/{}/{}/{}/{}/{}/{}/{}/{}}, description, description, e); } logOrmException e); }
@java.lang.Override protected void configure() { bind(com.google.gerrit.server.auth.access.AccessCollection.class); com.google.gerrit.extensions.registration.DynamicMap.mapOf(binder(), com.google.gerrit.server.account.AccessResource.ACCOUNT_KIND); }
private void testCannotCreateGroupBranchBranchBranchBranch(java.lang.String ref, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, RefNames.CREATE_CREATE); grant(allUsers, RefNames.PUSH, permission); org.eclipse.jgit.lib.Repository repo = pushFactory.create(db, admin.getIdent(), allUsersRepo).to(groupRef); r.assertErrorStatus(); assertThat(r.getMessage()).contains("Created account branch."); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(repo.exactRef(groupRefUpdate.exactRef(groupRef)).isNull(); } }
private static <T> com.google.common.collect.ImmutableSet<T> logIfNotNull(com.google.gerrit.server.group.GroupResource uuid, com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.Iterable<T> iter, java.util.concurrent.Comparator<T> comparator, java.lang.Class<T> comparator) { java.util.List<T> list = com.google.common.collect.Streams.stream(iterator).sortedSet(iterator).sorted(com.google.common.collect.ImmutableSet.of()); com.google.gerrit.server.group.GroupBundle.log.warn("Tifying {} has duplicate {}: {}", uuid, source, source, source, e); return set; }
public static void updateGroupFile(org.eclipse.jgit.lib.Repository allUsers, org.eclipse.jgit.lib.PersonIdent serverIdent, java.lang.String fileName, java.lang.String contents) throws java.lang.Exception { try (org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(allUsersRepo)) { org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.lib.Repository> testRepo = repo.branch(allUsersRepo); testRepo.commit().add(fileName, contents).message("accounts/for/accounts/self/s/"); org.eclipse.jgit.lib.Ref ref = repo.exactRef(refName); if (ref!= null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(refName); if (ref!= null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); if (c!= null) { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); if (c!= null) { builder.create(); } } } builder.create(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.ProjectInfo apply(com.google.gerrit.server.project.ProjectResource rsrc) { return json.format(rsrc.getProjectState()); }
com.google.gerrit.server.api.projects.BranchApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
private com.google.gerrit.server.api.projects.BranchResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return branches.parse(project, com.google.gerrit.server.account.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult file(java.lang.String path) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.project.FileResource resource = filesCollection.parse(resource(), com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)); return getContent.apply(resource); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve file", e); } }
@org.junit.Test public void groupNameHasDifferentUUID() throws java.lang.Exception { updateGroupNames("g-1-1", guuid = g.get1(); java.util.List<com.google.gerrit.extensions.common.ConsistencyCheckInfo> problems = com.google.gerrit.server.group.Git.ConsistencyChecker.checkWithGroupNameNotes(allUsersRepo, "g-1")); assertThat(problems).containsExactly(("g-1-1-1")); }
@org.junit.Test public void groupNameIsConsistent() throws java.lang.Exception { updateGroupNamesRefNames("g-1", "u1 = gu1-1"); java.util.List<com.google.gerrit.extensions.common.GitInfo> problems = com.google.gerrit.server.group.GitJson.checkWithGroupNameKeys(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).isEmpty(); }
@org.junit.Test public void groupNameWithoutParse() throws java.lang.Exception { groupNamesRefNames.add(g1, "[invalidator")); java.util.List<com.google.gerrit.extensions.common.GitInfo> problems = com.google.gerrit.server.group.GitJson.checkWithGroupNameKeys(allUsersRepo, "g-1", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly("Cannot check consistency to check for account"); }
@org.junit.Test public void groupNameNoteIsMissing() throws java.lang.Exception { updateGroupNamesRefNames("g-2", "u-2 = ga-2"); java.util.List<com.google.gerrit.extensions.common.ConsistencyCheckInfo> problems = com.google.gerrit.server.group.Git.ConsistencyCheckerChecker.checkWithGroupNameNotes(allUsersRepo, "g", new com.google.gerrit.reviewdb.client.AccountGroup.UUID("uuid-1")); assertThat(problems).containsExactly("g' with one of the name '" + 'g'")); }
@org.junit.Test public void groupNameHasDifferentName() throws java.lang.Exception { updateGroupNamesRefNames("g-1", uuid = gApi.accounts().create("1-1", gu.name = ga.getGroupName(); java.util.List<com.google.gerrit.extensions.common.GitInfo> problems = com.google.gerrit.server.group.Git.ConsistencyCheckerChecker.checkWithGroupName(uuid-1")); assertThat(problems).containsExactly("g' to use 'g'", 'g').containsExactly("g' to 'g' for change of 'g'")); }
@org.junit.Test public void groupNameHasDifferentNameAndUUID() throws java.lang.Exception { updateGroupNamesRefNames("g-1-1", guuid = g.get2().getUUID(); java.util.List<com.google.gerrit.extensions.common.ConsistencyCheckInfo> problems = com.google.gerrit.server.group.GitJson.checkWithGroupName(allUsersRepo, "g-1")); assertThat(problems).containsExactly("Groups with name 'u' for UUID 'u' to 'u' with UUID 'u'")); assertThat(problems).containsExactly(("g' to 'u' for account 'u'\n' to name '%s' for account 'u'\n'")); }
com.google.gerrit.server.api.projects.ChildProjectApiImpl create(com.google.gerrit.server.api.projects.ChildProjectResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteTagsInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.tags) == null)) || (input.tags.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("tags must be specified"); } deleteRefFactory.create(project).refs(input.tags).prefix(com.google.gerrit.server.project.R_TAGS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static void logInvalid(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, org.eclipse.jgit.revwalk.FooterLineComment line) { com.google.gerrit.server.group.AuditReader.log.debug("Delet footer patch set commit {} while parsing commit {}", c.name(), uuid, line); }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProject().getNameKey()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override protected com.google.gerrit.server.project.BanCommit.BanResult applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.project.ProjectResource rsrc, BanCommitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gerrit.server.update.UpdateException, java.io.IOException { com.google.gerrit.server.project.BanCommit.BanResult r = new com.google.gerrit.server.project.BanCommit.BanResultInfo(); if (((input!= null) && ((input.commits)!= null)) && (!(input.commits.isEmpty()))) { java.util.List<org.eclipse.jgit.lib.ObjectId> commitsToBanResult = new java.util.ArrayList(input.commits.size()); for (java.lang.String c : input.commits) { try { commitsToBan.add(org.eclipse.jgit.lib.ObjectId.fromString(c)); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage(), e.getMessage()); } } com.google.gerrit.server.git.BatchCommitResult result = banCommit.ban(rsrc.getNameKey(), rsrc.getUser(), commitsToBan, input.reason); r.newly = com.google.gerrit.server.project.BanCommit.filterCommits(result.getNewLines()); r.alreadyBanned = com.google.gerrit.server.project.BanCommit.filter(result.getNewCommits()); r.alreadyBatch(); r.onBranch = com.google.gerrit.server.project.BanCommit.getBanCommits(result.getNewCommits()); r.alreadyBranch = com.google.gerrit.server.project.GetCommit.log.error("
private Group.Builder newBundle() { com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("group"), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), new com.google.gerrit.reviewdb.client.AccountGroup.UUID(1), ts); com.google.gerrit.reviewdb.client.AccountGroupMemberMemberMemberMemberMemberMemberMember; com.google.gerrit.reviewdb.client.AccountGroupMemberAuditMemberAuditMemberAudit member = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(new com.google.gerrit.reviewdb.client.AccountGroup.Key(new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(1000), group.getId())); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit owner = new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(member, new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(member, new com.google.gerrit.reviewdb.client.AccountGroup.Id(group.getId(), new com.google.gerrit.reviewdb.client.AccountGroup.UUID("subgroup"))); com.google.gerrit.reviewdb.client.AccountGroupByIdAudit byIdAudit = new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit(group).memberAudit(memberAudit).memberAudit(memberAudit).byIdAudit(byId).byIdAudit(byId).byIdAudit(byId).byIdAudit(byId).toIdAudit(byId).byIdAudit(byId).byIdAudit(byId).toIdAudit); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.name = "Anonymous-Users.name", value = "CreateGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Custom names are registeredUsers is inactive Users", "Create Users is inactive users is"); gApi.groups().create(users).get("initial Users is inactive users is"); }
com.google.gerrit.server.api.changes.RobotCommentApiImpl create(com.google.gerrit.server.change.RobotCommentResource c);
private com.google.gerrit.extensions.common.AuthInfo getAuthInfo(com.google.gerrit.server.config.AuthConfig cfg, com.google.gerrit.server.account.Realm realm) { com.google.gerrit.extensions.common.AuthInfo info = new com.google.gerrit.extensions.common.AuthInfo(); info.authType = cfg.getAuthType(); info.useContributorAgreements = new java.util.ArrayList(realm.getEditableBoolean(cfg.getEditsContributorAgreements()); info.edAccountField = cfg.getBoolean(realm.getEditsBoolean(cfg.getBooleanSuggestionInfo()); info.changeAccount = cfg.getBoolean(realm.getEditUrl()); info.gitBasicAuthPolicy = cfg.getGitBasicAuthPolicy(); if ((info.useContributorAgreements)!= null) { java.util.Collection<com.google.gerrit.common.data.ContributorAgreements> agreements = projectCache.getAllProjects().getConfig(); if (!(info.useContributorAgreements)) { info.contributorAgreements = com.google.common.collect.Lists.newArrayListWithCapacity(agreements.size()); for (com.google.gerrit.common.data.ContributorAgreement agreement : agreements) { info.contributorAgreements.add(agreements.getConfig().getConfig().getConfig()); } } } switch (info.authType) { case LDAP : case LDAP : case LDAP_BIND : info.editUrl = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterUrl(); info.registerText = cfg.getRegisterUrl(); info.registerText = cfg.getString(); break; case HTTP_LDAP : info.loginText = cfg.getRegisterUrl(); break; case HTTP_LDAP : case HTTP_LDAP : case HTTP_LDAP : case HTTP_LDAP : case CLIENT_SSL_SSL_LDAP : info.loginText = true; default : throw new java.lang.IllegalArgumentException(("CERT_LDAP_LDAP_LDAP_LDAP
@org.junit.Test public void pushToReviewersForAllSubmitOnSubmitOnSubmitOnSubmitOnSubmit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectState = new com.google.gerrit.reviewdb.client.Branch.NameKey(adminGroupUUID()), "update not allowed"); updateToReview(allUsers, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID())); java.lang.String changeId = "g.getCommitId(); com.google.gerrit.reviewdb.client.RefNames.refsGroupsForAll(adminGroupUUID, adminGroupUUID); if ((all)!= null) { update notAllowed = pushFactory.create(db, adminGroupUUID, "not allowed to update not allowed"); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "groups.name = "Anonymous-Users.name", value = "CreateGroup_Conflict() throws java.lang.Exception { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Create new users that you users already exists"); gApi.groups().create("Create"); }
@org.junit.Test public void createDuplicateSystemConfigSensitive_Conflict() throws java.lang.Exception { java.lang.String newGroupName = "test"; exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Create new users that you successfully created"); gApi.groups().create(newGroupName); }
private void testDeleteGroupBranchBranchBranchBranch, java.lang.String groupRef) throws java.lang.Exception { grant(allUsers, RefNames.RETRY_USERS, true, com.google.gerrit.acceptance.api.accounts.REGISTERED_USERS); org.eclipse.jgit.junit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> allUsersRepo = cloneProject(allUsers); org.eclipse.jgit.transport.PushResult r = com.google.gerrit.acceptance.GitUtil.deleteRef(allUsersRepo, groupRef); assertThat(refUpdate.getStatus()).containsExactly(RefUpdate.Result.REJECT_OTHER_REASON); assertThat(refUpdate.getStatus()).isNotNull(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { assertThat(refUpdate.getStatus()).isNotNull(); assertThat(refUpdate.getMessage()).contains("not allowed to delete account"); } }
private void pushToGroupBranchForReviewersForSubmit(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedError) throws java.lang.Exception { assume().that(groupsInNoteDb()).isTrue(); grant(groupsInNoteDb()).isTrue(); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "2"), 2, project, false, com.google.gerrit.reviewdb.client.AccountGroup.Id accountId, false); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + ":group")); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + ":group")); org.eclipse.jgit.TestRepository<org.eclipse.jgit.internal.storage.dfs.InMemoryRepository> repo = cloneProject(project); com.google.gerrit.acceptance.GitUtil.fetch(repo, (groupRefNames.REFS_GROUPS) + ":group")); repo.reset("group"); com.google.gerrit.acceptance.PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "accounts/for/master", "groupRef"); r.assertOkStatus(); assertThat(r.getChange().getDest().get()).isEqualTo(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); if (expectedError!= null) { exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("not allowed to update not allowed"); } gApi.changes().id(r.getChangeId()).current().submit(); }
@org.junit.Test public void pushToGroupNamesIsRejectedForAllUsersRepo() throws java.lang.Exception { assume().that(groupsInNoteDbProvider.assertNotUsedNoteDb(com.google.gerrit.acceptance.api.group.GroupBackend.REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE); assertThat(groups).hasSize(1); }
@org.junit.Test public void pushToDeletedGroupBranchRefStateIsRejected() throws java.lang.Exception { java.lang.String groupRef = com.google.gerrit.reviewdb.client.AccountGroup.UUID.refsDeletedGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(gApi.groups().create(name("foo")).get().id)); createBranch(allUsers, groupRef); assertPushToGroupBranch(allUsers, groupRef, "Update not allowed"); }
@org.junit.Test public void createDuplicateInternalGroupSensitive() throws java.lang.Exception { java.lang.String df = name("duplicate"); gApi.groups().create(dupGroupName); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage((("Duplicate " + buckGroupName) + "\" already exists")); gApi.groups().create(duplicateName); }
private void assertPushToGroupBranchBranch(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnUpdate) throws java.lang.Exception { grant(project, project, "*"), permission.CREATE_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), permission.user, false, com.google.gerrit.server.group.RefNames.REFS_USERS); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + "*"), perm, perm, false, com.google.gerrit.reviewdb.client.AccountGroup.Id accountId = ((com.google.gerrit.reviewdb.client.RefNames.REFS_USERS) + "*"), perm.PUBLOCKED, false, perm.create(Permission.PUBLOCKED_USERS, false, false, com.google.gerrit.acceptance.api.group.RefNames.REFS_USERS); grant(project, RefNames.REFS_GROUPS, RefNames.PUSH_USERS, false, perm.name(), false, com.google.gerrit.acceptance.api.account.GroupRepositoryManager.GROUP_UUID, RefNames.REFS_USERS); grant("group",Permission.CREATE_GROUPS, perm.PUSH_USERS); com.google.gerrit.acceptance.TestAccountGroup r = pushFactory.create(db, admin.getIdent(), accountCache.get(userRefName), "user content"); repo.reset("user"); com.google.gerrit.server.git.Git.Result r = pushFactory.create(db, admin.getIdent(), repo, "updateRef", "User", "Account:user")); if (r.assertErrorOnUpdate(expectedErrorOnUpdateOnUpdate(expectedMessage, "Update on update", true); } else { r.assertErrorStatusOnUpdate(expectedErrorOnUpdate(expectedUpdate); } }
private void assertCreateGroupBranchBranch_NameKey(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String expectedErrorOnCreate) throws java.lang.Exception { grant(project, "refs/for/master", false, com.google.gerrit.reviewdb.client.AccountGroup.Id accountId); grant(project, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), permission, false, com.google.gerrit.acceptance.rest.group.InMemoryRepositoryManager.create(project, admin.getIdent(), accountConfig.get(), false), userProvider.create("user", "user"), permission, group.getCreatedOnCreate()); }
@org.junit.Test public void onlyVisibleGroupsReturned() throws java.lang.Exception { java.lang.String newGroupName = name("newGroup"); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = "newGroup"; in.description = "Create group"; in.ownerId = adminGroupUUID().get(); gApi.groups().create(in); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).doesNotContainKey(newGroupName); setApiUser(admin); gApi.groups().list().addMembers(newGroupName); setApiUser(admin); gApi.groups().id(newGroupName).addMembers(user.username); setApiUser(user); assertThat(gApi.groups().list().getAsMap()).containsKey(newGroupName); }
@org.junit.Test public void pushToGroupBranchIsRejectedForAllUsersRepo() throws java.lang.Exception { pushToReviewDbChangeBranchRefs(adminUUID, "groupUUID"); assertThat(groups).isTrue(); }
@org.junit.Test public void groupDescription() throws java.lang.Exception { java.lang.String name = name("group"); gApi.groups().create(name).description(); java.lang.String desc = "description"; gApi.groups().id(name).descriptionFor(name); assertThat(gApi.groups().id(name).isEmpty(); java.lang.String desc = "Anonymous description for the description"; gApi.groups().id(name).description(desc); assertThat(gApi.groups().id(name).isEqualTo(desc); assertThat(gApi.groups().id(name).description).isEqualTo(desc); gApi.groups().id(name).description(""); assertThat(gApi.groups().id(name).description()).isEmpty(); assertThat(gApi.groups().id(name).description()).isEmpty(); }
@org.junit.Test public void reindexPermissions() throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount groupOwner = accountCreator.user2(); com.google.gerrit.extensions.api.groups.GroupInput in = new com.google.gerrit.extensions.api.groups.GroupInput(); in.name = name("group"); in.members = java.util.Collections.singleton(groupOwner).stream(groupOwner); in.members = java.util.Collections.singleton(groupOwner).stream(groupOwner); in.visibleToAll = true; com.google.gerrit.extensions.common.GroupInfo group = gApi.groups().create(in).get(); setApiUser(admin); gApi.groups().id(group.id).index(); setApiUser(group.id); gApi.groups().id(group.id).index(); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.AuthException.class); exception.expectMessage("Not allowed to index not allowed to index"); gApi.groups().id(group.id).index(); }
@org.junit.Test public void createDuplicateSystemGroupInsensitive() throws java.lang.Exception { java.lang.String newGroupName = "testusers/"); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("Create new users that you already exists"); gApi.groups().create(newGroupName); }
private com.google.gerrit.extensions.common.ChangeConfigInfo getChangeInfo(org.eclipse.jgit.lib.Config cfg) { com.google.gerrit.extensions.common.ChangeConfigInfo info = new com.google.gerrit.extensions.common.ChangeConfigInfo(); info.allowBlame = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowBlame", true)); info.allowDrafts = com.google.gerrit.server.config.GetServerInfo.toBoolean(cfg.getBoolean("change", "allowDrafts", true)); boolean hasAssigneeInIndex = indexes.getSearchIndex().hasField(ChangeField.ASSIGNEE); info.showAssigneeInChangesTable = indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE); info.showAssigneeInChangesTable = com.google.gerrit.server.config.GetServerInfo.toBoolean(((cfg.getBoolean("change", "showAssigneeInChangesTable", false)) && hasAssigneeInIndex)); info.largeChange = cfg.getInt("change", "largeChange", 500); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getBoolean("change", false))? a) : "largeChange", 500); info.replyTooltip = (java.util.Optional.ofNullable(cfg.getBoolean("change", null, "replyTooltip")).orElse("Reply and score")) + " (Shortcut: a)"; info.updateDelay = ((int) (com.google.gerrit.server.git.ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 300, java.util.concurrent.TimeUnit.SECONDS))); info.submitWholeTopic = com.google.gerrit.server.git.MergeSuperSet.wholeTopicEnabled(cfg); return info; }
private com.google.gerrit.extensions.common.GerritInfo getGerritInfo(org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.config.AllProjectsName allProjectsName, com.google.gerrit.server.config.AllUsersName allUsersName) { com.google.gerrit.extensions.common.GerritInfo info = new com.google.gerrit.extensions.common.GerritInfo(); info.allProjects = allProjectsName.get(); info.allUsers = allUsersName.get(); info.reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = cfg.getString("gerrit", null, "reportBugUrl"); info.reportBugText = getDocUrl(cfg); info.docSearch = docSearcher.isAvailable(); info.editGpgKeys = com.google.gerrit.server.config.GetServerInfo.toBoolean(((enableSignedPush) && (cfg.getBoolean("gerrit", null, "editGpgKeys", true)))); info.webUis = java.util.EnumSet.noneOf(com.google.gerrit.extensions.client.UiType.class); if (gerritOptions.enableGwtUi()) { info.webUi = java.util.EnumSet.noneOf(com.google.gerrit.extensions.client.UiType.class); if (gerritOptions.enableGwtUi()) { info.webUi.add(UiType.GWTIP); } } return info; }
@java.lang.Override public com.google.gerrit.extensions.common.ServerInfo apply(com.google.gerrit.server.config.ConfigResource rsrc) throws java.net.MalformedURLException { com.google.gerrit.extensions.common.ServerInfo info = new com.google.gerrit.extensions.common.ServerInfo(); info.accounts = getAccountInfo(accountVisibilityProvider); info.auth = getAuthInfo(authConfig, realm); info.change = getDownloadInfo(config); info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats); info.gerrit = getGerritInfo(config, allProjectsName, allUsersName); info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.plugin = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.defaultTheme = getPluginInfo(); if (java.nio.file.Files.exists(sitePaths.site_theme)) { info.sshd = getSuggestInfo(config); info.urlAliases = getUrlAliasesInfo(config); info.urlAliases = getUrlAliasesInfo(config); info.urlAliases = null; } info.urlAliases = getUrlAliasesInfo(anonymousCowardName); return info; }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource>> views() { return views; }
@java.lang.Override public void check() throws com.google.gerrit.server.StartupException { java.lang.String invalid = cfg.getSubsections("groups").stream().filter(( sub) -> { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(sub); com.google.gerrit.server.account.GroupBackend groupBackend = util.group(uuid); return (group == null)? uuid.get(uuid)) : ("'" + uuid); }).map((("'" + u) + "':")); if (!(invalidators.isEmpty())) { throw new com.google.gerrit.server.plugins.StartupException(java.lang.String.format(("Cannot validate the validators of '%s in the invalid '%s in the gerrit-config\n" + ": invalid"), invalidUsers.get())); } }
@org.kohsuke.args4j.Option(name = "--query", aliases = { "-q" }, usage = "--change-Id: " + (descuator) + " to lookup") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { addGroup(uuid); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.server.group.GroupResource rsrc = groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromDecoded(groupName)); com.google.gerrit.extensions.common.NameInput input = new com.google.gerrit.extensions.common.NameInput(); input.name = newGroups.apply(rsrc, input); putName.apply(rsrc, input); } catch (com.google.gerrit.extensions.restapi.RestApiException | org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw die(e); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup> getGroupFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUUID).toList(); if ((accountGroups.size()) == 1) { return java.util.Optional.of(com.google.gerrit.server.account.Iterables.getOnlyElement(accountGroups)); } else if (accountGroups.isEmpty()) { return java.util.Optional.emptyList(); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot apply group UUID " + groupUUID)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.BranchResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), org.eclipse.jgit.lib.ObjectId.fromString(parent.getRevision()), id.get()); }
@org.junit.Test public void readPluginConfigGroupReferenceNotInGroupsFile() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("groups", " + (staff.toConfigValue()))).create(); update(rev); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); assertThat(cfg.getValidationError()).hasSize(1); assertThat(com.google.common.collect.Iterables.getOnlyElement(cfg.getValidationError()).containsExactly((("Account " + (staff.getName())) + " is not in ") + (GroupList.FILE_NAME)) + " in ") + (GroupList.FILE_NAME))); }
@org.junit.Test public void editConfigMissingGroupTableEntry() throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit rev = tr.commit().add("groups", com.google.gerrit.server.git.ProjectConfigTest.group(developers)).add("groups", "exclusiveGroupPermissions = read", ((("project.config\n" + " exclusiveGroupPermissions = read submit\n") + " submit = account\n") + " upload = account\n") + " upload = accountCreator.getAccessSection("refs/heads/*"); com.google.gerrit.server.git.ProjectConfig cfg = read(rev); com.google.gerrit.common.data.AccessSection section = cfg.getAccessSection("refs/heads/*"); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(Permission.SUBMIT)); submit.add(new com.google.gerrit.common.data.PermissionRule(cfg.resolve(staff))).isEqualTo((((("Project " + (((((project.config.config.config)) + " exclusiveGroupPermissions = read submit\n") + " submit\n") + " submit = read submit\n") + " submit = account\n") + " submit = account\n") + " upload = account\n") + " upload = account\n") + " upload = accountCreator.config\n")); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.access.View<com.google.gerrit.server.access.AccessResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.access.AccessResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.api.projects.TagInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Cannot merge " + (resource.getTagInfo().ref)) + "\" already exists")); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { permissionBackend.user(user).ref(RefPermission.DELETE).check(RefPermission.DELETE); if (!(queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) { return com.google.gerrit.server.group.GroupOptions.createOptions(resource.getGroup()); }
@org.kohsuke.args4j.Option(name = "-o", usage = "add options") public void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--query2", aliases = { "-q2" }, metaVar = "query2" }, usage = "query2" }, usage = "query2" + "query") public void setQuery(java.lang.String query) { this.query = query; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.DashboardInfo apply(com.google.gerrit.server.project.DashboardResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if ((inherited) && (!(rsrc.isProjectDefault()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("project default must be specified"); } if (rsrc.isProjectDefault()) { rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser()); } if (rsrc.isProjectDefault()) { try { rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser()); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } } return com.google.gerrit.server.project.DashboardsCollection.parse(rsrc.getProjectState().getProject(), rsrc.getRefName(), rsrc.getConfig().getProject(), rsrc.getConfig(), rsrc.getConfig().getName(), rsrc.getConfig().getProjectState(), rsrc.getConfig().getName(), rsrc.getConfig().getName(), rsrc.getConfig().getName(), true); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { return parse(projectState, user, id); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(2).split(id).split(id)); java.lang.String ref = com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); return dashboards.parse(new com.google.gerrit.server.project.ProjectResource(projectState, user), com.google.gerrit.extensions.restapi.UrlString.fromUrl(((ref + ':') + path))); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.RobotCommentResource>> views() { return views; }
@org.junit.Test public void byOwner() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo ownerGroup = createGroup(name("owner "group")); com.google.gerrit.extensions.common.GroupInfo group = createGroupWithOwner(name("group"), ownerGroup); createGroup(name); assertQuery(("owner:group2"), group, (ownerGroup.id))); assertQuery(("owner:user\n" + (ownerGroup.id))); assertQuery(("owner:group:" + (ownerGroup.name)), group, group); }
@java.lang.Override public com.google.gerrit.server.change.RobotCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.RobotComment c : commentsUtil.robotCommentsByPatchSet(notes.getPatchSet().getId())) { if (uuid.equals(c.key.uuid)) { return new com.google.gerrit.server.change.RobotCommentResource(id, c); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@org.junit.Test public void byName() throws java.lang.Exception { assertQuery("name:non-existing"); group = createGroup(name("Group")); assertQuery(("name:" + (group.name)), group); assertQuery(("name:" + (group.name.toLowerCase(Locale.USERS)))); groupWithExceeded = createGroup(name); assertQuery(("name-with-with-match-match-match-with-match-match-match-with"))); }
@org.junit.Test public void byDefaultField() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroup(name("foo-account-account" + "foo-account")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup(name("group2"), ("group3 must contain a group2" + "some group2 not exist or group")); assertQuery("non-existing"); assertQuery("foo", group3, group3); assertQuery("foo", group3, group3); assertQuery("foo", group2, group2); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); if (Patch.COMMIT_MSG.equals(path)) { java.lang.String msg = getMessage(rsrc.getRevision().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_X_MESSAGE_MESSAGE).base64(); } else if (Patch.MERGE_LIST.equals(path)) { byte[] mergeList = getMergeList(rsrc.getRevision().getNotes()); return com.google.gerrit.extensions.restapi.BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64(); } return fileContentUtil.getContent(projectCache.checkedGet(rsrc.getRevision().getProject()), org.eclipse.jgit.lib.ObjectId.fromString(rsrc.getRevision().getRevision().get()), path, parent); }
@org.junit.Test public void fixCommitPostCommitsAllAuditsAllAuditsAsAudits() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.util.concurrent.IntStream s = com.google.common.TimeUtil.nowTs(); java.util.concurrent.TimeMillis now = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep(1, java.util.concurrent.TimeUnit.SECONDS); com.google.gerrit.server.group.GroupBranchBranchBranchBranchBuilder b = com.google.gerrit.server.group.GroupRebuilderTest.Builder.Builder.buildWithClockStep(g).byId(g, "x"), byId(g, "x"), byId(g, "x"), byIdAudit(addId(g, "x"), byIdAudit(addId(g, "x"), byIdAudit(addId(g, "x"), ordering)).build(); rebuild(repo, b, null); assertNoSuch(db, b, "open"); assertThat(log).hasSize(3); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log.get(0), "fatal: x@example.com", c.com", "Inserter"); assertThat(log.get(2), log.committer.get(2), "Insert-stream"); assertThat(log.fromImmutableList)).isEqualTo(log.date).isEqualTo(toImmutableList()); assertThat(log.get(0).named(toImmutableList)).isEqualTo(log.warn(future); }
@org.junit.Test public void memberAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t2 = com.google.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.GroupBackend b = groupBackend.builder().group(g).members(g).member(g, 1, t2).addAll(addMember(g, 1, t2).build(); rebuild(repo, b, null, "Remove member").build(); rebuild(repo, b, null, null); assertMigration.rebuild(g), b); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertThat(log.get(0), "2@example.com", "Update log "Update log ").hasSize(4); assertCommit(log.get(1), "2 admin2@server/id1@example.com")); assertCommit(log.get(1), "Inserter"); assertCommit(log.get(1), "Omitting "Change 2", "O@server/id 1 "2@server/id")); assertCommit(log.get(2), "Change2 "2@server/id1@server/id")); }
@org.junit.Test public void unauditByIdEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.GroupBranchBranch b = com.google.gerrit.server.group.GroupRebuilderTest.builder().group(g).group(g).byId(g, "x"), byId(g, "x"), byIdAudit(addId(g, "x"), byIdAudit(addId(g, "x"), byIdAudit(addId(g, "x"), ordering.get()); assertNotFound(reload(reload(g), "Failed to update"); assertCommit(log).hasSize(3); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(("Failed to determine " + "Failed to index ") + "O")); assertServerCommit(log.get(1), "O"); assertServerCommit(log.get(2), "I-id"); }
@org.junit.Test public void applyByIdAuditsAreIgnored() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t2 = com.google.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t3 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t4 = com.google.gerrit.common.TimeUtil.nowTs(); java.sql.Timestamp t5 = com.google.gerrit.server.group.GroupBackend.builder().group(g).byId().byId(add(addByIdAudit(add("x", "x", 8), t4, t4); addAndRemove(g, "x", "x", 9, 9, 5, t4); assertNoRemove(g, "x", u4, "x", 9, t4); assertNoRemove(g, "x", u4, t); assertMovedClean(repo, b, null); com.google.gerrit.extensions.common.CommitInfo log = log(g); assertThat(log).hasSize(3); assertCommit(log.get(1), b, "Unexpected update " + (com.google.gerrit.extensions.common.CommitInfo.fromJson(g), b.get(1), "O").update(2); assertCommit(log.get(2), "O").update(2); }
@org.junit.Test public void unauditMembershipsOfEnd() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.GroupBranchBranchBuilder b = newGroup(g).members(g).members(g, 1).member(g, 2), member(g, 4).build(); rebuild(addMember(g, 1, 8, "g"), com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder(reload(g); assertThat(log).hasSize(3); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(3); assertThat(log.get(0), "I-server/mail: " + (c.get(1), "O@gerrit-id1@example.com") @java.lang.Override public void testRepo(com.google.gerrit.extensions.common.CommitInfo info) { assertThat(log.get(1), "Omitting "O")).isEqualTo("Uploaded " + "O: "O")); assertServerCommit(log.get(2), "2@gerrit-id2@server.id2@server.id2@gerrit-id2")); } }); }
@org.junit.Test public void integrateAtSameTimestampWhenUserAndType() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp ts = com.google.gerrit.common.TimeUtil.nowTs(); int user1 = 8; com.google.gerrit.server.group.GroupBundle b = com.google.gerrit.server.group.GroupBackend.builder().group(g).members(g).add(g, 1).member(g, 2), member(g, user1).member(g, 2), addMember(g, "g", uuid, "x"), byId(g, user1, "x")).byId(g, user1, user1).byId(g, "y").byId(g); addById(g, "y", u, "y", user1, "y", user2).byId(g); addById(g, "y", user2, "y", user2, "y", user2).build()); add(g, "y", "y", user2); assertNotFound(log.get(0), logDebug("Failed to update " + (("\n")), add(log, "fromId: ") + (("x ") + "O")), build()); assertCommit(log.get(1), testRepo.get(0), "foo@example.com"); com.google.gerrit.extensions.common.CommitInfo log = log(log.get(2), "fatal: Group d2"); assertCommit(log.get(2), "Change 1: " + (("\n" + "Change-id1\n") + "Commit: ")")), "Commit:9@example.com"); assertCommit(log.get(2), assertCommit.get(2), "Commit 2 "Commit 2", "9.9.name()"); assertCommit(log.get(2), "9.get(2).isEqualTo("server-id 1 " + "9:9:9:9:9"); com.google.gerrit.extensions.common.CommitInfo> group2 = group2.get
@org.junit.Test public void byIdAudit() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); java.sql.Timestamp t2 = com.google.common.TimeUtil.nowTs(); java.sql.Timestamp t2 = com.google.gerrit.common.TimeUtil.nowTs(); com.google.gerrit.server.group.GroupBackend b = groupBackend.builder().group(g).byId(g, "x", u2, "x", u2).byId(addId(addId(g, "x", 8), addId(g, "y", u2), "y", t3).build(); rebuild(repo, b, null, null); assertNoSuch(reloadByIdCommit(g), b, null); assertCommit(log).hasSize(4); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertCommit(log.get(1), "Omitting o " + "O")); assertCommit(log.get(2), "O").call(); assertCommit(log.get(2), "O "O")); assertCommit(log.get(2), "9 "server group "x/id"); }
@org.junit.Test public void membersAndSubgroups() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.GroupBranchBuilder b = newGroupBuilder().group(g).members(g).members(g, 1).byId(g, "x"), byId(g, "x")).build(); rebuilder.rebuild(repo, b, b, null); assertThat(log).hasSize(2); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(gw); assertThat(log).hasSize(2); assertThat(log.get(0).hasSize(2); assertServerCommit(log.get(0), ("Key is " + (("\n" + "X-server-id\n") + "Key: ") + (("\n") + "Key2\n") + "Branch: Code-id\n")); }
@org.junit.Test public void allGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); g.setDescription("Description"); g.setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("owner")); g.setVisibleToAll(true); com.google.gerrit.server.group.GroupBundle b = com.google.gerrit.server.group.GroupRebuilderTest.builder().group(g).build(); rebuilder.rebuild(g); assertThat(commands).hasSize(1); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertThat(log.get(0).isEqualTo(1); }
@org.junit.Test public void memberAuditLegacyLegacy() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.GroupBranchBranchBranch b = com.google.gerrit.server.group.GroupRebuilderTest.builder().group(g).members(g).member(g, 1, 8, com.google.gerrit.common.TimeUtil.nowTs()).build(); rebuilder(reloadAndLegacyRemoveMember(g, 1, 8, 8, 8, com.google.gerrit.common.TimeUtil.nowTs())).build(); rebuilder(reload(g); assertThat(log).hasSize(4); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(4); assertThat(log.get(1), "I-server/mail.get(1), "Omitting o "@server/project-id"); assertCommit(log.get(1), "Omitting o "@server/server-id: ").isEqualTo-id"); assertCommit(log.get(2), "Omitting "O "@server/server-id - "@server-id"); }
@org.junit.Test public void defaultGroupFields() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup g = newGroup("a"); com.google.gerrit.server.group.GroupBranchBuilder b = newGroupBuilder().group(g).build(); rebuild(reload(g).build(); rebuild(reload(repo, b, null); assertThat(log).hasSize(1); com.google.common.collect.ImmutableList<com.google.gerrit.extensions.common.CommitInfo> log = log(g); assertThat(log).hasSize(1); assertCommit(log.get(0), "accounts/email addresses"); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.project.FileResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { return fileContentUtil.getContent(rsrc.getProjectState(), rsrc.getPath(), rsrc.getPath(), null); }
@org.junit.Test public void byDescription() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo group1 = createGroupWithDescription(group1), "test test a test a test"); accountGroup2 = createGroupWithDescription(name("group2"), "group 1."); assertQuery("description: test", group1, group2); assertQuery("description:non-existing"); assertQuery("description", group2, group2); assertQuery("description", group2, group2); assertQuery("description:\""); }
@org.junit.Test public void bySubsections() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(GroupField.SUBGROUP_SUBGROUP); assertMissingQuery("subgroup:someGroup:someGroup"); } com.google.gerrit.extensions.common.GroupInfo parentGroup1 = createGroup(name("superGroup1"); com.google.gerrit.extensions.common.GroupInfo parentGroup = createGroup(name("parentGroup1")); com.google.gerrit.extensions.common.GroupInfo parentGroup2 = createGroup(name("parentGroup2")); gApi.groups().id(superParentGroup1.id).addGroups(parentGroup1.id); gApi.groups().id(parentGroup1.id).addGroups(parentGroup1.id); assertQuery(("subgroup:subgroup1.id + (parentGroup2.id)) + ":supergroup")); gApi.groups().id(parentGroup2.id).addGroups(parentGroup1, parentGroup1, parentGroup1); assertQuery(("subgroup:" + (parentGroup1.id)) + "parentGroup")), superGroup1, group2); gApi.groups().id(superGroup1.id).removeGroups(parentUUID); assertQuery(("subgroup: " + (subgroup.id))), superGroup, group2); }
@org.junit.Test public void byMember() throws java.lang.Exception { if ((getSchemaVersion()) < 4) { assertMissingField(group1, "User1", "user1@example.com"); return; } com.google.gerrit.extensions.common.AccountInfo user1 = createAccount("user1", "User1", "user2@example.com"); com.google.gerrit.extensions.common.AccountInfo user2 = createAccount("group2", "User2", "user2@example.com"); com.google.gerrit.extensions.common.GroupInfo group1 = createGroup("group2", "User2", user2); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup(name("group2"), user1); assertQuery(("member:" + (user1.name)), group1, group1); group3 = query("member:" + (user1.name)), group1, group1); gApi.groups().id(group1.id1.username).removeMembers(user1.email); group2.addMembers(group3.id); assertQuery(("member:" + (user1.name))); group1, group1, group1); }
@org.junit.Test public void byInname() throws java.lang.Exception { java.lang.String name = getSanitizedMethodName(); nameKey = com.google.common.base.CharMatcher.is('_').removeFrom(namePart); com.google.gerrit.extensions.common.GroupInfo group2 = createGroup((("account-" + namePart) + "-2") + "3")); com.google.gerrit.extensions.common.GroupInfo group3 = createGroup(((account-" + namePart) + "3")); group3 =("invisible:") + nameKey, group2); assertQuery(("invisible:" + nameKey.toUUID(name)); assertQuery(("inname:" + (namePart.toUUID(java.util.Locale.USERS))), group2, group2, group2, group2); assertQuery(("inname:" + (namePart.toUUID(java.util.Locale.USERS))), group2, group2, group2); }
@org.junit.Test public void byIsVisibleToAll() throws java.lang.Exception { assertQuery("is:visible to:visible"); com.google.gerrit.extensions.common.GroupInfo groupThat = createGroupThat(name("account-is-visible-is-visible-to-visible-visible-to-visible-visible")); createGroup(name("group" + "access")); assertQuery("is:visible", groupThat(group))); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void deleteGroup_Conflict() throws java.lang.Exception { allow(allUsers, com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS_GROUPS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), permission.user, com.google.gerrit.acceptance.rest.project.RefNames.refsUsers(adminGroupUUID, "*"), permission.PUSH, com.google.gerrit.acceptance.rest.project.RefNames.refsGroups(adminGroupUUID, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID))).delete(); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Cannot merge " + (rsrc.getRef())) + "\" already exists")); }
com.google.gerrit.server.api.changes.CommentApiImpl create(com.google.gerrit.server.change.CommentResource c);
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Move change").setTitle("Move change to a change"); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getProjectState().getProject().getDescription()); }
private com.google.gerrit.server.project.ProjectResource checkExists() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((project) == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(name); } return project; }
com.google.gerrit.server.api.projects.ProjectApiImpl create(com.google.gerrit.server.api.projects.ProjectResource project);
@java.lang.Override public void onPreMerge(org.eclipse.jgit.lib.Repository repo, com.google.gerrit.server.git.CodeReviewCommit commit, com.google.gerrit.server.project.ProjectState destProject, com.google.gerrit.reviewdb.client.Branch.NameKey destBranch, com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId, com.google.gerrit.server.IdentifiedUser caller) throws com.google.gerrit.server.git.validators.MergeValidationException { if ((!(allUsersName.equals(destProject.getNameKey()))) || (!(com.google.gerrit.server.IdentifiedUser.get())))) { return; } throw new com.google.gerrit.server.git.validators.MergeValidationException("Not allowed to update not allowed to update not allowed"); }
public static AccountGroup.UUID create(java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent author) { java.security.Message m = com.google.common.base.CharMatcher.newMessage(); md.setMessage(("Cannot create " + groupName)); md.update(org.eclipse.jgit.lib.Constants.encode((" " + (creator.toExternalString())))); }
@org.junit.Test public void createdOnIsPopupToGroupsCreated() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup("accounts/for schema"); setCreatedOn(groupId); removeAuditEntriesForGerritUser(groupId); deleteAuditData(db, new com.google.gerrit.testutil.TestUpdateUI()); java.sql.Timestamp createdOn = getCreatedOn(groupId); assertThat(createdOn).isEqualTo(com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs()); }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState project, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId())!= null)? ref.getObjectId().name() : null; info.canDelete = ((Tasks.contains(ref.getName())) && (perm.testOrFalse(RefPermission.DELETE))) && (perm.testOrFalse(RefPermission.DELETE)))? true : null; com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.server.project.BranchResource(projectState, user, rsrc); for (com.google.gerrit.extensions.webui.UiAction d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new com.google.gerrit.extensions.common.ActionInfo(d.getId(), new com.google.gerrit.extensions.common.ActionInfo(d)); } info.actions = (d.getId())? null : links.actions.get(r)); info.webLinks = (links.isEmpty())? null : links; } java.util.List<com.google.gerrit.extensions.common.WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty())? null : links; return info; }
com.google.gerrit.extensions.api.projects.BranchInfo toBranchInfo(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try (org.eclipse.jgit.lib.Repository r = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.lib.Ref r = db.getRef(rsrc.getRef()); if (r == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, com.google.common.collect.ImmutableList.of(r)).get(0); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> allBranches(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.util.List<org.eclipse.jgit.lib.Ref> refs = com.google.gerrit.server.permissions.PermissionBackend.openRepository(rsrc.getNameKey()).values(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey())) { java.util.Collection<org.eclipse.jgit.lib.Ref> heads = db.getRefDatabase().getRefs(Constants.R_HEADS).values(); refs.addAll(heads); refs.addAll(heads); refs.addAll(db.getRefDatabase().exactRef(Constants.REFS_CONFIG, RefNames.REFS_CONFIG, RefNames.REFS_USERS_CONFIG), null); refs.addAll(db, refs); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noGitRepository) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } return toBranchInfo(rsrc, refs); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.server.project.RefInfo>(org.eclipse.jgit.lib.Constants.R_HEADS).subString(matchSubstring(matchSubstring).regex(matchRegex).start(start).limit(limit).limit(limit(allBranches(rsrc)); }
private java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> toBranchInfo(com.google.gerrit.server.project.ProjectResource rsrc, java.util.List<org.eclipse.jgit.lib.Ref> refs) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Set<java.lang.String> targets = com.google.common.collect.Sets.newHashSetWithExpectedSize(1); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { targets.add(ref.getTarget().getName()); } } com.google.gerrit.server.permissions.PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey()); java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> branches = new java.util.ArrayList(refs.size()); for (org.eclipse.jgit.lib.Ref ref : refs) { if (ref.isSymbolic()) { java.lang.String target = ref.getTarget().getName(); if (!(perm.ref(target.ref.ref(target).test(RefPermission.READ))) { continue; } if (target.startsWith(Constants.R_HEADS)) { target = target.substring(Constants.R_HEADS.length()); } com.google.gerrit.extensions.api.projects.BranchInfo b = new com.google.gerrit.extensions.api.projects.BranchInfo(); b.revision = ref.getName(); b.revision = target; branches.add(b); if (!(Constants.R_HEAD.equals(ref.getName()))) { b.canDelete = (Ref(ref.getName()).testOrFalse(Ref.ref.ref.getName()).test(RefPermission.READ))? true : null; } continue; } if (perm.ref(ref.getName())) { branches.add(createBranch, ref, ref, ref, null); } } if (includes.ref.
@java.lang.Override public com.google.gerrit.server.project.ProjectResource resource(com.google.gerrit.extensions.api.projects.ProjectInput input) { com.google.gerrit.reviewdb.client.Project.NameKey project = resource.getNameKey(); com.google.gerrit.server.git.MultiProgressMonitor mgr = new com.google.gerrit.server.git.MultiProgressMonitor(com.google.common.io.ByteStreams.nullOutputStream(), "project", project).beginSubProgressMonitor("MultiProgressMonitor", project).beginSubpletion("MultiProgressMonitoring ProgressMonitor.UNKNOWN"); com.google.gerrit.server.index.change.AllChangesIndexer.setVerboseOut(null, "project", project)); @java.lang.SuppressWarnings("unused") java.util.concurrent.Future<java.lang.Void> ignored = executor.submit(allUsers.reindexProject(indexer, project, mgr, mgrtpt)); return com.google.gerrit.extensions.restapi.Response.accepted(("Reindexer indexer indexer for " + project) + " submitted for reindex")); }
@org.kohsuke.args4j.Option(name = "--owned", usage = "add the owner by the groups") void setOwnedBy(java.lang.String ownedBy) { this.owned = ownedBy; }
@org.kohsuke.args4j.Option(name = "--account", aliases = { "-g" }, metaVar = "GROUP", usage = "add to index") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { groupsToAdd.add(uuid); }
@org.kohsuke.args4j.Option(name = "-o", usage = "o", usage = "add options") void addOption(com.google.gerrit.extensions.client.ListGroupsOption o) { options.add(o); }
@org.kohsuke.args4j.Option(name = "--regex", aliases = { "-r" }, metaVar = "REGEX", usage = "REGEX", usage = "REGEX", usage = "REGEXACT") public void setMatchRegex(java.lang.String matchRegex) { this.matchRegex = matchRegex; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.TagInfo input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); permissionBackend.user(user).project(resource).ref(tag).check(RefPermission.DELETE).check(RefPermission.DELETE).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.server.query.QueryParseException getExceptionForUnsupportedOperation(java.lang.String operatorName) { return new com.google.gerrit.server.query.QueryParseException(java.lang.String.format("Unsupported operator for index version %s operator operator: %s", operatorName, operatorName)); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Authentication must be set"); } com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, user.getUserName())); if (extId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId newExtId = com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.email(), extId.email(), newPassword); externalIdsUpdate.create().upsert(newExtId); externalIdsUpdate.create().upsert(newPassword); return com.google.common.base.Strings.isNullOrEmpty(newPassword); }
@java.lang.Override public void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, com.google.gerrit.server.group.InternalGroupConfig config) throws org.eclipse.jgit.errors.ConfigInvalidException { int id = config.getInt(com.google.gerrit.server.group.GroupConfigEntry.SECTION_NAME, super.key, super.keySet()); if (id < 0) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("%s must be negative, found, found %s found", found, found, found)); } group.setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(id)); }
@java.lang.Override public com.google.gerrit.extensions.common.ProjectInfo apply(com.google.gerrit.server.project.ChildProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ((recursive) || (rsrc.isDirectChild())) { return json.format(rsrc.getChild().getProject()); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(rsrc.getChild().getProject()); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.GroupInfo> apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException.new com.google.gerrit.server.project.NoSuchGroupException((rsrc.getControl().isInternal()? "() : rsrc.getControl()))); return getDirections(group, rsrc.getControl()); }
private java.util.List<com.google.gerrit.reviewdb.client.Account.Id> suggestAccounts(com.google.gerrit.server.query.change.SuggestReviewers suggestReviewers) throws com.google.gwtorm.server.OrmException { try (com.google.gerrit.metrics.Timer0.Context ctx = metrics.queryAccountsLatency.start()) { try { com.google.gerrit.metrics.Timer0.Context result = queryProvider.get().setUserWithCapacity(((suggestReviewers.getLimit()) * (com.google.gerrit.server.change.ReviewersUtil.CANDONLY_LIST_MULTIP))).query(com.google.gerrit.server.query.change.Reviewers.CANDONLY_LIST_MULTIP); return result.entities().map(( a) -> a.getAccount().getId()).collect(java.util.stream.Collectors.toList()); } catch (com.google.gerrit.server.query.QueryParseException e) { return com.google.common.collect.ImmutableList.of(); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.AddSubmodule.PutSubscription create(com.google.gerrit.server.group.GroupResource group, com.google.gerrit.reviewdb.client.AccountGroup.Id id) { return new com.google.gerrit.server.group.AddSubsections.AddSubsections(addSubsections, id.get()); }
@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { com.google.gerrit.common.data.GroupDescription.Basic parent = resource.asInternalGroup().orElseThrow(Method.new com.google.gerrit.extensions.restapi.ResourceNotFoundException(Method.class, id).getGroup(); com.google.gerrit.common.data.GroupDescription member = groupsCollection.parse(TopLevelResource.INSTANCE, id).getGroup(); if ((resource.getControl().canSeeGroup()) && (com.google.gerrit.server.group.Subsections.isSubgroup(parent, member))) { return new com.google.gerrit.server.group.SubmoduleResource(resource, member); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource> list() { return list; }
com.google.gerrit.server.api.changes.DraftApiImpl create(com.google.gerrit.server.api.changes.DraftCommentResource d);
@org.kohsuke.args4j.Option(name = "--match", aliases = { "-m" }, metaVar = "MATCH", usage = "MATCH", usage = "add sub sub sub sub sub sub sub sub sub sub sub"; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupOptions apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.common.GroupOptionsInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Internal externalGroup = resource.asInternal(); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to determine all of the owner"); } if (!(resource.getControl().isOwner())) { input.visibleToAll = false; } if ((input.visibleToAll) == null) { input.visibleToAll = false; } if ((input.visibleToAll) == null) { input.visibleToAll())!= null) { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.create(group.getGroupUUID()); com.google.gerrit.server.group.GroupControl group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.setVisibleToAll(true, groupUpdate); try { groupsUpdateFactory.get().updateGroup(db.get(), groupUuid, group); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUUID)); } } return group; }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.project.ProjectResource resource) { com.google.gerrit.reviewdb.client.Project.NameKey parent = resource.getProject().getProject(); com.google.gerrit.reviewdb.client.Project.NameKey parentName = project.getParent(allProjectsName); return parentName!= null? parentName.get() : ""; }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.server.project.GarbageCollection.Input input) { com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getNameKey(); if (input.async) { return applyAsync(project, input); } return applyAsync(project, input); }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.project.ProjectResource rsrc) { return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Git GCGarbage collection for GC : com.google.gerrit.server.webui.UiCollection.Description.setLabel(GitGarbageCollection.getName()); }
protected com.google.gerrit.common.data.ContributorAgreement configureContributorAgreement(boolean autoVerify) throws java.lang.Exception { com.google.gerrit.common.data.ContributorAgreement ca; if (autoVerify) { java.lang.String g = createGroup(g); com.google.gerrit.extensions.common.GroupInfo groupApi = gApi.groups().id(g); groupApi.description("cla test"); com.google.gerrit.server.group.GroupReference group = group(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupApi.getGroupUUID().id)); com.google.gerrit.server.group.GroupReference group = new com.google.gerrit.common.data.GroupReference(groupReference); rule.setAction(PermissionRule.ALL); ca.setAutoVerify(group.getGroupUUID()); com.google.gerrit.common.data.PermissionRule rule = new com.google.gerrit.common.data.PermissionRule(group); rule.setAutoValue(groupRef); ca.setAutoMerge(groupRef); } else { ca = new com.google.gerrit.common.data.ContributorAgreements("cla-check"); ca.setAutoValue(groupRef); } return ca; }
@java.lang.Override public com.google.gerrit.server.change.FileResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) { return new com.google.gerrit.server.change.FileResource(rev, id.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.FileResource>> views() { return views; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { try { com.google.gerrit.extensions.api.projects.BanCommitInput input = com.google.gerrit.extensions.api.projects.BanCommitInput.fromCommit(commitsToBan, objectId::getName()); input.reason = reason; com.google.gerrit.server.project.BanCommit.BanResult r = banCommit.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), input); printCommits(r.new com.google.gerrit.server.project.ProjectResource(projectState, "", "the following commits were banned"); printCommits(r.alreadyBanned, "The following commits were ignored"); printCommits(r.identifiedBanned, ""); } catch (java.lang.Exception e) { throw die(e); } }
@java.lang.Override public void readFromConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID, com.google.gerrit.server.group.InternalGroupConfig config, org.eclipse.jgit.lib.Config config) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ownerGroupUUID = config.getString(com.google.gerrit.server.group.GroupConfig.SECTION_NAME, null, super.key); if (com.google.common.base.Strings.isNullOrEmpty(ownerGroupUUID)) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("Included group %s is not allowed to group %s", ownerUUID.get())); } group.setOwnerUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(ownerGroupUUID)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource project, DeleteBranchesInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((input == null) || ((input.branches) == null)) || (input.branches.isEmpty())) { throw new com.google.gerrit.extensions.restapi.BadRequestException("branches must be specified"); } deleteRefFactory.create(project).refs(input.branches).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override protected com.google.gerrit.extensions.common.CommentInfo applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.DraftCommentResource rsrc, DraftInput in) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException { if (((in == null) || ((in.message) == null)) || (in.message.trim().isEmpty())) { return delete.apply(updateFactory, rsrc, null); } else if (((in.id)!= null) && (!(rsrc.getId().equals(in.id)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must match URL"); } else if (((in.line)!= null) && ((in.line)!= null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must be >= 0"); } else if ((((in.line)!= null) && ((in.line)!= null)) && ((in.line)!= null)) { throw new com.google.gerrit.extensions.restapi.BadRequestException("line must be >= 0"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.PutDraftComment.Op op = new com.google.gerrit.server.change.PutDraft.Op(rsrc.getUser().getAccount(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs()))); bu.addOp(rsrc.getChange().getId(), op); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(rsrc.getChange().getId(), op); }
private java.util.Optional<com.google.gerrit.server.group.GroupsResult> updateGroupInNoteDb(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroupUpdate uuid) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository allUsers = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.load(allUsersRepo, groupUUID); if (!(groupConfig.getAccount().isPresent())) { return new com.google.gerrit.server.group.GroupConfig(com.google.gerrit.server.group.GroupConfig.loadForGroup(allUsers, groupUUID, this::getGroupName); } if (!(groupConfig.isPresent())) { throw new com.google.gerrit.common.errors.NoSuchGroupException(group); } return java.util.Optional.emptyMap(); } com.google.gerrit.server.group.GroupBackend.FindUpdate originalGroup = groupConfig.getLoadedGroup().get(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = groupUpdate.get(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = groupUpdate.get(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = groupUpdate.get(); com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName = groupUpdate.getNameKey(); groupName = groupCache.get(allUsersRepoManager, groupUUID, oldName, newName); commit(allUsersRepoManager, groupName); } catch (java.lang.IllegalStateException e) { com.google.gerrit.server.group.InternalGroupBackend.log.error("Cannot find new project", e); throw new java.lang.IllegalStateException("Unsupported operation", change.getName()).to
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id id, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> added, java.sql.Timestamp added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupListeners) { try { auditListener.onAddGroups(owner, added, added, added, added, added); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceService.log.error("Cannot log to log to log to log to log to log to log", e); } } }
private void addMembers(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddMembers.Input input = AddMembers.Input.fromMembers(initialMembers.stream().map(java.util.Collections.singleton(r)); addMembers.apply(rsrc, input); }
private void addSubgroups(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.AddSubmodule.Input input = AddSubsections.Input.fromGroups(InitialGroups.stream().map(Group).collect(java.util.stream.Collectors.toList())); addSubgroups.apply(rsrc, input); }
@org.kohsuke.args4j.Option(name = "--account", aliases = { "-g", usage = "group to be included in the group") void addGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID id) { initialGroups.add(id); }
@java.lang.Override public void replace(com.google.gerrit.server.group.InternalGroup group) throws java.io.IOException { io.searchbox.core.Bulk bulk = new io.searchbox.core.Bulk.Builder().defaultIndex(indexName).defaultType(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS).defaultAction(insert(com.google.gerrit.elasticsearch.ElasticGroupIndex.GROUPS, group)).refresh(true).build(); io.searchbox.client.JestResult result = client.execute(bulk); if (!(result.isSucceeded())) { throw new java.io.IOException(java.lang.String.format("Account %s in index %s: %s", group.getGroupUUID().get(), indexName, result.getErrorMessage())); } }
private void reportGroupsAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupUuidList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = groupList.stream().map(( uuid) -> groupCache.get(uuid).map(uuid).map(java.util.Objects::stream).collect(java.util.stream.Collectors.joining(util.join(group).getName(), names).getBytes(com.google.gerrit.sshd.commands.ENC)); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gerrit.sshd.commands.UnloggedFailure, java.lang.Exception { try { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid : groups) { com.google.gerrit.server.group.GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(groupUuid.get())); if (!(accountsToRemove.isEmpty())) { deleteMembersAction.apply(resource, fromMembers(accountsToRemove)); reportMembersAction("removed from", accountsToRemove); reportMembersAction("removed from", accountsToRemove); reportMembersAction("unremove", fromMembers(accountsToRemove)); reportMembersAction("removed from", accountsToRemove); reportMembersAction("unavailable", toMembers); reportMembersAction("from", toMembers); reportMembersAction("included from", toMembers); reportGroupsAction("included from", toMembers); reportGroupsAction("included from", toInclude); } if (!(groupsToInclude.isEmpty())) { addSubgroupsAction("Include"); reportGroupsAction("Include", toInclude); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e.getMessage()); } }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.Objects.firstNonNull(accountId).getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.toSet()); java.lang.String action = accountId.getPreferredEmail().getPreferredEmail(); if ((action.name())!= null) { out.write(java.lang.String.format("%s: %s: %s", action, action.getName(), action.getName(), actions.getBytes(com.google.gerrit.sshd.commands.ENC)); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.api.projects.ProjectInput input) throws com.google.gerrit.extensions.restapi.ResourceConflictException { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Cannot merge " + (resource.getName())) + "\" already exists")); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure { com.google.gerrit.extensions.api.projects.ConfigInput configInput = new com.google.gerrit.extensions.api.projects.ConfigInput(); configInput.submitType = submitType; configInput.useContributorAgreements = submitType; configInput.useContributorAgreements = contributorMerge; configInput.useContributorAgreements = signedOffBy; configInput.useContributorAgreements = state.useSignedOffBy(); configInput.useSignedOffBy = state.getProject().getState(); configInput.maxObjectSizeLimit = maxObjectSizeLimit; if ((com.google.common.base.Strings.emptyToNull(projectDescription))!= null) { configInput.description = projectDescription; } else { configInput.description = projectState.getProject().getDescription(); } try { putConfig.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), configInput); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw die(e); } }
com.google.gerrit.server.api.groups.GroupApiImpl create(com.google.gerrit.server.group.GroupResource rsrc);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo owner() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getOwner.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot get owner", e); } }
@java.lang.Override public void options(com.google.gerrit.extensions.common.GroupOptionsInfo options) throws com.google.gerrit.extensions.restapi.RestApiException { try { putOptions.apply(rsrc, options); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put options", e); } }
@java.lang.Override public void index() throws com.google.gerrit.extensions.restapi.RestApiException { try { index.apply(rsrc, new com.google.gerrit.extensions.common.Input()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot index", e); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> members(boolean recursive) throws com.google.gerrit.extensions.restapi.RestApiException { listMembers.setRecursive(recursive); try { return listMembers.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot list members", e); } }
@java.lang.Override public void removeMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot remove members", e); } }
@java.lang.Override public void name(java.lang.String name) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.NameInfo in = new com.google.gerrit.extensions.common.NameInput(); in.name = name; try { putName.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put name", e); } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo detail() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDetail.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve account", e); } }
@java.lang.Override public void addMembers(java.lang.String... members) throws com.google.gerrit.extensions.restapi.RestApiException { try { addMembers.apply(rsrc, AddMembers.Input.fromMembers(java.util.Arrays.asList(members))); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot add members", e); } }
@java.lang.Override public void description(java.lang.String description) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.Description in = new com.google.gerrit.extensions.common.Description(); in.description = description; try { putDescription.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put description", e); } }
@org.kohsuke.args4j.Option(name = "--member", aliases = { "-m" }, metaVar = "USER", usage = "USER to be set of users to be members of users to be members of users to be provided as members of the user of users that to be members of the user that you to be members of the user that are members of the user that to a user) { initialMembers.add(id); }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.Failure, com.google.gwtorm.server.OrmException, java.io.IOException { try { com.google.gerrit.server.group.GroupResource rsrc = createGroup(); if (!(initialMembers.isEmpty())) { addMembers(rsrc); } if (!(initialGroups.isEmpty())) { addSubmissions(rsrc); } if (!(initialGroups.isEmpty())) { addSubmissions(rsrc); } } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e); } catch (com.google.gerrit.extensions.restapi.RestApiException e) { throw die(e); } }
private com.google.gerrit.server.group.GroupResource createGroup() throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.extensions.api.changes.GroupInput input = new com.google.gerrit.extensions.api.changes.GroupInput(); input.visibleToAll = visibleToAll; input.visibleToAll = visibleToAll; if ((ownerGroupId)!= null) { input.ownerId = java.lang.String.valueOf(ownerGroup.get()); } com.google.gerrit.extensions.common.GroupInfo group = createGroupFactory.create(groupName).apply(TopLevelResource.INSTANCE, input); return groups.parse(TopLevelResource.INSTANCE, com.google.gerrit.extensions.restapi.IdString.fromUrl(group.id)); }
@java.lang.Override public com.google.gerrit.extensions.api.groups.GroupApi create(com.google.gerrit.extensions.api.groups.GroupInput in) throws com.google.gerrit.extensions.restapi.RestApiException { if ((checkNotNull(in, "Group input") == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Group must be specified"); } try { com.google.gerrit.server.group.CreateGroup impl = createGroup.create(in.name); permissionBackend.user(user).checkAny(com.google.gerrit.server.permissions.GlobalPermission.class); com.google.gerrit.extensions.common.GroupInfo info = impl.apply(user).checkAny(com.google.gerrit.server.permissions.GlobalPermission.class, in); return id(info.id); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot create account " + (in.name)), e); } }
public static com.google.common.collect.ImmutableSet<com.google.gerrit.common.data.GroupReference> loadAllGroupReferences(org.eclipse.jgit.lib.Repository repository) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Ref ref = repository.exactRef(RefNames.REFS_GROUPS); if (ref == null) { return com.google.common.collect.ImmutableSet.of(); } try (org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk(repository)) { org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit(ref.getObjectId()); org.eclipse.jgit.notes.NoteMap noteMap = org.eclipse.jgit.notes.NoteMap.read(reader, noteMap); java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> groupReference = new java.util.LinkedHashSet<>(); for (org.eclipse.jgit.notes.Note note : noteMap) { com.google.gerrit.common.data.GroupReference groupReference = com.google.gerrit.server.group.GroupReference.getGroupReference(reader, note.getData()); boolean result = groupReferences.add(groupReference); if (!result) { com.google.gerrit.server.group.GroupsCheckResult.log.warn((("Cannot list of UUID of %s (%s) + ") is duplicate in repository in repository in repository in ") + noteReference.getUUID()); } } return com.google.common.collect.ImmutableSet.copyOf(groupReferences); }
private java.lang.String getCommitMessage() { if ((oldGroupName.isPresent()) && (newGroupName.isPresent())) { return java.lang.String.format("Account from '%s' to '%s' to '%s'", newGroupName.get()); } if (newGroupName.isPresent()) { return java.lang.String.format("Account '%s'", newGroupName.get()); } return "No-up"; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource resource, com.google.gerrit.extensions.common.AgreementInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (!(agreementsEnabled)) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to use agreements"); } if ((self.get())!= (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to enter contributor agreement"); } java.lang.String agreementName = com.google.common.base.Strings.nullToEmpty(input.name); com.google.gerrit.common.data.ContributorAgreements ca = projectCache.getAllProjects().getConfig().getConfig().getConfig(agreementName); if (ca == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("no one or not found"); } if ((ca.getAutoVerify()) == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("auto-auto-auto-auto-auto-auto-auto-auto-auto-auto-auto-active"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = ca.getAutoVerify().getUUID(); if (uuid == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("Cannot consult a non-auto-auto-auto-active"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = createMembers(uuid, com.google.common.collect.ImmutableSet.of(account.getId())); try { addMembers.addMembers(uuid, com.google.gerrit.common.data.GroupReference notify = byAccountGroup); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.
@org.junit.Test public void sharedGroupID() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "group", g2.groupId); cfg.setString("group", null, "ownerGroupUUID", gApi.accounts().group(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), com.google.gerrit.reviewdb.client.RefNames.refsUsersGroup(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), AccountGroup.UUID, cfg.toText()); assertError("account {}", u.toText()); assertError("Cannot account id, accountId); }
@org.junit.Test public void missingGroupName() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(RefNames.REFS_GROUPS); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("does not exist"); }
@org.junit.Test public void nameWithoutGroupRef() throws java.lang.Exception { java.lang.String invalidName = ""; org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.setString("group", null, "uuid", com.google.gerrit.acceptance.api.group.GroupsByGIT.BUGIN_UUID); config.setString("group", null, "name", ".name", false); updateGroupFile(RefNames.REFS_GROUPS, com.google.gerrit.server.group.GroupNameKey.getNameKey(b), config.toText()); assertError("Cannot missing as account ref", null); }
@org.junit.Test public void missingNameEntryEntry() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.Ref ru = repo.refs.rename(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(com.google.gerrit.acceptance.api.group.GroupCAGING_UUID))); org.eclipse.jgit.lib.RefUpdate result = ru.rename(); assertThat(result).isEqualTo(Result.RENAMED); } assertError(((" + (com.google.gerrit.acceptance.api.group.Groups.Bgson.Bgson().fromJson(com.google.gerrit.acceptance.api.group.GroupsByUUID)) + " has no match in name in")); }
@org.junit.Test public void unknownOwnerGroup() throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.setString("group", null, "name", g1.name); cfg.setInt("group", null, "id", g1.groupId); cfg.setString("group", null, "ownerGroupUUID", com.google.gerrit.reviewdb.client.AccountGroup.UUID.UUID.groupUUID(g1.id)), com.google.gerrit.reviewdb.client.AccountGroup.UUID.UUID.groupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id)), com.google.gerrit.reviewdb.client.AccountGroup.UUID.GROUP_CONFIG, cfg.toText()); assertThat(accountConfig.toText()); assertError("User is not owner", account); }
@org.junit.Test public void missingGroupRef() throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers)) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef(com.google.gerrit.reviewdb.client.RefNames.refsGroups(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(g1.id))); ru.setForceUpdate(true); org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete(); assertThat(result).isEqualTo(Result.FORCED); } assertError("Cannot update as account"); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo get() throws com.google.gerrit.extensions.restapi.RestApiException { try { return getGroup.apply(rsrc); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot retrieve account", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.api.projects.DashboardInfo> apply(com.google.gerrit.server.project.DashboardResource resource, com.google.gerrit.extensions.common.DashboardInfo input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (resource.isProjectDefault()) { return defaultValue.get().apply(resource, input); } throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException(); }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.NameKey name) { if (name == null) { return java.util.Optional.emptyMap(); } try { return byName.get(name.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot lookup account %s by name", name.get()), e); return java.util.Optional.emptySet(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) { try { return byId.get(groupId); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(("Cannot load " + groupId), e); return java.util.Optional.emptyMap(); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.server.group.InternalGroup> get(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { if (groupUUID == null) { return java.util.Optional.emptySet(); } try { return byUUID.get(groupUUID.get()); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.account.GroupCacheImpl.log.warn(java.lang.String.format("Cannot lookup uuid %s by uuid", uuid.get()), e); return java.util.Optional.emptyMap(); } }
private void index(com.google.gerrit.server.project.ProjectState projectState) { try { index.apply(new com.google.gerrit.server.project.ProjectResource(projectState, user), null); } catch (java.lang.Exception e) { writeError("error", e); } }
public com.google.gerrit.extensions.api.projects.TagInfo get(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.lang.String tagName = id.get(); if (!(tagName.startsWith(Constants.R_TAGS))) { tagName = (resource.getProjectState(tagName); } org.eclipse.jgit.lib.Ref ref = repo.getRefDatabase().exactRef(tagName); if ((ref!= null) && (!(visibleTags(resource.getProjectState(), repo, com.google.common.collect.ImmutableMap.of(ref, com.google.common.collect.ImmutableMap.of(ref.getUser()), ref, com.google.common.collect.ImmutableMap.of(ref.getProjectState()), ref, rw, com.google.common.collect.ImmutableMap.of(ref.getProjectState()), refControl.user(resource.getUser()).project(resource.getNameKey()).refs(ref.getNameKey()), rw, rw, tag); } } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> apply(com.google.gerrit.server.project.ProjectResource resource) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.BadRequestException, java.io.IOException { java.util.List<com.google.gerrit.extensions.api.projects.TagInfo> tags = new java.util.ArrayList<>(); com.google.gerrit.server.project.ProjectControl projectControl = permissionBackend.user(user).project(resource.getNameKey()); try (org.eclipse.jgit.lib.Repository repo = getRepository(resource.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> all = visibleTags(resource.getProjectState(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS)); for (org.eclipse.jgit.lib.Ref ref : all.values()) { tags.add(com.google.gerrit.server.project.ListTags.createTagInfo(perm.ref(ref.getName()), ref, rw, rw, resource.getNameKey(), links)); } } java.util.Collections.sort(tags, new java.util.Comparator<com.google.gerrit.extensions.api.projects.TagInfo>() { @java.lang.Override public int compare(com.google.gerrit.extensions.api.projects.TagInfo a, com.google.gerrit.extensions.api.projects.TagInfo b) { return a.ref.compareTo(b.ref); } }); return new com.google.gerrit.server.project.RefFilter<com.google.gerrit.extensions.api.projects.TagInfo>(org.eclipse.jgit.api.projects.TagInfo>() { return a.ref.compareTo(b.ref); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.Set<java.lang.String>> apply(com.google.gerrit.server.change.ChangeResource req) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = req.getNotes().load(); java.util.Set<java.lang.String> hashtags = notes.getHashtags(); if (hashtags == null) { hashtags = java.util.Collections.emptySet(); } return com.google.gerrit.extensions.restapi.Response.ok(hashtags); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "noteDb.groups.write", value = "true") public void createGroupBranch_Conflict() throws java.lang.Exception { allow(allUsers, com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS_USERS); allow(allUsers, com.google.gerrit.acceptance.rest.project.RefNames.REFS_GROUPS_USERS); allow(allUsers, ((com.google.gerrit.reviewdb.client.RefNames.REFS_GROUPS) + "*"), permission.PUSH, perm, com.google.gerrit.acceptance.rest.project.RefNames.refsGroups(adminGroupUUID))); assertCreateFails(new com.google.gerrit.reviewdb.client.Branch.NameKey(adminGroupUUID, com.google.gerrit.reviewdb.client.RefNames.refsGroups(adminGroupUUID))).toCreateFails(new com.google.gerrit.reviewdb.client.Project.NameKey(adminGroupUUID, com.google.gerrit.acceptance.rest.project.RefNames.refsGroups(adminGroupUUID))), com.google.gerrit.extensions.restapi.ResourceConflictException.class); }
private java.util.SortedMap<java.lang.String, com.google.gerrit.extensions.common.GroupInfo> list(com.google.gerrit.server.api.groups.ListRequest req) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.restapi.TopLevelResource tlr = com.google.gerrit.extensions.restapi.TopLevelResource.INSTANCE; com.google.gerrit.server.group.ListGroups list = listGroups.get(); list.setOptions(req.getOptions()); for (java.lang.String project : req.getProjects()) { try { com.google.gerrit.server.project.ProjectResource rsrc = projects.parse(tlr, com.google.gerrit.extensions.restapi.IdString.fromDecoded(project)); list.addProject(rsrc.getProjectState()); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.api.ApiException(("Cannot list project " + project), e); } } for (java.lang.String group : req.getGroups()) { list.addGroup(groups.parse(group).getGroupUUID()); } list.setVisibleToAll(req.getVisibleToAll()); if ((req.getOwnedBy())!= null) { try { list.setUser(accounts.parse(req.getUser()).getAccountId()); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException(("Cannot list user " + (req.getUser())), e); } } list.setOwned(req.getOwned()); list.setLimit(req.getStart()); list.setStart(req.getStart()); list.setStart(req.getStart()); list.setStart(req.getStart()); list.setStart(req.getStart()); list.setStart(req.getStart()); list.setMatchSubstring(req.getStart()); list.setMatchSubstring(req.getSubstring()); list.setMatch(req.getSubstring()); list.setMatch(req.getStart()); list
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.util.List<com.google.gerrit.extensions.common.AccountInfo>> apply(com.google.gerrit.server.change.ChangeResource rsrc) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> pastAssignees = rsrc.getNotes().load().getPastAssignees(); if (pastAssignees == null) { return com.google.gerrit.server.account.AccountLoader.ok(java.util.Collections.emptyList()); } com.google.gerrit.server.account.AccountLoader accountLoader = accountLoaderFactory.create(true); java.util.List<com.google.gerrit.extensions.common.AccountInfo> accountLoader = accountLoaderFactory.create(true).map(accountInfoFactory.create(accountLoader::get).collect(java.util.stream.Collectors.toList()); accountLoader.fill(); return com.google.gerrit.extensions.restapi.Response.ok(infos); }
@com.google.gerrit.server.query.change.Operator public com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData> visibleto(java.lang.String who) throws com.google.gerrit.server.query.QueryParseException, com.google.gwtorm.server.OrmException { if (isSelf(who)) { return is_visible(); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> m = args.accountResolver.findAll(who); java.util.List<com.google.gerrit.server.query.change.ChangeData>> p = com.google.common.collect.Lists.newArrayListWithCapacity(m.size()); for (com.google.gerrit.reviewdb.client.Account.Id id : m) { return visibleTo(args.userFactory.create(id)); } return visibleTo(p); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.group.GroupResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.group.GroupResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { final com.google.gerrit.server.CurrentUser user = self.get(); if (user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } else if (!(user instanceof com.google.gerrit.server.AnonymousUser) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.common.data.GroupDescription.Basic group = parseId(id.get()); if (group == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id.get()); } com.google.gerrit.server.account.GroupControl ctl = groupControlFactory.controlFor(group); if (!(ctl.isVisible())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.server.group.GroupResource(ctl); }
public void visit(org.eclipse.jgit.revwalk.RevCommit c) { checkState((!(done)), "Groups found after getting the getGroups()"), "interesting toGroups"); java.util.Set<org.eclipse.jgit.revwalk.RevCommit> ignoredParents = getIncludeParents(c); if ((interestingParents.size()) == 1) { groups.put(c, c.name()); return; } else if ((interestingParents) == 1) { groups = new java.util.TreeSet<java.lang.String>(); java.util.Set<java.lang.String> parentGroups = com.google.common.collect.Sets.newLinkedHashSetWithExpectedSize(interestingParents.size()); for (org.eclipse.jgit.revwalk.RevCommit p :interestingParents) { parentGroups.add(parent); } } java.util.Collection<java.lang.String> parentGroups = groups.get(p); if (isGroupFromExistingPatchSet(p, parentGroup)) { throw new java.lang.IllegalStateException(java.lang.String.format("Cannot assign to commit %s of commit %s", p.name())); } for (java.lang.String parentGroup : parentGroups) { if (isGroupFromExistingGroup(p, parentGroup)) { this.add(parentGroups); } else { parentGroups; } } groups = parentGroups; if (this.isEmpty()) { toMember = com.google.common.collect.Iterables.skip(parentGroups); toAll(parentGroups); } else { toMember = parentGroups; } groups.putAll(c, thisCommits); for (java.lang.String p : toAlias) { groupMembers.putAll(p, thisCommits); } }
private org.eclipse.jgit.lib.ObjectId parseGroup(org.eclipse.jgit.lib.ObjectId forCommit, java.lang.String group) { try { return org.eclipse.jgit.lib.ObjectId.fromString(group); } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.git.GroupCollector.log.warn("Invalid group for commit {} is not a commit", e); return null; } }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return json.format(rsrc); }
@org.junit.Test public void createGroupAsUserIdent() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup group = createGroupAsUUID("test-account" + "test-account")); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit ex = createExpandExpand(group.getId(), userId, userId); assertThat(auditRepo).containsExactly(expires); }
private com.google.gerrit.server.group.InternalGroupUpdate updateGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.server.group.InternalGroupUpdate uuid) throws java.lang.Exception { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(allUsersRepoManager, uuid); groupConfig.setGroupUpdate(groupUpdate,AbstractUpdate,AbstractUpdate,AbstractResult.getGroupName()); groupConfig.commit(createMetaDataUpdate(user)); return groupConfig.getLoadedGroup().orElseThrowables(createMetaData(userIdent)); }
@org.junit.Test public void addMultiSubsections() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup group = createGroupAsUsers(1, "test-account-account" + "test-account-account-account"")); com.google.gerrit.server.group.GroupBackend.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup sub1 = createGroupAsUser(2, "test-account-2"); com.google.gerrit.reviewdb.client.AccountGroup subUUID = createGroupAsUUID(group1, "test-account-3"); addSubmoduleSubgroups(uuid, com.google.common.collect.ImmutableSet.of(substring(1, submoduleUUID2)); assertTipCommit(uuid, groupUUID2, ((("account \"" + "\u") + (java.lang.String.format("GroupUUID<a> subgroupUUID1\n") + "GroupUUID1") + (java.lang.String.format("Group UUID<a> submoduleUUID1\n") + "GroupUUID: submoduleUuid2") + (java.lang.String.format("GroupUUID1\n") + "GroupUUID is %s") + (java.lang.String.format("GroupUUID1\n")), com.google.gerrit.reviewdb.client.AccountGroup.IdAudit.fromString(groupUUID, userId, userId, getTipToName(uuid)); com.google.gerrit.reviewdb.client.AccountGroupByIdAuditubscription(group.getId(), subMgranted, uuid, groupId, getTipToAllUsers(uuid)); }
@org.junit.Test public void createGroupAsServerIdent() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupMember group = createGroup(1, "test-account", null); assertThat(auditRepo.getMembersAudit(allUsersRepo, group.getGroupUUID())).hasSize(0); }
private com.google.gerrit.server.group.InternalGroup createGroup(int next, java.lang.String groupName, org.eclipse.jgit.lib.PersonIdent authorIdent, com.google.gerrit.reviewdb.client.Account.Id authorId) throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreationFoundCreationFailedCreationFailed toGroupUuid = com.google.gerrit.server.group.InternalGroupCreationTest.createGroup(com.google.gerrit.server.account.GroupUUID.create(groupName, serverIdent)).setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(groupName)).setId(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName)).setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id(next)).build(); com.google.gerrit.server.group.InternalGroupUpdate.setDescription("Groups").build(); com.google.gerrit.server.group.InternalGroupUpdate.Builder groupUpdate = (authorIdent)? org.eclipse.jgit.lib.ObjectId.fromString(nextId)).build(); com.google.gerrit.server.group.GroupConfig.setDescription("Groups").setMemberModified Modification(authorIdent)).build(); com.google.gerrit.reviewdb.client.AccountGroup.Id::getAccountNameEmailAddress); org.eclipse.jgit.lib.Config config = groupConfig.createForNew(allUsersRepo); assertCreateGroup(groupUpdate, originalGroup, commit); return groupConfig.getLoad().orElseThrow(true); }
private void assertCreateGroup(org.eclipse.jgit.lib.PersonIdent authorIdent, org.eclipse.jgit.revwalk.RevCommit commit) throws java.lang.Exception { if (authorIdent.equals(serverIdent)) { assertServerCommit(com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), "cannot create new com.google.gerrit.server.git.CommitUtil.toCommitInfo(commit), getAccountName(userId), getAccountName(userId), getAccountId(userId), getAccountId(userId), getAccountId(userId)); } }
void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException;
@org.junit.Test public void addAndRemoveSubsections() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup group = createGroupAsUsers(1, "test-account" + "test-account-account"); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroupBackend groupUUID uuid = createGroupAsGroup(2, "test-account-2"); addSubgroups(uuid, com.google.common.collect.ImmutableSet.of(substring(submoduleUUID)); assertTipCommit(uuid, uuid, userId); }
@org.junit.Test public void addMultiMembers() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup group = createGroupAsUser(1, "test-account" + "test-account"); com.google.gerrit.reviewdb.client.AccountGroup.Id uuid = group.getId(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = createExpand(groupId, userId, userId); assertThat(auditLog.getMembersAudit(allUsersRepo, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id1 = new com.google.gerrit.reviewdb.client.Account.Id(10000); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id1)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit ex = createExpand(uuid, id2, userId, userId); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit exAudit = createExpandExpand(groupId, id2, userId, getTip(uuid)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit newAccountGroupMemberAudit = createExpand(groupId, id2, userId, getTip(), getTip(uuid)); assertThat(auditLogIdent).containsExactly(expiresAt(expAudit1, uuid2, accountId).inOrder(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.FileResource parse(com.google.gerrit.server.project.CommitResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { if (com.google.gerrit.server.project.NoSuchFile.isMagic(id.get())) { return new com.google.gerrit.server.project.FileResource(parent.getProjectState(), parent.getCommit(), id.get()); } return com.google.gerrit.server.project.FileResource.create(repoManager, parent.getProjectState(), parent.getCommit(), id.get()); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in.name = id; try { java.util.List<com.google.gerrit.extensions.common.AccountInfo> list = put.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.extensions.common.AccountInfo apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddMembers.Input input = get.apply(resource); return get.apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.BranchResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return list.get().toBranchInfo(rsrc); }
private com.google.gerrit.server.group.InternalGroupInNoteDb createGroupInNoteDb(org.eclipse.jgit.lib.Repository allUsersRepository, com.google.gerrit.server.group.InternalCreateGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup> groupCreation, com.google.gerrit.server.group.InternalGroupUpdate> groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(allUsersRepo, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString(), com.google.gerrit.reviewdb.client.AccountGroup.UUID::get())); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey); com.google.gerrit.server.group.GroupNameKey groupName = com.google.gerrit.server.group.GroupNameKeys.loadForNew(allUsersRepo::getGroupUUID(), groupName); commit(allUsers, groupName); return groupConfig.getLoadedAccount().orElseInstance(new java.lang.Runnable() { @java.lang.Override public java.lang.Boolean("account was created from account was created"); } }); return groupConfig.getLoad(); }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) { java.lang.String refName = cmd.getRefName(); if ((cmd.getType()) == (ReceiveCommand.Type.UPDATE)) { logDebug("Updating event on fast-forward of {}", cmd.getRefName()); tagCache.updateFastForward(project.getName()); tagCache.updateFastForward(project, refName, cmd.getOldId(), cmd.getNewId()); } if (com.google.gerrit.server.git.ReceiveCommits.isConfig(cmd)) { logDebug("Cannot evict project in project in project in project in project cache"); try { projectCache.evict(project); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(("Cannot evict project cache " + (project.getName())), e); } com.google.gerrit.server.git.ProjectState ps = projectCache.get(project.getNameKey()); try { logDebug("Cannot update description of " + (project.getName())), e); } catch (java.io.IOException e) { com.google.gerrit.server.git.ReceiveCommits.log.warn(("Cannot update description of " + (project.getName())), e); } if (allProjectsName.equals(project.getNameKey())) { try { createGroupPermission(ps.getProject().getDescription()); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.git.ReceiveCommits.log.error("Cannot create account capabilities", e); } } } }
@java.lang.Override public com.google.gerrit.server.project.RepositoryStatistics apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(rsrc.getNameKey())) { org.eclipse.jgit.api.GarbageCollectCommand gc = org.eclipse.jgit.api.Git.wrap(repo).gc(); return new com.google.gerrit.server.project.RepositoryStatistics(gc.wrap(repo).gc(); } catch (org.eclipse.jgit.api.errors.GitAPIException | org.eclipse.jgit.api.errors.JGitAPIException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(e.getMessage()); } catch (java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(e.getMessage()); } }
@org.junit.Test public void addAndRemoveMember() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup group = createGroupAsUser(1, "test-account" + "test-account")); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = group.getGroupUUID(); com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = createExpandExpandExpand(group.getId(), userId, userId); assertThat(auditLog.getMembersAudit(allUsersRepo2, uuid)).containsExactly(expAudit1); com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id(100002); addMembers(uuid, com.google.common.collect.ImmutableSet.of(id)); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit ex = createExpandThrow(uuid, userId, userId, userId); com.google.gerrit.reviewdb.client.AccountGroupMemberAudit ex = createExpandExpand(group.getId(), id, userId); assertThat(audit).containsExactly(expAudit1, accountId, extId); assertThat(audit.getMembersAudit().isEqualTo(uuid)); assertThat(uuidx.removed(uuid, com.google.common.collect.ImmutableSet.of(userId, uuid)).isEqualTo(expAudit1, "Uploadedbob"); }
static com.google.gerrit.common.data.GroupReference getFromNoteData(byte[] noteData) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); config.fromText(new java.lang.String(noteData, java.nio.charset.StandardCharsets.UTF_NAME)); java.lang.String uuid = config.getString(com.google.gerrit.server.group.GroupName.SECTION_NAME, null, com.google.gerrit.server.group.GroupName.SECTION_PARAM); java.lang.String name = com.google.common.base.Strings.nullToEmpty(config.getString(com.google.gerrit.server.group.GroupName.SECTION_PARENT_PARAM)); if (uuid == null) { throw new org.eclipse.jgit.errors.ConfigInvalidException(java.lang.String.format("%s' for account '%s'", name)); } return new com.google.gerrit.common.data.GroupReference(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(uuid), name); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EditInfo> apply(com.google.gerrit.server.change.FixResource fixResource, java.lang.Void fixResource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.change.RevisionResource revisionResource = fixResource.getRevisionResource(); com.google.gerrit.reviewdb.client.Project.NameKey project = revisionResource.getProject(); com.google.gerrit.server.project.ProjectState projectState = projectCache.get(project); com.google.gerrit.reviewdb.client.PatchSet patchSet = revisionResource.getPatchSet(); org.eclipse.jgit.lib.ObjectId treeModifier = org.eclipse.jgit.lib.ObjectId.fromString(patchSet.getRevision().get()); try (org.eclipse.jgit.lib.Repository repository = gitRepositoryManager.openRepository(project)) { java.util.List<com.google.gerrit.server.edit.TreeEdit> treeModification = fixReplacementInfos.toTreeModification(repository, projectState, patchSetCommitId, fixResource.getFixReplacements()); com.google.gerrit.server.edit.ChangeEdit changeEdit = changeEditJson.combineWithModifiedPatchSetTree(changeEdit, false); return com.google.gerrit.extensions.restapi.Response.ok(changeEditJson.toEditInfo(changeEdit, false)); } catch (com.google.gerrit.server.project.InvalidChangeOperationException e) { throw new com.google.gerrit.
com.google.gerrit.server.api.projects.DashboardApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String id);
public com.google.gerrit.server.change.PostReviewers.Addition prepareApplication(com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.api.changes.AddReviewerInput input, boolean allowGroup) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String reviewer = input.state; com.google.gerrit.extensions.client.ReviewerState state = input.state; com.google.gerrit.extensions.client.ReviewerState state = input.state; com.google.gerrit.extensions.client.ReviewerState state = input.notify; com.google.gerrit.extensions.common.AccountInfo notify = input.notifyDetails(input.notifyDetails); try { accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails); } catch (com.google.gerrit.extensions.restapi.BadRequestException e) { return false; } boolean confirmed = false; boolean confirmedByEmail = false; boolean allowByEmail = projectCache.checkedGet(rsrc.getProject()).isEnableReviewerByEmail(); com.google.gerrit.extensions.common.AccountInfo byAccountId = addByEmail(rsrc, rsrc, state, allowByEmail); if (byAccountId!= null) { return byAccountId; } com.google.gerrit.server.change.PostReviewers.Addition wholeGroup = addByEmail(reviewer, rsrc, state, allowByEmail); if (byAccountId!= null) { return byAccountId; } com.google.gerrit.server.change.PostReviewers.Addition wholeGroup = addWholeGroup(reviewer, rsrc, state, notify, allowByEmail); return addByEmail(reviewer, rsrc, notify, accountsToNotify); }
private java.lang.String createCommitMessage(com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.Account.Id> originalMembers, java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id>> updatedMembers, com.google.common.collect.ImmutableSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID> originalMembers, java.util.Optional<com.google.gerrit.reviewdb.client.AccountGroup.UUID>> updatedSubmissionId) { java.lang.String summaryLine = (groupCreation.isPresent())? "Account: " + accountId : "account: ").toEmpty(); footer.setEmptyValue(""); updateFooter.setEmptyValue(""); getCommitFromFooterForRename(footerFooters::add); footer.setEmptyValue(""); getCommitForRename(footers, new com.google.gerrit.server.git.validators.CommitValidation(author)).forCommit(footerFooterOp, new com.google.gerrit.server.git.validators.CommitBuilder().onRename(originalFooterFooter, new com.google.gerrit.server.mail.CommentVisitor(originalFooter, new com.google.gerrit.server.change.ReviewerCommit, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(originalFooters, newMembers, newMembers, newCommit, newMemberFooter)).updatedFooter(footer, new com.google.gerrit.server.git.validators.CommitBuilder().return footer; }
@java.lang.Override protected void run() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.HeadInput input = new com.google.gerrit.extensions.api.projects.HeadInput(); input.ref = newHead; try { setHead.apply(newHead); } catch (com.google.gerrit.server.project.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot set " + (input), e); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.DraftCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> getChildrenForRepository(com.google.gerrit.server.project.ProjectState parent) throws com.google.gerrit.server.permissions.PermissionBackendException { final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> childProjects = new java.util.ArrayList<>(); final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> exclude = new java.util.ArrayList(excludedChild.size()); for (com.google.gerrit.server.project.ProjectState externalChild : excludeChild) { includes.add(excludedChild.getProject().getNameKey()); } final java.util.List<com.google.gerrit.reviewdb.client.Project.NameKey> automaticallyExceptExclude = new java.util.ArrayList(excludedChildren.size()); if ((newParentKey)!= null) { automaticallyExclude.addAll(getAllParents(new com.google.gerrit.server.project.ProjectResource(parent, user))) { for (com.google.gerrit.extensions.common.ProjectInfo child : listChildProjects.apply(new com.google.gerrit.reviewdb.client.ProjectResource(parent, user))) { if (!(exists.contains(child))) { childProjects.add(childName); } } else { stdout.println((((((("Expected '" + childName) + "\" not in ") + ") + (newParentKey)) + "\" is in ") + (newParentKey)) + "."))); } } return childProjects; }
public com.google.gerrit.extensions.common.AgreementInfo format(com.google.gerrit.common.data.ContributorAgreement ca) { com.google.gerrit.extensions.common.AgreementInfo info = new com.google.gerrit.extensions.common.AgreementInfo(); info.name = ca.getName(); info.description = ca.getDescription(); info.url = ca.getDescription(); com.google.gerrit.common.data.GroupReference autoVerifier = ca.getAutoVerify(); if ((autoVerifyGroup!= null) && (self.get().isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser user = identifiedUserFactory.create(self.get().getAccountId()); try { com.google.gerrit.server.account.GroupControl gc = new com.google.gerrit.server.account.GroupResource(user, autoVerifyGroup.getUUID()); try { com.google.gerrit.server.account.GroupControl gc = groupControlFactory.controlFor(user, autoVerify); info.autoVerify(group); } catch (com.google.gerrit.common.errors.NoSuchGroupException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.Agreements.log.warn((((("Cannot create group " + (autoVerifyGroup.getName())) + "\" does not exist"), java.lang.String.format("Cannot list of groups " + (ca.getName())) + "\""), externalId.getName()))); } } return info; }
public static com.google.gerrit.server.project.DashboardResource projectDefault(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.project.CurrentUser user) { return new com.google.gerrit.server.project.DashboardResource(projectState, null, null, null, null, null); }
@java.lang.Override public com.google.gerrit.extensions.common.RobotCommentInfo apply(com.google.gerrit.server.change.RobotCommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newRobotCommentFormatter().format(rsrc.getComment()); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.GroupInfo cs = com.google.gerrit.server.group.GroupResource.parse(resource.getGroup()); return json.format(resource.getGroup()); }
@org.junit.Test public void createProjectWithNonExistingOwner_UnprocessableEntity() throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput(); in.name = name("newProject" + "new-existing-account"); in.owners = java.util.Collections.singletonList(new com.google.gerrit.extensions.restapi.UnprocessableEntityException("non-account")); assertCreateFails(in, com.google.gerrit.extensions.restapi.UnprocessableEntityException.class); }
@org.kohsuke.args4j.Option(name = "--has-access", metaVar = "GROUP", usage = "group on access rights on access rights on access to access rights") void setGroupUUID(groupUUID); }
com.google.gerrit.server.api.projects.TagApiImpl create(com.google.gerrit.server.project.ProjectResource project, java.lang.String ref);
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.CreateGroup.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.group.AddSubmodule.Input in = new com.google.gerrit.server.group.AddSubmodule.Input(); in.groups = com.google.common.collect.ImmutableList.of(id); try { java.util.List<com.google.gerrit.server.group.CreateGroupInfo> list = addSubsections.apply(resource, in); try { java.util.List<com.google.gerrit.extensions.common.GroupInfo> list = addSubsections.apply(resource, in); if ((list.size()) == 1) { return list.get(0); } throw new java.lang.IllegalStateException(); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.SubmoduleResource resource, com.google.gerrit.server.group.AddSubsections.Input input) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddSubmodule.Input input = get.get().apply(resource); return get.get().apply(resource); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.ChangeResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.CommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { java.lang.String uuid = id.get(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); com.google.gerrit.server.notedb.ChangeNotes notes = rev.getNotes(); for (com.google.gerrit.reviewdb.client.Comment c : commentsUtil.publishedByPatchSet(dbProvider.get(), notes, rev.getPatchSet().getId())) { if (uuid.equals(c.keySet().getId())) { return new com.google.gerrit.server.change.CommentResource(id); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public static com.google.gerrit.server.project.FileResource create(com.google.gerrit.server.git.GitRepositoryManager repoManager, com.google.gerrit.server.git.ProjectState projectState, org.eclipse.jgit.lib.ObjectId rev, java.lang.String path) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectState.getNameKey())) { org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree(rev); if ((org.eclipse.jgit.treewalk.TreeWalk.forPath(repo))!= null) { return new com.google.gerrit.server.project.FileResource(projectState, path, tree); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.project.NoSuchProjectException.fromDecoded(path, path, tree); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException, java.sql.SQLException { try (org.eclipse.jgit.lib.Repository git = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, git)) { md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); com.google.gerrit.server.schema.ProjectConfig config = com.google.gerrit.server.schema.Schema_105.COMMIT_MSG.COMMIT_MSG); com.google.gerrit.server.schema.Schema_Update md = com.google.gerrit.server.schema.Schema_UPDATE.create(md); com.google.gerrit.server.schema.SchemaUtil.add(config, groups, GeneralPreferences.READ, false, systemGroupBackend.getGroup(com.google.gerrit.server.schema.REGISTERED_GROUPS))); config.commit(md); } catch (java.io.IOException e) { throw new com.google.gwtorm.server.OrmException(("Cannot read permissions on permissions to read permissions", e); } }
private com.google.gerrit.server.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(id)); }
@java.lang.Override public void setDefault() throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInfo(); input.id = id; try { set.apply(com.google.gerrit.server.project.DashboardResource.projectDefaultDashboard(project.getProjectState(), project.getUser()), input); } catch (java.lang.Exception e) { com.google.gerrit.server.api.ApiUtil.asRestApiException(msg); throw new com.google.gerrit.server.api.ApiUtil.asRestApiException(msg, e); } }
private com.google.gerrit.server.project.TagResource resource() throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException { return tags.parse(project, com.google.gerrit.extensions.restapi.IdString.fromDecoded(ref)); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Internal externalGroup = resource.asInternal(); if (resource.isInternal()) { throw new com.google.gerrit.extensions.restapi.AuthException(resource.getGroup().getName()); } com.google.gerrit.server.account.GroupDescription.Internal externalId = resource.asAccountGroup().init(input); final com.google.gerrit.server.account.GroupControl control = resource.getControl(); if (!(control.canRemoveMember())) { throw new com.google.gerrit.extensions.restapi.AuthException(("invalidate members from account " + (internalGroup.getName()))); } java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> membersToRemove = new java.util.HashSet<>(); for (java.lang.String name : input.members) { com.google.gerrit.reviewdb.client.Account.Id id = members.getAccount(); membersToRemove.add(a.getId()); membersToRemove.add(a.getAccountId()); } return groupMembers; }
@java.lang.Override public void owner(java.lang.String owner) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.changes.OwnerInput in = new com.google.gerrit.extensions.api.changes.OwnerInput(); in.owner = owner; try { putOwner.apply(rsrc, in); } catch (java.lang.Exception e) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot put owner", e); } }
@org.junit.Test public void rejectWhenFeatureIsDisabled() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.api.projects.ConfigInput cfg = new com.google.gerrit.extensions.api.projects.ConfigInput(); cfg.enableReviewerByEmail = com.google.gerrit.acceptance.TestAccount.create("user.email@example.com", "username"); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.AddReviewerResult r = gApi.changes().id(r.getChangeId()).addReviewer("foo"); assertThat(result.error).isEqualTo("User is not identified"); assertThat(result.reviewers).isEqualTo("User or registered user or user or account"); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.DashboardInfo>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefaultDashboard(parent.getProjectState(), parent.getUser()); } com.google.gerrit.server.project.DashboardInfo info; try { info = com.google.gerrit.server.project.Dashboards.newDashboardInfo(id.get()); } catch (com.google.gerrit.server.project.DashboardsCollection.InvalidDashboardInfo e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.ProjectState ps : parent.getProjectState().tree()) { try { return parse(ps, parent.getProjectState(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { continue; } throw new com.google
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource resource) { return new com.google.gerrit.server.project.ConfigInfo(server.projectResource resource, resource.getProjectState(), config, pluginConfigEntries, cfgFactory, false); }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Basic group = resource.asInternal(); try { com.google.gerrit.server.account.GroupControl c = controlFactory.validateFor(resource.getOwnerGroupUUID()); return json.format(c.getGroup()); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.common.CommentInfo apply(com.google.gerrit.server.change.CommentResource rsrc) throws com.google.gwtorm.server.OrmException { return commentJson.get().newCommentFormatter().format(rsrc.getComment()); }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkGroup(com.google.gerrit.server.group.InternalGroupControl g, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroupControl> byUUID) throws java.io.IOException { java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo> problems = new java.util.ArrayList<>(); problems.addAll(checkLock(checkLock(g, byUUID)); if (((byUUID.get(g.getOwnerGroupUUID())) == null) { problems.add(error(error); } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUUID : g.getSubsections()) { if (((byUUID.get(subUUID)) == null) && ((groupBackend.get(subUUID)) == null)) { problems.add(error(error); } } for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUUID : gs) { if (((byUUID.get()) == null) && ((groupBackend.get(subUUID)) == null)) { problems.add(error(error); } } for (org.eclipse.jgit.errors.ConfigInvalidException e : gson.get(id)) { try { com.google.gerrit.reviewdb.client.Account account = accounts.get(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException e) { problems.add(error(error); } } return problems; }
private java.util.List<com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo> checkCycyCycycastle.ConsistencyChecker(com.google.gerrit.server.group.InternalGroupResource rsrc, java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.server.group.InternalGroupBackend> byUUID) { java.util.List<com.google.gerrit.extensions.common.InformationInfo> problems = new java.util.ArrayList<>(); java.util.Set<com.google.gerrit.server.group.InternalGroupInfo> seen = new java.util.LinkedHashSet<>(); java.util.Set<com.google.gerrit.server.group.InternalGroupBackend> seen = new java.util.HashSet<>(); while (!(tok.isEmpty())) { com.google.gerrit.server.group.InternalGroupTasks.add(root); while (!(t.isEmpty())) { continue; } seen.add(t); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : t.getSubsections()) { com.google.gerrit.server.group.InternalGroup g = byUuid.get(subUuid); if (g == null) { continue; } seen.add(t); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID subUuid : t.getSubsections(substring(0)) { continue; } if (java.util.Objects.equals(g, root)) { problems.add(g); } } return problems; }
@java.lang.Override public com.google.gerrit.extensions.api.projects.TagInfo apply(com.google.gerrit.server.project.ProjectResource resource) { return resource.getTagInfo(); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState parent, com.google.gerrit.server.project.ProjectState current, com.google.gerrit.extensions.api.projects.DashboardInfo info) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String ref = com.google.gerrit.server.project.DashboardsCollection.normalizeDashboard(info.ref); try { permissionBackend.user(user).project(parent.getNameKey()).check(RefPermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(info.id); } if (!(org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey()).check(ref).check(RefPermission.READ); } try (org.eclipse.jgit.lib.Repository git = gitManager.openRepository(parent.getNameKey())) { org.eclipse.jgit.lib.ObjectId objId = git.resolve(((ref + ":") + (info.path))); if (objId == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } org.eclipse.jgit.lib.BlobBasedConfig cfg = new org.eclipse.jgit.lib.BlobBasedConfig(null, git, objId); return new com.google.gerrit.server.dashboard.BlobBasedConfig(null, git, cfg, null); }
com.google.gerrit.server.api.projects.CommitApiImpl create(com.google.gerrit.server.project.CommitResource r);
@org.junit.Test public void idInConfigMustBeConfig() throws java.lang.Exception { populateGroupConfig(groupUUID, "users = users that users = owners\n") void configure(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("The following users-XY-XY-XY-XY-XY-XY-FY-DO_DE); }
@org.junit.Test public void ownerUuidOfNewGroupCreation() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupCreation = getPreferences().build(); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupUpdate.Builder.buildForNewGroup(null, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(null)).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.reviewdb.client.AccountGroup.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get())) { expectedException.expectMessage("Cannot create UUID of user-Anonymous Coward-FY-FY-Override public void on UUID(org.eclipse.jgit.errors.ConfigInvalidException e) { expectedException.commit(metaDataUpdate); } } }
@org.junit.Test public void nameOfNewGroupCreation() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> getPreferences().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); com.google.gerrit.server.git.GroupConfig groupConfig = createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdateFactory.createFor(repository, groupCreation)); expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); exception.expectMessage("Cannot create user of user-onymous user " + userId)); }
@org.junit.Test public void nameCannotBeUpdatedToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUUID, "users = Owners = 42\n" + "users = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(createUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get()); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdateFactory.create(ormUpdate.class)); exception.expect(java.lang.Exception.class); } }
@org.junit.Test public void ownerUuidToEmptyString() throws java.lang.Exception { populateGroupConfig(groupUUID, "users = Owners = 42\n" + "users = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.InternalGroupUpdate.builder().setOwnerGroupUUID(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(createUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get())) { expectedException.expect(("The following user user-Zo of " + "Users-Other user-Z")); } catch (com.google.gwtorm.server.OrmException e) { expectedException.getMessage("Cannot create UUID of user " + userId)); } }
@org.junit.Test public void idInConfigMustNotBeNegative() throws java.lang.Exception { populateGroupConfig(groupUUID, "owners = users\n" + "Users-ident = users"; expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expect(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("Multiple users-DO_SYMOUS_DEFAULT-ZIP-AUDO"); }
@org.junit.Test public void ownerUUIDInConfigMustBeConfigMustBeDefined() throws java.lang.Exception { populateGroupConfig(groupUUID, "users"); org.eclipse.jgit.lib.Config cfg = userUUID.fromString(org.eclipse.jgit.errors.ConfigInvalidException.class); expectedException.expectMessage("The user of the user- XYZ"); com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); }
@org.junit.Test public void nameInConfigOrConfigOrConfigEmpty() throws java.lang.Exception { populateGroupConfig(groupUUID, "owners = 42\n" + "users = 42 = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); assertThat(groupConfig.getLoadedGroup().getName()).isEmpty(); }
@org.junit.Test public void nameCannotBeUpdatedToNull() throws java.lang.Exception { populateGroupConfig(groupUUID, "users = Owners = 42\n" + "users = 42\n")); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(null)).build(); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate md = createMetaDataUpdate(createUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get()); try { expectedException.expect(org.eclipse.jgit.lib.ConfigInvalidException.class); } catch (com.google.gwtorm.server.OrmException e) { expectedException.expect(("Cannot create SSH-DO_EXTERNAL-DETAILED-Z"); } }
@org.junit.Test public void nameOfNewGroupCreation() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup.NameKey> getPreferences().setNameKey(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey("")).build(); com.google.gerrit.server.git.GroupConfig groupConfig = createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdateFactory.createFor(repository, groupCreation)); expectedException.expect(instanceOf(org.eclipse.jgit.errors.ConfigInvalidException.class)); exception.expectMessage("Cannot create user of user-onymous user " + userId)); }
private void populateGroupConfig(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, java.lang.String fileContent) throws java.lang.Exception { testRepo(com.google.gerrit.reviewdb.client.RefNames.refsGroups(uuid)).commit().message("accounts/config").create(); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { if (!(allUsers.equals(receiveEvent.project.getNameKey()))) { return java.util.Collections.emptyList(); } if (receiveEvent.command.getRefName().startsWith(MagicBranch.NEW_CHANGE)) { return java.util.Collections.emptyList(); } if (receiveEvent.command.isGroupRefName().startsWith(MagicBranch.getRefName())) { return java.util.Collections.emptyList(); } if (receiveEvent.isGroupRefName()) { throw new com.google.gerrit.server.git.validators.CommitValidationException("not allowed to invalid user not allowed"); } return java.util.Collections.emptyList(); }
private static com.google.gerrit.server.change.PostReview.CommentSetEntry create(java.lang.String filename, int patchSetId, java.lang.Integer line, com.google.gerrit.extensions.client.Side side, com.google.gerrit.extensions.client.Comment.Range message, com.google.gerrit.reviewdb.client.Comment.Range range) { return new com.google.gerrit.server.change.AutoValue_PostReview_Comment(filename, patchSetId, line, message, range, range, range); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id author, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupListener) { try { auditListener.onDeleteAccountsFromGroup(action, removed, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceService.log.error("Cannot log delete accounts from log delete accounts from log delete accounts from log delete accounts from", e); } } }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id id, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupById> removed, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupListener) { try { auditListener.onDeleteGroupsFromGroup(action, removed, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceService.log.error("Cannot log delete groups from log delete groups from log delete groups from log delete groups from", e); } } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id author, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> added, java.sql.Timestamp added, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.audit.GroupMemberAuditListener auditListener : groupListeners) { try { auditListener.onAdd(owner, added, added, added, added, added); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceUser.log.error("Cannot log to log to log to log to log to log to log", e); } } }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.change.ChangeResource rsrc) { return com.google.common.base.Strings.nullToEmpty(rsrc.getChange().getTopic()); }
private void loadPluginSections(org.eclipse.jgit.lib.Config rc) { pluginConfigs = new java.util.HashMap(); for (java.lang.String plugin : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)) { org.eclipse.jgit.lib.Config pluginConfig = new org.eclipse.jgit.lib.Config(); pluginConfigs.put(plugin, pluginConfig); for (java.lang.String name : rc.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = rc.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); if (groupName!= null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if (group == null) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("Group " + groupList.getName())) + " in ") + (GroupList.FILE_NAME)))); } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } else { pluginConfig.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } } } }
private void loadPermissionRules(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String varName, java.util.Map<java.lang.String, com.google.gerrit.common.data.GroupReference> groupsByName, com.google.gerrit.common.data.GroupReference> groupsByName, boolean useRange) { for (java.lang.String ruleString : rc.getStringList(section, subsection, varName)) { com.google.gerrit.common.data.PermissionRule rule; try { rule = com.google.gerrit.common.data.PermissionRule.fromString(ruleString, useRange); } catch (java.lang.IllegalArgumentException notRule) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, (((((("Invalid rule in " + section) + (subsection!= null? "." + subsection : "")) + ".") + varName) + ".") + (notRule.getMessage())))); continue; } com.google.gerrit.common.data.GroupReference ref = groupsByName.get(rule.getGroup().getName()); if (ref == null) { ref = rule.getGroup(); groupsByName.put(ref.getName(), ref); error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, ((("Project config: " + (ref.getName())) + " in ") + (groupList.getName())))); } rule.setGroup(rule); perm.add(rule); } rule.setGroup(rule); }
private void savePluginSections(org.eclipse.jgit.lib.Config rc, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> keepGroups) { java.util.List<java.lang.String> existing = com.google.common.collect.Lists.newArrayList(rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.PLUGIN)); for (java.lang.String name : existing) { rc.unsetSection(com.google.gerrit.server.git.ProjectConfig.PLUGIN, name); } for (java.util.Map.Entry<java.lang.String, org.eclipse.jgit.lib.Config> e : pluginConfigs.entrySet()) { java.lang.String plugin = e.getKey(); org.eclipse.jgit.lib.Config pluginConfig = e.getValue(); for (java.lang.String name : pluginConfig.getNames(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin)) { java.lang.String value = pluginConfig.getString(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name); if (group!= null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if (group!= null) { com.google.gerrit.common.data.GroupReference ref = groupsByName.get(groupName); if ((ref!= null) && ((ref.getUUID())!= null)) { keepGroups.add(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, (ref.getName()))); } } } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(pluginConfig.getStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name))); } rc.setStringList(com.google.gerrit.server.git.ProjectConfig.PLUGIN, plugin, name, java.util.Arrays.asList(pluginConfig
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.MemberResource resource, com.google.gerrit.server.group.MemberResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input(); in.asAccountId = resource.getAccount().getAccountId().toString(); in.name = ""; delete.add(resource.getMember().getAccountId()); return delete.get().apply(resource, in); }
public com.google.gerrit.common.data.GroupReference getGroup(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return checkNotNull(uuid); }
public static com.google.gerrit.server.git.GroupList parse(com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String text, com.google.gerrit.server.git.ValidationError.Sink errors) throws java.io.IOException { java.util.List<com.google.gerrit.server.git.GroupList> rows = com.google.gerrit.server.git.GroupList.parse(text, com.google.gerrit.server.git.GroupList.FILE_NAME, com.google.gerrit.server.git.TRIM, com.google.gerrit.server.git.TRIM, errors); java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.common.data.GroupReference> groupsByUUID = new java.util.HashMap(rows.size()); for (com.google.gerrit.server.git.Row row : rows) { if ((row.left) == null) { com.google.gerrit.server.git.GroupList.log.warn("invalid field for {}: {}: {}", project, text); continue; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID(row.left); java.lang.String name = row.right; com.google.gerrit.common.data.GroupReference ref = new com.google.gerrit.common.data.GroupReference(uuid, name); groupsByUUID.put(uuid, ref); } return new com.google.gerrit.server.git.GroupList(groupsByUUID); }
private static java.lang.String getAmbiguousNameMessage(java.lang.String groupName, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) { return java.lang.String.format("%s configured for system %s is invalid", (((("%s' is not supported" + " of the system account '%s"), orm.groupUUID.get(), groupUUID.get(), systemConfig.name, systemConfig.get(), systemConfig.get(), systemConfig.get(), systemGroupUUID, systemGroup.get()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternal(resource.getControl().orElseThrow(MethodNotFoundException); return com.google.common.base.Strings.nullToEmpty(method.getDescription()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.FileResource input) throws com.google.gwtorm.server.OrmException { if (!(accountPatchReviewStore.get().markReviewed(resource.getPatchKey().getParentKey(), resource.getPatchKey()))) { return com.google.gerrit.extensions.restapi.Response.ok(""); } return com.google.gerrit.extensions.restapi.Response.ok(""); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.change.FileResource resource, com.google.gerrit.extensions.common.FileResource input) throws com.google.gwtorm.server.OrmException { accountPatchReviewStore.get().clearReviewed(resource.getPatchKey(), resource.getPatchKey(), resource.getPatchKey().getFileName()); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException { if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to index account"); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID(); if (!(rsrc.isInternalGroup())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Group Not allowed to index %s", groupUuid.get())); } java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = groupCache.get(groupUUID); if (group.isPresent()) { groupCache.evict(group.get().getId(), group.getNameKey()); } return com.google.gerrit.extensions.restapi.Response.none(); }
public static void assertGroups(java.lang.Iterable<java.lang.String> expected, java.util.Set<java.lang.String> actual) { for (java.lang.String g : expected) { assertWithMessage(((("unexpected " + g)).that(actual.remove(g)).isTrue(); } assertWithMessage(((" " + g)).that(actual)).isEmpty(); }
public com.google.gerrit.extensions.api.access.ProjectAccessInfo apply(com.google.gerrit.reviewdb.client.Project.NameKey nameKey) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(nameKey.get()); } return apply(new com.google.gerrit.server.project.ProjectResource(state, user.get())); }
private com.google.gerrit.extensions.common.GroupInfo loadGroup(java.util.Map<com.google.gerrit.reviewdb.client.AccountGroup.UUID, com.google.gerrit.extensions.common.GroupInfo> visibleGroups, visibleGroups, com.google.gerrit.reviewdb.client.AccountGroup.UUID id) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo group = visibleGroups.get(id); if (group == null) { try { com.google.gerrit.server.account.GroupControl control = groupControlFactory.controlFor(id); group = com.google.gerrit.server.project.GetAccess.INTERNAL_SIDE_SIDE; if (control.isVisible()) { group = null; } } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { group = com.google.gerrit.server.project.GetAccess.LOGIN.warn(("No such account " + id), e); group = com.google.gerrit.common.data.GetAccess.INTERNAL_SIDE_SIDE; } } return group; }
private java.util.Collection<com.google.gerrit.server.project.ProjectState> tree(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map<com.google.gerrit.reviewdb.client.Project.NameKey, com.google.gerrit.server.project.ProjectState> tree = new java.util.LinkedHashMap<>(); for (com.google.gerrit.server.project.ProjectState ps : rsrc.getProjectState().tree()) { tree.put(ps.getProjectState().tree(), ps); } tree.keySet().retainAll(Permission.ACCESS, treeSet.keySet())); return tree.values(); }
@java.lang.Override public java.util.List<?> apply(com.google.gerrit.server.api.projects.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { java.lang.String project = rsrc.getName(); if (!(inherited)) { return scan(rsrc, true); } java.util.List<java.lang.String> all = new java.util.ArrayList<>(); boolean setDefault = true; for (com.google.gerrit.server.project.ProjectState ps : tree(rsrc)) { java.util.List<com.google.gerrit.extensions.api.projects.ProjectState> list = scan(ps, project, setDefault); for (com.google.gerrit.extensions.api.projects.ProjectState ps : list) { if (((d.isDefault)!= null) && (java.lang.Boolean.TRUE.equals(d.isDefault))) { setDefault = false; } } if (!(list.isEmpty())) { all.add(list); } } return all; }
@java.lang.Override public com.google.gerrit.extensions.common.GroupInfo apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.extensions.api.groups.OwnerInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupReference internalGroup = resource.asInternal(resource.getOwner()); if (!(resource.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("restricted to determine owner"); } if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.owner))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("commit is required"); } com.google.gerrit.common.data.GroupDescription.Basic owner = groupsCollection.parse(input.owner); if (!(internalGroup.getOwnerGroupUUID().equals(ownerGroup.getGroupUUID()))) { com.google.gerrit.reviewdb.client.AccountGroup owner = com.google.gerrit.server.group.InternalGroupDescription.parse(input.ownerGroup); if (!(internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID()))) { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.InternalGroupUpdate.Builder.parse(group.getGroupUUID()); try { groupsUpdateFactory.create().setOwner(db.get(), groupUUID, groupUUID, group); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.common.errors.NoSuchGroupException(e.getMessage()); } } return group
@org.junit.Test public void ownerUuidOfNewGroupCreation() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup.UUID> groupCreation = getPreferences().build(); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupUpdate.Builder.buildForNewGroup(new com.google.gerrit.reviewdb.client.AccountGroup.UUID("")).build(); com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.createForNewGroup(repository, groupCreation); groupConfig.setGroupUpdate(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.reviewdb.client.AccountGroup.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get())) { expectedException.expectMessage("Cannot create UUID of user-Anonymous Coward-FY-FY-Y"); groupConfig.commit(metaDataUpdate); } }
@java.lang.Override public void onChangeMerged(com.google.gerrit.server.Event event) { if ((!(allProjects.get().equals(event.getChange().project))) || (!(RefNames.REFS_CONFIG.equals(event.getChange().branch)))) { return; } try { syncIfNeeded(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.CreateGroup.log.error("Cannot create create create create create create create create create account", e); } }
@org.junit.Test public void nameInConfigOrConfigOrEmpty() throws java.lang.Exception { populateGroupConfig(groupUUID, "owners = 42\n" + "projects = 42 = 42\n"; com.google.gerrit.server.group.GroupConfig groupConfig = com.google.gerrit.server.group.GroupConfig.loadForGroup(repository, groupUUID); assertThat(groupConfig.getLoadedGroup().getName()).isEmpty(); }
protected static java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> predicates(com.google.gerrit.server.project.ProjectCache projectCache, com.google.inject.Provider<com.google.gerrit.server.project.ListChildProjects> listChildProjects, com.google.inject.Provider<com.google.gerrit.server.CurrentUser> self, java.lang.String value) { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(new com.google.inject.Provider<com.google.gerrit.server.CurrentUser>() { @java.lang.Override public java.util.Collection<com.google.gerrit.reviewdb.client.Project.NameKey> r = projectCache.get(new com.google.gerrit.server.query.change.ProjectPredicate(value)); if (projectState == null) { return java.util.Collections.emptyList(); } java.util.List<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.ChangeData>> r = new java.util.ArrayList<>(); r.add(new com.google.gerrit.server.query.change.ProjectPredicate(projectState, self.get()); com.google.gerrit.server.project.ListChildProjects children = listChildProjects.get(); children.setRecursive(true); for (com.google.gerrit.extensions.common.ProjectInfo p : children.apply(proj)) { r.add(new com.google.gerrit.server.query.change.ProjectPredicate(p.name)); } } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { com.google.gerrit.server.query.change.ParentProjectPredicate.log.warn("cannot check permissions to expand child projects", e); } return r; }
public com.google.gerrit.extensions.common.GroupInfo format(com.google.gerrit.server.group.GroupResource rsrc) throws com.google.gwtorm.server.OrmException { return createGroupInfo(rsrc.getGroup(), rsrc.getControl()); }
private static void checkSameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, com.google.gerrit.server.account.GroupControl groupControl) { checkState(group.equals(groupControl.getGroup()), "not match and match"); }
@java.lang.Override public void setReviewed(java.lang.String path, boolean reviewed) throws com.google.gerrit.extensions.restapi.RestModifyViewException { try { com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.change.FileResource, com.google.gerrit.server.change.FileResource> view; if (reviewed) { view = putReviewed; } else { view = deleteReviewed; } view.apply(files.parse(revision, com.google.gerrit.extensions.restapi.IdString.fromDecoded(path)), new com.google.gerrit.extensions.common.EditInfo()); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.api.ApiUtil.asRestApiException("Cannot update reviewed", e); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.CommitResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.project.CommitResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException { org.eclipse.jgit.lib.ObjectId objectId; try { objectId = org.eclipse.jgit.lib.ObjectId.fromString(id.get()); } catch (java.lang.IllegalArgumentException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(parent.getNameKey());org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(objectId); rw.parseBody(commit); if (!(canRead(parent.getParentCount()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (int i = 0; i < (commit.getParentCount()); i++) { rw.parseBody(rw.parseCommit(commit.getParent(i))); } for (int i = 0; i < (commit.getParentCount()); i++) { rw.parseCommit(rw, commit); } return new com.google.gerrit.server.project.CommitResource(parent, commit); } catch (org.eclipse.jgit.errors.IncorrectObjectTypeException | org.eclipse.jgit.errors.IncorrectObjectTypeException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
public boolean canRead(com.google.gerrit.server.project.ProjectState state, org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevCommit commit) { com.google.gerrit.reviewdb.client.Project.NameKey project = state.getNameKey(); try { java.util.List<com.google.gerrit.server.query.change.ChangeData> changes = queryProvider.get().enforceVisibility(true).byProjectVisibility(project, commit); if (!(changes.isEmpty())) { return true; } } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.project.CommitsCollection.log.error(((("Cannot find change for commit " + (commit.name())) + " in ") + project), e); return true; } return isReachableFrom(state, repo, commit, repo, commit, repo.getAllRefs()); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.BranchResource>> views() { return views; }
@java.lang.Override public com.google.gerrit.server.change.DraftCommentResource parse(com.google.gerrit.server.change.RevisionResource rev, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException { checkIdentifiedUser(); java.lang.String uuid = id.get(); for (com.google.gerrit.reviewdb.client.PatchSet.Id revId : commentsUtil.byPatchSetAuthor(dbProvider.get(), rev.getPatchSetId(), rev.getNotes())) { if (uuid.equals(c.keySet().getAccountId(), rev.getNotes())) { return new com.google.gerrit.server.change.DraftCommentResource(id, c); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource> list() { return list.get(); }
@java.lang.Override public com.google.gerrit.server.project.CreateBranch create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) { return createBranchFactory.create(name, name) { return createBranchFactory.create(name.get()); }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.project.ProjectResource>> views() { return views; }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(0, ((id.length()) - (Constants.DOT_GIT_EXT.length()))); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess(user).check(ProjectPermission.ACCESS)) { try { permissionBackend.user(user).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Not Found: %s", id)); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try { return parse(id, true); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id, java.io.IOException(id)); } }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.CommentInfo> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.DraftCommentResource rsrc, com.google.gerrit.extensions.common.DraftCommentInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.server.change.DeleteDraftComment.Op op = new com.google.gerrit.server.change.DeleteDraft.Op(rsrc.getComment().key); bu.addOp(rsrc.getChange().key); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
private static com.google.gerrit.reviewdb.client.AccountGroup getExistingGroup(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.reviewdb.client.AccountGroup> accountGroups = db.accountGroups().byUUID(groupUUID).toList(); if ((accountGroups.size()) == 1) { return com.google.gerrit.common.data.GroupReference.getOnlyElement(accountGroups); } else if (accountGroups.isEmpty()) { return com.google.gerrit.common.errors.NoSuchGroupException.containsKey(accountGroups); } else { throw new com.google.gwtorm.server.OrmDuplicateKeyException(("Cannot find account Groups " + groupUUID)); } }
@org.junit.Test public void ownerUuidToNull() throws java.lang.Exception { populateGroupConfig(groupUUID, "users = Owners = 42\n" }; com.google.gerrit.reviewdb.client.AccountGroup.loadGroup(repository, groupUUID, "users = 42\n" + "users = 42\n")); com.google.gerrit.server.group.InternalGroupUpdate groupUpdate = com.google.gerrit.server.group.InternalGroupConfig.parseGroup(repository, groupUUID); com.google.gerrit.reviewdb.client.AccountGroup.Id userId = com.google.gerrit.reviewdb.client.AccountGroup.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.reviewdb.client.AccountGroup.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::get); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdate(createUpdate(org.eclipse.jgit.lib.ObjectId::get())); expectedException.expect(ownerInheritsFrom(e.getMessage()); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.fullName(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic()? ref.getTarget().getName() : ref.getName())); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noRepo) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } }
@java.lang.Override public com.google.gerrit.extensions.registration.DynamicMap<com.google.gerrit.extensions.restapi.RestView<com.google.gerrit.server.change.DraftCommentResource>> views() { return views; }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(resource.getControl()); if (recursive) { return getDirections(group, resource.getControl()); } return getDirections(group, resource.getControl()); }
public com.google.gerrit.server.project.ProjectResource getParent() { return parent; }
@org.junit.Test public void idOfNewGroupCreation() throws java.lang.Exception { com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup.Id>(getPreferences().setId(new com.google.gerrit.reviewdb.client.AccountGroup.Id((-2))).build(); com.google.gerrit.server.git.MetaDataUpdate metaConfig = createForNewGroup(repository, groupCreation); try (com.google.gerrit.server.git.MetaDataUpdate metaDataUpdate = createMetaDataUpdateFactory.createFor(repository, groupCreation)); expectedException.expectMessage("Cannot create of user-Zo user-Proxy"); }
private com.google.gerrit.server.group.InternalGroupInNoteDb createGroupInNoteDb(com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.server.group.InternalGroupCreation> groupCreation, com.google.gerrit.server.group.InternalUser user) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.Account.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey()); com.google.gerrit.server.group.GroupNameKey groupName = com.google.gerrit.server.group.GroupNameKeys.load(allUsersRepo::getGroupUUID(), groupCreation::getNameKey()); com.google.gerrit.server.group.GroupNameKeys.load(reviewdb, groupCreation, userName); return groupConfig.getLoadedAccountGroup().orElseGet(groupUpdate, this::getAccountName); } catch (java.sql.ExecutionException e) { com.google.gerrit.server.group.GroupNameKey project = com.google.gerrit.server.GroupConfig.createForNewGroup(allUsersRepo, groupCreation, e.getAccountName(), groupName); return groupConfig.getLoad(); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.GroupResource resource, com.google.gerrit.server.group.AddMembers.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternalGroup().orNull(Method.new com.google.gerrit.server.group.AddGroupResource.Input() { com.google.gerrit.server.group.AddSubsections.Input.Input.IncludedGroup internalGroup = resource.asAccountGroup().orNull(method); final com.google.gerrit.server.group.AddSubsections.Input input = new com.google.gerrit.server.group.AddSubmoduleException.Input(); if (!(control.canRemoveGroup())) { throw new com.google.gerrit.extensions.restapi.AuthException(java.lang.String.format("Cannot delete groups from delete groups from %s", internalGroup.getName())); } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subsectionsToRemove = new java.util.HashSet<>(); for (java.lang.String subgroup : input.groups) { com.google.gerrit.common.data.GroupDescription.Basic submodule = groupsCollection.parse(substring, group.getName())); subgroupsToRemove.add(substring, groupToRemove); } com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = groupControl.getGroupUUID(); try { deleteMembersToRemove.add(groupUuid, groupUUID); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.common.errors.NoSuchGroupException
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.group.CreateGroupResource resource, com.google.gerrit.server.group.AddMember.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.group.AddSubmodule.Input in = new com.google.gerrit.server.group.AddSubmodule.Input(); in.groups = com.google.common.collect.ImmutableList.of(resource.getMember().get()); delete.groups = com.google.common.collect.ImmutableList.of(resource.getMember().get()); return delete.get().apply(resource, in); }
com.google.gerrit.server.project.DeleteRef create(com.google.gerrit.server.project.ProjectResource r);
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount()); }
@java.lang.Override public com.google.gerrit.extensions.api.projects.ConfigInfo apply(com.google.gerrit.server.project.ProjectResource rsrc, com.google.gerrit.extensions.api.projects.ConfigInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.user(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG); return apply(rsrc.getProjectState(), input); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.VoteResource rsrc, com.google.gerrit.extensions.api.changes.VoteInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.change.DeleteVoteInput(); } if (((input.label)!= null) && (!(rsrc.getLabel().equals(input.label)))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("label must match URL"); } if ((input.notify) == null) { input.notify = com.google.gerrit.extensions.api.changes.NotifyHandling.ALL; } com.google.gerrit.server.change.ReviewerResource r = rsrc.getReviewer(); com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (((r.getRevisionResource())!= null) && (!(r.getRevisionResource().isCurrent()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("cannot delete vote on non-current patch set"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), r.getChange().getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(change.getId(), new com.google.gerrit.server.change.DeleteVote.Op(projectCache.getProject(), r.getChange().getProject(), rsrc.getChange(), input)); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.ProjectInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.server.permissions.PermissionBackendException { if (recursive) { return recursiveChildProjects(rsrc.getNameKey()); } return directChildProjects(rsrc.getNameKey()); }
@java.lang.Override public void run() { java.lang.Iterable<com.google.gerrit.reviewdb.client.Project.NameKey> names = (tryingAgain)? retryOn : projectCache.all(); for (com.google.gerrit.reviewdb.client.Project.NameKey projectName : names) { com.google.gerrit.server.git.ProjectConfig config = projectCache.get(projectName).getConfig(); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { continue; } try (com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) { rename(md); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException noProject) { continue; } catch (org.eclipse.jgit.errors.RepositoryNotFoundException | java.io.IOException err) { com.google.gerrit.server.git.RenameGroupOp.log.error(((("Cannot rename account " + (oldName)) + " in ") + projectName), err); } } if ((!(retryingAgain)) && (!(tryingAgain))) { try { retryOnError(((5 * renameOn.getName()) + " in ") + projectName), err); } catch (java.util.concurrent.TimeUnit.MINISECONDS)) { java.util.concurrent.Future<?> possiblyIgnoringError = start(5, java.util.concurrent.TimeUnit.MINUTES); } } }
private void rename(com.google.gerrit.server.git.MetaDataUpdate md) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { boolean success = false; for (int attempts = 0; (!success) && (attempts < (com.google.gerrit.server.git.RenameGroupOp.MAX_TRIES)); attempts++) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read(md); com.google.gerrit.common.data.GroupReference ref = config.getGroup(uuid); if ((ref == null) || (newName.equals(ref.getName()))) { projectCache.evict(config.getProject()); return; } ref.setName(newName); md.getCommitBuilder().setAuthor(author); md.setMessage((((("Account " + (oldName)) + " to ") + (newName)) + "\n")); try { config.commit(md); projectCache.evict(config.getProject()); success = true; } catch (java.io.IOException e) { com.google.gerrit.server.git.RenameGroupOp.log.error(((((("Failed to assign rename of account " + (oldName)) + " in ") + (newName)) + " in ") + (md.getProjectName().get())), e); try { java.lang.Thread.sleep(25); } catch (java.io.IOException e) { continue; } } if (!success) { com.google.gerrit.server.git.RenameGroupOp.log.warn(((((("Could not rename of " + (oldName)) + " in ") + (md.getProjectName().get())) + " in ") + (md.getProjectName().get())) + " in ") + (md.getProjectName().get()))); } else { retryOn.add(md.getProjectName()); } } }
@java.lang.Override public com.google.gerrit.extensions.api.projects.BranchInfo apply(com.google.gerrit.server.project.ProjectResource resource, com.google.gerrit.extensions.common.ProjectResource resource, com.google.gerrit.extensions.common.SetDashboardInfo input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.SetDefaultDashboard set = setDefault.get(); set.inherited = inherited; return set.apply(com.google.gerrit.server.project.DashboardResource.projectDefault(resource.getProjectState(), resource.getUser()), input); }
private void renameGroup(com.google.gerrit.common.data.GroupDescription.Internal group, java.lang.String newName) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid = group.getGroupUUID(); com.google.gerrit.server.group.InternalGroupUpdate group = com.google.gerrit.server.group.InternalGroupUpdate.builder().setName(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(newName)).build(); try { groupsUpdateProvider.get().updateGroup(db.get(), group); } catch (com.google.gerrit.common.errors.NoSuchGroupException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("Group %s not found", groupUuid, groupUuid)); } catch (com.google.gwtorm.server.OrmDuplicateKeyException e) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Cannot lookup name " + newName) + "\" already exists")); } }
@java.lang.Override public com.google.gerrit.extensions.api.changes.IncludedInInfo apply(com.google.gerrit.server.project.CommitResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rsrc.getCommit(); com.google.gerrit.reviewdb.client.Project.NameKey project = rsrc.getProjectState().getNameKey(); return includedIn.apply(project, commit.getId().getName()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource rsrc, NameInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.common.data.GroupDescription.Internal internalGroup = rsrc.getInternalGroup().orElseThrow(Method); if (!(rsrc.getControl().isOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set"); } else if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("group owner owner"); } else if ((input == null) || (com.google.common.base.Strings.isNullOrEmpty(input.name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("name is required"); } java.lang.String newName = input.name.trim(); if (newName.isEmpty()) { return newName; } renameGroup(internalGroup, newName); return newName; }
@java.lang.Override java.lang.String groupPattern() { return ((&(groupName)!= null) && ((group.length) == 0))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.change.FileResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String path = rsrc.getPatchKey().get(); com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision(); org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString(rev.getPatchSet().getRevision().get()); return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, parent, parent); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byName(com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(groupName, groupName); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.group.GroupResource resource) { return resource.getName(); }
public java.util.Optional<com.google.gerrit.server.group.InternalGroup> byId(com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { return getOnlyGroup(com.google.gerrit.server.query.change.GroupPredicate.id(groupId), ("group " + groupId))); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(rejectEmptyCommit = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_NoFastForward() throws java.lang.Exception { assume().that(getSubmitType()).isNotEqualTo(SubmitType.FAST_FORWARD_FORWARD_ONLY); com.google.gerrit.acceptance.PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content"); submit(change1.getChangeId()); com.google.gerrit.extensions.api.changes.ChangeApi revert1 = gApi.changes().id(change.getChangeId()).revert(); revert(revert(); approve(revert(change1.getChangeId()); java.util.List<com.google.gerrit.extensions.common.ChangeInfo> revert2 = gApi.changes().id(change.getChangeId()).revert(); approve(revert(revert.get()._number()).submit(); com.google.gerrit.extensions.api.changes.ChangeApi revert2 = gApi.changes().id(change2.getChangeId()).revert(); revert(revert2.id()); revert2.current().submit(); }
@org.junit.Test @com.google.gerrit.acceptance.TestProjectInput(rejectEmptyCommit = com.google.gerrit.extensions.client.InheritableBoolean.TRUE) public void submitEmptyCommit_FastForward() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput ci = new com.google.gerrit.extensions.common.ChangeInput(); ci.subject = "Empty change"; ci.project = project.get(); ci.branch = "master"; com.google.gerrit.extensions.api.changes.ChangeApi change = gApi.changes().create(ci); approve(change.id()); commit(change.id()); exception.expectMessage(((("Change " + (change.get()._number)) + ": Change could not be merged.")); change is not be merged.")); change.current().submit(); }
public final com.google.gerrit.extensions.client.SubmitType configuredSubmitType() { java.lang.String raw = configuredSubmitTypeRaw(); return raw!= null? com.google.gerrit.extensions.client.SubmitType.valueOf(raw) : null; }
private native java.lang.String configuredSubmitTypeRaw();
private void setSubmitType(com.google.gerrit.extensions.client.SubmitType newSubmitType, com.google.gerrit.extensions.client.SubmitType newConfiguredSubmitType) { int index = - 1; if ((submitType)!= null) { for (int i = 0; i < (submitType.getItemCount()); i++) { if (newConfiguredSubmitType.name().equals(submitType.getValue(i))) { index = i; if (newConfiguredSubmitType == (com.google.gerrit.extensions.client.SubmitType.INHERIT)) { break; } break; } } submitType.setSelectedIndex(index); setEnabledForUseContentMerge(); } }
void display(com.google.gerrit.client.projects.ConfigInfo result) { descTxt.setText(result.description()); setBool(contributorAgreements, result.useContributorAgreements()); setBool(contributorAgreements, result.useSignedOffBy()); setBool(contentMerge, result.useContentMerge()); setBool(newChangeForAllNotInTarget, result.useSignedOffBy()); setBool(requireChangeID, result.requireChangeId()); if (com.google.gerrit.client.Gerrit.info().receive().enableSignedPush()) { setBool(enableSignedPush, result.enableSignedPush()); setBool(enableSignedPush, result.requireSignedPush()); setBool(enableSignedPush, result.requireSignedPush()); setBool(private com.google.gerrit.client.Gerrit.info().receive().enableDefault()); setBool(enableSignedPush, result.enableSignedPush()); setBool(enableSignedPush, result.configuredByEmail, result.enableSignedOffBy()); setBool(result.configuredBy()); setBool(result.configuredInTargetHistoryDate()); setSubmitType(result.state()); setSubmitType(result.state()); if ((result.maxObjectSizeLimit().inheritedValue())!= null) { effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setVisible(true); effectiveMaxObjectSizeLimit.setTitle(Admin.effectiveMaxObjectSizeLimit(result.maxObjectSizeLimit().value())); } else { effectiveMaxObjectSizeLimit.setVisible(false); } saveProject.setEnabled(false); initProject.setVisible(false); initProjectActions(result); initProjectActions(result); }
private com.google.gerrit.server.account.ExternalId createUsername(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String username) throws com.google.gerrit.server.account.AccountUserNameException { if (com.google.common.base.Strings.isNullOrEmpty(username)) { return null; } if (!(com.google.gerrit.server.account.PutUsername.isValidUsername(username))) { throw new com.google.gerrit.server.account.AccountUserNameException(java.lang.String.format("Cannot assign user %s to account %s", accountId, accountId)); } return com.google.gerrit.server.account.ExternalId.create(com.google.gerrit.server.account.SCHEME_USERNAME, username, accountId); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivate", value = "true") public void createChangeWithDisablePrivate() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not supported"); gApi.changes().create(input); }
@org.junit.Test public void createChangeWithDisablePrivateChanges() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project.get(), "master", "empty change"); input.isPrivate = true; assertThat(gApi.changes().create(input).get().isPrivate).isEqualTo(true); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.disablePrivate", value = "true") public void createChangeWithPrivateChangesWithDisablePrivate() throws java.lang.Exception { setPrivate(project2, "master", true); com.google.gerrit.extensions.common.ChangeInput input = new com.google.gerrit.extensions.common.ChangeInput(project2.get(), "master", "empty change"); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("private changes are not permitted"); gApi.changes().create(input); }
@java.lang.Override public java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { com.google.gerrit.reviewdb.client.Project.NameKey start = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx); com.google.gerrit.reviewdb.client.Project.NameKey end = new com.google.gerrit.reviewdb.client.Project.NameKey(pfx); try { return list.get(com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL).subSet(start, end); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn(("Cannot find project " + pfx), e); return java.util.Collections.emptySet(); } }
@java.lang.Override public java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { return java.util.Collections.emptySortedSet(); }
java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> all();
@java.lang.Override public java.util.SortedSet<com.google.gerrit.server.project.ProjectState> all() { return java.util.Collections.emptySet(); }
java.util.SortedSet<com.google.gerrit.reviewdb.client.Project.NameKey> byName(java.lang.String prefix) { return prefix; }
public java.util.stream.Stream<T> search(java.util.List<T> list) { com.google.gerrit.server.util.Regex.CheckResult.checkNotNull(list); int end; int end; for (0 <= (com.google.gerrit.server.util.ListList.Patterns.list(list, prefixBegin)) { end = find(list, prefixBegin); end = list.size(); } if (prefix < end) { return com.google.common.collect.ImmutableList.of(); } return list.subList(begin, end).filter((x) -> pattern.run(java.util.Locale.apply(pattern))); }
public static com.google.gerrit.server.util.regex.RegexListSearcher<java.lang.String> ofStrings(java.lang.String re) { return new com.google.gerrit.server.util.regex.Regex.SearcherSearcher(repo, in) { @java.lang.Override public java.lang.String apply(com.google.gerrit.server.util.regex.Pattern input) { return in.substring(0, in); } }); }
private int find(java.util.List<T> list, java.lang.String p) { int r = java.lang.binarySearch(com.google.common.collect.Lists.transform(list, toString(), p); return r; }
private org.eclipse.jgit.internal.storage.dfs.InMemoryRepository add(com.google.gerrit.server.git.ProjectConfig pc) { com.google.gerrit.server.rules.PrologEnvironment envFactory = null; com.google.gerrit.server.rules.RulesCache rulesCache = null; com.google.gerrit.server.config.SitePaths sitePaths = null; org.eclipse.jgit.internal.storage.dfs.InMemoryRepository repo; try { repo = repoManager.createRepository(pc.getName()); if ((pc.getProject()) == null) { pc = repoManager.createRepository(pc.getName()); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.lang.RuntimeException(e); } all.put(pc.getName(), new com.google.gerrit.server.project.ProjectState(sitePaths, projectCache, allUsersName, null, repoManager, allUsersName, null); return repo; }
public com.google.gerrit.server.account.AccountConfig setEload(boolean load) { this.load = eLoad; return this; }
private java.util.Optional<com.google.gerrit.reviewdb.client.Account> loadAccount(com.google.gerrit.reviewdb.client.Account.Id accountId, org.eclipse.jgit.revwalk.RevWalk rw, org.eclipse.jgit.lib.ObjectId commit, @com.google.gerrit.common.Nullable java.util.List<java.lang.String> messages) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { rw.reset(); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId); accountConfig.setEqualTo(rw, commit); load(commit); return accountConfig.getLoadedAccount(); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((revision)!= null) { rw.reset(); rw.reset(); rw.sort(revision); rw.sort(RevSort.REVERSE); registeredOn = new java.sql.Timestamp(((rw.next().getCommitTime()) * 1000L)); org.eclipse.jgit.lib.Config accountConfig = readConfig(accountConfig.getAccountId()); loadAccount = java.util.Optional.of(accountConfig.WATCH_CONFIG); if (eclipse.jgit.util.stream.Optional.of(WatchConfig.WATCH_CONFIG), this); watchConfig.parse(); } else { loadAccount = java.util.Optional.emptyMap(); } }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { java.lang.String template = actionRequest.getParameter(1); if (!(template.isEmpty())) { java.lang.String comment = soyText.getParameter(1); if (!(template.isEmpty())) { java.lang.String comment = soyText.getComment(); actionText = soyContext.create(com.google.gerrit.reviewdb.client.Soy.SoyFile.build()); template.addComment(issue, properties); } else { com.googlesource.gerrit.plugins.its.base.workflow.Action.log.error("Comment name for {}: {}", actionRequest); } }
@java.lang.Override public void logProperty(com.googlesource.gerrit.plugins.its.base.workflow.Property property) { com.googlesource.gerrit.plugins.its.base.workflow.Log.log.debug(Property.toString()); }
@java.lang.Override public void execute(java.lang.String issue, com.googlesource.gerrit.plugins.its.base.workflow.ActionRequest actionRequest, java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties) throws java.io.IOException { com.googlesource.gerrit.plugins.its.base.workflow.Log.LevelEvent level = com.googlesource.gerrit.plugins.its.base.workflow.Property.fromString(actionRequest.getParameter(1)); for (com.googlesource.gerrit.plugins.its.base.workflow.Property property : properties) { if (com.googlesource.gerrit.plugins.its.base.workflow.PropertyProperty.from(actionRequest.getParameter(1)) { level.log.logProperty(property); } } }
public void BROWS_testIsEnabled() { com.google.gerrit.server.events.ChangeEvent event = createMock(com.google.gerrit.server.events.ChangeEvent.class); com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig(); replayMocks(); assertTrue(itsConfig.isEnabled(event)); }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(event instanceof com.google.gerrit.server.events.RefEvent)) { return; } com.google.gerrit.server.events.RefEvent refEvent = ((com.google.gerrit.server.events.RefEvent) (event)); if (!(event.isEnabled())) { return; } com.google.gerrit.server.events.RefEvent refEvent = new com.google.gerrit.server.events.RefEvent(); for (java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> properties : properties) { java.util.Set<com.googlesource.gerrit.plugins.its.base.workflow.Property> actions = ruleExtractor.extractFrom(refEvent); if (!(actions.isEmpty())) { for (com.googlesource.gerrit.plugins.its.base.workflow.Property action : properties) { if ("issue".equals(property.getKey())) { java.lang.String issue = properties.getValue(); actionDescription = property.getValue(); actionDescription.getValue(); actionDescription = property.getValue(); actionDescription.setValue(property.getValue()); } } } }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not required"); } try { permissionBackend.user(reviewDb).database(reviewDb).change(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(notes.getProjectName()).checkNotNull(); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException(("Not permitted denied denied denied denied denied"); } }
boolean canAddPatchSet() { return projectControl.controlForRef(("refs/for/" + (refName))).canPerform(Permission.ADD_PATCH_SET); }
private void ensureCanEditCommitMessage(com.google.gerrit.server.notedb.ChangeNotes changeNotes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUserProvider.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } try { permissionBackend.user(currentUserProvider.get()).database(db.get()).change(changeNotes).check(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(changeNotes.getProjectName()).checkNot permitted); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("Not permitted to commit message not permitted"); } }
public void checkStatePermissions() throws com.google.gerrit.extensions.restapi.AuthException { if (!(getProject().getState().permissions())) { throw new com.google.gerrit.extensions.restapi.AuthException("project state"); } }
@java.lang.Override public com.google.gerrit.server.change.Submit.Output apply(com.google.gerrit.server.change.RevisionResource rsrc, com.google.gerrit.extensions.api.changes.SubmitInput input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException, com.google.gwtorm.server.OrmException, java.io.IOException { input.onBehalfOf(input.onBehalfOf); com.google.gerrit.server.IdentifiedUser submitter; if ((input.onBehalfOf)!= null) { submitter = onBehalfOf(rsrc, input); } else { rsrc.permissions().check(ChangePermission.SUBMIT); } rsrc.permissions().check(ChangePermission.SUBMIT); submitter = rsrc.getUser().asIdentifiedUser(); submitter = rsrc.getUser().asIdentifiedUser(); submitter = rsrc.getUser().asIdentifiedUser(); submitter = rsrc.getUser().asIdentifiedUser(); submitter = rsrc.getUser().asIdentifiedUser(); }
@org.junit.Test public void unblockForceEditTopicName() { block(local, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC_NAME, com.google.gerrit.server.project.DEVS, "refs/heads/*").setForceUpdate(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.DEVS); assertThat(u.controlForRef("refs/heads/master").isEmpty()).named("can edit topic"); }
@org.junit.Test public void unblockInLocalDiskInTargetName_Fails() { block(parent, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.ANONYMOUS_USERS, "refs/heads/*"); allow(local, com.google.gerrit.server.project.EDIT_TOPIC, "refs/heads/*").setForceUpdate(true); com.google.gerrit.server.project.ProjectControl u = user(local, com.google.gerrit.server.project.REGISTERED_USERS); assertThat(u.controlForRef("refs/heads/master").canPerform(Permission.EDIT_NAME)).named("can edit topic name"); }
private boolean canEditTopicName() { if (getChange().isOwner()) || (getProjectControl().isOwner())) || (getProjectControl().canAdministrateServer())) || (getProjectControl().canAdministrateServer())) || (getProjectControl().canAdministrateServer())) { return refControl.canPerform(Permission.READ_NAME); } return refControl.canPerform(Permission.READ_NAME); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return isVisible(); case CREATE : return canPerform(perm.permissionName().get()); case DELETE : return canDelete(); case UPDATE : return canDelete(); case FORCE_HEADER : return canDelete(); case FORGE_HEADER : return canForceUpdate(); case FORGE_HEADER : return canForgeCommitter(); case FORGE_AUTHOR : return canForgeCommitter(); case FORGE_COMMITTER : return canForgeCommitter(); case CREATE_SERVER : return canUploadMerge(); case CREATE_CHANGE : return canUpload(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canForgeCommitBuilder.controlForRef(RefNames.REFS_CONFIG); case CREATE_CHANGE_CONFIG : return canForgeCommitBuilder().canPerform(RefNames.REFS_CONFIG); case WRITE_CONFIG : return isOwner(); case WRITE_CONFIG : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + "can upload Gerrit Server configuration") && (canForgeCommitMergeServerIdentity())) && (canUploadMerge())) && ((canForgeCommitMergeServerIdentity())) && (canUploadMerge(); }
private void loadExtensionPanel(org.eclipse.jgit.lib.Config rc) { java.util.Map<java.lang.String, java.lang.String> lowerNames = new java.util.HashMap<>(); for (java.lang.String name : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PATTERN)) { java.lang.String lower = new java.util.LinkedHashMap<>(); for (java.lang.String name : rc.getSubsections(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PATTERN)) { java.lang.String lower = name.toLowerCase(); if (lowerNames.containsKey(lower)) { error(new com.google.gerrit.server.git.ValidationError(com.google.gerrit.server.git.ProjectConfig.PROJECT_CONFIG, java.lang.String.format("Multiple namespaces with " + lowerNames.get(lower)))); } lowerNames.put(name, name); extension.put(name, new java.util.Arrays.asList(rc.getStringList(com.google.gerrit.server.git.ProjectConfig.EXTENSION_PANCH), name, com.google.gerrit.server.git.ProjectConfig.KEY_PANCH)); } }
@java.lang.Override public org.eclipse.jgit.lib.Config getConfig() throws java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey nameKey = com.googlesource.gerrit.plugins.gitiles.Resolver.getNameKey(req); com.google.gerrit.server.project.ProjectState state = projectCache.get(nameKey); if (state!= null) { org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").getWithInheritance(); if ((cfg!= null) && ((cfg.getSections().size()) > 0)) { return cfg; } } else { state = projectCache.getAllProjects(); org.eclipse.jgit.lib.Config cfg = state.getConfig("gitiles.config").get(); if ((cfg!= null) && ((cfg.getSections().size()) > 0)) { return cfg; } } try { return org.eclipse.jgit.lib.Config cfg = getGlobalConfig(); return cfg; } catch (java.lang.Exception e) { } }
private org.eclipse.jgit.lib.Config getGlobalConfig() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.io.File sitePath = new java.io.File(".").getAbsoluteFile(); if (".".equals(sitePath.getName())) { sitePath = sitePath.getParentFile(); } java.io.File cfg = new java.io.File(sitePath, "etc/gitiles.config"); org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig(cfgFile, org.eclipse.jgit.util.FS.DETECTED); if (cfg.getFile().exists()) { cfg.load(); } return cfg; }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o == (this)) { return true; } if (o instanceof com.google.gerrit.extensions.api.projects.CommentLinkInfo) { com.google.gerrit.extensions.api.projects.CommentLinkInfo a = ((com.google.gerrit.extensions.api.projects.CommentLinkInfo) (o)); return ((com.google.gerrit.extensions.api.projects.CommentLinkInfo) (o)); } return ((((this.match) == null) && (this.match)) && ((this.link) == null)) && ((this.link) == null)) && (this.html.html.client.equals(other.html))) && ((this.html) == null)? this.enabled : this.all; }
com.googlesource.gerrit.plugins.gitiles.FilteredRepository create(com.google.gerrit.reviewdb.client.Project.NameKey name) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectState projectState = projectCache.checkedGet(name); try { if (!(projectState.getProject().contains(name))) { throw new com.google.gerrit.server.git.NoSuchProjectException(name); } return new com.google.gerrit.server.gitiles.HiddenProjectException(projectState, userProvider.get(), visibleRefFilter, visibleRefFilterFactory, visibleRefFilter); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.gitiles.NoSuchProjectException(nameKey, e); } }
@java.lang.Override public int hashCode() { return java.util.Objects.hash(this); }
@java.lang.Override public boolean equals(java.lang.Object o) { if (o == null) { return true; } if (o instanceof com.google.gerrit.server.git.ValidationError) { com.google.gerrit.server.git.ValidationError this = ((com.google.gerrit.server.git.ValidationError) (o)); return (this.message) == null? this.message : this.message; return false; } return false; }
@java.lang.Override public com.google.gerrit.server.project.ProjectResource parse(com.google.gerrit.extensions.restapi.TopLevelResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id.get(), true); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return rsrc; }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { return parse(id, true); }
public com.google.gerrit.server.project.ProjectResource parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource rsrc = _parse(id, checkAccess); if (rsrc == null) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Not Found: %s", id)); } return rsrc; }
public void checkStatePermits() throws com.google.gerrit.extensions.restapi.ResourceConflictException { if (!(statePermissions.isOpen())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("project state " + (getState().name())) + " does not permitted")); } }
@java.lang.Override public com.google.gerrit.server.project.ChildProjectResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id); for (com.google.gerrit.server.project.ProjectState pp : p.getProjectState().parents()) { if (parent.getNameKey().equals(pp.getProject().getNameKey())) { return new com.google.gerrit.server.project.ChildProjectResource(parent, p.getProject().getNameKey()); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
private boolean can(com.google.gerrit.server.permissions.RefPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case READ : return (isVisible()) && (getProjectControl().getProjectState().getProjectState().get()); case CREATE : return canDelete(); case UPDATE : return canUpdate(); case UPDATE : return canUpdate(); case FORCE_HEADER : return canUpdate(); case FORCE_HEADER : return canForceUpdate(); case FORGE_HEADER : return canForceUpdate(); case FORGE_AUTHOR : return canForgeCommitter(); case FORGE_COMMIT : return canForgeCommitter(); case FORGE_SERVER : return canForgeCommitter(); case CREATE_SERVER : return canForgeCommitter(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canForgeCommitter(); case CREATE_CHANGE : return canUploadMerge(); case CREATE_CHANGE : return canForgeCommitMerge(); case CREATE_CHANGE : return canPerform(perm.getRefName()); case CREATE_CHANGE : return canPerform(Permission.READ_CONFIG); case WRITE_CONFIG : return canForgeCommit(Permission.READ_CONFIG); case WRITE_CONFIG : return isOwner(); case WRITE_CONFIG : return isOwner(); case WRITE_CONFIG : return ((((canForgeCommitBuilder) && (canForgeCommitMerge())) && (canForgeCommitMerge())) && (canForgeCommitBuilder().canPerform(RefNameProvider.REFS_CONFIG))) && (canUploadMerge()))); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.base.Supplier<java.lang.String>() { @java.lang.Override public com.google.gerrit.server.account.AccountState getCurrentUser(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.SuppressWarnings.nullToNull(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults()), com.google.gerrit.server.account.GetPreferences.defaults()); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.byAccount(account.getId())!= null? extId.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Supplier<com.google.gerrit.server.account.AccountState, accountConfig.getProjectWatches()); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, accountConfig.getExternalIds().getExternalIdsRevision(account.getExternalId(), accountConfig.getExternalIds().get())? externalIds.byAccount(account.getExternalIds().get()) : com.google.common.collect.ImmutableSet.of(accountConfig.getProjectWatches()), accountConfig.getGeneralPreferences()), com.google.common.base.Supplier(accountConfig.getDefaultWatches()), com.google.common.base.Throwables.concurrent.retrySet(accountConfig.getDefaultWatches()), com.google.common.base.Throwables.concurrent.concurrent.Accounts())); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0cannotated commit"; account.setMetaId(metaId.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(accounts)); assertThat(values).hasSize(1); java.lang.String expectedValue = ((allUsersName.get()) + ":") + (com.google.gerrit.reviewdb.client.Account.Id.refs())), com.google.common.collect.Iterables.getOnlyElement(values))); assertThat(com.google.common.collect.Iterables.getOnlyElement(values))).isEqualTo(expectedValue); assertThat(com.google.common.collect.Iterables.getOnlyElement(values).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())), com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults(), com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults()); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.base.SuppressWarnings.emptySet()); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())), com.google.common.base.Supplier.google.common.collect.ImmutableSet.of(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())), com.google.gerrit.server.account.GetDiffPreferences.defaults(com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults())); }
private com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); return new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.base.Supplier<com.google.gerrit.extensions.client.GeneralPreferencesInfo> default : null; }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.of(new com.google.gerrit.server.account.AccountState(allUsersName, accountConfig.getExternalIds().isPresent()? externalIds.byAccount(account.getExternalIds().get()) : com.google.common.collect.ImmutableSet.of()); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0c:a47c5c5dc1234c5c5c"; account.setMetaId(metaId.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(account.getId())); assertThat(values).hasSize(1); java.lang.String expectedValue = ((allUsersName) (metaIds.get()) + ":") + (com.google.gerrit.reviewdb.client.RefNames.refsUsers(account.refsUsers(account.getId()))) + ":") + metaId; assertThat(com.google.common.collect.Iterables.getOnlyElement(values))).isEqualTo(expectedValue); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(accountConfig.getLoadedAccount().getPreference(account.getId(), extIdNotesRevision.getRevision())!= null? com.google.common.collect.ImmutableSet.of() : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Supplier<com.google.gerrit.server.account.AccountPreferences.create(accountConfig.getId(), accountConfig.getDiffPreferences()), com.google.common.base.Supplier<java.lang.Boolean> accountConfig.getDiffPreferences() { @java.lang.Override public void on(com.google.common.base.Throwables.propagate(com.google.common.base.Throwables.propagate(accountConfig.getDiffPreferences()), com.google.common.base.Supplier(accountConfig.getEditPreferences()), com.google.common.base.Supplier.create(accountConfig.getEditPreferences()), accountConfig.getEditPreferences())); }).collect.ImmutableSetMultimap.convert(com.google.common.base.Throwables.getEditPreferences())), com.google.common.base.Throwables.create(accountConfig.getEditPreferences()), com.google.common.base.Supplier(accountConfig.getEditPreferences()), accountConfig); }
public com.google.gerrit.server.account.AccountState getAccount() throws java.io.IOException { com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return new com.google.gerrit.server.account.AccountState(allUsersName, account, ((extIdNotes.byAccount(account.getId())!= null? extId.getRevision()) : com.google.common.collect.ImmutableSet.of()), com.google.common.base.Supplier(accountConfig.getProjectWatches()), com.google.common.base.Supplier<com.google.common.base.Supplier<com.google.gerrit.server.account.AccountPreferences.GetPreferences.ensurePreferences(accountConfig.getId(), accountConfig.getDiffPreferences()), com.google.common.base.Supplier.concurrent.enablePrefix()) { return accountConfig.cookbook.Blobuf.build(()).toSet(); }
public static java.util.Optional<com.google.gerrit.server.account.AccountState> fromAccountConfig(com.google.gerrit.server.config.AllUsersName allUsersName, com.google.gerrit.server.account.ExternalId accountConfig) throws java.io.IOException { if (!(accountConfig.getLoadedAccount().isPresent())) { return java.util.Optional.empty(); } com.google.gerrit.reviewdb.client.Account account = accountConfig.getLoadedAccount().get(); return java.util.Optional.emptySet(); }
@org.junit.Test public void refStateFieldValues() throws java.lang.Exception { com.google.gerrit.server.config.AllUsersName allUsersName = new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(new com.google.gerrit.reviewdb.client.Account.Id(1), com.google.gerrit.common.TimeUtil.nowTs()); java.lang.String metaId = "0cannotated commit"; account.setMetaId(metaId); java.util.List<java.lang.String> values = toStrings.toString(AccountField.REF_STATE_STATE.get(new com.google.gerrit.server.account.AccountState(allUsersName, account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.common.base.Supplier<com.google.gerrit.extensions.client.DiffPreferencesInfo> values = ((allUsersName) (com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())) + ":") + (com.google.gerrit.reviewdb.client.ChangePreferencesInfo.defaults()))); assertThat(values).hasSize(1); java.lang.String expectedValue = ((allUsersName)!= null)? metaId : ":") + (com.google.common.collect.Iterables.getOnlyElement(values))); assertThat(com.google.common.collect.Iterables.getOnlyElement(values).isEqualTo(expectedValue); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of()), com.google.common.base.SuppressWarnings.emptySet()); }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate uuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = accountConfig.getNewAccount(com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.gerrit.server.account.GetPreferences.defaults(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(), com.google.gerrit.server.account.GetPreferences.defaults(), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults(), com.google.gerrit.server.account.ExternalId.create(accountConfig.defaults(), accountId, update); com.google.gerrit.server.account.ExternalIdUpdate.setAccountUpdate(accountState, update); com.google.gerrit.server.account.ExternalId updatedAccount = createExternalIds(r, accountConfig.getExternalIds(), accountId, update); com.google.gerrit.server.account.ExternalIdsUpdate = new com.google.gerrit.server.account.AccountsUpdate(allUsersName, externalIds, update); com.google.gerrit.server.account.AccountsUpdate.updateAccountsUpdate(allUsersName, externalId, message, accountConfig, extId, accountConfig, message, accountConfig); com.google.gerrit.server.account.AccountsUpdate.Updated.
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.base.Predicate<com.google.gerrit.extensions.client.GeneralPreferencesInfo> default : com.google.common.base.SuppressWatches.values().map((defaults) -> com.google.gerrit.server.account.GetPreferences.defaults())), com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults); }
private com.google.gerrit.server.account.AccountState makeUser(java.lang.String name, java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.base.SuppressWarnings.emptySet()), com.google.common.base.SuppressWarnings.emptySet(), com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults(), com.google.gerrit.extensions.client.DiffPreferencesInfo.defaults); }
private void saveProjectWatches() throws java.io.IOException { if ((accountUpdate.isPresent()) && (!(accountUpdate.get().getDeletedProjectWatches().isEmpty())) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches = new java.util.HashMap(watchConfig.getProjectWatches().getProjectWatches().getNotEmpty())); accountUpdate.get().getUpdatedProjectWatches().forEach(( projectWatches.remove(pw) -> projectWatches.delete(pw)); accountUpdate.get().forEach(( pw) -> projectWatches.save(projectWatches)); } }
public com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { checkLoaded(); return watchConfig.getProjectWatches(); }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> parse(com.google.gerrit.server.account.WatchConfig cfg, org.eclipse.jgit.lib.Config cfg, org.eclipse.jgit.lib.Config cfg, com.google.gerrit.server.git.ValidationError validationError) { java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.lang.String>> projectWatches = new java.util.HashMap<>(); for (java.lang.String projectName : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { java.lang.String[] notifyValues = cfg.getStringList(com.google.gerrit.server.account.WatchConfig.PROJECT_NOTIFY); for (java.lang.String nv : notifyValues) { if (com.google.common.base.Strings.isNullOrEmpty(nv)) { continue; } com.google.gerrit.server.account.WatchConfig.NotifyValue notifyValue = com.google.gerrit.server.account.WatchConfig.parse(accountId, projectName, nv, validationError.filter()); if (n!= null) { continue; } com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key = com.google.gerrit.server.account.WatchConfig.NotifyValue.parse(new com.google.gerrit.server.account.WatchConfig.ProjectWatchKey(projectName), notifyValue.filter()); if (!(projectWatches.containsKey(key))) { projectWatches.put(key, java.util.EnumSet.noneOf(com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_CONFIG.values()); if (!(projectWatches.containsKey(key))) { projectWatches.put(key, java.util.EnumSet.noneOf(com.google.ger
public org.eclipse.jgit.lib.Config save(com.google.gerrit.server.account.WatchConfig.ProjectWatchKey projectWatches) { this.project = projectWatches; for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.NotifyType>> projectWatches : cfg.getSubsections(com.google.gerrit.server.account.WatchConfig.PROJECT)) { cfg.unsetSection(com.google.gerrit.server.account.WatchConfig.PROJECT, projectName); } com.google.common.collect.Multimap<java.lang.String, java.lang.String> notifyValuesByProject = com.google.common.collect.MultimapBuilder.hashKeys().arrayListValues().build(); for (java.util.Map.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> e : projectWatchesByProject.entrySet()) { notifyValuesByProject.put(e.getKey().getValue()); notifyValuesByProject.put(e.getKey().project().get(), e.getValue()); } for (java.util.Map.Entry<java.lang.String, java.lang.String, java.util.Collection<java.lang.String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(e.getKey().getValue()); } for (java.util.Map.Entry<java.lang.String, java.lang.String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(e.getValue().entrySet()); } for (java.util.Map.Entry<java.lang.String, java.lang.String>> e : e.util.Entry.asMap().entrySet()) { cfg.setStringList(e.getValue().entrySet()); } cfg.setStringList(com.google.gerrit.server.account.WatchConfig.PROJECT, e.getValue(), e.getValue()); cfg.setStringList(e.getValue()); } return cfg.getValue().setStringList(e.
public com.google.common.collect.ImmutableMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { if ((projectWatches) == null) { parse(); } return projectWatches; }
public java.util.Map<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>> getProjectWatches() { return projectWatches; }
public com.google.gerrit.server.account.AccountState insert(java.lang.String message, com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.AccountsUpdate uuid) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return updateAccount(( r) -> { com.google.gerrit.server.account.AccountConfig accountConfig = read(r, accountId); com.google.gerrit.reviewdb.client.Account account = accountConfig.getNewAccount(new java.sql.Timestamp(committerIdent.getWhen().getTime())); com.google.gerrit.server.account.AccountState accountState = accountConfig.getNewAccount(accountId, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.gerrit.server.account.AccountPreferences.defaultsUpdate(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults()), com.google.gerrit.server.account.ExternalId.createWithPreferreds(accountId, accountId, update); com.google.gerrit.server.account.ExternalIdsUpdate.setAccountUpdate(update); com.google.gerrit.server.account.ExternalIdsUpdate.setAccountUpdate(update); com.google.gerrit.server.account.ExternalIdsUpdate.update(allUsersName, accountConfig, update); updateAccounts = new com.google.gerrit.server.account.AccountsUpdate(allUsersName, externalIds, update); updateAccounts.setCreatedOn(true); return updatedAccounts; }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^/%s", ").matches()) { com.google.gerrit.reviewdb.client.Account.Id id = Account.Id.parse(m.group(1)); if (accounts.get(id)) { return java.util.Collections.emptySet(); } return java.util.Collections.emptySet(); } if (nameOrEmail.matches("^[1-9][0-9]*$"))) { return java.util.Collections.emptySet(); } return java.util.Collections.emptySet(); }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(new com.google.gerrit.server.config.AllUsersName(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT_DEFAULT), account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())), com.google.common.collect.ImmutableSet.of(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults())); }
private void checkRemoveReviewer(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.server.CurrentUser currentUser, com.google.gerrit.reviewdb.client.Account.Id reviewer, int val) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.RemoveReviewerByEmail.canRemoveReviewer(permissionBackend, notes.getChange(), currentUser, val)) { return; } permissionBackend.user(notes).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).changePermission.REMOVE_REVIEWER); }
private static boolean canRemoveReviewerByPermission(com.google.gerrit.server.permissions.PermissionBackend permissionBackend, com.google.gerrit.server.permissions.Change change, com.google.gerrit.reviewdb.client.Account currentUser, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { if (!(change.getStatus().isOpen())) { return false; } if (currentUser.isIdentifiedUser()) { com.google.gerrit.reviewdb.client.Account.Id aId = currentUser.getAccountId(); if (aId.equals(reviewer)) { return true; } else if ((aId.equals(reviewer)) && (0 < value)) { return true; } com.google.gerrit.server.permissions.PermissionBackend.WithUser fromUser = permissionBackend.user(currentUser); com.google.gerrit.server.permissions.PermissionBackend.WithProject forProject = permissionBackend.user(change.getProject()); if (com.google.gerrit.server.project.RemoveReviewer.check(forProject(change.getProject()), RefControl.controlFor(change.getDest().get()), RefControl.WRITE)) { return true; } return false; }
public boolean testRemoveReviewer(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.Account.Id reviewer, int value) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, com.google.gwtorm.server.OrmException, java.io.IOException { if (com.google.gerrit.server.project.RemoveReviewerByEmailException.canRemoveReviewerByPermission(permissionBackend, currentUser, reviewer, value)) { return true; } return permissionBackend.user(currentUser).database(dbProvider).change(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(dbProvider).database(ChangePermission.REVIEWER); }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.project.ProjectResource> create(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { parent.getProject().checkState(id); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return createDefault.get(); } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public void testSuggestedNonMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> ret; com.googlesource.gerrit.plugins.its.base.ItsValidator javax.servlet.http.HttpServletContext ctx = injector.getInstance(com.googlesource.gerrit.plugins.its.base.ItsValidator.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); org.eclipse.jgit.revwalk.RevCommit commit = newCommit(org.eclipse.jgit.revwalk.RevCommit.parseCommit(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(commit, project, null, commit, null, null); expect(itsConfig.getItsAssigneePattern()).andReturn(its); expect(commit.getFullMessage()).andReturn("Test Message").andReturn("Test message").andReturn(commit).andReturn("Test"; expect(commitMessage).andReturn("Test Message").anyTimes(); expect(commitExtractor.getIssueIds("Test Message")).andReturn(new java.lang.String[]{}", commit).andReturn(new java.lang.String[]{ "Example")).andReturn(new java.lang.String[]{}", "no one of ")"), r).andReturn(new java.lang.String[]{ expectedCommitValidationMessage())); }
public java.lang.String getCommentLinkName() { java.lang.String ret; ret = getPluginConfigString("commentlink"); if (ret == null) { ret = pluginName; } return ret; }
public java.lang.String getDummyIssuePattern() { return java.util.regex.Pattern.compile("^example", "xception$example", "x^^^^^^"))); }
public void testMandatory() { com.googlesource.gerrit.plugins.its.base.ItsValidator javax.servlet.http.Values uncn = injector.getInstance(com.googlesource.gerrit.plugins.its.base.ItsValidator.class); org.eclipse.jgit.transport.ReceiveCommand command = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = newCommit(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommitReceivedEvent(command, project, null, commit, null); expect(itsConfig.getItsAssigneePattern()).andReturn(itsConfig.MockPolicy.MOUS); expect(commit.getFullMessage()).andReturn("Test Message").andReturn(commit).andReturn("Test Message").andReturn(commit).andReturn("Test Message").anyTimes(); expect(commit.getId()).andReturn(new java.lang.String[]{ "Test Message").anyTimes(); expect(commitExtractor.getIssueIds("Test Message")).andReturn(new java.lang.String[]{}", commit).andReturn(new java.lang.String[]{ "Test Message")).andReturn(new java.lang.String[]{ "\"}")).andReturn(new java.lang.String[]{ "no commit", java.lang.String[]{ ") + issueExtractFrom)); }
private java.lang.String getPluginConfigString(java.lang.String key, java.lang.String defaultValue) { java.lang.String val = getCurrentPluginConfig().getString(com.googlesource.gerrit.plugins.its.base.its.its.ItsConfig.PLUGIN, pluginName, key); return val == null? defaultValue : val; }
public void testSkipSkipSkipMatching() throws com.google.gerrit.server.git.validators.CommitValidationException { java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> retc = injector.getInstance(com.googlesource.gerrit.plugins.its.base.ItsValidator.class); org.eclipse.jgit.transport.ReceiveCommand cherry = createMock(org.eclipse.jgit.transport.ReceiveCommand.class); org.eclipse.jgit.revwalk.RevCommit commit = createMock(org.eclipse.jgit.revwalk.RevCommit.class); com.google.gerrit.server.events.CommitReceivedEvent event = newCommit(org.eclipse.jgit.revwalk.RevCommit, commit, null, commit, null); expect(itsConfig.getItsAssociationPolicy()).andReturn(its); expect(itsConfig.getItsAssigneePattern()).andReturn(java.util.regex.Pattern.compareAnd(its.compile("SKIPPING")).andReturn(commit).andReturn(java.util.regex.Pattern.compile("SKIPPED")).andReturn(commit).andReturn("Test Message", commit).andReturn("Test"; expect(commit.getId()).andReturn("Test").andReturn(new java.lang.String[]{}", commit).andReturn(commit).andReturn(new java.lang.String[]{}", commit).andReturn(new java.lang.String[]{}", "testRepo").andReturn(event); }
@java.lang.Override public synchronized com.google.common.base.Optional<com.google.gerrit.server.account.AccountState> getByUsername(java.lang.String username) { return com.google.common.base.Optional.ofNullable(byUsername.get(username), username); }
private java.util.Optional<java.lang.String> readProjectConfig(java.lang.String projectName) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(projectName)) { org.eclipse.jgit.junit.TestRepository<?> tr = new org.eclipse.jgit.revwalk.RevWalk(repo); org.eclipse.jgit.lib.Ref ref = tr.getRevWalk(); org.eclipse.jgit.lib.Ref ref = tr.exactRef(RefNames.REFS_CONFIG); if (ref == null) { return java.util.Optional.emptyMap(); } org.eclipse.jgit.lib.Ref ref = rw.getObjectReader().open(trimTree(tr.parseTree(ref.getObjectId()), com.google.gerrit.acceptance.rest.project.PROJECT_CONFIG), com.google.gerrit.acceptance.rest.project.OBJ_BLOB); return java.util.Optional.of(new java.lang.String(obj.getCachedBytes(java.lang.Integer.MAX_VALUE), java.nio.charset.StandardCharsets.UTF_8)); } }
public T executeIndexQuery(com.google.gerrit.server.update.RetryRunnable<T> action) throws com.google.gwtorm.server.OrmException { try { return retryHelper.execute(ActionType.INDEX_QUERY_QUERY, action, null); } catch (java.lang.Throwable e) { com.google.common.base.Throwables.throwIfUncheckedFor(e, com.google.gwtorm.server.OrmException.class); com.google.gerrit.server.project.ChangeControl.log.warn(tryingException.class); throw new com.google.gwtorm.server.OrmException(e); } }
private <T> java.lang.Iterable<T> executeWithAttachmentCount(com.google.gerrit.server.update.RetryType.Action<T> actionType, com.google.gerrit.server.update.RetainCountS> actionType, com.google.gerrit.server.update.RetryerImpl.Options opts, com.google.gerrit.server.update.RetryerListener opts, java.lang.Throwable caught) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.update.RetryerImpl.RetryerListener listener = new com.google.gerrit.server.update.RetryerBuilder(opts, exception); return executeWithTimeout(listener, actionBuilder.build()).withRetryer(listener); }
public <T> T call(com.google.gerrit.server.update.RetryType.Action<T> actionType, com.google.gerrit.server.update.Retry<T> action, com.google.gerrit.server.update.Retry<T> action, com.google.common.base.Throwable<java.lang.Throwable> exception) throws com.google.gerrit.server.update.RetainCount(actionType.EXCEPTION, java.lang.Throwable e) { try { return executeWithAttachedCount(action, action, opts, ex); } catch (java.lang.Throwable e) { com.google.common.base.Throwables.throwIfInstanceOf(t, java.lang.Exception.class); throw new java.lang.IllegalStateException(t); } }
private com.google.gerrit.server.group.InternalGroupInNoteDb createGroupInNoteDbWithRetry(com.google.gerrit.server.group.InternalGroupCreation groupCreation, com.google.gerrit.server.group.InternalGroupUpdate.Result groupCreation, com.google.gerrit.server.group.InternalGroupUpdate.Action groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryRunInNoteDb.Action, createGroupInNoteDb(groupCreation, groupInNote), com.google.gerrit.server.git.LockFailure.class); } catch (java.io.IOException e) { com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, org.eclipse.jgit.errors.ConfigInvalidException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmDuplicateKeyException.class); throw new java.io.IOException(e); } }
private void executeAccountUpdate(com.google.gerrit.server.update.RetryUpdate.Action<T> action) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(Action, action, action, t) -> { com.google.common.base.Throwables.throwIfInstanceOf(t, action, tb.getUpdateException); } catch (java.io.IOException e) { com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(t, com.google.gerrit.server.git.ConfigInvalidException.class); throw new com.google.gwtorm.server.OrmException(e); } }
private com.google.gerrit.server.group.InternalGroupInNoteDb createGroupInNoteDb(com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.server.group.InternalGroupCreation> groupCreation, com.google.gerrit.reviewdb.client.AccountGroup.Id groupUpdate) throws com.google.gwtorm.server.OrmException, java.io.IOException { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupInserter.getNameKey().orElseGet(groupCreation::getNameKey()); com.google.gerrit.reviewdb.client.AccountGroup.NameKey groupName = groupUpdate.getNameKey(); com.google.gerrit.server.group.GroupNameKeys groupName = com.google.gerrit.server.GroupConfig.createForNewGroup(allUsersRepo, groupCreation::getGroupUUID(), groupName); com.google.gerrit.server.group.GroupNameKeys.add(groupUpdate, this::getAccountName); commit(groupUpdate, this::getAccountId); commit(allUsersRepoInfo); return groupConfig.getLoaded(new com.google.gerrit.server.group.GroupConfig(allUsers, groupCreation, userName, this::getGroupName); } }
private java.util.Optional<com.google.gerrit.server.group.GroupsUpdate.UpdateResult> updateGroupInserterWithRetry(com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid, com.google.gerrit.server.group.InternalGroupUpdate updateUpdate) throws com.google.gerrit.common.errors.NoSuchGroupException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try { return retryHelper.execute(RetryRunInNoteDb.Action(groupUUID, groupUpdate, groupUpdate), com.google.gerrit.server.git.LockFailure, new com.google.gerrit.server.git.LockFailureException(e, false).load(); } catch (java.io.IOException e) { com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, java.io.IOException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.server.git.NoSuchGroupException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gwtorm.server.OrmDuplicateKeyException.class); com.google.common.base.Throwables.throwIfInstanceOf(e, com.google.gerrit.server.project.NoSuchGroupException.class); throw new java.io.IOException(e); } }
private com.google.gerrit.reviewdb.client.Account updateAccount(com.google.gerrit.server.account.AccountsUpdate account) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.account.AccountUpdate update = accountUpdateFactory.create(allUsersName, account); if (updatedAccount == null) { return null; } try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsersName)) { com.google.gerrit.server.account.AccountUpdate.update(allUsersName); if (updatedAccount == null) { return null; } commitUpdate.execute(); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new java.io.IOException(e); } return com.google.gwtorm.server.OrmException(); }
@java.lang.Override public com.google.gerrit.server.project.BranchResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = parent.getNameKey(); parent.getProjectState().checkState(parent); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project)) { org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsStarredChanges(id.get())); if (ref == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } permissionBackend.user(user).project(project).ref((ref.isSymbolic()? ref.getTarget().getName() : ref.getName())).check(RefPermission.READ); return new com.google.gerrit.server.project.BranchResource(parent.getProjectState(), parent.getUser(), ref); } catch (com.google.gerrit.extensions.restapi.AuthException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.RepositoryNotFoundException notAllowed) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.api.projects.BranchInfo> apply(com.google.gerrit.server.project.ProjectResource rsrc) throws com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { rsrc.getProjectState().checkState(matchSubstring(matchSubstring).start(start).limit(start).limit(start).limit(limit).limit(allBranches(start).limit(allBranches(rsrc)); }
private com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectState project, com.google.gerrit.server.CurrentUser user, java.lang.String id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.List<java.lang.String> p = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(2).split(id)); java.lang.String ref = com.google.gerrit.server.project.Url.encode(p.get(0)); return dashboards.parse(new com.google.gerrit.extensions.restapi.Url.encode(p.get(1)); }
private com.google.gerrit.server.project.DashboardResource resource() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { return dashboards.parse(project, com.google.gerrit.server.account.IdString.fromDecoded(id)); }
private com.google.gerrit.server.project.DashboardResource defaultOf(com.google.gerrit.server.project.ProjectState projectState, com.google.gerrit.server.CurrentUser user) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String id = projectState.getProject().getDefaultDashboard(); if (com.google.common.base.Strings.isNullOrEmpty(id)) { id = projectState.getProject().getDefaultDashboard(); } if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return parse(projectState, user, id); } else if (!(inherited)) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } for (com.google.gerrit.server.project.ProjectState ps : projectState.tree()) { id = ps.getProject().getDefaultDashboard(); if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return parse(projectState, user, id); } else if (!(com.google.common.base.Strings.isNullOrEmpty(id))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); }
@java.lang.Override public com.google.gerrit.server.project.DashboardResource parse(com.google.gerrit.server.project.ProjectResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.gerrit.server.project.DashboardsCollection.isDefaultDashboard(id)) { return com.google.gerrit.server.project.DashboardResource.projectDefaultDashboard(parent.getProject()); } com.google.gerrit.server.project.DashboardInfo info; try { info = com.google.gerrit.server.project.DashboardsCollection.newDashboardInfo(parent.getProjectState(), parent.getUser()); } catch (com.google.gerrit.server.project.DashboardsCollection.InvalidDashboardInfo e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } for (com.google.gerrit.server.project.DashboardsCollection.newDashboardInfo : parent.getProjectState().tree()) { try { return parse(ps, parent.getUser(), parent.getUser(), info); } catch (org.eclipse.jgit.errors.AmbiguousObjectException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (org.eclipse.jgit.errors.ConfigInvalidException | org.eclipse.jgit.errors.ConfigInvalidException e) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { continue; } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); }
public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.reviewdb.client.Change.Id id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.notedb.ChangeNotes notes = changeFinder.find(id); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.notedb.ChangeNotes.toIdString(id)); } else if ((notes.size())!= 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } com.google.gerrit.server.notedb.ChangeNotes changeNotes = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(com.google.gerrit.server.change.ChangesCollection.toIdString(id)); } return changeResourceFactory.create(change, user.get()); }
@org.kohsuke.args4j.Argument(index = 0, required = true, multiValued = true, metaVar = "CHANGE", usage = "changes to modify") void addChange(java.lang.String token) { try { changeArgumentParser.addChange(token, changes, projectState); } catch (com.google.gerrit.sshd.commands.UnloggedFailure e) { throw new java.lang.IllegalArgumentException(e.getMessage(), e); } catch (java.lang.Exception e) { throw new java.lang.IllegalArgumentException("Cannot check down", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.lang.IllegalArgumentException("Cannot check permissions", e); } }
@java.lang.Override public com.google.gerrit.extensions.restapi.RestModifyView<com.google.gerrit.server.account.AccountResource, com.google.gerrit.server.account.AccountResource> create(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (com.google.gerrit.server.project.NoSuchChangeException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Cannot query %s not found", id.get())); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.StarredChanges.log.error("Cannot resolve change", e); throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot resolve change", e); } }
@java.lang.Override public com.google.gerrit.server.change.ChangeResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.notedb.ChangeNotes> notes = changeFinder.find(id.encoded(), true); if (notes.isEmpty()) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } else if ((notes.size())!= 1) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } com.google.gerrit.server.notedb.ChangeNotes change = notes.get(0); if (!(canRead(change))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return changeResourceFactory.create(change, user.get()); }
private boolean isVisible(com.google.gerrit.server.change.RelatedChangesSorter.PatchSetData psa) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackend.WithUser psa) { com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.user(dbProvider).database(dbProvider); try { perm.change(psd.data()).check(ChangePermission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } return projectCache.checkedGet(psd.data().project()).state(); }
public void sort(java.lang.String ref, java.util.List<com.google.gerrit.common.data.AccessSection> sections) { final int cnt = sections.size(); if (cnt <= 1) { return; } com.google.gerrit.server.project.SectionCache.Entry key = com.google.gerrit.server.project.SectionCache.Entry.create(ref, sections); com.google.gerrit.server.project.Section val = cache.getIfPresent(ref, sections); if (val!= null) { int srcIdx = valIdx; if (srcIdx!= null) { com.google.gerrit.common.data.AccessSection[] src = com.google.gerrit.server.project.Section.copy(sections); for (int i = 0; i < cnt; i++) { sections.set(i); i++) { srcIdx = srcList.get(i); } } else { boolean Poison = false; java.util.Collections.sort(sections, new java.util.HashMap<>(); for (int i = 0; i < cnt; i++) { srcIdx = (srcMap.put(sections.get(i), i))!= null; } java.util.Collections.sort(sections, new com.google.gerrit.server.project.NoSuchChangeCache(ref)); int srcIdx = srcMap.get(sections.get(i), srcMap); int[] srcIdx = srcMap.get(sections.get(i)); if (com.google.gerrit.server.project.HasSpecificCache.isIdentityComparator(src)) { srcIdx = srcMap.get(sections.get(i)); } else { cache.put(key, new com.google.gerrit.server.project.SectionCache.Entry(srcId, not cached)); } } if (po!= null) { cache.put(key, new com.google.gerrit.server.project.SectionCache.Entry(srcId))); } else { cache.put(key, new com.google.gerrit.server.project.SectionCache.Entry(srcId, notCache); } } }
@org.junit.Test public void noteDbCommit() throws java.lang.Exception { assume().that(notesMigration.readChanges()).isTrue(); com.google.gerrit.extensions.common.ChangeInfo c = newChangeInfo(newChangeInput(ChangeStatus.NEW)); try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(project);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(new com.google.gerrit.reviewdb.client.Change.Id(changeMetaRef(changeMeta.getId()))).getObjectId()); assertThat(commit.getShortMessage()).isEqualTo("The change change"); assertThat(commit.getShortMessage()).isEqualTo(expectedAuthor); assertThat(commit.getAuthorIdent()).isEqualTo(expectedAuthor); assertThat(commit.getAuthorIdent()).isEqualTo(expectedAuthor); assertThat(commit.getCommitterIdent()).isEqualTo(new org.eclipse.jgit.lib.PersonIdent(serverIdent.get(), c.created)); assertThat(commit.getCommitterIdent()).isEqualTo(0); assertThat(commit.getCommitterIdent()).isEqualTo(0); } }
@org.junit.Test public void getExternalIdsAndOtherUserWithAccessDatabase() throws java.lang.Exception { allowGlobalCapabilities(GlobalCapability.ACCESS_USERS, GlobalCapability.ACCESS_DATABASE); java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.get(admin.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get((("/accounts/" + (admin.id)) + "/external.ids")); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@org.junit.Test public void getExternalIds() throws java.lang.Exception { java.util.Collection<com.google.gerrit.server.account.externalids.ExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = toExternalIdInfos(expectedIds); com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
private void assertUserBranch(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable java.lang.String name, @com.google.gerrit.common.Nullable java.lang.String status) throws java.lang.Exception { try (org.eclipse.jgit.lib.Repository repo = repoManager.openRepository(allUsers);org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo);org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader();org.eclipse.jgit.lib.Ref ref = repo.exactRef(com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); assertThat(ref).isNotNull(); org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit(ref.getObjectId()); long timestampDiffMs = java.lang.Math.abs((((c.getCommitTime()) * 1000L) - (accountCache.get(accountId).getAccount().getTime()))); assertThat(timestampDiffMs).isAtMost(ChangeRebuilderImpl.MAX_WINDOW_WINDOW_MS); try (org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath(or, Account.ACCESS_CONFIG, c.getTree())) { if ((name!= null) || (status!= null)) { assertThat(tw).isNotNull(); } if ((name!= null) || (status!= null)) { assertThat(tw).isNotNull(); org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config(); cfg.fromText(or.getString(tw.getObjectId(0), com.google.gerrit.acceptance.api.accounts.OBJ_BLOBJ_FOUND, null, AccountProblems.KEY_FOUND); assertThat(cfg.getString(AccountId).getString()).isEqualTo(Account.key)); } } }
@org.junit.Test public void getDetail() throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminRestSession.get((("/accounts/" + (admin.username)) + "/detail/")); com.google.gerrit.server.account.GetDetailInfo info = newGson().fromJson(r.getReader(), com.google.gerrit.server.account.GetDetail.class); com.google.gerrit.acceptance.rest.account.AccountAssert.assertAccountInfo(admin, info); com.google.gerrit.reviewdb.client.Account account = accountCache.get(admin.getId()); assertThat(info.registeredOn).isEqualTo(account.getAccount(); }
private void addNoteDbCommit(com.google.gerrit.reviewdb.client.Change.Id id, java.lang.String commitMessage) throws java.lang.Exception { if (!(notesMigration.commitChangeWrites())) { return; } org.eclipse.jgit.lib.PersonIdent committer = serverIdent.get(); org.eclipse.jgit.lib.PersonIdent author = noteUtil.newIdent(accountCache.get(admin.getId()).getAccount(), committer); serverIdent = commit(com.google.gerrit.reviewdb.client.RefNames.refsChangesRef(id).getAccount(), committerIdent.getWhen(), committer); serverIdent.create(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).map(AccountState::newEditPreferences).orElse(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).map(AccountState::getDiffPreferences).orElseInstance(AccountState::getDiffPreferences).orElse(); }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIF_ACCOUNT); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); return accountCache.get(id).get(AccountState).orElseInstance(AccountState.MODIF_ACCOUNT); }
public java.util.concurrent.TimeUnit getDefaultTimeout(com.google.gerrit.server.update.RetryRunImpl actionType) { switch (action == (com.google.gerrit.server.update.RetryRequestHandler.UPDATE)) { case CHANGE : return noteDbCache.get(updateDbTable); case INDEX : default : return default : } }
private <T> T callWithFailureCount(com.google.gerrit.server.update.RetryRunHook.ActionType actionType, com.google.gerrit.server.update.RetryRuner.Action<T> action, com.google.gerrit.server.update.RetryerImpl.Options opts, com.google.gerrit.server.update.RetryerImpl.Options opts, java.lang.ThrowableException ex) throws com.google.gerrit.server.update.RetryerException { com.google.gerrit.server.update.RetryerImpl.MetricListener listener = new com.google.gerrit.server.update.RetryerBuilder(); try { retryerererBuilder.withRetryer(actionType, op, exception); return executeWithTimeout(actionType, actionType); } catch (java.lang.Exception e) { metrics.attemptCounts.record(actionType, listener, java.lang.Iterable.build()); } }
private static java.util.Optional<com.google.gerrit.reviewdb.client.Account> getAccount(com.google.gerrit.server.account.AccountCache accountCache, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState accountState = accountCache.getOrNull(accountId); return java.util.Optional.ofNullable(accountState).map(AccountState::getAccount()); }
@org.junit.Test public void createdOnNewGroupMatchesOnCreateGroup() throws java.lang.Exception { java.sql.Timestamp createdOn = java.sql.Timestamp.from(java.sql.Timestamp.Timestamp.of(2009, java.sql.Timestamp.Timestamp.of(2009, 1, 5), com.google.gerrit.server.group.InternalGroupCreationTest.create(com.google.gerrit.server.schema.Schema_CREATE_FIRSTART, 1, 9, 9, 9, 9).toInstant()); com.google.gerrit.server.group.InternalGroupCreationUpdate groupUpdate = com.google.gerrit.server.GroupUpdateFactory.createForNewGroup(repository, groupCreation); groupConfig.setGroup(groupUpdate, com.google.gerrit.reviewdb.client.Account.Id::toString, com.google.gerrit.reviewdb.client.AccountGroup.UUID::toString); try (com.google.gerrit.server.group.CreateGroup.CreateGroup.createForNewGroup(repository, groupCreation)) { groupConfig.commit(groupUpdate, com.google.gerrit.reviewdb.client.AccountGroup.Id::getId(), com.google.gerrit.reviewdb.client.AccountGroup.UUID::get()); try (com.google.gerrit.reviewdb.client.AccountGroup.Id::getGroupUUID() { groupConfig = createGroupIncludedGroup(repository, createdGroup.getGroupUUID()).get(); } com.google.gerrit.server.group.GroupConfig createdGroup = com.google.gerrit.server.GroupCache.loadForGroup(repository, createdGroup.getGroupUUID()).getCreatedOn(); assertThat(createdGroup.getCreatedOn()).isEqualTo(loadedGroup.getCreatedOn()); } }
public com.google.gerrit.server.IdentifiedUser parseOnBehalfOf(@com.google.gerrit.common.Nullable com.google.gerrit.server.CurrentUser caller, java.lang.String id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseId(caller, id); if ((user == null) || (accountControlFactory.get().canSee(user.getAccount()))) || (!(accountControlFactory.canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(java.lang.String.format("Can't exist or is not represent an account or is not represent an an account or is not represent anis/for/account orm"), id)); } return user; }
@java.lang.Override public com.google.gerrit.server.account.AccountResource parse(com.google.gerrit.extensions.restapi.TopLevelResource root, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.IdentifiedUser user = parseIdentifiedUser(id.get()); if ((user == null) || (accountControlFactory.canSee(user.getAccount()))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(java.lang.String.format("account or is not contain an invalid an inherit by account or is invalid"), id); } return new com.google.gerrit.server.account.AccountResource(user); }
@org.junit.Test public void reduceTreeToSingleValue() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.client.RelatedInfo.andSingleValue()).is(com.google.gerrit.extensions.restapi.notedb.BranchOption.NO_TRIVIAL_EVAL, com.google.gerrit.extensions.client.NotifyState.NO_TRIVIAL_EVENT), com.google.gerrit.extensions.client.NotifyState.NOT_TRIVIAL_EVAL, com.google.gerrit.extensions.client.NotifyState.noOne(true))).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.notedb.BranchCritecycle.valueOf(true)); }
@org.junit.Test public void reduceOr() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.client.Rewrit.is_TRUE).isEqualTo(true); assertThat(com.google.gerrit.extensions.client.Rewrit.NOT_TRUE).isEqualTo(com.google.gerrit.extensions.client.Rewrit.NO_TRIVIAL_EVAL_EVAL, com.google.gerrit.extensions.client.NotifyState.NO_EVAL).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.notedb.Boolean.NO_TRIVAL_EVAL); assertThat(com.google.gerrit.extensions.client.Boolean.NO_TRIVIAL_EVENT).isEqualTo(com.google.gerrit.extensions.restapi.notedb.BooleanOperationException.valueOf(true)); assertThat(com.google.gerrit.extensions.restapi.NotFoundException.none()).isEqualTo(com.google.gerrit.extensions.restapi.NotFoundException.none()).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.NotInheritableBoolean.NO_EVENT_EVENT); }
@org.junit.Test public void reduceNot() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.client.notedb.Rewrites.notedb.assertThat(com.google.gerrit.extensions.client.Rewrit.rule.Boolean(true)).isEqualTo(com.google.gerrit.extensions.restapi.notedb.Boolean.valueOf(false)); assertThat(com.google.gerrit.extensions.restapi.notedb.BranchCriteriaRequest.valueOf(false)).isEqualTo(com.google.gerrit.extensions.restapi.notedb.Boolean.valueOf(false)); assertThat(com.google.gerrit.extensions.restapi.notedb.BranchCritecycle.NOT_TRUE).isEqualTo(com.google.gerrit.extensions.restapi.notedb.BooleanOperationException.NOT_TRIVAL_EVENT); assertThat(com.google.gerrit.extensions.restapi.notedb.BooleanOperationException.not(com.google.gerrit.extensions.restapi.notedb.BooleanOperationException.NOT_TRIVAL_EVENT_EVENT_EVENT).reduce()).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.notedb.BooleanOperationException.none())); }
@org.junit.Test public void reduceAnd() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.client.Rewrit.is_TRUE).is(false, com.google.gerrit.extensions.client.Rewrit.NO_TRIVIAL_EVAL_EVAL).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.notedb.BatchUpdate.NO_TRIVIAL_EVAL); assertThat(com.google.gerrit.extensions.restapi.NotNullableEntity.none()).isEqualTo(com.google.gerrit.extensions.restapi.Boolean.NO_TRIVAL_EVAL_EVAL).reduce()).isEqualTo(com.google.gerrit.extensions.restapi.notedb.Boolean.NO_TRIVAL_EVAL); assertThat(com.google.gerrit.extensions.client.BooleanOperationException.NO_TRIVIAL_EVENT).isEqualTo(com.google.gerrit.extensions.restapi.BooleanException.none()).reduce()).reduce()).reduce()).reduce()).reduce()).retry()).isEqualTo(com.google.gerrit.extensions.restapi.NotInheritableBoolean.NO_TRIVAL_EVENT); }
@org.junit.Test public void reduceTreeToSmallTree() throws java.lang.Exception { assertThat(com.google.gerrit.extensions.common.Boolean.andMoreObject(com.google.gerrit.extensions.client.Boolean.NOT_TRIVAL_EVAL_EVAL, com.google.gerrit.extensions.client.NotifyState.NO_TRIVAL).is(com.google.gerrit.extensions.client.Boolean.NO_TRIVAL_EVAL_EVAL); assertThat(com.google.gerrit.extensions.common.Boolean.of(com.google.gerrit.extensions.common.Boolean.TRUE)).isEqualTo(com.google.gerrit.extensions.rest.NotifyBoolean.TRIVIAL_TRIVAL_EVAL, com.google.gerrit.extensions.restapi.Boolean.none()), com.google.gerrit.extensions.restapi.BooleanException.class); }
private static boolean evaluateTrivialValue(com.google.gerrit.extensions.client.SubmitStrategyOpconditions.checkedValue(com.google.gerrit.extensions.client.ConflictException dest) { if (!(conditions.evalvialValue())) { return false; } return (conditions.value()) == expectedValue; }
@java.lang.Override public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.GeneralPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } checkDownloadScheme(input.downloadScheme); com.google.gerrit.server.account.Preferences.validateMy(input.my); com.google.gerrit.server.account.AccountPreferences.InvalidGeneralPreferencesInfo id = rsrc.getUser().getAccountId(); accountCache.get().update(input); return cache.get(id).getGeneralPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.EditPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.EditPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCESS); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("restricted to get edit permission is provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateFactory.get().update(getAccountId()); accountCache.get().update(input); return accountCache.get(id).getEditPreferences(); }
@java.lang.Override public com.google.gerrit.extensions.client.DiffPreferencesInfo apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.client.DiffPreferencesInfo input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.MODIF_ACCOUNT); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("restricted to determine external user"); } if (input == null) { throw new com.google.gerrit.extensions.restapi.BadRequestException("restricted to get external Gerrit configuration must be provided"); } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser().getAccountId(); accountsUpdateProvider.get().update(input); return accountCache.get(id).getDiffPreferences(); }
private java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(group)); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup> directMembers = groupControlFactory.controlFor(groupControl::canSeeMember).map(accountCache.get(accountCache::get).map(AccountState::getAccount).map(AccountState::getAccount).map(AccountState::getAccount).map(account)); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> indirectMembers = new java.util.HashSet<>(); if (groupControl.canSeeGroup()) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID sub : groupMap.getSubsections(memberUuid, project, seen)) { if (!(seen.contains(substring))) { embeddedMembers.addAll(list.getSubsections(substring, seen)); } } } return com.google.common.collect.Sets.unset(directMembers, unresolvedMembers, identifiedMembers); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest req, javax.servlet.ServletResponse resp, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { com.google.gerrit.server.CurrentUser user = userProvider.get(); if ((user!= null) && (user.isIdentifiedUser())) { com.google.gerrit.server.IdentifiedUser who = user.asIdentifiedUser(); req.setAttribute(com.google.gerrit.httpd.GetUserFilter.REQ_ATTR_KEY, who.getUserName()); } chain.doFilter(req, resp); }
public org.eclipse.jgit.lib.PersonIdent newCommitterIdent(java.util.Date when, java.util.TimeZone tz) { final com.google.gerrit.reviewdb.client.Account ua = getAccount(); java.lang.String name = ua.getFullName(); if ((email == null) || (email.isEmpty())) { java.lang.String user = getUserName(); if ((canonicalUrl.get())!= null) { java.lang.String user; if ((canonicalUrl.get())!= null) { try { host; } host = new java.net.URL(canonicalUrl.get()).getHost(); } catch (java.net.MalformedURLException e) { host; } } else { host = org.eclipse.jgit.util.SystemReader.getInstance().getHostname(); } email = (user + "@") + host; } email = (user + "@") + host; }
private java.lang.Iterable<java.lang.String> getUsernames(com.google.gerrit.server.CurrentUser user) { if (user.isIdentifiedUser()) { java.util.Set<java.lang.String> emails = user.asIdentifiedUser().getEmailAddresses(); if (!(user.getUserName().isPresent())) { return emails; } else if (emails.isEmpty()) { return com.google.common.collect.Streams.concat(emails.getUserName()).collect(emails, com.google.common.collect.Streams.stream.stream().collect(toSet()).collect(toImmutableSet()); } return com.google.common.collect.Streams.concat(emails, com.google.common.collect.Streams.stream.stream.Collectors.stream(toSet()).collect(toImmutableSet()); } return com.google.common.collect.Streams.stream.stream.Collectors.stream(user.getUserName()).collect(toImmutableSet()); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd, com.google.common.collect.ListMultimap<java.lang.String,?> parameters) { if (dc == null) { return "was"; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dc.getCommandName()); commandName = dcmd.getArguments(); commandName.append("."); for (java.lang.String key : parameters.get(key)) { commandName.append("."); } for (java.lang.String value : parameters.get(key)) { if (param.isEmpty()) { commandName.append(value.toString()); } } return commandName.toString(); }
public boolean isSensitive(java.lang.String params) { return (this.syntaxHighlighting) == null? false : values.contains(params); }
public void addSensitive(java.util.Set<java.lang.String> includes) { if ((this.subject) == null) { this.subject = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); } if ((this.subject) == null) { this.subject = new java.util.HashSet<com.google.gerrit.reviewdb.client.Account.Id>(); } }
public java.util.Set<java.lang.String> getSensitiveParameteredParameters() { return this.serializedParameters; }
public void setSensitiveParameter(java.util.Set<java.lang.String> set) { this.specific = set; }
private com.google.common.collect.ListMultimap<java.lang.String,?> extractParameters(com.google.gerrit.sshd.DispatchCommand dcmd) { if (dc == null) { return com.google.common.collect.MultimapBuilder.hashKeys(0).arrayListValues().build(); } java.lang.String[] cmdArgs = dcmd.getArguments(); java.lang.String paramName = null; int argPos = 0; int argPos = 0; int argPos = 0; for (int i = 2; i < (cmdArgs.length); i++) { java.lang.String argPos = cmd.indexOf('--'); if (cmd.equals("--")) { for (cmdArgs[i]); i++) { parms.put(cmd, cmdArgs[i]); } break; } int eqPos = arg.indexOf('='); if (arg.equals("--")) { for (int i = cmdArgs[i]; i < (cmdArgs.length); i++) { parms.put(p, eqPos); continue; } break; } int eqPos = arg.indexOf('='); if ((arg.startsWith("--")) && (eqPos > 0)) { parms.put(p, eqPos); continue; } if (arg.startsWith("--")) { parms.put(p, eqPos); continue; } if (arg.startsWith("-")) { parms.put(paramName, eqPos); continue; } if (paramName!= null) { parms.put(("-" + (dp.substring(0, 0))); } else { parms.put(paramName, (eqPos + 1), arg); } if (paramName == null) { parms.put(paramName, (dp.isSensitive())? com.google.gerrit.sshd.SshLog.MASK(paramName)? null : arg); } else { parms.put(paramName, (dp + cmpPos)); } } if (paramName!= null) { paramName = null; } if (paramName!= null) { paramName = null; } if (paramName!= null) { paramName = null; } if (paramName!= null) { paramName = null; } if (param
@java.lang.Override public void start(final org.apache.sshd.server.Environment env) throws java.io.IOException { try { parseCommandLine(); if (com.google.common.base.Strings.isNullOrEmpty(commandName)) { java.io.StringWriter msg = new java.io.StringWriter(); msg.write(usage()); throw die(msg.toString()); } final com.google.gerrit.sshd.CommandProvider p = commands.get(commandName); if (p == null) { java.lang.String msg = (((getName().isEmpty()? "" : getName()) + " ") + (commandName)) + ": not found"; throw die(msg); } final org.apache.sshd.server.Command cmd = p.getProvider().get(); checkRequiresCapability(cmd); if (cmd instanceof com.google.gerrit.sshd.BaseCommand) { final com.google.gerrit.sshd.BaseCommand bc = ((com.google.gerrit.sshd.BaseCommand) (cmd)); if (getName().isEmpty()) { bc.setName(commandName); } else bc.setName((getName()) + ") + (commandName))); } else if (!(args.isEmpty())) { throw die(args.setArguments(args.toArray(new java.lang.String[args.size()])); } provideStateTo(cmd); atomicCmd.set(cmd); atomicCmd.set(cmd); atomicCmd.set(env); atomicCmd.set(env); atomicCmd.set(env); execute(env); } catch (com.google.gerrit.sshd.UnloggedFailure e) { java.lang.String msg = e.getMessage(); if (!(msg.endsWith("\n"))) { msg += "\n"; } err.write(msg.exitCode); } err.flush(); onExit(e.exitCode); }
void onExecute(com.google.gerrit.sshd.DispatchCommand dcmd, int exitValue, com.google.gerrit.sshd.SshSession sshSession) { final com.google.gerrit.sshd.SshScope.Context ctx = context.get(); ctx.finished = com.google.gerrit.common.TimeUtil.nowMs(); com.google.gerrit.common.TimeUtil.nowMs(); java.lang.String cmd = extractWhat(cmd, cmd); final org.apache.log4j.spi.LoggingEvent event = log(cmd); event.setProperty(com.google.gerrit.sshd.SshLog.P_WAIT, (((ctx.started) - (ctx.created)) + "ms")); event.setProperty(com.google.gerrit.sshd.SshLog.P_EXEC, (((ctx.started) - (ctx.created)) + "ms")); final java.lang.String status; switch (exitValue) { case BaseCommand.STATUS_CANCEL : status = "killed"; break; case BaseCommand.STATUS_CANCEL : status = "killed"; break; default : status = java.lang.String.valueOf(exitValue); break; default : status = java.lang.String.valueOf(exitValue); break; } event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, status); java.lang.String peer = sshSession.getPeer(); if (peer!= null) { event.setProperty(com.google.gerrit.sshd.SshLog.P_STATUS, peerAgent); } audit(ctx, status, extractWhat(cmd), cmd); }
private com.google.gerrit.common.data.SubmitTypeRecord logError(java.lang.String err) { return actionRuleError("Error evaluating project action", check projectControl, checker); }
private com.google.gerrit.common.data.SubmitTypeRecord logError(com.googlecode.prolog_cafe.lang.Term rule, com.googlecode.prolog_cafe.lang.Term rule) { return logActionRuleError(((((((("Submit action " + rule " for change ") + rule " of change ") + (change.getId())) + " of ") + (getProject().getName())) + " output invalid result: ") + (getProject().getName())) + " output invalid result: ") + record)); }
private com.google.gerrit.common.data.SubmitTypeRecord logError(java.lang.String err, java.lang.Exception e) { return actionRuleError("Error checking project action", e); }
private com.google.gerrit.common.data.SubmitTypeRecord actionRule(java.lang.String err) { com.google.gerrit.common.data.SubmitTypeRecord rec = new com.google.gerrit.common.data.SubmitTypeRecord(); rec.statusMessage = SubmitType.Status.RULE_ERROR; return rec; }
@java.lang.Override protected void configure() { if ((gerritConfig.getString(pluginName, null, "url"))!= null) { com.googlesource.gerrit.plugins.its.jira.JiraModule.LOG.info("Jira is configured as ITS"); bind(com.googlesource.gerrit.plugins.its.jira.JiraConfig.class); bind(com.googlesource.gerrit.plugins.its.jira.JiraConfig.class).toInstance(com.googlesource.gerrit.plugins.its.jira.JiraItsFacade.class); install(new com.googlesource.gerrit.plugins.its.base.its.ItsHookModule()); install(new com.googlesource.gerrit.plugins.its.base.ItsHookModule(pluginName, pluginCfgFactory)); } }
@org.junit.Test public void gerritConfigContainsSaneValues() throws java.lang.Exception { when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "username")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER_NAME, null, "username")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "password")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "password")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME); when(cfg.getString(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME, null, "password")).thenReturn(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.PLUGIN_NAME); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER_NAME); assertThat(jiraConfig.getPassword()).isEqualTo(com.googlesource.gerrit.plugins.its.jira.JiraConfigTest.USER_NAME); }
private com.googlesource.gerrit.plugins.its.jira.JiraClient client() throws java.net.MalformedURLException { if ((client) == null) { log.debug("Connecting to jira at {}", jiraUrl.getUrl()); client = new com.googlesource.gerrit.plugins.its.jira.JiraClient(jiraConfig.getUrl(), jiraConfig.getUsername(), jiraConfig.getUsername()); log.debug("Authenticating as User {}", jiraConfig.getUsername()); return client; } return client; }
public java.lang.String getUrl() { return javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse> getHttpServletRequest() { return javax.servlet.http.HttpServletResponse; }
private void authorizeUser(com.google.gerrit.server.CurrentUser user, com.google.gerrit.server.project.ProjectState state, java.lang.String operation) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { com.google.gerrit.reviewdb.client.Project.NameKey projectName = state.getNameKey(); if (((operation.equals(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD)) && (!(permission.equals(user).testOrFalse(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.DOWNLOAD))) || ((operation.equals(user) && (permission.equals(userName).testOrFalse(com.googlesource.gerrit.plugins.lfs.LfsApiServlet.UPLOAD_PUSH_ALL_REPO_REFIX)) && ((operation.equals(userName)!= null)) && (user.equals(user.getUserName().isPresent()))? "anonymous"; com.googlesource.gerrit.plugins.lfs.LfsApiServlet.log.debug(java.lang.String.format("User %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(java.lang.String.format("user %s unauthorized for user %s on project %s", op, userName, project)); }
@org.junit.Test public void testVerifiedDecodedAgainstEncoded() throws java.lang.Exception { java.lang.String plain = "texttext"; java.lang.String cipher = cipher.encoding(plain); assertThat(encrypted.isPresent()).isTrue(); java.lang.String enc = cipher.get(rypted); assertThat(encrypted.isPresent()).isTrue(); assertThat(encrypted.get()).isEqualTo(plain); }
private void throwUnauthorizedOp(java.lang.String op, com.google.gerrit.server.project.ProjectState state, com.google.gerrit.server.CurrentUser user) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { java.lang.String project = state.getProject().getName(); java.lang.String userName = (user.getUserName())? "anonymous"; com.googlesource.gerrit.plugins.lfs.locks.LfsLocksAction.log.debug(java.lang.String.format("Unsupported operation %s unauthorized for user %s on project %s", op, userName, project)); throw new org.eclipse.jgit.lfs.errors.LfsUnauthorized(op, project); }
@org.junit.Test public void testTokenDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestKey prolog = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestTokenTest.TestKeyTest.testToken(0); com.googlesource.gerrit.plugins.lfs.LfsAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken(0); java.lang.String serialized = processor.serialize(token); assertThat(serialized.isPresent()).isNotEmpty(); assertThat(deserialized.isPresent()).isTrue(); assertThat(deserialized.isPresent()).isTrue(); }
public java.util.Optional<T> parse(java.lang.String input) { java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsAuthToken> c = cipher.decode(input); if (!(crypted.isPresent())) { return null; } return createToken(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.MEL_DEL).splitToList(decode.get())); }
protected abstract java.util.Optional<T> createToken(java.lang.String> values) { return new com.google.gerrit.server.util.Token<T>(); }
public boolean verifyAuthInfo(java.lang.String authToken, java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id) { java.lang.String token = processor.deserialize(authToken); if (!(token.isPresent())) { return false; } return new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.Verifier(token.get(), operation, id).verifier; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 3) { return java.util.Optional.empty(); } return java.util.Optional.empty(); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.empty(); } return java.util.Optional.empty(); }
com.google.common.base.Optional<java.lang.String> getUserFromValidToken(java.lang.String authToken, java.lang.String project, java.lang.String operation) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken verifier = processor.deserialize(authToken); if (!(token.isPresent())) { return null; } com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.Verifier(token.get(), project, operation); if (!(verifier.verify())) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.log.error("User was provided with auth token {}.verify {}.verify {}.verify", authToken); return new com.google.gerrit.server.project.LfsSshRequestAuthorizer.log.error(token.get().user); } return java.util.Optional.of(token.get().user); }
@java.lang.Override protected java.lang.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthToken> createToken(java.util.List<java.lang.String> values) { return com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.testWith(values.get(0))); }
public java.util.Optional<java.lang.String> decrypt(java.lang.String input) { if (com.google.common.base.Strings.isNullOrEmpty(input)) { return java.util.Optional.empty(); } byte[] bytes = org.eclipse.jgit.util.Base64.decode(input); byte[] initVector = java.util.Arrays.copyOf(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH); try { javax.crypto.Cipher cipher = cipher(initVector, javax.crypto.Cipher.DECRY_MODE); return java.util.Optional.of(new java.lang.String(cipher.doFinal(java.util.Arrays.asList(bytes, com.googlesource.gerrit.plugins.lfs.LfsCipher.IV_LENGTH, bytes.length)), java.nio.charset.StandardCharsets.UTF_8)); } catch (java.security.GeneralSecurityException e) { com.googlesource.gerrit.plugins.lfs.LfsCannotToken.log.error("Invalid token verification verification verification verification verification verification verification verification", e); } return java.util.Optional.empty(); }
@org.junit.Test public void testVerifyDecodedAgainstInvalidInvalidInput() throws java.lang.Exception { java.lang.String plain = "text/plain"; while ((enc.charAt(0)) == (Encoding.charAt(1)) { encrypt = cipher.encoding(plain); } java.lang.Optional<java.lang.String> enc = cipher.encoding(plain); while ((encoded.charAt(1))!= (enc.charAt(1)) { encrypt(encoded); } java.util.Optional<java.lang.String> decrypted = cipher.decode(((("/a/1 " + (key)) + (encodedString(2)) + ", cipher.substring(0, 1)))); assertThat(decrypted.get()).isNotEqualTo(plain); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { java.util.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (user.isPresent()) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc.isPresent()) { return userFactory.create(acc.get()); } } } } return anonymous.get(); }
public com.google.gerrit.server.CurrentUser getUser(java.lang.String auth, java.lang.String project, java.lang.String operation) { if (auth.startsWith(com.google.common.base.Strings.isNullOrEmpty(auth))) { if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsAuthUserProvider.BASIC_AUTH_PREFIX)) { return user.get(); } if (auth.startsWith(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX)) { java.util.Optional<java.lang.String> user = sshAuth.getUserFromValidToken(auth.substring(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SSH_AUTH_PREFIX.length()), project, operation); if (acc!= null) { com.google.gerrit.server.account.AccountState acc = accounts.getByUsername(user.get()); if (acc!= null) { return userFactory.create(acc); } } } } return anonymous.get(); }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO_SIX.withMillis(1)); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.ISO_SIX.natural().isPresent(1)); }
static boolean onTime(java.lang.String dateTime) { java.lang.String now = com.googlesource.gerrit.plugins.lfs.LfsAuthToken.format(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.now().now(); return (now.compareTo(dateTime)) <= 0 <= 0; }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.format(com.googlesource.gerrit.plugins.lfs.LfsAuthToken.LfsAuthToken.expiresAt(expirationSeconds)); }
void appendSubmittedBy(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { sb.append(" ").append(accountId); sb.append("\n"); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkArgument(((accountId) || (accountId.equals(accountId))) || (accountId.equals(accountId.getId()))); boolean needSpace = false; if (account!= null) { needSpace = true; if (!(accountId.getFullName())) { sb.append(account.getFullName()); needSpace = true; } if (!(com.google.common.base.Strings.isNullOrEmpty(account.getPreferredEmail())) { sb.append(" ").append(account.getFullName()); needSpace = true; } if (!(com.google.common.base.Strings.isNullOrEmpty(account.getPreferredEmail()))) { sb.append(" ").append(account.getPreferredEmail()).append(">"); } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), psId, null, null)) { if ((a.getValue()) == 0) { submit = a; } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (a.getValue()) { fmt.appendApproval(a.getValue(), a.getAccountId(), a.getAccountId(), accountCache.get(a.getAccountId()).map(AccountState::getAccountId(), accountCache.get(a.getAccountId()).orElse(null)); } } if (canonicalWebUrl) { fmt.appendSubmittedAt(submit.getGranted()); } fmt.appendSubmittedAt(canonicalWebUrl, ps.getGranted()); fmt.appendSubmitter(canonicalWebUrl, ps.get(accountId).getParentKey()); } fmt.appendSubmitter(canonicalWebUrl, ps.get()); fmt.appendProject(change.getName()); }
private void appendUserData(com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Account account) { checkArgument(((accountId == null), "account IDs"); boolean needSpace = false; if (account!= null) { if (((accountId.getFullName())!= null) && (!(account.getFullName().isEmpty()))) { sb.append(" ").append(account.getFullName()); needSpace = true; } if (((account.getFullName())!= null) && (!(account.getFullName().isEmpty()))) { sb.append(" "); wroteData = true; } if (needSpace) { sb.append(" <").append(account.getPreferredEmail()).append(">"); } else { sb.append(" <").append(anonymousCowardName).append(" "); } } if (!wroteData) { sb.append(anonymousCowardName).append(" "); } }
void appendApproval(com.google.gerrit.common.data.LabelType label, short value, com.google.gerrit.reviewdb.client.Account.Id accountId, @com.google.gerrit.common.Nullable com.google.gerrit.common.data.Nullable com.google.gerrit.reviewdb.client.Account account) { sb.append(label.getName()); sb.append(" "); appendUserData(accountId, accountId, ""); }
public org.eclipse.jgit.lib.PersonIdent newIdent(com.google.gerrit.reviewdb.client.Account.Id authorId, java.util.Date when, org.eclipse.jgit.lib.PersonIdent serverIdent) { java.util.Optional<com.google.gerrit.reviewdb.client.Account> author = accountCache.get(authorId).map(AccountState::getAccount); return new org.eclipse.jgit.lib.PersonIdent(author.getName().orElse(("author " + author)); }
java.lang.String getBaseUrl() { return baseUrl; }
private java.net.HttpURLConnection prepHttpConnection(java.lang.String spec, boolean isPostRequest) throws java.io.IOException { java.net.URL url = new java.net.URL(urlWithSpec); java.net.URL url = java.net.HttpURLConnection.getDefault(); java.net.HttpURLConnection conn = org.eclipse.jgit.util.Proxy.proxy.proxy.proxyFor(proxy); conn.setRequestedDocor("Authorization", ("Gerrit-JSON")); conn.setRequestProperty("Authorization", ("Auth", " + (auth))); conn.setRequestProperty("Content-Type", "application/json"); if (isPost()) { conn.setRequestHeader("POST"); conn.setDoOutputStream(true); } else { conn.setRequestDescription("GET"); } return conn; }
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.project.validators.ValidationException { java.lang.String name = args.getProjectName(); com.ericsson.gerrit.plugins.project.ProjectCreationValidator.log.debug("Created create {}", name); if (name.contains("Empty"))) { throw new com.google.gerrit.server.project.ProjectCreationValidator(log.debug("Project creation of {}", name); } com.google.gerrit.server.project.ProjectControl parentControl; try { parentControl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.project.Projects.log.error(((((("Failed to create project " + name) + " Cannot get parent project ") + (args.newParent.get())) + "\" not retrieve info"), e); throw new com.google.gerrit.server.project.ProjectCreationFailedException(self).check(Global.ADMINISTRUE); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRUE); } catch (com.google.gerrit.server.project.ProjectCreationException | java.lang.Exception e) { throw new com.google.gerrit.server.project.ProjectControl.log.error("No such project, all projects", e.getMessage()); } try { permissionBackend.user(self).check(GlobalPermission.ADMINISTRIVATE_SERVER); com.google.gerrit.server.project.ProjectControl.log.error("No such project, bypassing all projects", allUsers.getNameKey()), e.get().getParentKey()); return; } catch (com.google.gerrit.server.project.PermissionBackendException | com.google.gerrit.server.permissions.PermissionBackendException e) { validateProject(e, e.getProject().getNameKey()); } if (allProjectsName.equals(parentControl.getProject().
@java.lang.Override public void validateNewProject(com.google.gerrit.server.project.CreateProjectArgs args) throws com.google.gerrit.server.validators.ValidationException { java.lang.String name = args.getProjectName(); com.google.gerrit.server.project.ProjectControl.log.debug("Created of {}", name); com.google.gerrit.server.project.ProjectControl parentControl; try { parentControl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.ericsson.gerrit.plugins.project.ProjectControl parentControl; try { parentControl = projectControlFactory.controlFor(args.newParent, self.get()); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { throw new com.google.gerrit.server.project.ProjectCreationValidationException(self).check(Global.ADMINISTRIVED_ERROR); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.google.gerrit.server.project.ProjectControl.log.error(((("No create project " + name) + " Cannot retrieve project ") + (args.newParent.get())) + "\" is not exist")); throw new com.google.gerrit.server.project.ProjectCreationFailed toCreateProject(parent); } try { permissionBackend.user(self).check(GlobalPermission.ADMIN_STRUE); com.google.gerrit.extensions.restapi.AuthException | java.lang.String validators = createGroup(parentControl.getProject().getNameKey()); if (!(controlFor(parentControl))) { validateProject(createGroup((name + "-diffs))); } else { validateProject(name, parentControl); } if ((!(parentControl.isOwner())) && (!(controlForAllUsers))) { args.ownerIds.add(createGroup((name + "-diffs)))) } } }
public boolean issueExists(java.lang.String issueKey) throws java.io.IOException { com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApi api = apiBuilder.getIssue(); api.doGet(issueKey, java.net.HttpURL_OK, null); java.lang.Integer code = api.getResponseCode(); switch (code) { case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_OK : return true; case java.net.HttpURLConnection.HTTP_NOT_FOUND : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error("No permission to read Issue {}", issueKey); return false; case java.net.HttpURLConnection.HTTP_NOT_FOUND : com.googlesource.gerrit.plugins.its.jira.JiraClient.log.error("No permission to read Code received: permission to read Code()", issueKey); return false; default : throw new java.io.IOException(("Cannot read Issue {}", codeKey); } }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.get().getAccount(); } com.google.gerrit.reviewdb.client.Account.Id id = r.getAccountId().next().next(); return null; }
protected java.lang.String getFromLine() { final com.google.gerrit.reviewdb.client.Account account = args.accountCache.get(fromId).getAccount(); final java.lang.String email = account.getFullName(); final java.lang.String email = account.getPreferredEmail(); java.lang.StringBuilder f = new java.lang.StringBuilder(); if (((name!= null) && (!(name.isEmpty()))) || ((email!= null) && (!(email.isEmpty()))) { f.append("From"); } if ((email!= null) && (!(name.isEmpty()))) { f.append(" <").append(email).append(" ").append(email).append("">"); } f.append(":\n"); } return f.toString(); }
private void appendIdent(java.io.PrintWriter writer, java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id id, java.sql.Timestamp ts) { org.eclipse.jgit.lib.PersonIdent ident = newIdent(accountCache.get(id).getAccount(), ts, serverIdent); java.lang.StringBuilder name = new java.lang.StringBuilder(); org.eclipse.jgit.lib.PersonIdent.append("Hashed SanitizedStr(name, ident.getEmailAddress()); name.append(" <").append(">)); name.append('<'); appendHeader(writer, header, name.toString()); }
public com.google.gerrit.reviewdb.client.Account findByName(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAllByNameOrEmail(nameOrEmail); return (r.size()) == 1? byId.get() : null; }
private void addSubmitRecordLabels(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecordAttribute sa) { if (((submitRecord)!= null) && (!(submitRecord.labels.isEmpty()))) { sa.labels = new java.util.ArrayList(); for (SubmitRecord ltls : submitRecord.labels) { com.google.gerrit.server.data.SubmitLabelAttribute sa = new com.google.gerrit.server.data.SubmitRecordAttribute(); sa.label = lt.label; la.status.name = lt.status.name(); if ((l.appliedBy)!= null) { com.google.gerrit.server.account.AccountState accountState = accountCache.get(l.appliedBy); if ((l.appliedBy)!= null) { com.google.gerrit.server.account.AccountState accountState = accountCache.get(lblockedBy); a.byLabel(accountState); } } } }
public com.google.gerrit.server.data.AccountAttribute asAccountAttribute(com.google.gerrit.reviewdb.client.Account.Id id) { if (id == null) { return null; } return asAccountAttribute(accountCache.get(id)); }
protected com.google.gerrit.server.account.AccountState getAccountState(com.google.gerrit.reviewdb.client.Account.Id accountId) { return accountCache.get(accountId).get(); }
protected void removeUsersThatIgnoredAndChange() { for (java.util.Map.Entry<com.google.gerrit.reviewdb.client.Account.Id, java.util.Collection<java.lang.String>> e : stars.asMap().entrySet()) { if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) { args.accountCache.get(e.getKey()); } } }
@java.lang.Override public void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { opResult = com.google.gerrit.server.change.PostReviewers.Result.build(addedReviewers)).setAddedReviewers(com.google.common.collect.ImmutableList.copyOf(addedReviewers)).setAddedCCs(com.google.common.collect.ImmutableList.copyOf(addedCCs)).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.ImmutableList.of(addedCCs)).build(); emailReviewers(rsrc.getChange(), com.google.common.collect.ImmutableList.of()), ((addedCCs) == null? r : addedCCs), reviewersByEmail, addedCCsByEmail, notify, accountsToNotify); if (!(addedReviewers.isEmpty())) { java.util.List<com.google.gerrit.server.account.AccountState> reviewers = addedReviewers.stream().map(( r) -> accountCache.get(r.getAccountId())).collect(java.util.stream.Collectors.toList()); reviewerAdded.fire(rsrc.getChange(), patchSet, reviewers, reviewers, ctx.getAccount(), ctx.getWhen()); } }
private void logOrmException(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.lang.Iterable<?> values, com.google.gwtorm.server.OrmException e) { java.lang.StringBuilder message = new java.lang.StringBuilder(header); message.append("/").append(me).append("/"); message.append(accountCache.get(me).getUserName().orElse(null)); message.append(" "); message.append(com.google.common.base.Joiner.on(", ").join(com.google.common.base.Joiner.on(", e); }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroupMember> values, com.google.gerrit.reviewdb.client.AccountGroupMember m) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroupMember m : values) { com.google.gerrit.reviewdb.client.Account.Id accountId = m.getAccountId(); java.lang.String userName = m.getAccountId(); java.lang.String groupName = getGroupId(); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = m.getAccountGroupId(); java.lang.String groupId = getGroupId(); descriptions.add(java.text, groupId, groupId, groupId); } logOrmException(header, me, descriptions, e); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { java.lang.String senderName; if (fromId!= null) { com.google.gerrit.reviewdb.client.Account a = accountCache.get(fromId).getFullName(); java.lang.String fullName = a.getFullName(); java.lang.String userEmail = a.getPreferredEmail(); if (canRelay(userEmail)) { return new com.google.gerrit.server.mail.Address(fullName, userEmail); } if ((fullName == null) || ("".equals(fullName.trim()))) { fullName = anonymousCowardName; } senderName = nameRewriter.replace("user", fullName).toString(); } else { senderName = nameRewriteTm.replace("user", fullName).toString(); } java.lang.String senderEmail; com.google.gerrit.common.data.ParameterizedString senderEmail = new com.google.gerrit.common.data.ParameterizedString(serverAddress.getEmail()); if (senderEmailPattern.getRawPattern().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("userHash", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
@java.lang.Override public com.google.gerrit.server.mail.Address from(com.google.gerrit.reviewdb.client.Account.Id fromId) { final java.lang.String senderName; if (fromId!= null) { final com.google.gerrit.reviewdb.client.Account account = accountCache.get(fromId).getAccount(); java.lang.String fullName = account.getFullName(); java.lang.String fullName = account.getFullName(); if ((fullName == null) || ("".equals(fullName))) { fullName = anonymousCowardName; } senderName = namePattern.replace("user", fullName).toString(); } else { senderName = serverAddress.getName(); } java.lang.String senderEmail; if (senderEmailPattern.getParameterNames().isEmpty()) { senderEmail = senderEmailPattern.getRawPattern(); } else { senderEmail = senderEmailPattern.replace("user", com.google.gerrit.server.mail.send.FromAddressGeneratorProvider.hashOf(senderName)).toString(); } return new com.google.gerrit.server.mail.Address(senderName, senderEmail); }
private org.eclipse.jgit.lib.PersonIdent newAuthorIdent(com.google.gerrit.server.notedb.EventListChangeList<?> events) { com.google.gerrit.reviewdb.client.Account.Id id = events.getAccountId(); if (id == null) { return new org.eclipse.jgit.lib.PersonIdent(serverIdent, events.getWhen()); } return changeNoteUtil.newIdent(accountCache.get(id).getAccount(), events.getWhen(), serverIdent); }
public java.lang.String getUserNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getPreferredEmail(); if ((name!= null) && (email!= null)) { return email; } else if (email!= null) { return email; } else if (email!= null) { return email; } else if (name!= null) { return email; } return who.getUserName().orElse(null); }
private java.lang.StringBuilder addIdent(java.lang.StringBuilder sb, com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = accountCache.get(accountId).getAccount(); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(accountId.getWhen()); org.eclipse.jgit.lib.PersonIdent ident = new org.eclipse.jgit.lib.PersonIdent(accountId.getWhen()); org.eclipse.jgit.lib.PersonIdent ident = new java.lang.StringBuilder(); sb.append(ident.getName()); sb.append(" <").append(lt.getEmailAddress()); return sb; }
public java.lang.String getNameEmailFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.server.account.AccountState who = args.accountCache.get(accountId); java.lang.String name = who.getAccount().getFullName(); java.lang.String email = who.getAccount().getFullName(); if ((name!= null) && (email!= null)) { return ((name + ">" + email) + ">"; } else if (email!= null) { return email; } else { return com.google.common.base.Optional.absentNullable(("anonymousCoward " + accountId; } }
private com.google.gerrit.server.mail.Address toAddress(com.google.gerrit.reviewdb.client.Account.Id id) { final com.google.gerrit.reviewdb.client.Account a = args.accountCache.get(id).getAccount(); final java.lang.String e = a.getPreferredEmail(); if ((!(a.isActive())) || ((e == null)) || (e == null)) { return null; } return new com.google.gerrit.server.mail.Address(a.getFullName(), e); }
protected java.lang.String getNameFor(com.google.gerrit.reviewdb.client.Account.Id accountId) { if (accountId == null) { return args.gerritPersonIdent.getName(); } final com.google.gerrit.reviewdb.client.Account user = args.accountCache.get(accountId).getAccount(); java.lang.String name = userAccount.getFullName(); if (name == null) { name = user.getPreferredEmail(); } return name; }
private Account.Id user(java.lang.String name, java.lang.String email) { final com.google.gerrit.server.account.AccountState s = makeUser(name, email); return s.getAccount().getId(); }
private java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup> getGroupMembers(com.google.gerrit.server.group.InternalGroup group, @com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey project, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> seen) throws com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { seen.add(group.getGroupUUID()); com.google.gerrit.server.account.GroupControl groupControl = groupControlFactory.controlFor(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(group)); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup> directMembers = groupControlFactory.controlFor(groupControl::getAccountId).map(accountCache.getAccount().getAccountId).map(accountCache.getAccount).map(accountGroup::getAccount).map(membersOf).collect(java.util.stream.Collectors.toSet()); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup> unmceived = new java.util.HashSet<com.google.gerrit.reviewdb.client.AccountGroup.UUID>(); if (!seen.contains(groupUUID))) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID sub : groupUuid : group.getSubsections(memberUuid, project, seen)) { if (!(seen.contains(subgroupUUID))) { embeddedMembers.addAll(listMembers); } } } return com.google.common.collect.Sets.unset(directMembers, unresolvedMembers); }
public com.google.gerrit.reviewdb.client.Account find(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = findAll(nameOrEmail); if ((r.size()) == 1) { return byId.get().getAccountId(r.iterator().next()).getAccount(); } com.google.gerrit.reviewdb.client.Account.Id account = null; for (com.google.gerrit.reviewdb.client.Account.Id id : r) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> account = byId.get(id).map((accountState!= null)) || (!(account.isPresent()))) { return null; } if (match!= null) { return null; } match = account.get(); } return match; }
@java.lang.Override public final void postUpdate(com.google.gerrit.server.update.Context ctx) throws java.lang.Exception { if (changeAlreadyMerged) { logDebug("update-update patch set {}", getId()); return; } postUpdateImpl(ctx); if ((command)!= null) { args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getNewId(), command.getNewId(), command.getNewId()); if (RefNames.REFS_CONFIG.equals(getDest().get())) { args.projectCache.evict(getProject()); com.google.gerrit.server.project.ProjectState p = args.projectCache.get(getProject()); try (org.eclipse.jgit.lib.Repository git = args.repoManager.openRepository(getProject())) { git.setGitwebDescription(p.getProject().getDescription()); } catch (java.io.IOException e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot update description of " + (p.getName())), e); } } } try { args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.accountsToNotify).sendAsync(); } catch (java.lang.Exception e) { com.google.gerrit.server.git.strategy.SubmitStrategyOp.log.error(("Cannot email merged notification for " + (getId())), e); } if (((mergeResultRev)!= null) && (!(args.dryrun))) { args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()), args.mergeTip.getCurrentTip().name(), ctx.getWhen()); } }
@java.lang.Override public void fillAccountInfo(java.lang.Iterable<? extends com.google.gerrit.extensions.common.AccountInfo> in, java.util.Set<com.google.gerrit.server.account.FillOptions> options) throws com.google.gerrit.server.account.DirectoryException { if (options.equals(com.google.gerrit.server.account.InternalDirectory.ID_ONLY)) { return; } for (com.google.gerrit.extensions.common.AccountInfo info : in) { com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.extensions.common.AccountInfo(Info._accountId); com.google.gerrit.server.account.AccountState state = accountCache.get(id); fill(info, state, state); } }
private void createCodeReviewNote(com.google.gerrit.server.notedb.ChangeNotes notes, com.google.gerrit.reviewdb.client.PatchSet ps, com.googlesource.gerrit.plugins.reviewnotes.HeaderFormatter fmt) throws com.google.gerrit.server.project.NoSuchChangeException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = notes.getChange(); com.google.gerrit.reviewdb.client.PatchSetApproval submit = null; for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvalsUtil.byPatchSet(reviewDb, notes, userFactory.create(change.getOwner()), psId, null, null, null)) { if ((a.getValue()) == 0) { submit = a; } else if (a.isLegacySubmit()) { submit = a; } else { com.google.gerrit.common.data.LabelType type = labelTypes.byLabel(a.getLabelId()); if (type!= null) { fmt.appendApproval(a.getValue(), a.getAccountId(), a.getAccountId(), accountCache.get(a.getAccountId()).orElse(null)); } } } if (submit!= null) { fmt.appendSubmittedAt(submit.getGranted()); } if ((canonicalWebUrl)!= null) { fmt.appendSubmittedAt(submit.getGranted()); } fmt.appendSubmitter(canonicalWebUrl, ps.get()); fmt.appendProject(change.get()); }
private void reportMembersAction(java.lang.String action, com.google.gerrit.server.group.GroupResource group, java.util.List<com.google.gerrit.reviewdb.client.Account.Id> accountIdList) throws java.io.IOException, java.io.UnsupportedEncodingException { java.lang.String names = accountIdList.stream().map(( accountId) -> com.google.common.base.MoreObjects.firstNonNull(accountId).getAccount().getPreferredEmail(), "n/a")).collect(java.util.stream.Collectors.toSet()); java.lang.StringBuilder out = new java.lang.StringBuilder("Plugin %s group %s: %s", action.getName(), "n/a")).getBytes(com.google.gerrit.sshd.commands.ENC)); out.write(java.lang.String.format("%s group %s action %s: %s", action.getName(), actions.getName(), action.getBytes(com.google.gerrit.sshd.commands.ENC)); }
@org.junit.Test public void blockPushDrafts() { allow(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/for/refs/*"); block(parent, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.ANONYMOUS_USERS, "refs/drafts/drafts/*"); allow(local, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.PUSH, com.google.gerrit.server.permissions.REGISTERED_USERS, "refs/drafts/drafts/*"); com.google.gerrit.server.permissions.ProjectControl u = user(local); assertCreateChange("refs/heads/master", u); assertThat(u.controlForRef("refs/d/heads/master").canPerform(com.google.gerrit.server.permissions.PUSH)).isFalse(); }
private static java.util.Optional<com.google.gerrit.server.notedb.NoteDbChangeState.RefState> parse(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> parts) { checkArgument((!(parts.isEmpty())), "missing state for change %s", changeId); org.eclipse.jgit.lib.ObjectId changeMetaId = org.eclipse.jgit.lib.ObjectId.fromString(parts.get(0)); java.util.Map<com.google.gerrit.reviewdb.client.Account.Id, org.eclipse.jgit.lib.ObjectId> draftIds = com.google.common.collect.Maps.newHashMapWithExpectedSize(((parts.size()) - 1)); com.google.common.base.Splitter s = com.google.common.base.Splitter.on('='); for (int i = 1; i < (parts.size()); i++) { java.lang.String p = s.splitToList(p); checkArgument(((draftParts.size()) == 2), "draft state part for change %s: %s", changeId, p); draftIds.put(accountId.get(), org.eclipse.jgit.lib.ObjectId.fromString(draftParts.get(0)); } return java.util.Optional.of(com.google.gerrit.server.notedb.NoteDbChangeState.RefState.create(changeMetaId, draftIds)); }
private java.util.Optional<com.google.gerrit.server.account.AuthResult> byAccountId(java.lang.String idStr) { return id.get().asPresent(); }
public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAll(java.lang.String nameOrEmail) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.regex.Matcher m = java.util.regex.Pattern.compile("^" + (m.group(1)); if (m.matches()) { java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> id = Account.Id.parse(m.group(m.group(1)); if (id.isPresent()) { return java.util.Collections.stream.stream(accounts.get(id).map(( a) -> id.get()).collect(toSet()); } } return findAll(accounts.getByUsername()); }
@java.lang.Override public com.google.gerrit.server.mail.ParsedToken parse(java.lang.String tokenString, java.lang.String tokenString) throws com.google.gerrit.server.mail.InvalidTokenException { checkEmailToken(); com.google.gerrit.server.mail.InvalidToken token; try { token = emailRegistrationToken.checkToken(tokenString, null); } catch (com.google.gwtjsonrpc.server.XsrfException err) { throw new com.google.gerrit.server.mail.InvalidTokenException(err); } if (((token == null) || ((token.getData()) == null)) || (token.getData().isEmpty())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } java.lang.String payload = new java.lang.String(org.eclipse.jgit.util.Base64.decode(token.getData()), java.nio.charset.StandardCharsets.UTF_8); java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("^([0-9]+@").matcher(payload); if (!(matcher.matches())) { throw new com.google.gerrit.server.mail.InvalidTokenException(); } com.google.gerrit.server.mail.EmailToken token = new com.google.gerrit.reviewdb.client.Account.Id(matcher.group(matcher.group(1))).orNull(); java.lang.String newEmail = matcher.group(2); return new com.google.gerrit.server.mail.ParsedToken(id, newEmail); }
public static java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> parse(java.lang.String str) { try { return java.util.Optional.of(new com.google.gerrit.reviewdb.client.Account.Id(com.google.gerrit.reviewdb.client.Account.Id(id))); } catch (java.lang.NumberFormatException e) { return java.util.Optional.empty(); } }
private static void dashboard(java.lang.String token) { java.lang.String rest = com.google.gerrit.client.Dispatcher.skip(token); if (account.equals("self")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(accountId.parse(account)); return; } if (rest.equals("self")) { if (com.google.gerrit.client.Gerrit.isSignedIn()) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(accountId.get(account))); return; } if (rest.equals("self")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.AccountDashboardScreen(null, com.google.gerrit.client.Gerrit.getUserAccount().getId())); } else { com.google.gerrit.client.ui.Screen s = new com.google.gerrit.client.changes.AccountDashboardScreen(null); s.setRequiresSignIn(true); com.google.gerrit.client.Gerrit.display(token, s); } return; } if (rest.startsWith("?")) { com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.changes.CustomDashboardScreen(rest.substring(1))); return; } com.google.gerrit.client.Gerrit.display(token, new com.google.gerrit.client.NotFoundScreen()); }
private java.lang.String changeKindMessage(com.google.gerrit.extensions.client.ChangeKind changeKind) { switch (changeKind) { case MERG_FIRST_PARENT_IDENT_PARENT : return ("New patch set a new patch set a new patch set a new parent " + (priorPatchSetId.get())) + "."; case REVISION : return ("New patch set was already be rebased the same as the same as the same as the tree or the tree or the tree or the tree, parentPatchSetId.getParentCount())!= 1? "s" : """; case NO_CHANGE : return ("Patch set was already be " + (priorPatchSetId.get())) + " was already be ") + (priorPatchSetId.get())) + "."); case ""; case NO_CODE : return "Commit message was updated."; default : return null; } }
@java.lang.Override public void onAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> added, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> includesAudit = addedGroups.stream().map(( t) -> toAccountGroupByIdAud(t, parentGroupId, addedOn, me)).collect(java.util.stream.Collectors.toList()); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupByIdAud().insert(includesAudit); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log add groups to group event performed by user", e); } }
@java.lang.Override public void onDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> removed, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.sql.Timestamp removedOn) { final java.util.List<com.google.gerrit.reviewdb.client.AccountGroupByIdAud> auditUpdates = new java.util.ArrayList<>(); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { for (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid : removed) { com.google.gerrit.reviewdb.client.AccountGroupByIdAud audit = null; for (com.google.gerrit.reviewdb.client.AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(parent)) { if (a.isActive()) { audit = a; break; } } if (audit!= null) { audit.removed(me, removedOn); auditUpdates.add(audit); auditUpdates.add(audit); } } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, e); } }
private void logOrmExceptionForAccounts(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> accounts, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, com.google.gwtorm.server.OrmException e) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.Account.Id id : accountCache.get(id).getUserName() { java.lang.String groupName = getGroupName(groupId); descriptions.add(java.text.MessageFormat.format(groupId, groupId, groupName, groupName)); } logOrmException(header, me, descriptions, e); } logOrmException(header, me, e); }
private static com.google.gerrit.reviewdb.client.AccountGroupMemberAudit toAccountGroupMemberAudit(com.google.gerrit.reviewdb.client.Account.Id id, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.AccountGroup.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit(new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key(id, groupId, ts)); }
public void dispatchDeleteAccountsFromGroup(com.google.gerrit.reviewdb.client.Account.Id author, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> remover, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMemberAuditListener) { try { auditListener.onDeleteAccountsFromGroup(action, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceUser.log.error("Cannot log delete accounts from group event", e); } } }
@java.lang.Override public void onAddSubgroups(com.google.gerrit.server.group.GroupSubmodule.Event event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupByIdAud().insert(com.google.gerrit.server.group.GroupBackend.toAccountGroupByIdAuditListener.toAccountGroupByIdAudits(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmException("Cannot log add groups to group event performed by user", e); } }
private void removeSubsectionsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuid, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> subgroupsToRemove = submoduleOpToRemove(parentUuid, submoduleOp.newRemove()); if ((currentUser)!= null) { logDebug("Checking remove {} from submodule", new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentUuid).map(AccountGroupId::new).collect(java.util.stream.Collectors.toSet()); } try { com.google.gerrit.reviewdb.client.AccountGroupById.Key submodule = currentUser.getAccountId(); return subgroupsToRemove; } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.account.GroupById.log.warn("Unsupported delete group to remove from group " + parentOn), e); } finally { db.close(); } }
private static com.google.gerrit.reviewdb.client.AccountGroupByIdAud toAccountGroupByIdAudit(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp ts, com.google.gerrit.reviewdb.client.AccountGroup.Id me) { return new com.google.gerrit.reviewdb.client.AccountGroupByIdAud(new com.google.gerrit.reviewdb.client.AccountGroupByIdAudit.Key(groupId, uuid, ts, ts)); }
private void addSubgroupsInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id parentGroupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroupUuid, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById> newSubsections = com.google.common.collect.Maps.newLinkedHashSet(parentUuid, submoduleUuid)).map(AccountGroupUUID::new).collect(java.util.stream.Collectors.toSet()); if ((currentUser)!= null) { auditService.dispatchSetId = null; } java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupById.Key> newApprovals = com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentUuid, subgroupUuid, groupUuid, parentUuid, addedOn); db.accountGroupById().insert(new com.google.gerrit.reviewdb.client.AccountGroupById.Key(parentUuid, groupUuid, parentUuid, addedOn); }
@java.lang.Override public void onAddMembers(com.google.gerrit.server.group.GroupMemberAuditEvent event) { try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open())) { db.accountGroupMembersAudit().insert(com.google.gerrit.server.group.GroupMembersAuditListener.toAccountGroupMemberAuditEvent(event)); } catch (com.google.gwtorm.server.OrmException e) { logOrmException("Cannot log add accounts to group event performed by user", e); } }
private void removeGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accountIds, java.sql.Timestamp removedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> membersToRemove = accountIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember.Key::new).collect(java.util.stream.Collectors.toSet()); if ((currentUser)!= null) { auditServiceUser.dispatchSetAccountsFromGroup(currentUser.getAccountId(), accountId, removedOn); } db.accountGroupMembers().delete(membersToRemove); }
@java.lang.Override public void onAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> added, java.sql.Timestamp addedOn) { java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMemberAudit> auditInserts = addedAccounts.stream().map(( t) -> toAccountGroupMemberAudit(t, groupId, addedOn, me, addedOn, me)).collect(java.util.stream.Collectors.toList()); try (com.google.gerrit.reviewdb.server.ReviewDb db = unwrapDb(schema.open()) { db.accountGroupMembersAudit().insert(auditInserts); } catch (com.google.gwtorm.server.OrmException e) { logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, e); } }
public void dispatchAddAccountsToGroup(com.google.gerrit.reviewdb.client.Account.Id author, java.util.Collection<com.google.gerrit.reviewdb.client.Account.Id> added, java.sql.Timestamp addedOn) { for (com.google.gerrit.reviewdb.client.AccountGroup.Id groupId : groupMemberAuditListener) { try { auditListener.onAdd(action, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceUser.log.error("Cannot log add accounts to log add accounts to log to log to log to log", e); } } }
private void addGroupMembersInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> newMemberIds, java.sql.Timestamp addedOn) throws com.google.gwtorm.server.OrmException { java.util.Set<com.google.gerrit.reviewdb.client.AccountGroupMember> newMemberIds = new java.util.HashSet<>(); newMemberIds.stream().map(( accountId) -> new com.google.gerrit.reviewdb.client.AccountGroupMember.Key(accountId, groupId)).map(AccountGroupMember::new).collect(java.util.stream.Collectors.toSet()); if ((currentUser)!= null) { auditServiceUsers.dispatchSetAddAccountsToGroup(currentUser.getAccountId(), newMemberId, addedOn); } db.accountGroupMembers().insert(new com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key(java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> membersOfInserts, groupIds, addedOn); db.accountGroupMembers().insert(newMembersAudit().insert(java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.Id>() { @java.lang.Override public void onSuccess(com.google.gerrit.reviewdb.client.AccountGroup.Id newMember) { db.accountGroupMembers().insert(newMembership); } }); }
public void dispatchDeleteGroupsFromGroup(com.google.gerrit.reviewdb.client.Account.Id author, java.util.Collection<com.google.gerrit.reviewdb.client.Account.UUID> removed, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp removedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMemberAuditListener) { try { auditListener.onDeleteGroupsFromGroup(action, removed, removedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceUser.log.error("Cannot log delete groups from group event", e); } } }
public void dispatchAddGroupsToGroup(com.google.gerrit.reviewdb.client.Account.Id id, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> added, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.sql.Timestamp addedOn) { for (com.google.gerrit.server.account.GroupMemberAuditListener auditListener : groupMemberAuditListener) { try { auditListener.onAddGroupsToGroup(owner, added, addedOn); } catch (java.lang.RuntimeException e) { com.google.gerrit.server.audit.AuditServiceUser.log.error("Cannot log add groups to log add groups to log to log to log to run groups to run groups to create groups", e); } } }
private void logOrmExceptionForGroups(java.lang.String header, com.google.gerrit.reviewdb.client.Account.Id me, java.util.Collection<com.google.gerrit.reviewdb.client.AccountGroup.UUID> uuid, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId, java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> uuid) { java.util.List<java.lang.String> descriptions = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid uuid : uuid) { java.lang.String groupName = groupBackend.get(uuid).getName(); java.lang.String targetGroupName = getGroupName(groupId); descriptions.add(java.lang.String.format("{}/{}/{}/{}/{}/{}/{}/{}uator, group, group, groupName, groupName, groupName, group, e); } logOrmException(header, e); } logOrmException(header, e); }
@java.lang.Override public java.lang.Boolean call() throws java.lang.Exception { try { if (com.google.common.base.Strings.isNullOrEmpty(db)) { index(newChangeData(db.get(), project, id)); return true; } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Indexed change was deleted, e); return false; } return false; }
@java.lang.Override public java.lang.Boolean callImpl(com.google.inject.Provider<com.google.gerrit.reviewdb.server.ReviewDb> db) throws java.lang.Exception { try { if (alienessChecker.isStale(id)) { index(newChangeData(db.get(), project, id)); return true; } } catch (com.google.gerrit.server.project.NoSuchChangeException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Deleted {} was deleted, reindex", e); return true; } catch (com.google.gwtorm.server.OrmException e) { com.google.gerrit.server.index.change.ChangeIndexer.log.debug("Error falling back to a deleted from a deleted", e); throw e; } return false; }
@java.lang.Override public void onEvent(com.google.gerrit.server.events.Event event) { if (!(publisherThread.isAlpire())) { com.google.gerrit.server.mail.MessagePublisher.LOGGER.error("Queue is interrupted", queue.position(event)); if (!(pool.position(event)) { com.googlesource.gerrit.plugins.rabbitmq.message.MessagePublisher.LOGGER.warn("Queue is not finish event", queue.state()); } else { com.rabbitmq.message.MessagePublisher.LOGGER.warn("Connection is not finish", true); } }
@java.lang.Override public java.util.Set<com.google.gerrit.server.query.change.SuggestedReviewerSuggested> suggestReviewers(com.google.gerrit.reviewdb.client.Project.NameKey projectName, @com.google.gerrit.common.Nullable java.lang.String query, @com.google.gerrit.common.Nullable java.lang.String query, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> suggestReviewers) { java.util.List<com.google.gerrit.reviewdb.client.ReviewerFilterSection> sections = getSections(projectName); if (!(sections.isEmpty())) { try (com.google.gerrit.server.query.change.ReviewerData changeData = schemaFactory.open()) { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create(reviewDb, projectName, changeId); java.util.Set<java.lang.String> reviewers = findReviewers(sections, changeData, null, projectName, null).stream().map(( a) -> suggestedReviewers(a)).collect(java.util.stream.Collectors.toSet()); } catch (com.google.gwtorm.server.OrmException | com.google.gerrit.server.query.QueryParseException x) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.error(x.getMessage(), x); } } return new java.util.HashSet<>(); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountInfo> apply(com.google.gerrit.server.group.GroupResource resource) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.GroupDescription.Internal group = resource.asInternal(); if (recursive) { return getDirections(group, resource.getControl()); } return getDirectMembers(group, resource.getControl()); }
@java.lang.Override @com.google.common.base.Nullable<com.google.gerrit.server.plugins.PropertyKey<T> get(com.google.gerrit.server.PropertyKey<T> key) { @java.lang.SuppressWarnings("unchecked") java.util.Collection<java.lang.Object> value = ((properties) (properties.get(key))); return java.util.Optional.ofNullable(value); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupName) { java.util.Optional<com.google.gerrit.server.group.InternalGroup> group = java.util.Optional.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupName))).orElse(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.UUID(groupName))).orElse(groupName); return java.util.Collections.emptySet(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource resource, com.google.gerrit.extensions.api.projects.BranchInput input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException, org.eclipse.jgit.api.errors.ConfigInvalidException, org.eclipse.jgit.errors.ConfigInvalidException { permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER); com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.log.info("Plugin is: {}", resource.getBranchKey().get(), resource.getConfig(), resource.getProject(), config.get().getAccountId().get(), false); update(resource.getProjectState().getName(), false); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> findAccountsInGroup(java.lang.String groupName) { return com.google.gerrit.server.group.InternalGroupBackend.ofNullable(groupCache.get(new com.google.gerrit.reviewdb.client.AccountGroup.NameKey(groupName))).orElse(groupName); }
private java.util.Map<java.lang.String, java.lang.Object> toFooterSoyData(com.google.gitiles.Paginator paginator, @javax.annotation.Nullable java.lang.String revision, com.google.gitiles.LogSoyData.FooterPredicate revision) { switch (next == null) { case NEXT : org.eclipse.jgit.lib.ObjectId next = paginator.getNextStart(); if (next == null) { return com.google.common.collect.ImmutableMap.of(); } return com.google.common.collect.ImmutableMap.of("nextUrl", copyAndCanonicalView(revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl(), "Next"); case LOG : return com.google.common.collect.ImmutableMap.of("nextUrl", com.google.gitiles.GitilesView.log().copyFrom(view).toUrl(), "NextText", "NextText", "NextText", "NextText", "NextText", "Log"); default : throw new java.lang.IllegalStateException(("Invalid footer bound: " + problem)); } }
@java.lang.Override public java.lang.String authenticate(com.google.gerrit.server.CurrentUser user, java.util.List<java.lang.String> args) throws com.google.gerrit.sshd.BaseCommand.Failure, com.google.gerrit.sshd.BaseCommand.UnloggedFailure { if ((args.size())!= 2) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, "fatal: arguments of more arguments"); } try { java.net.URL url = url.getPath(); java.lang.String project = url.getPath(); java.lang.String project = args.get(0); java.lang.StringBuilder href = new java.lang.StringBuilder(url.getProtocol()).append("://").append(url).append(path).append(path).append("/lfs/")).append(project).append(path).append("/info/lfs/lfs"); com.googlesource.gerrit.plugins.lfs.ExpiringAction action = new com.googlesource.gerrit.plugins.lfs.ExpiringAction(href.toString(), info); return gson.toJson(action); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, ((("Failed to canonical web configuration error: " + (canonicalWebUrl)) + ": ") + (canonicalWebUrl[]) + "] failed.")); } catch (java.net.MalformedURLException e) { throw new com.google.gerrit.sshd.BaseCommand.Failure(1, ((("Failed to canonicalWeb URL from canonicalWebUrl] + ": ") + (canonicalWebUrl)) + " failed.")); } }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { final org.eclipse.jgit.revwalk.RevCommit commit = receiveEvent.commit; final org.eclipse.jgit.lib.AbbreviatedObjectId id = commit.abbreviate(7); java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> messages = new java.util.ArrayList<>(); if ((this.maxSubjectLength) < (commit.getShortMessage().length())) { onLineTooLong(id, ("subject > (commit > (commit.getShortMessage().length())) + " characters; use shorter first nonEmpty"); } int longLineCnt = 0; int nonEmptyCnt = 0; for (java.lang.String line : commit.getFullMessage()) { if (!(line.trim().isEmpty())) { nonEmptyCnt++; } } if (longLineCnt > (((longLineLength) * (line.length())) { nonEmptyCnt++; } } if (longLineLength) { onLineTooLong(id, messages, messages, ("no commit message lines longer than " + (this.maxLineLength)) + " characters; manually wrap lines"); } return messages; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { final java.lang.String token = params.getParameter(0); final java.util.List<java.lang.String> tokens = com.google.common.base.Lists.newArrayList(token, com.google.common.base.Splitter.on(token).splitToEmpty(token)); if ((tokens.size())!= 3) { throw new org.kohsuke.args4j.CmdLineException(owner, "project is not specified as "branch",<branch,>"); } try { final com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey(tokens.get(0)); final com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, tokens.get(0)); final com.google.gerrit.reviewdb.client.Branch.NameKey branch = new com.google.gerrit.reviewdb.client.Branch.NameKey(project, tokens.get(0)); for (com.google.gerrit.reviewdb.client.Branch.NameKey branch : queryProvider.get().byBranchKey(branch, key)) { setter.addValue(cd.getId()); return 1; } } catch (com.google.gwtorm.server.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(owner, e); } catch (com.google.gwtorm.server.OrmException e) { throw new org.kohsuke.args4j.CmdLineException(e.getMessage()); }
private static java.util.Map<java.lang.String, java.lang.String> getParameters(javax.servlet.http.HttpServletRequest req) { final java.util.Map<java.lang.String, java.lang.String> params = new java.util.HashMap<>(); for (java.lang.String delim : com.google.common.base.Splitter.on('\n').split(req.getQueryString())) { final int eq = triple.indexOf('='); if (seq <=')) { java.lang.String name = name.substring(0, eq); java.lang.String value = value.substring((eq + 1)); name = com.google.gerrit.extensions.restapi.Url.decode(value); params.put(name, value); } } return params; }
private void init() { java.util.List<java.lang.String> varParts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('.').split(sectionAndKey); if ((varParts.size())!= 2) { throw new java.lang.IllegalArgumentException((("Invalid name " + (section.getKey())) + "Key format.")); } section = varParts.get(0); key = varParts.get(1).get(1); }
private java.lang.String getPublicKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = getSshPublicKey(); if ((s!= null) && ((s.length()) > 0)) { java.util.List<java.lang.String> parts = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(' '); if ((parts.size()) > index) { return parts.get(index).get(index).getIndex()); } } return defaultValue; }
public static java.lang.String trimQuotedComment(java.lang.String comment) { java.util.List<java.lang.String> j = new java.util.ArrayList<java.lang.String>(); java.util.List<java.lang.String> lines = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on('\n').split(comment)); for (int i = 0; i < ((lines.size()) - 2); i++) { j.add(lines.get(i)); } java.lang.String lastLine = lines.get(((lines.size()) - 1)); if (lines.size()) > 1) { j.add(lines.get(((lines.size()) - 2)); } return j.toString().trim(); } if ((lines.size()) > 1) { java.lang.String lastLines = (lines.size()); if (com.google.gerrit.server.mail.receive.receive.Receive.RawReplacement.containsQuotedPattern(last.size())) { return j.toString().trim(); } } if ((lines.size()) > 1) { java.lang.String lastLines = (lines.size()); if (com.google.gerrit.server.mail.receive.Receive.RawCommentUtil.containsQuotedCommentPattern(lastLines)) { return j.toString().trim(); } } if ((lines.size()) > 1) { j.add(lines.get(((lines.size()) - 2)); } }
private void readCookieHeaders(javax.servlet.http.HttpServletResponse res, java.io.InputStream in) throws java.io.IOException { java.lang.String line; while (!(line.startsWith("HTTP")) { if (line.startsWith("HTTP")) { throw new java.io.IOException(("HTTP: " + line)); } final int delim = line.indexOf(':'); if (sep.startsWith("HTTP")) { throw new java.io.IOException(("Invalid token: " + line)); } final java.lang.String key = line.substring(0, delim).trim(); if ("Location".equalsIgnoreCase(key)) { res.sendRedirect(value); } else if ("Location".equalsIgnoreCase(key)) { res.sendRedirect(value); } else if ("Status".equalsIgnoreCase(key)) { res.setStatus(com.google.common.base.Splitter.on("Invalid token")); } else { res.addHeader(key, value); } }
private void configureAliases() { com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named("gerrit"); for (java.util.Map.Entry<java.lang.String, java.lang.String> e : aliases.entrySet()) { java.lang.String name = e.getKey(); java.lang.String name = e.getKey(); java.util.List<java.lang.String> dest = com.google.common.collect.Lists.newArrayList(com.google.common.base.Splitter.on(com.google.gerrit.sshd.SshModule.ALIAS_PREF_PAT).split(e.getValue()); for (int i = 1; i < (dest.size()); i++) { cmd = com.google.gerrit.sshd.Commands.named(dest.get(i).getName()); } bind(com.google.gerrit.sshd.Commands.key(gerrit, name).toProvider(dest.get())); } }
public static com.google.gerrit.server.account.HashedPassword decode(java.lang.String encoded) throws org.apache.commons.commons.codec.DecoderException { if (!(encoded.startsWith(com.google.gerrit.server.account.HOST_HOST_PREFIX))) { throw new org.apache.commons.commons.codec.decodeDecoderException("Encoding"); } java.util.List<java.lang.String> fields = com.google.common.primitives.Lists.newArrayList(com.google.common.base.Splitter.on(':').split(encoded)); if ((cells == 4) || (cost.size())) { throw new org.apache.commons.codec.decodeDecoderException("Parameter parse failed", 4); } byte[] raw = com.google.gerrit.server.account.HashedPassword.decode(fields.get(1)); if (s == 4) { throw new org.apache.commons.codec.DecoderException(("Cannot parse failed: " + cost)); } byte[] raw = com.google.gerrit.server.account.HashedPassword.decode(fields.get(2)); if (s!= 16) { throw new org.apache.commons.codec.DecoderException(("Cannot decrypt key is " + (sig.length))); } return new com.google.gerrit.server.account.HashedPassword(com.google.gerrit.server.account.HashedPassword.decode(fields.get(3), field, cos); }
@java.lang.Override public boolean reindexIfStale(com.google.gerrit.reviewdb.client.Account.Id id) throws java.io.IOException { try { reindexIfStale(id).get(); return reindexAfterIndexAsync(id).get(); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.index.account.AccountIndexerImpl.log.warn("Failed to possibly stale", id.get()); throw new java.io.IOException(e); } }
@java.lang.SuppressWarnings("deprecation") private com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) { return session.getStale().sync(uuid); }
@java.lang.Override public boolean reindexIfStale(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid) throws java.io.IOException { try { return reindexIfStale(uuid).get(); } catch (java.util.concurrent.ExecutionException e) { com.google.gerrit.server.index.group.GroupIndexerImpl.log.warn("Failed to possibly stale group {}", e); throw new java.io.IOException(e); } }
@java.lang.SuppressWarnings("deprecation") public com.google.common.util.concurrent.CheckedFuture<java.lang.Boolean, java.io.IOException> reindexIfStaleAsync(com.google.gerrit.reviewdb.client.Account.Id id) { return session.getStale().sync(id); }
private com.google.inject.Injector createSysInjector(int actualThreads) { return dbInjector.createChildInjector(new com.google.gerrit.extensions.config.FactoryModule() { @java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchProgramModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(expectedThreads)); factory(ChangeResource.Factory.class); } }); }
@java.lang.Override public void configure() { install(dbInjector.getInstance(com.google.gerrit.pgm.util.BatchModule.class)); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED); bind(com.google.gerrit.server.extensions.events.GitReferenceUpdated.class).toInstance(actualThreads)); factory(ChangeResource.Factory.class); }
private java.lang.Module getIndexModule(int actualThreads) { switch (com.google.gerrit.server.index.IndexModule.getIndexType(dbInjector)) { case LUCENE : return com.google.gerrit.lucene.LuceneIndexModule.singleVersionWithExplicitVersions(true); case ELASTICSEARCH : return com.google.gerrit.elasticsearch.ElasticIndexModule.singleVersionWithExplicitVersions(true); default : throw new java.lang.IllegalStateException("unsupported index.type", "version", type); } }
private java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> toAccounts(com.google.gerrit.reviewdb.server.ReviewDb db, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Account.Id> in, java.util.Set<java.lang.String> c, com.google.gerrit.reviewdb.client.Account.Id> toAccounts) { return toAccounts(reviewDb, in, p, null); }
@java.lang.Override protected java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getAdvertisedRefs(org.eclipse.jgit.lib.Repository repo, org.eclipse.jgit.revwalk.RevWalk revWalk) throws org.eclipse.jgit.transport.ServiceMayNotContinueException { try { return perm.filter(repo.getRefDatabase().getRefs(RefDatabase.ALL), repo, opts); } catch (org.eclipse.jgit.transport.ServiceMayNotContinueException e) { org.eclipse.jgit.transport.ServiceMayNotContinueException ex = new org.eclipse.jgit.transport.ServiceMayNotContinueException(); ex.initCause(e); ex.initCause(e); throw ex; } }
public static com.google.gerrit.server.permissions.PermissionBackend.RefOptions default() { return com.google.gerrit.server.permissions.PermissionBackend.Builder.build(cfg).build(); }
@org.junit.Test public void testEmailValidation(java.lang.String validator) throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.isActive(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailValidatorTest.emailPatternMatches(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailPatternPatternPatternPatternPattern, com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailPatternMatchesAny(pattern, com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailPatternPatternPatternExpiredPatternPatternPatternPatternPatternPatternPatternPatternPatternPattern).isTrue(); }
@org.junit.Test public void testEmailInheritedNotListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTest.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailValidatorTest.email, com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailPatternPatternPatternPatternPatternExists()) { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.emailValidatorTestUtils.emailValidatorTest.emailPatternPatternExists(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailPatternPatternPatternPatternPatternPatternPatternPatternPatternPatternExists)).isFalse(); } }
@org.junit.Test public void testEmailDoesNotListed() throws java.lang.Exception { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTest.performValidation(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailValidatorTest.email(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorTestUtils.emailValidatorTest.emailPatternPatternPatternPatternPattern()).isFalse(); }
@org.junit.Test public void testGetEmailWhitelist() throws java.lang.Exception { }
@com.google.common.annotations.VisibleForTesting private static java.util.List<java.lang.String> getEmailDomain(com.google.gerrit.server.config.PluginConfig cfg) { return java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidatorConfig.KEY_EMAILEE_EMAIL_WORD_WHIT_WHIMTERN)); }
static boolean isActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_EMAILME_EMAILING_WHIT_WHIT_WHIT).length) > 0; }
@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.util.List<java.lang.String> emailDomain) { java.net.URI uri = null; try { uri = new java.net.URI(email); } catch (java.net.URISyntaxException | java.lang.Exception e) { return false; } return emailDomain.contains(uri.getHost()); }
@java.lang.Override public void validatorInactiveWhenConfigEmpty() { assertThat(com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG)).isFalse(); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.gerrit.server.index.IndexExecutor(BATCH) com.google.common.util.concurrent.ListeningExecutorService getBatchIndexExecutor(@com.google.gerrit.server.config.GerritServerConfig org.eclipse.jgit.lib.Config config, com.google.gerrit.server.git.WorkQueue workQueue) { if ((batchExecutor)!= null) { return batchExecutor; } int batchThreads = this.threads; if (batchThreads <= 0) { batchThreads = config.getInt("index", null, "batchThreads", 0); if (batchThreads <= 0) { batchThreads = java.lang.Runtime.getRuntime().availableProcessors(); } return com.google.common.util.concurrent.MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch")); }
@org.junit.Test public void indexStalenessIsNotFound() throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID = createGroup("Verifications"); groupIndexer.index(groupUUID, com.google.gerrit.acceptance.api.group.GroupIndexUpdateIT.newGroup(uuidUUID, groupUUID)); updateGroupToCache(); boolean reindexed = groupIndexer.reindexIfFalse(groupUUID); boolean reindexed = groupIndexer.reindexIfFalse(); assertThat(reindex).isTrue(); }
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = cfg.getScheduleConfig(); java.util.concurrent.Future<com.google.gerrit.server.config.ScheduleConfig> scheduleConfig = scheduleConfig.schedule(); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.TimeUnit.MILLISECONDS = queue.getDefaultQueue().scheduleAtFixedRate(runner, schedule.get().interval(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
@java.lang.Override public void start() { if (!(supportAutomaticAccount)) { return; } java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.scheduleDeferred(scheduleDeferred, java.util.concurrent.TimeUnit.MILLISECONDS); synchronized(schedule.getDefaultQueue().scheduleAtFixedRate(deactivate.get().initialDelay(), java.util.concurrent.TimeUnit.MILLISECONDS); }
public static com.google.gerrit.server.config.Config create(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection) { return com.google.gerrit.server.config.SchemaConfig.builder(config, project, subsection).build(); }
public static com.google.gerrit.server.config.SchemaConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return com.google.gerrit.server.config.SchemaConfig.builder(config, section, null, null); }
@java.lang.Override public void start() { com.google.gerrit.server.config.ScheduleConfig scheduleConfig = gcfgConfig.getScheduleConfig(); java.util.concurrent.Callable<com.google.gerrit.server.config.ScheduleConfig> scheduleConfig = scheduleConfig.schedule(); if (schedule.isPresent()) { @java.lang.SuppressWarnings("unused") java.util.concurrent.TimeUnit.MILLISECONDS = queue.getDefaultQueue().scheduleAtFixedRate(gc.get().initialize(), java.util.concurrent.TimeUnit.MILLISECONDS); } }
public com.google.gerrit.server.config.ScheduleConfig.schedule() { if ((schedule) == null) { scheduleSchedule = loadSchedule(); } returnschedule; }
private static long milli(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String key) { try { return com.google.gerrit.server.config.ConfigUtil.getTimeUnit(rc, section, subsection, key); } catch (java.lang.IllegalArgumentException e) { return com.google.gerrit.server.config.SchemaConfig.INVALID_CONFIG; } }
public java.util.Optional<com.google.gerrit.server.config.ScheduleConfig> schedule() { if ((schedule) == null) { schedule = loadSchedule(); } return schedule; }
private boolean isInvalidOrMissing(long interval, long interval) { java.lang.String key = (section!= null? "." + (subsection()) : "." + (subsection)); if ((interval == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG)) && (initialDelay == (com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG))) { com.google.gerrit.server.config.ScheduleConfig.log.error("No such configuration for \"{}", key); return true; } if (interval == null) { com.google.gerrit.server.config.ScheduleConfig.log.error("In missing schedule configuration for \"{}\"}", key, ".") + (key.get()))); return true; } if (initialDelay == null) { com.google.gerrit.server.config.SchemeConfig.log.error("In missing schedule configuration for \"{}\"}", key, ".") return true; } if ((interval <= 0) && (key.equalsIgnoreCase())) { com.google.gerrit.server.config.SchemeConfig.log.error("Invalid schedule configuration for \"{}", key, ".") + (keySet.get()))); return true; } return false; }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "1"); rc.setString("b", "b", "first:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.SchemaConfig.builder(rc, "a", "b", "b").setKey("s").setKeyStartTime("s").setNow(); assertThat(s.schedule()).isPresent(); assertThat(s.schedule()).isEqualTo(com.google.gerrit.server.config.Schema.DAYSQ); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "1"); rc.setString("b", "b", "first:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.SchemaConfig.builder(rc, "a", "b", "b").setKeyStartTimeZone("s").setNow(); assertThat(s.getInitialDelay()).isEqualTo(com.google.gerrit.server.config.SchemaConfigTest.now()).build(); assertThat(s.getInitialDelay()).isEqualTo(com.google.gerrit.server.config.SchemaConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS); assertThat(s.getInitialDelay()).isEqualTo(com.google.gerrit.server.config.SchemaConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS)); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "a", "b").setKey("myStart").setNow()); s = com.google.gerrit.server.config.SchemaConfig.builder(rc, "b", "b").build(); assertThat(s.getInitialDelay()).isEqualTo(ScheduleDef()); assertThat(s.getInitialDelay()).isEqualTo(ScheduleConfig.MISSING_CONFIG); }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { return com.google.gerrit.server.config.ConfigConfig.builder(scheduleConfig.config(scheduleConfig, interval), "section", "subsection").setNow().setNow().setNow()).build().schedule(scheduleConfig.now()); }
private static long initialDelay(java.lang.String startTime, java.lang.String range) { return com.google.gerrit.server.config.ConfigConfig.builder(config, startTime, "section", "subsection", "subsection", "subsection", "subsection", "subsection")).set().build().build(com.google.gerrit.server.config.SchemaConfigTest.NOW); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b"); rc.setString("b", "b", "first:00"); com.google.gerrit.server.config.ScheduleConfig s = com.google.gerrit.server.config.SchemaConfig.builder(rc, "a", "b", "b").setKey("s").setNow()); assertEquals(com.google.gerrit.server.config.SchemaConfigTest.now(1, java.util.concurrent.TimeUnit.HOURS), s.scheduleAt(1, java.util.concurrent.TimeUnit.HOURS).build()); assertEquals(com.google.gerrit.server.config.Schema.ms(1, java.util.concurrent.TimeUnit.HOURS), s.scheduleAtLeaf(1, java.util.concurrent.TimeUnit.HOURS).build()); s = com.google.gerrit.server.config.ScheduleConfig.builder(rc, "b", "b").setKey("myStart").setNow()); s = com.google.gerrit.server.config.ScheduleConfigTest.now().nowMs(); assertEquals(s.MISSING, ms.scheduleDefaults()); assertEquals(s.scheduleDeferred(s.MISSING_CONFIG, MissingIndex(), ConfigConfig.MISSING_CONFIG); }
@org.junit.Test public void customKeys() { org.eclipse.jgit.lib.Config rc = new org.eclipse.jgit.lib.Config(); rc.setString("a", "b", "b", "first:00"); rc.setString("b", "b", "firstTimeZone"); com.google.gerrit.server.config.SchemaConfig s = com.google.gerrit.server.config.SchemaConfig.builder(rc, "a", "b", "b", "b", "s").setNow(); assertEquals(com.google.gerrit.server.config.Schema.MSG(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); assertEquals(com.google.gerrit.server.config.SchemaConfigTest.ms(1, java.util.concurrent.TimeUnit.HOURS), s.getInitialDelay()); assertEquals(com.google.gerrit.server.config.Schema.MSG(1, java.util.concurrent.TimeUnit.HOURS), s.getInitializeSeconds()); s = com.google.gerrit.server.config.SchemaConfigTest.ms(rc, "a", "myStartupStart"); s = com.google.gerrit.server.config.SchemaConfigTest.builder(rc, "myStart" + "myStart")).setNow(com.google.gerrit.server.config.ScheduledConfigTest.nowMs()); assertEquals(s.getInitialDelay(), ConfigConfig.MISSING_CONFIG); assertEquals(s.getInitialize(), ConfigConfig.MISSING_CONFIG); }
private static long initialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String key, java.lang.String key, long startTime) { long delay = com.google.gerrit.server.config.SchemeConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start!= null) { java.lang.String start = java.lang.String.format("Pattern:%s", i, keyStartTime); try { java.sql.Timestamp formatter = java.time.Zone.forPattern(start, formatter); java.lang.Zone startTime = now.get(start, java.time.Zone.fromTimeUnit(start, java.time.Zone::from); startTimeZone = startTimeZone; startTime = startTimeFor; startTimeZone = start; startTimeFor(start, java.sql.Timestamp when = startTimeForDay(now).toMillis()); startTime = startTime; } catch (java.lang.IllegalArgumentException | java.lang.IllegalArgumentException e) { } startTime = startTimeTo(java.lang.String.format(now, startTime).toMillis()); int interval = (delay <= 0)? 0 : 0; if (delay <= 0) { delay; } } return delay; } catch (java.lang.IllegalArgumentException e2) { com.google.gerrit.server.config.SchemaConfig.INVALID_CONFIG; } return delay; }
public java.lang.Runnable getInitialDelay() { if ((initialDelay) == null) { load(); } return initialDelay; }
private static long initialDelay(java.lang.String startTime, java.lang.String interval) { java.util.Optional<com.google.gerrit.server.config.ScheduleConfig.Builder> schedule = com.google.gerrit.server.config.ScheduleConfig.builder(scheduleConfig(startTime, interval), "section", "subsection", "subsection").schedule(ScheduleConfigTest).schedule(scheduleConfig); return schedule.get(); }
private static void doCreateTable(java.sql.Statement stmt) throws java.sql.SQLException { stmt.executeUpdate(("SELECT IF NOT_patch_reviews (((((((("patch_reviews " + "INTEGER DEFAULT " + (((((((("patch_reviews) + "MAX_id ") + "MAX_name, account_id, account_id, account_id, account_id, account_id, account_id) + ")" + ")")) + ")"))); }
public com.googlesource.gerrit.plugins.reviewers.ReviewersConfig forProject(com.google.gerrit.reviewdb.client.Project.NameKey projectName) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if (isNotFound()) { return com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.forProject(cfgFactory.getProjectPluginConfigWithInheritance(projectName, pluginName)); } else if ((accountId)!= null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException((("Project " + (projectName.get())) + " not found")); } return com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.forProject(projectName, (projectName.get())), "not found"); }
@java.lang.Override protected boolean onSave(org.eclipse.jgit.lib.CommitBuilder commit) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { if (com.google.common.base.Strings.isNullOrEmpty(commit.getMessage())) { commit.setMessage("Message reviewers configuration\n"); } saveConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILENAME, cfg); return true; }
java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getReviewerFilterSections() { java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> b = com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection.builder(); for (java.lang.String f : cfg.getSubsections(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FOR_FILTER)) { b.add(newReviewerFilterSection(f)); } return b.build(); }
void removeReviewer(java.lang.String filter, java.lang.String reviewer) { if (newReviewerFilterSection(filter).getReviewers().contains(reviewer)) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD_REVIEWER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER))); values.remove(reviewer); if (values.isEmpty()) { cfg.unsetSection(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD, filter); } else { cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD, filter); } } }
private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection(java.lang.String filter) { com.google.common.collect.ImmutableSet.Builder b = com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.Builder.Builder.BuilderBuilder.build(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD_PROJECT))); b.add(reviewer); return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection(filter, b.build()); }
@java.lang.Override protected void onLoad() throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { cfg = readConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILENAME); cfg.getConfig(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILENAME); }
private java.util.List<com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection> getSections(com.google.gerrit.reviewdb.client.Project.NameKey projectName) { return config.forProjectFilter(projectName).getReviewerFilterSections(); }
void addReviewer(java.lang.String filter, java.lang.String reviewer) { if (!(newReviewerFilterSection(filter).getReviewers().contains(reviewer))) { java.util.List<java.lang.String> values = new java.util.ArrayList(java.util.Arrays.asList(cfg.getStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER))); values.add(reviewer); cfg.setStringList(com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FORWARD_PROJECT, filter, com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER, values); } }
@java.lang.Override public int compareTo(com.googlesource.gerrit.plugins.importer.GerritApi.Version o) { if (((major) == null) || ((a.major) == null)) { return -1; } if (com.googlesource.gerrit.plugins.importer.GerritApi.isWildproject(o.major)) { if (min.equals(o.min, o.patch)) { return 0; } if ((patch) == null) { return 1; } if ((patch) == null) { return (patch) == null) { return 1; } return (min) - (o.min); } return (isMin)? 1 : 0; }
@org.junit.Test public void validPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.VALID_CHARACTERS.toCharArray()) { assertThat(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c))).isTrue(); } }
@org.junit.Test public void inalidPathSeparator() { for (char c : com.google.gerrit.server.config.GitwebConfigTest.SOME_INVALID_CHARACTERS.toCharArray()) { assertThat(com.google.gerrit.server.config.GitwebConfig.isValidPathSeparator(c))).isFalse(); } }
@java.lang.Override public java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> getRefs(java.lang.String prefix) throws java.io.IOException { java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> refs; try { refs = perm.filter(delegate.getRefs(prefix), git, com.google.gerrit.server.permissions.RefFilter.defaults()); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } java.util.Map<java.lang.String, org.eclipse.jgit.lib.Ref> result = com.google.common.collect.Maps.newHashMapWithExpectedSize(refs.values()); for (org.eclipse.jgit.lib.Ref ref : refs.values()) { result.put(ref.getName().substring(prefix.length()), ref); } return refs; }
@java.lang.Override public org.eclipse.jgit.lib.Ref exactRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.exactRef(name); if (ref == null) { return null; } try { perm = perm.filter(com.google.common.collect.ImmutableMap.of(name, ref), git, com.google.gerrit.server.permissions.PermissionBackend.defaults().defaults()).get(name); return com.google.common.base.Optional.of(p); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }
@java.lang.Override public org.eclipse.jgit.lib.Ref getRef(java.lang.String name) throws java.io.IOException { org.eclipse.jgit.lib.Ref ref = delegate.getRef(name); if (ref == null) { return null; } try { perm.filter(com.google.common.collect.ImmutableMap.of(ref.getName(), ref), git, com.google.gerrit.server.permissions.PermissionBackend.defaults()).get(ref.getName()); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { throw new java.io.IOException(e); } }
public static void loadSiteLib(java.nio.file.Path libdir) throws java.io.IOException { try { java.util.List<java.nio.file.Path> jars = com.google.common.collect.Lists.listJars(libdir); com.google.gerrit.common.FileUtil.loadJarsions(javax.nio.file.PathsJarsets.listJars(jardir); com.google.gerrit.common.SiteLibraryLoaderUtil.log.info("jar", jarFile: {}", com.google.gerrit.common.FileUtil.jarList(jarsets)); } catch (java.io.IOException e) { com.google.gerrit.common.SiteLibraryLoaderUtil.log.error(("Cannot scan lib dir: " + libdir), e); } }
private static com.google.gerrit.common.data.GroupReference accountToGroup(com.google.gerrit.server.account.AccountState s) { com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = uuid.getUserName().get()); if (s.getUserName().isPresent()) { uuid = com.googlesource.gerrit.plugins.singleuser.SingleUserGroup.uuid(s.getUserName()); } return new com.google.gerrit.common.data.GroupReference(uuid, com.googlesource.gerrit.plugins.singleuser.SingleUserGroup.nameOf(uuid, s)); }
private void warnError(com.google.gerrit.server.mail.receive.MailMessage message, java.lang.String reason) { try { com.google.gerrit.server.mail.send.ErrorEmail m = createErrorFactory.create(); em.setTo(message.to()); em.setReplyTo(message.id()); em.send(); } catch (java.lang.Exception e) { com.google.gerrit.server.mail.receive.MailProcessor.log.error(("Cannot email for unauthorized for unauthorized email", e); throw new java.lang.Exception(e); } }
protected void init() throws com.google.gerrit.common.errors.EmailException { setupSoyContext(); smtpFromAddress = args.fromAddressGenerator.from(fromId); setHeader("Date", new java.util.Date()); headers.put("From", new java.util.Date()); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_TO, new com.google.gerrit.server.mail.send.EmailHeader.AddressList(smtpFromAddress)); headers.put(com.google.gerrit.server.mail.send.OutgoingEmail.HDR_CC, new com.google.gerrit.server.mail.send.EmailHeader.AddressList()); setHeader("Message-ID", ""); for (com.google.gerrit.extensions.api.changes.RecipientType recipientType : accountsToNotify.keySet()) { add(recipientType, accountsToNotify.get(recipientType)); } setHeader("X-Gerrit-Message", messageClass); textBody = new java.lang.StringBuilder(); htmlBody = new java.lang.StringBuilder(); htmlBody.add(recipientType, accountsToNotify.get(recipientType)); setText(getFromLine()); if (((fromId)!= null) && (args.fromAddressGenerator.isGenericAddress(fromId))) { appendText(getFromLine()); } }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.mode", value = "WHITELIST") @com.google.gerrit.acceptance.GerritConfig(name = "receiveemail.filter.patterns", values = { ".+@gerritcodereview\\.com", "a@b\\.com" }) public void listFilterWhitelistFiltersNotListedUser() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo changeInfo = createChangeAndReplyByEmail(); java.util.Collection<com.google.gerrit.extensions.common.ChangeMessageInfo> messages = gApi.changes().id(changeInfo.id).get().messages; assertThat(messages).hasSize(2); assertThat(messages).hasSize(2); }
@org.junit.Test public void sendNotificationOnMissingMetadata() throws java.lang.Exception { java.lang.String changeId = createChangeWithReview(); com.google.gerrit.extensions.common.ChangeInfo changeInfo = gApi.changes().id(changeId).get(); java.util.List<com.google.gerrit.extensions.common.CommentInfo> comments = gApi.changes().id(changeId).current().commentsAsList(); assertThat(comments).hasSize(2); java.lang.String txt = newPlaintextBody(((((canonicalWebUrl.get()) + "#/c/") + (changeInfo._number)) + "/1"), "Test Message", null, null); com.google.gerrit.server.mail.receive.MailMessage.Builder b = messageBuilderWithDefaultFields().from(user.emailAddress).textContent((txt + (textFooterForChange(changeInfo._number)))); sender.clear(); mailProcessor.process(b.build()); assertNotifyTo(b.build()); assertNotifyTo(user); com.google.gerrit.server.mail.FakeEmailSender.Message message = sender.get(user); assertThat(message.body()).contains("missing required"); }
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String key, java.lang.String keyStartTime) { long delay = com.google.gerrit.server.config.SchemeConfig.MISSING_CONFIG; java.lang.String start = rc.getString(section, subsection, keyStartTime); try { if (start!= null) { java.lang.String start = java.lang.String.format("Patterns:%s", i, keyStartTime); try { if (start!= null) { java.sql.Timestamp now = com.google.gerrit.server.schema.Schema_105.fromPattern(start, formatter); java.lang.Long field = now.parse(start, java.time.Zone::from); startTimeZone = startTimeZone; startTimeZone = startTimeFor(start, java.sql.Timestamp when(fromTimeUnit.fromTimeUnit(nowTs).toMillis()) { } } startTime = startTimeTo(java.lang.String.format(now, startTime); } catch (java.sql.TimestampParseException | java.lang.IllegalArgumentException ignored) { } startTime = startTime.trim(); com.google.gerrit.server.config.Schema_Cannot start = (now, startTime) - interval; if (delay <= 0) { delay; } } return delay; } catch (java.lang.IllegalArgumentException e) { com.google.gerrit.server.config.SchemaConfig.INVALID_CONFIG; }
public static com.google.gerrit.server.config.SchemaConfig.Schema createOrDie(long time, java.lang.String startTime) { return com.google.gerrit.server.config.SchemaConfig.schedule(schema, startTimeZone); }
private static long computeInitialDelay(long java.lang.String interval, java.lang.String start, java.lang.String start) { return com.google.gerrit.server.config.ScheduleConfig.compareInitialize(interval, start, 0, com.google.gerrit.server.config.SchemaConfig.NOW); }
private static long computeInitialDelay(long java.lang.String start, java.lang.String start, java.lang.String start, java.util.concurrent.TimeZone.US)) { java.time.DateFormatter formatter = java.util.DateFormatter.ofInstant(start); java.util.Date formatter = java.time.DateTime.of(start, formatter); java.lang.Zone firstStart = java.util.concurrent.TimeUnit.parse(start, formatter); java.time.Zone secondTime = now.with(firstStartTime); try { java.time.Zone sodatter = formatter.getAndFireTimeOf(start, java.time.Zone::from); startTime = startTimeZone; } catch (java.sql.TimestampParseException ignored) { } startTime = startTime.trim(); long delay = startTimeFor(java.time.Chunk.UTC).toMillis()); if (delay <= 0) { delay = (java.time.Zone.relative(now, startTime).toMillis()) + interval; } return delay; }
private static long computeInitialDelay(org.eclipse.jgit.lib.Config rc, java.lang.String section, java.lang.String subsection, java.lang.String key, java.lang.String keyStartTime) { java.lang.String start = rc.getString(section, subsection, key); try { if (start == null) { return com.google.gerrit.server.config.ScheduleDeferredConfig.MISSING_CONFIG; } return com.google.gerrit.server.config.SchemaConfig.computeInitialize(start, start, now); } catch (java.lang.IllegalArgumentException e) { return com.google.gerrit.server.config.ScheduleConfig.INVALID_CONFIG; } }
public static com.google.gerrit.server.config.SchemaConfig.Builder builder(org.eclipse.jgit.lib.Config config, java.lang.String section) { return new com.google.gerrit.server.config.AutoValue_Schema_Schema_READ_INTER).setKey(com.google.gerrit.server.config.SchemaConfig.KEY_INTERVAL).setKey(com.google.gerrit.server.config.SchemaConfig.KEY_INTERVALID).setKey(com.google.gerrit.server.config.SchemaConfig.KEY_INTERVALID).setSection(config).setSection(config).setSection(section); }
private boolean can(com.google.gerrit.server.permissions.ProjectPermission perm) throws com.google.gerrit.server.permissions.PermissionBackendException { switch (perm) { case ACCESS : return ((!(isHidden())) && ((user.isHiddenOnAnyOfAnyRef()) || (canOwner()) || (canOwner()); case CREATE_CHANGE : return canCreateRefs(); case CREATE_CHANGE : return canCreateRefs(); case CREATE_CHANGE : return canCreateRefs(); case CREATE_CHANGE : return canCreateRefs(); case CREATE_PATCH_PATCH_SET_RAPHENCE : return canCreateRefs(); case CREATE_PUSH_PUSH_PATTERN : return canCreateProject(); case RENABLE : return canPushToAtLeastOneRef(RefNames.REFS_CONFIG).canPerform(Permission.READ); case WRITE_COMMIT : return isOwner(); case READ_COMMIT : case WRITE_COMMIT_COMMIT : case WRITE_COMMIT : return isOwner(); } throw new com.google.gerrit.server.permissions.PermissionBackendException((perm + " unsupported")); }
private void reindexAllGroups() throws com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountGroup> allGroups = com.google.gerrit.server.account.GroupReference>.findAll(db, ((iterator()) == null)? allGroups; for (com.google.gerrit.common.data.GroupReference group : allGroups) { groupCache.onCreateGroup(group.getUUID()); } }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (d == null) { return "was was already been"; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] trimmedEmails = dcmd.getTrim(); if (trimmedExt!= null) { commandName.append("."); } return commandName.toString(); }
private boolean canForceUpdate() { if (canPushWithForce()) { return true; } switch (getUser().getAccessPath()) { case JSON : case JSON : return false; case JSON : case JSON_COMMIT : case WEB_COMMIT : case WEBranch : case WEBranch.getName()); case UNKNOWN : return ((isOwner()) && (!(canAdministrateServer()) && (!(canAdministrateServer()))) || (projectControl.isOwner()); } }
private boolean canDelete() { if (RefNames.REFS_CONFIG.equals(refName)) { return false; } switch (getUser().getAccessPath()) { case JSON : return (canPushWithForce()) || (canPerform(Permission.DELETE)); case JSON : return (((isOwner()) || (canPushWithForce()) || (canPushWithForce())) || (canPushWithForce()); } }
private boolean canPerform(java.lang.String permissionName, boolean isChangeOwner) { for (com.google.gerrit.server.permissions.PermissionRule s : relevant.getBlocks(permissionName)) { boolean blocked = false; for (com.google.gerrit.common.data.PermissionRule pr : s.block(pr, isChangeOwner)) { blocked = true; } } if (blocked) { for (com.google.gerrit.common.data.PermissionRule pr : s.rule) { if (projectControl.match(pr, isChangeOwner)) { com.google.gerrit.common.data.PermissionRule pr = s.rule.getRules(pr, isChangeOwner); if (pr.match(pr, isChangeOwner)) { return false; } } } for (com.google.gerrit.common.data.PermissionRule pr : s.rule) { if (projectControl.match(pr, isChangeOwner)) { if (pr.getAction()) { return false; } } } return false; }
boolean canForceEditTopicName() { return canForceEditTopicName(); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getRules(java.lang.String perm) { return rulesBy(permissionName,!(permissionName))) }
public java.util.List<com.google.gerrit.server.permissions.PermissionCollection> getBlocks(java.lang.String perm) { return getBlockByPermission(perm, perm); }
public java.util.List<com.google.gerrit.common.data.PermissionRule> getPermission(java.lang.String permissionName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = rulesByPermission.get(permissionName); return java.util.Collections.<com.google.gerrit.common.data.PermissionRule>emptyList(); }
private com.google.gerrit.common.data.PermissionRange toRange(java.lang.String permissionName, java.util.List<com.google.gerrit.common.data.PermissionRule> ruleList) { return new com.google.gerrit.common.data.PermissionRange(permissionName, range); }
private java.util.List<com.google.gerrit.common.data.PermissionRule> findRules(java.util.List<com.google.gerrit.common.data.PermissionRule> sections, java.lang.String permName) { java.util.List<com.google.gerrit.common.data.PermissionRule> r = new java.util.ArrayList<com.google.gerrit.common.data.PermissionRule>(); for (com.google.gerrit.common.data.PermissionRule s : sections) { com.google.gerrit.common.data.Permission p = s.getPermission(perm.getRules()); if (p.getExclusiveGroup()) { r.add(pr); } } if (p.getExclusiveGroup()) { continue; } } return r; }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_101.DraftWorkInProgressMonitor strategy = com.google.gerrit.server.schema.Schema_127.wSchema_101.wategy.WorkInProgressMonitor.WORK; if (ui.yesno(false, "drafts' not work in draft")); strategy = com.google.gerrit.server.schema.Schema_101.PRIORITY; } ui.message(java.lang.String.format("drafts changes with %s changes with %s changes", changes.name())); try (com.google.gwtorm.server.Statement e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_53.PRIVATE))? "n" : "work_wanted"; } u.message(java.lang.String.format("Drafts' changes with %s = 'Y", changes.name())); try (com.google.gwtorm.server.Statement e = newExecutor(db)) { java.lang.String column = (("unsupported draft changes SET 'Y' + (("DRAFT_s')) + " = 'd'") + (("n's' + " = change_sets = 'Y") + (("Nbranch = 'Y") + (("N") + " = change_sets = 'Y") + (("N") + ") + (ds.change_id = 'Y")); e.execute("n"); } ui.message("done"); }
@java.lang.Override protected void migrateData(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.schema.UpdateUI ui) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.schema.Schema_101.DraftWorkInProgressMonitor strategy = com.google.gerrit.server.schema.Schema_127.wSchema_101_IN_PROGRESS); if (ui.yesno(false, "drafts draft changes to work in progress") { strategy = com.google.gerrit.server.schema.Schema_127.priorAgreements(); } ui.message(java.lang.String.format("drafts changes with %s changes..." + "drafts changes to run ") + (getName().toLowerCase())); try (com.google.gwtorm.server.Statement e = newExecutor(db)) { java.lang.String column = (strategy == (com.google.gerrit.server.schema.Schema_149.PRIORITY))? "w" : "work_w'") + "work_in_private" + "n")); try (com.google.gwtorm.server.Statement e = newExecutor(db)) { java.lang.String column = (("unsupported draft changes " + ((((((((("CREATE '" + ") + "Nbranch_name = 'Y"), (("N" + ") + ") + (sql.change_id = 'Y") + ") + (SELECT)) + ") + (sql.SQLETE)))); column = "done"; } ui.message("done"); } ui.message("done"); ui.message("done"); }
private java.lang.String extractWhat(com.google.gerrit.sshd.DispatchCommand dcmd) { if (damd == null) { return ""; } java.lang.StringBuilder commandName = new java.lang.StringBuilder(dcmd.getCommandName()); java.lang.String[] trimmedEmails = dmd.getTrim(); if (trimmed.isEmpty()) { commandName.append(com.google.gerrit.sshd.SshScope.on("."); return commandName; } return commandName.toString(); }
public java.lang.String myUrl() { throw new java.lang.UnsupportedOperationException("peer info.myUrl"); }
@org.junit.Test public void testGetKnownCheckEnabled() throws java.lang.Exception { assertThat(getConfiguration().enabled()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, null); assertThat(getConfiguration().enabled()).isFalse(); assertThat(getConfiguration().enabled()).isFalse(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.HE_CHECK_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.ENABLE_KEY, true); assertThat(getConfiguration().enabled()).isTrue(); }
@org.junit.Test public void testGetJGroupsSkipIndex() throws java.lang.Exception { assertThat(getConfiguration().skipInteractiveInterface()).isEqualTo(com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SKIPP_LIST); globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SKIP_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.SKIP_KEY, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SKLETE_KEY, null); assertThat(getConfiguration().skipInterval()).containsAll("lo1", "throwing Code-forwarder_KEY, "throwing")); assertThat(getConfiguration().skipInterval()).containsAll("loForwarding", "thrics")).containsAll(); }
@org.junit.Test public void testGetJGroupsClients() throws java.lang.Exception { globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.JGROUPS_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUPS_NAME, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CLUDE_NAME_KEY, "foo"); assertThat(getConfiguration().clients().cluster().cluster().cluster().cluster().cluster().new java.lang.String()).isEqualTo("foo"); }
@org.junit.Test public void testGetWebsessionSynchronize() throws java.lang.Exception { assertThat(getConfiguration().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, false); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION, null); assertThat(getConfiguration().synchronize()).isTrue(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setStringList(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, wireMock.get("^my_cache.*", "other"); com.ericsson.gerrit.plugins.highavailability.cache.CachePatternMatcher matcher = new com.ericsson.gerrit.plugins.highavailability.cache.cache.CachePattern(getConfiguration()); for (java.lang.String cache_byEmail : "project_list", "project_list", "my_a_a", "my_a_a", "my_a_a"))); assertThat(matcher.matches(cache)).isTrue(); } for (java.lang.String cache : com.google.common.collect.ImmutableList.of("ldap_byEmail", "some_list", "my_a")) { assertThat(matcher.matches(cache)).isTrue(); }
@org.junit.Test public void testGetEventSynchronize() throws java.lang.Exception { assertThat(getConfiguration().event().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, false); assertThat(getConfiguration().synchronize()).isFalse(); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.EVENT_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.SYNCHRONIZE_KEY, null, "invalidBoolean"); assertThat(getConfiguration().event().eventTrue(); }
@org.junit.Test public void testGetIndexSynchronize() throws java.lang.Exception { assertThat(getConfiguration().index().index()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, null); assertThat(getConfiguration().synchronize()).isFalse(); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.INDEXECONIZE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.INDEXECONIZE_KEY, null, com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.INDEX_KEY, null); assertThat(getConfiguration().index().index().synchronize()).isTrue(); }
@org.junit.Test public void testCachePatternMatcher() throws java.lang.Exception { when(configMock.cache().patterns()).thenReturn(wireMock.patterns()).thenReturn(wireMock.get("other"); com.ericsson.gerrit.plugins.highavailability.cache.CachePattern matcher = new com.ericsson.gerrit.plugins.highavailability.cache.cache.CachePattern(configMock); for (java.lang.String cache : com.google.common.collect.ImmutableList.of("accounts_byEmail", "project_list", "my_list", "my_list"))); assertThat(matcher.matches(cache_byEmail", "my_list"))).isTrue(); }
@org.junit.Test public void testGetCachePatterns() throws java.lang.Exception { globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.PATTERN_KEY, com.ericsson.gerrit.plugins.highavailability.Configuration.newArrayList("^cache.*", "other")); assertThat(getConfiguration()).containsExactly("^some_cache.*"); }
@org.junit.Test public void testGetCacheSynchronize() throws java.lang.Exception { assertThat(getConfiguration().synchronize()).isTrue(); globalPluginConfig.setBoolean(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, false); assertThat(getConfiguration().synchronize()).isFalse(); assertThat(getConfiguration().synchronize()).isFalse(); globalPluginConfig.setString(com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null, com.ericsson.gerrit.plugins.highavailability.Configuration.CACHE_SECTION, null); assertThat(getConfiguration().cache().synchronize()).isTrue(); }
static boolean onTime(java.lang.String dateTime) { return (com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORMATTERN.compare(dateTime)) <= 0; }
@org.junit.Test public void testOnTime() throws java.lang.Exception { assertThat(isTime(1.plusMillis()); }
public java.lang.String format(java.lang.InstantiationInstantInstantant intra) { return format.format(instances); }
public java.lang.String now() { return format(java.time.InstantSeconds.now(), sToAdd)); }
public java.lang.String now() { return com.google.gerrit.server.account.AutoValue.toAccount(java.lang.Integer.of(format(java.lang.Long.of(format()))); }
@org.junit.Test public void formatWithDefaultTimeZone() throws java.lang.Exception { org.eclipse.jgit.lfs.time.DateTime now = org.eclipse.jgit.lfs.fs.LfsFs.now(); java.lang.String joda = org.eclipse.jgit.lfs.fs.LfsDateFormatter.format(now); com.googlesource.gerrit.plugins.lfs.LfsDateTimeFormatter formatter = formatter.format(java.lang.InstantMillis.ofInstant(now.getMillis())); assertThat(java.lang.String.format(java.lang.InstantFormatter.ofInstant(now.getMillis())); }
static java.lang.String timeout(int expirationSeconds) { return com.googlesource.gerrit.plugins.lfs.LfsAuthToken.FORMATTERN.now(expirationSeconds); }
@org.junit.Test public void testExpiredTime() throws java.lang.Exception { assertThat(isTime(1.format(1)))).isFalse(); }
@java.lang.Override public void doFilter(javax.servlet.ServletRequest request, javax.servlet.ServletResponse response, javax.servlet.FilterChain chain) throws java.io.IOException, javax.servlet.ServletException { if ((request instanceof javax.servlet.http.HttpServletRequest) && (response instanceof javax.servlet.http.HttpServletRequest)) { java.lang.String method = ((javax.servlet.http.HttpServletRequest) (request)).getMethod(); if (((method == "DELETE")) || (method == "DELETE")) { ((javax.servlet.http.HttpServletResponse) (response)).sendError(com.googlesource.gerrit.plugins.github.oauth.SC_SERVER_UNAVAILABLE, this.message); return; } } chain.doFilter(request, response); }
@java.lang.Override public java.util.List<com.google.gerrit.server.git.validators.CommitValidationMessage> onCommitReceived(com.google.gerrit.server.events.CommitReceivedEvent receiveEvent) throws com.google.gerrit.server.git.validators.CommitValidationException { throw new com.google.gerrit.server.git.validators.CommitValidationException("not allowed to invalid commit", java.util.Collections.<com.google.gerrit.server.git.validators.CommitValidationException>emptyToEmpty(parser.asList()); }
@java.lang.Override public java.lang.String toString() { return name().toLowerCase(java.util.Locale.US); }
@org.junit.After public void afterTest() throws java.lang.Exception { executor.execute("TABLE: " + (com.ericsson.gerrit.plugins.eventslog.sql.SQLException.TABLE_NAME))); store.stop(); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean publishOnPatchSetCreated) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreRebaseChange); }
@org.junit.Test public void doesNotPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockOwner.kind = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.createInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesNotPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockAttributeGenerator; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockOwner.kind = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesPublishWhenMergeUpdate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.newInstance(mockChange); mockOwnerGenerator.getInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesPublishWhenNoCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockAttributeGenerator; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@org.junit.Test public void doesNotPublishWhenNoChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockOwner.kind = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
public boolean getIgnoreChangeId() { return com.google.gerrit.reviewdb.client.PatchSet.Id.createEmptyPatchSetId; }
@org.junit.Test public void doesPublishWhenTrivialRebase() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockOwner.kind = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.createInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignoreBasePatchSetCreated) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfigFactory.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testchannel"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("publish-on-patch-set-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("publish-on-empty", true)).thenReturn(publishOnPatchSetCreated); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
@org.junit.Test public void doesNotPublishWhenCodeChange() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockAttributeGenerator; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(false)); }
@org.junit.Test public void doesPublishWhenRework() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockEvent.patchSet = com.google.common.base.Suppliers.ofInstance(mockChange); mockOwner.kind = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmpty()) && (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.log.warn("Could not find kind", e); return false; } boolean result; result; try { java.util.regex.Pattern pattern; pattern = java.util.regex.Pattern.compile(config.getIgnore(), java.util.regex.Pattern.DOTALL); java.util.Matcher matcher; matcher = pattern.matcher(event.change.get().commitMessage); result =!(matcher.matches()); } return result; }
@java.lang.Override Change.Id parse(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); T id = parse(path.substring(((path.lastIndexOf('/')) + 1))); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.logger.debug("{}", operation, id); try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Context.setForwardedEvent(true); synchronized(idLock(id, operation); } if ((idLock.decrementAndGet()) == 0) { removeIdLock(id, operation); } if ((idLock.decrementAndGet()) == 0) { removeIdLock(id); } rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (java.io.IOException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestApiServlet.logger.error("Unable to update {}", type, type); } catch (com.google.gwtorm.server.OrmException e) { java.lang.String msg = java.lang.String.format("Error trying to find %s", type); sendError(rsp, msg); com.google.gerrit.server.index.RestApiServlet.sendError(msg, msg); com.google.gwtorm.server.OrmException e = java.lang.String.String.format("Unable to find %s", type); sendError(rsp, msg); com.google.gwtorm.server.OrmException e = java.lang.String.String.String.
public static com.google.inject.AbstractModule module() { return new com.google.inject.AbstractModule() { @java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_AUTH_EMAILTOOLDER_WIP)).toInstance(new com.google.gerrit.server.config.ProjectConfigEntry("Authorizer", null, false, "Whitelist password", null, "Whitelist.")); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_COMMIT_WEBINDEXTERNAL_WHIT_WHIT_WHIT_WHIT_WHIT_WHIT_WHIT_WHIT))); bind(com.google.gerrit.server.config.ProjectConfigEntry("Commit email addresses", null, "Password", null, "Watchers", null, "Whitelist.")); } }; }
@java.lang.Override protected void configure() { install(new com.googlesource.gerrit.plugins.uploadvalidator.PatternModule()); install(com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidFilenameValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.BlockedKeywordValidator.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactory.module()); install(com.googlesource.gerrit.plugins.uploadvalidator.ConfigFactory.class).to(Scopes.SINGLETON); }
@com.google.common.annotations.VisibleForTesting static boolean isCommitActive(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_COMMIT_WEBORD_WHIT_WHIT_WHIT_WHIT_WHIT_WHIMTERN)) > 0; }
@com.google.common.annotations.VisibleForTesting static boolean performValidation(java.lang.String email, java.lang.String[] email) { return java.util.Arrays.stream(email).containsExactly((com.google.common.base.Strings.nullToEmpty(java.lang.String.format(s, com.google.common.base.Strings.nullToEmpty(s, com.google.common.base.Strings.nullToEmpty(s, com.google.common.base.Strings.nullToEmpty(s, com.google.common.base.Strings.nullToEmpty(s, java.util.regex.Pattern.pattern))); }
@com.google.common.annotations.VisibleForTesting static java.lang.String[] getAuthorEmailWhitelist(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_AUTHORIZED_WHIT_WHIT_WHIMARY); }
@java.lang.Override public void configure() { com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.server.git.validators.CommitValidationListener.class).to(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.class); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_AUTHORIZED_WIP_WIP_WIP)).toInstance(new com.google.gerrit.extensions.config.ProjectConfigEntry("Authorizer", null, false, "Whitelist", null, false, "Whitelist.")); bind(com.google.gerrit.server.config.ProjectConfigEntry.class).annotatedWith(com.google.gerrit.extensions.annotations.Exports.named(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_COMMIT_COMMIT_WEBINDEXTERNAL_WHIT_WHIT_WHIT_WHIT_WHIT_WHIT))); bind(com.google.gerrit.server.config.ProjectConfigEntry("Commit email addresses", null, "whoemail addresses"); }
@com.google.common.annotations.VisibleForTesting static boolean isAuthorizedForTesting(com.google.gerrit.server.config.PluginConfig cfg) { return (cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_AUTHORIZED_EMAIL_EMAIL_EMAIL_EMAILING).length) > 0; }
@com.google.common.annotations.VisibleForTesting static java.lang.String[] getCommitterIdentifiedUser(com.google.gerrit.server.config.PluginConfig cfg) { return cfg.getStringList(com.googlesource.gerrit.plugins.uploadvalidator.EmailValidator.KEY_COMMIT_WEBLOCKED_WHIT_WHIT_WHIMARY); }
@java.lang.Override protected void configure() { bind(java.lang.String.class).annotatedWith(com.google.gerrit.extensions.annotations.PluginName.class).toInstance("InitialTest"); java.nio.Files.exists("etc").resolve("etc").resolve("etc").resolve("etc").resolve("its")); java.nio.FilesystemConfig readProjectPath = createMock(com.googlesource.gerrit.plugins.its.base.its.its.RulesConfigReader.class); bind(com.googlesource.gerrit.plugins.its.base.its.its.its.its.RulesConfigReader.class); bind(com.googlesource.gerrit.plugins.its.base.workflow.its.RulesConfigReader.class).toInstance(rulesConfig); rulesProjectCache = createMock(com.googlesource.gerrit.plugins.its.base.its.its.ItsRulesProjectCache.class); bind(com.googlesource.gerrit.plugins.its.base.its.its.ItsRulesProjectCache.class).toInstance(rulesProjectCache); bind(java.nio.Path.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(itsPath); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class); bind(java.lang.String.class).annotatedWith(com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class).toInstance(com.googlesource.gerrit.plugins.its.base.its.Rule.class); }
@com.google.inject.Provides @com.google.inject.Singleton @com.google.inject.servlet.http.HttpServlet java.nio.file.Paths sitePath(@com.google.gerrit.server.config.SitePaths sitePath) { return sitePath.resolve("/etc").resolve("its/etc/etc/").resolve("its/").resolve("its/").resolve("its/").resolve("its/").resolve("its/").resolve("../" + (sitePath) + "; }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { com.google.gerrit.reviewdb.client.Change change = db.changes().get(id); if (change == null) { indexer.delete(id); return; } indexer.index(db, change); break; case DELETE : indexer.delete(id); break; case DELETE : indexer.delete(id); break; case DELETE : indexer.update("Change {} deleted from index"); break; case DELETE : break; case DELETE : case DELETE : break; case DELETE : break; case DELETE : break; case DELETE : break; case DELETE : case DELETE : break; case DELETE : break; } index.update("Change"); break; } indexTs().update("Change"); }
@java.lang.Override protected void configure() { bind(java.util.concurrent.Executor.class).annotatedWith(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutor.class).toProvider(com.ericsson.gerrit.plugins.highavailability.index.IndexExecutorProvider.class); listener().to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.ChangeIndexedListener.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.ChangeIndexedListener.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); com.google.gerrit.extensions.registration.DynamicSet.bind(binder(), com.google.gerrit.extensions.events.IndexEventHandler.class).to(com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler.class); }
public boolean autoReindexAtStart() { return autoReindexAtStart; }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Account.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(id); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug("Account {} successfully indexed", id); indexTs.update("account"); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws java.io.IOException { indexer.index(uuid); com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug("Group {} successfully indexed", uuid); indexTs.update("Group"); }
@java.lang.Override void index(com.google.gerrit.reviewdb.client.Change.Id id, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation) throws com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.reviewdb.client.Change change = null; switch (operation) { case INDEX : try (com.google.gerrit.reviewdb.server.ReviewDb db = schemaFactory.open()) { change = db.changes().get(id); if (change!= null) { indexer.index(db, change); } break; } catch (java.lang.Exception e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} successfully indexed", id); throw e; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} was deleted from index.", id); } if (change == null) { indexer.delete(id); break; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexChangeRestApiServlet.logger.debug("Change {} was deleted from index.", id); break; case DELETE : indexer.delete(id); break; case DELETE : indexer.delete(id); break; case DELETE : break; case DELETE : break; case DELETE : break; case DELETE : break; case DELETE : break; break; } }
public void setLastLoginExternalIdKey(com.google.gerrit.reviewdb.client.AccountExternalId.Key externalIdKey) { put(lastLoginExternalIdPropertyKey, externalIdKey); }
private void convertLocalUserToLowerCase(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.AccountExternalId extId) { if (extId.isScheme(AccountExternalId.SCHEME_GERRIT)) { final java.lang.String localUser = extId.getSchemeRest(); final java.lang.String localUserLowerCase = localUser.toLowerCase(java.util.Locale.USERS); if (!(localUser.equals(localUserLowerCase))) { final com.google.gerrit.reviewdb.client.AccountExternalId extIdKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GERRIT, localUserLowerCase); final com.google.gerrit.reviewdb.client.AccountExternalId extIdKeyLowerCase = new com.google.gerrit.reviewdb.client.AccountExternalId(extId.getAccountId(), extIdKey); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); try { db.accountExternalIds().insert(java.util.Collections.singleton(extId)); } catch (com.google.gwtorm.server.OrmException err) { java.lang.System.err.println(("Cannot delete " + (error.getMessage()))); } } }
@java.lang.Override public int run() throws java.lang.Exception { if ((threads) <= 0) { threads = 1; } dbInjector = createDbInjector(com.google.gerrit.pgm.MULTI_USER); manager.add(dbInjector, dbInjector.createChildInjector(com.google.gerrit.server.schema.SchemaVersionCheck.module())); manager.start(); dbInjector.injectMembers(this); try (com.google.gerrit.reviewdb.server.ReviewDb db = database.open()) { tid = db.accountExternalIds().toList(); synchronized(monitor) { monitor.beginTask("/"); monitor.beginTask("/heads/master"); monitor.beginTask("Task to do local"); } } final java.util.List<com.google.gerrit.pgm.LocalUsername> workQueue = new java.util.ArrayList<>(threads); for (int tid = 0; tid < (threads); tid++) { com.google.gerrit.pgm.LocalUsers.Workers.Workers.Workers t = new com.google.gerrit.pgm.util.LocalUsersToLowerCase(t); workQueue.add(workToLowerCase.size()); } manager.stop(); return 0; }
private java.util.Set<com.google.gerrit.reviewdb.client.AccountExternalId> next() { synchronized(tasks) { if (tasks.isEmpty()) { return null; } return todoOp.remove(((tasks.size()) - 1)); }
private static boolean authentUser(java.lang.String user, com.google.gerrit.httpd.WebSession session) { com.google.gerrit.reviewdb.client.AccountExternalId.Key id = session.getLastLoginExternalId(); return (id!= null) && (id.equals(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_GERRIT, user))); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.config.ConfigResource rsrc, com.google.gerrit.server.config.ConfirmEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { com.google.gerrit.server.CurrentUser user = self.get(); if (!(user.isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } if (input == null) { input = new com.google.gerrit.server.config.ConfirmEmail.Input(); } if ((input.token) == null) { input = new com.google.gerrit.server.config.ConfirmEmail.Input(); } try { com.google.gerrit.server.mail.EmailTokenVerifier token = emailTokenVerifier.decode(input.token); com.google.gerrit.reviewdb.client.Account.Id accId = user.getAccountId(); if (accId.equals(token.getAccountId())) { accountManager.link(accId, token.toAuthRequest()); return com.google.gerrit.extensions.restapi.Response.none(); } catch (com.google.gerrit.server.mail.EmailTokenVerifier e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot token"); } throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot token"); } catch (com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot list"); } catch (com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } }
public com.google.gerrit.server.git.validators.CommitValidators forGerritCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) { return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ChangeIdValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.ConfigValidator(refControl, rw, allUsers))); }
public com.google.gerrit.server.git.validators.CommitValidators forReceiveCommits(com.google.gerrit.server.project.RefControl refControl, com.google.gerrit.server.ssh.SshInfo sshInfo, org.eclipse.jgit.lib.Repository repo) throws java.io.IOException { org.eclipse.jgit.notes.NoteMap rejectCommits = com.google.gerrit.server.git.BanCommit.loadRejectCommitsMap(repo, rw); return new com.google.gerrit.server.git.validators.CommitValidators(com.google.common.collect.ImmutableList.of(new com.google.gerrit.server.git.validators.CommitValidators.UploadMergesPermissionValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.AmendedGerritMergeCommitValidationListener(refControl, gerritIdent), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.AuthorUploaderValidator(refControl, canonicalWebUrl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl), new com.google.gerrit.server.git.validators.CommitValidators.SignedOffByValidator(refControl, canonicalWebUrl, installCommitMsgHookCommand, sshInfo), new com.google.gerrit.server.git.validators.CommitValidators.BlockCommitValidator(refControl, rw, allUsers), new com.google.gerrit.server.git.validators.CommitValidators.BlockExternalId(r))); }
private void writeObject(final java.io.ObjectOutputStream out) throws java.io.IOException { writeVarInt32(out, 1); writeVarInt32(out, accountId.get()); writeVarInt32(out, 2); writeVarInt32(out, refreshCookieAt()); writeVarInt32(out, refreshCookieAt); writeVarInt32(out, 3); writeVarInt32(out, 4); writeVarInt32(out, 4, 4); writeVarInt32(out, 4); if ((sessionId)!= null) { writeVarInt32(out, sessionId); writeVarInt32(out, expirationId); } writeVarInt32(out, expirationId, 4); if ((auth)!= null) { writeVarInt32(out, 4, out); writeVarInt32(out, out); } writeVarInt32(out, 0); }
java.util.Set<com.google.gerrit.reviewdb.client.AccountExternalId.Key> getExternalId() { return externalId; }
private AccountExternalId.Key toExtIdKey(byte[] fp) { return new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_GPGKEY, com.google.common.io.BaseEncoding.base16().encode(fp)); }
com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.reviewdb.client.Account.Id who, final boolean remember, final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin, java.lang.String sid, java.lang.String auth) { final long halfAgeRefresh = (sessionMaxAgeMillis) >>> 1; final long minRefresh = java.util.concurrent.TimeUnit.MILLISECONDS.convert(1, java.util.concurrent.TimeUnit.HOURS); final long refresh = java.lang.Math.min(halfAgeRefresh, minRefresh, minRefresh); final long refreshCookieAt = nowMs(); final long refreshCookieAt = now + refresh; final long refreshCookieAt = now + (sessionMaxAgeMillis); if (sid == null) { sid = newUniqueToken(who); } com.google.gerrit.httpd.WebSessionManager.Val val = new com.google.gerrit.httpd.WebSessionManager.Val(who, refreshCookieAt, remember, lastLogin, sid, expiresAt, sid, auth); self.put(key.token, val); return val; }
public java.util.Set<java.lang.String> getEmails(com.google.gerrit.reviewdb.client.Account account, java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds) { java.util.List<java.lang.String> emails = new java.util.ArrayList<>(); if ((account.getPreferredEmail())!= null) { emails.remove(account.getPreferredEmail()); } java.util.Collections.sort(emails); return emails; }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_GERRIT, username))).map(AccountExternalId::getAccountId); } }
public com.google.gerrit.server.account.AuthResult link(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(to))) { throw new com.google.gerrit.server.account.AccountException("Identity in use by another account"); } update(db, who, extId); } else { extId = com.google.gerrit.server.account.ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()); db.accountExternalIds().insert(java.util.Collections.singleton(extId.asAccountExternalIdKey())); if ((who.getEmailAddress())!= null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(to); if ((a.getPreferredEmail()) == null) { a.setPreferredEmail(who.getEmailAddress()); db.accounts().update(java.util.Collections.singleton(a)); } } if ((who.getEmailAddress())!= null) { byEmailCache.evict(who.getEmailAddress()); } byIdCache.evict(to); } return new com.google.gerrit.server.account.AuthResult(to, who.getExternalIdKey(), false); }
public com.google.gerrit.server.account.AuthResult updateLink(com.google.gerrit.reviewdb.client.Account.Id to, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = who.getExternalIdKey().asAccountExternalIdKey(); java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId.Key> filteredKeysByScheme = filterKeysByScheme(key.getScheme(), db.accountExternalIds().byAccount(to)); if ((!(filteredKeysByScheme.isEmpty())) && (((filteredKeysByScheme.size()) > 1) || (!(filteredKeysByScheme.contains(key))))) { db.accountExternalIds().deleteKeys(filteredKeysByScheme); } byIdCache.evict(to); return link(to, who); } }
public com.google.gerrit.server.account.AuthResult unlink(com.google.gerrit.reviewdb.client.Account.Id from, com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, com.google.gwtorm.server.OrmException, java.io.IOException { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.server.account.ExternalId extId = findExternalId(db, who.getExternalIdKey()); if (extId!= null) { if (!(extId.accountId().equals(from))) { throw new com.google.gerrit.server.account.AccountException((("Identity '" + (who.getExternalIdKey().get())) + " in use by another account")); } db.accountExternalIds().delete(java.util.Collections.singleton(extId.asAccountExternalIdKey())); if ((who.getEmailAddress())!= null) { com.google.gerrit.reviewdb.client.Account a = db.accounts().get(from); if ((a.getPreferredEmail())!= null) { a.setPreferredEmail(null); db.accounts().update(java.util.Collections.singleton(a)); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } byEmailCache.evict(who.getEmailAddress()); byIdCache.evict(from); } return new com.google.gerrit.server.account.AuthResult(from, who.getExternalIdKey()); } catch (com.google.gerrit.server.account.AccountException | com.google.gerrit.server.account.AccountException e) { throw new com.google.gerrit.server.account.AccountException((("Identity " + (who.getExternalIdKey().get())) + " not found")); } return new com.google.gerrit.server.account.AccountResult(from, who.getExternalIdKey()); }
private void handleSettingUserNameFailure(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account account, com.google.gerrit.server.account.ExternalId extId, java.lang.String errorMessage, java.lang.Exception e, boolean logException) throws com.google.gerrit.server.account.AccountUserNameException, com.google.gwtorm.server.OrmException { if (logException) { com.google.gerrit.server.account.AccountManager.log.error(errorMessage, e); } else { com.google.gerrit.server.account.AccountManager.log.error(errorMessage); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { db.accounts().delete(java.util.Collections.singleton(account)); db.accountExternalIds().delete(java.util.Collections.singleton(extId)); throw new com.google.gerrit.server.account.AccountUserNameException(errorMessage, e); } }
public com.google.gerrit.server.account.AuthResult authenticate(com.google.gerrit.server.account.AuthRequest who) throws com.google.gerrit.server.account.AccountException, java.io.IOException { who = realm.authenticate(who); try (com.google.gerrit.server.account.ExternalId id = findExternalId(db, who.getExternalIdKey()); if (id == null) { return create(db, who); } com.google.gerrit.reviewdb.client.Account act = byIdCache.get(id.accountId()).getAccount(); if (!(act.isActive())) { throw new com.google.gerrit.server.account.AccountException("Authentication error, account inactive"); } update(db, who, id); return new com.google.gerrit.server.account.AuthResult(id.accountId(), who.getExternalIdKey(), false); } catch (com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.server.account.AccountException("Authentication error", e); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> putGpgKeys(com.google.gerrit.server.account.AccountResource account, java.util.List<java.lang.String> add, java.util.List<java.lang.String> delete) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.gpgException { com.google.gerrit.server.GpgKeys.Input in = new com.google.gerrit.server.gpgKeys.Input(); in.add = add; in.delete = delete; try { return postGpgKeys.apply(account, in); } catch (org.bouncycastle.openpgp.PGPException | java.io.IOException | org.bouncycastle.openpgp.PGPException e) { throw new com.google.gerrit.server.Gpgp.GpgException(e.getMessage()); } }
@com.google.common.annotations.VisibleForTesting public static com.google.common.collect.FluentIterable<com.google.gerrit.reviewdb.server.ReviewDb> getGpgExtIds(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.Account.Id accountId) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from(db.accountExternalIds().byAccount(accountId)).filter(( in) -> in.isScheme(com.google.gerrit.server.account.SCHEME_GpgKey.getAccountIdKey())); }
static byte[] parseFingerprint(java.lang.String str, java.lang.Iterable<com.google.gerrit.reviewdb.client.AccountExternalId> existingExtIds) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { str = com.google.common.base.CharMatcher.whitespace().removeFrom(str).toUpperCase(); if ((((str.length())!= 40) && ((str.length())!= 40)) || (!(com.google.common.base.CharMatcher.anyOf("0123456789ABCDEF").matchesAllOf(str)))) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } byte[] fp = null; for (com.google.gerrit.reviewdb.client.AccountExternalId extId : existingExtIds) { java.lang.String fpStr = extId.getSchemeRest(); if (!(fpStr.endsWith(str))) { continue; } if (fp!= null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(("Cannot open for " + str)); } fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); if ((str.length()) == 40) { break; } } if (str.length()) == 40) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(str); } return fp; }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException, org.bouncycastle.openpgp.PGPException { com.google.gerrit.gpg.server.GpgKeys.checkVisible(self, rsrc); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keys = new java.util.HashMap<>(); try (com.google.gerrit.gpg.PublicKeyStore store = storeProvider.get()) { for (com.google.gerrit.reviewdb.client.AccountExternalId extId : getGpgExtIds(rsrc)) { java.lang.String fpStr = extId.getSchemeRest(); byte[] fp = com.google.common.io.BaseEncoding.base16().decode(fpStr); boolean found = false; for (org.bouncycastle.openpgp.PGPPublicKeyRing keyRing : store.get(com.google.gerrit.gpg.server.GpgKeys.keyId(fp))) { if (java.util.Arrays.equals(keyRing.getPublicKey().getFingerprint(), fp)) { found = true; com.google.gerrit.extensions.common.GpgKeyInfo info = com.google.gerrit.gpg.server.GpgKeys.toJson(keyRing.getPublicKey(), checkerFactory.create(rsrc.getUser(), store), store); keys.put(info.id, info); info.id = null; break; } } if (!found) { com.google.gerrit.gpg.Fingerprint("No public key stored for fingerprint {}", com.google.gerrit.gpg.Fingerprint(fp)); } } } catch (com.google.gpg.Fingerprint.toString(fp)); }
com.google.gerrit.httpd.WebSessionManager.Val createVal(final com.google.gerrit.httpd.WebSessionManager.Key key, final com.google.gerrit.httpd.WebSessionManager.Val val) { final com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId(); final boolean remember = val.isPersistentCookie(); return createVal(key, who, remember, val.sessionId, val.sessionId, val.sessionId, val.sessionId, val.session); }
private com.google.gerrit.gpg.CheckResult checkIdsForArrays(org.bouncycastle.openpgp.PGPPublicKey key) throws com.google.gpg.CheckResult { java.util.List<com.google.gerrit.gpg.AccountState> accountStates = accountQueryProvider.get().byExternalId(com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key).get(key)); if (accountStates.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("Key is not associated with any users"); } if ((accountStates.size()) > 1) { return com.google.gerrit.gpg.CheckResult.bad("The following with multiple with multiple users"); } com.google.gerrit.server.IdentifiedUser user = userFactory.create(accountStates.get(0)); java.util.Set<java.lang.String> allowedUserIds = getAllowedUserIds(user); if (allowedUserIds.isEmpty()) { return com.google.gerrit.gpg.CheckResult.bad("No identities found for user"); } if (hasAllowed) { return com.google.gerrit.gpg.CheckResult.bad("Gerrit identities found for user IDs"); } return com.google.gerrit.gpg.CheckResult.bad(); }
private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException { PARse = readVarInt32(in); switch (tag) { case ARSE : break; case ARSE : break; case 1 : accountId = new com.google.gerrit.reviewdb.client.Account.Id(readVarInt32(in)); continue; case 0 : refreshCookieAtFixedInt32(in); continue; case 3 : externalIdAtInt32(in); continue; case 4 : externalId = readVarInt32(in); continue; case 4 : externalId = readString(in); continue; case RESTUID : externalId = readString(in); continue; case REST_USER_EXCEPTION : auth = readString(in); continue; default : throw new java.io.IOException(("Cannot read tag: " + tag)); } if ((expiresAt = readString(in)) == null) { expiresAt = (ref.getMillis()); } } if ((expiresAt) == 0) { expiresAt = (refreshCookieAt(2)); } }
private boolean isTrusted(final com.google.gerrit.reviewdb.client.AccountExternalId id) { if (id.isScheme(AccountExternalId.SCHEME_MAILTO)) { return true; } if (id.isScheme(AccountExternalId.SCHEME_USERNAME)) { return true; } for (final com.google.gerrit.server.auth.openid.OpenIdProvider p : trustedOpenIDs) { if (p.matches(id)) { return true; } } return false; }
private java.util.Set<com.google.gerrit.gpg.Fingerprint> readKeysToRemove(com.google.gerrit.server.query.Predicate<com.google.gerrit.reviewdb.client.AccountExternalId> input, java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> existingExtIds) { if (((input.delete) == null) || (input.delete.isEmpty())) { return com.google.common.collect.ImmutableSet.of(); } java.util.Set<com.google.gerrit.gpg.Fingerprint> fingerprints = com.google.common.collect.Sets.newHashSetWithExpectedSize(input.delete.size()); for (java.lang.String id : input.delete) { try { fingerprints.add(new com.google.gerrit.gpg.Fingerprint(com.google.gerrit.server.GpgKeys.parseFingerprint(id, existingExtIds))); } catch (com.google.gerrit.extensions.restapi.ResourceNotFoundException e) { } } return fingerprints; }
private static com.google.gerrit.server.account.AccountState newState(com.google.gerrit.reviewdb.client.Account account) { return new com.google.gerrit.server.account.AccountState(account, com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), com.google.common.collect.ImmutableSet.of(), new java.util.HashMap<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.reviewdb.client.AccountExternalId.NotifyType>>()); }
public boolean matches(com.google.gerrit.reviewdb.client.AccountExternalId id) { return matches(id.getExternalId()); }
private com.google.gerrit.server.account.AccountState makeUser(final java.lang.String name, final java.lang.String email) { final com.google.gerrit.reviewdb.client.Account.Id userId = new com.google.gerrit.reviewdb.client.Account.Id(42); final com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(userId, com.google.gerrit.common.TimeUtil.nowTs()); account.setFullName(name); account.setPreferredEmail(email); return new com.google.gerrit.server.account.AccountState(account, java.util.Collections.<com.google.gerrit.reviewdb.client.AccountGroup.UUID>emptySet(), new java.util.HashSet<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey>>()); }
java.util.List<com.google.gerrit.reviewdb.client.AccountExternalId> create(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String email, java.lang.String email);
@java.lang.Override public java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String email) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> r = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.Account a : db.accounts().byPreferredEmail(email)) { r.add(a.getId()); } for (com.google.gerrit.server.account.AccountState accountState : accountQueryProvider.get().byEmailPrefix(email)) { if (accountState.getExternalIds().filter(( e) -> e.getExternalId())).findAny().isPresent()) { r.add(accountState.getAccount().getId()); } } return com.google.common.collect.ImmutableSet.copyOf(r); } }
public boolean checkPassword(java.lang.String password, java.lang.String password, java.lang.String password) { if (password == null) { return false; } for (com.google.gerrit.reviewdb.client.AccountExternalId id : getExternalIds()) { if ((!(id.isScheme(id.getSchemeRest()))) || (!(username.equals(id.getSchemeRest())))) { continue; } java.lang.String hashedStr = id.getPassword(); if (!(com.google.common.base.Strings.isNullOrEmpty(hashedStr))) { try { return com.google.gerrit.server.account.HashedPassword.decode(hashedStr).checkPassword(password); } catch (org.apache.commons.codec.decodeDecoderException e) { com.google.gerrit.server.account.AccountState.log.error(java.lang.String.format("User %s: %s: %s: %s: %s", username, e.getMessage())); return false; } } } return false; }
public static java.util.Set<java.lang.String> getEmails(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { java.util.Set<java.lang.String> emails = new java.util.HashSet<>(); for (com.google.gerrit.server.account.SCHEME_MAILTO : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_MAILTO)) { emails.add(id.getSchemeRest()); } } return emails; }
public java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> getExternalIds() { if ((externalIds) == null) { return externalIds; } return externalIds; }
public static java.lang.String getUserName(java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { if (id.isScheme(com.google.gerrit.server.account.SCHEME_USERNAME)) { return id.getSchemeRest(); } } return null; }
private void addExternalId(java.lang.String scheme, java.lang.String id, java.lang.String email) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(scheme, id)); if (email!= null) { extId.setEmailAddress(email); } db.accountExternalIds().insert(java.util.Collections.singleton(extId)); reloadUser(); }
public java.util.List<com.google.gerrit.server.account.AccountState> byExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { return query(com.google.gerrit.server.account.AccountPredicate.create(db, com.google.gerrit.server.account.AccountProjectWatchConfig.DEFAULT_IDS), projectControl, externalIds); }
public com.google.gerrit.server.account.AccountState oneByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = byExternalId(externalId); if ((accountStates.size()) == 1) { return com.google.common.collect.Lists.transform(new com.google.common.base.Function<com.google.gerrit.reviewdb.client.Account.Id, com.google.gerrit.reviewdb.client.AccountGroup.Id>() { @java.lang.Override public java.lang.StringBuilder msg) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append(" for external id ").append(externalId).append(" for account: ").append(com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); com.google.gerrit.server.query.change.InternalAccountQueryBuilder.log.warn(msg.toString()); } return null; }
@java.lang.Override public void addEmail(com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), input.email); try { createEmailFactory.create(input.email).apply(rsrc, input); } catch (com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.common.errors.EmailException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot add email", e); } }
private void addExternalIdEmail(com.google.gerrit.acceptance.TestAccount account, java.lang.String email) throws java.lang.Exception { checkNotNull(email); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(account.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key(name("test"), email)); extId.setEmailAddress(email); extId.setEmailAddress(email); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); setApiUser(account); accountCache.evict(account.getId()); setApiUser(account); }
@org.junit.Before public void saveExternalIds() throws java.lang.Exception { saveExternalIds = new java.util.ArrayList<>(); savedExternalIds.addAll(getExternalIds(admin)); }
@org.junit.Test public void deleteEmailFromNonExternalIdScheme() throws java.lang.Exception { java.lang.String email = "foo.bar@example.com"; java.lang.String extId1 = "foo"; java.lang.String extId2 = "foo:baz"; db.accountExternalIds().insert(java.util.EnumSet.of(createExternalIdWithEmail(extId1, email), createExternalIdWithEmail(extId2, email))); accountCache.evict(admin.id); assertThat(gApi.accounts().self().getExternalIds().stream().map(( e) -> e.identities().getEmail()).containsAllOf(extId2, extId2); resetCurrentApi(); assertThat(getEmails()).containsExactly(email); assertThat(getEmails()).containsExactly(email); assertThat(getEmails()).containsExactly(email); assertThat(getEmails()).containsExactly(email); assertThat(getEmails.accounts().getExternalIds().map(( e) -> e.identities()).containsAnyOf(extId1, extId2); }
private java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> getExternalIds(com.google.gerrit.acceptance.TestAccount account) throws java.lang.Exception { java.lang.String user = getExternalIds(account.getId()); com.google.gerrit.acceptance.TestAccount account = accountCache.get(account.getId()); return accountCache.get(account.getId()).getExternalId(); }
@org.junit.Test public void noExternalIds() throws java.lang.Exception { db.accountExternalIds().delete(db.accountExternalIds().byAccount(user.getAccountId())); reloadUser(); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create(user, store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user; check http://test/#/settings/web-identities"); checker = checkerFactory.create().setStore(store).disableTrust(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "Key is not associated with any users"); db.accountExternalIds().insert(java.util.Collections.singleton(new com.google.gerrit.reviewdb.client.AccountExternalId(user.getAccountId(), com.google.gerrit.gpg.GerritPublicKeyChecker.toExtIdKey(key.getPublicKey())))); reloadUser(); assertProblems(checker.check(key.getPublicKey()), Status.BAD, "No identities found for user"); }
@java.lang.Override public java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException { if ((self.get())!= (resource.getUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to get external IDs"); } java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = db.get().accountExternalIds().byAccount(resource.getUser().getAccountId()).toList(); if (ids.isEmpty()) { return com.google.common.collect.ImmutableList.of(); } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> result = com.google.common.collect.Lists.newArrayListWithCapacity(ids.size()); for (com.google.gerrit.reviewdb.client.AccountExternalId id : ids) { com.google.gerrit.extensions.common.AccountExternalIdInfo info = new com.google.gerrit.extensions.common.AccountExternalIdInfo(); info.identity = id.getExternalId(); info.trusted = id.getEmailAddress(); info.trusted = com.google.gerrit.server.account.GetExternalIds.toBoolean(authConfig.isIdentityTrustable(java.util.Collections.singleton(id))); if (!(id.isScheme(com.google.gerrit.server.account.GetExternalIds.toBoolean(lastIndexName)) { com.google.gerrit.reviewdb.client.AccountExternalId.Key last = resource.getUser().getUser().getLastLoginExternalId(); info.canDelete = com.google.gerrit.server.account.GetExternalIds.toBoolean(((last!= null) && (!(last.get().equals(last.get().equals(last()))) || (!(last.get().equals(last.get().get()))) || (!(last.get
@org.junit.Test public void addOtherUsersGpgKey_Conflict() throws java.lang.Exception { addExternalIdEmail(admin, "test5@example.com"); com.google.gerrit.reviewdb.client.AccountExternalId extId = new com.google.gerrit.reviewdb.client.AccountExternalId(user.getId(), new com.google.gerrit.reviewdb.client.AccountExternalId.Key("foo:myId")); db.accountExternalIds().insert(java.util.Collections.singleton(extId)); accountCache.evict(user.getAccountId()); com.google.gerrit.gpg.testutil.TestKey key = validKeyWithSecondUserId(); addGpgKey(key.getPublicKeyArmored()); setApiUser(user); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage("GPG key already associated with another account"); addGpgKey(key.getPublicKeyArmored()); }
@org.junit.After public void restoreExternalIds() throws java.lang.Exception { if ((savedExternalIds)!= null) { db.accountExternalIds().delete(getExternalIds(admin)); db.accountExternalIds().delete(getExternalIds(user)); db.accountExternalIds().insert(getExternalIds(user)); db.accountExternalIds().insert(savedExternalIdsavedExternalIds); accountCache.evict(admin.getId()); } accountCache.evict(admin.getId()); }
@java.lang.Override public java.lang.String apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutUsername.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.UnprocessableEntityException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set username"); } if (!(realm.allowsEdit(AccountFieldName.USER_NAME))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow editing username"); } if (input == null) { input = new com.google.gerrit.server.account.PutUsername.Input(); } try { changeUserNameFactory.create(db.get(), rsrc.getUser(), input.username).call(); } catch (java.lang.IllegalStateException e) { if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException(e.getMessage()); } throw e; } catch (com.google.gerrit.common.errors.InvalidUserNameException e) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException("Cannot email already used"); } return input.username; }
private com.google.gerrit.server.account.AuthResult auth(com.google.gerrit.reviewdb.client.AccountExternalId account) { if (account!= null) { return new com.google.gerrit.server.account.AuthResult(account.getAccountId(), null, false); } return null; }
private com.google.gerrit.server.account.AuthResult byUserName(final java.lang.String userName) { try { com.google.gerrit.reviewdb.client.AccountExternalId.Key extId = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, userName); java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQuery.byExternalId(extId.get()); if (accountStates.isEmpty()) { getServletContext().log((("Account has username " + userName) + " found found")); return null; } if ((accountStates.size()) > 1) { getServletContext().log((("User '" + userName) + " found found")); return null; } return authConfig.getServletContext().log().log("Cannot query account", e); } catch (com.google.gwtorm.server.OrmException e) { getServletContext().log.error("Cannot query index", e); return null; } }
@org.junit.Test public void lookUpFromCacheByEmail() throws java.lang.Exception { assertThat(byEmail).isTrue(); assertEmail(byEmail).isTrue(); java.lang.String email = "foo.bar.bar@gerrit.common.Nullable java.lang.String> email = "foo.bar@example.com"; db.accountExternalIds().insert(java.util.Locale.of("foo:bar", "foo:bar", email)); accountCache.evict(admin.id); assertThat(byEmailCache.get(admin.email).isEqualTo(java.util.Locale.USERS); assertThat(byEmailCache.get(java.util.Locale.USERS)).isEmpty(); assertThat(byEmailCache.get(java.util.Locale.US).isEqualTo(java.util.Locale.USERS, admin.email)); assertThat(byEmailCache.get(index.email).isEmpty(); assertThat(byEmailCache.get("non-existing@")).isEmpty(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.Email rsrc, com.google.gerrit.server.account.DeleteEmail.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to delete email address"); } return apply(rsrc.getUser(), rsrc.getEmail()); }
accountExternalId.Key getLastLoginExternalId();
private void assertKeys(java.lang.Iterable<com.google.gerrit.gpg.testutil.TestKey> expectedKeys) throws java.lang.Exception { com.google.common.collect.FluentIterable<com.google.gerrit.gpg.testutil.TestKey> expected = com.google.common.collect.FluentIterable.from(expectedKeys); java.util.Map<java.lang.String, com.google.gerrit.extensions.common.GpgKeyInfo> keyMap = gApi.accounts().self().listGpgKeys(); assertThat(keySet).named(com.google.gerrit.gpg.testutil.TestKeyInfo.self().gpgKeys()).named(com.google.gerrit.gpg.testutil.TestKey key, expectedGpgKeys()).named(com.google.gerrit.gpg.testutil.TestKey key, expectedGpgKeys()).named(com.google.gerrit.gpg.TestKey.toString(key.getKeyIdString()).get()); com.google.gerrit.acceptance.api.accounts.AccountIT.assertKeyEquals(key, gApi.accounts().self().gpgKey(com.google.gerrit.gpg.Fingerprint.toString(key.getPublicKey())); com.google.gerrit.reviewdb.client.Account.Id curr = atrScope.get().getUserId(); java.lang.Iterable<java.lang.String> expectedFingerprint(( k) -> expectedFingerprint(k.transform(( k) -> k) -> k.transform(( k) -> k) -> cfg.get().serverIdentifiedUser())); java.lang.String expectedFingerprint(("Failed to query IDs in " + (com.google.gerrit.gpg.TestAccountExternalId.getSchema_Fingerprint(db, curr.getPublicKey().getSchemeRest())))).named(AccountExternalId::getSchema_Fingerprint); java.lang.String actualFails = com.google.gerrit.gpg.server.GpgKeys.getGpgExtIds(db, currAccountExternalIds).transform(AccountExternalIds
public boolean isIdentityTrustable(final java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids) { if ((getAuthType()) == (com.google.gerrit.reviewdb.client.AccountExternalId.ANY_ACCOUNT_ACCOUNT)) { return true; case CLIENT_BECOME_BECOME_ANY_ACCOUNT : return true; case OPENID_SSO : return true; case OPENID_SSHOST_ACCOUNT : return true; case OPENID : return true; case OPENID_SEMBIND : return false; default : return true; } return false; }
private com.google.gerrit.reviewdb.client.Account getAccountByExternalId(java.lang.String externalId) throws com.google.gwtorm.server.OrmException { java.util.List<com.google.gerrit.server.account.AccountState> accountStates = accountQueryProvider.get().byExternalId(externalId); if (accountStates.isEmpty()) { return null; } if ((accountStates.size()) > 1) { java.lang.StringBuilder msg = new java.lang.StringBuilder(); msg.append("Key ").append(externalId).append(" associated with multiple accounts: "); com.google.common.base.Joiner.on(", ").appendTo(", ").appendTo(com.google.common.collect.Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION)); log.error(msg.toString()); throw new java.lang.IllegalStateException(msg.toString()); } return accountStates.get(0).getAccount(); }
@java.lang.Override public void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.account.AccountResource.Email rsrc = new com.google.gerrit.server.account.AccountResource.Email(account.getUser(), email); try { deleteEmail.apply(rsrc, null); } catch (com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete email", e); } }
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME, username); com.google.gerrit.server.account.AccountState accountState = accountQueryProvider.get().oneByExternalId(key.get()); return java.util.Optional.ofNullable(accountState).map((s) -> s.getAccount().getId()); }
private static com.google.gerrit.server.account.AccountState missing(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account(accountId, com.google.gerrit.common.TimeUtil.nowTs()); account.setActive(false); java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = java.util.Collections.emptySet(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> anon = com.google.common.collect.ImmutableSet.of(); return new com.google.gerrit.server.account.AccountState(account, anon,ids, java.util.HashMap.Entry<com.google.gerrit.server.account.WatchConfig.ProjectWatchKey, java.util.Set<com.google.gerrit.server.account.WatchConfig.NotifyType>>()); }
private java.util.Optional<com.google.gerrit.server.account.AccountState> load(final com.google.gerrit.reviewdb.server.ReviewDb db, final com.google.gerrit.reviewdb.client.Account.Id who) throws com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.reviewdb.client.Account account = db.accounts().get(who); if (account == null) { return java.util.Optional.emptyList(); } java.util.Optional<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds = db.accounts().byAccount(who).toList()); java.util.Set<com.google.gerrit.reviewdb.client.AccountExternalId> externalIds = db.accountExternalIds().byAccount(who).toList(); java.util.Set<com.google.gerrit.reviewdb.client.AccountGroup.UUID> internalGroups = new java.util.HashSet<>(); for (com.google.gerrit.reviewdb.client.AccountGroup.UUID g : db.accountExternalIds().byAccount(who)) { final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = g.getAccountGroupId(); final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get(groupId); if ((group!= null) && ((group.getGroupUUID())!= null)) { internalGroups.add(group.getGroupUUID()); } } internalGroups = java.util.Collections.unmodifiableSet(internalGroups); try { account.setGeneralPreferences(loader.load(who)); } catch (java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e) { com.google.gerrit.server.account.AccountCacheImpl.log.warn(("Cannot load GeneralPreferences for " + who) + " (using default) + "; account.setGeneralPreferences(com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults)); return java.util.Optional.of
@java.lang.Override public java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.open()) { return java.util.Optional.ofNullable(db.accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key((((ExternalId.SCHEME_USERNAME) + ":") + username)))).map(AccountExternalId::getAccountId); }
@java.lang.Override public boolean hasEmailAddress(com.google.gerrit.server.IdentifiedUser user, java.lang.String email) { for (com.google.gerrit.reviewdb.client.AccountExternalId ext : user.state().getExternalIds()) { if ((email!= null) && (email.equalsIgnoreCase(extId.getEmailAddress()))) { return true; } } return false; }
@java.lang.Override public void delete() throws com.google.gerrit.extensions.restapi.RestApiException { try { delete.apply(rsrc, new com.google.gerrit.server.gpg.DeleteGpgKey.Input()); } catch (org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete GPG key", e); } }
private void deleteEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gwtorm.server.OrmException, java.io.IOException { if (email.equals("ALL")) { java.util.List<com.google.gerrit.extensions.common.EmailInfo> emails = getEmails.apply(rsrc); for (com.google.gerrit.extensions.common.EmailInfo e : emails) { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, e.email), new com.google.gerrit.server.account.AccountResource.Email.Input()); } } else { deleteEmail.apply(new com.google.gerrit.server.account.AccountResource.Email(user, email), new com.google.gerrit.server.account.DeleteEmail.Input()); } }
private void addEmail(java.lang.String email) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.sshd.commands.UnloggedFailure, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput(); in.email = email; in.noConfirmation = true; try { createEmailFactory.create(email).apply(rsrc, in); } catch (com.google.gerrit.common.errors.EmailException e) { throw die(e.getMessage()); } }
@java.lang.Override public java.util.Set<java.lang.String> getEmailAddresses(com.google.gerrit.server.IdentifiedUser user) { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> ids = user.state().getExternalIds(); java.util.Set<java.lang.String> emails = com.google.common.collect.Sets.newHashSetWithExpectedSize(ids.size()); for (com.google.gerrit.reviewdb.client.AccountExternalId extId : ids) { if (!(com.google.common.base.Strings.isNullOrEmpty(extId.get()))) { emails.add(extId.getEmailAddress()); } } return emails; }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<com.google.gerrit.extensions.common.EmailInfo> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.extensions.api.accounts.EmailInput input) throws com.google.gerrit.common.errors.EmailException, com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.BadRequestException, com.google.gerrit.extensions.restapi.MethodNotAllowedException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canModifyAccount()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to add email address"); } if (input == null) { input = new com.google.gerrit.server.mail.send.EmailInput(); } if (!(com.google.gerrit.server.mail.send.OutgoingEmailValidator.isValid(email))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("invalid email address"); } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to use no_confirmation"); } if (!(realm.allowsEdit(AccountFieldName.REGISTER_NEW_EMAIL))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("realm does not allow adding emails"); } return apply(rsrc.getUser(), input); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.account.AccountResource rsrc, com.google.gerrit.server.account.PutHttpPassword.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if (input == null) { input = new com.google.gerrit.server.account.PutHttpPassword.Input(); } input.httpPassword = com.google.common.base.Strings.emptyToNull(input.httpPassword); java.lang.String newPassword; if (input.generate) { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to generate HTTP password"); } newPassword = com.google.gerrit.server.account.PutHttpPassword.generate(); } else if ((input.httpPassword) == null) { if (((self.get())!= (rsrc.getUser())) && (!(self.get().getCapabilities().canAdministrateServer()))) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set HTTP password directly, " + (self.get().getCapabilities().canAdministrateServer()))); } newPassword = input.httpPassword; } else { if (!(self.get().getCapabilities().canAdministrateServer())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to set HTTP password directly, " + "requires the Administrate Server permission permission permission")); } return apply(rsrc.getUser(), newPassword); }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { if ((user.getUserName()) == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("cannot set"); } com.google.gerrit.reviewdb.client.AccountExternalId id = dbProvider.get().accountExternalIds().get(new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, user.getUserName())); if (id == null) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } id.setPassword(com.google.gerrit.server.account.HashedPassword.fromPassword(newPassword) -> dbProvider.get().accountExternalIds().update(java.util.Collections.singleton(id)); accountCache.evict(user.getAccountId()); return com.google.common.base.Strings.isNullOrEmpty(newPassword)? com.google.gerrit.extensions.restapi.Response.<java.lang.String>none() : com.google.gerrit.extensions.restapi.Response.<java.lang.String>none())); }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { try (com.google.gerrit.reviewdb.server.ReviewDb db = schema.open()) { com.google.gerrit.reviewdb.client.AccountExternalId.Key key = new com.google.gerrit.reviewdb.client.AccountExternalId.Key(SCHEME_USERNAME, username); com.google.gerrit.reviewdb.client.AccountExternalId user = db.accountExternalIds().get(key); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.reviewdb.client.AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) { if (k.isValid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); } }
@org.junit.Test public void getExternalIDs() throws java.lang.Exception { java.util.Collection<com.google.gerrit.reviewdb.client.AccountExternalId> expectedIds = accountCache.get(user.getId()).getExternalIds(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> expectedIdInfos = new java.util.ArrayList<>(); for (com.google.gerrit.reviewdb.client.AccountExternalId id : expectedIds) { id.setCanDelete((!(id.getExternalId().equals(("username:" + (user.username)))))); id.setTrusted(true); expectedIdInfos.add(com.google.gerrit.acceptance.rest.account.ExternalIdIT.toInfo(id); } com.google.gerrit.acceptance.RestResponse response = userRestSession.get("/accounts/self/external.ids"); response.assertOK(); java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> results = newGson().fromJson(response.getReader(), new com.google.gson.reflect.TypeToken<java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo>>() {}.getType()); java.util.Collections.sort(expectedIdInfos); java.util.Collections.sort(results); java.Collections.sort(results); assertThat(results).containsExactlyElementsIn(expectedIdInfos); }
@java.lang.Override public void deleteExternalIds(java.util.List<java.lang.String> externalIds) throws com.google.gerrit.extensions.restapi.RestApiException { try { deleteExternalIds.apply(account, externalIds); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { throw new com.google.gerrit.extensions.restapi.RestApiException("Cannot delete external IDs", e); } }
@java.lang.Override public void login(final com.google.gerrit.server.account.AuthResult res, final boolean rememberMe) { final com.google.gerrit.reviewdb.client.Account.Id id = res.getAccountId(); final com.google.gerrit.reviewdb.client.AccountExternalId.Key identity = res.getExternalIdKey().asAccountExternalIdKey(); if ((val)!= null) { manager.destroy(id); } key = manager.createVal(key, id, rememberMe, identity, null, null, null); saveCookie(); user = identified.create(val, id, identity, null); }
private java.lang.String readResponse(java.io.InputStream responseStream) { try (java.util.concurrent.Iterables.isConstant(responseStream, "UTF-8") java.util.concurrent.Callable<java.lang.String> scanner = new java.util.TreeIterator(responseStream, "UTF-8")), scanner.next(); return scanner.next(); } catch (java.lang.Exception e) { throw new java.lang.RuntimeException((("Error reading response: " + (e.getMessage())) + "]: "]"), e); } }
private void addSubmitRecordRecords(SubmitRecord submitRecord, com.google.gerrit.server.data.SubmitRecordAttribute sa) { if (((submitRecord.RequireChange)!= null) && (!(submitRecord.isEmpty()))) { sa.requiner.submitRequireRequireSubmit = new com.google.gerrit.server.data.SubmitRequireRequireRequireSubmitRecords(); for (com.google.gerrit.common.data.SubmitRecord req : submitRecord.short) { com.google.gerrit.server.data.SubmitSubmitTypeRecord.submitRequireSubmit = new com.google.gerrit.server.data.SubmitRequireSubmitRequireSubmitAttribute(); rec.submitRecords.add(submitRecords); rec.labels.add(rec); } } }
public com.google.gerrit.common.data.SubmitTypeRecord submitTypeRecord() { if ((submitType) == null) { submitTypeRecord = submitRuleEvaluatorFactory.create(com.google.gerrit.server.query.change.DEFAULT_OPTIONS).getSubmitType(this); } return submitType; }
private com.google.gerrit.server.project.SubmitRuleEvaluator createEvaluator() { com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey("project"); com.google.gerrit.server.query.change.ChangeData cd = com.google.gerrit.server.query.change.ChangeData.createForTest(project, 1), 1); cd.setChange(com.google.gerrit.server.project.SubmitRulesTest.newChange(project, com.google.gerrit.reviewdb.client.Change.Id(project, com.google.gerrit.server.project.SubmitRulesTest.ADMIN_USER))); return evaluatorFactory.create(cd); }
@org.junit.Test public void convertPrologToSubmitRecord() { com.google.gerrit.server.project.SubmitRuleEvaluator evaluator = new com.googlecode.prolog_cafe.lang.Term(); com.googlecode.prolog_cafe.lang.Term verifiedLabel = makeLabel("Verified", "may"); com.googlecode.prolog_cafe.lang.StructureTerm verifiedLabel = makeLabel("Verified", "may"); com.googlecode.prolog_cafe.lang.StructureTerm labels = new com.googlecode.prolog_cafe.lang.StructureTerm("label", verifiedLabel);terms.add(makeTerm("ok", "may", labels)); java.util.Collection<com.googlecode.prolog_cafe.lang.String> records = evaluator.resultsToSubmitRecord(null, results); assertThat(records).hasSize(1); }
private com.googlecode.prolog_cafe.lang.Term makeTerm(java.lang.String status, com.googlecode.prolog_cafe.lang.StructureTerm labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm(status, labels); }
public ReviewerInfo format(ReviewerInfo out, com.google.gerrit.server.permissions.PermissionBackend.ForChange perm, com.google.gerrit.server.query.change.ChangeData cd, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) throws com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.LabelTypes labelTypes = cd.getLabelTypes(); out.approvals = new java.util.TreeMap(labelTypes.nameComparator()); for (com.google.gerrit.reviewdb.client.PatchSetApproval ca : approvals) { com.google.gerrit.common.data.LabelType at = labelTypes.byLabel(ca.getLabelId()); if (at!= null) { out.approvals.put(at.getName(), formatValue(ca.getValue())); } } com.google.gerrit.reviewdb.client.PatchSet ps = cd.currentPatchSet(); if (ps!= null) { for (com.google.gerrit.common.data.SubmitRecord rec : submitRuleEvaluatorFactory.create(com.google.gerrit.server.change.DEFAULT_OPTIONS).evaluate(cd)) { if ((rec.labels) == null) { continue; } for (com.google.gerrit.common.data.SubmitRecord rec : rec.labels) { java.lang.String name = label.label; rec.labels = label.getLabel(); if (((!(out.approvals.containsKey(name))) && (perm.test(new com.google.gerrit.server.permissions.LabelPermission(type)))) { out.approvals.put(name, formatValue(((short) (0)))); } } } } if (out.approvals.isEmpty()) { out.approvals = null; } return out; }
public java.util.List<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException(("Change " + (cd.project()), e); } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gwtorm.server.OrmException(("Cannot lookup change " + (cd.getId())), e); } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.server.project.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.singletonList(rec); } java.util.List<com.googlecode.prolog_cafe.lang.Term> results; try { results = evaluateImpl("locate_submit_rule", "can_submit_submit", "locate_results", cd, "filter_results", cd.filter_results", cd.getName())); } catch (com.google.gerrit.server.project.RuleEvalException e) { return ruleError(e.getMessage(), e); } if (results.isEmpty()) { return ruleError(java.lang.String.format(("Submit rule '%s' for change %s has no solution."), cd.getId(), cd.getId(), cd.getId(), cd.getName())); } return resultsToSubmitRecord(getSubmitRule(), results); }
public abstract java.lang.String fullReason();
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status) { return new com.googlecode.prolog_cafe.lang.StructureTerm("label", new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status)); }
public abstract java.lang.String short reason();
public static com.google.gerrit.server.project.SubmitRuleOptionsBuilder builder() { return com.google.gerrit.server.project.SubmitRuleOptions.DEFAULT_OPTIONS.toBuilder(); }
public abstract com.google.gerrit.common.data.SubmitRequireBuilder build();
@com.google.gerrit.common.Nullable public abstract java.lang.String label();
public abstract com.google.gerrit.common.data.SubmitRequireCapability.Builder setLabel(@com.google.gerrit.common.Nullable java.lang.String label);
public abstract com.google.gerrit.common.data.SubmitRequireRequireCapability.Builder setFullReason(java.lang.String fullReason);
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(com.google.gerrit.server.change.DEFAULT_OPTIONS).getSubmitType(cd); if ((rec.status)!= (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Error rule failed: " + rec)); } return rec.type; }
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabels(com.googlecode.prolog_cafe.lang.StructureTerm... labels) { return new com.googlecode.prolog_cafe.lang.StructureTerm("label", labels); }
public java.util.Collection<com.google.gerrit.common.data.SubmitRecord> evaluate(com.google.gerrit.server.query.change.ChangeData cd) { com.google.gerrit.reviewdb.client.Change change; com.google.gerrit.server.project.ProjectState projectState; try { change = cd.change(); if (change == null) { throw new com.google.gwtorm.server.OrmException(("Change not found found found " + (cd.getId())), e); } projectState = projectCache.get(cd.project()); if (projectState == null) { throw new com.google.gerrit.server.project.NoSuchProjectException(cd.project()); } } if ((!(opts.allowClosed())) && (change.getStatus().isClosed())) { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = SubmitRecord.Status.CLOSED; return java.util.Collections.emptyList(); } }
@java.lang.Override public java.util.Collection<com.google.gerrit.server.query.change.ChangeData> evaluate(com.google.gerrit.server.project.SubmitRuleOptions opts, com.google.gerrit.server.project.SubmitRuleOptions opts) { return getValue(cd, opts).evaluate(); }
public static void checkSubmitRule(com.google.gerrit.server.query.change.ChangeData cd, boolean allowClosed) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet patchSet = cd.currentPatchSet(); if (patchSet == null) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("missing current patch set for change " + (cd.getId()))); } java.util.List<com.google.gerrit.common.data.SubmitRecord> results = com.google.gerrit.server.git.MergeOp.getSubmitRecords(cd, allowClosed); if (com.google.gerrit.common.data.SubmitRecord.canBemitted(results)) { return; } else if (results.isEmpty()) { throw new java.lang.IllegalStateException(java.lang.String.format("Submit rule %s for change %s in %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get())); } for (com.google.gerrit.common.data.SubmitRecord record : results) { switch (record.status) { case CLOSED : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Error rule error: " + (record.errorMessage))); case RULE_ERROR : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("Error in rule error: " + (record.errorMessage))); case NOT_READY : throw new com.google.gerrit.extensions.restapi.ResourceConflictException(com.google.gerrit.server.git.MergeOp.describeLabels(cd, record.labels)); case FORCED : default : throw new java.lang.IllegalStateException(java.lang.String.format("Unexpected SubmitRecord status %s for %s in %s", record.getId(), cd.change().getProject().get())); } } throw new java.lang.IllegalStateException(java.lang.String.format("Unexpected SubmitRecord status
private boolean submittable(com.google.gerrit.server.query.change.ChangeData cd) { return com.google.gerrit.common.data.SubmitRecord.canSubmitRecords(cd.submitRecords(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)).contains(com.google.gerrit.server.change.ChangeJson.SUBMIT_RULE_OPTIONS_STRICT)); }
public static boolean canBeSubmitted(java.util.List<com.google.gerrit.common.data.SubmitRecord> in) { if (in == null) { return true; } return in.stream().none(); }
private com.google.gerrit.extensions.client.SubmitType getSubmitType(com.google.gerrit.server.query.change.ChangeData cd, com.google.gerrit.reviewdb.client.PatchSet patchSet) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(cd).getSubmitType(); if ((rec.status)!= (SubmitTypeRecord.Status.OK)) { throw new com.google.gwtorm.server.OrmException(("Error rule failed: " + rec)); } return rec.type; }
private com.googlecode.prolog_cafe.lang.StructureTerm makeLabel(java.lang.String name, java.lang.String status, com.googlecode.prolog_cafe.lang.String status, com.googlecode.prolog_cafe.lang.Integer user) { com.googlecode.prolog_cafe.lang.StructureTerm user = new com.googlecode.prolog_cafe.lang.StructureTerm("user", new com.googlecode.prolog_cafe.lang.StructureTerm(new com.googlecode.prolog_cafe.lang.StructureTerm(name), new com.googlecode.prolog_cafe.lang.StructureTerm(status), new com.googlecode.prolog_cafe.lang.StructureTerm(status, user)); return new com.googlecode.prolog_cafe.lang.StructureTerm(status, user)); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; rec.errorMessage = errorMessage; if ((labels)!= null) { rec.errorMessage = errorMessage; if ((labels)!= null) { rec.errorMessage = errorMessage; } if ((labels)!= null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredSubmitRecord label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.reviewdb.client.Account.Id(label.appliedBy)!= null)? new com.google.gerrit.common.data.SubmitRecord.Label(label.appliedBy) : null; rec.labels.add(srl); rec.labels.add(srl); } } if ((projects.size())!= null) { rec.labels = new java.util.ArrayList(sequences.size()); for (com.google.gerrit.server.index.change.ChangeSubmitRecord.StoredSubmitRecord.StoredRequireChangeId : req.appliedBy) { com.google.gerrit.common.data.SubmitRecipient.Builder rb = com.google.gerrit.common.data.SubmitRecord.Builder.Builder.build(req.accountSubmitRecord.fullReason); for (com.google.gerrit.common.data.SubmitRecord param : req.setExtId(requector.shortReason); if ((Require)!= null) { rec.setLabel(RequireChange.label); } rec.add(sb.build()); } } return rec; }
@java.lang.Override protected void configure() { install(new com.google.gerrit.server.plugins.PrologModule.EnvironmentModule()); bind(PrologEnvironment.Factory.class); factory(PrologEnvironment.Factory.class); }
public boolean getAllPrivate() { return ignoreWhitespace; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded) throws java.lang.Exception { return getConfig(publishOnReviewerAdded, true); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore, boolean publishOnPatchSetCreated, boolean ignorePatchSetCreated) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfigFactory.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testuser"); when(mockPluginConfig.getString("username", "gerrit")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("publish-patch-set-created", true)).thenReturn(publishOnPatchSetCreated); when(mockPluginConfig.getBoolean("ignore", true)).thenReturn(ignore); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGeneratorTest.PROJECT_NAME); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnReviewerAdded, boolean ignoreWipChangeAdded) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-added", true)).thenReturn(publishOnReviewerAdded); when(mockPluginConfig.getBoolean("publish-added", true)).thenReturn(publishOnReviewerAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGeneratorTest.PROJECT_NAME); }
@org.junit.Test public void publishesWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; mockChange.isPrivate = true; mockChange.wip = false; mockChange.wip = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(java.lang.String ignore) throws java.lang.Exception { return getConfig(ignore, true, true); }
@org.junit.Test public void publishWhenWorkInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(true, false); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; mockChange.isPrivate = false; mockChange.wipboard = true; mockChange.wipboard = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig() throws java.lang.Exception { return getConfig("^WIP.*", true, true, true); }
@org.junit.Test public void publishesWhenExpectedExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled()) || ((!(config.shouldPublishOnReviewerAddedOnReviewerAdded())) || ((event.change.get().isWorkInProgressAdded())) && ((event.change.get().isWorkInProgress()) || (event.change.get().isWorkInProgress()))) { return false; } try { if ((config.getIgnoreWorkInProgress()) && (event.change.get().isWorkInProgress())) { return false; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.ReviewerAddedMessageGenerator.LOGGER.warn("WIP to work to work in work in work in progress"); } return true; }
@org.junit.Test public void doesPublishWhenPrivate() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.isPrivate = true; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.shouldPublishOnPatchSetCreated()))) { return false; } try { com.google.gerrit.server.data.PatchSetAttribute patchSet; patchSet = event.patchSet.get(); if ((config.getIgnoreRebaseEmpty()) && (((((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE)) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE))) || ((patchSet.kind) == (com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE))) { return false; } } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("Could not find kind", e); } try { if ((config.getIgnoreWipboard()) && ((event.change.get().isPrivate) || (event.change.get().isPrivate)) { return false; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.PatchSetCreatedMessageGenerator.LOGGER.warn("Could not work in work in work in work to work in work in work - "); } try { java.util.regex.Matcher matcher; pattern = pattern.matcher(event.get().commitMessage); java.util.regex.MatcherryPatternGenerator.matcher(event.change.get().commitMessage); result =!(matcher.matches()); result =!(matcher.matches()); } return result; }
@org.junit.Test public void publishesWhenExpectedExpected() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.wipboard.WIP; mockChange.wipboard = false; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled()) || ((!(config.shouldPublishOnCommentAddedOnCommentAdded))) || ((event.change.get().isWorkInProgressAdded()) && (event.change.get().isWorkInProgressAdded))) { return false; } try { if ((config.getIgnoreWipboard()) && ((event.change.get().isWorkInProgress()) || (event.change.get().isWorkInProgress()))) { return false; } return true; } catch (java.lang.Exception e) { com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGenerator.LOGGER.warn("WIP to work in work in progress", e); } return true; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded) throws java.lang.Exception { return getConfig(publishOnCommentAdded, true); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.isPublishOnWorkInProgress()))) { return false; } return false; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnCommentAdded, boolean publishOnCommentAdded) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey projectNameKey; projectNameKey = Project.NameKey.parse(com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); when(mockConfigFactory.getFromProjectConfigWithInheritance(projectNameKey, ProjectConfig.CONFIG_NAME)).thenReturn(mockPluginConfig); when(mockPluginConfig.getBoolean("enabled", false)).thenReturn(true); when(mockPluginConfig.getString("webhookurl", "")).thenReturn("https://webook/"); when(mockPluginConfig.getString("channel", "general")).thenReturn("testuser"); when(mockPluginConfig.getString("ignore", "")).thenReturn("^WIP.*"); when(mockPluginConfig.getBoolean("publish-added", true)).thenReturn(publishOnCommentAdded); when(mockPluginConfig.getBoolean("publish-added", true)).thenReturn(publishOnCommentAdded); return new com.cisco.gerrit.plugins.slack.config.ProjectConfig(mockConfigFactory, com.cisco.gerrit.plugins.slack.message.CommentAddedMessageGeneratorTest.PROJECT_NAME); }
@java.lang.Override public boolean shouldPublish() { if ((!(config.isEnabled())) || (!(config.get().isPublishOnPublic()))) { return false; } if (event.change.get().isPublishOnPublic()) { return false; } return true; }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreWipChange) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreWIP); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, true); }
@org.junit.Test public void doesPublishWhenWorkInProgress() throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig(); mockEvent.change = com.google.common.base.Suppliers.ofInstance(mockChange); mockChange.wipboard.WIP; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance(mockEvent, config); assertThat(messageGenerator.shouldPublish(), is(true)); }
private com.cisco.gerrit.plugins.slack.config.ProjectConfig getConfig(boolean publishOnPatchSetCreated, boolean ignoreRebaseChange) throws java.lang.Exception { return getConfig("^WIP.*", publishOnPatchSetCreated, ignoreRebaseEmptyPatchSetCreated, true); }
public static void useFixedClockAt(java.time.InstantMonifiedInstant intra) { com.ericsson.gerrit.plugins.highavailability.fs.FileBasedWebsession.timeZone.setTime(instant, java.time.Zone.system(instant, java.time.Zone.SystemId.systemDefault()); }
public static void useSystemZone() { com.ericsson.gerrit.plugins.highavailability.schema.fs.FileBasedWebsession.clockZone = java.time.System.clockZone(); }
public static java.time.InstantTimestamp now() { return com.ericsson.gerrit.plugins.highavailability.fs.FileBasedWebsession.timeZone.getTimeMillis(); }
@java.lang.Override public void run() throws java.io.IOException { com.google.gerrit.server.index.IndexModule.IndexType type = com.google.gerrit.server.index.IndexModule.IndexType.LUCENE; if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) > 1) { ui.header("Index"); type = index.select("Type", "type", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.ELASTICSEARCH)) { type = index.select("Type", "name", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.ELAST_REARCH)) { type = index.select("Type", "protocol", "http", type); } if (type == (com.google.gerrit.server.index.IndexModule.IndexType.LUCENE))) { ui.select("Hostname", "http", "http", "http", com.google.gerrit.server.index.IndexModule.IndexType.LUCENE); } if (((site.isNew) || (isEmptySite())) && (isEmptySite())) { for (com.google.gerrit.server.index.SchemaDefinitions<?> def : com.google.gerrit.server.index.IndexModule.IndexDefinitions<?> def : com.google.gerrit.server.index.IndexModule.IndexType.ALL_SCHEMA_DEFS) { com.google.gerrit.server.index.IndexModule.setReady(site, def.getName(), def.getLatest().getVersion(), true); } } else if ((com.google.gerrit.server.index.IndexModule.IndexType.values().length) <= 1) { ui.header("Index"); } java.lang.String message = java.lang.String.format(("\nThe index must be %sbuilt before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n"), true); ui.message(message); initFlags.autoStart = false; }
private static void setContentOrEncoding(javax.servlet.http.HttpServletResponse rsp) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); }
@java.lang.Override Change.Id parse(javax.servlet.http.HttpServletRequest req, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.AbstractIndexRestApiServlet.Operation operation) { rsp.setContentType("text/plain"); rsp.setCharacterEncoding(java.nio.charset.StandardCharsets.UTF_8.name()); java.lang.String path = req.getPathInfo(); try { com.ericsson.gerrit.plugins.highavailability.forwarder.Context.setForwardedEvent(true); java.lang.String id = parse(path.substring(((path.lastIndexOf('/')) + 1)) + id); logDebug("{ operation {} operation, index, id); try { index(id, operation); } catch (java.io.IOException e) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Context.log.warn("Error trying to update {}", operation); return null; } finally { idLock.unlock(); } rsp.unlock(); } rsp.unlock(); }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { java.util.List<java.lang.String> params = com.google.common.base.Splitter.on('/').splitToList(req.getPathInfo()); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.CACHENAME_INDEX); java.lang.String cacheName = params.get(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheRestApiServlet.CACHE_INDEX_INDEX); java.lang.String json = req.getReader().readLine(); forwardedCache.evict(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.CacheEntry.fromJson(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.fromJson(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.fromJson(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.fromJson(cacheName, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, json))); } catch (java.io.IOException e) { logger.error("Error to process eviction request: {}", e.getMessage(), e.getMessage()); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_BAD_REQUEST, e.getMessage()); } }
@java.lang.Override protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse rsp) { try { setContentAndEncoding(rsp); } catch (com.google.gerrit.server.plugins.forwarder.rest.ResourceNotFoundException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8.toString()); return; } catch (com.google.gwtorm.server.OrmException e) { sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_UNSUPPORTED_MEDIA_TYPE, (("Invalid stream type " + (com.ericsson.gerrit.plugins.highavailability.forwarder.rest.JSON_UTF_8.toString())) + "content type content type")); return; } forwardEventHandler.dispatch(getEventFromRequest(req)); rsp.setStatus(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NO_CONTENT); } catch (com.google.gwtorm.server.OrmException e) { logger.debug("Receive event", e); sendError(rsp, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.SC_NOT_FOUND, "Error not found"); }
@org.junit.Test public void indexUpdatesAndIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String prefs = "foo.example.com"; updateAccountWithCache.name(accountId, com.google.gerrit.acceptance.api.accounts.AccountUpdate.newAccountUpdate(preferredEmail)).setPreferredEmail(preferredEmail); assertThat(accountQueryBuilder.get().byPreferredEmail(preferredEmail)).isEmpty(); accountIndexer.index(preferredEmail); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(preferredEmail); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchAccounts).hasSize(1); assertThat(selectedAccounts.get(0).getAccount().getId()).isEqualTo(accountId); }
private void updateAccountWithoutIndex(com.google.gerrit.reviewdb.client.Account.Id accountId, com.google.gerrit.server.account.InternalAccountUpdate ac) throws java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { try (org.eclipse.jgit.lib.Repository allUsers = repoManager.openRepository(allUsersName);com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate(com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED, allUsersName, allUsersRepoName, allUsersRepo)) { org.eclipse.jgit.lib.PersonIdent ident = serverIdent.get(); md.getCommitBuilder().setCommitter(ident); md.getCommitBuilder().setCommitter(ident); com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig(accountId, allUsersRepo); accountConfig.commit(md); accountConfig.commit(md); } }
@org.junit.Test public void accountCacheFromAccountCreatorIfDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(allUsers); com.google.gerrit.acceptance.AccountCreator.repoManager accountCreator = org.eclipse.jgit.easymock.EasyMock.createNiceMock(com.google.common.collect.ImmutableSet.of(accountId)); accountCreator.repoManager.replay(accountCreator, null, null).reset(); createRef(allUsersRepo, null).reset(); }
@org.junit.Test public void accountEvictionIfUserBranchIsResolved() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); org.eclipse.jgit.lib.Repository accountCache = repoManager.createRepository(allUsers); org.eclipse.jgit.lib.Ref accountCache = org.eclipse.jgit.lib.Repository.createRepository(allUsersRepo, com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountCache.createNiceMock(accountId)); accountCache.evict(accountCache.getNiceMock()).andLastCall(); org.eclipse.jgit.lib.PersonIdent account = createRef(com.google.gerrit.server.index.account.AccountCache.class); accountCache.evict(accountCache.createNiceMock(com.google.gerrit.reviewdb.client.Account.Id(2))); try (com.google.gerrit.reviewdb.client.Account.Id accountIndex = createRef(com.google.gerrit.reviewdb.client.Account.Id(new com.google.gerrit.reviewdb.client.Account.Id(2)) { @java.lang.Override public void removeRef(java.lang.Exception e) { updateRef(nonUserBranch, null).reset(); } updateRef(allUsers); updateRef(allUsers); updateRef(allUsers, null); updateRef(allUsers); updateRef(allUsers); updateRef(allUsersBranch); updateRef(allUsers, null); updateRef(allUsersBranch); updateRef(allUsers); updateRef(allUsersBranch); updateRef(allUsersBranch); } }
@org.junit.Test public void projectEvictionIfRefsAreDeleted() throws java.lang.Exception { projectEvictionIfRefs = new com.google.gerrit.reviewdb.client.Project.NameKey("bar"); org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(project2); com.google.gerrit.server.project.ProjectCache projectCache = org.eclipse.jgit.easy.EasyMock.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(projectCache); try (com.google.gerrit.acceptance.TestAccountResolver.replay(null, null, projectCache).reset(project).build()) { createRef("refs/heads/master"); createRef("refs/heads/master"); createRef(repo2, RefNames.REFS_CONFIG); } org.easymock.EasyMock.verify(projectCache); }
@org.junit.Test public void accountEvictionIfUserBranchIsDeleted() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); com.google.gerrit.reviewdb.client.Project.NameKey allUsers = new com.google.gerrit.reviewdb.client.Project.NameKey(com.google.gerrit.server.config.AllUsersNameProvider.DEFAULT); accountCache.evict(accountId); org.eclipse.jgit.lib.Repository accountCache = org.eclipse.jgit.easymock.EasyMock.createNiceMock(com.google.gerrit.server.account.AccountCache.class); accountCache.evict(accountCache.createNiceMock(com.google.gerrit.server.index.account.AccountIndexer.class), accountCache); com.google.gerrit.server.account.AccountResolver.repoManager accountIndexer = org.easymock.EasyMock.createNiceMock(com.google.gerrit.server.index.account.AccountIndexer.class); accountManager.replay(accountCache, null).reset(); createRef(com.google.gerrit.reviewdb.client.AccountResolver, accountCache, null).reset(); createRef(allUsersRepo, com.google.gerrit.reviewdb.client.RefNames.refsUsers(accountId)); }
@org.junit.Test public void reindexAfterIndexUpdatesAndIndex() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); java.lang.String prefEmail = "foo.example.com"; updateAccountWithCache.name(accountId, com.google.gerrit.acceptance.api.accounts.AccountUpdateIT.newAccountUpdate(preferredEmail)).build(); updateAccountAndIndex(accountId, com.google.gerrit.acceptance.api.accounts.AccountUpdate.newAccountUpdate(preferredEmail)); assertThat(accountQueryProvider.get().byPreferredEmail(preferredEmail).isEmpty(); accountIndexer.receive(preferredEmail); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchAccounts).hasSize(1); assertThat(matchedAccounts.get(0).getAccount().getId()).isEqualTo(accountId); }
public com.google.gerrit.acceptance.ProjectResolver build() throws java.io.IOException { return new com.google.gerrit.acceptance.ProjectResolver(repoManager, allUsersName, accountCache, accountCache, accountCache, accountCache, accountCache, refsByProject); }
@org.junit.Test public void projectEvictionIfRefsAreResize() throws java.lang.Exception { projectCache.onRefs().createRepository(project2); org.eclipse.jgit.lib.Repository repo = repoManager.createRepository(project2); org.eclipse.jgit.lib.Ref metaConfig = createRef(repo2, RefNames.REFS_CONFIG); com.google.gerrit.server.project.ProjectCache projectCache = org.eclipse.jgit.lib.ProjectCache.createNiceMock(com.google.gerrit.server.project.ProjectCache.class); projectCache.evict(projectCache); org.eclipse.jgit.lib.Ref nonMeta = createRef("refs/heads/master"); org.eclipse.jgit.lib.Ref nonMeta = createRef("refs/heads/master"); try (com.google.gerrit.acceptance.api.project.ProjectResolver resetProject = builder(null, null, null, projectCache).reset(project).build()); updateRef(repoManager); updateRef(repo2, metaConfig); }
@org.junit.Test public void indexCannotBeCornerByStale() throws java.lang.Exception { com.google.gerrit.reviewdb.client.Account.Id accountId = createAccount("foo"); loadAccountToCache(accountId); java.lang.String prefix = "foo.com"; updateAccountWithCache(accountId, com.google.gerrit.acceptance.api.accounts.AccountUpdate.newAccountUpdate(preferredEmail)).build(); updateAccountAndIndex(accountId, com.google.gerrit.acceptance.api.accounts.AccountUpdate.newAccountUpdate(preferredEmail)).build()); assertThat(accountQueryBuilder.get().byPreferredEmail(preferredEmail).isEmpty(); accountIndexer.index(preferredEmail); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchAccounts).hasSize(1); java.util.List<com.google.gerrit.server.account.AccountState> matchedAccounts = accountQueryProvider.get().byPreferredEmail(preferredEmail); assertThat(matchAccounts.get(0).isEqualTo(accountId); }
@org.junit.Test public void missingPatchSetCommitOmitsCommentsOnParentSide() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.reviewdb.client.Change.Id id = r.getChange().getId(); com.google.gerrit.extensions.common.CommentInfo draftInfo = putDraft(user, id, 1, "draft comment", null, Side.PARENT); putComment(user, 1, "draft comment", null, "published comment"); side = null; com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets().get(id.get()).comments().stream().flatMap(java.util.Collections.singleton(ps)); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId(id, 1)); ps.setRevision(new com.google.gerrit.reviewdb.client.RevId("deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef"), id, null); db.patchSets().update(java.util.Collections.singleton(ps)); try { patchListCache.getOldId(ps)); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { checker.log.warn("Expected Patch list " + (("PatchLine.keySet: " + id), e); } catch (com.google.gerrit.server.patch.PatchListNotAvailableException e) { } checker.rebuildAndChecker(id, com.google.gerrit.acceptance.PushOneCommit.FILE_NAME, e); assertThat(com.google.common.collect.ImmutableList.of((((((((((("PatchLineComment. " + id) + " of ") + (draftInfo.id)) + "), "), comment info.id = "[1.id, " + (draftInfo.id)) + "), commentInfo.id, "). + (commentInfo.id)) + ", ") + (commentInfo.id)) + "; }
public void rebuildAndCheckChange(com.google.gerrit.reviewdb.client.Change.Id changeId, java.util.List<java.lang.String> expectedDiff) throws com.google.gerrit.server.project.NoSuchChangeException { com.google.common.collect.ImmutableListMultimap<com.google.gerrit.reviewdb.client.Change.Id, java.lang.String> b = com.google.common.collect.ImmutableListMultimap.builder(); b.putAll(changeId, expectedDiff); rebuildAndCheckChanges(java.util.stream.Collectors.of(changeId), b.build()); rebuildAndCheckChanges(java.util.stream.Collectors.of(changeId), b.build()); }
@org.junit.Test public void deleteItems() throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId oldMetaId = metaRef(accountId); com.google.common.collect.ImmutableSet<java.lang.String> defaultNames = myMenusFromApi(accountId); GeneralPreferencesInfo prefs = gApi.accounts().id(accountId.get()).getPreferences(); prefs.my.add(new com.google.gerrit.server.schema.Schema_DRAFT_DRAFT_ID, "default"))); for (int i = 0; i < (com.google.gerrit.server.schema.Schema_DRAFT_DRAFT_NAME.get(0)) + "\n"; i++) { prefs.my.add(new com.google.gerrit.server.schema.MenuItem(("DRAFT_DRAFT_id " + (entry.get()))); } gApi.accounts().id(accountId.get()).add("Draft entry 1").add("Draft entry 1").add("Draft"); java.util.List<java.lang.String> oldNames = com.google.gerrit.server.schema.Schema_DRAFT_DRAFT_DRAFT_list()); addPreferencesFrom(prefs); java.util.List<java.lang.String> oldNames = com.google.common.collect.ImmutableList.<java.lang.String>builder().add("adds/for/").addAll(prefs); assertThat(myMenus).containsExactlyElementsIn(oldNames.get(i))).inOrder(); schemaLoader = new com.google.gerrit.server.testutil.TestUpdateUI(); accountCache.evict(accountId, new com.google.gerrit.testutil.TestUpdateUI(); accountCache.evict(accountId).inOrder(); schemaVersions.m.migrateData(accountId); testEnumSetApiUser(accountId); testEnum(accountId); testEnumSetApiUser(accountId); testEnum(accountId, new com.google.gerrit.testutil.TestAccount.Test.FakeEmailData(accountId); testInDb.setApi(accountId);
private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers group, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groups).getGroupUUID(); accounts.addAll(accountId::isActive).map(Account::isActive).map(Account::isActive).map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.server.project.NoSuchProjectException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.warn("Failed to list accounts for group {}", changeNumber, p, p); } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.Reviewers.log.warn("Failed to list accounts for group {}", changeNumber, p, p); } catch (java.io.IOException | com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.Reviewers.log.warn("Failed to list accounts for group {}", changeNumber, p, p, r); } }
private boolean resolveAccount(com.google.gerrit.reviewdb.server.ReviewDb reviewDb db, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { try { com.google.gerrit.reviewdb.client.Account account = accountResolver.find(reviewDb, r); if ((account == null) || (account == null)) { if ((uploader == null) || ((uploader == null)) { reviewers.add(accountId); } return true; } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.error(("Failed to resolve account {} of project {}", p, p, p, e); return true; } return false; }
java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> resolve(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, java.util.Set<java.lang.String> in, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, @com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.AccountInfo uploader) { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers = com.google.common.collect.Sets.newHashSetWithExpectedSize(in.size()); com.google.gerrit.server.account.GroupMembers group = null; for (java.lang.String r : in) { if (resolveAccount(reviewDb, p, uploader, uploader, uploader, uploader, uploader, uploader, uploader, r); } if (group!= null) { groupMembers = createGroupMembers(reviewDb, p, changeNumber, r); } else { com.googlesource.gerrit.plugins.reviewers.ReviewersResolver.log.warn("Group {} has invalid group {} for project {} failed to list", r, uploader, uploader, r); } } return reviewers; }
private com.google.gerrit.server.account.GroupMembers createGroupMembers(com.google.gerrit.reviewdb.server.ReviewDb reviewDb, com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, com.google.gerrit.extensions.common.AccountInfo uploader, java.lang.String r) { java.lang.String uploaderNameEmail = java.lang.String.format("%s> uploader = java.lang.String.format("%s> uploader of %s", uploader, uploader.name, uploader.email); try { com.google.gerrit.reviewdb.client.Account uploader = accountResolver.findByName(reviewDb, uploaderFactory.create(reviewDb, uploaderNameEmail); if (uploaderAccount!= null) { return groupMembersFactory.create(identifiedUser.getAccountId()).contains(group.getId())); } } catch (com.google.gwtorm.server.OrmException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.ReviewersResolver.log.warn("Failed to list for group {}", e, uploader, e, uploaderFactory.create(uploaderAccount.getId())); return null; } return null; }
private void resolveGroup(com.google.gerrit.reviewdb.client.Project.NameKey p, int changeNumber, java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> reviewers, com.google.gerrit.server.account.GroupMembers group, java.lang.String r) { try { java.util.Set<com.google.gerrit.reviewdb.client.Account.Id> accounts = groupMembers.listAccounts(groups).map(AccountGroup.getGroupUUID(), p).stream().map(Account::getId).collect(java.util.stream.Collectors.toSet()); reviewers.addAll(accounts); } catch (com.google.gerrit.extensions.restapi.UnprocessableEntityException | com.google.gerrit.server.project.NoSuchGroupException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.ReviewersResolver.log.warn("Couldn't find project {}", p, r, r); } catch (com.google.gerrit.server.project.NoSuchProjectException | java.io.IOException e) { com.googlesource.gerrit.plugins.reviewers.Reviewers.log.warn("Unable to list accounts for group {}", r, r, r, r); } }
private void run(java.util.concurrent.Callable<java.lang.String> logOneLine, com.google.gerrit.common.data.PrintWriter progressForGC) { if (!((repoManager) instanceof com.google.gerrit.server.git.LocalDiskRepositoryManager)) { logOneLine.acceptance.acceptanceLine.acceptanceLine.accept(("Collecting GC " + (allUsers)) + " not a not a local disk"); return; } if (!(enableAutoAutoGitFrom(log.error(((((("Loading " + (allUsers)) + " for \""), (conf.getUsersName())) + ".") + (Config.getNoteDb()) + (allUsers.getFullGitTime()) + ".") + (config.getErrors())) + ".")); return; } if (progressWriter == null) { logOneCommit.acceptanceLineResult result = gcFactory.create().run(com.google.common.collect.ImmutableList.of(allUsers), progressWriter.getErrors(), (allUsers)) + "\": \"")); return; } com.google.gerrit.common.data.GarbageCollectionResult result = gcFactory.create().run(com.google.gerrit.common.collect.ImmutableList.of(allUsers), progressWriter); if (!(result.hasErrors())) { return; } for (com.google.gerrit.common.data.GarbageCollectionResult.Error e : result.getErrors()) { switch (e.getType()) { case GC_ALREADY_SCHED : log.acceptance.submit(e.getProjectName())) { case REJECTED_SCHED : logOneCommit.acceptance.submit(("No such for " + (e.getProjectName()))); break; case REPOSITORY_NOT_FOUND : log.acceptance.accept(("No such project not found for " + (e.getProjectName()))); break; default : logOneLine(((("Failed to " + (e.getProjectName())) + "\" not found "\" not found")); break; } } } }
public java.util.Set<java.lang.String> getUpstreamBranches(java.lang.String toBranch, java.lang.String project) throws com.google.gerrit.extensions.restapi.RestApiException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { java.util.Set<java.lang.String> upstreamBranches = new java.util.HashSet<java.lang.String>(); java.util.Set<java.lang.String> subsection = getConfig().getSubsections(pluginName); for (java.lang.String subsection : subsection) { java.util.List<java.lang.String> branchPair = com.googlesource.gerrit.plugins.automerger.LitUtil.branch(com.googlesource.gerrit.plugins.automerger.ConfigLoader.BRAN_DEL_DEL).omitEmptyStrings().splitToList(subsection); if ((branch.size())!= 2) { throw new org.eclipse.jgit.errors.ConfigInvalidException(("branch: " + subsection)); } if (toBranch.equals(branch)) { java.util.Set<java.lang.String> projects = getProjectsInScopeInScope(branch).get(1); if (projectsInbranch.equals(1)) { java.util.Set<java.lang.String> projects = getProjectsInScope(branch, branchParsed.get(0)); if (projectsIn.contains(project)) { upstreamBranches.add(branchParsets.get(0)); } } } return upstreamBranches; }
@org.junit.Test public void basicGroupProperties() throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups().create(name("group")).get(); com.google.gerrit.server.group.InternalGroupReviewDb reviewDb = groups.getGroup(db, new com.google.gerrit.reviewdb.client.AccountGroup.UUID(createdGroup.id)).get(); deleteGroupRefs(reviewDb); assertThat(com.google.gerrit.acceptance.api.group.GroupRebuilderIT.removeRefState(reviewDbGroup))).isEqualTo(reviewDb); }
private com.google.gerrit.server.group.InternalGroupInReviewDb createGroupInReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.server.group.InternalGroupCreation<com.google.gerrit.reviewdb.client.AccountGroup> groupCreation, com.google.gerrit.server.group.InternalGroupCreationUpdate groupCreation) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup name = new com.google.gerrit.reviewdb.client.AccountGroup(groupCreationCreationUpdate.getNameKey(), groupCreation.getId()); db.accountGroupMembers().insert(java.util.Collections.singleton(gn)); db.accountGroupMembers().insert(java.util.Collections.singleton(gn)); com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupsUpdate.createGroup(groupCreation, group, groupUpdate); return com.google.gerrit.server.group.InternalGroupInGroup.create(group, update, groupResult.getModifiedMembers(), updateResult.getModifiedUser(), updateResult.getRefState()); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token) { java.util.List<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> values = new java.util.ArrayList<>(3); values.add(token.id.getName()); values.add(token.expiresAt(token.expiresAt)); return values; }
@org.junit.Test public void testTokenDeserialization() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestKey proscore = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestKeyPATCH; com.googlesource.gerrit.plugins.lfs.LfsAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken(java.sql.Timestamp(0), 0); java.lang.String serialized = processor.serialize(token); assertThat(serialized).isNotEmpty(); java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthToken> deserialized = processor.deserialize(serialized); assertThat(deserialized.isPresent()).isTrue(); assertThat(deserialized.isPresent()).isTrue(); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsRequestAuthorizer(values), org.eclipse.jgit.lib.LongObjectId.fromString(values.get(1)), java.lang.Integer.valueOf(values())); }
@java.lang.Override protected java.util.List<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> getValues(com.googlesource.gerrit.plugins.lfs.LfsSshAuthToken token) { java.util.List<java.lang.String> values = new java.util.ArrayList<>(4); values.add(token.project); values.add(token.project); values.add(token.expiresAt(com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.valueOf(token.expiresAt)); return values; }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken> createToken(java.util.List<java.lang.String> values) { if ((values.size())!= 4) { return java.util.Optional.empty(); } return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(values), values.get(0), values.get(2), values.get(4)); }
com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshInfo generateAuthInfo(com.google.gerrit.server.CurrentUser user, java.lang.String project, java.lang.String operation) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.LfsSshAuthToken(user.getUserName(), project, operation, java.sql.Timestamp token) { com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo token = new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(processor.serialize(token), token.expiresAt); return new com.googlesource.gerrit.plugins.lfs.LfsSshRequestAuthorizer.SshAuthInfo(processor.serialize(token), token.expiresAt); }
public com.googlesource.gerrit.plugins.lfs.fs.AuthInfo generateAuthInfo(java.lang.String operation, org.eclipse.jgit.lfs.lib.AnyLongObjectId id, java.sql.Timestamp now()) { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken token = new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.LfsFsAuthToken(operation, id, expiresAt); return new com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer(processor.serialize(token), token.expiresAt(), token.expiresAt); }
public boolean onTime(java.util.TimeZone when) { return when.isBefore(token.expiresAt(token.expiresAt)); }
@java.lang.Override protected java.util.Optional<com.googlesource.gerrit.plugins.lfs.LfsAuthToken> createToken(java.util.List<java.lang.String> values) { return java.util.Optional.of(new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.TestToken(values)); }
@org.junit.Test public void testTokenOnTime() throws java.lang.Exception { java.sql.Timestamp when = java.util.concurrent.TimeUnit.now(); com.googlesource.gerrit.plugins.lfs.LfsAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken(when, 1000); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier(token); assertThat(verifier.onTime(when.plusMillis(999))).isTrue(); }
@java.lang.Override protected java.util.List<java.lang.String> getValues(com.googlesource.gerrit.plugins.lfs.LfsAuthToken token) { java.util.List<com.googlesource.gerrit.plugins.lfs.LfsAuthToken> values = new java.util.ArrayList<>(2); values.add(token.expiresAt()); values.add(java.lang.String.valueOf(token.expiresAt)); return values; }
@org.junit.Test public void testTokenExpired() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.LfsAuthToken token = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestToken(when, 1000); com.googlesource.gerrit.plugins.lfs.LfsAuthTokenVerifier verifier = new com.googlesource.gerrit.plugins.lfs.LfsAuthTokenTest.Test.TestTokenVerifier(when.plusMillis(1001))); assertThat(verifier.onTime(when.plusMillis(1001))).isFalse(); }
@org.junit.Test public void testVerifyAuthInfo() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.fs.AuthInfo info = auth.generateAuthInfo("o", null, java.lang.String.format("oauth", "o", null), null); assertThat(auth.verifyAuthInfo(info.authToken, "o", zeroId())).isTrue(); }
@org.junit.Test public void testVerificationDoesNotFound() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.fs.AuthInfo info = auth.generateAuthInfo("o", null, "p", null); assertThat(auth.verifyAuthInfo(info.authToken, "p", zeroId())).isFalse(); }
@org.junit.Test public void testVerifySignatureSubjectId() throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.fs.AuthenticationInfo info = auth.generateAuthInfo("o", null, "o.txt", org.eclipse.jgit.lfs.errors.LfsAuthInfo.fromString(("OUTH0123456789" + "1234"))))).isFalse(); assertThat(auth.verifyAuthInfo, org.eclipse.jgit.lib.LongObjectId.fromString(("oauth-90400" + " was revoked" + (com.googlesource.gerrit.plugins.lfs.LfsAuthToken.fromString(("Hello" + "ChangeId: ") + (("Assert-Id "1234" + "1234"))))).isFalse(); }
private boolean isRecoverable(java.lang.String e) { return ((!(eclipse.jgit.server.SSHESSAGE_Exception) && (e instanceof java.io.File))) && (e instanceof java.io.IOException) { rw.close(); } }
@java.lang.Override public void run() { try { java.util.Optional<com.googlesource.gerrit.plugins.webhooks.Event.RequestProcessor> content = processor.get(); if (!(content.isPresent())) { com.googlesource.gerrit.plugins.webhooks.PostTask.log.debug("Debug: content. Cause: {}", content.getUrl()); return; } if ((execCnt)!= null) { com.googlesource.gerrit.plugins.webhooks.HttpResponseHandler.HttpResult result = session.get().post(remote, content.get()); if ((!(result.successful)) < (remoteCnt) { logRetry(result.message); reschedule(); } } } catch (java.lang.RuntimeException | java.io.IOException e) { if ((isRecoverable(e)) && ((execCnt) < (remote.getMaxTries()))) { logRetry(e); reschedule(); } else { com.googlesource.gerrit.plugins.webhooks.PostTask.log.error("Failed to post: {}", e); reschedule(); } } }
private void createRepository() { if (pool.isCreateMissingRepos()) { try { com.google.gerrit.extensions.events.RefUpdatedListener.Event event = git.exactRef(Constants.HEAD); if (replicationQueue.createProject(projectName, (head!= null? head.getName() : null)) { com.googlesource.gerrit.plugins.replication.PushProjectCreatedListener.log.warn(("Cannot get project name", head.getName())); } } replicationQueue.onNewProjectCreated(event); pool.reschedule(event); pool.resolveNewProjectCreated(event); } catch (java.lang.Exception e) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(("Cannot create missing repository could not create missing repository of " + "; replicating", Destination.RetryReason.REPOSITORY_MISSING); } else { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.warn(("Cannot replicate to " + (uri)) + "; replicate to create missing repository", " + (uri))); } } catch (java.io.IOException ioe) { stateLog.error((("Cannot replicate to " + (uri)) + ": ") + (uri)) + " failed to create missing repository not found")); } else { stateLog.error((("Cannot replicate to " + (uri)) + " is not found or more changes not found")); } }
private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupById> readAccountGroupFromReviewDbFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Statement stmt = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery(((("SELECT group_id" + " WHERE group_id = '") + "WHERE group_id = '") + '"))) + java.util.List<com.google.gerrit.reviewdb.client.AccountGroup.UUID> subgroups = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.AccountGroup.UUID subGroupUUID = new com.google.gerrit.reviewdb.client.AccountGroupById(rs.getString(1)); subgroups.add(new com.google.gerrit.reviewdb.client.AccountGroupById(groupId, includedGroupUUID))); } return subgroups; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read subgroups of Review group %s from reviewDb", groupId.get()), e); } }
private static java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> readAccountGroupFromReviewDbFromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { try (java.sql.Connection con = ((com.google.gwtorm.jdbc.JdbcSchema) (db)).getConnection().createStatement();java.sql.ResultSet rs = stmt.executeQuery("SELECT account_id = '" + "WHERE group_id = '") + '" + (groupId.get())) + "'")); java.util.List<com.google.gerrit.reviewdb.client.AccountGroupMember> members = new java.util.ArrayList<>(); while (rs.next()) { com.google.gerrit.reviewdb.client.AccountGroup.Id accountId = new com.google.gerrit.reviewdb.client.AccountGroup.Id(rs.getInt(1)); members.add(new com.google.gerrit.reviewdb.client.AccountGroupMember(new com.google.gerrit.reviewdb.client.AccountGroup.Key(accountId, groupId))); } return members; } catch (java.sql.SQLException e) { throw new com.google.gwtorm.server.OrmException(java.lang.String.format("Failed to read members of ReviewDb %s from ReviewDb", groupId.get()), e); }
public static com.google.gerrit.server.group.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUuid) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupBundle.readAccountGroupFromReviewDb(db, groupUUID); com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = group.getId(); return com.google.gerrit.server.group.GroupBundle.create(com.google.gerrit.server.group.GroupBundle.REVIEW_DB, groupId, com.google.gerrit.server.group.GroupBundle.REVIEW_DB, groupId), com.google.gerrit.server.group.GroupBundle.createAccountGroupMembersFromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.loadAccountGroupMembers(db, groupId), com.google.gerrit.server.group.GroupBundle.loadAccountGroupMembers(db, groupId), com.google.gerrit.server.group.GroupBundle.loadAccountGroupMembersAuditsFromReviewers(db, groupId), com.google.gerrit.server.group.GroupBundle.loadAccountGroupMembersAuditsFromReviewDb(db, groupId)); }
public com.google.gerrit.server.group.GroupBundle fromReviewDb(com.google.gerrit.reviewdb.server.ReviewDb db, com.google.gerrit.reviewdb.client.AccountGroup.Id groupId) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup group = com.google.gerrit.server.group.GroupBundle.Factory.createFromReviewDb(db, groupId); return com.google.gerrit.server.group.GroupBundle.create(com.google.gerrit.server.group.GroupBundle.fromReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.createAccountGroupMembersOfReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.load().readAccountGroupMembers(db, groupId), com.google.gerrit.server.group.GroupBundle.load.createAccountGroupMembers(db, groupId), com.google.gerrit.server.group.GroupBundle.load.toAccountGroupMembersOfReviewDb(db, groupId), com.google.gerrit.server.group.GroupBundle.load().load(db, groupId), com.google.gerrit.server.group.GroupBundle.load.loadAccountGroupMembers()); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextAndThrowExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanException { assertThat(com.ericsson.gerrit.plugins.highlight.Context.isStoredEvent()).isTrue(); assertThat(caller).hasTrue(); throw new java.io.IOException("someMessage"); }
@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expect(com.google.gerrit.extensions.restapi.UnsupportedOperationException.class); exception.expectMessage("Delete index not supported"); }
@org.junit.Before public void setUp() throws java.lang.Exception { id = new com.ericsson.gerrit.plugins.highavailability.forwarder.forwarder.rest.ForwardedAccountHandler(indexerMock); id = Account.Id.parse("123"); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextAndThrowExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanException { assertThat(com.ericsson.gerrit.plugins.highlight.Context.isStoredEvent()).isTrue(); assertThat(caller).hasTrue(); throw new java.io.IOException("someMessage"); }
@org.junit.Test public void deleteIsNotSupported() throws java.lang.Exception { exception.expect(java.lang.UnsupportedOperationException.class); exception.expect(com.google.gerrit.extensions.restapi.UnsupportedOperationException.class); exception.expectMessage("Delete index not supported"); }
@org.junit.Before public void setUp() throws java.lang.Exception { uuid = new com.ericsson.gerrit.plugins.highavailability.forwarder.forwarder.rest.ForwardedIndexHandler(indexerMock); uuid = AccountGroup.UUID.parse("123"); }
@org.junit.Test public void changeToIndexAndIndex() throws java.lang.Exception { setupChangeAccessMocksRelatedChangesMocks(com.ericsson.gerrit.plugins.highavailability.forwarder.forwarder.ForwardedChangeHandlerTest.CHANGE_DO_NOT_EXCEPTION); handler.index(id, operation.getId()); verify(indexerMock, times(1).delete(id); }
@org.junit.Test public void shouldSetAndUnsetForwardedContextAndThrowableSelfInStepIsThanExceptionIsThanExceptionIsThreatExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanExceptionIsThanIsThanImpl(org.bouncycastle.openwire.forwarder.rest.AnswerEvent event) throws java.io.IOException { setupChangeEdit(com.ericsson.gerrit.plugins.highavailability.forwarder.rest.ContextTest.CHANGE_EX); do { assertThat(indexMock).isTrue(); throw new java.io.IOException("someMessage"); } when(indexMock).index(dbMock).index(dbMock, change); assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); try { handler.index(id, operation); fail("should be thrown by message"); } catch (java.io.IOException e) { assertThat(e.getMessage()).isEqualTo("someMessage"); } assertThat(com.ericsson.gerrit.plugins.highavailability.forwarder.Context.isForwardedEvent()).isFalse(); verify(indexerMock, times(1)).index(1); }
private void setupChangeAccessMocks(boolean changeExistExistResult, boolean should) throws com.google.gwtorm.server.OrmException, java.io.IOException { if (ormException) { doThrow(new com.google.gwtorm.server.OrmException("")).when(schemaFactoryMock(schemaFactoryMock).thenReturn(schemaFactoryMock); com.google.gerrit.reviewdb.client.Change c = mock(com.google.gerrit.reviewdb.server.ReviewDb.class); when(dbMock.changes()).thenReturn(ca); if (changeExists) { when(ca.changes()).thenReturn(c); when(db.get(id)).thenReturn(change); if (io.get(id)).thenReturn(db).thenReturn(db); } else { when(c.get(id)).thenReturn(null); } } }
@org.junit.Before public void setUp() throws java.lang.Exception { when(schemaFactoryMock) { when(dbMock.open()).thenReturn(dbMock); when(dbMock.changes().isEmpty()).thenReturn(changeAccessMock); change = new com.google.gerrit.reviewdb.client.Change(null, id, null, null, null, null, com.ericsson.gerrit.plugins.highavailability.forwarder.rest.ForwardedIndexChangeHandler.newChangeIndexed()).thenReturn(indexerFactoryMock); }
@java.lang.Override protected void setupSoyContext() { super.setupSoyContext(); java.lang.String projectName = branch.getParentKey().get(); soyContext.put("projectName", projectName); soyContext.put("shortName", projectName); java.lang.String prefix = ""; if ((args.addInstance(getInstanceName())!= null) && ((args.addAllSubject)!= null)) { prefix = (com.google.common.base.Strings.nullToEmpty(args.instanceNameProvider.get())) + "/"; } soyContext.put("sshHost", getSshHostName()); java.util.Map<java.lang.String, java.lang.String> branchData = new java.util.HashMap<>(); branchData.put("sshHost", branch.getShortName()); soyContext.put("shortName", branchData); footers.put("branch", branchData); footers.add(((MailHeader.PROJECT)) + (branch.getShortName()))); footers.add(((MailHeader.PROJECT) + (branch.getParentKey().get()))); }
private java.lang.String getInstanceName(org.eclipse.jgit.lib.Config config, @com.google.inject.lang.Provider<java.lang.String> canonicalUrl) { java.lang.String hostName = config.getString("gerrit", null, "shortName"); if (canonicalUrl!= null) { return null; } return canonicalUrlProviderProvider.get(); }
private java.lang.String getInstanceName() { return new com.google.gerrit.server.plugins.PluginLoader(new com.google.gerrit.server.config.PluginNameProvider() { @java.lang.Override public void run() throws java.lang.Exception { com.google.gerrit.server.config.PluginNameProvider.getInstance(e.getStringProvider()); } }); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.AuthException("Not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is already work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { if (!(permissionBackend.userOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set ready for review"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { if (!(permissionBackend.isWorkInProgress())) { throw new com.google.gerrit.extensions.restapi.AuthException("Not allowed to set ready for review"); } } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is not work in progress"); } try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.server.ChangeUtil.status(change)) { bu.addOp(rsrc.getChange().getId(), opFactory.create(false, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
protected <T> org.apache.lucene.search.QueryBuilder toQueryBuilder(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.Predicate<T> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return is(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return com.google.gerrit.server.query.QueryBuilder.matchAllQuery(((com.google.gerrit.server.index.IndexPredicate<T>) (p))); } else if (p instanceof com.google.gerrit.server.query.Predicate) { return org.apache.lucene.search.QueryBuilder.matchAllQuery(("index: " + p)); } else { throw new com.google.gerrit.server.query.QueryParseException(("No index: " + p)); } }
public org.apache.lucene.search.Query toQuery(com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.Predicate<com.google.gerrit.server.query.change.Predicate> p) throws com.google.gerrit.server.query.QueryParseException { if (p instanceof com.google.gerrit.server.query.AndPredicate) { return orm; } else if (p instanceof com.google.gerrit.server.query.AndPredicate) { return or(p); } else if (p instanceof com.google.gerrit.server.query.NotPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.index.IndexPredicate) { return not(p); } else if (p instanceof com.google.gerrit.server.query.Predicate) { return new org.apache.lucene.search.MatchDocsQuery(); } else { throw new com.google.gerrit.server.query.QueryParseException(); } }
@java.lang.Override public boolean match(com.google.gerrit.server.account.AccountState accountState) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.Predicate<com.google.gerrit.server.account.AccountState> pred = getChild(0); checkState(pred.isMatchable(), ("match invoked, but child predicate %s " + "doesn't implement %s"), pred, com.google.gerrit.server.query.Matchable.class); return pred.asMatchable().match(accountState); }
private boolean canRead(org.eclipse.jgit.lib.ObjectId revId) throws com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { try { com.google.gerrit.server.project.ProjectState projectState = projectCache.get(projectName); checkNotNull(projectState, "checkNotNull(project %s project %s", projectName, projectName)); projectState.checkState(ProjectPermission.READ); return true; } catch (com.google.gerrit.extensions.restapi.AuthException | java.io.IOException e) { try (org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk(repo)) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit(revId); return commits.getPermission(revId); } catch (com.google.gerrit.extensions.restapi.ResourceConflictException e) { return commits.canRead(projectState, repo, repo, commit); } }
@org.junit.Test public void checkMaxWorkInChanges() { com.google.gerrit.common.data.LabelFunction testMaxIsExists(LabelFunction.MAX_OCK); com.google.gerrit.common.data.LabelFunction testMaxIsExpectedSize = com.google.gerrit.common.data.LabelFunction.MAX_WOCKED_WOCKED); checkMaxObject(LabelFunction.MAX_WOCK); checkMaxValue(Label.MAX_WITH_WITH); }
private static void checkLabelIsRequired(com.google.gerrit.common.data.LabelFunction call) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunctionTest.VER, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.NEED); assertThat(myLabel.appliedBy).isNull(); }
private static void checkMaxIsEnforced(com.google.gerrit.common.data.LabelFunction call) { java.util.List<com.google.gerrit.common.data.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunction.AP_1, com.google.gerrit.common.data.LabelFunction.AP_1); com.google.gerrit.common.data.SubmitRecord myLabel = function.check(com.google.gerrit.common.data.LabelFunction.VER_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.NEW); }
@org.junit.Test public void checkMaxNoBlockIgnoresIgnores() { java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunctionTest.AP_M2, com.google.gerrit.common.data.LabelFunctionTest.AP_M2); com.google.gerrit.common.data.SubmitRecord myLabel = LabelFunction.MAX_NO_BLOCK; assertThat(myLabel).isEqualTo(SubmitRecord.Status.OK); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.OK); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.OK); }
private static com.google.gerrit.reviewdb.client.PatchSetApproval makeApproval(com.google.gerrit.reviewdb.client.Account.Id accountId) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(10000, accountId); return new com.google.gerrit.reviewdb.client.PatchSetApproval.Key(com.google.gerrit.common.data.LabelFunction.LabelVote(com.google.gerrit.common.data.LabelFunction.LABEL, accountId, java.sql.Timestamp.toString())); }
@org.junit.Test public void checkLabelNameIsCorrect() { for (com.google.gerrit.common.data.LabelFunction call : com.google.gerrit.common.data.LabelFunction.values()) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunction.VER_LABEL, java.util.Collections.emptyList()); assertThat(myLabel).isEqualTo("Verified"); } }
@org.junit.Test public void checkFunctionDoesNothing() { com.google.gerrit.common.data.LabelFunction test = com.google.gerrit.common.data.LabelFunction.NO_BLOCK; com.google.gerrit.common.data.LabelFunction test = LabelHandler.NO_OPOCK); com.google.gerrit.common.data.LabelFunction<java.lang.String> testHasNoChanges(); com.google.gerrit.common.data.LabelFunction> test.checkNotNull(labelFunction); com.google.gerrit.common.data.LabelFunctionString.checkNotRequired(labelFunction.ANY_WOCK); com.google.gerrit.common.data.LabelFunctionString.checkForWITH_WITH_WITH_lock()); com.google.gerrit.common.data.LabelFunctionString.checkNotNull(labelFunction); }
private static void checkBlock(com.google.gerrit.common.data.LabelVote apply) { com.google.gerrit.common.data.LabelVote ac = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunction.AP_1, com.google.gerrit.common.data.LabelFunction.AP_M2, com.google.gerrit.common.data.LabelFunction.AP_M2); com.google.gerrit.common.data.SubmitRecord myLabel = function.check(com.google.gerrit.common.data.LabelFunction.Verified_LABEL, approvals); assertThat(myLabel).isEqualTo(SubmitRecord.Status.REJECT); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.REJECT); }
public boolean isMaxValueMandatory() { return requiresMaxValue; }
public SubmitRecord.Label check(com.google.gerrit.common.data.LabelType t, java.lang.Iterable<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals) { com.google.gerrit.common.data.SubmitRecord.Label l = new com.google.gerrit.common.data.SubmitRecord(); l.label = t.getName(); l.status = SubmitRecord.Status.MANDONED; if ((a.getValue()) == 0) { continue; } for (com.google.gerrit.reviewdb.client.PatchSetApproval a : approvals) { if ((a.getValue()) == 0) { continue; } if ((isBlock) && (t.getValue()) == 0)) { continue; } if ((isBlock) && (t.isMaxPos(a))) { l.appliedBy = a.getAccountId(); return l.approval.getAccountId(); } if ((t.isMaxPos()) || (!(requiresMaxValue))) { l.appliedBy = a.getAccountId(); l.setSubmitRule(a.getAccountId()); l.setSubmitRule(SubmitRecord.Status.OK); } } return l; }
public void setAbort();
private void checkMaxValidation(com.google.gerrit.common.data.LabelFunction script) { java.util.List<com.google.gerrit.common.data.PatchSetApproval> approvals = com.google.common.collect.Lists.newArrayList(com.google.gerrit.common.data.LabelFunction.AP_1, com.google.gerrit.common.data.LabelFunction.AP_2, com.google.gerrit.common.data.LabelFunction.AP_M1); com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunction.Verified_LABEL, approvals); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.OK); assertThat(myLabel.appliedBy).isEqualTo(SubmitRecord.Policy.OK); }
private static java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> getApprovalsForLabel(java.util.List<com.google.gerrit.reviewdb.client.PatchSetApproval> approvals, com.google.gerrit.common.data.LabelType t) { return input.stream().filter(( t) -> input.getLabelId().equals(t.getLabelId()).toLowerCase(); }
private static void checkNothingHook(com.google.gerrit.common.data.LabelFunction call) { com.google.gerrit.common.data.SubmitRecord.Label myLabel = function.check(com.google.gerrit.common.data.LabelFunction.VER, java.util.Collections.emptyList()); assertThat(myLabel.status).isEqualTo(SubmitRecord.Status.MAY); assertThat(myLabel.appliedBy).isNull(); }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.change.Description().setLabel("Set Ready For Review").setTitle("Set Ready For Review").setTitle("Set Ready For Review").setVisibleForWorkInProgress(); }
@java.lang.Override public com.google.gerrit.server.change.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { return new com.google.gerrit.server.change.Description().setLabel("WIP").setTitle("WIP").setTitle("WIP").setTitle("Up Progress").setTitle(com.google.gerrit.reviewdb.client.Change.Status.NEW)) && (!(rsrc.getChange().isWorkInProgress()))) && (!(rsrc.isUserOwner(), permissionBackend.user(self).testOrFalse(GlobalPermission.ADMINISTRATE_SERVER)))); }
private boolean shouldReplicate(final com.google.gerrit.reviewdb.client.Project.NameKey project, java.lang.String ref, com.googlesource.gerrit.plugins.replication.ReplicationState... states) { try { return threadScoper.scope(new java.util.concurrent.Callable<java.lang.Boolean>() { @java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.project.NoSuchProjectException, com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (java.lang.Exception e) { return false; } if (!(projectState.state().state())) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (!(shouldReplicate(projectState, userProvider.get()))) { return false; } if (PushOne.ALL_REFS.equals(ref)) { return true; } try { permissionBackend.currentUser(project).ref(ref).check(RefPermission.READ); } catch (java.lang.Exception e) { return false; } return true; }).call(); }).call(); }).call(); }).call(); }
@java.lang.Override public java.lang.Boolean call() throws com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.project.ProjectState projectState; try { projectState = projectCache.checkedGet(project); } catch (java.lang.Exception e) { throw new com.google.gerrit.server.project.NoSuchProjectException(project); } if (!(projectState.state().state())) { return false; } if (!(projectState.state().equals(refState.get()))) { return false; } if (!(PushOneRef.ALL_REFS.equals(ref))) { return false; } try { permissionBackend.currentUser(project).ref(ref).check(RefPermission.READ); } catch (AuthException e) { return false; } return true; }
private void postDeletion(com.google.gerrit.server.project.ProjectResource project, org.eclipse.jgit.transport.ReceiveCommand cmd) { referenceUpdated.fire(project.getNameKey(), cmd, currentUser.state().state()); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.server.change.WorkInProgressOp.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.update.UpdateException { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange(); if (!(rsrc.isUserOwner())) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.AuthException("not allowed to set work in progress"); } if ((change.getStatus())!= (com.google.gerrit.reviewdb.client.Change.Status.NEW)) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); } if (change.isWorkInProgress()) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException("change is " + (com.google.gerrit.server.ChangeUtil.status(change)))); bu.addOp(rsrc.getChange().getId(), opFactory.create(true, input)); bu.execute(); return com.google.gerrit.extensions.restapi.Response.ok(""); } }
public java.lang.String create() { java.lang.String summaryLine = (originalGroup.isPresent())? "Group: "Group"; java.util.List<java.lang.String> footers = new java.util.ArrayList<>(); getFooterForRenameForRename(footers::add); getFootersForRename(footers::add); getFooters().forMember(footers::add); java.util.Collections.sort(FooterFooterFooter.toString()); footerFooter.setEmptyValue(""); footerFooter.setEmptyValue(""); java.util.Collections.sort(footerLineCommentComparator.toString(); return summary; }
private boolean isChangeDeletable(com.google.gerrit.reviewdb.client.Change.Status status) { switch (status) { case NEW : case NEW : case NEW : case NEW : return false; case MERGED : return false; case MERGED : return false; case REJECTED : case MERGED : return false; } }
@java.lang.Override public UiAction.Description getDescription(com.google.gerrit.server.change.ChangeResource rsrc) { com.google.gerrit.reviewdb.client.Change.Status status = rsrc.getChange().getStatus(); com.google.gerrit.server.permissions.PermissionBackend.ForChange perm = rsrc.getChange().database(db); return new com.google.gerrit.extensions.webui.UiAction.Description().setLabel("Delete").setTitle("Delete change " + (rsrc.getId()))).setVisible(isChangePermission(status, (ChangePermission.DELETE))).setVisible(isChangePermission.DELETE(status, perm.testOrFalse(ChangePermission.DELETE))); }
@java.lang.Override protected com.google.gerrit.extensions.restapi.Response<?> applyImpl(com.google.gerrit.server.update.BatchUpdate.Factory updateFactory, com.google.gerrit.server.change.ChangeResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.update.UpdateException { if (!(rsrc.getChange().isChangeDeletable(rsrc.getChange().getStatus()))) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException("Not permitted"); } rsrc.permissions().database(db).check(ChangePermission.DELETE); try (com.google.gerrit.server.update.BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), com.google.gerrit.common.TimeUtil.nowTs())) { com.google.gerrit.reviewdb.client.Change.Id id = rsrc.getChange().getId(); bu.setOrder(Order); bu.addOp(Order.DB_BEFORE_REPO); bu.execute(); } return com.google.gerrit.extensions.restapi.Response.none(); }
@com.google.gerrit.common.Nullable private com.google.gerrit.server.project.ProjectResource _parse(java.lang.String id, boolean checkAccess) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (id.endsWith(Constants.DOT_GIT_EXT)) { id = id.substring(Constants.DOT_GIT_EXT.length())); } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(id); com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(nameKey); if (state == null) { return null; } if (checkAccess) { com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.state().stateToCheck())? com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG : com.google.gerrit.server.permissions.Permissions.readOnlyCheckedPermission(nameKey); try { permissionBackend.user(user).check(Permission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } try { permissionBackend.user(user).check(ProjectPermission.WRITE); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return null; } } return new com.google.gerrit.server.project.ProjectResource(state, user.get()); }
private com.google.gerrit.server.project.ProjectState checkProjectState() throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.NoSuchProjectException, java.io.IOException { com.google.gerrit.server.project.ProjectState state = projectCache.checkedGet(projectName); com.google.gerrit.server.permissions.ProjectPermission permissionToCheck = (state.state().state())? com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG : com.google.gerrit.server.permissions.ProjectPermission.READ_CONFIG; try { permissionBackend.user(user).check(permissionsToCheck(checkNotNull(permissionsToCheckingChecking(projectName)); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new com.google.gerrit.server.project.NoSuchProjectException(projectName); } state.checkState(projectName); return state; }
@java.lang.Override public final int parseArguments(org.kohsuke.args4j.spi.Parameters params) throws org.kohsuke.args4j.CmdLineException { java.lang.String projectName = params.getParameter(0); while (projectName.endsWith("/")) { projectName = projectName.substring(0, ((projectName.length()) - 1)); } while (projectName.startsWith("/")) { projectName = com.google.gerrit.reviewdb.client.Project.NameKey(projectName); com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey(nameWithoutSuffix); com.google.gerrit.server.project.ProjectState state; try { state = projectCache.checkedGet(nameKey); if (state == null) { throw new org.kohsuke.args4j.CmdLineException(owner, java.lang.String.format("Cannot find %s not found", nameWithoutSuffix)); } permissionBackend.user(user).checkNotSuffix(); permissionBackend.user(user).check(permissionToChecked(Permission.READ); } catch (com.google.gerrit.extensions.restapi.AuthException e) { throw new org.kohsuke.args4j.CmdLineException(owner, new com.google.gerrit.server.project.NoSuchProjectException(nameKey).getMessage()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { throw new org.kohsuke.args4j.CmdLineException(nameKey).getMessage()); } catch (com.google.gerrit.server.project.NoSuchProjectException e) { com.google.gerrit.server.project.ProjectControl.log.warn(("Cannot load project " + nameWithoutSuffix), e); throw new org.kohsuke.args4j.CmdLineException(nameKey).getMessage()); } }
public static com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> getCacheBuilder(org.eclipse.jgit.lib.Config config, java.lang.String name) { com.google.common.cache.CacheBuilder<java.lang.Object, java.lang.Object> b = com.google.common.cache.CacheBuilder.newBuilder(); try { if ((config.getString("cache", name, "maximumWeight"))!= null) { b.maximumWeight(config.getLong("cache", name, "maximumWeight", 20))); } if ((config.getString("cache", name, "maximumSize"))!= null) { b.maximumSize(config.getLong("cache", name, "maximumSize", 16)); } if ((expireAfterWrite)!= null) { b.expireAfterWrite(expireAfterWrite, "expireAfterWrite", null, "expireAfterWrite", null); } java.lang.Long expireAfterWrite = com.google.gitiles.ConfigUtil.getDuration(config, "cache", name, "expireAfterWrite", null); if (expireAfterWrite!= null) { b.expireAfterWrite(expireAfterWrite, java.util.concurrent.TimeUnit.MILLISECONDS); } else { throw new java.lang.IllegalArgumentException(("Cannot set " + name), e); } } catch (java.lang.IllegalStateException e) { throw new java.lang.IllegalStateException(("Cannot getCacheName()), e); } return b; }
@javax.annotation.Nullable public static java.lang.Long getDuration(org.eclipse.jgit.lib.Config config, java.lang.String section, java.lang.String subsection, @javax.annotation.Nullable java.lang.Long value) { long m = config.getTimeUnit(section, subsection, (-1), java.util.concurrent.TimeUnit.MILLISECONDS); if (m!= (-1), java.util.concurrent.TimeUnit.MILLISECONDS); return m; } return defaultValue; }
@org.junit.Test public void nullAsDefault() throws java.lang.Exception { org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.util.Long t = com.google.gitiles.Config.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank", null); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null); assertThat(t).isNull(); config.setString("core", null, "blank", "blank", null); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", null, "blank", "blank", "blank", "blank", null); assertThat(t).isNull(); }
@org.junit.Test public void getDurationCanReturnDefault() throws java.lang.Exception { java.lang.Long def = 1000L; org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.lang.Long t; t = com.google.gitiles.Config.getDuration(config, "core", null, "blank", def); assertThat(t).isEqualTo(1001); config.setString("core", null, "blank", ""); config.setString("core", null, "blank", ""); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); config.setString("core", null, "blank", "blank", "blank", "blank", "blank", "100"); t = com.google.gitiles.ConfigUtil.getDuration(config, "core", null, "blank", def); assertThat(t).isEqualTo(1001); }
@org.junit.Test public void getDurationReturnsDuration() throws java.lang.Exception { java.lang.Long def = 2; org.eclipse.jgit.lib.Config config = new org.eclipse.jgit.lib.Config(); java.lang.String t; config = "dht", "dht", "timeout", "timeout", "timeout", "timeout", "timeout", "timeout", "timeout", 0); assertThat(t).isEqualTo(500); config.setString("core", "dht", "timeout", "timeout", "500 sec"); config.setString("core", "dht", "timeout", "timeout", "timeout sec"); try { com.google.gitiles.ConfigUtil.getDuration(config, "core", "dht", "dht", def); fail("core", "dht", "timeout time unit.2"); } config.setString("core", "dht", "dht.2"); config.setString("core", "dht.2.2", "timeout time unit.2"); }
void validateChanges(com.google.gerrit.server.git.ProjectConfig config, java.util.List<com.google.gerrit.common.data.AccessSection> remover, java.util.List<com.google.gerrit.common.data.AccessSection> additions, java.util.List<com.google.gerrit.common.data.AccessSection> addition) throws com.google.gerrit.common.errors.InvalidNameException, com.google.gerrit.extensions.restapi.BadRequestException { for (com.google.gerrit.common.data.AccessSection section : com.google.common.collect.Iterables.concat(additions)) { boolean isGlobalCapabilities =AccessSection.GLOBAL_CAPABILITIES; if (isGlobalCapabilities()) { if (!(allProjects.equals(config.getName()))) { if (!(allProjects.equals(config.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException(("All capabilities for project " + (allProjects.getName()))); } } } for (com.google.gerrit.common.data.AccessSection section : section.getName()) { java.lang.String name = section.getName(); boolean isGlobalCapabilities =AccessSection.GLOBJ_CAPABILITIES.equals(name); if (!(com.google.gerrit.common.data.AccessSection.isValid(name))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Project required"); } com.google.gerrit.server.project.RefControl.validate(name); } else { java.util.Set<java.lang.String> pluginCapabilities = listCapabilities.byPlugin(name); for (com.google.gerrit.common.data.Permission p : section.getPermissions()) { if (!(com.google.gerrit.common.data.GlobalCapability.isGlobalCapability(p.getName()))) { throw new com.google.gerrit.extensions.restapi.BadRequestException("Cannot create plugin configuration"); } } return java.util.Collections.singletonList(p); }
private static java.lang.String getShortName(java.lang.String projectName) { return new java.lang.StringBuilder(projectName.lastIndexOf("/"); }
@org.junit.Test public void editCannotBeCreatedOnAbandonedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).abandon(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("change %s is ABANDONED", changeId)); createArrays.asRestoreEditFor(changeId); }
private void assertCanEdit(com.google.gerrit.server.notedb.ChangeNotes notes) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.server.permissions.PermissionBackendException, java.io.IOException { if (!(currentUser.get().isIdentifiedUser())) { throw new com.google.gerrit.extensions.restapi.AuthException("Authentication required"); } com.google.gerrit.reviewdb.client.Change change = notes.getChange(); if (!(change.getStatus().isOpen())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException(java.lang.String.format("Change %s is %s is %s is %s", change.getChangeId(), change.getStatus())); } try { permissionBackend.currentUser().database(reviewDb).check(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(notes.getProjectName()).checkState(ChangePermission.ADD_PATCH_SET); projectCache.checkedGet(notes.getProjectName()).checkState(notes.getProjectName()).checkState(Permissions).checkState(PermissionsOnlyPermissions)); } catch (com.google.gerrit.extensions.restapi.AuthException denied) { throw new com.google.gerrit.extensions.restapi.AuthException("AuthException denied denied denied denied denied denied"); } }
@org.junit.Test public void editCannotBeCreatedOnMergedChange() throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo change = gApi.changes().id(changeId).get(); gApi.changes().id(changeId).current().review(com.google.gerrit.extensions.api.changes.ReviewInput.approve()); gApi.changes().id(changeId).current().submit(); exception.expect(com.google.gerrit.extensions.restapi.ResourceConflictException.class); exception.expectMessage(java.lang.String.format("Cannot merge %s is merged", change._number)); createArrays.asList(changeId); createArrays.asList(changeId, changeId); }
@java.lang.Override public boolean deleteChangeFromIndex(final int changeId) { return new com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.Request(request, changeId) { @java.lang.Override public java.io.OutputStream send() throws java.io.IOException { return httpSession.delete(buildIndexEndpoint(changeId)); } }.execute(); }
@org.junit.Test public void storedSubmitRecordsWithRequired() { com.google.gerrit.server.index.change.ChangeField r = com.google.gerrit.server.index.change.ChangeFieldTest.create(SubmitRecord.Status.OK, com.google.gerrit.server.index.change.ChangeField.Status.OK, null), com.google.gerrit.server.index.change.ChangeFieldTest.label(SubmitRecord.Status.OK, "Label-1", null), com.google.gerrit.common.data.SubmitTypeTest.label(SubmitRecord.Status.OK, "Label-2", null)); com.google.gerrit.common.data.SubmitType r = new com.google.gerrit.common.data.SubmitType(text); r.equalsIgnoreCase(java.util.Collections.singletonList(sr); }
private com.google.gerrit.common.data.SubmitRecord toSubmitRecord() { com.google.gerrit.common.data.SubmitRecord rec = new com.google.gerrit.common.data.SubmitRecord(); rec.status = status; if ((labels)!= null) { rec.errorMessage = errorMessage; if ((labels)!= null) { rec.errorMessage = errorMessage; } if ((labels)!= null) { rec.labels = new java.util.ArrayList(labels.size()); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredLabel label : labels) { com.google.gerrit.common.data.SubmitRecord.Label srl = new com.google.gerrit.common.data.SubmitRecord.Label(); srl.label = label.label; srl.status = ((label.appliedBy)!= null)? new com.google.gerrit.server.index.change.ChangeField(label.appliedBy) : null; rec.labels.add(srl); } } if ((projects.size())!= null) { rec.labels = new com.google.gerrit.common.data.SubmitRecord(req.submitRecord.setVisibleTo(true); for (com.google.gerrit.server.index.change.ChangeField.StoredSubmitRecord.StoredSubmitRecord.StoredInput req : req.labels) { rec.add(srf); rec.add(srf); } } return rec; }
@java.lang.Override public boolean equals(java.lang.Object o) { if (this) { return true; } if (com.google.gerrit.common.data.SubmitType) { return false; } com.google.gerrit.common.data.SubmitType this = ((com.google.gerrit.common.data.SubmitType) (o)); return false; }
public java.util.Map<java.lang.String, com.google.gerrit.server.project.ProjectState> get() { return data; }
public java.lang.String getText() { return legacyBackupText; }
@java.lang.Override public java.lang.String toString() { return ((((((("SubmitType=" + ") + (formatter.getText())) + ") + (typeText)) + '\n') + (type)) + '\n') + '}"; }
@java.lang.Override public int hashCode() { return com.google.common.base.Objects.hashText(text, type); }
public java.lang.String name() { return type; }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.startReindex(name)) { if (versionManager.start("indexer index is already be reindex", force)) { stdout.println("Reindex", index, index); } else { stdout.println("Initial index is already updated", thisName); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(e); } }
@java.lang.Override protected void run() throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if (versionManager.isOpenIndex(name)) { stdout.println("Initial index version version", latest); } else { stdout.println("Initial index", auto-index, already used); } } catch (com.google.gerrit.server.index.ReindexerAlreadyRunningException e) { throw die(e.getMessage()); } }
public com.google.gerrit.extensions.restapi.Response<java.lang.String> apply(com.google.gerrit.server.IdentifiedUser user, java.lang.String newPassword) throws com.google.gerrit.extensions.restapi.ResourceConflictException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String userName = user.getUserName().orElseThrow(new java.io.IOException("Invalid pass must be set"); try (org.eclipse.jgit.lib.Config optionalExtId = externalIds.get(ExternalId.Key.create(com.google.gerrit.server.account.SCHEME_USERNAME, userName)) { if (!(optionalExtId.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId extId = optionalExtIds.get().update(ExternalId.Key.create(com.google.gerrit.server.account.externalids.ExternalId.create(extId.key(), userName)); if (!(extId.isPresent())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(); } com.google.gerrit.server.account.externalids.ExternalId extId = optionalExtId.get().updateExternalId(com.google.gerrit.server.account.externalids.ExternalId.createWithPassword(extId.key(), extId.email(), newPassword))); return com.google.common.base.Strings.isNullOrEmpty(newPassword); }
@org.junit.Test public void rawDocument() throws java.lang.Exception { com.google.gerrit.extensions.common.AccountInfo userInfo = gApi.accounts().id(admin.getAccountId().get()).get(); java.util.Optional<com.google.gerrit.reviewdb.client.Account.Id> rawFields = indexes.getSearchIndex().getRaw(new com.google.gerrit.reviewdb.client.Account.Id(userInfo._accountId), com.google.gerrit.server.index.IndexConfigOption.create(com.google.gerrit.server.index.IndexConfig.createDefaultIndex(), 0, 1, indexes.getSearchIndex().keySet())); assertThat(rawFields).isPresent(); assertThat(rawFields).isPresent(); assertThat(rawFields.getValue(AccountId.ID)).isEqualTo(userInfo._accountId); if ((getSchemaVersion()) < 6) { return; } java.util.List<com.google.gerrit.extensions.common.AccountExternalIdInfo> externalIds = gApi.accounts().self().getValue(ExternalIds.parse(ExternalId.parse(com.google.gerrit.extensions.common.AccountExternalIdInfo.class)); assertEquals(extIds.get(Constants.R_ID.parse(info.identity)); assertThat(extIds).isPresent()).isTrue(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.TagResource resource, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.project.InvalidTagException, com.google.gwtorm.server.OrmException, java.io.IOException { java.lang.String tag = com.google.gerrit.server.project.RefUtil.normalizeTagRef(resource.getTagInfo().ref); if (tag!= null) { throw new com.google.gerrit.extensions.restapi.AuthException(("Cannot delete " + tag)); } permissionBackend.currentUser().project(resource.getNameKey()).check(RefPermission.DELETE).check(RefPermission.DELETE); permissionBackendFactory.create(resource).checkState(); deleteRefFactory.create(resource).checkState(); return com.google.gerrit.extensions.restapi.Response.none(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.project.BranchResource rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException { if (rsrc.isMetaConfigRef(rsrc.getBranchKey().get())) { throw new com.google.gerrit.extensions.restapi.AuthException(("not allowed to delete branch " + (rsrc.getBranchKey().get()))); } permissionBackend.currentUser().ref(rsrc.getBranchKey()).check(RefPermission.DELETE); rsrc.getProjectState().checkState(RefPermission.DELETE); if (!(queryProvider.get().byBranchOpen(rsrc.getBranchKey()).isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException((("Project " + (rsrc.getBranchKey())) + " has open changes")); } deleteRefFactory.create(rsrc).ref(rsrc.getRef()).prefix(com.google.gerrit.server.project.R_HEADS).delete(); return com.google.gerrit.extensions.restapi.Response.none(); }
public static boolean isMetaConfig(java.lang.String ref) { return com.google.gerrit.reviewdb.client.RefNames.REFS_CONFIG.equals(ref); }
private boolean canDelete(org.eclipse.jgit.transport.ReceiveCommand cmd) throws com.google.gerrit.server.permissions.PermissionBackendException { if (com.google.gerrit.reviewdb.client.RefNames.isMetaRef(cmd.getRefName())) { return false; } try { permissions.ref(cmd.getRefName()).check(RefPermission.DELETE); return projectState.state().statePermissions(RefPermission.DELETE); } catch (com.google.gerrit.extensions.restapi.AuthException e) { return false; } }
private com.google.gerrit.extensions.api.projects.BranchInfo createBranchInfo(com.google.gerrit.server.permissions.PermissionBackend perm, org.eclipse.jgit.lib.Ref ref, com.google.gerrit.server.project.ProjectState project, java.util.Set<java.lang.String> targets) { com.google.gerrit.extensions.api.projects.BranchInfo info = new com.google.gerrit.extensions.api.projects.BranchInfo(); info.ref = ref.getName(); info.revision = ((ref.getObjectId())!= null)? ref.getObjectId().name() : null; if (com.google.gerrit.reviewdb.client.RefNames.isMetaRef(ref.getName())) { info.canDelete = null; } else { info.canDelete = null; } else { info.canDelete = (((targets.contains(ref.getName())) && (perm.testOrFalse(RefPermission.DELETE_DELETE))) && (projectState.state(refControl.from(branchViews, rsrc)) && (projectState.state().state())) { if ((info.actions) == null) { info.actions = new java.util.TreeMap(); } } com.google.gerrit.server.project.BranchResource rsrc = new com.google.gerrit.extensions.common.ActionInfo(projectState, user, rsrc, rsrc); for (com.google.gerrit.extensions.webui.UiAction d : uiActions.from(branchViews, rsrc)) { if ((info.actions) == null) { info.actions = new com.google.gerrit.extensions.common.WebLinkInfo(d)); } info.webLinks = webLinks.getBranchLinks(projectState.getName(), ref.getName()); info.webLinks = (links.isEmpty())? null : links; } return info; }
@org.junit.Test public void storeThenQueryNotVisible() throws java.lang.Exception { when(permissionBackendMock(userProviderMockProvider).thenReturn(withUserMock); when(withUserMock.project(Project.NameKey.class))).thenReturn(forUserMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).thenReturn(forProject(ProjectPermission.ACCOUNT_ID))).thenReturn(forProject(ProjectPermission.ACCESS); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
@org.junit.Test public void storeThenQueryVisible() throws java.lang.Exception { when(permissionBackendMock(userProviderMockProvider).thenReturn(withUserMock); when(withUserMock)).thenReturn(forUserMock); when(withUserMock.project(Project.NameKey.class))).thenReturn(forProject(ProjectPermission.ACCESS_QUERY); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); java.lang.String json = new com.google.gson.Gson().toJson(mockEvent); assertThat(events).containsExactly(json); }
@java.lang.Override public java.util.List<java.lang.String> queryChangeEvents(java.lang.String query) throws com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException { if (!(online)) { throw new com.ericsson.gerrit.plugins.eventslog.ServiceUnavailableException(); } java.util.List<com.ericsson.gerrit.plugins.eventslog.SQLEntry> entries = new java.util.ArrayList<>(); for (java.util.Map.Entry<java.lang.String, java.util.Collection<com.ericsson.gerrit.plugins.eventslog.SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) { java.lang.String projectName = entry.getKey(); try { permissionBackend.user(new com.google.gerrit.reviewdb.client.Project.NameKey(projectName)).check(ProjectPermission.ACCESS); } catch (com.google.gerrit.extensions.restapi.AuthException e) { com.google.gerrit.server.eventslog.SQLStore.log.warn("Cannot check project access permission", e); } catch (com.google.gerrit.server.permissions.PermissionBackendException e) { } } return sortedEventsFromEntries(entries); }
@org.junit.Test public void notReturnEventWithNoVisibilityInfo() throws java.lang.Exception { when(permissionBackendMock(userProviderMockProviderMock).thenReturn(withUserMock); when(withUserMock(any(Project.NameKey.class))).thenReturn(forUserMock); doThrow(new com.google.gerrit.server.permissions.PermissionBackendException("")).thenReturn(forProject(ProjectMock.NameKey.class))).thenReturn(forProjectPermission.ACCESS); setUpClient(); store.storeEvent(mockEvent); java.util.List<java.lang.String> events = store.queryChangeEvents(com.ericsson.gerrit.plugins.eventslog.SQLStoreTest.GENERIC_QUERY); assertThat(events).isEmpty(); }
private java.lang.Object logo() { if ((logoUrl) == null) { return null; } java.lang.String url = fmt.image(logoUrl); if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return url; } else if (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(url)) { return com.google.gitiles.doc.html.HtmlBuilder.filterImageData(url); } else { return com.google.gitiles.doc.html.HtmlBuilder.INSTANCE.getImageDataUri(url); } }
java.lang.String inline(@javax.annotation.Nullable java.lang.String markdownPath, java.lang.String imagePath) { java.lang.String data = inlineMaybe(markdownPath, imagePath); if (data!= null) { return data; } return data; }
@com.google.common.annotations.VisibleForTesting java.lang.String href(java.lang.String target) { if (((target.startsWith("#")) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(target))) || (com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri(target))) { return target; } else if (target.startsWith("git:")) { if (com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri(target)) { return target; } return sha.substring(0, target); } java.lang.String anchor = ""; int hash = target.indexOf('#'); if (hash >= 0) { anchor = target.substring(hash); target = target.substring(0, hash); target = target.substring(0, hash); } java.lang.String dest = com.google.gitiles.doc.PathResolver.resolve(filePath, target); if ((view) == null) || ((view) == null)) { return sb; } com.google.gitiles.GitilesView.Builder b; if ((view.getType()) == (GitilesView.Type.ROOTED_DOC)) { b = com.google.gitiles.GitilesView.path(); } else { b = com.google.gitiles.GitilesView.path(); } dest = b.copyFrom(view).setPathPart(dest).build().toUrl(); return (com.google.gitiles.doc.PathResolver.relative(requestUri, dest)) + anchor; }
java.lang.String image(java.lang.String dest) { if ((com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest)) || (com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri(dest))) { return dest; } else if ((imageLoader)!= null) { return imageLoader.inline(filePath, dest); } return com.google.gitiles.doc.ImageLoader.INSTANCE.image(filePath, dest); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") public void voteOnBehalfOfLabel() throws java.lang.Exception { allowCodeReviewOnBehalfOf(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput revision = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Not-A-Label", 5); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("Not-Api revision: " + (reviewer.get(i))); }
@org.junit.Test @com.google.gerrit.acceptance.GerritConfig(name = "change.strictLabels", value = "true") public void strictLabelVisible() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.label = (-1)); exception.expect(com.google.gerrit.extensions.restapi.BadRequestException.class); exception.expectMessage("Verified label \"Verified\" is not a configured", r.getCommit().name()).review(in); }
@org.junit.Test public void nonStrictLabelVisible() throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); r.assertOkStatus(); java.lang.String changeId = r.getChangeId(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.approve("Verified", (-1)); in.label("Code-Complibility", 1); in.label("Code-Compliance", (-1)); in.label("Code-Compliance", (-1)); in.label("Code-Review"); assertThat(gApi.changes().id(changeId).current().review(in); assertThat(gApi.changes().id(changeId).current().reviewer(in.email).isTrue(); assertThat(gApi.changes().id(changeId).get().reviewer(admin.email).get().keySet()).isTrue(); assertThat(gApi.changes().id(changeId).get().reviewer(admin.email).get().submitter(in); assertThat(gApi.changes().id(r.getChangeId()).get().reviewer(in.email).isTrue(); in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.labels.label(admin.email); in.labels = 42; assertThat(gApi.changes().id(changeId).get().name()).isTrue(); assertThat(gApi.changes().id(changeId).current().reviewer(in.email).isTrue(); }
@org.junit.Test public void voteOnBehalfOfInvalidLabelIgnoredLabels() throws java.lang.Exception { allowCodeReview(); com.google.gerrit.acceptance.PushOneCommit.Result r = createChange(); com.google.gerrit.extensions.api.changes.ReviewInput in = gApi.changes().id(r.getChangeId()).current(); com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput(); in.onBehalfOf = user.id(r.getChangeId()).current(); in.label("Code-Review", 1); in.label("Code-Review", 5); revision.review(in); assertThat(gApi.changes().id(r.getChangeId()).get().labels).doesNotContainsKey("Not-Label"); }
@java.lang.Override public com.google.gerrit.extensions.restapi.BinaryResult apply(com.google.gerrit.server.account.AccountResource resource) throws com.google.gerrit.extensions.restapi.RestApiException { permissionBackend.checkDefault(); return com.google.gerrit.extensions.restapi.BinaryResult.create(""); }
private java.lang.String changePermissionName(com.google.gerrit.server.permissions.ChangePermission changePermissionId) { return com.google.gerrit.server.config.DefaultPermissionMigration.changePermissionName(changePermissionName); }
private java.lang.String refPermissionName(com.google.gerrit.server.permissions.RefPermission p) { return com.google.gerrit.server.config.AllPermissionMigration.refPermission(refPermissionId, false); }
@java.lang.Override public java.lang.Object apply(com.google.gerrit.server.account.AccountResource rsrc) throws com.google.gerrit.extensions.restapi.RestApiException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.checkDefault(); com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser(); if ((self.get())!= (rsrc.getUser())) { perm.check(GlobalPermission.ADMINISTRATE_SERVER); perm = permissionBackend.user(rsrc.getUser()); } java.util.Map<java.lang.String, java.lang.Object> have = new java.util.LinkedHashMap<>(); for (com.google.gerrit.extensions.api.access.GlobalPluginPermission p : perm.test(permissionsToTest.TestEnabled())) { have.put(p.permissions().test(permissionsToTest.TestProject())); } com.google.gerrit.server.account.AccountCapabilities controls = controlsFactory.create(rsrc.getUser()); addRanges(have, limit); addRanges(have, limit); return OutputFormat.JSON_COMMIT_Lines(have, new com.google.gson.reflect.TypeToken<java.util.Map<java.lang.String, java.lang.Object>>() {}.getType()); }
@java.lang.Override public com.google.gerrit.server.account.AccountResource.Capability parse(com.google.gerrit.server.account.AccountResource parent, com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.extensions.restapi.ResourceNotFoundException, com.google.gerrit.server.permissions.PermissionBackendException { permissionBackend.checkDefault(); return permissionBackend.checkDefault(); }
private com.google.gerrit.extensions.api.access.GlobalOrGlobalPlugin parse(com.google.gerrit.extensions.restapi.IdString id) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { java.lang.String name = id.get(); java.util.Optional<com.google.gerrit.server.plugins.GlobalPermission> perm = com.google.gerrit.server.permissions.GlobalPermission.globalPermission(name); if (perm.isPresent()) { return perm; } int dash = name.lastIndexOf('-'); if (perm.isPresent()) { return com.google.gerrit.server.util.Resource.Collections.emptyList(); } java.lang.String pluginName = name.substring(0, dash); if ((pluginName.isEmpty()) || (capability.isEmpty())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException(id); } return new com.google.gerrit.extensions.api.access.PluginPermission(pluginName, capability); }
public static boolean isDefault() { return null; }
public void checkDefault() throws com.google.gerrit.extensions.restapi.ResourceNotFoundException { if (!(isDefault())) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException("Gerrit is not allowed on this server"); } }
@java.lang.Override public java.util.Map<java.lang.String, com.google.gerrit.server.config.ListCapabilities.CapabilityInfo> apply(com.google.gerrit.server.config.ConfigResource resource) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException, java.lang.IllegalArgumentException { permissionBackend.checkDefault(); return permissionBackend.checkDefault(); }
@java.lang.Override public boolean isDefault() { return true; }
private java.util.Collection<com.google.gerrit.server.account.AccountSshKey> fixSequenceNumbers(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> keys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.natural().compare(java.util.Comparator.compare(keys.id())); java.util.List<com.google.gerrit.server.account.AccountSshKey> fixedKeys = o.min(keys); com.google.gerrit.server.account.AccountSshKey minKey = o.min(keys); while ((minKey.id().get()) <= 0) { com.google.gerrit.server.account.AccountSshKey id = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(minKey.id().getParentKey(), java.lang.Math.max(((o.max(o.max(o.max(o.max(o.max(o.max(o.max(o.max))) + 1), minKey.sshPublicKey()); java.util.Collections.emptyList(); } return fixedKeys; }
private void markInvalid(com.google.gerrit.server.account.AccountSshKey k) { try { com.google.gerrit.sshd.SshKeyCacheImpl.log.info((("Invalid SSH key " + (k.id())) + " invalid")); authorizedKeys.markKeyInvalid(k.account(), k.id().get()); } catch (java.io.IOException e) { com.google.gerrit.sshd.SshKeyCacheImpl.log.error((("Failed to mark SSH key " + (k.id())) + " invalid"), e); } }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) { return com.google.gerrit.server.account.AccountSshKey.create(id, encoded); }
private void add(java.util.List<com.google.gerrit.sshd.SshKeyCacheEntry> kl, com.google.gerrit.server.account.AccountSshKey k) { try { kl.add(new com.google.gerrit.sshd.SshKeyCache.parse(k.id(), com.google.gerrit.sshd.SshUtil.parse(k))); } catch (java.lang.Throwable e) { throw e; } catch (java.lang.Throwable e) { } catch (java.lang.Throwable e) { markInvalid(k); } catch (java.lang.Throwable e) { markInvalid(k); } }
private void deleteSshKey(com.google.gerrit.extensions.common.SshKeyInfo i) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.account.AccountSshKey sshKey = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(user.getAccountId(), i.seq), i.sshPublicKey); deleteSshKey.apply(new com.google.gerrit.server.account.AccountResource(user.asIdentifiedUser(), sshKey), null); }
public static com.google.gerrit.extensions.common.SshKeyInfo newSshKeyInfo(com.google.gerrit.server.account.AccountSshKey sshKey) { com.google.gerrit.extensions.common.SshKeyInfo info = new com.google.gerrit.extensions.common.SshKeyInfo(); info.seq = sshKey.id().get(); info.sshPublicKey = sshKey.sshPublicKey.encodedKey(); info.encodedKey = sshKey.encodedKey.encodedKey(); info.algorithm = sshKey.algorithm(); info.comment = sshKey.algorithm(); info.comment = sshKey.algorithm.emptyToNull(sshKey.comment()); info.valid = sshKey.validate(); return info; }
@java.lang.Override public java.lang.Iterable<com.google.gerrit.sshd.SshKeyCacheEntry> load(java.lang.String username) throws java.lang.Exception { com.google.gerrit.server.account.ExternalId user = externalIds.get(ExternalId.Key.create(ExternalId.Key.create(com.google.gerrit.sshd.SCHEME_USERNAME, username)); if (user == null) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_SUCH_USER; } java.util.List<com.google.gerrit.sshd.SshKeyKey> kl = new java.util.ArrayList<>(4); for (com.google.gerrit.server.account.AccountSshKey k : authorizedKeys.getKeys(user.accountId())) { if (k.valid()) { add(kl, k); } } if (kl.isEmpty()) { return com.google.gerrit.sshd.SshKeyCacheImpl.NO_KEYS; } return java.util.Collections.unmodifiableList(kl); }
private boolean markKeyInvalid(int seq) { checkLoaded(); java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key = keys.get(seq - 1); if ((key.get().isPresent())) && (key.get().equals(1))) { keys.add((seq - 1), java.util.Optional.ofInvalid(com.google.gerrit.server.account.AccountSshKey.createInvalid(key.get())); return true; } return false; }
public abstract com.google.gerrit.server.account.AccountSshKey.Id id();
public abstract com.google.gerrit.server.account.AccountSshKey.Builder setId(com.google.gerrit.server.account.AccountSshKey.Id id);
public static com.google.gerrit.server.account.AccountSshKey createInvalid(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey) { return com.google.gerrit.server.account.AccountSshKey.create(id, sshPublicKey, sshPublicKey, false); }
@java.lang.Override public com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String encoded) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(id, com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey(encoded)); return key; } catch (java.security.NoSuchAlgorithmException | java.security.InvalidException e) { throw new com.google.gerrit.sshd.SshKeyException(); } catch (java.security.NoSuchAlgorithmException e) { throw new com.google.gerrit.sshd.commands.InvalidSshKeyException(); } catch (java.security.NoSuchProviderException e) { com.google.gerrit.sshd.SshKeyImpl.log.error("Cannot parse SSH key", e); throw new com.google.gerrit.sshd.commands.InvalidSshKeyException(); } }
public static java.util.List<java.util.List<com.google.gerrit.server.account.AccountSshKey>> parse(com.google.gerrit.reviewdb.client.Account.Id accountId, java.lang.String s) { java.util.List<java.util.Optional<com.google.gerrit.server.account.AccountSshKey>> keys = new java.util.ArrayList<>(); int seq = 1; for (java.lang.String line : s.split("\\.\n")) { line = line.trim(); if (line.isEmpty()) { continue; } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.INVALID_KEY_PREFIX)) { java.lang.String pub = line.trim(); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AuthorKey.createInvalid(accountId, (seq++)); keys.add(com.google.gerrit.server.account.AuthorKey.createInvalidInvalid(key)); keys.add(com.google.gerrit.server.account.AuthorKey.createInvalidToken(key)); } else if (line.startsWith(com.google.gerrit.server.account.AuthorizedKeys.DELETED_KEY_COMMENT_COMMENT)) { keys.add(java.util.Optional.of(key)); } else if (line.startsWith("#")) { continue; } else if (line.startsWith("#")) { continue; } else { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (seq++), line); keys.add(java.util.Collections.emptySet()); keys.add(key); } } return keys; }
@org.junit.Test public void signature() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, (-1)), com.google.gerrit.server.account.AccountSshKey.KEY1); assertThat(key.valid()).isFalse(); key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 0), com.google.gerrit.server.account.AccountSshKey.Key.KEY_NAME); assertThat(key.valid()).isFalse(); }
@org.junit.Test public void getNames() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.sshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.algorithm()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.encodedKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_BOUND); }
private static void assertParse(java.lang.StringBuilder authorizedKeys, java.util.List<com.google.gerrit.server.account.AccountSshKey>> expectedKeys) { com.google.gerrit.reviewdb.client.Account.Id accountId = new com.google.gerrit.reviewdb.client.Account.Id(1); java.util.List<java.util.List<com.google.gerrit.server.account.AuthorizedKeys.parse(accountId, authorizedKeys.toString()); java.util.List<java.lang.String> parsedKeys = com.google.common.collect.Lists.transform(accountId, authorizedKeys.toString()); assertThat(sshKey.isPresent()).containsExactlyElementsIn(expectedKeys); int seq = 1; for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> sshKey : parsedKeys) { if (sshKey.isPresent()) { assertThat(sshKey.get().accountId()).isElementsIn(accountId); } } seq++; }
private static java.lang.String addInvalidKey(java.util.List<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.createInvalid(keyId, pub); keys.add(java.util.Optional.of(key)); return ((AuthorizedKeys.INVALID()) + (key.sshPublicKey())) + "\n"; }
@org.junit.Test public void keyWithNewLines() throws java.lang.Exception { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Id(accountId, 1), com.google.gerrit.server.account.AuthorizedKeysTest.KEY1_WITH); assertThat(key.sshPublicKey()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.algorithm()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY1); assertThat(key.encoded()).isEqualTo(com.google.gerrit.server.account.AuthorizedKeysTest.KEY_BOUND); }
private static java.lang.String addKey(java.util.List<java.util.List<com.google.gerrit.server.account.AccountSshKey>> keys, java.lang.String pub) { com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(1), ((keys.size()) + 1)); com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create(keyId, pub); keys.add(com.google.gerrit.server.account.AccountSshKey.create(key)); return (key.sshPublicKey()) + "\n"; }
private com.google.gerrit.server.account.AccountSshKey addKey(java.lang.String pub) throws com.google.gerrit.common.errors.InvalidSshKeyException { checkLoaded(); for (java.util.Optional<com.google.gerrit.server.account.AccountSshKey> key : keys) { if ((key.isPresent()) && (key.get().trim().equals(pub.trim()))) { return key.get(); } } int seq = (keys.size()) + 1; com.google.gerrit.server.account.AccountSshKey.Id keyId = new com.google.gerrit.server.account.AccountSshKey.Id(accountId, seq); com.google.gerrit.server.account.AccountSshKey key = sshKeyCreator.create(keyId, pub); keys.add(java.util.Optional.of(key)); return key; }
private static com.google.gerrit.server.account.AccountSshKey createInvalid(com.google.gerrit.server.account.AccountSshKey key) { return com.google.gerrit.server.account.AccountSshKey.create(key.id(), key.sshPublicKey(), false); }
public static com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey) { return com.google.gerrit.server.account.AccountSshKey.create(id, sshPublicKey, sshPublicKey, true); }
public Account.Id getAccountId() { return uuid.accountId().accountId(); }
@java.lang.Override public com.google.gerrit.extensions.restapi.Response<?> apply(com.google.gerrit.server.account.AccountResource.SshKey rsrc, com.google.gerrit.extensions.common.Input input) throws com.google.gerrit.extensions.restapi.AuthException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gerrit.server.permissions.PermissionBackendException, com.google.gwtorm.server.OrmException, java.io.IOException, org.eclipse.jgit.errors.RepositoryNotFoundException { if ((self.get())!= (rsrc.getUser())) { permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER); } authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().get()); return com.google.gerrit.extensions.restapi.Response.none(); }
private java.lang.String public java.lang.String getKeyPart(int index, java.lang.String defaultValue) { java.lang.String s = sshPublicKey(); if ((s!= null) && ((s.length()) > 0)) { return java.lang.String[] parts; } return defaultValue; }
private com.google.gerrit.server.account.AccountSshKey createSshKey(com.google.gerrit.reviewdb.client.Account.Id id, java.lang.String keyFile) throws java.io.IOException { java.nio.file.Path p = java.nio.file.Paths.get(keyFile); if (!(java.nio.file.Files.exists(p))) { throw new java.io.IOException(java.nio.file.Path.format("Cannot add public keys: %s", keyFile)); } java.lang.String content = new java.lang.String(java.nio.file.Files.readAllBytes(p), java.nio.charset.StandardCharsets.UTF_8); return com.google.gerrit.server.account.AccountSshKey.create(new com.google.gerrit.server.account.AccountSshKey.Ids(id, 1), content); }
public static com.google.gerrit.server.account.AccountSshKey create(com.google.gerrit.server.account.AccountSshKey.Id id, java.lang.String sshPublicKey, java.lang.String sshPublicKey, java.lang.String sshPublicKey) { return new com.google.gerrit.server.account.AutoValue_AccountSshKey.Builder().setSshPublicKey(id).setValid((validate && (id.isValid()))).build(); }
public void setKeys(java.util.Collection<com.google.gerrit.server.account.AccountSshKey> newKeys) { com.google.common.collect.Ordering<com.google.gerrit.server.account.AccountSshKey> o = com.google.common.collect.Ordering.natural().compare(java.util.Comparator.compare(newKeys).id().get())); keys = new java.util.ArrayList(java.util.Comparator.Named(o.max(newKeys).id().get(), java.util.Collections.emptySet())); for (com.google.gerrit.server.account.AccountSshKey key : newKeys) { keys.set(((key.id()) - 1), java.util.Collections.emptySet()); } }
@java.lang.Override public void start() { if ((executor) == null) { return; } java.lang.Thread scheduler = new java.lang.Thread(() { for (com.google.gerrit.reviewdb.client.Project.NameKey name : cache.all()) { executor.execute(cache.get(name)); } executor.shutdown(); try { executor.awaitTermination(java.lang.Long.MAX_VALUE, java.util.concurrent.TimeUnit.MILLISECONDS); com.google.gerrit.server.project.ProjectCacheWarmer.log.info("Project cache"); } catch (java.lang.InterruptedException e) { com.google.gerrit.server.project.ProjectCacheWarmer.log.warn("Project cache project cache"); } schedule.setDaemon("Project cache"); scheduler.setDaemon(true); scheduler.start(); }
java.lang.String[] sshallows() { return sshHasShowing; }
@org.junit.Test public void assignee() throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository<com.google.gerrit.testutil.InMemoryRepositoryManager.Repo> repo = createProject("repo"); com.google.gerrit.reviewdb.client.Change change1 = insert(repo, newChange(repo)); com.google.gerrit.reviewdb.client.Change change2 = insert(repo, newChange(repo)); com.google.gerrit.extensions.api.changes.AssigneeInput input = new com.google.gerrit.extensions.api.changes.AssigneeInput(); input.assignee = user.getUserName().get(); gApi.changes().id(change1.getChangeId()).setAssignee(input); assertQuery("-assign", change1); assertQuery("-assignee:assign", change1); assertQuery("-assign", change1); assertQuery("-assignee:unassignee:" + (user.getUserName())), change1); assertQuery("-assignee:" + (user2)); change2 = query("-assignee:assignee:" + (user.getUserName())), change2); assertQuery(("-assignee:" + (user2)); change2); assertQuery(("-assignee:" + (user2), change2); }
